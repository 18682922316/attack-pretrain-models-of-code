{"id1": "8266672", "id2": "2198730", "code1": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"updatePicInfo": [" updatePictureData", " updatePictureObj", "updatePanObj", " updatePicObj", "updateImageObj", " updatePicData", "updatePicInf", "updateImageInfo", "updatePictureInf", "updatePictureObj", "updatePictureData", "updatePicObj", "updatePanInfo", "updateImageInf", "updatePanData", "updatePicData", "updatePictureInfo", " updatePicInf", "updateImageData", "updatePanInf", " updatePictureInf", " updatePictureInfo"], "conn": ["ch", "priv", "nc", "connect", "db", "on", "con", "cell", "addr", "close", "init", "n", "config", "org", "open", "pkg", "sys", "gate", "handle", "connection", "pg", "ct", "iw", "rel", "pool", "enc", "wp", "irm", "subject", "conv", "pas", "resp", "client", "win", "adj", "nt", "cmp", "fail", "js", "ns", "req", "ait", "cp", "cb", "comm", "coll", "dc", "obj", "exec", "err", "gc", "wn", "yn", "ctx", "cn", "stat", "cc", "ann", "co", "info", "cert", "admin", "jp", "apt", "query", "cmd", "act", "conf", "ca", "Conn", "c", "cur"], "nr": ["wr", "gr", "out", "attr", "nar", "notice", "rar", "n", "nb", "ln", "org", "occup", "sys", "rid", "cor", "reviewed", "Num", "nm", "root", "nick", "rel", "inv", "num", "np", "hr", "conv", "kid", "radius", "ns", "nor", "inner", "nu", "src", "ni", "next", "req", "store", "nv", "number", "nw", "stock", "mr", "nir", "tn", "nn", "sn", "ner", "ne", "iter", "nit", "rn", "adr", "NR", "range", "info", "blocks", "kr", "r", "wire", "ng", "rb", "nie"], "lock": ["nil", "ite", "or", "block", "prime", "ln", "sync", "ock", "locks", "type", "link", "ck", "Lock", "id", "p", "pin", "pen", "locked", "row", "fp", "size", "num", " unlock", "th", "locking", "length", "le", "key", "box", "ld", "l", "k", "kl", "limit", "ne", "rl", "wl", "sp", "handle", "LOCK", "zip"], "picInfo": ["piExt", "pnginfo", "pixelFi", "pinTier", "featInfo", " picFi", "icINFO", "pinDef", "PicDef", "statFi", "PicInf", "specDiff", "featINFO", "styleInf", "pInfo", "icDiff", "pickINFO", "icObj", "specINFO", "camINFO", "picAuth", "pictinfo", "picINFO", "picEx", "picFi", "camObj", "pixelINFO", " picDef", "picinfo", "synType", "picDiff", "PicINFO", "pinInf", "piInfo", " picType", "styleINFO", " picInf", "pngINFO", "specExt", "pngAuth", "synData", "featinfo", "pickInf", " picDiff", "icInfo", "statInfo", "pictAuth", "styleDef", "statInf", "pictInfo", "picExt", "icType", "icInf", "piInf", "pInf", "pickType", " picINFO", "icDef", "pinObj", "picInf", "pinEx", "icEx", "synInfo", "PicInfo", "camEx", "picType", "pDef", "pINFO", "picAbout", "featAuth", "pinINFO", "PicType", "pinDiff", "statINFO", "picObj", "piINFO", "specInfo", "icAbout", "pngInfo", "pinAbout", "piAbout", "pixelInf", "icTier", "pinInfo", "picData", "pixelInfo", "picDef", "camInfo", " picData", "pictINFO", "synINFO", "picTier", "styleInfo", " picTier", "icData", " picExt", "piDiff", "pickInfo"], "sql": ["series", "expression", "plan", " msg", "mail", "json", "html", "description", "lex", " SQL", "sleep", "ms", "sl", "ln", "links", "lua", "template", "pel", "prefix", "msg", "sal", "wal", "sys", "statement", "seed", "shell", "params", "ql", "body", "socket", "rel", "inv", "util", "SQL", "test", "soft", "dl", "ssl", "nl", "login", "spec", "blank", "services", "js", "cloth", "ship", "ns", "sol", "rpm", "ips", "xml", "ll", "l", "joined", "owl", "sn", "string", "expr", "scl", "csv", "log", "software", "spr", "sp", "query", "sv", "format", "eps", "url", "sil", "cmd", "sq", "il"], "pstmt": ["pondm", "pstmr", "pStmem", "opStmt", "prestr", " pstmem", "pstermk", " pstatm", "pstartmm", "pstyst", "fpsttx", "psptim", "pstmb", "psycl", "pspmt", "pstatmu", "phttkl", "Pistmed", "Pstatm", "pstartemb", "wpstm", "psthmat", " psttr", "postmb", "pSTmag", "psetmt", "pesttar", "vpstirm", "psterager", "phttpt", "pconstdt", "pputgr", " pthmt", " pstatem", "psttar", "httpstlet", "pthmm", "httpstatemt", "pconstmm", " pstgr", "prostmb", "pstartcl", "psetmk", "opstmm", "fpstr", "wpstym", "prostemb", "vpputmb", "pconstmb", "pingstm", "prestmm", "pstatMT", "wpstyml", "pstructmr", "httpstmat", "pSttx", "pstirm", "pingstbolt", "pstst", "pSTr", "pStem", "pputem", "pputapter", "httpstkl", "pstartmb", "postgr", "httpstmap", "pputst", "fpstalr", "opstmt", " pstmat", "httpstatelem", "pconstolt", " pstattr", "Pstatql", "pstrmt", "ptrymap", "psettmat", "pstatelem", "httpstatemap", "pstalmm", "pstallt", "pstalmem", "pingstmr", " pstatgr", "pstmk", "pstamk", "pSTmat", "pSttar", "psttr", "pstalmt", "pstarttar", "prrestmt", "pconstgr", "Pstmed", "prestmt", "pscem", "pingstructbolt", "fpstalmem", " pstem", "pStm", "pstatml", "pstom", "pstatmag", "pstatmm", "vpstmt", "pstapter", "fpstalmt", "ptrylet", " pstatmat", "psthkl", "pstatpt", "pstgr", "psetdt", "Pstatil", "peputtar", "pstrm", "psthmu", "pconstirm", "pstpt", "httpstmt", "pestapter", "pStr", "ptrymt", "Pstmu", "pingstructm", "psttx", "wpstml", "pstatmt", "prostartmt", "prstem", "httphttmat", " pstattx", "pstatdt", "pStmt", "pstattim", "pstym", "pstem", "prstmt", "pstructm", "pstalr", "pftmn", "psymm", "pstaolt", "pstr", "pstamt", " pstcl", "prestm", " pstatmk", "Pstm", "Pstmt", "pSTmt", "pstattr", "httpstlem", "psymt", "pstatbolt", "pSTmap", "psettmt", "Pstil", "opStmm", "pStapter", " pthcl", "pstemb", "pistmed", "Pistmu", "vpputgr", "pstartth", "Pstmr", "psettmem", " psttx", "pstrql", "pstatemt", "pconstmk", "pscmt", "pstlem", "phttmt", "prostartst", "pstyml", "pSTmem", "psettmag", "ptrylem", " pstatmem", " pstmag", "pstatager", "pstatmn", "pstattx", "pstm", "pconstmt", "wpstytim", "pestem", "httphttkl", " pthth", "pputbolt", "phttmat", "pstamm", "prrestem", "pstalkl", "pstatr", "psthmt", "pstmag", "pestmt", "pstatmr", "pstytim", "pstmn", "pstmed", "pistm", "pstartmt", "pputemb", "pstymb", "vpstmb", "pputirm", "pstMT", "Pstql", "pputmr", "pstml", "pstatmk", "psetager", "Pstdt", "pstartapter", "phttmn", "pthem", " pstatager", "pstatmed", "httpstlt", "pputtar", "pondmr", "peputapter", "psyth", "pstth", "pstql", "pstymt", "vpstgr", "phttom", "pondql", "pstructbolt", "psthm", "prrestm", " pstmn", "pistmu", "pstergr", "pthtr", "pSTtx", "pscm", " pstmm", "Pistm", "pSTlem", " pstatpt", "pstalmat", "pscirm", "postmt", "Pstatdt", "phttlt", "prestmk", "pstartst", " pstth", "prostmt", "pthtx", "psthmed", " pthmm", "pstmu", " pstatmn", "pstbolt", "pconstil", "pSTlet", " pstatmt", "prostartmb", "httphttmt", "pStMT", "pconstm", "vpputmt", " pstm", "pstrmr", "pstcl", "pstatgr", "prostst", "pstermt", "pstaltx", "prostartemb", "pstatom", " pstager", "pthm", "pstatem", "pstructmt", "presttx", "pstatelet", "pondmt", "fpstmt", "pftom", "pstatil", "pstatm", "fpstmem", "pputmb", "prestem", "opStMT", "pputm", "pstatirm", "prestolt", "pthmt", "httphttlt", "pstmm", "prestirm", "pspm", "pstager", "pstmap", "pstatql", "fpstaltx", "pstlet", "pthr", "postirm", "pStmm", "pstatemap", "pstatmat", "peputmt", "pthcl", "pstalMT", "peputem", "pstdt", "wpstmt", "prstirm", "Pstatmr", "Pistmt", " pstr", "pingstructmr", " pstpt", "pistmt", "pingstmt", "pstyemb", "pthth", "pstlt", "psetm", "Pstatmt", "pSttr", "psttim", "pftmt", " pstom", "pstolt", "pstmat", "wpsttim", "pstil", "pspml", "prrestirm", "prstm", "pftpt", "vpputirm", " pstatom", "psthlt", "pstmem", "psetil", "pstkl", " pstatr", "pingstructmt", "opstMT", " pstmk", " pstatmag", "psetgr", "httpstatelet", "wpstymt", "pputmt", "pstatmem", "pstartem"]}}
{"id1": "804637", "id2": "5808579", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "18891988", "id2": "21016435", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"getFile": ["selectfile", "getFilename", "createFilename", "GetFile", "selectFilename", "createString", "GetString", "createFile", "getfile", "createfile", "GetFilename", "getString", "selectFile", "Getfile", "selectString"], "serviceName": [" serviceCode", "libraryName", "ServiceFamily", "libraryType", "serverCode", "ServiceType", "serviceType", "serverType", "libraryFamily", "serviceCode", "serviceNames", "ServiceName", " serviceFamily", "ServiceNames", "ServiceCode", "libraryNames", "serviceFamily", "serverName", " serviceType", " serviceNames"], "wsdlLocation": ["wslLocation", "wlLoc", "awsdlURL", "wslLoc", "wssdFolder", "wslFolder", "wssdlocation", "awsdlocation", "wsdLoc", "wsDLlocation", "wsdllocation", "wsDLPath", "wsdlURL", "wsdLocation", "wsDLLoc", "wsDLFolder", "wsollocation", "wlFolder", "awsdllocation", "wsdURL", "wdlLocation", "wlPath", "wsolLoc", "awsdlLocation", "awsdlLoc", "wsolLocation", "wsDLURL", "wssdPath", "wssdLocation", "awsolLocation", "wsdlPath", "wsdlocation", "wsDLLocation", "wsdlFolder", "awsdURL", "wdlLoc", "awsolURL", "awsdLocation", "awsollocation", "wdlFolder", "wdlPath", "wlLocation", "wslPath", "wsdlLoc", "awsdLoc", "wssdLoc", "wsolURL", "wssdURL", "awsolLoc"], "endpoint": ["endword", "bindport", "startPoint", "idpoints", "bindpoints", "bindpoint", "endPoint", "Endpoint", "startpoints", "beginPoint", " endpoints", "beginword", "bindPoint", " endline", "idPoint", " endport", "Endpoints", "EndPoint", "beginpoint", "startword", "Endport", "startpoint", "idpoint", "Endword", "startline", "endport", "endline", " endPoint", "endpoints", "beginpoints", "idline"], "fileLocation": ["FileLoc", "Filelocation", "FileLocation", "fileLoc", "filePosition", " fileLoc", " filelocation", "documentLoc", " filePosition", "documentPosition", "filelocation", "FilePosition", "documentLocation", "documentlocation"], "tempDir": ["tmpUrl", "TempUrl", "TempPath", "TempDir", "tempDirectory", "tmpDirectory", "tmpdir", "tmpPath", " tempFolder", "tmpFolder", "tempPath", " tempdir", " tempUrl", "tempFolder", "TempDirectory", "TempFolder", " tempDirectory", "tmpDir", "tempUrl", "Tempdir", " tempPath", "tempdir"], "url": ["http", "mail", "ls", "window", "location", "sl", "open", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "socket", "URL", "rel", "sur", "pl", "re", "ssl", "uri", "dl", "loc", "nl", "up", "browser", "gl", "cr", "str", "mount", "ll", "cp", "service", "l", "char", "un", "conn", "base", "m", "job", "ctrl", "web", "https", "cert", "r", "li", "github", "il"], "WSDLFile": ["WSDLLFilename", "WSDLString", "WSDQLFile", "WIDDLString", "WHDLfile", "WIDDLType", "WSDDLString", "WIDLFile", "WHDDLFile", "WSDDLFILE", "WNDLFILE", "WSDDLType", "WHDDLfile", "WSDLLString", "WSDLLFILE", "WIDDLFile", "WNDLFile", "WSDDLFile", "WNDDLfile", "WSDLLType", "WHDDLFILE", "WSDELfile", "WSDLSFile", "WNDLFilename", "WIDLType", "WIDLString", "WSDQLfile", "WIDLfile", "WNDDLFILE", "WSDLLfile", "WSDMLfile", "WSDQLFILE", "WSDMLFILE", "WSDLLFile", "WSDMLFile", "WSDELFILE", "WNDLfile", "WSDLSType", "WSDLSString", "WSDLFILE", "WSDLType", "WSDLSfile", "WSDDLfile", "WHDLFILE", "WSDLFilename", "WSDLfile", "WSDELFile", "WNDDLFilename", "WSDDLFilename", "WHDLFile", "WIDDLfile", "WNDDLFile", "WSDELFilename"], "tmpWSDLFile": ["tmpWSDDLFiles", "tmpWSDlFile", "tmpWSDLDFilename", "tmpWIDDLFILE", "tmpWNDDLFilename", "tmpWSDLDFILE", "tmpWIDDLfile", "tmpWSDLLFilename", "tmpWSDLLFiles", "tmpWNDDLfile", "tmpWNDDLFiles", "tmpWSDlFiles", "tmpWSDlfile", "tmpWSDLFiles", "tmpWNDDLFile", "tmpWNDLFile", "tmpWSDlFilename", "tmpWIDDLFilename", "tmpWSDLLFILE", "tmpWNDLFiles", "tmpWSDLDFile", "tmpWSDDLFILE", "tmpWSDLDfile", "tmpWIDLfile", "tmpWSDLLfile", "tmpWIDDLFile", "tmpWSDLFilename", "tmpWSDDLFilename", "tmpWIDLFILE", "tmpWSDDLFile", "tmpWNDLFilename", "tmpWIDLFilename", "tmpWNDLfile", "tmpWSDLLFile", "tmpWIDLFile", "tmpWSDLFILE", "tmpWSDLfile", "tmpWSDDLfile"], "inputFile": ["inputPlace", "InputStream", "inputPath", "indexFILE", "indexStream", "intFiles", "inputSourceFile", "tmpFILE", "inputFILE", "outputFILE", "clientPath", "outputFile", "clientFiles", " inputfile", "indexfile", "errorFile", "tmpSourceFile", " inputPlace", "interfacePlace", "errorfile", "outputfile", "Inputfile", " inputFILE", "inputStream", "interfaceSourceFile", "InputFiles", "tmpStream", "clientFile", "intFILE", "inputFiles", "infile", "inputDo", "clientFILE", " inputFiles", "intfile", "errorFILE", " inputDo", "intFile", "tmpPlace", "inDo", "indexFile", "inFile", "interfaceFile", "inPath", " inputPath", "InputFile", "interfacefile", "tmpfile", " inputSourceFile", "InputPath", "InputDo", "errorStream", "InputFILE", "outputStream", "inputfile"], "tmpFile": ["tmpFILE", "inputFILE", "empFilename", "tmpFiles", "mpFile", " tmpPath", "empFILE", "mpfile", " tmpfile", "tmpPath", "tempFiles", "tempFILE", "tempPath", "mpFiles", "inputFilename", "empFile", "mpPath", "tempFile", "tempFilename", " tmpFiles", "empfile", "tmpFilename", "tmpfile", "tempfile", "inputfile"], "in": ["ch", "IN", "din", "init", "ln", "n", "it", "rin", "ri", "ai", "is", "ic", "ini", "sin", "ain", "id", "o", "inv", "en", "inc", "io", "from", "mi", "ind", "ins", "t", "client", "ar", "bin", "inner", "stream", "isin", "r", "In", "cont", "conn", "input", "source", "file", "inn", "inf", "c", "cin"], "out": ["output", "ch", "buffer", "on", "by", "n", "auto", "Out", "sys", "tmp", "connection", "can", "pool", "o", "inv", "to", "os", "en", "aos", "io", "OU", "ex", "outs", "t", "client", "conv", "ou", "lock", "cm", "all", "write", "at", "null", "group", "writer", "this", "ao", "w", "obj", "net", "conn", "OUT", "conf", "ne", "file", "log", "oss", "co", "we", "outer", "c", "cache"], "con": ["ch", "fn", "nc", "cos", "connect", "Con", "cone", "const", "cur", "ln", "cal", "exc", "mc", "connection", "acon", "ain", "can", "ws", "num", "re", "conv", "login", "win", "fc", "cm", "tc", "cp", "cons", "sec", "un", "conn", "cn", "CON", "ran", "func", "co", "cf", "com", "conf", "soc", "Conn", "c", "cin"], "fileLength": ["objectSize", "objectFontSize", "channelSize", "objectDuration", "FILESize", "channelLength", "ileLen", "FILELength", "fileDuration", "ileLength", " fileDuration", "fileSize", "FILEDuration", " fileLen", " fileSize", "FILELen", " fileFontSize", "fileLen", "ileDuration", "channelDuration", "fileFontSize", "channelFontSize", "ileSize", "objectLength"], "channelIn": ["channelIN", "chanIn", "consoleIn", "ChannelIn", "clientSet", "channelSet", "Channelin", "consoleedIn", "clientIn", "clientOut", "ChannelIN", "ChannelSet", " channeledIn", "ChanneledIn", "channeledIn", "ChannelOut", "channelin", "consoleOut", "consoleIN", "chanSet", "clientin", "chanIN", "chanOut", "clientIN", " channelIN", " channelin"], "channelOut": ["chanIn", "consoleIn", "ChannelIn", "channelOUT", " channelConn", "ChannelConn", "courseout", "courseOut", "courseOUT", "courseIn", "chanout", "chanConn", "ChannelOut", "consoleOUT", "channelout", "Channelout", "consoleout", "consoleOut", "chanOut", " channelout", "channelConn", " channelOUT", "ChannelOUT"], "tmpDocument": ["tmpDoc", "tpFile", "npDocument", "mkdocument", "npFile", " tmpDocuments", "mpDoc", "npMedia", "tpDocument", "tempDoc", "cpDocument", "tmDoc", "tpMedia", " tmpDoc", "tmDocument", " tmpMedia", "tmpDocuments", "cpDoc", "cpdocument", "tempdocument", " tmpdocument", "mpDocument", "mkDocument", "npDocuments", "mkDoc", "tmpdocument", "tpDocuments", "tmpMedia", "tmdocument", "mpdocument", "tempDocument"], "nl1": ["ln01", "rn6", "NL0", "pelOne", "sol0", "sol1", "nl01", "sol2", "nrOne", "nelOne", "rn3", "nl2", "ln2", "nl3", "pel1", "nel1", "lnOne", "ln6", "nel3", "nl6", "nlOne", "nr1", "sol9", "nr01", "ln3", "nel6", "nl0", "rn1", "pel01", "NL2", "nl9", "ln0", "ln9", "NL1", "ln1", "NL9", "rnOne"], "i": ["multi", "ims", "ms", "x", "j", "n", "init", "it", "ai", "a", "is", "ic", "ini", "ui", "ie", "me", "ri", "id", "y", "o", "io", "mi", "ci", "qi", "ii", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "span", "u", "k", "m", "xi", "cli", "us", "mu", "ami", "ori", "di", "sim", "pi", "info", "ij", "ip", "li", "\u0438", "ix"], "node1": ["Node2", "ode001", "nOne", "node91", "ode2", "component0", "node001", "NodeOne", "component2", "Node1", "layer91", "layer0", " node2", "layerOne", "ode1", "ode0", " node91", "node0", "Node001", " node0", " node001", "componentOne", " nodeOne", "layer1", "n1", "n0", "nodeOne", "node2", "n91", "Node0", "component1"], "tmpOut": ["tmpObj", " tmpIs", "tmpIs", "mpOut", "empIs", "mpout", "TempOUT", "npIn", "mpObj", "cmpIn", "cmpout", "TempIn", "tmpOUT", " tmpObj", "tempout", " tmpIn", "empout", "npout", "mpIn", " tmpOUT", "cmpOut", "TempObj", "tmpout", "tempObj", "tmpIn", "npObj", "tempIn", "tempOUT", "tempIs", "TempOut", "tempOut", "empOut", " tmpout", "npOut"], "retVal": ["retValue", "returnVal", "returnValue", "returnTrue", "returnval", "retval", "RetTrue", "RetValue", "Retval", "retTrue", " retValue", " retval", " retTrue", "RetVal"]}}
{"id1": "20306677", "id2": "12306305", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"update": ["edit", "UPDATE", "Update", "load", "patch", "json", "offset", "add", "save", "init", "replace", "touch", "now", "user", "draw", "build", "change", "database", " Update", "put", "updated", "flush", "send", "latest", "id", "state", "local", "size", "create", "execute", "test", "num", " UPDATE", "use", "login", "op", "current", "up", "oo", "run", "call", "delete", "write", "where", "all", "version", "ask", "index", "get", "upload", "u", "print", "batch", "check", "fill", "set", "push", "status", "date", "value", "match", "find", "query", "out", "insert", "commit", "report"], "o": ["onet", "bo", "n", "iso", "oin", "a", "O", "fo", "b", "ob", "p", "y", "to", "os", "t", "oo", "v", "e", "oa", "ao", "oice", "u", "obj", " mo", "k", "om", "object", "m", "po", "i", " os", "mo", "vo", "oid", "ooo", "out"], "bill": ["bo", "iban", "lex", "kick", "gross", "nb", "book", "money", "bean", "build", "bar", " Bill", "b", "handle", "inv", "bb", "BILL", "pay", "phy", "Bill", "fax", "ship", "ll", " billing", "service", "bank", "quote", "net", "nn", "conn", "trade", "stuff", "batch", "project", "biz", "company", "ann", "work", "vo", "unk", "sk", " billed", "fund", "report"], "pst": [" pct", "apct", " psp", "tpse", "tpST", "tpsp", "cstra", "pstro", "opst", "apsp", "opse", "picstro", "pstra", "pST", "cstro", "picst", "pse", "tpstra", "opct", "pth", " pST", "pkgth", "cth", "tpct", "pkgstro", "opstra", "tpst", "apst", " pse", "picth", "pkgstra", "pkgst", "cst", " pstra", "psp", "apST", "picstra", "pct"]}}
{"id1": "189963", "id2": "21488518", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "13596891", "id2": "23246123", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 1, "substitutes": {"doTransfer": [" doDownload", "doDownload", "handleSend", "DoTransfer", "handleRequest", "handleTransfer", "DoRequest", " doSend", "handleDownload", "doSend", " doRequest", "doRequest", "DoSend", "DoDownload"], "request": ["have", "message", "http", "application", "session", "QUEST", "config", "user", "header", "change", "requ", "connection", "attribute", "address", "reference", "params", "raw", "complete", "reset", "create", "frame", "subject", "re", "use", "client", "resource", "initial", "server", "current", "parent", "setup", "call", "this", "req", "process", "version", "xml", "name", "quest", "get", "position", "result", "record", "remote", "command", "input", "object", "Request", "log", "document", "query", "context", "remove", "in", "report", "order", "question"], "response": ["output", "message", "http", "application", "session", "site", "json", "description", "block", "onse", "connection", "proxy", "send", "body", "reset", "ce", "frame", "default", "answer", "respond", "pos", "resp", "server", "wrapper", "content", "exit", "summary", "write", "this", "version", "next", "view", "service", "one", "position", "respons", "page", "Response", "result", "sequence", "print", "object", "status", "reply", "document", "success", "context", "res", "out", "image", "report"], "method": ["message", "http", "ETHOD", "reason", "timeout", "prefix", "instance", "type", "property", "send", "dir", "num", "subject", "period", "th", "right", "transform", "length", "direction", "call", "verb", "name", "version", "hod", "post", "service", "tr", "other", "form", "mod", "command", "string", "m", "Method", "METHOD", "report", "eth"], "servletContext": ["servletDefinition", "servletEvent", "servLETChain", "servletsContext", "ServletConfig", "ServletsConfig", "ServletsContext", "servLETConfig", "servantComponent", "servantContext", "servLETDefinition", "servlerContext", "servLETComponent", "servLETEvent", "servLETcontext", "servfileContext", "servLETContext", "servlerConfig", " servletComponent", "servletComponent", "servletsConfig", "servfileComponent", "servletcontext", "servlerEvent", " servantcontext", " servantDefinition", "servletsChain", "ServletEvent", " servantComponent", "servletConfig", "ServletChain", "servantcontext", "servantDefinition", "ServletContext", "servfileDefinition", "ServletsEvent", "servlerChain", " servletDefinition", "servfilecontext", "servletsEvent", " servantContext", "ServletsChain", "servletChain", " servletcontext"], "wac": ["wbacs", "wAC", "wbAC", "wacc", "wacs", "wbac", " wacs", " wAC", "bAC", "bac", "bacs", "bacc", " wacc", "wbacc"], "szUrl": [" szPath", "szeURL", " szeLoc", "szUr", "sgzUr", " szeGl", "sldPath", "szeStr", "sizURL", "sldGl", "szeLoc", "sgzUrl", "szPath", "szaURL", "deszPath", "szaUr", "deszUrl", "deszStr", "desgzUrl", "desgzURL", "szarPath", " szeUrl", "szeGl", "sziUr", "szePath", " szePath", "szGl", " szURL", "szLoc", "sizStr", "sgzLoc", "szaUrl", "sizPath", "sizUrl", " szurl", " szLoc", "sldUrl", "szeurl", "sgzURL", "szeUrl", "desgzPath", " szeUr", " szGl", "szStr", "szurl", "sziUrl", " szeURL", " szUr", "desgzStr", "sZurl", "szarUrl", "sZGl", "sldUr", "deszURL", "sgzPath", " szeurl", "szaLoc", "szURL", "szarUr", "sgzStr", "sziGl", "sZUrl", "szarGl", "sZUr", "sziurl", "szeUr"], "url": ["http", "mail", "ls", "location", "ol", "sl", "org", "open", "ret", "build", "bel", "link", "ur", "lb", "ul", "Url", "f", "ml", "address", "ob", "URL", "connection", "socket", "util", "re", "pl", "ssl", "uri", "t", "nl", "loc", "client", "browser", "gl", "ref", "impl", "name", "str", "xml", "ll", "mount", "l", "u", "char", "www", "un", "conn", "gc", "base", "rl", "date", "file", "web", "https", "cert", "host", "prot", "il"], "is": ["ms", "es", "isc", "tis", "iso", "ris", " cis", "ri", "ic", "sys", "ois", "nis", "bis", "bs", "id", "isa", "as", "its", "iss", "os", "cs", "ins", "ii", " bis", "ps", "serv", "si", "Is", "isin", "ir", "ism", "us", "isi", "i", "info", "ios", "sis", "s", "in", "res", "ip", "lis", "IS"], "sout": ["wsj", " sin", "osouth", " sos", "wsos", "osin", "sin", "lsOut", " sOut", " scho", "scho", "wscho", " south", "lsos", "wsout", "lscho", "lsout", "sOut", "lsj", "lsouth", "sos", "lsin", "osOut", "south", "sj", " sj", "osout"], "con": ["http", "ion", "cell", "ln", "config", "change", "connection", "ain", "rc", "num", "re", "syn", "code", "canon", "cp", "cons", "fac", "ctrl", "cf", "com", "dial", "cur", "nc", "const", "on", "cone", "internal", "condition", "util", "create", "cv", "control", "conv", "cm", "apache", "don", "obj", "bc", "un", "conn", "ran", "co", "res", "cmd", "conf", "thin", "cos", "cond", "acon", "can", "pen", "h", "local", "en", "client", "current", "fc", "comm", "compl", "stat", "coll", "Conn", "connect", "Con", "cal", "ven", "ver", "socket", "common", "call", "cgi", "req", "fl", "ctx", "cn", "CON", "log", "act", "c", "cache"], "hNames": ["tStates", "tKeys", "hrKeys", "hmNames", "dhWords", " hAMES", "dhKeys", " hWords", "hrWords", "hrNames", "hKeys", "dhNames", "tNs", "bNames", " hKeys", "tNames", "htKeys", "bNs", " hUsers", "hAMES", "hmAMES", "bStates", "hmUsers", "htAMES", "hStates", "hrIDs", "bKeys", " hNs", " hStates", "htUsers", "hIDs", "hmKeys", "hNs", "dhIDs", "hUsers", "hWords", "htNames", " hIDs"], "txt": ["fn", "btn", "text", "qt", "TEXT", "te", "msg", "pkg", "tt", "ext", "tmp", "ct", "tm", "lt", "xt", "tk", "nm", "tab", "kt", "dat", "htm", "test", "mt", "dj", "t", "XT", "pt", "bt", "filename", "typ", "kw", "nt", "cmp", "wt", "ns", "nu", "xxx", "str", "xx", "nv", "obj", "ht", "gt", "tx", "sp", "elt", "lv", "tf"], "inBody": ["inputBox", " INBox", " inThread", "Inbody", " INBoot", " inReader", "inputBody", " INBody", "InReader", " inBoot", "cinBoot", "InThread", "dinbody", "inReader", "inBox", "inBlock", "dinReader", "inputThread", " inbody", "cinBody", "dinBody", "InBox", " INBlock", " inBlock", "inThread", "cinBox", " inBox", "inBoot", "inbody", "InBody", "cinBlock"], "bufCh": [" bufComp", "bufferch", "buffch", " bufch", "bufferCH", "bufCH", "ufCH", "bufch", "BufferCh", "BufferCH", "cbCol", "BufferComp", "ufCh", "bufferCh", " bufBuff", "bufComp", "bufChar", " bufChar", "ufCol", "cbCH", " bufCol", "BufferChar", "buffComp", "bufCol", "buffCh", " bufCH", "bufferBuff", "ufChar", "buffCH", "cbCh", "buffBuff", "buffChar", "cbChar", "bufBuff"], "r": ["ch", "gr", "out", "dr", "R", "or", "x", "rar", "n", "rec", "f", "q", "p", "rc", "o", "h", "hr", "re", "rd", "er", "nr", "t", "arr", "ar", "rs", "rw", "v", "cr", "e", "rt", "d", "w", "l", "u", "k", "mr", "err", "rr", "rate", "sr", "lr", "z", "i", "res", "c", "rb"], "outReq": ["outFrej", "outConj", "outConek", " outReQ", "inSeq", "outConquest", "outReck", "outRequest", "outFrech", "outTeqs", " outConj", " outReqs", "outSequest", "inSej", "outRecqs", "outSech", "outResq", "outResquest", " outConch", "outFreck", "outReek", " outRej", "outRecek", "outReqs", "outConqs", "inReq", " outConquest", " outRecque", "outConQ", "outConck", "outResch", "outRecque", "outConch", "inRequest", "outRecquest", " outReck", " outRecek", "outConq", " outRecq", "outTeq", "outREq", "inRech", "outREqs", "outTequest", " outRech", "inRej", "outTeQ", "outSeck", "outFreq", "outSej", "outREque", " outReque", "outResj", "outRecQ", "outSeq", " outRequest", " outConq", "outREek", "outConque", "inSequest", "outRech", "outRecq", "outRej", "outReQ", " outConqs", "outReque", "inSech", " outReek", " outConck", " outConQ", " outRecqs"], "buff": ["buffer", "nd", "cond", "buf", "font", "eng", "img", "cho", "Buff", "alph", "bb", "bin", "ref", "uf", "emb", "comp", "be", "cod", " buf", "cb", "ff", "mem", "bj", "ph", "off", "info", "cmd", " buffers"]}}
{"id1": "13757855", "id2": "3024992", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"process": ["proc", "load", "task", "step", "add", "replace", "save", "build", "apply", "loop", "filter", "processor", "create", "execute", "transform", "run", "Process", "call", "processing", "write", "project", "render", "parse", "format", "display", "handle"], "tpl": ["stpg", "tpg", "stspl", "tpr", " tld", "tpp", "stbl", "atuple", "timpl", "tuple", "terpl", "tld", "ttplug", "tyPL", "timspl", "ptplates", "terplate", "ttPL", "Tpp", "itplate", "Tph", "ptld", "itbl", "topl", "ttpl", "stopl", "tembl", "Tld", "Tbl", "atplate", "TPL", "Tspl", "itpl", "templ", "otpl", "tmbl", "ttph", "tspr", "tmpl", "teruple", "otld", "tmpp", "stplate", "tempr", "temPL", "itPL", "atpl", "tplug", "tbl", "timbl", "Tpr", " tpp", "ptbl", "ptpl", "ttbl", "atld", "otplate", "timplate", "tph", "Tpl", "tspl", "tsPL", "tsbl", "tmplate", "ttpg", "stpl", "Tplate", "ttopl", " tuple", " tplate", "tplate", "timopl", "Tplates", " turtle", "turtle", " tbl", "typl", "stplug", "timplug", "timpg", "tmPL", "terld", "tPL", "otbl", " tPL", " tph", "tmplates", "tyurtle", "tplates", " tplates", "tsurtle"], "model": ["node", "html", " models", "product", "ml", "M", "el", "parent", "content", "tree", "module", "md", "Model", "record", "base", "project", "models", "object", "m", "file", "log", "document", "data", "Document", " Model"], "packageName": ["PackageClass", "PackageName", "groupName", " packageNames", "packageClass", "viewName", "packagename", "viewClass", " packageVersion", "PackageRoot", " packageFamily", "viewname", "groupFamily", "packageNames", "pkgFamily", "viewRoot", "groupNames", "groupVersion", "Packagename", "packageRoot", "pkgNames", " packageClass", "packageVersion", "pkgName", "packageFamily", " packageRoot", "pkgVersion", " packagename"], "outFileName": ["outfilePath", "outStreamPath", " outTableName", "outTablename", "outFilenameChain", "outDirName", " outFilenameType", "outImagePath", "outFilenameTime", "outImageSize", "outTableName", " outFileTime", "infileType", " outFileNames", " outTableSize", "outDirPath", "outStreamName", "outStreamTime", "outFileTime", "outFilenamename", "inFileTime", "outFilenameType", " outfileName", "outfileType", "outfileTime", "outFilenameNames", "outFileChain", "outStreamNames", "outfileChain", " outfilePath", " outTablePath", "outFName", "outTableType", "outfileName", "inFileNames", "outTableChain", "outFPath", "inFileName", " outfilename", " outFilename", "outImageName", "infilePath", "outFileType", "outTableSize", " outFilenamePath", " outFilenameSize", "outfilename", "outFileNames", "inFileType", " outFileType", " outFileChain", "infileNames", " outfileNames", " outFilenameName", "outDirTime", " outFilePath", "outFilenameName", "outFilenameSize", "infileTime", " outTableTime", "infileName", "outFileSize", "outFilename", "outTablePath", "outImagename", "outFNames", " outFileSize", "outFilenamePath", "outStreamType", "outFilePath", " outFilenamename", "outFname", " outFilenameChain", "outfileNames", "inFilePath", "outTableTime", "outDirSize"], "xsltParam": ["xsmlConf", "xltParameter", "xsmlParam", "xsmlParameter", "xsqlParam", "xsqlConf", "xmlConf", "xsltConf", "xltConf", "xsltParameter", "xsslParam", "xsqlParameter", "xltParam", "xmlParam", "xsslParameter", "xsslConf", "xmlParameter"], "artifact": ["ardifacts", " artificial", "artifacts", "arifacts", "anificial", "ardifact", " artifacts", "partifacts", "partifact", "anifact", "ardificial", "anificate", "anifacts", "Artifacts", "artificial", " artificate", "arifact", "ardificate", "Artifact", "artificate"], "destinationPath": ["destinationLog", "destinatedKey", "destinateNow", "estinationPart", "destociationForm", "termininerTarget", "destinationNow", "generinateJar", "desturationPath", "destinateLog", "destinationName", "origininatedNow", "destinationPoints", "destitutionPATH", "destesticSystem", "destinationAt", "identinatePath", "destinatorpath", "destociationpath", "destinationInfo", "destinateKey", "destificationUrl", "chaininatedHome", "desticationPath", "desturationTarget", "destinatedDisk", "destositoryHost", "destinantDir", "destregationPath", "destinatedTarget", "destinateTime", "destinatedInfo", "estinoPath", "destinationPod", "destionPATH", "DestinationDir", "estionpath", "generinateSystem", "chaininationHome", "estinationTime", "descinationPath", "destinateName", "estionPoint", "destinationHost", "destationDir", "descinationHost", "termininerpath", "destinationJar", "destinerHost", "destATIONHost", "destinatorKey", "destinationTarget", "destinatepath", "destociationTarget", "origininatedForm", "identinateKey", "DestensionPod", "chaininationPath", "destationPath", "estationDir", "destociationHost", "destinoPath", "destensionTemp", "generinationPath", "chaininationDriver", "destranceLog", "destociationPoint", "destinatorHost", "termininerJar", "origininationNow", "destositoryPath", " destinationTarget", "destinateForm", "origininationPath", "destitutionPoint", "destationLocation", "delinatePoints", "destensionPoint", "destionpath", "termininationTarget", "origininationChain", "destATIONPath", "destinantPath", "destociationDriver", "identinationKey", "destinationUrl", "destociationPath", "DestinationTemp", " destociationTarget", "estinationDir", "estinoKey", "destinationForm", "destinatePoints", "chaininationDisk", "destesticPath", "identinationChain", "desticationDir", "termininerPath", "DestificationUrl", "destociationDir", "destinateDir", "DestinationUrl", "destinationTime", "destociationPoints", " destinationDisk", "destinerTarget", "estinationHost", "destinationLocation", "destinerpath", "destinationDriver", "descositoryPort", "destationHost", "destigationPath", "destensionPath", "DestensionDir", "destinatedChain", "destregationTarget", "destinateChain", "DestensionTemp", "chaininatedDriver", "destventionHome", "destinoHost", "destinatePart", "destationPart", "destinationPATH", "destventionPath", "destventionDisk", "identinationInfo", "destATIONParent", "destinatedForm", "destinateAt", "estionPath", "destesticJar", "destinoName", "DestinationLocation", "destinatedNow", "destinationParent", "generinationAt", "DestinationPoint", "destinateTarget", " destociationPath", "destigationChain", "estationHost", "delinatePath", "destinatorPort", "origininatedChain", "DestinationPod", "estinationpath", "descinationPort", "destinateSystem", " destinationpath", "origininationForm", "estinationKey", "DestensionPath", "delinationPath", "destinatedpath", "termininationPath", "destinatedPath", "desturationJar", "DestificationDir", "generinationJar", "destitutionpath", "destositoryPort", "destinoTime", "destacementPath", "termininationpath", "delinationPoints", "destranceForm", "destigationNow", "destinationKey", "destinatorChain", "destesticAt", "estinationPath", "DestificationLocation", "destinerSystem", "destinatorPATH", "destinerJar", "destacementKey", "delinationForm", "desticationTemp", "descositoryParent", "destinationDisk", "destionPath", "destinateUrl", "destociationDisk", "generinationSystem", "destATIONPort", "destinerDir", "DestinationHost", "descinationParent", "destventionDriver", "destinateJar", "destinateHost", "estinationPATH", "destinationPart", "destinerPart", "generinatePath", "destinationHome", "destinateLocation", "origininatedPath", "chaininatedDisk", "chaininatedPath", " destociationpath", "destinatorParent", "desticationPod", "destacementTime", "destinationSystem", "destitutionPath", "destinatedDriver", "DestinationPath", "estinationName", "identinationPath", "destinationpath", "delinateLog", "generinateAt", "destigationForm", "estationPath", "identinateChain", "destacementName", "destregationDisk", "identinateInfo", "estationPart", "DestensionPoint", "destionPoint", "delinateForm", "descositoryHost", "destensionDir", "destinatorInfo", "destrancePath", "destinantTemp", "estinoTime", "destationUrl", " destociationDisk", "destinoKey", "destinantPod", "DestensionHost", "destificationLocation", "descositoryPath", "termininationJar", "destinateInfo", "destinationPoint", "destinatePath", "destositoryParent", "destinationChain", "delinationLog", "destrancePoints", "estinoName", "destensionHost", "destociationLog", "destinerPath", "destinationDir", "estinationPoint", "destificationDir", "destinatorPath", "destinatorPoint", "destregationpath", "destinerAt", "destinoDir", "destociationHome", "DestificationPath", "estionPATH", "desturationpath", "destinationPort", "destensionPod", "destinoPoint", "destificationPath", "destinatedHome", "destinationTemp"], "in": ["IN", " IN", "din", "n", "f", "id", "o", "io", "ins", "t", "bin", "inner", "doc", "reader", "d", "w", "l", "r", "In", "input", "m", "file", "i", "info", "c"], "out": ["output", "ch", "gr", "list", "con", "ger", "or", "ln", "n", "Out", "dis", "it", "msg", "sys", "b", "f", "raw", "can", "p", "o", "aos", "inv", "to", "os", "io", "ex", "outs", "ins", "nr", "t", "client", "up", "cfg", "v", "ou", "nt", "oe", "all", "e", "write", "null", "inner", "writer", "println", "w", "screen", "l", "u", "obj", "go", "err", "net", "c", "conn", "print", "OUT", "conf", "cn", "cache", "file", "log", "co", "s", "res", "outer", "cmd", "report", "gen"], "root": ["json", "node", "parents", "se", "config", "graph", "id", "p", "dir", "roots", "create", "Root", "New", "ok", "initial", "scope", "parent", "tree", "group", "name", "impl", "Template", "dump", "println", "_", "child", "m", " roots", "def", "table", "chain", "data", "context", "start", "r", "de"]}}
{"id1": "4056444", "id2": "12744653", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["updateUser", "Hashpassword", " hashpassword", "hashUser", "updatePassword", "updateText", "HashText", "HashPassword", "updatepassword", " hashText", "HashUser", "hashpassword", "hashText", " hashUser"], "password": ["message", "expression", "text", " Password", "description", "prefix", "phrase", "hello", "user", "present", "database", "attribute", "account", "secret", "address", "p", "token", "wd", "reset", "default", "Password", "login", "email", "pass", "PASS", "key", "name", "sword", "required", "w", "shadow", "username", "command", "string", "input", "padding", "value", "data", "random", "word", "report", "pattern"], "md": ["dr", "db", "pm", "ms", "add", "hed", "sd", "mc", "bd", "od", "del", "MD", "sha", "grad", "der", "cd", "mg", "desc", "mm", "dm", "mt", "ind", "red", "sm", "dh", "cm", "det", "ld", "sh", "mb", "d", "dd", " Md", "mk", "mod", "pd", "m", "df", "sam", "di", "mo", "mn", "mand", "cmd", "med", "hd", "ad"], "hash": ["message", "html", "mask", "block", "Hash", "user", "hed", "build", "has", "filter", "address", "secret", "sha", "id", "state", "token", "h", "row", "test", "auth", "map", " hashing", "all", "code", "hex", "key", "name", "version", "sh", "index", "mac", "shadow", "username", "char", "sum", "crypt", "mod", "dig", "print", "check", "string", "file", "value", "bh", "search", "full", "format", "array", "handle", "score", "cache", "ash"]}}
{"id1": "11716816", "id2": "19467540", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"updateFile": ["UpdateContent", "downloadContent", "archiveSourceFile", "downloadSourceFile", "archivePage", "updateContent", "UpdateSourceFile", "downloadPage", "UpdatePage", "archiveFile", "archiveContent", "updateSourceFile", "UpdateFile", "downloadFile", "updatePage"], "file": ["path", "output", "message", "db", "type", "link", "handle", "attribute", "title", "f", "issue", "p", "h", "local", "fp", "io", "use", "File", "t", "channel", "resource", "filename", "content", "le", "e", "null", "rule", "name", "get", "page", "ile", "line", "FILE", "base", "entry", "input", "source", "port", "table", "log", "document", "info", "data", "format", "full", "url", "image", "report"], "IOException": ["IOProblem", "OperationError", "IOError", "SecurityError", "OperationProblem", "SecurityProblem", " IOProblem", "OperationException", " IOError", "SecurityException"], "destFile": ["optFolder", "DestPage", "DestPath", "tempDir", " destile", " destEmail", " destinationDir", " destDir", "destile", " destinationFile", "targetFolder", "sourceDir", "destPage", "declSourceFile", "destEmail", " DestEmail", "targetFile", "DestDir", "destDir", "Destile", "sourceFolder", " DestFile", "optPage", " destfile", " destFolder", "optPlace", "tempPath", "targetPath", "declFolder", "destDo", "sourcePath", " destPlace", "declile", "tempFile", "destfile", "destPath", "declFile", "optFile", " destinationEmail", " destPath", "Destfile", "destPlace", " destDo", "destFolder", " destinationDo", "targetDir", "sourceFile", "DestFolder", " DestDir", " destPage", " destSourceFile", "DestPlace", "DestSourceFile", "tempfile", "DestFile", " DestDo", "destSourceFile"], "in": ["IN", "on", "din", "gin", "im", "con", " IN", "init", "n", "ln", "it", "oin", "rin", "ai", "is", "ie", "ic", "ini", "sin", "f", "ain", "raw", "read", "local", "en", "inc", "io", "mm", "mi", "from", "ind", "re", "al", "ins", "up", "bin", "edIn", "pass", "all", "inner", "isin", "r", "l", "In", "net", "input", "m", "iter", "ne", "i", "info", " din", "s", "inn", "act", "inside", "inf", "cin"], "out": ["output", "ch", "fn", "cos", "ion", "con", "or", "n", "Out", "it", "msg", "sys", " OUT", "b", "flush", "can", "no", "o", "aos", "to", "os", "en", "io", "OU", "note", "ex", "outs", "t", "client", "conv", "channel", "up", "v", "ou", "nt", "oe", "at", "write", "g", "null", "one", "obj", "net", "result", "conn", "OUT", "gt", "ne", "cn", "again", "log", "oss", "chain", "co", "ot", "s", "jp", "cmd", "outer", "cache"]}}
{"id1": "755203", "id2": "16092702", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "16851955", "id2": "7044685", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"testTrainingBackprop": ["testTrainingBackward", "testTrainingbackend", "testTrainingbackprop", "testTestingBackward", "testTestingbackend", "testTestingBackprop", "testTrainingBProp", "testTrainingBprop", "testTrainingBend", "testTestingBackProp", "testTrainingBackProp", "testTrainingbackward", "testTrainingBackend", "testTrainingbackProp", "testTestingBackend", "testTrainingBward", "testTestingbackProp", "testTestingbackward", "testTestingbackprop"], "temp": ["output", "fake", "emp", "prefix", "orig", "template", "EMP", "unt", "tmp", "tar", "tm", "tab", "p", "dat", "make", "complete", "local", "por", "create", "test", "stem", "mt", "t", "created", "pt", "loc", "v", " temporary", "relative", "this", "null", "tc", "cp", "dest", "w", "mp", "txt", "mk", "mod", "porary", "Temp", "Tem", "partial", "copy", " Temp", "file", " tmp", "tem", "full", "empty", "remove", "out", "cache", "zip"], "layers": ["liowers", "lipackages", " lacks", "lasks", "lowers", "lepackages", "lients", " lenges", "slenses", "slights", "leenges", "lienses", "slensions", " lanes", "llacks", "liights", "liumers", "listayers", "lays", " languages", "listenses", "slanguages", "lsasks", "liacks", " lights", "lsayers", "liients", "lumers", "llays", "llanguages", "liayers", "vlenses", "listasks", "lenges", " Layers", " lpackages", "languages", "vlayers", "flenses", "llenses", "flanguages", "lsanes", "slayers", "lanes", "lenses", "flays", " lients", "leights", " lowers", " Languages", "lacks", " Lights", "leayers", "listanes", "llients", "lensions", " lumers", "vlpackages", "lights", " lensions", "llowers", "flayers", "slays", "llayers", " lasks", "lienges", "lpackages", " Lensions", "vlumers", " lenses", "lsenses"], "fann": ["fmanANN", "cann", "carn", " fannot", "flannis", "cain", "fmanann", " farn", "FANN", "ffann", " fain", "fANN", "fmanannis", "fain", "flANN", "ffarn", "cannot", "Fannis", "Fana", "fannis", "flann", "ffain", "flana", "fmanana", "Fann", "ffannot", "fannot", "fana", "farn"], "trainer": ["tracy", "Trainer", "bruner", "runer", "formacer", "Trrain", "Truner", " tracer", "Tracy", "riner", "Tracer", "rrain", "trrain", "tracer", "racy", "rainer", "racer", "Trayer", "triner", "trayer", "strrain", "striner", "formainer", "truner", "bracy", "brainer", "formayer", " trayer", "strainer", "bracer", "stracer", "Triner"], "desiredError": ["deseedException", "desiredEvent", "desuredError", "desIREDERROR", "desuredEvent", "desuredERROR", "desiringEr", "desIREDValue", "desiringError", "desuredException", "DesiredError", "demuredError", "demiredEvent", "desiredERROR", "demireEvent", "DesiredERROR", "deseedError", "desireEvent", "desireError", "demiredError", "desIREDError", "deseedERROR", "deseedValue", "DesuredError", "desireEr", "desiredEr", "desIREDException", "demuredEvent", "DesiredException", "demireEr", "DesiredValue", "DesuredERROR", "DesuredException", "demireError", "desiredValue", "DesuredValue", "desuredEr", "demuredEr", "desiredException", "demiredEr", "desiringEvent", "desuredValue"], "mse": ["msem", "mese", " msem", "dse", "MSE", "mSE", "mpe", "mmpe", " mpe", " mso", "mrpe", "Moe", "dSE", "mrse", "cmse", " moe", "dte", "dsem", "cmpe", "cmSE", "mso", "mroe", "mmese", "Mte", "Mpe", "Mso", "mte", "moe", " mSE", " mte", "Mse", "mmse", "cmese", "mrso", " mese", "Msem", "mmSE"]}}
{"id1": "19549577", "id2": "18693224", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"callApiPost": ["callUapiPOST", "callApiPut", "callUpiPut", "callUpiDelete", "callAiPut", "callAiDelete", "callApiDelete", "callActionsPut", "callActionsPOST", "callUapiPut", "callApiPOST", "callUapiPost", "callAapiPOST", "callActionsPost", "callAiPOST", "callActionsDelete", "callUapiDelete", "callAapiPost", "callUpiPost", "callAapiPut", "callAiPost", "callUpiPOST", "callAapiDelete"], "apiUrl": ["piPath", "resourceName", "apiName", "piURL", " apiName", "apiUr", "baseURL", " apiURL", "baseUr", "resourceURL", "apiPath", "baseUrl", "resourceUrl", "basePath", "piUr", "apiURL", " apiUr", "apURL", "piName", "resourceUr", "piUrl", "apUr", "apPath", "apUrl"], "parameters": ["queters", "authorants", "payeters", "paramels", "pParameters", "paytons", "paramants", "paramParameters", "qutons", "paramtons", "mions", "quels", "paramions", "payels", "payants", "mperties", "questParameters", "questperties", "mParameters", "meters", "authortons", "authoreters", "pions", "peters", "pperties", "paramperties", "authorels", "questions", "questeters", "quants"], "expected": ["json", " expect", " expects", "pects", "hello", " expecting", "force", "type", "example", "future", "count", "size", "checked", "test", "sent", "ped", "default", "pected", "encrypted", "actual", "needed", "current", "odd", "posted", "sex", "e", "code", "done", "error", "required", " expectation", "event", " unexpected", "finished", "set", "seen", "received", "value", "pect", "foo", "empty", "safe", "reported", "failed", "allowed"], "url": ["http", "mail", "ls", "abs", "sl", "arl", "build", "bel", "link", "ur", "Url", "f", "address", "q", "ml", "ul", "URL", "loader", "pl", "re", "ssl", "uri", "dl", "nl", "loc", "gl", "str", "mount", "impl", "ll", "get", "service", "l", "www", "gc", "base", "rl", "log", "https", "oul", "r", "hl"], "request": ["header", "change", "requ", "root", "complete", "re", "reverse", "require", "parent", "exit", "version", "Request", "web", "query", "begin", "report", "buffer", "close", "QUEST", "access", "response", "condition", "q", "create", "friend", "run", "pair", "release", "forward", "name", "pull", "quest", "rate", "remote", "project", "object", "parse", "document", "search", "memory", "remove", "session", "application", "volume", "worker", "reset", "register", "use", "client", "resource", "xml", "get", "first", "order", "question", "message", "connect", "over", "open", "user", "reference", "send", "socket", "accept", "initial", "setup", "call", "req", "store", "process", "position", "record", "command", "java", "media", "enter"], "headerName": ["methodSpec", "componentNAME", "attributename", "propertyname", "headerSpec", "profileLetter", "authorNAME", "profileName", "attributeSet", "componentFamily", "headername", "profileHandle", "headerHandle", "headerSet", "propertySet", " headerFamily", "profileSpec", "headingSpec", "headingFamily", "headingNAME", "methodHandle", "headerLetter", "headingName", "authorSet", "attributeName", "headingHandle", "headingLetter", "headerNAME", "methodName", "methodLetter", " headerNAME", "propertyNAME", "authorName", "headerFamily", "attributeNAME", "authorname", "componentName", "propertyName"], "out": ["output", "timeout", "init", "n", "auto", "Out", "ent", "sys", "tmp", "flush", "can", "console", "pretty", "o", "to", "os", "aos", "io", "help", "conv", "outs", "ex", "client", "t", "server", "up", "ou", "at", "write", "all", "inner", "null", "writer", "stream", "net", "print", "OUT", "check", "source", "set", "cn", "table", "log", "comment", "co", "s", "in", "res", "outer"]}}
{"id1": "19608872", "id2": "17116123", "code1": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"genDropSchema": [" sqlDropschemas", " sqlDropSheme", " sqlDropSchema", " sqldropschemas", " sqlDropShemas", " sqlDropShema", " sqldropScheme", " sqldropscheme", " sqlDropSchedule", " sqldropSchemas", " sqlDropScheme", " sqlDropSchdule", " sqldropschema", " sqldropschedule", " sqlDropSchemas", " sqlDropShedule", " sqlDropschema", " sqldropSchedule", " sqlDropSchmas", " sqlDropscheme", " sqlDropSchma", " sqlDropSchme", " sqlDropschedule", " sqldropSchema"], "diagramModel": [" DiagramData", "diagData", "diagrammodel", "diagModule", "diagModel", "diageData", "diageModel", "daagonalModel", " DiagonalData", "diagramMachine", "daagramModel", "diageView", "diagonalView", " Diagrammodel", " DiagramModel", "diagonalmodel", "diagonalData", "daagramView", "diageModule", "diagramModule", "diagramView", "diagMachine", "diagonalMachine", " Diagonalmodel", "diagonalModule", "daagonalModule", "diagView", "diagraphModel", "daagramData", " DiagramMachine", "diagraphData", "diagramData", "daagonalData", "diagraphmodel", "daagramModule", "diagmodel", " DiagonalModel", "diagonalModel", "daagonalView", "diagraphMachine", " DiagonalMachine"], "foreignKeys": [" foreignFiles", "primarykeys", "primaryKeys", "localFiles", "externalFiles", "externalKeys", "localItems", "primaryFiles", "externalNames", " foreignNames", "ForeignFiles", "foreignFiles", "foreignNames", "Foreignkeys", "ForeignItems", "ForeignKeys", "foreignItems", "foreignkeys", "localKeys", "primaryItems", "localkeys", "ForeignNames"], "stmt": ["ostMT", "STm", "stpt", "stMT", "ostmt", "Stm", "stm", "StMT", "ostpt", "Stmb", "Stmt", "Stpt", "ostm", "STmb", "STMT", " stm", "stmb", " stMT", " stpt", " stmb", "STmt"], "boxes": ["uploads", "rices", "cases", "ls", "es", "bags", "balls", "eas", "olds", "users", "nuts", "checks", "facts", "gs", "rooms", "bs", "drivers", "frames", "aos", "rows", "qs", "forms", "roots", "xs", "cells", "outs", "files", "lines", "classes", "bits", "lists", "tests", "xes", "books", "ox", "photos", "ones", "works", "ns", "lbs", "vals", "vers", "nets", "results", "modules", "ros", "naires", "blocks", "groups", "objects"], "box": ["BOX", "bo", "window", "block", "bed", "bean", "cross", "button", "zone", "root", "folder", "bb", "OX", "bin", "label", "cam", "form", "ba", "word", "role", "zip", "db", "book", "Box", "row", "ico", "ex", "dim", "container", "obj", "go", "docker", "co", "div", "grid", "add", "buf", "deck", "draw", "can", "pool", "col", "area", "lock", "tag", "check", "copy", "mix", "coll", "pack", "shape", "boxing", "wrap", "font", "pkg", "hold", "item", "b", "tar", "ver", "thing", "bag", "tab", "gro", "ox", "wrapper", "key", "snap", "border", "record", "base", "point", "ix"], "sqlQuery": ["qlUpdate", "qlName", "qlCode", "sqCode", " sqlStatement", "SQLUpdate", "sqQuery", "sqStatement", "qlCommand", "sqlStatement", "sqRequest", "qlStatement", "qlQuery", "qlRequest", " sqlName", "SQLCommand", "sqlRequest", "sqCommand", " sqlCode", "SQLCode", " sqlCommand", " sqlUpdate", "sqlCode", "SQLName", " sqlRequest", "sqlCommand", "SQLStatement", "sqlName", "sqlUpdate", "SQLQuery"], "x": ["nox", "on", "lex", "ls", "px", "inx", "plus", "ext", "Tx", "xf", "rx", "X", "ct", "nex", "xy", "xt", "read", "xe", "checked", "xs", "ex", "mx", "el", "xc", "xes", "ox", "gal", "v", "ac", "xxxx", "xp", "xxx", "any", "xx", "xml", "ax", "fx", "ctx", "ix", "tx", "xi", "z", "ux", "co", "exp", "xd", "act", "ross", "wx"], "counter": ["collection", "buffer", "nc", "message", "second", "pointer", "timeout", "TRY", "phrase", "book", "cover", "user", "TER", "controller", "loop", "currency", "condition", "processor", "Counter", "manager", "count", "ounter", "loader", "num", "card", "creator", "conv", "nr", "frequency", "created", "total", "timer", "continue", "code", "clock", "ctr", "index", "number", "container", "ter", "page", "sequence", "result", "taker", "batch", "entry", "amount", "hash", "cookie", "system", "chain", "finder", "walker", "outer", "population", "order"], "tableName": ["treePath", "tabSize", " tableSize", "tabPath", "treeSize", "tablename", "tableSource", "tableNames", " tableNames", " tableTitle", "fileInfo", " tablename", "tabSource", "tableInfo", "fileNames", "fileName", "filename", "tablePath", "tableTitle", " tableSource", "treeName", "tabTitle", "tabNames", "TableName", "tableSize", "Tablename", "TABLENames", "TABLETitle", " tablePath", "tabName", "TableNames", "TABLEPath", "TableInfo", "TABLEName", " tableInfo", "treeSource"], "msg": ["message", "mail", "text", "reason", "ms", "html", "notice", "kg", "term", "pkg", "sys", "title", "gs", "nm", "state", "mg", "Message", "crit", "conv", "cfg", "cmp", "ag", "summary", "bg", "g", "gz", "req", "warn", "str", "mb", "contact", "Msg", "char", " message", "txt", "sg", "print", "mem", "gm", "m", "gp", "nom", "log", "og", "comment", "mn", " MSG", "mess", "cmd"]}}
{"id1": "20028790", "id2": "22114133", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleInfoNames", "setBundleFileNames", "setBundleDataTitle", "setBundleInfLabel", "setBundleDataLabel", "setBundleInfTitle", "setBundleFileName", "setBundleDataNames", "setBundleInfoTitle", "setBundleFileLabel", "setBundleInfNames", "setBundleFileTitle", "setBundleDataName", "setBundleInfoLabel", "setBundleInfName"], "location": ["path", "message", "history", "description", "program", "template", "Location", "address", "reference", "local", "area", "uri", "loc", "resource", "filename", "translation", "library", "LOC", "where", "name", "position", "l", "directory", "remote", "command", "ocation", "localhost", "point", "language", "availability", "comment", "document", "country", "layout", "color"], "list": ["collection", "ist", "out", "missing", "add", "block", "n", "detail", "p", "pool", "local", "dl", "map", "lists", "spec", "v", "all", "name", "l", "level", "sequence", "net", "print", "batch", "set", "m", "status", "table", "chain", "stack", "listed", "L", "LIST"], "url": ["http", "mail", "html", "abs", "sl", "open", "build", "bel", "link", "ur", "lb", "Url", "b", "f", "ul", "URL", "rel", "pl", "ssl", "dl", "uri", "nl", "loc", "el", "browser", "ref", "google", "str", "mount", "ll", "gb", "l", "char", "base", "lr", "rl", "job", "sb", "r", "hl"], "br": ["ch", "wr", "gr", "dr", "buf", "bd", "b", "bp", "bs", "BR", "rel", "read", "bl", "hr", "pr", "er", "nl", "fr", "bt", "browser", "Br", "cr", "bro", "be", "str", "next", "gb", "mr", "tr", "bridge", "sr", "lr", "bh", "kr", "div", "ber", "r", "rb"], "line": ["buffer", "message", "style", "text", "part", "cell", "block", "lin", "phrase", "ln", "se", "lo", "header", "eline", "link", "detail", "piece", "body", "sql", "row", "sample", "frame", "note", "linux", "stay", "nl", "liner", "lock", "le", "code", "inline", "ine", "store", "rule", "name", "next", "label", "LINE", "l", "online", "page", "char", "sequence", "record", "entry", "string", "source", "point", "print", "iter", "log", "comment", "chain", "data", "trace", "handle", "word", "Line"], "pos1": ["Pos0", "position3", "pos2", "PosOne", "pos0", "POS1", "poOne", " posOne", "index1", "Pos1", "posOne", "poone", " pos2", "Pos2", "position2", "POS0", "po1", "pos3", "po3", "positionone", "position0", "indexOne", "indexone", "POSOne", "posone", "index3", "POS2", "position1", " pos0", "positionOne"], "bundleSymbolicName": ["bundleSymbolicalName", "bundleSymbicNames", "bundleSymbololicFamily", "bundleSymbolicType", "bundleSyMBolicNames", "bundleSyMBolicCode", "bundleSyMBolicName", "bundleSymboryType", "bundleSyMBicalCode", "bundleSymbicalCode", "bundleSymbicalType", "bundleSyMBicalNames", "bundleSymboryVersion", "bundleSymbolicalType", "bundleSymbularFamily", "bundleSymboryName", "bundleSymbularNames", "bundleSymbularName", "bundleSyMBolicVersion", "bundleSymbolicNames", "bundleSymbicalname", "bundleSymbularname", "bundleSyMBicalname", "bundleSymbolicVersion", "bundleSymbicCode", "bundleSymbicalNames", "bundleSyMBolicType", "bundleSymbololicType", "bundleSymboryNames", "bundleSyMBicalVersion", "bundleSymbicalVersion", "bundleSymbololicNames", "bundleSymboryCode", "bundleSymbolicFamily", "bundleSyMBolicname", "bundleSyMBicalType", "bundleSymbolicalFamily", "bundleSymbicVersion", "bundleSyMBicalName", "bundleSymbolicCode", "bundleSymboryname", "bundleSymbicalFamily", "bundleSymbicalName", "bundleSymbicName", "bundleSymbolicname", "bundleSymbolicalNames", "bundleSymbularType", "bundleSymbololicName"], "bundleName": ["bundleType", "baleName", "bowerVersion", "branchName", " banchname", "fasketVersion", "fundleName", "basketType", "bowerType", "balename", "bowername", "bowerName", "fasketType", "baleVersion", "bachmentInfo", " banchName", " bundlename", "bachmentName", "brundleInfo", "basketName", "brundleString", " banchInfo", "basketname", "banchname", "banchString", "bundleString", "basketVersion", "bundleVersion", "brundlename", "banchInfo", "fundleVersion", "bundleInfo", "bachmentname", "baleType", "fasketname", "fundleType", "bowerString", "fasketName", "fundlename", "branchString", "banchName", "bowerInfo", "baleInfo", "brundleName", " bundleInfo", "bundlename", "branchname", "branchInfo"], "info": ["history", "http", "self", "update", "json", "block", "iso", "instance", "now", "dev", "user", "fo", "te", "ext", "detail", "item", "me", "f", "state", "local", "note", "INFO", "fit", "summary", "all", "inner", "error", "index", "obj", "event", "details", "entry", "check", "tip", "def", "status", "iter", "information", "value", "match", "job", "tf", "i", "comment", "Info", "data", "query", "context", "alias", "conf", "image", "report", "inf"]}}
{"id1": "14001795", "id2": "8665649", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyOverWarFiles", "copyOverwarFile", "copyoverwarFiles", "copyoverWarFilename", "copyOverTarFiles", "copyOverWarfile", "copyOverTarFile", "copyoverWarFile", "copyoverwarFilename", "copyOverwarFilename", "copyOverTarFilename", "copyoverWarFiles", "copyoverwarfile", "copyoverwarFile", "copyOverWarFilename", "copyOverwarfile", "copyoverWarfile", "copyOverwarFiles", "copyOverTarfile"], "dir": ["path", "disk", "dr", "db", "window", "addr", " d", "add", "cur", "vol", "tmp", "del", "old", "dat", "rel", "wd", "cd", "folder", " directory", "direct", "local", "desc", "dm", "re", "ind", "dep", "dl", "loc", "fin", "parent", " Dir", "dist", "ld", "DIR", "doc", "name", "dd", "d", "dim", "good", "ir", "md", "directory", "mk", "form", "Dir", "def", "iter", "df", "file", "log", "di", "div", "fd", "res", "out", "url", "dial", "coll", "zip"], "ff": ["af", "bf", "alf", "ffe", " aft", " eff", "wind", "lf", "cond", "ef", " af", "fg", "xf", "filter", "ck", " cf", "fp", "aft", "mt", "fact", " df", "ft", " ref", "FF", "buff", "aff", "fc", "uf", "ld", "fl", " def", "cb", "UFF", "fx", "df", "tf", "file", "eff", "uff", "xff", "off", "fd", "cf", "F", "iff", "sf", " FF"], "files": ["uploads", "faces", "assets", "ls", "balls", "plates", "ports", "facts", "iles", "images", "Files", "frames", "rows", "forms", "jobs", "mas", "les", "lines", "tests", "ions", "styles", "features", "members", "days", "leases", "bees", "keys", "values", "fs", "parts", "models", "fields", "file", "resources", "flows", "ories", "names", "issues", "ails", "items", "objects"], "f": ["bf", "alf", "lf", "n", "a", "fe", "xf", "b", "p", "h", "col", "fp", "ft", "t", "v", "sf", "fc", "fab", "fm", "uf", "e", "g", "d", "fl", "w", "fac", "l", "rf", "k", "fs", "elf", "def", "m", "file", "i", "exp", "fw", "F", "cf", "fd", "tf", "c", "fa"], "newFile": ["newsKey", "newsFile", "NewKey", "newFiles", "newPage", "anotherFiles", "NEWNode", "NewFiles", "newfile", "NEWFile", "oldFilename", "newNode", "NewNode", "uniquefile", "uniqueFile", "NewPlace", " newPlace", "NewPage", "newFilename", "newsfile", "NEWPage", "NewFilename", "securefile", "newKey", "anotherfile", "secureFile", "secureKey", "NEWfile", "uniquePage", " newFiles", " newfile", "NewFile", "uniqueNode", "anotherPlace", "oldFile", "Newfile", " newFilename", "anotherFile", "newPlace", "oldfile"], "fi": ["bf", "zi", "lf", "phi", "ini", "fe", "ri", "iu", "FI", "fp", "io", "ci", "mi", "ki", "ii", "fr", "flo", "ifa", "ife", "uf", "ti", "bi", "ni", "si", "afi", "Fi", "i", "di", "pi", "fd", "cf", "fin", "li", "sf", "isi", "fa"], "fo": ["bo", "eno", "FO", "eto", "jo", "te", "ato", "xf", "tk", "tto", "o", "zz", "ki", "flo", "oo", "uo", "ott", "ho", "wt", "hi", "ti", "opa", "oe", "ow", "tif", "oooo", "sty", "hea", "ph", "wo", "po", "zo", "ko", "mo", "fam", "co", "vo", "cf", "tf", "sf"]}}
{"id1": "13891080", "id2": "22801734", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferStream", "cloneDir", "cloneFile", "cloneStream", "transferFile", " copyStream", "copyStream", " copyDir", " copyTo", "copyTo", "cloneTo", "transferDir", "transferTo", "copyDir"], "srcFile": ["initFile", "initfile", "initBlock", " srcfile", " srcEmail", "subfile", "initEmail", " srcPath", "rcFile", "srcPath", "subFile", "srcfile", " srcBlock", "rcfile", "srcBlock", "destPath", "rcPath", "subEmail", "subBlock", "sourceFile", "srcEmail", "sourcefile"], "destFile": ["refFILE", "litDir", " destDir", " dstFile", " destStyle", "litFILE", "DestDir", "destDir", "refFile", " destfile", "altFile", " destFILE", "litMail", "altfile", "destStyle", " dstDir", "srcfile", " destPlace", "srcStyle", "destfile", " destMail", "Destfile", "destPlace", "altDir", "litFile", "refMail", "refDir", "srcDir", " dstfile", "destMail", "altStyle", "destFILE", "DestPlace", "DestFile", " dstPlace"], "srcChannel": [" srcchannel", "curChannel", "curChan", "srcChan", "srcStream", "rcConnection", "rbButton", "srcButton", "subButton", "srcchannel", "srcFace", " srcConnection", "rcStream", "rbClient", " srcChan", "rbFace", "srcSection", "rcChannel", "curConnection", "subFace", " srcClient", "rbChannel", "subChannel", "rcchannel", "rcChan", "srcConnection", " srcStream", "curSection", " srcFace", "curStream", " srcSection", "srcClient", " srcButton", "subClient", "curchannel", "rcSection"], "dstChannel": ["dndCow", "ddestBuffer", "dstChan", "dotConnection", "distUser", "rddestStore", "dblConnection", "distBuffer", " dotConnection", "dblStore", "rddestConnection", "dndConnection", "dstConnection", " dotCow", "dotStore", "dblChannel", " dotChan", "ddestChannel", " dstChan", "dotChannel", "rddestChan", " dstCow", "dotBuffer", " dotUser", "ddestCow", "dndChan", "ddestChan", "dblChan", "rdstChannel", "dndChannel", "ddestUser", " dotChannel", "rdstStore", "dotCow", " dstConnection", "dotUser", "rddestChannel", "distChannel", "rdstConnection", "rdstChan", "dstCow", " dstBuffer", " dstUser", "ddestConnection", "ddestStore", "dstBuffer", "dstUser", "dstStore", "distConnection", "dotChan", " dotBuffer"]}}
{"id1": "2521141", "id2": "15645004", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"copy": ["edit", "load", "close", "replace", "save", "sync", "link", "move", "cut", "crop", "transfer", "export", "download", "create", "clip", "io", "slice", "delete", "write", "cop", "cp", "share", "get", "upload", "Copy", "set", "source", "drop", "archive", "file", "select", "clone", "paste", "remove", "insert", "opy", "ate", "zip"], "from_name": [" from_part", " from_no", "from_resource", " from_names", " from_info", "fromamekey", "fromkcase", "from_names", "fromkName", "fromkname", " from_filename", " from_resource", "fromkpart", "from_filename", "fromameName", "from_info", "fromamename", "fromamefilename", " from_case", " from_Name", "from_no", "from_case", "from_key", " from_key", "from_part", "from_Name"], "to_name": ["to7name", " to_nm", "to_new", "to_get", "from_new", "from_get", "eto_Name", "tolyfile", "eto_word", "toNamefile", "tolynm", "to_number", "tolynumber", "to7file", "toNamenew", "toNameget", " to_number", "to7new", "toNamename", "to_nm", "to_word", "to_Name", "to7get", "tolyname", "eto_name"], "from_file": ["or_name", "or_File", " from_type", "or_run", " from_node", "from_resource", "from_dir", "fromlynode", "from_File", "fromsfile", "fromsname", "from_type", " from_File", "from_time", " from_resource", "from_port", "fromlyfile", "or_file", "fromlyFile", "fromsdir", "fromlyresource", " from_time", "from_do", "from_node", " from_do", "to_dir", "from_run", " from_port"], "to_file": ["to_block", "to_local", "that_file", "toJblock", "to_create", " to_create", "to_element", " to_block", "to_port", "that_tree", " to_local", "TO_port", "to_drop", "toJfile", "from_dir", "to_FILE", "that_File", " to_drop", "that_link", "from_type", "to_base", " to_dir", "TO_FILE", "TO_files", "to_type", "to_link", "toJdrop", "to_File", " to_base", "toJFile", " to_run", "TO_file", "to_files", " to_File", "to_tree", "TO_name", "TO_element", "to_run", "to_dir"], "parent": ["path", "owner", "part", "top", "shape", "per", "parents", "timeout", "prefix", "block", "man", "my", "instance", "user", "peer", "tar", "percent", "params", "holder", "master", "root", "p", "id", "pool", "paren", "Parent", "folder", "test", "desc", "default", "pid", "pa", "global", "ma", "client", "up", "server", "par", "spec", "cmp", "relative", "tree", "where", "null", "home", "rule", "name", "prop", "unit", "position", "mother", "family", "page", "event", "directory", "pixel", "form", "remote", "base", "source", "child", "point", "def", "port", "file", "comment", "chain", "sp", "ip", "temp"], "dir": ["path", "dr", "self", "db", "part", "addr", "vol", "cond", "init", "rec", "del", "rel", "wd", "cd", "folder", "local", "ind", "dep", "red", "loc", "det", "dist", "module", "DIR", "str", "dd", "d", "dim", "tr", "good", "md", "ir", "directory", "cont", "mod", "Dir", "dict", "def", "iter", "file", "di", "sp", "div", "fd", "cmd", "coll", "cur"], "from": ["style", "on", "con", "st", "window", "or", "vol", "by", "term", "se", "init", "ent", "user", "orig", "false", "com", "ie", "normal", "From", "and", "so", "link", "old", "no", "reset", "bound", "en", "local", "re", "io", "pos", "fr", "with", "client", "back", "inner", "store", "error", "fun", "stream", "form", "before", "base", "entry", "check", "source", "set", "ra", "file", "func", "query", "empty", "in", "start", "out", "left"], "to": ["output", "on", "top", "or", "eto", "by", "auto", "te", "ato", "tt", "so", "b", "into", "sys", "toc", "two", "too", "tto", "ta", "token", "o", "no", "pretty", "can", "t", "op", "client", "total", "ma", "will", "nt", "e", "stable", "null", "must", "ts", "go", "please", "base", "tty", "that", "ne", "table", "po", "co", "pi", "target", "TO", "To", "out"], "buffer": ["message", "Buffer", "binary", "function", "window", "password", "block", "phrase", "buf", "template", "button", "database", "bar", "available", "attribute", "variable", "character", "sample", "row", "queue", "frame", "buff", "char", "page", "sequence", "event", "command", "batch", "base", "entry", "iter", "table", "stroke", "stack", "document", "memory", "append", "paste", "word", "temp", "cache"], "bytes_read": ["bytes__Read", "bytes_write", " bytes2range", "words_len", "wordsyncread", "Bytes_write", "bytesyncreport", "words_report", "bytes2Read", "wordsyncreport", "words_read", "bytes_run", " bytes_write", "bytes__read", " bytes2read", "bytes_range", "wordsynclen", "bytes2write", "bytes_report", "bytes_Read", "bytes__range", "bytes2range", "bytesyncwrite", "words_write", "wordsyncwrite", "bytes_len", " bytes_Read", " bytes2write", " bytes_range", "Bytes_run", "bytes2read", "bytes__write", "bytesyncread", " bytes2Read", "bytesynclen", "Bytes_read"]}}
{"id1": "1508930", "id2": "15472181", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"httpRequestByPOST": ["httpRequestbyPOST", "httpRequestBypost", "httpRequestWithpost", "httpGetByPOST", "httpGetbyPOST", "httpRequestViaGET", "httpGetByGET", "httpRequestWithPOST", "httpRequestbyPost", "httpRequestByPost", "httpGetByPost", "httpRequestByGET", "httpGetBypost", "httpRequestViapost", "httpGetbypost", "httpGetbyPost", "httpRequestViaPOST", "httpRequestWithGET", "httpRequestbypost", "httpRequestbyGET", "httpRequestWithPost", "httpRequestViaPost", "httpGetbyGET"], "url": ["path", "http", "ls", "location", "method", "ret", "ur", "Url", "address", "URL", "id", "api", "pl", "ssl", "uri", "dl", "loc", "ref", "call", "request", "key", "name", "str", "ll", "l", "k", "href", "remote", "base", "string", "domain", "web", "join", "format", "host", "pattern"], "timeout": ["sleep", "blocking", "password", "time", "method", "type", "body", "pool", "duration", "size", "ssl", "period", "mode", "length", "version", "number", "delay", "batch", "amount", "padding", "wait", "port", "max", "format", "Timeout", "seconds"], "params": ["properties", "pps", "posts", "pos", "ams", "p", "images", "forms", "mm", "mas", "AMS", "pins", "packages", "spec", "ps", "param", "styles", "photos", "tags", "changes", "actions", "settings", "Par", "terms", "keys", "values", "Parameters", "parts", "details", "padding", "pi", "media", "data", "names", "query", "objects", "list", " parameters"], "response": ["output", "message", "application", "text", "json", "description", "block", "template", "onse", "example", "connection", "address", "body", "complete", "reset", "relation", "frame", "respond", "answer", "resp", "yes", "relative", "content", "request", "all", "null", "version", "next", "xml", "view", "service", "respons", "Response", "result", "sequence", "command", "remote", "string", "object", "status", "value", "reply", "document", "data", "success", "format", "report", "network"], "httpClient": ["htmlCase", "httpCase", "htmlDo", "httpCo", " httpclient", "Httpclient", "htmlCo", " httpDo", " httpCase", "httpConnect", "sslClient", " httpProxy", "htmlClient", "HttpClient", "sslCo", "sslDo", "httpProxy", "sslCase", "httpDo", "HttpConnect", " httpCo", "ttpclient", "httpclient", "ttpProxy", "HttpProxy", "ttpConnect", "ttpClient", " httpConnect"], "httpPost": ["HttpRequest", "HTTPPut", "thisPut", "httppost", "statusPos", "HTTPpost", "thisPOST", "HttpPOST", "thisPost", "httpPos", "ttpPost", " httpPOST", "HttpPut", "httpPut", "HTTPPost", "HttpPos", "HTTPPOST", "statusPost", "ttpPut", " httpPut", "statusPut", "HttpPost", "HTTPRequest", "ttpPOST", "statusRequest", "httpRequest", "thispost", " httppost", "HTTPPos", "httpPOST"], "serverResponse": ["serverAnswer", "erverLine", "statusPage", " serverDescription", " serverEntity", "serverPage", "statusResponse", "httpResponse", "ServerPage", "statusEx", " serverAnswer", "descriptionAnswer", "verLine", "ServerResponse", "ServerAnswer", "verCall", "serverBody", "descriptionDescription", "httpCall", "httpBody", "ServerDescription", "serverDescription", "verBody", "serverEx", "httpLine", " serverEx", "serverStream", "ServerEntity", "descriptionResponse", "erverResponse", "serverCall", "serverEntity", "erverBody", "serverLine", "ServerStream", "ServerEx", " serverPage", "erverCall", "descriptionStream", " serverStream", "verResponse", "statusEntity"], "statusLine": ["serviceLine", "checkCode", "statusPage", "serviceResponse", "serverPage", "statusResponse", "specCode", "serverCode", "checkline", "responseCode", "serviceCode", "checkLine", " statusCode", "StatusLine", "statLink", "responseline", "statusLink", " statusLink", " statusline", "statusline", "responseLine", "specLink", "Statusline", " statusResponse", "StatusPage", "statusCode", "serverLine", "specline", "servicePage", "StatusCode", "statPage", "specLine", " statusPage", "statline", "statLine", "statCode", "responsePage", "checkPage"], "inputStream": ["InputStream", "imageReader", "inputPath", "contentSource", " inputThread", "contentSteam", "inputstream", "InputSteam", "InputSource", " inputSource", "outputSource", "imagestream", " inputSteam", "inReader", "contentThread", "inStream", "inputThread", "inputSteam", "outputReader", "inSteam", "contentStream", "InputReader", "InputThread", "imageSteam", " inputstream", "inputSource", "outputStream", " inputPath", "InputPath", "outputPath", "imageStream", "instream"], "inputReader": ["InputStream", "imageReader", "uploadStreamer", "uploadStream", "uploadreader", "uploadReader", "imagereader", "serviceStream", "InputStreamer", "serviceReader", "serviceEditor", " inputLibrary", "inputLibrary", "serviceLibrary", "Inputreader", "InputReader", "imageStreamer", "inputEditor", "errorLibrary", "errorEditor", "errorReader", "errorStream", "inputStreamer", "inputreader", " inputEditor", "imageStream"], "bufferedReader": ["bufferedParser", "buffedLoader", "buffinedRunner", "bedenedWriter", "bederedParser", "buffinedReader", "bufferredStream", "bufferredRunner", "buffedParser", "bedenedReader", "buffedReader", "buffererredStream", "buffererredReader", "bedenedParser", "bedenedLoader", "buffereredWriter", "buffedWriter", "buffereredRunner", "buffererRunner", "buffenedParser", "bederedReader", "buffenedReader", "bufferedWriter", "bufferredParser", "buffinedStream", "buffenedWriter", "buffererStream", "buffererredRunner", "bufferedStream", "bufferedRunner", "buffinedWriter", "bederedWriter", "buffererredWriter", "buffererReader", "bufferredReader", "bufferedLoader", "buffereredStream", "bederedLoader", "buffererWriter", "buffereredReader", "bufferredWriter", "buffenedLoader", "bufferredLoader"], "buffer": ["message", "Buffer", "binary", "builder", "black", "window", "block", "phrase", "buf", "template", "button", "database", "bar", "change", "filter", "console", "absolute", "bound", "queue", "note", "bone", "total", "buff", "library", "null", "background", "mb", "bridge", "sequence", "print", "batch", "layer", "table", "comment", "escape", "profile", "document", "stack", "display", "memory", "append", "trace", "temp", "cache"], "line": ["message", "text", "cell", "model", "lin", "block", "phrase", "ln", "n", "user", "header", "eline", "link", "lane", "row", "frame", "nl", "liner", "email", "le", "e", "code", "inline", "ine", "error", "name", "rule", "LINE", "l", "online", "page", "sequence", "entry", "string", "print", "point", "file", "stroke", "log", "comment", "chain", "query", "column", "word", "Line"], "lastErrorCode": [" lastErCount", "lastStatusCount", "lastErCount", " lastErClass", "firstErrorCount", "lastErMessage", "firstErrorCode", "lastEventCode", "firstStatusCode", "firstErrorMessage", "lastEventCount", "lastErClass", " lastErMessage", "lastErrorCount", "firstStatusMessage", "firstErrorClass", "lastStatusMessage", "lastStateClass", "lastEventClass", "lastStateMessage", "lastStatusCode", " lastErCode", "lastStateCount", "lastEventMessage", "lastErCode", " lastErrorCount", "lastStatusClass", " lastErrorClass", "firstStatusClass", "lastStateCode", "lastErrorClass", "firstStatusCount"], "lastErrorMessage": ["lastIssueDetails", "lasterrorString", "lastErrorString", "lastErrorLine", "lastWarningDetails", "lastEventLine", " lastEventMessage", " lastStatusMsg", "lastWarningDescription", "lastStatusDetails", " lastStatusDetails", "lastIssueDescription", " lastErrorString", "lastEventDescription", "lastErrorMsg", "lasterrorDescription", " lastEventDescription", " lastEventString", " lastEventLine", "lastStatusMsg", "lastErrorDetails", " lastErrorDescription", "lastIssueMessage", " lastStatusMessage", "lastErrorDescription", " lastErrorLine", "lasterrorMessage", "lastStatusMessage", "lastEventString", "lastStatusLine", "lastStatusString", " lastStatusDescription", "lastWarningMessage", " lastErrorMsg", "lastStatusDescription", "lasterrorLine", "lastEventMessage", "lastWarningMsg", "lastIssueMsg", " lastErrorDetails"]}}
{"id1": "8046691", "id2": "3514286", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retireImage", "retrieveImage", "detrievedLocal", "detrievedFile", "retrievedFile", "detrieveLink", "retractLink", "retrievedImage", "detrieveImage", "detrievedImage", "detrieveLocal", "retrieveLink", "retrieveLocal", "retireFile", "retrievedLocal", "retireLocal", "retireLink", "detrieveFile", "retractImage", "detrievedLink", "retractFile", "retractLocal", "retrievedLink"], "url": ["path", "http", "ls", "location", "abs", "sl", "arl", "build", "bel", "ur", "Url", "f", "address", "ml", "URL", "id", "row", "pl", "ssl", "uri", "dl", "nl", "resource", "el", "ref", "run", "call", "str", "name", "ll", "cp", "get", "l", "char", "u", "un", "remote", "rect", "base", "string", "m", "rl", "file", "job", "web", "host", "image"], "link": ["style", "links", "block", "Link", " load", "error", "label", "light", "cp", " relay", "let", "set", "status", "file", "query", "li", "list", "path", "ment", " check", "db", "mark", "init", "msg", "download", "install", " LINK", "linked", "ssl", "dl", "write", "share", "l", "go", "remote", "entry", "def", "handle", " lock", "ls", "add", "loop", "ml", "loader", "local", "relation", "map", "lock", " block", "tag", "library", "ld", "index", "get", "page", "line", "check", "system", "pack", "message", "load", "self", "mail", "task", "open", "build", "type", "sign", "detail", "master", "rel", "ink", "le", "key", " delay", "post", "stream", "tool", "thread", "lib", "base", " jump", "log", "info", " reload", "image", "network"], "httpConn": ["internalconn", " httpCt", "htmlConn", "HTTPConn", "HttpConnection", "HttpConn", "httpSyn", "httpCon", "appConnect", " httpCmd", "localConnection", "httpConnection", "hoverSyn", " httpCon", "appConn", "HTTPCons", "httpsConnection", "htmlConnect", "ttpCons", "realConnect", "httpsCon", "internalConnect", "httpConnect", "httpCmd", "httpsConn", "internalCt", "httpsCmd", "htmlCt", "internalConnection", "socketconn", "localConn", "localCon", " httpConnection", "httpCt", "realConn", "ttpCt", "ttpSyn", "socketConnection", "HTTPConnect", "hoverConnection", "httpsCons", "socketConn", "internalCon", "hoverConn", "ttpCmd", "httpsConnect", "ttpCon", " httpSyn", "htmlconn", "HttpConnect", "ttpConn", "appConnection", "httpconn", "realconn", "hoverCons", "internalConn", "appconn", "localconn", "HttpCon", "httpsconn", "ttpConnection", "realCt", "hoverCon", "HTTPCon", "hoverConnect", "hoverCt", "httpCons", "socketConnect", "ttpconn", " httpconn", "ttpConnect", " httpConnect", " httpCons"], "outs": ["uploads", "out", "ims", "ches", "nos", "cos", "ls", "ops", "locks", "gets", "ows", "ports", "uts", "checks", "yout", "gs", "lets", "bs", "ds", "its", "uds", "os", "aches", "aos", "boxes", "qs", "cells", "plays", "ins", "bits", "obs", "lists", "sets", "dates", "ns", " outputs", "ks", " layouts", "ips", "ats", "fits", "tops", "offs", " ops", "vals", "ends", "nets", "uns", "ios", "s", "eps", "aps", "ts", "als", " out", "orts"], "bins": ["lobs", "blids", "wobs", "rans", "blouts", "bkins", "lin", "lins", "blins", "lids", "binn", " binos", "hin", "hins", "blkins", "binos", " bans", " bkins", "linn", "bids", "win", "bin", "routs", "bobs", "blinn", "wins", "louts", "hobs", "wouts", " bids", "linos", " binn", "blinos", "blans", "houts", "rins", "rkins", "bans"], "bouts": ["Bouts", "baos", "bout", "byout", " bonds", "bbbs", "obins", "Bins", "obouts", " baints", "bbyout", "wbout", "bbs", "wbouts", "fbins", "wbaos", "waints", "wins", "bonds", "bbouts", " bout", "wouts", "obbs", " baos", "fbbs", "wout", "wonds", "obyout", "Baints", "fbyout", "fbouts", "baints", "Baos", "bbins", "wbonds", "waos"], "postData": ["postsdata", " postDATA", "PostQuery", "POSTQuery", "POSTDATA", "postBody", "postQuery", "postDat", "postsBytes", "postsData", "formdata", "formData", " postBytes", "POSTData", "postDATA", "PostDATA", "POSTdata", "postdata", " postBody", "formDATA", " postDat", "postBytes", "POSTDat", " postdata", "formDat", "PostData", "PostBytes", "Postdata", " postQuery", "POSTBody", "postsDATA", "POSTBytes", "PostBody"], "mimePattern": [" mimepattern", " mimeTemplate", "metypattern", "mIMEPattern", "smetyPattern", "smimepattern", "muxpattern", "muxPattern", " muxpattern", "metyTemplate", "mimeFormat", "smetyFormat", "mimesTemplate", "metyPattern", "mIMEFormat", "mimesPattern", "metyFormat", "mimeTemplate", "muxTemplate", "smimePattern", " muxTemplate", "mIMEpattern", " muxPattern", "mimespattern", "mimesFormat", "smimeFormat", "mimepattern", "smetypattern"], "matcher": ["dismatch", "Matching", "matmatch", "patch", " matches", "patter", "Matter", "Matmatch", "stather", " mature", "Matcher", "matching", "discher", "statching", " matmatch", "mather", "patcher", "matter", "Mature", " matching", "disure", "Match", "Mather", "statcher", " match", "statter", "matches", "disches", "match", "mature", "pather", "Matches", " matter", " mather"], "byteBuffer": ["ByteBuffer", "byteVar", "bbuffer", "letterBuffer", "wordBuffer", "ByteBuff", "bBuff", " byteFFER", "noteVar", "bFFER", "byteBuilder", "letterMatrix", "charVar", "noteBuilder", "bytebuffer", "byteFrame", "wordbuffer", " byteMatrix", " byteBuilder", "byteMatrix", " byteBuff", "bBuffer", "wordMatrix", "letterbuffer", "ByteFFER", " bytebuffer", "noteBuff", " byteVar", "charBuffer", "Bytebuffer", "byteFFER", "noteBuffer", " byteFrame", "charBuff", "charBuilder", "letterFrame", "byteBuff", "wordFrame"], "count": ["ch", "buffer", "C", "depth", "counter", "core", "add", "first", "n", "val", "force", "last", "loop", "read", "size", "num", "ind", "current", "total", "more", "length", "nt", "acc", "continue", "cycle", "Count", "code", "all", "call", "ctr", "index", "number", "char", "ount", "sum", "err", "result", "cont", "batch", "check", "amount", "child", "iter", "cap", "cc", "max", "comment", "find", "found", "start", "conf", "c", "list", "cache", "len"]}}
{"id1": "18544890", "id2": "8216539", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"get": ["gets", "draw", "put", "getting", "stats", "api", "read", "download", "create", "game", "call", "run", "all", "pull", "post", "Get", "print", "GET", "match", "show", "range", "info", "query", "search", "list", "cache"], "url": ["path", "http", "mail", "html", "location", "addr", "sl", "hub", "ret", "build", "link", "ur", "lb", "Url", "ul", "address", "q", "URL", "id", "api", "pl", "ssl", "uri", "dl", "nl", "game", "ref", "str", "mount", "xml", "ll", "l", "base", "rect", "string", "rl", "domain", "file", "web", "host", "hl"], "lat": ["grid", "top", "st", "addr", "x", "ct", "xy", "y", "kt", "wp", "coord", "area", "att", "sat", "feat", "west", "loc", "pos", "pt", " latitude", "at", "rt", "Lat", "dist", "alt", "ats", "str", "south", "sta", "rect", "apt", "height", "ip", "mat", "sq"], "lon": ["fn", "las", "on", "top", "location", "lin", "x", "lf", "ln", "n", "lang", "elong", "lu", "lay", "lt", "ong", "itude", "local", "zon", "low", "west", "loc", "pos", "geon", "phy", "vert", "ll", "ino", "l", "mag", "land", "los", "lol", "lbs", "ng", "len"], "count": ["top", "counter", "cond", "n", "nb", "score", "last", "ct", "id", "size", "num", "frequency", "th", "current", "total", "more", "length", "nt", "call", "Count", "code", "index", "number", "sum", "ount", "page", "batch", "limit", "amount", "max", "range", "search", "scroll", "found", "start", "c", "list", "cache"], "req": ["gr", "proc", "http", "qt", "reg", "j", "init", "qq", "org", "peer", "pkg", "rx", "requ", "q", "send", "sql", "forge", "rel", "inv", "htt", "pr", "hr", "desc", "friend", "ind", "sub", "crit", "pas", "rd", "fr", "resp", "Requ", "client", "ps", "require", "uj", "typ", "sem", "rest", "fail", "request", "comp", "cgi", "aux", "dist", "pull", "next", "dj", "quest", "comm", "quick", "r", "compl", "err", "mk", "rr", "conf", "Request", "tx", "https", "cert", "search", "jp", "urg", "cmd", "res", "repl", "usr", "sq", "forced", "wx", "cur"], "gl": ["gr", "als", "ger", "ls", "jl", "balls", "sl", "bel", "gold", "tl", "wal", "gif", "gs", "ogl", "ml", "igl", "rel", "console", "bl", "pl", "ibl", "dl", "nl", "gall", "vl", "gel", "g", "gz", "spring", "bal", "ll", "fl", "gb", "l", "illas", "Gl", "gc", "abl", "gm", "cl", "acl", "rl", "tf", "lol", "wl", "lor", "gn", "GL", "hl", "list", "il"], "br": ["ch", "wr", "gr", "dr", "shr", "buf", "b", "bp", "bm", "BR", "bl", "hr", "pr", "er", "fr", "bt", "arr", "el", "browser", "Br", "cr", "bg", "bro", "be", "bi", "str", "vr", "mr", "tr", "FR", "sr", "lr", "sp", "bh", "kr", "ber", "r", "yr", "rb"], "line": ["message", "style", "text", "cell", "lin", "block", "phrase", "ln", "n", "valid", "user", "lo", "msg", "header", "eline", "link", "lane", "body", "console", "row", "sample", "frame", "note", "stay", "channel", "el", "liner", "train", "le", "e", "code", "inline", "ine", "error", "str", "label", "rule", "edge", "LINE", "stream", "l", "page", "sequence", "entry", "string", "print", "point", "check", "iter", "stroke", "log", "file", "comment", "range", "chain", "display", "trace", "word", "Line"]}}
{"id1": "804637", "id2": "3945236", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "6966398", "id2": "11477906", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["runner", "buffer", "dr", "builder", "rar", "ri", "rx", "rer", "loader", "parser", "rc", "read", "row", "io", "older", "er", "rs", "wrapper", " read", "this", "inner", "writer", "handler", "stream", "rot", "mr", "rr", "redo", "Reader", "ner", "roller", "sr", "lr", "input", " readers", "rl", "iter", "file", "driver", "ro", "cer", "query", "ocr", "r"], "ks": ["KS", "sky", "vs", "ms", "ls", "ates", "kk", "kes", "km", "kies", "checks", "ck", "akes", "cks", "bs", "kb", "ss", "ds", "ars", "qs", "uds", "ses", "hs", "ys", "ke", "ces", "ki", "cs", "obs", "uk", "ips", "ans", "keys", "k", "fs", "mk", "eks", "ols", "kens", "icks", "agles", "ros", "oss", "nets", "kr", "eps", "sk", "kas", "ups"], "key": ["owner", "sky", "Key", "password", "core", "by", "x", "my", "user", "type", "ek", "sign", "link", "tk", "root", "y", "ssh", "ke", "er", "power", "client", "KEY", "ox", "pair", "trust", "null", "service", "keys", "char", "k", "obj", "mk", "base", "entry", "ey", "object", "hash", "file", "cer", "info", "sk", "ca"], "chain": ["path", "binary", "password", "block", "type", "sign", "piece", "ver", "root", "can", "pool", "sche", "test", "ce", "frame", "channel", "component", "pair", "code", "box", "group", "number", "stream", "chains", "bank", "family", "sequence", "result", "form", "base", "batch", "check", "string", "hash", "table", "file", "range", "stack", "data", "Chain", "trace", "ca", "c", "list", "cache"], "os": ["out", "cos", "ls", "ms", "OS", "oos", "ops", "is", "sys", "uts", "bos", "osi", "bs", "oso", "ds", "o", "aos", "io", "css", "ys", "cs", "obs", "pos", "ps", "ox", "oS", "js", "Os", "oids", "fs", "ols", "los", "us", "ose", "oss", "oes", "ios", "ot", "oses", "ts"], "stamper": [" strampler", " stamPER", " stummer", "font", " stcamter", "valid", "stramper", " stcampler", "stumper", "stampler", "stimPER", "stammer", " stcamper", " stimper", "stimmer", "stramPER", "stAmmer", "stumpler", " stamter", "stamPER", "read", "New", " stumter", "The", "stimpler", " stcammer", "strampler", "this", "Print", "annot", "stummer", "strammer", " stumper", "stAmPER", "println", "_", "stimper", "good", " stammer", " strammer", "stAmper", " stramper", " stimmer", " stumpler", " stramPER", "def", " stimpler", "stamter", " stampler", "stAmpler", "important", "stumter", " stimter"], "appearance": [" appendix", "attlies", "apeared", "attearance", "apearances", "Appeared", "ascearing", "Applies", " appearing", "appendix", "patternearances", " appeared", "patternendix", "displayearances", "aceared", "accearance", "apearance", "atteared", "displayearing", "Appearances", "suppeared", "ascears", "appearances", "Appearance", "appreciation", "apreciation", "appeared", "acearance", "aplies", "ascearances", "attearances", "applies", "ascearance", "displayears", "suppearance", "displayreciation", "apearing", "displayeared", "appears", "patternearance", "accears", "accearances", " appearances", "displayearance", "displaylies", "appearing", "patternearing", "acclies", "displayendix", "suppearances", "acreciation", "acearances", "apears"]}}
{"id1": "12428013", "id2": "13757855", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "label": 0, "substitutes": {"polishOff": [" swishoff", " swISHOff", " swishingExec", " swishingOff", " swishersoff", "finishoff", " swishOff", " swishingoff", "finISHoff", " swishExec", " swishersExec", "finISHExec", " swISHExec", "finishExec", " swISHoff", "finishOff", "finISHOff", " swishersOff"], "monitor": ["runner", "message", "description", "timeout", "progress", "healthy", "hover", "member", "menu", "spin", "ai", " monitoring", "detail", "manager", "processor", "umi", "bm", "master", "state", "pool", "execute", "test", "dm", "note", "mx", "video", "timer", "pai", "cm", "summary", "mate", "mon", "writer", "handler", "number", "when", " Monitor", "thread", "mr", "watch", "problem", "username", "directory", "tim", "batch", "check", "that", "m", "meter", "stat", "status", "log", "driver", "Monitor", "profile", "minimum", "sim", "info", "monkey", "trace", "man", "report", "network"], "from": ["path", "text", "part", "html", "st", "add", "or", "by", "term", "host", "org", "user", "a", "normal", "From", "link", "address", "old", "id", "as", "no", "reset", "bound", "os", "local", "create", "low", "about", "fr", "with", "pos", "back", "code", "name", "str", "original", "un", "form", "remote", "base", "before", "string", "source", "set", "input", "file", "range", "off", "what", "query", "data", "origin", "url", "rom"], "to": ["path", "output", " too", "on", "top", "html", "term", "eto", "by", "auto", "template", "org", "user", "type", "tt", "tmp", "into", "tu", "address", "toc", "body", "tab", "too", "no", "ta", "token", "o", "id", "os", "size", "test", "two", "pro", "about", "t", "client", "total", "delete", "done", "oto", "name", "number", "tr", " TO", "source", "port", "zero", "table", "value", "file", "po", "range", "target", "data", "format", "TO", "To"], "renameTo": ["denameTarget", "renewTo", "rennameFrom", "rennamFrom", "reenameTO", "reenameBody", "penAMETo", "renamesTO", "renewFrom", "renokeTO", "renenameTarget", "renameFor", "renameBody", "denameTO", "renameT", "renameTO", "renenameTO", "renateFrom", "renokeTarget", "renAMEFrom", "reenameTo", "reenameFrom", "penameto", "reenameTarget", "penameTo", "renadeTo", "renadeFrom", "renAMETarget", "renadeFor", "reameFrom", "renamiTO", "renenameOr", "renowOr", "renAMEFor", "reennameTO", "renamesBody", "renameto", "reameto", "renateTo", "renAMETO", "renamiT", "renamTarget", "renateTarget", "renewBody", "renewTO", "renamiTo", "reennameTo", "reameBody", "denamTO", "rennamto", "renadeto", "renokeTo", "reennameFrom", "reameTo", "denameTo", "denamTo", "renowTo", "renamiTarget", "penAMEFor", "renateTO", "renowTarget", "renateto", "penAMEto", "rennamFor", "rennamTo", "reameOr", "renamesTo", "renameTarget", "renamesFrom", "penameFor", "penAMEFrom", "penameFrom", "rennameTO", "renenameTo", "renamTO", "renenameFrom", "renamTo", "renameOr", "denamTarget", "reameTarget", "rennameTo", "renameFrom", "rennameto", "renenameT", "renokeOr", "reenameOr", "reameTO", "denamT", "renAMEto", "renamT", "renowTO", "reennameTarget", "renAMETo", "renenameBody", "denameT", "rennameTarget"], "ftpClient": ["fttpAPI", "ftwpAPI", "ftpcclient", "ftwpClient", "afttpClient", "aftcpClient", "fttpEntry", "ftpcConnection", "ftwpControl", "fttpClient", "ftcpStore", "aftcpStore", "ftlpConnect", "aftpClient", "ftpConnection", "ftpConnect", "ftcControl", "ftapAPI", "afttpConnect", "ftcpclient", "aftcpControl", "ftphpClient", "ftcClient", "ftpclient", "ftlpClient", "aftcpEntry", "aftpAPI", "ftpiClient", "ftPControl", "fttpPlayer", "ftapControl", "aftpPlayer", "ftpcClient", "fttclient", "aftPClient", "ftpControl", "afttpRemote", "aftpStore", "fttpRemote", "aftpConnection", "aftcpConn", "aftpConnect", "aftpEntry", "ftPConnection", "aftcpclient", "aftpRemote", "ftpiControl", "fttClient", "ftcpEntry", "fttRemote", "ftpcPlayer", "ftpEntry", "aftPControl", "ftlpclient", "aftpConn", "afttpConnection", "ftpStore", "ftwpclient", "aftPclient", "fttpConnection", "afttpAPI", "ftcpConnect", "ftpPlayer", "ftcpRemote", "fttpclient", "aftpControl", "ftcclient", "ftcpPlayer", "ftpAPI", "ftpConn", "ftpiclient", "fttConn", "ftcpClient", "fttpStore", "afttpControl", "ftphpclient", "ftcpConn", "fttpConn", "fttpControl", "ftpRemote", "ftcpConnection", "ftapClient", "fttpConnect", "ftcpControl", "ftapStore", "aftpclient", "ftPclient", "afttpclient", "ftPClient", "ftapclient", "afttpPlayer", "ftphpEntry"], "ftpHolder": ["ftphoster", "ftphholder", "ftpHeander", "ftPHholder", "ftcpHaver", "ftpNholder", "ftPHander", "ftpHander", "ftpHaver", "ftphaver", "ftcpHoster", "ftpNoster", "ftphander", "ftpHoster", "ftpHeoster", "ftcpHolder", "ftPHoster", "ftpHeolder", "ftcpHholder", "ftpHeholder", "ftpNaver", "ftpholder", "ftPHolder", "ftpNolder", "ftpHholder"], "iter": ["ser", "list", "ite", "per", "ator", "counter", "iner", "it", "valid", "Iter", "loop", "orient", "ver", "inv", "iterator", "altern", "test", "er", "oper", "inner", "store", "writer", "impl", "reader", "ait", "inter", "coll", "ipper", "thread", "ptr", "tr", "ter", "ir", "other", "upper", "ner", "mem", "former", "itter", "ne", "actor", "exp", "walker", "cer", "outer", "enter", "Iterator", "order"], "element": ["field", "ment", "Element", "style", "message", "cell", "model", "lements", "instance", "member", "section", "button", "peer", "worker", "item", "detail", "attribute", "manager", "address", "environment", "variable", "folder", "ele", "iterator", "letter", "relation", "test", "er", "component", "le", "e", "pair", "lem", "atom", "module", "xxx", "number", "container", "event", "sequence", "record", "result", "activity", "entry", "former", "object", "action", "air", "match", "actor", "option", "document", "info", "data", "lement", "append", "finder", "search", "empty", "elt", "editor", "article"]}}
{"id1": "14324112", "id2": "17558353", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"innerProcess": ["originalSelect", "originalprocess", "innerprocess", "innerRender", "inlineSelect", "originalRender", " innerSelect", "inlineProcess", "inlineprocess", "inlineRender", "originalProcess", "innerSelect", " innerprocess", " innerRender"], "curi": ["cophi", "crudi", "crui", "Cumi", "covoid", "cumi", "acuri", "lcvoid", "wri", " cumi", "dumi", " cudi", "diri", "cdri", "uncaddress", "acumi", "rcri", "catphi", "luri", "mcurl", "cury", "catury", " caddress", "couri", "cdu", "ctui", "acri", "lcri", "coumi", "mciri", " citi", "acuni", "crdu", "rcuri", "Couri", "cvoid", " couri", "wiri", "Cuni", "curl", "liri", "mcuni", "ctumi", "cphi", "achtml", "mcumi", "cdui", "Cri", "Cui", "Ciri", "Curl", "catumi", "uncuri", "rcui", "ctiri", "ctdu", "catuni", "cui", "Caddress", "mchtml", "caturi", "cri", "lcui", "cathtml", "uncdu", "cori", "lui", "chtml", "Curi", "coury", "ciri", "cdumi", "cudi", "wdu", "duri", "wuri", "cruri", "lri", "lcdu", "durl", "lcury", "uncri", "Cdu", "lcudi", "lcuri", " cdu", "lcphi", "cduri", "mcuri", "cturi", " curl", "citi", "caddress", " cri", "catvoid", "lciti", "rcouri", "ctiti", " cui", " ciri", "ctri", "cuni", "couni", "cdurl"], "maxsize": ["axSize", "MAXsize", "maxlength", " maxbytes", "MAXlength", "minspace", "maxSize", " maxSize", "maxlen", "maxnumber", " maxize", " maxSIZE", "mxspace", "mxSize", "Maxbytes", " MAXlength", "axlen", "MAXnumber", " maxspace", "maxbytes", "Maxlen", "axsize", "axSIZE", "axize", "maxize", " maxlen", " MAXnumber", "mxsize", "minSIZE", "Maxize", "minSize", "axbytes", "MaxSize", "maxspace", "Maxsize", "MAXSize", " maxnumber", "maxSIZE", "minsize", "mxSIZE", "MaxSIZE", " maxlength", " MAXsize", " MAXSize"], "regexpr": ["recreps", "fregexPR", "reewexpr", "regexvr", "relyrepl", "reewpr", "fregdvr", "resexexpr", "consexprop", "fregexpro", "reewrepl", "regexexpr", "repexpr", "replexPR", "resexrepl", "reexvr", "repatternpt", "repexpro", "fregexexpr", "bregexps", "replexpr", "fregdpt", "reexper", "relyprop", "reqexpr", "resexpr", "reqpr", "congexprop", "congexrepl", "recreexpr", "repatternper", "reewprop", "fregexpt", "bregexer", "regdpt", "regexpro", "congexpr", "relypr", "regexprop", "fregexper", "regdvr", "repatternpr", "rexPR", "reqps", "reqer", "frepexpr", "frepexpro", "recrepr", "reexpr", "reexexpr", "resexprop", "regexps", "reexer", "reexps", "fregdper", "regexper", "reexpt", "fregexvr", "brecreexpr", "repexexpr", "fregdpr", "regexPR", "replexexpr", "bregexpr", "brecreer", "repexPR", "congexexpr", "consexpr", "rexexpr", "regexpt", "replexpro", "rexpr", "bregexexpr", "relyexpr", "brecreps", "consexrepl", "consexexpr", "frepexPR", "regdpr", "brecrepr", "recreer", "regdper", "fregexpr", "rexpro", "frepexexpr", "regexrepl", "repatternvr", "regexer"], "cs": ["nc", "ims", "ours", "ls", "ms", "es", "cus", "sels", "gs", "wcs", "cks", "bs", "sc", "ss", "ds", "ws", "qs", "ars", "its", "css", "ces", "cms", "CS", "ics", "ps", "rs", "Cs", "js", "ns", "acs", "ks", "sts", "ats", "cp", "ctr", "unes", "mr", "fs", "gc", "acts", "ctx", "cn", "cc", "csv", "icks", "caps", "cf", "ts", "cas", "c"], "digest": ["dester", "Digse", "digist", " digse", "diger", "Digester", "Digest", "digested", "signum", "Diger", "ddest", "ddester", "shaested", "der", "digum", "Digum", "ddist", "shase", "hashest", "hashse", "hashester", "dist", "digse", "dest", "Digested", "signest", "Digist", " diger", "digester", "shaest", " digester", "shaum", "signested", "signse", "dder", "hasher"], "s": ["ims", "text", "strings", "ls", "ms", "es", "x", "j", "n", "a", "gets", "is", "des", "b", "sq", "f", "gs", "simple", "p", "ss", "ds", "y", "o", "h", "ws", "qs", "os", "stats", "conv", "t", "ps", "v", "js", "ns", "less", "sts", "ats", "str", "ts", "w", "l", "fs", "string", "i", "sb", "r", "S", "c"], "m": ["message", "ms", "model", "n", "arm", "vm", "b", "f", "tm", "em", "nm", "p", "h", "mol", "ym", "mm", "dm", "mt", "M", "mi", "rm", "t", "sm", "v", "cm", "fm", "g", "d", "w", "mr", "l", "md", "span", "mod", "gm", "match", "i", "mo", "r", "mat", "c"]}}
{"id1": "810342", "id2": "7118860", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["DoDateFix", "doVersionsCheck", "doLicenseUpdate", "DoVersionUpdate", "doVersionscheck", "doDateFix", "doDateUpdate", "doVersionsUpdate", "doLicenseFix", "DoVersionFix", "DoDateUpdate", "doDatecheck", "doVersionUpdate", "doLicenseCheck", "doVersionFix", "DoVersionCheck", "doDateCheck", "DoDatecheck", "doVersionsFix", "doLicensecheck", "doVersioncheck", "DoDateCheck", "DoVersioncheck"], "view": ["buffer", "http", "self", "update", "html", "window", "model", "block", "cell", "iew", "open", "controller", "manager", "see", "review", "q", "console", "util", "row", "cv", "views", "help", "VIEW", "subject", "client", "server", "v", "browser", "wrapper", "component", "call", "this", "tree", "doc", "index", "hl", "engine", "get", "page", "form", "eye", "print", "blade", "check", "input", "View", "tv", "file", "table", "show", "web", "document", "query", "display", "context", "layout", "out", "host", "widget", "image", "report"], "url": ["path", "http", "json", "html", "ls", "location", "sl", "org", "bel", "link", "b", "lb", "Url", "f", "address", "ur", "ul", "socket", "URL", "id", "rel", "github", "pl", "ssl", "uri", "dl", "nl", "loc", "client", "v", "browser", "gl", "null", "str", "mount", "ll", "l", "char", "string", "lr", "rl", "language", "file", "date", "log", "web", "oul", "r", "host", "hl"], "in": ["IN", " IN", "gin", "din", "asin", "init", "ln", "n", "rin", "is", "vin", "b", "sin", "f", "body", "ain", "inc", "ins", "inner", "reader", "stream", "isin", "l", "kin", "In", "input", "source", "file", "i", "mn", " din", "info", "inn", "out", "mat", "inf", "cin"], "bin": ["buffer", "cos", "binary", "din", "gin", "con", "by", "ln", "nb", "abin", "spin", "bed", "rin", "sin", "b", " Bin", "loader", "bn", "local", "bl", "ebin", "win", "pipe", "buff", "bur", "len", "bg", "inner", "bi", "mon", "reader", "stock", "lib", " bins", "conn", "mem", "obin", "file", "ran", "sam", " din", "inn", "out", "thin", "rb", "cache", "cin"], "line": ["path", "field", "style", "load", "text", "ide", "part", "ls", "cell", "lin", "block", "ln", "se", " Line", "section", "lo", "eline", "link", "lane", "body", "no", "state", "cat", "sample", "row", "col", "frame", "lines", "channel", "el", "liner", "le", "code", "inline", "ine", "store", "LINE", "ice", "one", "l", "level", "page", "char", "err", "record", "entry", "string", "base", "point", "print", "iter", "port", "file", "log", "job", "range", "comment", "chain", "trace", "cmd", "column", "word", "Line"], "version": ["update", "ion", "description", "iso", "volume", "type", "versions", "title", "Version", "major", "ver", "latest", "usage", "test", "feature", "client", "resource", "video", "spec", "v", "browser", "tag", "translation", "VERSION", "release", "river", "key", "vision", "name", "index", "number", "serial", "position", "scale", "virtual", "license", "sequence", "form", "VER", "command", "project", "string", "hash", "status", "date", "python", "value", "match", "vers", "language", "software", "info", "format", "image"], "build": ["style", "load", "binary", "builder", "db", "update", "bor", "add", "dev", "last", "link", "hold", "b", "built", "arch", "ver", "old", "latest", "make", "util", "test", "install", "use", "th", "tag", "fail", "ship", "release", "where", "be", "dist", "unit", "ward", "building", "other", "round", "lib", "print", "project", "struct", "hash", "date", "boost", "match", "log", "Build", "ble", "work", "full", "develop", "bug", "uild"]}}
{"id1": "62362", "id2": "6501291", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"convert": ["consverting", "converted", "converts", "Conversion", "converting", "compversion", "CONverting", "conprocess", "compprocess", "CONversion", "consversion", "consVERT", "unverted", "compverts", "CONfer", "ConVERT", "CONVERT", "Converting", "unprocess", "unvert", "unversion", "Converted", "unverts", "compvert", "conversion", "Convert", "conVERT", "unfer", "confer", "Conprocess", "Converts", "consvert", "CONvert", "CONverted", "Confer"], "src": ["path", "ser", "http", "attr", "st", "orig", "addr", "RC", "config", "SOURCE", "img", "pkg", "sys", "rx", "sin", "ur", "ource", "sc", "rel", "rc", "its", "scan", "scene", "from", "ebin", "buster", "uri", "ins", "loc", "filename", "Source", "rs", "iv", "rest", "dist", "req", "str", "stream", "upload", "txt", "href", "cont", "sit", "sr", "source", "input", "file", "cc", "ipl", "usr", "func", "inst", "s", "url", "start", "host", "hl", "sq", "SourceFile", "cur"], "dest": ["disk", "gin", "est", "orig", "img", " Destination", "dat", " orig", "dir", "test", "foreign", "write", "dist", " destinations", "txt", " destination", "result", "Dest", "tif", "source", "port", "table", "target", " dst", "mat", "temp", "rest", " Dest"], "in": ["IN", "din", "st", "rin", "is", "b", "as", "sql", "en", "io", "from", "ind", "ins", "ar", "el", "up", "bin", "serv", "inner", "reader", "d", "stream", "isin", "r", "l", "In", "input", "source", "m", "file", "i", "inn", "res", "inf", "ad", "cin"], "p": ["vp", "dp", "P", "pm", "per", "part", "ping", "j", "rep", "it", "pkg", "b", "prot", "f", "tp", "pg", "lp", "parser", "wp", "pa", "h", "fp", "pl", "pro", "er", "t", "op", "pt", "ps", "pre", "at", "g", "ap", "pb", "cp", "d", "post", "l", "pc", "c", "pe", "pd", "m", "ph", "parse", "i", "sp", "pi", "py", "pers", "jp", "php", "r", "pp"], "ds": ["loads", " ads", "workers", "ports", "bs", "iffs", "ss", "its", "aws", "dt", "obs", "lists", "yes", "ils", "dh", "ads", "terms", "ats", "nas", "dds", "tes", " dd", "db", "vs", " des", "des", "tp", "ws", "uds", "qs", "hs", "cs", "dl", "outs", "ks", "dd", "points", "pd", "edes", "ls", " d", "sd", "gs", " DS", "cks", "os", "Ds", "DS", "dates", "tests", "rs", "ags", "ods", "gd", "scripts", "d", "docs", "ands", "els", "ras", "ts", "dp", "posts", "drivers", "dos", "ys", "xs", "eds", "amps", "ps", "tags", "mys", "js", "ns", "sts", "df", "di", " os", "s", "eps", "hd", "sets"], "format": ["output", "path", "style", "top", "shape", "template", "it", "type", "title", "filter", "ct", "f", "id", "pretty", " Format", "size", "sche", "lat", "mt", "feat", "feature", "t", "Format", "spec", "mode", "fc", "fm", "tag", "settings", "at", "module", "version", "ats", "MAT", "unit", "name", "l", "policy", "form", "source", "set", "status", "table", "file", "parse", "pi", "cf", "layout", "act", "mat", "pattern"], "hasPixelData": ["hasFrameData", "HaspixelDATA", "HasPixelDATA", "HasPixelData", "hasixelDATA", "hasPixeldata", "hasixeldata", " hasPixelDATA", "hasPixelDATA", "haspixelData", "HasPixeldata", "Haspixeldata", " hasPixeldata", "haspixeldata", "hasFrameDATA", "haspixelDATA", "HaspixelData", "hasixelData", "hasFramedata"], "inflate": ["Inflated", "infolated", " invalidate", "Informate", "inFLate", " invalidicate", "invalidate", "inFLated", "Informated", "inflicate", "invalidicate", "informocate", "inflat", "invalidocate", "Inflate", "inflATE", "inflated", " inflicate", " inflATE", "informat", "informate", "Informat", "incelocate", "inFlate", "Informocate", "Inflat", "incelicate", "infolocate", "incelate", "inFlATE", "inFlocate", "inFLat", "inFLocate", " invalidATE", "incelATE", "infolate", "Inflocate", "informated", "invalidATE", "infolat", " inflocate", " invalidocate", "inflocate", "inFlicate"], "pxlen": ["xyln", "xylength", "mxdec", "packln", "packfun", "tmplen", "phplen", "mxlength", "cplength", "packlength", "pexls", "mmlength", "pexlen", "pxdec", "pixelfun", "pexfun", "tmpln", "mxlen", "pixellength", "pixellen", "pxden", "mmln", "xplen", "cplen", "packlen", "packls", "mmlen", "pixells", "pxls", "pxfun", "phplength", "phpln", "pexln", "pexlength", "pexden", "xplength", "pxlin", "mmlin", "phpdec", "pxlength", "xpden", "xpln", "tmplength", "cpden", "pxln", "packdec", "xylen", "tmplin", "cpln", "xylin", "mxln"], "out": ["output", "gr", "gov", "prefix", "init", "ln", "Out", "user", "msg", "sys", "pretty", "inv", "aos", "dir", "io", "ex", "outs", "crit", "client", "up", "cfg", "ou", "group", "writer", "store", "name", "inter", "screen", "sum", "obj", "net", "err", "conn", "print", "OUT", "log", "res", "outer", "cmd", "temp", "list"]}}
{"id1": "11484416", "id2": "149935", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" movefile", "movefile", "copyImage", " moveDirectory", "moveImage", "MoveDirectory", " moveImage", "MoveImage", "moveDirectory", "Movefile", "copyDirectory", "copyFile", "copyfile", "MoveFile"], "orig": ["Original", "im", "internal", "Origin", "or", "init", "org", "img", "ret", "ie", "tmp", "ip", "proxy", "old", "raw", "rc", "inv", "clip", "prop", "create", "coord", " ORIG", "ex", "created", "lim", "existing", "src", "original", "dest", "ord", "good", "imp", "base", "copy", "ra", "iter", "def", "ori", "exp", "origin", " original", "Orig", "dom", "act", "temp", "was", "cur"], "target": ["output", "path", "top", "replace", "template", "touch", "it", "tile", "ret", "build", "sys", "tmp", "arget", "Target", "rel", "local", "test", "t", "png", "parent", "src", "null", "next", "goal", "dest", "mac", "base", "source", "gt", "copy", "table", "file", "match", "format", "origin", "out"], "buffer": ["output", "message", "Buffer", "binary", "history", "face", "window", "password", "block", "buf", "phrase", "button", "header", "available", "bar", "attribute", "filter", "variable", "read", "sample", "bb", "queue", "buff", "length", "engine", "stream", "bytes", "screen", "char", "bank", "bridge", "page", "sequence", "print", "line", "batch", "limit", "base", "mem", "iter", "table", "command", "comment", "stack", "chain", "document", "data", "scroll", "memory", "display", "paste", "cache"], "bread": ["rain", "four", "spoken", "bb", "stay", " breadth", "eric", "less", "bridge", "level", "ig", "ble", "web", "scroll", " Bread", "bad", "beck", "broken", "fine", "lf", "bn", "bold", "give", "shield", "READ", "bi", "wei", "jing", "bush", "don", "bc", "print", " barely", "corruption", "brow", "brew", "inn", "oug", "ful", "leen", "score", "bishop", "rew", "billion", "iber", "rik", "bel", "bill", "fred", "nob", "uckle", "gear", "good", "bird", "cake", "knife", "rown", "bled", "middle", "fee", "piece", "boat", "fan", "read", "neum", "eb", " ribs", "robe", "beat", "log", "blow", "crafted", "wake"], "fis": [" fi", "ufos", " fiss", "biss", "dis", " fia", "bos", "bis", " fris", "fiss", "Fis", "fi", "frei", "Fiss", "freia", "bi", "Fos", "freis", "liss", "ufris", "los", "ufiss", "ufis", "Fris", "di", "dia", "fia", "li", "fris", "lis"], "fos": ["toos", "ooses", "tis", "oos", "voos", " foses", "fus", "vus", "eis", "Fis", "eoes", "eoos", " foes", "pos", " foos", "toes", "vos", "Foses", "pus", "poes", "Fos", "foes", " fus", "Fot", "tos", "ooes", "fot", "foos", "Foos", "oot", "foses", " fot", "Foes", "voes", "poos", "eos"]}}
{"id1": "20208819", "id2": "17286898", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"hash": ["message", "update", "password", " sum", "Hash", "sign", "sha", "id", "h", "read", "uri", " hashing", "tag", "run", " fingerprint", "code", "key", "name", "dump", "get", "sum", "print", "check", "value", "render", "format", " Hash"], "input": ["output", "buffer", "message", "text", "password", "prefix", "hello", "config", "valid", "example", "q", "raw", "p", "accept", "sample", "lat", "Input", "current", "request", "this", "bit", "null", "char", "sequence", "form", "command", "string", "source", "select", "value", "active", "data", " inputs", "url", "in", "out", "empty", "image", "pattern"], "algorithm": ["aloch", "arabet", "alphabet", "validgo", "alphoch", "alabet", "validometry", "assometry", "algo", "assabet", "alometry", " Alabet", " Algorithm", "alphgo", "argorithm", "Algorithm", "validabet", " Aloch", "Aloch", "arometry", "assgo", "validgorithm", "assgorithm", "alphgorithm", "argo", "Alabet", "Algo", " Algo"], "dig": ["alg", "ve", "deg", "db", "add", "nd", "sd", "des", "bd", "od", "del", "Dig", "grad", "dat", "cd", "rip", "enc", "dir", "desc", "ind", "rd", "dep", " Dig", "dh", "cong", "cr", "g", "ld", "dd", "d", "fun", "dim", "comm", "dec", "dash", "round", "md", "mod", "df", "find", "pers", "plug", "div", "fin", "her", "ng", "de"], "result": ["output", "out", "proc", "part", "reason", "description", "mark", "prefix", "term", "user", "ret", "response", "currency", "product", "dat", "make", "rc", "complete", "region", "ral", "create", "relation", "true", "answer", "use", "created", "current", "up", "total", "wrapper", "continue", "component", "summary", "run", "this", "pair", "mate", "group", "next", "position", "event", "pixel", "print", "date", "match", "render", "comment", "results", "br", "profile", "join", "display", "success", "res", "r", "report", "Result"], "digest": ["Digse", "digist", "displaytest", "displayEST", "displayest", "Digest", "digested", " digested", "hasate", "Digate", "equgest", "displayested", "digenge", "equse", "digtest", "equested", " digenge", " digEST", " digate", "hasested", "equest", "hasest", "digate", "DigEST", "definedest", "dist", "diggest", "dest", "displaygest", "Digested", "digse", "digEST", "Digist", "definedse", "Digtest", "dgest", " digtest", "dested", "Digenge", "hasenge", "definedested", "displayist", "Diggest", "definedgest"], "hex": ["ch", "alpha", "json", "rex", "html", "tex", "term", "x", "ape", "des", "pex", "xf", "nuts", "percent", "raw", "wh", "prop", "h", "alph", "row", "ex", " Hex", "sex", "solid", "comp", "key", "sh", "index", "serial", "char", "form", "print", "hist", "check", "def", "utf", "tx", "iter", "ph", "zero", "oct", "exp", "https", "sv", "full", "com", "hw", "hl", "color", "zip"], "i": ["multi", "im", "zi", "x", "j", "n", "phi", "it", "ai", "ini", "a", "ic", "ri", "ui", "me", "f", "iu", "id", "y", "io", "ci", "mi", "ind", "ki", "uri", "conv", "ii", "qi", "v", "gi", "e", "hi", "g", "ti", "bi", "ji", "index", "si", "I", "k", "ei", "print", "batch", "m", "status", "xi", "cli", "z", "di", "pi", "ij", "info", "ip", "li", "\u0438", "ix"], "u": ["U", "eu", "cu", "unsigned", "uni", "user", "pu", "uc", "ui", "ur", "b", "ul", "um", "tu", "f", "iu", "su", "q", "util", "h", "num", "au", "bu", "t", "uj", "up", "v", "ou", "uu", "nu", "hu", "uv", "d", "uid", "ue", "you", "c", "uint", "us", "mu", "fu", "ut", "lu"], "highCount": ["hiCast", "highPtr", " highFlag", "lowCast", "highFlag", "higherAmount", "highLength", "highAmount", "higherCount", " highCode", "HighCount", "highcount", " highcount", "lowFlag", " highPtr", "Highcount", "HighCode", "highercount", "lowLength", "topCode", "HighPtr", " highLength", "topCount", "highCast", "lowcount", "highCode", "topcount", "hiFlag", "hiLength", "hiCount", "topPtr", "higherCast", " highAmount", " highCast", "lowAmount"], "lowCount": ["lowButton", "ownButton", "littleCounter", "lowCounter", "lowCold", " lowButton", "highLength", "littleLength", "ownSum", "midCold", "lowSum", "midLength", "highCountry", " lowSum", "ownCount", "midCountry", " lowCold", "midCounter", "midCount", "lowLength", "littleCount", "littleCountry", "midSum", "ownCold", "lowCountry", "midButton", "highCounter"]}}
{"id1": "693636", "id2": "732800", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createThisProduct", "createZeroProduct", "createEmptyTransaction", " createEmptyTransaction", " createNewProduct", "createZeroTransaction", "createNewProduct", "createThisCart", "createNewOrder", "createNewCart", " createEmptyProduct", "createEmptyProduct", "createThisTransaction", "createNewTransaction", "createZeroOrder", " createNewCart", "createEmptyOrder", " createEmptyOrder", " createNewTransaction", "createThisOrder", "createZeroCart", " createNewOrder"], "SHOPPING_ID": ["SHOPPOTINGIDs", "SHOPPINGPNUM", "SHOPPINGPID", "SHOPPINGITNUM", "SHOPPOT_IDs", "SHOPPINGPUID", "SHOPPINGIDIDS", "SHOPPINGINGId", "SHOPPAP_UID", "SHOPPING_id", "SHOPPINGINGNUM", "SHOPPTINGIDVID", "SHOPPING_NUM", "SHOPPTING_NAME", "SHOPPINGIDURL", "SHOPPINGVALid", "SHOPPINGIdID", "SHOPPINGVALUID", "SHOPPINGIdVID", "SHOPPING_VID", "SHOPPOT_ID", "SHOPPING_Id", "SHOPPOTINGID", "SHOPPAP_Id", "SHOPPINGPIDs", "SHOPPINGIdNAME", "SHOPPIP_UID", "SHOPPINGITID", "SHOPPAP_IDS", "SHOPPING_IDs", "SHOPPINGIDNAME", "SHOPPAP_ID", "SHOPPING_UID", "SHOPPINGVALID", "SHOPPINGITIDs", "SHOPPTING_URL", "SHOPPINGINGIDs", "SHOPPINGINGID", "SHOPPING_IDS", "SHOPPOT_NUM", "SHOPPINGITUID", "SHOPPING_URL", "SHOPPOTINGNUM", "SHOPPING_NAME", "SHOPPTING_VID", "SHOPPTING_ID", "SHOPPTINGIDNAME", "SHOPPINGIDId", "SHOPPINGIDVID", "SHOPPTINGIDURL", "SHOPPTINGIDID", "SHOPPOT_UID", "SHOPPINGIDID", "SHOPPINGIDUID", "SHOPPINGIdURL", "SHOPPOTINGUID", "SHOPPIP_id", "SHOPPIP_ID", "SHOPPINGINGUID", "SHOPPINGINGIDS"], "con": ["ch", "bo", "nc", "cos", "const", "Con", "connect", " conn", "db", "ln", "cal", "cover", "Conn", "open", "mc", "connection", "ct", "pg", "ain", "can", "pool", "pen", "rc", "cat", "col", "en", "re", "conv", "ex", "client", "win", "soc", "xc", "fc", "cp", "cons", "pc", "un", "conn", "cont", "gc", "ctx", "cn", "CON", "cc", "bon", "po", "ran", "ctrl", "co", "ren", "cf", "com", "conf", "ca", "dial", "coll", "c", "cur"], "insert_cart": ["insertptcod", "insertTheprogress", "insert_Cart", "insert___cart", "insertPTcod", " insert2cod", "insert2pt", "entryMemarticle", " insert2start", "entry_art", "insert2quant", "insert2Cart", "insert_controller", "insert_start", "import___controller", " insert_pt", "insertMemarticle", "import___pt", "insertThearticle", "insert_art", "insertPTcart", " insert2cart", "entryMemcart", "entry_progress", " insert2pt", "insertPcart", "insert_quant", "insertptquant", "insertingart", "insertPTquant", "insertMemcart", "insert2progress", "insert___art", "insertingcart", "insertMemprogress", "insertingstart", " insert2art", "import_Cart", " insert_art", " insert_cod", "import_pot", "import_cart", "insert___controller", "insert_article", "insertPTart", "insert_pt", "insertingpt", "import_pt", "insert_progress", "entry_article", "import_controller", "insert2cart", "insertptcart", "insertTheart", "insert2art", "insertPcontroller", "entryMemart", " insert2quant", "insert2cod", " insert_quant", "insert___pt", "import_art", "import___cart", "entry_cart", "insert2pot", "insertPart", "insertThecart", "entryMemprogress", "insertPpt", "import___art", "insert2controller", "insert2article", "insert_pot", " insert_start", "insertMemart", "insert_cod", "insert2start", "insertptart"]}}
{"id1": "6840241", "id2": "13657103", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["load", "close", "save", "replace", "sync", "cover", "link", "move", "transfer", "clip", "read", "size", "create", "cat", "slice", "map", "call", "delete", "write", "cop", "cp", "share", "gc", "print", "Copy", "system", "clone", "opy"], "source": ["style", "session", "site", "se", "template", "SOURCE", "ie", "shell", "body", "master", "ource", "sql", "state", "local", "sample", "ce", "size", "from", "subject", "ins", "resource", "pse", "Source", "scope", "spec", "wrapper", "parent", "src", "store", "inner", "reader", "si", "stream", "base", "sr", "input", "status", "iter", "select", "table", "sp", "info", "origin", "context", "start", "inside", "image", "cache"], "sink": ["sinker", "Sink", "asender", "asink", "slender", " sue", "Sinker", "slink", "ssink", "ssource", "Sender", " sinker", "Source", "asource", "ssender", " sender", "asinker", "sender", "Sue", "sue", "slue", "ssinker", "slource"]}}
{"id1": "20675046", "id2": "1122585", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "label": 0, "substitutes": {"getContent": ["GetBody", "setContent", "getContents", " getText", " getBody", "GetContents", "getText", "getBody", "setText", "GetText", "setBody", "setContents", "GetContent", " getContents"], "context": ["output", "message", "application", "text", "TEXT", "template", "config", "type", "processor", "state", "parser", "channel", "resource", "content", "component", "event", "command", "base", "input", "object", "ctx", "tx", "value", "Context", "chain", "document", "data", "network"], "ctxAttrName": ["ctxAttrKey", "ctxAddrname", "ctxAttrsName", "ctxAttrsValue", "ctxAttribKey", "ctxAddmname", "ctxAttribName", "ctxAddrValue", "ctxAttribValue", "ctxAttrname", "ctxAttrsKey", "ctxAttmName", "ctxAttmKey", "ctxAddrName", "ctxAddrKey", "ctxAddmValue", "ctxAttmValue", "ctxAddmKey", "ctxAttribname", "ctxAttmname", "ctxAddmName", "ctxAttrsname"], "ctxAttrValue": ["ctxAttrbvalue", "ctxAttmType", "ctxAttrdName", "ctxAttrType", "ctxAddrvalue", "ctxDetrVal", "ctxAttrdValue", "ctxAddrElement", "ctxAddrValue", "ctxAddrbName", "ctxAttribValue", "ctxAttribData", "ctxAttrbValue", "ctxAttrdvalue", "ctxAttuData", "ctxAttmName", "ctxAttmVal", "ctxAttrVal", "ctxAttmData", "ctxAttrbName", "ctxDetribType", "ctxAddrbvalue", "ctxAttribVal", "ctxAttrbElement", "ctxAddrName", "ctxDetribValue", "ctxAddrbElement", "ctxAttmvalue", "ctxAttuType", "ctxAttrData", "ctxAttribType", "ctxDetrData", "ctxAttmValue", "ctxAttrElement", "ctxAddrbValue", "ctxDetrType", "ctxDetribVal", "ctxAttmElement", "ctxAttuValue", "ctxDetrValue", "ctxDetribData", "ctxAttrdElement", "ctxAttrvalue", "ctxAttuVal"], "url": ["path", "http", "ls", "location", "sl", "build", "link", "ur", "b", "Url", "ul", "address", "URL", "rel", "io", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "client", "browser", "ref", "null", "name", "mount", "str", "ll", "external", "service", "l", "char", "base", "lr", "rl", "file", "log", "sb", "web", "cert", "handle", "hl"], "reader": ["buffer", "runner", "builder", "per", "shape", "ator", "rar", "volume", "open", "peer", "ri", "user", "handle", "rx", "loader", "parser", "read", "row", "iterator", "test", "io", "sample", "older", "er", "uri", "READ", "resource", "length", "inner", "writer", "readable", "reading", "handler", "dd", "stream", "rot", "rr", "upper", "Reader", "check", "input", "source", "iter", "rl", "file", "driver", "ro", "info", "data", "r", "dra", "image"], "available": ["played", "buffer", "missing", "loaded", "added", "valid", "enough", "visible", "released", "supported", "Available", "used", "installed", "count", "free", "acity", "usage", "can", "alloc", "no", "read", "locked", "checked", "bound", "produced", "num", "end", "ed", "enabled", "created", "current", "total", "needed", "ready", "length", "release", "all", "ap", "readable", "required", "written", "opened", "index", "position", "bytes", "good", "ocated", " unavailable", "capacity", "selected", "availability", "active", "max", "i", "sp", "usable", "provided", "full", "out", "allowed", "len"], "contents": ["CONTacts", "contented", "contContents", "Content", "CONTented", "Contents", "Contours", "mintented", " contentials", "contours", "mintents", " contours", "CONTars", "requentials", " contacts", "Contented", "Contentials", "CONTents", "mintars", "requents", "ContContents", "requries", " contries", "Contries", "content", "requours", "Contacts", " contContents", "CONTent", "Contars", "contars", "contentials", " content", "mintent", "contacts", "contries", "CONTContents"]}}
{"id1": "19086952", "id2": "22611968", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createFileResponse", " createUrlResp", " createURLView", " createUrlView", "createURLresponse", "createurlresponse", " createUrlresponse", " createURLResponse", "createurlResp", "createUrlView", "createFileResp", "createurlResponse", "createFileresponse", "createURLView", " createURLresponse", " createURLResp", "createFileView", "createURLResponse", "createUrlresponse", "createURLResp", "createUrlResp", "createurlView"], "url": ["path", "http", "mail", "html", "ls", "location", "org", "build", "bel", "link", "ur", "b", "Url", "address", "URL", "sql", "parser", "pl", "ssl", "uri", "dl", "loc", "nl", "client", "el", "email", "browser", "gl", "call", "str", "mount", "xml", "name", "ll", "get", "l", "char", "base", "string", "file", "domain", "job", "web", "document", "cert", "host", "image"], "connection": ["output", "nc", "message", "session", "connect", "application", "ion", "Connection", "description", "con", "reason", "location", "using", "builder", "close", "config", "window", "open", "callback", "link", "database", "generation", "response", "condition", "processor", "controller", "socket", "self", "usage", "pool", "to", "relation", "creator", "subject", "client", "channel", "current", "server", "writer", "communication", "process", "handler", "number", "position", "thread", "connected", "directory", "remote", "command", "entry", "ctx", "log", "document", "context", "intention", "c", "computer", "network"], "fullPath": ["FullUrl", "fullUrl", " fullPort", " fullpath", " fullName", "fullName", "partialPort", "FullName", "FullPort", "partialName", "partialPath", "FullPath", " fullUrl", "fullPort", "fullpath", "partialpath", "partialUrl", "Fullpath"], "conn": ["ch", "nc", "proc", "connect", "con", "Connection", "cell", "reg", "j", "n", "init", "open", "ct", "pg", "iw", "alloc", "enc", "col", "num", "desc", "conv", "loc", "resp", "cfg", "nt", "ns", "canon", "cb", "cp", "comm", "obj", "connected", "exec", "cont", "ctx", "ann", "oss", "co", "cert", "jp", "res", "cmd", "conf", "Conn", "c", "cur"], "in": ["IN", "on", "din", "gin", "or", "n", "user", "rin", "is", "mc", "and", "body", "sql", "en", "inc", "from", "mi", "ind", "ins", "ma", "bin", "inner", "reader", "stream", "get", "isin", "sum", "In", "input", "m", "file", "i", "inn", "out", "inside", "inf", "ad", "cin"], "length": ["path", "buffer", "message", "load", "history", "text", "shape", "offset", "description", "volume", "phi", "time", "type", "loop", "count", "ength", "address", " Length", "h", "duration", "size", "end", "enc", "frame", "Length", "total", "filename", "impl", "number", "position", "ENGTH", "family", "l", "sequence", "result", "HH", "string", "amount", "padding", "loss", "value", "distance", "width", "data", "height", "left", "len"]}}
{"id1": "19910627", "id2": "4593012", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getData": ["getResponse", " getResponse", "getDATA", "updatedata", "exportData", " getdata", "exportdata", " getDATA", "exportResponse", "updateData", "updateDATA", "exportDATA", "updateResponse", "getdata"], "httpclient": ["Httpparent", "httpscell", " httpcell", "httpconfig", "httpconnection", "httpcell", "Httpclient", "httpsClient", "httpsconfig", "socketclient", "HttpClient", "socketconfig", "socketcell", "socketClient", "httpparent", "httpsparent", "httpsconnection", "httpClient", " httpClient", "ttpclient", "ttpparent", "ttpconnection", " httpconfig", "Httpconnection", "ttpClient", "httpsclient"], "get": ["http", "patch", "add", "init", "open", "force", "gets", "build", "put", "see", "send", "body", "make", "read", "create", "execute", "use", "like", "give", "op", "current", "require", "call", "request", "delete", "g", "pre", "need", "name", "pull", "post", "service", "Get", "got", "check", "GET", "set", "select", "show", "parse", "find", "query", "ge", "start", "handle", "play", "exec", "cache"], "response": ["output", "ve", "message", "application", "function", "json", "description", "block", "open", "example", "connection", "onse", "see", "body", "console", "re", "respond", "answer", "pos", "resp", "resource", "yes", "still", "page", "sequence", "result", "Response", "remote", "entry", "that", "object", "status", "reply", "document", "given", "success", "trace", "res", "successful", "report"], "entity": ["orm", "message", "json", "ity", "model", "voice", "instance", "ent", "type", "detail", "em", "person", "ce", "icon", "resource", "el", "email", "ITY", "component", "le", "e", "eric", "name", "unit", "Entity", "quote", "obj", "event", "result", "pe", "line", "activity", "entry", "details", "object", "comment", "document", "query", "info", "image"], "instream": [" inpod", "Instream", "excase", "outpod", " incase", "inputstream", "inconsole", "inspod", "instack", "instore", "fromcase", " inconsole", "inputconsole", "outconsole", " inStream", "fromstream", "inputproc", "inputStream", " incomplete", "infield", "inStream", "inproc", "incomplete", "outstream", "fromstack", "inpod", "insfield", " inproc", " instack", "outproc", "fromconsole", " infield", "outcomplete", "insStream", "Incomplete", "insstream", "exstack", "outfield", "InStream", "exstream", "outStream", "outstore", " instore", "Instore", "exconsole", "incase"], "responseMessage": ["ResponseValue", " responseValue", " responseText", "responseValue", " responsemessage", "answerMsg", "answerMessage", "ResponseMsg", " responseString", "answerString", "Responsemessage", "ResponseText", "resMsg", " responseMsg", "responseMsg", "responseString", "responsemessage", "ResponseMessage", "resmessage", "responseText", "answerValue", "ResponseString", "resMessage", "resText"]}}
{"id1": "13657527", "id2": "742465", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatasesResult", "getDatisetsStatus", "getDatisetsResult", "getDatasuresResult", "getDatasuresList", "getDatasetsResult", "getDatisetList", "getDatasetList", "getDatasesList", "getDatasuresStatus", "getDatasetsStatus", "getDatisetResult", "getDatisetStatus", "getDatasetStatus", "getDatasesStatus", "getDatisetsList", "getDatasetResult"], "surl": ["sURL", "jslim", "esURL", " suri", "lsUrl", "stsurl", "slim", "lsurl", "sysserver", "sysurl", "sysuri", "jsuri", "ssurl", "ssUrl", " sname", " smail", "suri", "jsurl", "slt", "sserver", "sname", "lsserver", "esUrl", "lslt", "ssURL", "stslt", "sslim", "esname", "stsserver", "lsuri", "sUrl", " sUrl", "smail", "jsUrl", "ssuri", "stsuri", "lsmail", "syslt", "esuri", "esurl"], "datasetsList": ["datassetsList", "datasagesSet", "datasetLock", "datasETSMap", "datasagesList", "datasetGroup", "datarsetSet", "datisetMap", "datisetsMap", "datasetlist", "datarsetsLock", "datmassetsList", "datasetsTable", "datasensList", "datmasetsLock", "datassetsSet", "datasagesTable", "datarsetList", "dataselinesName", "datarssetsLock", "datassetsTable", "datasagesMap", "datasETSName", "datasetsSet", "datasETSGroup", "datasourcesSet", "datarssetsList", "datmassetsData", "datmassetsMap", "datasuresMap", "datasourcesTable", "datarssetsTable", "datarsetsMap", "datasagesData", "datasETSList", "datasetMap", "datassetslist", "datasuresList", "datarsetsList", "datasetsData", "datasourcesLock", "datarsetsSet", "datasetsGroup", "datasetslist", "datmasetsData", "datasetsLock", "dataselinesList", "datasourcesList", "dataselinesGroup", "datmasetsList", "datisetsList", "datasetSet", "datasuresSet", "datmasetsMap", "datasamesSet", "datisetsGroup", "datasenslist", "datmassetsLock", "datarsetMap", "datasamesList", "datassetsData", "dataselinesMap", "datasensMap", "datasagesLock", "datarsetslist", "datarsetlist", "datarssetsSet", "datisetList", "datasetList", "datasetsMap", "datasamesMap", "datasureslist", "datisetsName", "datasetsName", "datassetsLock", "datisetName", "datasetName", "datisetGroup", "datassetsMap", "datarsetsTable", "datasetData", "datasameslist"], "result": ["buffer", "message", "successfully", "description", "first", "menu", "valid", "ret", "detail", "response", "exist", "complete", "folder", "relation", "test", "default", "answer", "contact", "sequence", "record", "form", "details", "set", "def", "status", "table", "comment", "results", "chain", "cert", "search", "success", "found", "res", "there", "successful", "diff", "report", "Result"], "reader": ["field", "buffer", "runner", "ser", "dr", "bo", "per", "rar", "peer", "author", "handle", "via", "body", "rer", "loader", "socket", "parser", "read", "row", "iterator", "test", "older", "rd", "er", "READ", "client", "resource", "liner", "timer", "wrapper", "operator", "river", "inner", "writer", "reading", "handler", "stream", "mr", "rr", "redo", "upper", "Reader", "ner", "roller", "iter", "rl", "layer", "file", "driver", "ro", "range", "query", "r"], "url": ["http", "mail", "ls", "location", "sl", "org", "user", "link", "ur", "Url", "ul", "address", "URL", "loader", "id", "row", "ssl", "uri", "dl", "nl", "client", "resource", "browser", "key", "null", "str", "mount", "ll", "stream", "l", "char", "lr", "rl", "file", "web", "r", "il"], "s": ["series", "strings", "ls", "ms", "abs", "es", "n", "gets", "is", "has", "b", "gs", "bs", "as", "ss", "y", "sql", "ds", "its", "qs", "os", "h", "ws", "hs", "sample", "sw", "cs", "ins", "t", "sym", "ps", "rs", "v", "js", "ids", "ns", "less", "str", "sts", "ats", "ts", "still", "l", "string", "source", "us", "csv", "i", "tes", "sb", "sv", "full", "r", "S", "sq"], "list": ["collection", "ist", "top", "part", "ls", "st", "add", "block", "member", "detail", "ml", "pretty", "pool", "local", "test", "left", "note", "dl", "lists", "all", "group", "ll", "l", "sequence", "form", "cont", "print", "batch", "set", "def", "table", "log", "stack", "chain", "join", "format", "listed", "array", "php", "layout", "LIST", "full", "li", "word", "L", "single"]}}
{"id1": "6470716", "id2": "13657103", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"st": ["ist", "ust", "step", "est", "nd", "se", "stri", "tt", "ST", "stra", "St", "sw", "ost", "std", "ft", "t", "th", "sm", "ast", "stable", "rt", "store", "ld", "sts", "str", "sh", "d", "stream", "service", "sth", "www", "sta", "sn", "ste", "sty", "set", "sp", "inst", "start", "rest"], "url": ["ch", "http", "mail", "html", "ls", "addr", "host", "location", "sl", "abs", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "address", "shell", "URL", "rel", "github", "pl", "ssl", "dl", "uri", "loc", "nl", "client", "el", "browser", "gl", "ref", "null", "impl", "mount", "str", "ll", "fl", "l", "char", "www", "rect", "base", "string", "cl", "file", "domain", "web", "cert", "r", "li", "hl", "rest", "il"], "fis": [" fi", " fiss", "tiss", "tis", "efi", "xfier", "Fais", "fiss", "xfis", "fi", "f\u00eds", "Fis", "flisl", "fier", " fais", "Fiss", "fei", "efis", "fli", "xfi", "flis", "fisl", "feois", "feis", "fais", "Fos", "feier", "fliss", "uf\u00eds", "Fier", "Fi", "fois", "ufisl", "ufi", "ufiss", "tos", " fisl", "ufis", "Fois", " f\u00eds", "tais", "efiss", "ef\u00eds", "xfois"], "zis": [" ziss", " zris", "zhisin", "ozisin", "fisi", "zhis", "zris", "czits", "czis", "zIs", "ozes", "zits", "zipIs", "zipisin", "fiss", " zits", "zisa", " zisi", "zisin", "zipis", "ozisa", "zes", "zenisi", "ozis", "zos", "zipos", "zhes", "ozIs", "czisa", "zeniss", " zos", "fits", "zhIs", "zisi", " zIs", "zenris", "zenis", " zisa", "zipes", "ziss", "zipits", "ozits", "czIs", "fris"], "entry": ["field", "de", "cell", "or", "existent", "member", "se", "ent", "valid", "ie", "link", "tmp", "item", "attribute", "way", "ry", "entity", "row", "ce", "jar", "card", "element", "fr", "nt", "e", "key", "null", "be", "office", "name", "index", "inter", "char", "obj", "event", "result", "record", "form", "line", "source", "def", "log", "match", "zo", "comment", "chain", "info", "system", "sp", "Entry", "out", "enter", "word", "jo", "list", "pattern", "zip"], "count": ["ch", "buffer", "depth", "counter", "add", "cell", "core", "n", "nb", "force", "last", "ct", "read", "size", "end", "num", "ind", "t", "current", "total", "length", "nt", "acc", "call", "Count", "code", "name", "ctr", "index", "number", "char", "ount", "page", "sum", "err", "cont", "base", "batch", "check", "amount", "child", "iter", "cc", "match", "max", "comment", "found", "start", "c", "len"], "data": ["output", "buffer", "message", "text", "json", "reason", "part", "step", "block", "n", "buf", " DATA", "ata", "raw", "dat", "sample", "size", "area", "DATA", "bin", "length", "all", "done", "name", "next", "d", "number", "bytes", "good", "result", "string", "batch", "def", "mem", "source", "table", "value", "mu", "zero", "chain", "format", "out", "image", "cache"], "fos": [" fOS", "fool", "hos", "fol", "Foss", "fooss", "fOS", "fiops", "fops", "foops", "Fos", "wis", "hoss", "Fops", " foss", "hOS", "fios", "his", "foos", "foss", "Fol", "fiol", "woss", "wOS", "wos", "fioss"], "dest": ["output", "est", "nd", "member", "des", "gate", "send", "master", "dat", "transfer", "gest", "cat", "coord", "test", "desc", "pas", "std", "loc", "crit", "pipe", "bin", "foreign", "parent", "nt", "det", "comp", "done", "src", "dist", "writer", "dc", "ptr", "sum", "result", "cont", "Dest", "them", "mem", "source", "trans", "nom", "decl", "exp", "target", "comb", "origin", "out", "usr", "temp", "rest", "way"]}}
{"id1": "1769771", "id2": "23532405", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyLine", "CopyFile", "CopyLine", " copyFiles", "CopyStream", "CopyFiles", " copyLine", " copyStream", "copyLine", "copyStream", " CopyStream", " CopyFiles", " CopyFile", "copyFiles"], "in": ["IN", "on", "din", "gin", "init", "rin", "ini", "is", "ic", "b", "old", "en", "inc", "io", "from", "mm", "ind", "ins", "el", "up", "bin", "inner", "isin", "l", "r", "In", "input", "source", "i", "inn", " input", "inf", "cin"], "out": ["output", "update", "n", "Out", "it", "msg", "b", "p", "o", "to", "os", "io", "help", "ex", "outs", "t", "op", "up", "v", "ou", "serv", "nt", "at", "w", "l", "net", "err", "OUT", "gt", "file", "log", "po", "ot", "s", "res", "c"], "inChannel": [" inCommand", "insideCategory", "intCommand", "sinButton", " inButton", "dinchannel", "inConnection", " inConnection", "cinChannel", "cinRoom", "inScope", "insideChannel", "sinChannel", "ainScope", "inchannel", "InChannel", "inCategory", " inchannel", " inScope", "inChan", "Inchannel", "inRoom", " inChan", "dinChan", "outchannel", "ainClient", " inRoom", "sinCommand", "innButton", "ainChannel", "inCommand", "innClient", "insideScope", "insideClient", "intChannel", "sinClient", "innCase", "innChannel", "outChan", "inCase", "cinCommand", "dinConnection", "dinChannel", "ainCategory", " inCategory", "intChan", "intchannel", "outConnection", "sinRoom", "InChan", " inCase", "sinCase", "InCommand", "inButton", " inClient", "inClient"], "outChannel": ["neSection", "inCh", "outCh", "blockMany", " outCh", "neChan", "aosChan", "blockChannel", "aosMember", "outputManager", "parentChan", "outManager", "blockGate", "inchannel", "blockChan", "inMember", " outchannel", " outGate", "parentGate", "inChan", "aosSection", "parentMany", "outMember", "outGate", "outchannel", "parentChannel", "outputchannel", "inSection", "cnManager", "neMember", "outMany", "outputChan", "cnChan", " outChan", "outChan", "cnChannel", "outputChannel", " outMany", "outSection", " outManager", "outputCh", "neChannel", "aosChannel"]}}
{"id1": "19050432", "id2": "1586662", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["opennamedRes", "opennamingResource", "opennamingClass", "openNumberedStream", "openNestedStream", "openNestedRes", "openNamingClass", "openNamingRes", "openNamingStream", "openNumberedRes", "opennamedClass", "openNumberedResource", "openNamedRes", "openNamedClass", "opennamingStream", "openNestedClass", "openNamedStream", "opennamingRes", "opennamedResource", "openNamingResource", "openNestedResource", "opennamedStream", "openNumberedClass"], "name": ["path", "message", "part", "missing", "description", "password", "prefix", "n", "template", "type", "link", "title", "address", "id", "nm", "p", "local", "size", "use", "uri", "resource", "initial", "filename", "NAME", "ame", "ref", "key", "null", "str", "named", "string", "Name", "file", "value", "names", "search", "full", "url", "alias", "word"], "in": ["IN", "on", "din", "gin", "con", "asin", "n", "oin", "ini", "rin", "is", "vin", "mc", "f", "body", "ain", "as", "pin", "o", "to", "en", "from", "tin", "mi", "pid", "ind", "ins", "login", "up", "bin", "serv", "inner", "impl", "reader", "stream", "isin", "In", "conn", "input", "m", "i", " din", "inn", "out", "conf", "inf", " out", "cin"], "propsURL": ["ProrsURL", "proprNR", "propsURI", "projsUrl", "proPSCH", "PropsURI", "proPSURL", "propertiesURL", "probsurl", "Propsurl", "proppsUrl", "PropsUrl", "progsURL", "prorsURL", "proprsURL", "proprurl", "prorsEL", "progsUR", "PropsNR", "progsurl", "probsUrl", "PropsEL", "ProPSUR", "proppsCL", "propsEL", "proPSCL", "protsUrl", "proPSNR", "PropsUR", "ProPSURI", "propertiesURI", "proppsUR", "projsURL", "proprsCL", "progsCL", "proPSUrl", "proprURL", "probsURI", "PropsCL", "ProPSUrl", "propsSSL", "projsEL", "proppsURL", "progsEL", "PropsSSL", "propsUrl", "proppsCH", "proPSurl", "proPSUR", "prorsUrl", "ProPSCL", "projsUR", "propertiesUR", "propertiesUrl", "proprsUrl", "proPSSSL", "ProPSCH", "ProrsEL", "propsurl", "proppsSSL", "PropsURL", "progsUrl", "protsurl", "probsURL", "propertiesCH", "prorsCL", "progsURI", "propsCL", "propsCH", "prorsUR", "propertiesCL", "protsURL", "ProPSSSL", "propertiesurl", "propsUR", "ProPSurl", "ProrsUR", "protsNR", "propsNR", "ProrsUrl", "protsURI", "proprsUR", "propertiesSSL", "ProPSNR", "ProPSURL", "proPSURI", "PropsCH", "proprUrl"], "urlConn": ["UrlCon", "httpConn", "webconn", "handleCon", "urlconn", "urlInit", "slMem", "urlConnect", "lsInit", "fileMem", "URLConn", "urlMem", "slObj", "lsconn", " urlInit", "lsConnect", " urlconn", "fileConn", "urlConnection", "handleConnect", "slConn", "slCons", "UrlConnect", "handleConnection", "fileObj", "handleConn", "httpMem", "URLConnect", "urlCons", "webConnect", "webConn", "lsConn", "UrlConnection", "URLConnection", " urlConnect", "urlCon", "httpCons", "webInit", "UrlConn", "httpObj", "urlObj", "fileCons", "URLCon"], "httpURL": ["httpsurl", "healthurl", "httpUR", "ttpURL", "HttpURL", "httpDB", " httpDB", "healthUR", "httpsURL", " httpSSL", "httpsUR", "hoverUrl", "Httpurl", "HTTPUrl", "hoverurl", "httpURI", "ttpurl", "HttpUrl", "healthURL", "HttpSSL", "httpSSL", "ttpURI", " httpUrl", "hoverURL", " httpURI", "httpUrl", "HTTPDB", "ttpDB", " httpurl", "healthUrl", "hoverUR", "HTTPURI", "httpsUrl", "ttpSSL", "ttpUrl", "httpurl", "HTTPURL"], "hdrVal": ["hheaderVal", "hdrEl", "hDRVal", "hlrValue", "httpVal", "hDRLen", "hlrLen", " hheaderLen", "hDRVAL", "ohdrVal", "hdrValue", "hheaderEl", " hdrLen", "hheaderVAL", "hlrval", " hheaderval", "hDRval", "hdrVAL", "hheaderval", "httpValue", "HheaderVal", "hDREl", "hDRValue", "httpVAL", "ohDREl", "HdrVal", " hheaderValue", " hheaderVal", "hdrLen", "hlrVal", "hstrVal", " hdrValue", "ohdrEl", "httpEl", "hdrval", "hheaderValue", "hstrEl", "hheaderLen", "HdrEl", "HheaderVAL", "HdrValue", "ohdrValue", "hstrValue", "ohDRVal", " hdrval", "ohDRValue", "HheaderEl", "HheaderValue", "HdrVAL"], "code": ["ch", "message", "text", "reason", "description", "close", "cue", "se", "msg", "type", "header", "response", "color", "currency", "ct", "ck", "count", "body", "id", "state", "no", "rc", "size", "ce", "desc", "mode", "length", "component", "content", "cycle", "key", "cod", "error", "xxx", "magic", "xx", "ode", "index", "number", "codes", "coe", "one", "ack", "ace", "level", "go", "event", "result", "cont", "sec", "check", "string", "status", "zero", "cc", "value", "comment", "coded", "country", "age", "url", "city", "Code", "c", "zip"]}}
{"id1": "7044153", "id2": "5676111", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionToHost", "sendErrorToClient", "sendExceptiontoHost", "sendExceptionToClient", "sendExceptionTOServer", "sendErrorToHost", "sendExceptiontoServer", "sendErrorToServer", "sendExceptionTOHost", "sendErrortoServer", "sendExceptiontoClient", "sendExceptionTOClient", "sendErrortoHost", "sendErrortoClient"], "server": ["ser", "site", "description", "password", "ver", "address", "test", "env", "client", "channel", "v", "serv", "erver", "email", "code", "null", "store", "version", "service", "localhost", "base", "remote", "string", "port", "value", "host", "Server"], "ex": ["rex", "lex", "or", "x", "it", "exc", "eas", "pex", "ext", "ic", "rx", "example", "nex", "Exception", "ry", "except", "exclusive", "test", "re", "Exc", "el", "xc", "ox", "exit", "e", "fail", "hex", "aux", "error", "any", "none", "one", "obj", "EX", "err", "an", "event", "Ex", "expl", "tx", "ix", "ception", "exp", "com", "exe", "wx"], "config": ["text", "password", "ct", "params", "rc", "env", "control", "Config", "auth", "channel", "cfg", "param", "Configuration", "fig", "content", "settings", "debug", "service", "figure", "form", "input", "log", "cert", "context", "conf", "c", "cache"], "prob": ["Prob", "Probj", "Probes", " prbe", "prb", " prbj", "probes", "Probe", "probe", " prb", "prbe", "prbj", "prbes", "probj", " prbes"], "dataSB": [" dataBB", "ataMB", "imageSw", "dataBu", " dataNB", "listMB", " dataBP", "dateSB", "dateBu", "partialBB", "imageBB", "divSB", "defSB", "relationSL", "dataEB", "mapBB", "imageSB", "dataSI", "listEB", "imageSL", "jsonSF", "contentBS", "reasonBS", "keyBB", "relationMB", "divSF", "relationQB", "contentSF", "contentSR", "imageBP", "dataBB", "dataSW", " dataSA", "datWB", "DATASF", "divSN", "debugBB", "cacheSB", " dataRB", "jsonsb", "dataQB", "cacheSM", " dataSw", "defGB", "imageSF", "DATASW", "relationBS", "nextSF", "contentSN", "ataSW", "ataSL", "joinWB", "imageBS", "dataHB", "datSB", "listSB", "dateBS", "divBS", "contentNB", "joinSL", "windowSL", "relationBB", "ataSF", "dataSA", "DATABS", "divBB", "valueSW", "mapBS", " dataBS", "nextBS", "resourceSI", "listBB", "cacheBS", "imagesb", "defBB", "ataSN", "atasb", "datSL", "keySB", "ataEB", "debugSB", "relationNB", "joinsb", "cacheBB", "dataRB", "imageSR", "relationSN", "valueBS", "ataSA", "resourceSF", "imageQB", "jsonSw", "ataSB", "reasonSF", "listSF", " dataSI", " dataSquare", "dataSM", "dataBP", "dataBS", "ataBB", "relationBu", "partialSB", "nextQB", "ataNB", "cachesb", "ataSR", "resourcesb", "mapSB", " dataSW", "joinSF", " dataMB", "dataGB", " datasb", "windowBB", "relationRB", " dataHB", "mapHB", " dataSN", " dataBW", "nextSB", "cacheBW", "divNB", "listSI", "relSW", " dataQB", "resourceSB", "divBW", "windowSF", "imageHB", " dataEB", "mapSN", "DATASB", "relationSquare", "reasonSB", "imageNB", " dataSF", "dataSF", "debugSF", "dataSw", "dataSR", "relBS", "windowSB", "ataWB", "jsonSB", "windowSN", "divSquare", "ataBS", "cacheSF", "dataBW", "nextGB", "nextBB", "relationSF", "partialGB", "windowBS", "dateQB", "relBB", "valueSB", "datMB", "imageSM", " dataSM", "mapSL", "keySL", "mapGB", "defQB", "partialSL", "debugRB", "cacheSA", "dataSL", "ataBP", " dataSL", "relationSB", "dataSquare", "imageSN", "valueBB", "datasb", "reasonSW", "dataNB", "relSB", "dataSN", "ataBu", " dataGB", "listsb", "ataQB", "keyBS", "dataWB", "dataMB", "joinSB", "mapSF", "joinMB", "contentSB"], "trace": ["buffer", "fake", "message", "history", "style", "list", " Trace", "se", "time", "tile", "te", "detail", "tm", "address", "body", "sample", "create", "test", "true", "frame", "mt", "feature", "th", "transform", "stable", "be", "store", "debug", "dump", "stream", "ace", "thread", "span", "tr", "sequence", "temp", "batch", "tty", "table", "log", "race", "profile", "stack", "chain", "range", "comment", "data", "track", "report", "role", "network"]}}
{"id1": "4852691", "id2": "22022715", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"hash": [" mac", " check", "update", " encoding", " sum", "Hash", " text", "sign", " equals", " signature", " key", "id", "h", " hashing", "run", " fingerprint", "code", "hex", " salt", "dump", "sum", " message", "print", "string", " h", " Hash"], "data": ["output", "buffer", "message", "text", "json", "password", "space", "hello", "ata", "secret", "raw", "dat", "state", "sample", "area", "DATA", "content", "this", "any", "name", "d", "dump", "bytes", "sequence", "result", "form", "command", "batch", "string", "input", "action", "padding", "value", "info", "what", "image"], "digest": [" digist", "deest", "digute", "dese", "digist", "deist", "Digse", " digse", " digests", "signEST", "duose", "Digester", " digested", "Digest", "digested", "mdester", " digEST", "duist", "duger", "redest", " digger", "Digests", "duest", " hexested", "redger", "DigEST", "mdested", "mdEST", " digose", "digse", "digEST", "digger", "Digested", " hexute", "signest", "digests", "Digist", "redist", "digester", "mdest", " hexests", " digester", "digose", " digute", "deEST", "redose", "signse", "signested", " hexest", "mdse", "Digute"]}}
{"id1": "9872346", "id2": "22431487", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readLocalFile", "readRawObject", "readRemotedocument", "readremoteDocument", "selectRawdocument", "readLocalDocument", "readLocalObject", "selectRemoteObject", "readremotedocument", "readRawdocument", "readLocaldocument", "readRemoteObject", "readremoteFile", "selectRawFile", "readRemoteFile", "selectRawDocument", "readremoteObject", "selectRemoteDocument", "readRawDocument", "selectRemotedocument", "readRawFile", "selectRawObject", "selectRemoteFile"], "url": ["path", "http", "load", "mail", "html", "ls", "location", "addr", "abs", "sl", "org", "hub", "link", "b", "ur", "Url", "ul", "address", "q", "URL", "p", "loader", "util", "ssl", "uri", "dl", "loc", "nl", "channel", "el", "resource", "client", "browser", "ref", "request", "key", "impl", "mount", "str", "ll", "l", "u", "href", "base", "cl", "lr", "rl", "domain", "file", "web", "r", "host", "github"], "validate": ["Validates", "Valididate", " invalidate", "Validation", "valididate", "validation", " validateate", " validateidate", " invalidation", "validates", " invalidates", " validateates", " invalididate", "Validate", " validateation"], "document": ["output", "collection", "buffer", "message", "expression", "application", "text", "json", "reason", "node", "window", "model", "location", "program", "instance", "database", "ocument", "response", "um", "person", "metadata", "entity", "duration", "relation", "initial", "content", "component", "tree", "null", "doc", "xml", "number", "event", "result", "record", "dict", "command", "entry", "object", "language", "information", "file", "value", "data", "Document", "context", "word", "article"], "factory": ["tacter", "tixture", "kixture", "face", "Factory", "Face", "affFactory", "bFactory", "vFactory", "fiber", "fificate", "invixture", "Fificate", "forace", "facility", "hixture", "Fancy", "FFactory", "kacter", "facactory", "inviber", "foractory", "fixture", "Fility", "forFactory", "affactory", "bancy", "vancy", "tiber", "hility", "invactory", "kactory", "hFactory", "Fixture", "vacter", "facixture", "forificate", "fancy", "facter", "fFactory", "bacter", "kiber", "affificate", "tactory", "hactory", "facFactory", "Facter", "vactory", "bactory", "invacter", "fility", "afface"], "connection": ["application", "connect", "ion", "cone", "Connection", "con", "location", "function", "close", "builder", "pointer", "description", "open", "link", "database", "response", "statement", "condition", "reference", "socket", "character", "to", "relation", "create", "uri", "client", "resource", "channel", "current", "server", "created", "wrapper", " Connection", "creation", "communication", "operation", "writer", "engine", "version", "handler", "session", "service", "position", "connected", "directory", "conn", "command", "entry", "object", "driver", "query", "context", "city", "network"], "stream": ["buffer", "message", "shape", "window", "progress", "instance", "present", "is", "response", "feed", "body", "console", "pool", "read", "sample", "row", "iterator", "sw", "channel", "resource", "Stream", "client", "length", "content", "REAM", "reader", "still", "ream", "upload", "screen", "sequence", "cont", "source", "input", "file", "sam", "stack", "data", "context", "in", "out", "zip"]}}
{"id1": "23677142", "id2": "17729554", "code1": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"BubbleSortShort2": ["BubblesortShort4", "BubbleSortShortDouble", "BubblesortIntTwo", "BubbleSortString2", "BubbleSortIntTwo", "BubbleSortInt4", "BubbleSortStringDouble", "BubbleSortShortTwo", "BubbleSortshortDouble", "BubblesortShortTwo", "BubblesortInt2", "BubbleSortShort4", "BubbleSortshort4", "BubbleSortshortTwo", "BubblesortInt4", "BubbleSortStringTwo", "BubblesortIntDouble", "BubblesortShort2", "BubbleSortIntDouble", "BubbleSortshort2", "BubbleSortString4", "BubblesortShortDouble", "BubbleSortInt2"], "num": ["fn", "alpha", "update", "im", "con", "missing", "add", "rum", "save", "n", "buf", "val", "eng", "img", "cal", "msg", "um", "tu", "tm", "ver", "old", "Num", "nm", "dat", "bn", "alph", "coord", "np", "en", "prim", "test", "note", "ums", "NUM", "nt", "cmp", "uf", "na", "hex", "nu", "mon", "comm", "number", "dim", "dec", "mun", "get", "sum", "txt", "snap", "net", "nam", "om", "form", "tim", "mem", "check", "m", "nom", "zero", "mu", "sam", "mn", "info", "mat", "pn", "cache"], "last_exchange": ["last_sexactly", "last_nameamine", "last_rxvert", "last_rxception", "last_elcessive", "last_elamine", "last_EXamine", "last_nameception", "last_rxcessive", "last_examine", "last_xerence", "last_exception", "last_sexaction", "last_sexamine", "last_pexamine", "last_exerence", "last_xChange", "last_pexception", "last_Exception", "last_EXaction", "last_exChange", "last_elchange", "last_exvert", "last_rxchange", "last_sexception", "last_Exerence", "last_EXerence", "last_sexchange", "last_exevert", "last_xchange", "last_elception", "last_pexactly", "last_xception", "last_elaction", "last_pexchange", "last_exaction", "last_nameactly", "last_EXception", "last_exeception", "last_execessive", "last_elvert", "last_excessive", "last_Exchange", "last_exechange", "last_EXChange", "last_namechange", "last_exactly", "last_EXchange", "last_ExChange"], "right_border": ["right_index", "rightPostgap", "rightflowborder", " right_comment", "right_only", "rightPostborder", "right_break", " rightflowgap", "rightPostcomment", "rightPostindex", "right_order", "rightflowindex", "rightflowgap", " right_break", "right_gap", " right_gap", " rightflowindex", "right_comment", "rightflowcomment", " right_order", " rightflowborder", " right_only", " rightflowcomment", " right_index"], "j": [" n", "it", "ind", "jc", "other", "err", "expr", "job", "og", "br", "ij", "oj", "json", "jet", "my", "f", "jj", "q", " obj", "o", "dj", "pr", "uj", "fr", "pos", "e", "g", "ji", "l", "obj", "k", " J", "__", " dj", "im", "jl", "n", "ret", "jack", "je", "kj", "er", "kid", "server", "adj", "journal", "index", "jac", " Dj", "get", "u", "J", "z", "jo", "user", "aj", "p", "jit", "jen", "ja", "note", "pt", "el", "v", "js", "key", "req", "jump", "bj", "i", " ii", "jp", "c", "ix"], "temp": ["fake", "buffer", "deg", "attr", "cu", "emp", "orig", "template", "unt", "tt", "tmp", "rem", "em", "dat", "variable", "read", "test", "cum", "dep", "t", "kw", " temporary", "acc", "pre", "null", "alt", "tc", "fac", "perm", "mp", "txt", "ptr", "result", "mod", "porary", "Temp", "base", "mem", "tim", " Temp", " tmp", "tem", "comb"]}}
{"id1": "18211588", "id2": "2668634", "code1": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyTextFile": [" copiedRemotePhoto", " copiedTextSourceFile", " copiedRemoteSourceFile", " copyRemoteSourceFile", " copiedTextPhoto", " copyRemotePhoto", " copyFilePhoto", " copiedTextFile", " copyStringFile", " copyStringSourceFile", " copyTextSourceFile", " copyFileSourceFile", " copyStringPhoto", " copyTextPhoto", " copyRemoteFile", " copiedRemoteFile", " copyFileFile"], "src": ["ser", "st", "init", "sys", "sin", "rx", "via", "bs", "sc", "rc", "from", "sel", "ins", "Source", "rs", "iv", "js", "rt", "req", "ctr", "dest", "upload", "txt", "sec", "sit", "iris", "sn", "sr", "source", "input", "rl", "ipl", "sb", "inst", "start", "usr", "sf", "sq", "cur"], "dst": [" ddest", "lnd", "pnd", "Dnd", " dnd", "Dgt", "bnt", "ddest", "dgt", "bdest", "bnd", "Ddest", " dnt", "Dst", "pdest", "lst", "pst", "bst", "ldest", "dnt", "Dnt", "lgt", "dnd", "pgt"], "bis": ["mos", "cos", "bf", "mis", "ais", "lin", "ris", "ri", "is", "stri", "sin", "nis", "bps", "bs", "pin", "mi", "onis", "conv", "opus", "bits", "obs", "pins", "ubis", "pse", "webkit", "bil", "bi", "bes", "bid", "fits", "isin", "fs", "iris", "sit", "avi", "los", "lbs", "isi", "oss", "zo", "bh", "ios", "vi", "oi", "lis", "cin"], "bos": ["bo", "mos", "cos", "oops", "nos", "ls", "ms", "oos", "jas", "ows", "sys", "uts", "bs", "dos", "aos", "uds", "os", "boards", "BS", "bol", "bits", "obs", "pins", "ubis", "bones", "bin", "rots", "bas", "ods", "bi", "acs", "bes", "eros", "bytes", "fs", "ols", "base", "los", "vas", "oss", "tes", "bh", "zo", "ios", "ts", "mus", "soc"], "buf": ["buffer", "Buffer", "db", "block", "img", "msg", "pkg", "var", "fg", "b", "bag", "nm", "raw", "norm", "Buff", "tab", "prop", "cat", "bl", "cv", "seq", "feat", "conv", "fb", "arr", "bin", "buff", "ref", "uf", "bg", "box", "bus", "vec", "cp", "cb", "bytes", "cam", "good", "batch", "tx", "cap", "mu", "log", "br", "data", "cf", "cmd", "act", "begin", "rb", "gen", "cur"], "readsize": ["Readsize", "Readnumber", "readcount", "Readcount", " readSize", "READneeded", " Readscope", " readscope", "READcount", "lengthlength", "lengthsize", "READnumber", " readlen", "readnumber", " readlength", "writelength", " ReadSize", " readnumber", "READsize", "readlength", " Readsize", "readlen", " readcount", " Readneeded", "writesize", "lengthSize", "readneeded", "READscope", "lengthlen", "writeSize", "writelen", "readscope", "readSize", "READSize", " readneeded", "ReadSize"]}}
{"id1": "13981689", "id2": "18358467", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"md5Hash": ["md7Sum", "md2hash", "md7Hash", "MD5Hash", "MD5Sum", "MD7hash", "md5Sum", "md3Hash", "md3hash", "MD5hash", "md2Sum", "MD7Sum", "md7hash", "md2Hash", "MD7Hash", "md3Sum", "md5hash"], "src": ["ser", "text", "st", "mph", "jpg", "RC", "sys", "rx", "b", "sc", "rc", "conv", "filename", "rs", "this", "obl", "str", "impl", "name", "ctr", "dest", "bytes", "fx", "obj", "txt", "sec", "sr", "string", "source", "input", "ipl", "sb", "inst", "data", "s", "url", "usc", "r", "sq"], "md": ["dr", "spread", "pm", "db", "ms", "nd", "sd", "msg", "mc", "bd", "od", "MD", "der", "cd", "ds", "mg", "dir", "mm", "dm", "rm", "mt", "ind", "down", "red", "pt", "sm", "nt", "det", "ld", "mb", "d", "dd", "mp", "mk", "amd", "mod", "pd", "m", "hash", "df", "mn", "mand", "cmd", "hd"]}}
{"id1": "4629990", "id2": "11933797", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonForServer", "logonToClient", "logonTOServer", "logonToSite", "logonForserver", "logOnToClient", "logonTOSite", "logOnToSite", "logontoClient", "logOnToserver", "logonTOserver", "logonForSite", "logOnToServer", "logontoSite", "logOntoServer", "logOntoClient", "logontoServer", "logonTOClient", "logonForClient", "logonToserver", "logontoserver", "logOntoSite", "logOntoserver"], "ftpClient": ["ftpBuilder", " ftpBuilder", "ftcResponse", " fttpclient", "afttpClient", "aftcpClient", "fttpClient", "ftcpBuilder", "aftcpResponse", "aftpClient", "ftpConnection", "fftClient", "aftpResponse", "ftcpServer", "ffpclient", "ftcpclient", "ftcClient", "ftpclient", " ftpLib", "fftclient", " fttpBuilder", "fttclient", "ftcConnection", "aftpConnection", "fttConnection", "fttpLib", "aftcpConnection", "fttLib", "fttBuilder", "aftcpclient", "fftConnection", "fttResponse", " ftpclient", "fttpServer", "fttClient", " fttpLib", "ftspClient", "ftcpLib", "ftspServer", "afttpConnection", "fttpBuilder", "fttpConnection", "fttpclient", "ftcclient", "ftpServer", "ftpLib", "ftpResponse", " fttpClient", "aftpServer", "ftcpClient", "aftcpServer", "ftcpConnection", "aftpclient", "ffpClient", "ftcpResponse", "ffpConnection", "afttpclient", "ftspclient"], "ftpAddress": [" ftpaddress", "aftrAdd", "fttInterface", "ftpPath", "ettpOrder", "aftpClient", "fttpOrder", " ftpPath", "ftfPort", "ffcpAddress", "ftrAddress", "aftrClient", "fttStreet", "ettpAdd", "ettpAddress", "afttpHost", "aftrAddress", "ftPStreet", "ftpaddress", "etpAddress", "ftfAdd", "ftcpInterface", "ftPInterface", "fttpPort", "aftpaddress", "ftcpHost", "afttpAdd", "ftrClient", "fttpHost", "ftcpPath", "ftfaddress", "ffpAddress", "ftphAdd", "ffcpInterface", "ftpeaddress", "etpOrder", " ftpPort", "ftfHost", "ftpOrder", " fttpaddress", "ftcpAdd", "ftraddress", "fttpPath", " fttpPort", "ftcpAddress", "etpAdd", "ftfAddress", "ftphaddress", "ftrAdd", "ftphClient", "fttpaddress", "ftcpStreet", "etpaddress", "ftpeOrder", " fttpPath", "fttpAddress", "ettpaddress", "ftpeAdd", "fttAddress", "ftpInterface", "ftcpOrder", "ftcpaddress", "ftPAddress", "aftpHost", "ftcpClient", "ftpHost", " fttpAddress", "ftphAddress", "aftraddress", "ftpPort", "afttpaddress", "ffpStreet", "ftpeAddress", "ftpStreet", "ftfPath", "afttpAddress", "ftcpPort", "fttpAdd", "aftpAdd", "ffpInterface", "ftpAdd", "aftpAddress", "ffcpStreet"], "noRetries": ["noEntries", "noRetry", "noretorts", "noRetorts", "noTrys", " noEntries", "NOReties", "noreties", "NOretry", "NOreties", " noRetorts", "noretry", "noContries", "noretrys", "noRetrys", "NOretries", "noContrys", "noTries", " noEnties", "NORetrys", "noEntorts", " noEntorts", "noContorts", "NOretrys", "noEnties", "noConties", "noTies", "NORetries", "noEntry", "noTry", "NORetry", " noEntrys", " noReties", " noRetrys", "noEntrys", "noReties", "noretries"], "remoteHomeDir": ["remoteRootRoot", "remoteRootdir", "remoteRootDirectory", " remoteHomeDirectory", "remoteWelcomeRoot", "RemoteHomeRoot", "remoteHomeDirectory", " remoteRootDirectory", "remoteBaseDirectory", "RemoteRootDir", "externalHomePath", " remoteRootPath", "externalHomeDir", "remoteRootDir", "remoteHostDir", "remoteWelcomePath", " remoteHomePath", "RemoteRootRoot", "RemoteHomeDir", "remoteHostPath", "remoteHostRoot", "remoteBaseDir", "remoteBasePath", "remoteWelcomeDir", "externalHomedir", "RemoteRootPath", "remotehomeDirectory", "remoteHomedir", "remotehomedir", "RemoteHomePath", "remoteRootPath", "remotehomePath", "remotehomeDir", "externalHomeDirectory", "remoteHomeRoot", "remoteHomePath", " remoteRootDir"], "noRetriesSoFar": ["noRetriesSOOld", "noRetriesSOMuch", "noRetrysSOfar", "noRetrysSOFar", "noRetriessoMuch", "noRetrysSofar", "noRetriesSoobar", "noRetriesOffFar", "noRetrysSONear", "noRetriessoOld", "noRetriesSofar", "noRetriesSOFar", "noRetriesPeFar", "noRetriesPefar", "noRetriesTooobar", "noRetriesOffNear", "noRetriesToofar", "noRetriesTooNear", "noRetrysSOobar", "noRetrysSoNear", "noRetrysSoFar", "noRetrysSoOld", "noRetrysSoMuch", "noRetriesTooFar", "noRetriesSoMuch", "noRetriessoobar", "noRetriesSOfar", "noRetriesSONear", "noRetriesSoNear", "noRetriesSoOld", "noRetriessoFar", "noRetriessoNear", "noRetrysSoobar", "noRetrysSOMuch", "noRetryssofar", "noRetriessofar", "noRetryssoOld", "noRetriesPeOld", "noRetryssoFar", "noRetriesSOobar", "noRetriesOfffar", "noRetryssoNear", "noRetriesPeNear"], "reply": ["message", "part", "close", "notice", "nb", "apply", "link", "response", "echo", "address", "count", "shell", "state", "reset", " Reply", "answer", "power", "continue", "exit", "flag", "code", "write", "error", "next", "number", "ignore", "Reply", "result", "print", "command", "consider", "status", "zero", "job", "match", "comment", "info", "py", "success", "repl", "report", "ply"]}}
{"id1": "6966398", "id2": "3187685", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["runner", "buffer", "dr", "builder", "rar", "ri", "rx", "rer", "loader", "parser", "rc", "read", "row", "io", "older", "er", "rs", "wrapper", " read", "this", "inner", "writer", "handler", "stream", "rot", "mr", "rr", "redo", "Reader", "ner", "roller", "sr", "lr", "input", " readers", "rl", "iter", "file", "driver", "ro", "cer", "query", "ocr", "r"], "ks": ["KS", "sky", "vs", "ms", "ls", "ates", "kk", "kes", "km", "kies", "checks", "ck", "akes", "cks", "bs", "kb", "ss", "ds", "ars", "qs", "uds", "ses", "hs", "ys", "ke", "ces", "ki", "cs", "obs", "uk", "ips", "ans", "keys", "k", "fs", "mk", "eks", "ols", "kens", "icks", "agles", "ros", "oss", "nets", "kr", "eps", "sk", "kas", "ups"], "key": ["owner", "sky", "Key", "password", "core", "by", "x", "my", "user", "type", "ek", "sign", "link", "tk", "root", "y", "ssh", "ke", "er", "power", "client", "KEY", "ox", "pair", "trust", "null", "service", "keys", "char", "k", "obj", "mk", "base", "entry", "ey", "object", "hash", "file", "cer", "info", "sk", "ca"], "chain": ["path", "binary", "password", "block", "type", "sign", "piece", "ver", "root", "can", "pool", "sche", "test", "ce", "frame", "channel", "component", "pair", "code", "box", "group", "number", "stream", "chains", "bank", "family", "sequence", "result", "form", "base", "batch", "check", "string", "hash", "table", "file", "range", "stack", "data", "Chain", "trace", "ca", "c", "list", "cache"], "os": ["out", "cos", "ls", "ms", "OS", "oos", "ops", "is", "sys", "uts", "bos", "osi", "bs", "oso", "ds", "o", "aos", "io", "css", "ys", "cs", "obs", "pos", "ps", "ox", "oS", "js", "Os", "oids", "fs", "ols", "los", "us", "ose", "oss", "oes", "ios", "ot", "oses", "ts"], "stamper": [" strampler", " stamPER", " stummer", "font", " stcamter", "valid", "stramper", " stcampler", "stumper", "stampler", "stimPER", "stammer", " stcamper", " stimper", "stimmer", "stramPER", "stAmmer", "stumpler", " stamter", "stamPER", "read", "New", " stumter", "The", "stimpler", " stcammer", "strampler", "this", "Print", "annot", "stummer", "strammer", " stumper", "stAmPER", "println", "_", "stimper", "good", " stammer", " strammer", "stAmper", " stramper", " stimmer", " stumpler", " stramPER", "def", " stimpler", "stamter", " stampler", "stAmpler", "important", "stumter", " stimter"], "appearance": [" appendix", "attlies", "apeared", "attearance", "apearances", "Appeared", "ascearing", "Applies", " appearing", "appendix", "patternearances", " appeared", "patternendix", "displayearances", "aceared", "accearance", "apearance", "atteared", "displayearing", "Appearances", "suppeared", "ascears", "appearances", "Appearance", "appreciation", "apreciation", "appeared", "acearance", "aplies", "ascearances", "attearances", "applies", "ascearance", "displayears", "suppearance", "displayreciation", "apearing", "displayeared", "appears", "patternearance", "accears", "accearances", " appearances", "displayearance", "displaylies", "appearing", "patternearing", "acclies", "displayendix", "suppearances", "acreciation", "acearances", "apears"]}}
{"id1": "23370621", "id2": "10715601", "code1": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadFiles", "Downloadfile", "loadFiles", " downloadSingle", "downloadfile", "loadSingle", "DownloadFiles", "DownloadSingle", "downloadFiles", "downloadSingle", "loadFile", " downloadfile", "DownloadFile", "loadfile"], "target": ["path", "output", "buffer", "top", "location", "bolt", "template", "touch", "it", "ret", "type", "tmp", "tar", "tp", "ver", "arget", "Target", "root", "rel", "local", "to", "dir", "test", "tor", "default", "t", "filename", "v", "fixed", "parent", " targ", "delete", "tree", "null", "this", "goal", "dest", "txt", "result", "tif", "remote", "localhost", "base", "source", "copy", "gt", "that", "physical", "table", "file", "match", "secondary", "set", "format", "alias", "out", "pattern"], "s3key": ["sdkkey", " s3url", " s2Key", " s3KEY", "sdkKey", "s6Key", "s4key", "sdkurl", "s3url", "s4KEY", " s2key", "s4Key", "s2secret", " s2url", " s3Key", "sdksecret", "s6secret", "s3KEY", " s3secret", " s2secret", "s2Key", "s2KEY", " s2KEY", "s2url", "s4url", "s3Key", "s6key", "s2key", "sdkKEY", "s3secret"], "in": ["IN", "on", "din", "gin", "con", "asin", "or", "init", "n", "it", "oin", "rin", "ini", "is", "mc", "vin", "and", "ai", "sin", "f", "ain", "raw", "sql", "o", "read", "local", "en", "inc", "io", "from", "re", "ind", "mm", "mi", "ins", "t", "nin", "up", "bin", "e", "inner", "req", "reader", "stream", "isin", "r", "l", "In", "input", "source", "m", "copy", "iter", "file", "i", " din", "s", "inn", "data", "out", "inside", "inf", "cin"], "temp": ["output", "fake", "buffer", "top", "part", "emp", "prefix", "template", "my", "EMP", "unt", "tmp", "tar", "tm", "tab", "p", "dat", "local", "to", "test", "stem", "mm", "mt", "t", "pt", "current", " temporary", "null", "tc", "dest", "mp", "tr", "txt", "mk", "mod", "porary", "Temp", "tim", "partial", "mem", "base", "copy", "tx", "file", " tmp", "tem", "res", "out"], "fout": ["flowou", "floutput", "FOut", "ifou", "flout", " fouts", " fou", "fouts", " foutput", "vouts", "flou", "fabout", "ifoutput", "ffOut", " fyout", "Fout", "ffou", " fOut", "wto", "wouts", "fabyout", "fto", "Fouts", "vout", "wout", "flOut", "ffto", "fabouts", "foutput", "vto", "flowoutput", "ffout", "fabOut", "ifout", "fyout", "vOut", "ffoutput", "flowout", "wOut", "ffouts", "flowOut", "ifOut", "fOut", "Fyout", "fou"]}}
{"id1": "20019847", "id2": "3756429", "code1": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", "Copyfile", "CopyStream", " cpfile", " cpStream", " cpFiles", "CopyFiles", "copyStream", " CopyStream", " Copyfile", " CopyFiles", "copyFiles", " CopyFile", "copyfile", " cpFile"], "source": ["series", "style", "site", "init", "template", "se", "space", "config", "SOURCE", "it", "seed", "ource", "sql", "sample", "ce", "size", "scene", "from", "subject", "resource", "spec", "Source", "scope", "filename", "parent", "src", "store", "name", "view", "service", "ace", "sequence", "details", "base", "check", "input", "copy", "string", "archive", "file", "query", "search", "format", "origin", "start"], "target": ["output", "arg", "top", "bolt", "replace", "template", "touch", "it", "link", "arget", "Target", "to", "test", "t", "resource", "parent", "delete", "stop", "next", "goal", "dest", "mac", "get", "result", "tif", "print", "base", "project", "check", "that", "gt", "copy", "table", "file", "match", "join", "alias", "pattern"], "in": ["IN", "din", "gin", "im", "con", "internal", "init", "it", "rin", "ai", "is", "ic", "sin", "ain", "id", "en", "inc", "from", "re", "ind", "al", "ins", "client", "ar", "up", "bin", "inner", "isin", "In", "input", "iter", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "ch", "on", "con", "or", "by", "n", "auto", "Out", "it", "user", "msg", "sys", "and", "b", "can", "o", "aos", "to", "en", "io", "ex", "outs", "t", "channel", "client", "up", "v", "ou", "nt", "at", "g", "l", "net", "result", "conn", "OUT", "gt", "ne", "cn", "i", "co", "ot", "cmd", "c"]}}
{"id1": "22479286", "id2": "4398382", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "label": 1, "substitutes": {"md5": [" MD4", "md4", "MD4", " MD3", " md3", "MD3", " md4", " MD5", "md3", " md2", " MD2", "MD5", "MD2", "md2"], "plainText": ["flatForm", "batSync", "ainSync", "batTerm", "alttext", " plaintext", "initialTrans", "altString", "fullString", "altPrint", "longString", "longTEXT", "longPrint", "batString", "aintext", "plainForm", "plainDelete", "externalText", "richPrint", "ainTerm", " plainTrans", "maintext", "mainString", "richString", "positionString", "initialText", "fullPrint", "richText", " plainForm", "plainMessage", "fullText", "fulltext", " plainSync", "mainText", " plainString", "externalDelete", "ainTEXT", "ainPrint", "batText", "plainPrint", "mainTEXT", " plainTEXT", "plainSync", "initialtext", "plainString", "positionText", "altTEXT", "plainTrans", "ainForm", " plainMessage", "plainTerm", " plainDelete", "flatTEXT", "plainTEXT", "richTEXT", "flatText", "externalTEXT", "initialString", "ainMessage", "externalString", "flatMessage", "ainString", "positionTEXT", " plainTerm", "ainTrans", "altText", "longText", "plaintext", "ainText", "positiontext", "ainDelete"], "md": ["dr", "pm", "ms", "add", "pdf", "sd", "mc", "bd", "od", "ad", "MD", "grad", "der", "cd", "mg", "h", "dir", "desc", "mm", "dm", "mt", "ind", "down", "red", "sm", "dh", "nt", "det", "ld", "mb", "d", "dd", " Md", "mac", "mp", "mk", "mod", " MD", "pd", "m", "df", "di", "mn", "mand", "cmd", "man", "hd", "ng", "de"], "digest": ["compest", "digute", "presentests", "defEST", " digse", " digests", "defested", "digity", "compidate", "presentEST", " digested", "digested", "Digest", "presentute", " digEST", "digum", "Digum", " digity", "candidate", "candest", "presentested", "defest", "Digests", "DigEST", "mdested", "candum", "candute", "mdEST", "digse", "digEST", "Digested", "digests", "digidate", "Digity", "defse", "Digidate", "compum", "compute", "mdest", "presentest", "presentity", " digute", "mdse", "Digute"], "hexString": ["exString", "expstring", " hexSingle", " hexstring", " Hexstring", "expText", "expBuffer", "exArray", "hexstring", " HexText", " hexText", "exBuffer", "hexSingle", "charArray", "rexString", " HexBuffer", "rexArray", " hexArray", "exText", " hexBuffer", "hexBuffer", "rexBuffer", "hexText", "expString", "charBuffer", "hexArray", "charString", "rexSingle", "charText", "exSingle", " HexString"], "i": ["multi", "im", "x", "j", "n", "init", "it", "phi", "my", "a", "ai", "is", "ic", "ski", "ui", "ie", "b", "me", "q", "iu", "id", "y", "to", "io", "ci", "gu", "ind", "mi", "ex", "conv", "qi", "ii", "uri", "v", "gi", "hi", "key", "g", "ti", "ji", "bi", "index", "si", "I", "u", "err", "batch", "yi", "set", "m", "xi", "iq", "z", "di", "sim", "pi", "info", "chain", "in", "ip", "li", "c", "\u0438", "ix"]}}
{"id1": "22022715", "id2": "3945236", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"digest": ["digen", "digist", "mdests", "Digest", "Digate", "digested", "den", "dine", "decest", "digum", "Digum", "decested", "mnist", "digate", "mnests", "dge", "mdested", "dist", "dest", "Digested", "digine", "mden", "dum", "digests", "mdum", "mdist", "mnen", "decge", "date", "dested", "mdest", "mdine", "Digine", "Digge", "decate", "digge", "dests", "mnest"], "s": ["text", "strings", "ms", "ls", "space", "n", "a", "is", "b", "sq", "f", "p", "ss", "sql", "y", "o", "h", "ses", "t", "ps", "v", "js", "e", "str", "ats", "sts", "bytes", "l", "r", "string", "m", "i", "sb", "sv", "ts", "S", "c"], "ret": ["elt", "arg", "out", "reg", "over", "buf", "val", "rets", "rep", "it", "ext", "tmp", "rem", "xt", "cat", "reset", "test", "re", "mt", "rm", "att", "ft", "t", "arr", "resp", "Return", "rs", "back", "nt", "ref", "det", "uf", "rt", "ts", "ert", "gb", "tr", "txt", "r", "result", "Ret", "pet", "cont", "gt", "RET", "data", "jp", "found", "res", "repl", "az", "report"], "md": ["dr", "pm", "mail", "ms", "nd", "pdf", "med", "sd", "mc", "bd", "od", "and", "del", "MD", "der", "ds", "cd", "mg", "met", "mm", "dm", "mt", "ind", "rm", "red", "sm", "dh", "det", "ld", "mb", "d", "dd", " Md", "mk", "mod", "managed", " MD", "pd", "m", "df", "di", "mo", "mn", "mand", "cmd", "man", "hd"]}}
{"id1": "3514286", "id2": "2199604", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"getHashedPassword": ["getHashUser", "getHashedUser", "getHackedSecret", "getHashpassword", "getHashPassword", "getHashesSecret", "getShashedUser", "getHashedSecret", "getShashedPassword", "getShashedSecret", "getShashedpassword", "getHackedPassword", "getShashSecret", "getShashPassword", "getShashpassword", "getShashUser", "getHashespassword", "getHashesPassword", "getHackedpassword", "getHackedUser", "getHashSecret", "getHashesUser", "getHashedpassword"], "password": ["message", "text", "description", "prefix", "phrase", "user", "database", "attribute", "secret", "address", "raw", "token", "wd", "reset", "default", "Password", "login", "email", "pass", "key", "name", "sword", "shadow", "username", "REDACTED", "command", "string", "input", "hash", "padding", "value", "wordpress", "data", "word", "pattern"], "digest": ["dests", "Digse", " digse", " digests", "Digester", "mdests", " digested", "Digest", "digested", "hashests", "mdester", " Digest", " Digester", " Digse", "Digests", "hashest", "hashse", "hashester", "digse", "digests", "Digested", "dest", "digester", "dested", "mdest", "hashested", " digester", "mdse"], "hashedInt": ["hashashingInteger", "hashingInt", "hcheckedINT", "happedInteger", "hashashedInteger", "hashedTx", "hashInt", "hashedINT", "hhedId", " hashedTx", " hushedInteger", "happedTx", "hashedId", "hhedInt", "hcheckedInt", "hashashingINT", "hashingINT", "hashINT", "happedInt", "hashashingInt", " hushedTx", " hashedInteger", "hhedTx", "happedId", "hhedInteger", " hashedId", "hashInteger", " hushedId", "hashedInteger", "hashingInteger", "hushedInt", " hushedInt", "hushedTx", "hushedId", "hushedInteger", "hashashedINT", "hcheckedInteger", "hashashedInt"]}}
{"id1": "20855053", "id2": "12085127", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "label": 0, "substitutes": {"init": [" bind", " service", "config", " initialization", "Init", " Init", " refresh", "initialized", "execute", " construct", " initiation", " prepare", "register", " initialized", " initiate", " abort", "run", " restart", " reset", "action", "launch", "construct", " login", "start", " deploy", " authorize", "activate", " dispatch"], "context": ["application", "self", "x", "config", "exc", "X", "sc", "state", "h", "ex", "component", "this", "null", "w", "txt", "event", "bc", " contexts", "ctx", "tx", "Context", "chain", "web", "res", "c"], "classLoader": ["fileManager", "classManager", "ClassLess", "taskElf", "Classloader", " classPath", "urlLoader", "classloader", "ClassLoader", " classReader", "urlReader", "classLess", " classBuilder", " classloader", "classBuilder", "ClassElf", "taskLoader", " classParser", "ClassBuilder", "classElf", "ClassPath", "fileReader", "urlloader", "ClassParser", "ClassReader", "taskBuilder", " classManager", "classReader", " classLess", "urlPath", "ClassManager", "classParser", "fileLoader", "fileParser", "classPath", "taskLess", " classElf"], "urls": ["urlls", " urllets", "URLgs", "ls", "urs", "limms", " urlgs", "longies", "limlets", "urllets", "URLms", "lxs", "normports", "limxs", "sls", "limgs", "urlms", "slists", "lps", "normies", " urlms", "longs", "urlies", "urlists", "slies", "normists", "longports", "norms", "URLs", "limls", "urlps", "slports", "urps", "urlxs", "URLlets", "lls", "limps", "urlports", "urxs", "urlgs", "lims", "longists"], "url": ["path", "http", "mail", "ls", "location", "sl", "org", "user", "ret", "bel", "link", "ur", "b", "Url", "f", "address", "ul", "ob", "URL", "rel", "util", "row", "re", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "channel", "email", "browser", "ref", "uu", "req", "name", "mount", "str", "ll", "l", "char", "page", "base", "entry", "lr", "rl", "file", "log", "job", "web", "res", "r", "li"], "reader": ["buffer", "runner", "per", " Reader", "rar", "peer", "iper", "rx", "rer", "loader", "parser", "read", "row", "iterator", "older", "er", "resource", "inner", "writer", "dd", "reading", "handler", "stream", "rot", "rr", "Reader", "ner", "entry", "roller", "input", "iter", "rl", "layer", "file", "driver", "ro", "range", "r"], "className": [" classType", " classPath", "packagename", " classLine", "playNo", "classNot", "cellRel", " classNot", "classNAME", "CLASSNames", " classData", "completeRel", " classNames", "playBody", "ClassPath", "cellName", "classStart", "ClassLine", "classToken", "CLASSFull", "classTitle", "clRel", " classStart", "classPath", "packagePath", "ClassToken", " classBody", "ClassString", "ClassName", "clNo", "Classname", "partNAME", "classLine", " classNAME", " ClassNames", "CLASSTitle", "playString", " ClassName", "ClassNot", "clString", " classTitle", "stringStart", "moduleStart", "completePath", " classToken", " classString", "classType", "classname", "partName", " classRel", "stringName", " classname", "classString", "classFull", "logValue", "CLASSName", "clBody", "moduleName", "ClassRel", "classValue", " classFull", "playName", "partname", "titleName", "classRel", "classData", " classNo", "classNo", "packageName", "logname", "logNAME", "clPath", " classValue", "classBody", "packageData", "cellToken", "stringType", "clName", "partValue", "titleNot", "titleLine", "completeName", " ClassTitle", " ClassFull", "stringString", "logName", "classNames", "cellString", "ClassData", "moduleString", "titleString", "moduleType"], "clazz": ["gluster", "glass", "laz", "classazz", "clace", "glclass", "class", "lclass", "glaz", " clace", "classclass", "classaz", "clade", "lass", "classass", "shade", "shazz", " clade", "glace", "shuster", "glazz", " cluster", "clclass", "cluster", "lazz", "shace", "glade", "claz"]}}
{"id1": "2642914", "id2": "12172485", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGst", "addFileToTarRz", "addFileToTarRw", "addFileToTarGep", "addFileToTarBt", "addFileToTarRzip", "addFileToTarJzip", "addFileToTarGzip", "addFileToTarGet", "addFileToTarBz", "addFileToTarBw", "addFileToTarJw", "addFileToTarBzip", "addFileToTarGszip", "addFileToTarGsz", "addFileToTarRx", "addFileToTarJz", "addFileToTarGw", "addFileToTarGp", "addFileToTarGx", "addFileToTarGsp", "addFileToTarBx", "addFileToTarBp", "addFileToTarGt", "addFileToTarGez", "addFileToTarJx", "addFileToTarGezip"], "taro": ["tarro", " tarro", " tosa", "tharro", "marro", "toa", " targo", "wro", "ttaro", "tro", " tory", "trary", "tempro", "warro", "Targo", "tamo", "qtory", "tempargo", "wargo", "taco", "starro", "staco", "Tarro", "ttosa", "targo", "temparo", "tempamo", " toa", "tary", " tolan", "Tara", "Tro", "stoa", "ktara", "tory", "Taro", "ktaro", " tary", "stargo", "retaco", "tara", "tosa", "stary", "staro", " trar", "qtaro", "thrar", "thosa", "qtolan", "traro", "stamo", "stro", "Tory", "margo", "qtro", " taco", "tharo", "retamo", "thamo", " tara", "retara", "ktarro", "troa", "ktrar", "retaro", "ttamo", "trar", "thara", "Tamo", "Tolan", "waro", "tolan", "mro", "maro", "ttara", "Taco", "trro", " tamo", " tro"], "path": ["history", "text", "binding", "core", "Path", "PATH", "ath", "root", "p", "h", "local", "dir", "kind", "ex", "th", "transform", "ref", "key", "name", "mount", "doc", "w", "print", "parts", "project", "string", "entry", "m", "clean", "file", "chain", "pi", "full", "url", "c", "pattern"], "base": ["buffer", "bf", "db", "part", "binding", "prefix", "ase", "template", "build", "normal", "Base", "b", "bare", "root", "common", "absolute", "reset", "create", "basic", "default", "server", "parent", "relative", "bas", "name", "shadow", "family", "extra", "check", "padding", "file", "based", "full", "pad", "start", "alias", "bad"], "f": ["af", "bf", "alf", "inf", "lf", "fo", "fe", "fg", "xf", "b", "p", "y", "fi", "h", "o", "fp", "ft", "t", "fb", "fr", "v", "fc", "fm", "fab", "uf", "e", "fed", "fa", "g", "life", "fl", "fac", "w", "rf", "fx", "l", "d", "fs", "perm", "form", "elf", "df", "file", "far", "i", "F", "cf", "fd", "r", "tf", "c", "sf"], "entryName": [" entryname", "EntryPath", "ryName", " entryKey", "Entryname", " entryLetter", "EntryName", "cueType", "elementKey", " entryType", "cueKey", " entryPath", "ryname", "entryLetter", "entryKey", "rowname", "entryType", "entryname", "ryLetter", "cueName", "entryPath", "cuename", "rowType", "elementName", "ryType", "EntryType", "rowLetter", "EntryKey", "rowName", "elementname", "elementPath"], "goIn": ["GoIn", "geIn", "moIns", "gein", " goIN", "GoIN", " goInput", "goin", "goOut", "poIn", "moin", "moIN", "geInput", "poIN", " goIns", "GoOut", "Goin", "goIns", "moInput", "geIns", " goOut", "moIn", "goInput", "GoIns", " goin", "poin", "poOut", "goIN"], "tarEntry": ["warEnt", "carEntry", "rarentry", "carEnt", "rarComponent", " tarEnt", "tarEnt", "rarEnt", "tarItem", "warEntry", " tarComponent", "tarComponent", "rarEntry", "warItem", "tarCategory", "rarCategory", " tarentry", "tarentry", "warComponent", "carentry", "carCategory", " tarItem", "rarItem", " tarCategory"], "children": ["each", "json", "ls", "parents", "balls", "hawks", "users", "ports", "follow", "ul", "ml", "kids", "aos", "pages", "roots", "jobs", "cs", "files", "items", "packages", "gall", "ps", "parent", "these", "cloud", "all", "ll", "they", "many", "keys", "Children", "fs", "wn", "batch", "reports", "los", "resources", "modules", "names", "groups", "blocks", "stories", "ren", "members", "objects", "cache"], "child": ["ch", "cow", "cell", "Child", "lf", "close", "block", "last", "follow", "count", "q", "shell", "id", "col", "row", "friend", "fr", "client", "parent", "key", "name", "background", "label", "ll", "uncle", "l", "char", "page", "pixel", "entry", "batch", "file", "ph", "job", "comment", "fd", "handle", "brother", "c", "cache", "zip"]}}
{"id1": "12766394", "id2": "7911686", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": [" testReadHelloWorldItxt", " testReadHelloWorldIttxt", " testReadHelloWorldTText", " testReadHelloWorldTXT", " testReadHelloWorldItText", " testReadHelloWorldTtxt", " testReadHelloWorldItXT"], "helloWorldIS": [" helloWorldI", "helloWestIs", "helloWorldISS", "helloLifeIS", "helloWorldI", "helloLifeIs", " helloWorldIs", " helloWorldISS", " helloWorldIC", "helloWestIC", "helloLifeISS", "helloLifeI", "helloWorldIC", "helloWestIS", "helloWorldIs"], "helloWorldPath": ["helloWestCh", " HelloWestP", " HelloWestName", "helloWorldCh", "helloWestPos", "helloWestP", "helloWireName", "helloWonderPos", "helloWonderPath", " helloWorldPos", "helloWireTemp", " HelloWorldName", " helloWorldCh", "helloWorldPos", " HelloWestPath", "helloWebName", " helloWorldTemp", " helloWonderPath", "helloWebTemp", " HelloWorldPos", " HelloWestPos", "helloWonderName", "helloWebPath", "helloWonderCh", "helloWestName", " helloWonderPos", "helloWestPath", "helloWirePath", " helloWorldName", "helloWorldTemp", " HelloWorldP", "helloWorldP", " HelloWorldPath", " helloWonderCh", " helloWonderName", "helloWorldName"], "fileOutputStream": ["fileOutStream", "fileInputstream", " fileoutputSteam", "fileWriteStream", "fileoutputStream", " fileInputStyle", " fileInputSt", " fileInputSteam", " fileOutputstream", "fileInputStream", "fileInputPoint", "fileOutputStyle", "fileOutStyle", "fileInputStyle", "fileWriteStyle", " fileOutputPoint", " fileOutputSteam", "fileOUSt", " fileOutputSt", "fileWritePoint", " fileInputstream", "fileOutputSteam", "fileOutputstream", "fileOUstream", " fileoutputPoint", "fileOutputSt", " fileOutputStyle", " fileoutputStream", "fileOutputPoint", "fileWriteSteam", "fileOutSteam", "fileOUSteam", "fileInputSt", " fileInputPoint", "fileoutputStyle", " fileoutputStyle", "fileoutputSteam", " fileInputStream", "fileOUStream", "fileoutputSt", "fileoutputstream", "fileOutPoint", "fileoutputPoint", "fileInputSteam"], "contentResolver": ["contentParreader", "Contentresolve", "commentResolver", "Contentresolver", "commentPoserver", "commentPosiper", "entityRESolution", "contentPoserver", " contentResander", "contentPalistor", "contentPosolved", "entityResolver", "contentresinter", " contentResistor", "entityRESinter", " contentResoser", "contentPosiper", "contentResolved", "Contentresolving", "ContentResolving", "contentResoser", "contentResinter", " contentResolution", "contentResolving", "contentJsolution", "contentRespter", "contentResourceolver", "contentRightinter", "ContentResolver", "contentRESinter", "contentSerolution", "contentSererver", "contentJsoser", " contentresoser", "contentSolver", "contentSerolver", "imageResistor", "imageRESistor", " contentresinter", "contentReserver", "contentResreader", "contentResander", "contentParolver", "contentPaloser", "contentResiper", "contentSander", "contentRESander", "entityResreader", "contentPalurer", "imageRESolution", "commentReserver", "contentrespter", "contentResourceurer", "contentResolve", " contentResolved", " contentrespter", " contentResinter", "contentresreader", "entityResolution", "contentRESreader", "contentResistor", "contentResol", "contentSeriper", "contentParolution", "contentresolving", "entityRESolver", "Contentresol", "entityRESreader", "commentPosolution", "commentPosolver", "contentRESolver", "ContentResol", "contentJspter", "contentRightolution", "contentPalolution", "imageResolver", " contentresolution", "imageRESolver", "imageResurer", " contentresolver", "contentPalpter", "contentresolver", "contentPosinter", "contentSolution", "contentResourceistor", "commentResolution", "ContentResolve", "contentresolution", "contentPosolution", "contentPalolver", "contentResourceolution", "entityResinter", "contentresoser", "contentResolution", "contentSistor", "contentresolved", "contentParinter", "contentresol", "contentRESistor", "contentRESiper", "contentresolve", "contentREServer", "contentResurer", "contentRightolver", "contentRESolution", "imageResolution", " contentRespter", "contentJsolver", "contentRightolved", "contentRESurer", "imageRESurer", "commentResiper", "contentPosolver", " contentresolved"], "content": ["mask", "core", "cell", "config", "ext", "controller", "example", "right", "parent", "code", "inner", "any", "version", "sequence", "padding", "status", "query", "layout", "report", "ontent", "description", "template", "condition", "entity", "draft", "continue", "quest", "comment", "document", "search", "data", "cmd", "handle", "temp", "output", "edit", "expression", "html", "valid", "section", "address", "body", "resource", "current", "null", "magic", "xml", "contact", "page", "good", "never", "result", "activity", "tx", "twitter", "article", "message", "load", "Content", "history", "reason", "time", "metadata", "filter", "raw", "ez", "read", "ce", "wrapper", "txt", "cont", "command", "here", "zero", "value", "lead", "media", "info", "full", "format", "empty", "context", "act", "image", "c", "cache"]}}
{"id1": "21181542", "id2": "16511008", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "label": 1, "substitutes": {"deleteRoleType": ["deleteRoleTyp", "deleteRoleTypes", "DeleteRoleType", "deleteGroupTyp", "deleteResourceType", "deleteResourceTyp", "DeleteRoleTyp", "deleteGroupType", "deleteResourceTypes", "deleteGroupTypes", "DeleteRoleTypes"], "id": ["path", "edit", "ident", "ide", "ion", "part", "node", "add", "orig", "x", "time", "instance", "Id", "it", "val", "type", "is", "link", "and", "rid", " pid", "p", "no", "h", "end", "create", "pid", "like", "mid", "t", "kid", " tid", "created", "iden", "ref", "hide", "ids", "key", "name", "bid", "d", "aid", "index", "uid", "l", "only", "event", "sid", "def", "hash", "vid", "show", "i", "info", "oid", "url", "in", "ID"], "namespaceId": ["namesplaceRef", " namespaceIdent", "namespacesRef", "nameshipID", "namesspaceAnd", "namespaceLog", "typesACEId", "namesACEId", "namesspaceid", "namespointRef", "namespaceid", "namespointName", "namesositoryBirth", " namespaceOr", "workspaceName", "namesplaceid", " namesiteIdent", "namesenceOr", "typespaceID", "workshipKey", "worksplaceName", "namesistenceLog", "namespaceIdent", "namespaceName", "namesenceId", "namesenceID", "namespacesid", "worksetAnd", " namesenceID", "namesistenceIdent", "worksplaceRef", "namespaceOr", "namesadeAnd", "namespacesId", "namespointID", "namespacesID", "workshipid", "namesetid", "namesositoryID", "workshipID", "namesistenceOr", "namesACEID", "namesiteId", "worksplaceid", " namesiteOr", "worksetId", "worksplaceId", "namesistenceId", " namespaceLog", "namesaceID", "namespaceBirth", "namesadeID", "workspaceRef", "namespaceRef", "typesACEAnd", " namesiteLog", " namespaceBirth", "namesetID", "namesositoryId", "namesaceId", "namespacesAnd", "namespaceID", " namesenceId", "namesaceid", "namesaceKey", "namespaceKey", "typesACEID", "namesplaceName", "namespacesKey", "namesetId", "workspaceid", "namesiteIdent", "namesiteOr", "namespaceAnd", "namesetAnd", "namespacesBirth", "worksetid", "workspaceAnd", "namesenceBirth", "namespointAnd", "workspaceKey", "namesadeId", " namespaceID", "namespointid", "nameshipid", "nameshipKey", "namesiteLog", "namesACEAnd", "nameshipId", "worksetID", "namespacesName", "namesplaceId", " namesenceBirth", "typespaceAnd", "workshipId", "namesspaceID", "namesenceIdent", "namespointId", "namesspaceId", " namesiteId", "workspaceId", "namesenceLog", "workspaceID", "typespaceId"], "removeReferencesInRoleTypes": ["removeReferencesInRightFiles", "removeReferencesFromroleType", "removeReferencesInroleTypes", "removeReferencesFromroleTypes", "removeReferencesFromMultipleType", "removeReferencesInroleNames", "removeReferencesInRoleFiles", "removeReferencesInRightType", "removeReferencesInRightTypes", "removeReferencesFromroleFiles", "removeReferencesInRightNames", "removeReferencesFromMultipleNames", "removeReferencesInMultipleFiles", "removeReferencesFromRoleType", "removeReferencesInRoleType", "removeReferencesFromRoleTypes", "removeReferencesFromRoleFiles", "removeReferencesInRuleType", "removeReferencesInRoleNames", "removeReferencesInMultipleNames", "removeReferencesInRuleNames", "removeReferencesInroleType", "removeReferencesInMultipleType", "removeReferencesInMultipleTypes", "removeReferencesInRuleTypes", "removeReferencesInRuleFiles", "removeReferencesFromMultipleTypes", "removeReferencesFromroleNames", "removeReferencesInroleFiles", "removeReferencesFromMultipleFiles", "removeReferencesFromRoleNames"], "permit": ["permission", "PERMIT", "Permission", "PERmiss", "PERmit", "Permitted", "permiss", "promit", "PERmitted", "PerMIT", "Permiss", "proMIT", "promission", "promitted", "perMIT", "permitted", "Permit", " perMIT", "PERmission", " permitted", " permiss"], "exist": ["ist", "have", "icate", "connect", "missing", "mark", "add", "save", "existent", "present", "ext", "see", "purpose", "keep", "create", "existence", "respond", "register", "use", "login", "current", "filename", "require", "ready", "existing", "write", " extant", "define", "know", "meet", "cont", "status", "same", "find", "establish", "attach", "there", "alias", "include", "remember", "list"], "msgBuf": ["msgBsuf", "messageBlf", "messageBuf", "msgPbuf", "msgPuff", "msgRfg", "messageRbuff", "msgMuf", "messagePfg", "msgGbuf", " msgRlim", "messageMuf", "msgRuff", "msgBbuff", "msgBsfg", "msgRlim", " msgCfg", "messageMbuff", "msgGbuff", "msgAbuff", "messageBuff", "msgBlf", "msgMbuf", "msgCuff", "msgBefg", " msgMbuff", " msgBbuf", " msgCbuf", "msgMuff", "msgBeuf", "msgVbuf", " msgRuf", "messageMbuf", "msgVuff", "messageRuf", "msgRlf", " msgRbuff", " msgCuff", "msgBsuff", "messagePuf", "msgCbuff", "messageRbuf", " msgCuf", "msgRbuf", "msgBsbuf", "msgAuf", "msgRuf", "messageBbuff", " msgBlim", " msgMuff", " msgBfg", "msgAbuf", "messageBbuf", "msgBebuf", " msgBbuff", "msgBuff", "messageMuff", "messagePbuf", "msgBeuff", "msgVbuff", "msgBbuf", "msgPbuff", "messageBfg", "msgPuf", "messageRuff", "msgCuf", "msgGlim", "msgBfg", "msgGuf", "messageRlf", "msgBlim", "msgVuf", "messagePuff", "msgCfg", "msgMbuff", "msgCbuf", " msgRbuf", "msgPfg", " msgMuf", "msgPlf", "msgRbuff", " msgBuff", "msgAuff", " msgMbuf"], "objects": ["uploads", "assets", "faces", "units", "products", "links", "beans", "artifacts", "locks", "workers", "headers", "ports", "versions", "plugins", "ors", "articles", "images", "frames", "pages", "jobs", "airs", "obs", "lines", "classes", "files", "packages", "bits", "books", "ids", "builders", "authors", "codes", "points", "keys", "oids", "errors", "values", "projects", "models", "parts", "tools", "apps", "organisms", "relations", "docs", "resources", "flows", "blocks", "items"], "sqlRightId": [" sqlRightRef", " sqlrightById", " sqlRightById", "sqlRightName", "sqlHeadId", "sqlrightById", "sqlHeadid", "sqlrightRef", "qlRightId", "sqlLeftName", "qlrightId", "qlrightName", " sqlrightId", "sqlLeftId", "sqlHeadRef", "qlRightName", "sqlrightName", "sqlRightRef", "qlRightid", " sqlRightid", "sqlHeadById", "sqlrightId", "sqlRightById", " sqlrightid", "qlrightid", " sqlrightRef", "sqlRightid", "sqlLeftid", "sqlrightid"], "sqlParent": ["sqlOwner", "sprparent", "sysChild", "sprParent", "invChild", "sysParent", "sprOwner", "sysOwner", "invOwner", "invParent", "sqlChild", "sqlparent", "invparent", "sprChild", "sysparent"], "sql": ["orm", "session", "db", "json", "description", "password", "term", "template", "sys", "statement", "params", "ql", "body", "SQL", "execute", "dl", "security", "spec", "cfg", "md", "command", "drop", "acl", "action", "comment", "data", "cmd", "diff"], "pstmt": ["pondm", "pstatms", "pndm", "PStng", " pstatmt", "pndmk", "pndmt", "wpastmt", "wpastm", "PstatStatement", "NEW", "pndMT", "pastmm", " pstem", "pStm", " pstms", "pstatmm", "pstm", " pstatmp", "wpstMT", "Pstatm", "insert", "pstatem", "wpastMT", "pstatmp", "wpstm", "pthmp", " pstmp", "pondmt", "pastStatement", "wpastmk", "create", "PstStatement", "pstatm", "pastmk", " pstatem", "pstStatement", "pstartr", "pthmt", "PStr", "pStr", "NULL", "_", "def", "pstmm", "pstartmt", "Pstr", "pstatmt", "PStmt", "pstartm", "pstartng", "Pstng", "pstMT", "Exception", "pStmt", "pthem", "Delete", "pstem", "nt", "pStng", "pstmp", "pctms", "pstms", "wpstmt", "Pstatmm", "pstr", "pastmt", "tx", "postm", " pstatms", "pthms", "wpstmk", "Pstm", "PStm", "pstatStatement", "pastm", "Pstatmt", "pstng", "Pstmt", "pastMT", "pctem", "pctmt", "postMT", "pondStatement", "postmt", "Pstmm", "pondmm", "postmk", "pstmk", "context", "pctmp"], "typeGid": ["typeCno", "typeGenid", "typeCId", " typeCids", " typeCno", "TypeCid", "typeGuid", " typeGno", "TypeCID", "TypeCId", "typeGuno", "typeRegid", "TypeGID", "typeGids", "typeGno", "TypeGId", "typeGuID", "typeRegID", "typeRegId", " typeGids", "typeGID", "typeGenids", "typeGuId", "typeCids", "typeCID", " typeCid", "TypeGid", "typeGenno", "typeGuids", "typeCid", "typeGId"], "defaultLevel": ["defaultDepth", " defaultDepth", "Defaultlevel", "DefaultMode", "errorLevel", "DefaultLevel", " defaultMode", "errorDepth", "DefaultDepth", "defaultMode", " defaultlevel", "errorlevel", "defaultlevel", "errorMode"], "success": ["successfully", "progress", "close", "save", "unknown", " succeed", "state", "rc", "accept", "ok", "continue", "fail", "pass", "summary", "warn", "error", "good", "result", "submit", "primary", "status", "undo", "info", "Success", "successful", "failed", "first"]}}
{"id1": "22418839", "id2": "6171406", "code1": "    public void handleHandshake(Packet2Handshake par1Packet2Handshake) {\n        boolean flag = true;\n        String s = par1Packet2Handshake.username;\n        if (s == null || s.trim().length() == 0) {\n            flag = false;\n        } else if (!s.equals(\"-\")) {\n            try {\n                Long.parseLong(s, 16);\n            } catch (NumberFormatException numberformatexception) {\n                flag = false;\n            }\n        }\n        if (!flag) {\n            netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" });\n        } else if (par1Packet2Handshake.username.equals(\"-\")) {\n            addToSendQueue(new Packet1Login(mc.session.username, 29));\n        } else {\n            try {\n                URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString());\n                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s1 = bufferedreader.readLine();\n                bufferedreader.close();\n                if (s1.equalsIgnoreCase(\"ok\")) {\n                    addToSendQueue(new Packet1Login(mc.session.username, 29));\n                } else {\n                    netManager.networkShutdown(\"disconnect.loginFailedInfo\", new Object[] { s1 });\n                }\n            } catch (Exception exception) {\n                exception.printStackTrace();\n                netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { (new StringBuilder()).append(\"Internal client error: \").append(exception.toString()).toString() });\n            }\n        }\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 0, "substitutes": {"handleHandshake": ["handlehandshake", "handleServerication", "handleHealthication", "handleServershake", "handlehandRequest", "handlehandication", " handlehandchange", " handleHandRequest", "handleServerRequest", " handlehandshake", " handlehandication", "handlehandchange", " handleHandication", "handleHandchange", "handleHandRequest", "handleHealthchange", " handleHandchange", "handleHealthshake", " handlehandRequest", "handleHealthRequest", "handleServerchange", "handleHandication"], "par1Packet2Handshake": ["par1Packet2handshake", "par1Packet1Handlers", "par1Packet1handshake", "par1Packet1Handlelers", "par1Packet1Handler", "par1Packet1handza", "par1Packet2Hostle", "par1Packet2handlers", "par1Packet1handle", "par1Packet2Handleza", "par1Packet2Hshake", "par1Packet2Headza", "par1Packet2Headshake", "par1Packet2handza", "par1Packet2Hostshake", "par1Packet2Handlele", "par1Packet2handler", "par1Packet1Handshake", "par1Packet2Handleler", "par1Packet2Handle", "par1Packet2Headle", "par1Packet1Handleza", "par1Packet2Handleshake", "par1Packet2Hler", "par1Packet2Handlers", "par1Packet1Handle", "par1Packet2Handza", "par1Packet2Headlers", "par1Packet1Handza", "par1Packet2Handler", "par1Packet2Hostza", "par1Packet2Handlelers", "par1Packet1handler", "par1Packet2Hza", "par1Packet2handle", "par1Packet1Handleshake"], "s": ["ls", "st", "abs", "save", "j", "n", "se", "sl", "x", "is", "sort", "b", "gs", "simple", "f", "su", "p", "ss", "sql", "sing", "y", "ws", "h", "qs", "stats", "hs", "ds", "its", "conv", "t", "sym", "spec", "ps", "v", "rs", "js", "e", "ns", "less", "g", "str", "sts", "sh", "ts", "ats", "w", "l", "u", "c", "string", "gins", "i", "sam", "sb", "sv", "r", "S", "sq"], "flag": ["field", "arg", "agged", "mail", "cond", "leaf", "member", "sync", "valid", "and", "f", " Flag", "local", "Flag", "flags", "true", "bool", "stay", "nl", "ground", "lock", "tag", "continue", "fail", "cloud", "run", "ld", "error", "group", "store", "xml", "FLAG", "compl", "char", "level", "bird", "print", "stage", "line", "limit", "set", "status", "lead", "log", "file", "func", "lag", "car", "age", "agg", "cmd", "bug", "lv", "image"], "url": ["http", "mail", "ls", "location", "window", "sl", "user", "ret", "build", "bel", "link", "ur", "Url", "ul", "address", "ml", "socket", "URL", "rel", "ssl", "uri", "dl", "nl", "client", "channel", "resource", "browser", "gl", "str", "mount", "xml", "mb", "ll", "l", "char", "www", "lr", "acl", "https", "web", "r", "li", "il"], "bufferedreader": ["bufferedrar", "Bufferredreader", "buffledReader", "bufferredwriter", "buffledbuffer", "bufferedbuffer", "buffledreader", "buffererbuffer", "bufferingReader", "Bufferedrar", "bufferedwriter", "buffererwriter", "Bufferedbuffer", "bufferedReader", "buffledwriter", "bufferingreader", "buffererreader", "Bufferredrar", "bufferredreader", "Bufferedwriter", "BufferedReader", "bufferingrar", "bufferingwriter", "BufferredReader", "Bufferredbuffer", "Bufferredwriter", "bufferredbuffer", "buffererReader", "bufferredReader", "Bufferedreader", "buffledrar", "buffererrar", "bufferredrar"], "s1": ["sts001", "str4", " s4", "sesinton", "s2", " s0", "sinton", "stsinton", "s001", "psOne", " sOne", "ses001", "S0", "ps1", "s0", "str2", "sOne", "ses1", "sts2", "S2", "str1", "sts1", " s001", "S1", "ses2", "ps0", " s2", "s4", " sinton", "S4", "ps2", "str0", "SOne"]}}
{"id1": "3401153", "id2": "17947246", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"getHTML": ["getJS", " getJS", "processHTML", "printJS", "processJS", " getURL", "printHTML", " getPDF", "getPDF", "printPDF", "getURL", "processPDF", "processURL", "printURL"], "pageURL": ["baseURI", "pageurl", " pageUrl", "cacheURI", "baseURL", "pageURI", " pageurl", "cacheUrl", "cacheURL", " pageUR", "baseUrl", "Pageurl", "PageURL", " pageURI", "PageURI", "PageUrl", "cacheurl", "PageUR", "pageUrl", "pageUR", "baseUR"], "encoding": ["Encaching", "ecoder", "decoding", "decuation", "enoding", "enuation", "Encuation", "encoded", "uncoding", "enaching", "enoder", "uncaching", "ecoding", "ecaching", "uncoder", "encaching", "decoder", "Encoder", "ecoded", "Encoded", "encoder", "decaching", "encuation", "Encoding", "uncoded"], "dirPath": ["pathDir", "viewName", "pkgDirectory", "folderRoot", "viewPATH", "dirRoot", "pathRoot", " dirRoot", "pkgDir", "pathFile", "viewDir", "directoryDirectory", "folderDir", "pkgPath", "directoryPath", " dirFile", "directoryPATH", "dirFile", "pathPath", " dirDirectory", "directoryDir", "dirDir", "dirPATH", "dirName", "folderFile", "directoryName", " dirPATH", " dirName", "viewPath", " dirDir", "pkgName", "dirDirectory", "folderPath"], "pageHTML": ["viewJSON", "searchHT", "pointHTTP", "componentHTML", "PageHTTP", "viewMD", "pointHTML", "agePUT", "componentHT", "pageJS", "viewHTML", "entryJS", "ageWP", " pageAPI", "searchHTML", "ageHT", "PageJS", "PageHT", "pagePUT", " pageHTTP", "searchJS", " pageWP", "componentSQL", "PageHTML", "ageSQL", "entryHTML", " pagePUT", "pageAPI", "entryAPI", "pageSQL", "entryHTTP", "pointJS", " pageJS", "pageMD", "searchURL", "displayHTML", "displayJS", "pointAPI", " pageJSON", "pageHT", "ageHTML", " pageMD", "pageJSON", " pageHT", "displayURL", "componentWP", "PageURL", " pageSQL", "pageHTTP", "viewPUT", "pageWP", "displayHTTP", "ageJSON", "ageMD"], "connection": ["bo", "nc", "message", "http", "session", "connect", "application", "ion", "Connection", "con", "description", "close", "open", "user", "link", "database", "response", "generation", "condition", "statement", "processor", "internet", "reference", "socket", "console", "character", "to", "relation", "io", "creator", "uri", "client", "resource", "channel", "current", "server", "browser", "library", "creation", "government", "communication", "operation", "writer", "engine", "still", "number", "established", "position", "connected", "directory", "conn", "remote", "command", "entry", "web", "document", "c", "network"], "url": ["path", "http", "ls", "location", "sl", "open", "bel", "link", "b", "Url", "f", "address", "ur", "ul", "URL", "p", "loader", "rel", "api", "ssl", "uri", "dl", "nl", "atl", "resource", "client", "gl", "google", "name", "str", "ll", "get", "l", "net", "conn", "base", "rl", "https", "web", "r"], "br": ["ch", "wr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "bs", "BR", "bl", "hr", "bb", "pr", "er", "fr", "bt", "Br", "cr", "bro", "be", "str", "gb", "vr", "mr", "tr", "bridge", "bc", "sr", "lr", "bh", "sp", "kr", "ber", "r", "rb"], "line": ["field", "style", "text", "cell", "block", "lin", "phrase", "ln", "section", "user", "eline", "detail", "link", "entity", "row", "sample", "frame", "stay", "nl", "liner", "email", "continue", "le", "code", "inline", "ine", "label", "LINE", "number", "l", "quote", "page", "online", "sequence", "entry", "string", "print", "source", "point", "stroke", "log", "comment", "range", "chain", "word", "Line"], "e": ["ve", "ite", "es", "x", "se", "ent", "te", "fe", "ie", "ze", "see", "f", "je", "p", "eeee", "xe", "ce", "en", "re", "ke", "ed", "er", "ex", "ee", "E", "le", "oe", "eb", "ine", "esome", "be", "error", "ode", "he", "ue", "ae", "err", "event", "pe", "ne", "ge", "de"], "file": ["path", "buffer", "output", "db", "mail", "task", "tile", "link", "handle", "f", "et", "h", "dir", "fp", "io", " File", "File", "resource", "el", "lock", "email", "parent", "le", "name", "page", "ile", "directory", "print", "FILE", "base", "port", "table", "log", "web", "work", "data", "out", "ca", "image", "report"], "bufferedWriter": ["bufferedMember", "bufferedWrite", " bufferredWriter", "buffaredReader", "buffaredwriter", "builteredReader", "buffererMember", "bufferredwriter", "buffenedClient", "bufferingReader", " bufferedHelper", "bufferredWrite", "bufferedwriter", "bufferedReader", "bufferedStreamer", "bufferredClient", " bufferedwriter", " bufferedClient", "bufferingClient", "buffaredWrite", "buffenedWrite", "builteringMember", " bufferedStreamer", " bufferredWrite", "bufferredStreamer", "bufferredHelper", "bufferingWrite", "buffaredMember", "builteringReader", " bufferredwriter", "buffaredStreamer", "bufferedHelper", "buffenedWriter", "bufferingwriter", "buffenedHelper", "bufferingWriter", " bufferredStreamer", " bufferredHelper", " bufferredClient", "buffererReader", "bufferingHelper", " bufferedWrite", "buffaredWriter", "builteredWriter", "bufferedClient", "builteredMember", "buffererWriter", "bufferredWriter", "bufferingMember", "builteringWriter", "bufferingStreamer"]}}
{"id1": "12454178", "id2": "17083703", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"alterar": [" ingestada", " ingestar", " ingestasar", " alterado", " consequasar", " scalada", " consequada", " ingestado", " scalar", " alterasar", " alterada", " consequado", " scalado", " consequar", " scalasar"], "t": [" ot", "T", "task", "qt", "st", "x", "j", "n", "template", "it", "ent", "te", "ret", "type", "tt", "a", "b", "title", "tp", "tm", "et", "mint", "q", "tu", "ct", "p", "y", "ta", "o", "h", "to", "mt", "dt", "pt", "total", "typ", "v", "nt", "translation", "det", "e", "at", "wt", "ti", " pt", "rt", "tree", "g", "tc", "ts", "vt", "w", "get", "l", "tr", "txt", "ter", "ht", "tip", "m", "table", "tg", "z", "i", "ot", "trace", "out", "temp", "c"], "stmt": ["ststat", "sttxt", "ttstat", "irsttx", "stMT", "irstmk", " sttxt", "Stm", "irstmt", "symon", " superstmt", "stm", "stytm", " superstmr", "styMT", "StMT", " supersttx", " stmon", " supersttxt", "sysm", "Ststat", "Sttm", "stmk", " sttx", "sttm", "sym", "Stmp", " stsm", "stym", "Stmt", " stmp", "stymt", "ttmp", "ttm", " stmr", "symt", "stmp", "stmon", "ttmt", " superstMT", " stmk", "Sttxt", "stymon", " stm", " ststat", "stsm", " stMT", "Stmr", "stytx", "Sttx", "Stmk", "irstMT", " sttm", "sttx", "stmr", "stysm"], "sql": ["fn", "series", "expression", "spr", "lex", "ls", "description", "template", "n", "ln", "pel", "sd", "wal", "sys", "seed", "q", "ql", "su", "SQL", "dl", "nl", "initial", "el", "spec", "lock", "QL", "sol", "name", "xml", "l", "string", "select", "scl", "csv", "table", "software", "query", "sv", "s", "format", "url", "sk", "cmd", "sq"], "id_disciplina": ["id_DisciplINA", "id_disciplinator", "id_Disciplini", "id_discomplain", "id_desciplina", "id_discompline", "id_Discipline", "id_Discomplina", "id_Disciplineinator", "id_Disciplina", "id_displinate", "id_DisciplineINA", "id_disciina", "id_Disciplinate", "id_disrigINA", "id_discomini", "id_disciplinate", "id_descomplain", "id_desciplain", "id_disriginator", "id_Disciplain", "id_discomina", "id_displinator", "id_descompline", "id_disciplineina", "id_Discomplini", "id_disgrain", "id_disciini", "id_disgrini", "id_disgrina", "id_desciplini", "id_disrigina", "id_disciplINA", "id_disciplineinate", "id_Discomplain", "id_disriginate", "id_displINA", "id_disciplineINA", "id_displain", "id_Disciplineina", "id_displine", "id_disciain", "id_discipline", "id_discomplini", "id_disciplini", "id_discomain", "id_disciine", "id_Disciplineinate", "id_discomine", "id_Discompline", "id_disciplineinator", "id_descomplini", "id_disgrine", "id_descipline", "id_disciplain", "id_Disciplinator", "id_displini", "id_discomplina", "id_displina", "id_descomplina"], "item": ["site", "task", "iso", "instance", "it", "menu", "link", "rec", "me", "bar", "id", "p", "local", "row", "mi", "ex", "element", "Item", "component", "e", "team", "key", "store", "unit", "other", "obj", "event", "hit", "entry", "tip", "object", "iter", "match", "job", "i", "info", "in", "items", "word", "image", "article"]}}
{"id1": "13852596", "id2": "20128728", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"execute": [" release", "init", " inherit", " proceed", " evaluate", " replay", " sweep", "evaluate", " execution", " chain", " resolve", "run", "process", " launch", " eval", " test", " perform", " executed", " exec", "launch", " executable", "construct", " scan", " assemble", " benchmark", " deploy", "exec"], "resources": ["uploads", "faces", "artifacts", "ris", "banks", "locks", "workers", "users", "types", "accessible", "ports", " Resources", "Resources", "rooms", "lets", "images", "pointers", "writers", "rows", "roots", "files", "classes", "packages", "resource", "rs", "ions", "actions", "these", "builders", "ids", "ifiers", "scripts", "they", "archives", "bytes", "projects", "models", "reports", "apps", "relations", "flows", "modules", "results", "stores", "names", "issues", "groups", "blocks", "res", "items", "objects", "services"], "i": ["multi", "ims", "im", "j", "phi", "ini", "ri", "ai", "ui", "bis", "ia", "iu", "q", "abi", "iri", "h", "ali", "io", "mi", "ci", "ki", "ex", "ii", "t", "v", "gi", "e", "hi", "ti", "g", "ji", "bi", "si", "I", "l", "ir", "xi", "cli", "ori", "mu", "\u0438", "ami", "di", "pi", "info", "ios", "ij", "in", "ip", "li", "oi", "list"], "classFile": ["attributeFiles", "typeFile", "classfile", "ClassTree", " classSourceFile", "ClassFiles", "recordFilename", "userfile", "fastFILE", " classLine", "attributeFile", "targetFile", "classResource", " classChain", " classfile", "fastFile", "attributeResource", "classFILE", "objectFile", "classDirectory", "parentfile", " classFolder", "clFiles", "parentSourceFile", "parentFILE", "targetFiles", "userFILE", "ClassLine", "sourceFile", "typeFILE", "typeLine", " classFILE", "recordFile", "classTree", "classifiedFile", "objectClass", "userFile", "classFolder", "sourceFILE", "connectionSourceFile", "classLine", "ClassFile", "ClassEntry", " classFiles", "cellFile", "classifiedFILE", "Classfile", "userFiles", "attributeEntry", " classClass", "attributeFILE", "sourceFiles", "classifiedFiles", " classResource", "parentFile", "connectionfile", "connectionFile", "classifiedSourceFile", "classFiles", "cellFolder", "clfile", "classifiedfile", "ClassDirectory", "typeFiles", "cellClass", "recordfile", "targetFILE", "recordFiles", "objectFolder", "instanceFilename", " classFilename", "classFilename", "ClassChain", "clTree", "classClass", " classEntry", " classTree", "instanceDirectory", "targetSourceFile", "sourceClass", "connectionFILE", "ClassFilename", "instanceFile", "fastFiles", "ClassClass", "clFile", "fastfile", "classSourceFile", "ClassResource", "attributeChain", "ClassSourceFile", " classDirectory", "instanceFiles", "classChain", "ClassFILE", "classEntry"], "inputStream": ["InputStream", "familyFile", "outputTime", "innerSet", "innerStreamer", "outputSteam", "inputTime", "audioStreamer", "inputstream", "audioSt", "InputSteam", "jsonSet", "ipFile", "jsonStreamer", "errorSteam", "outputFile", "familySource", " inputSource", "ipStream", " inputStreamer", "Inputstream", "outSt", "inputMode", "familyStyle", " inputSt", "outputPort", "outSteam", " inputPort", " inputSteam", "inputSet", "thisFile", "inSet", "InputTime", "ipSteam", "outputstream", " inputTime", "inStreamer", "InputMode", "familyStream", "familySteam", "inputSteam", "inStream", " inputMode", "inputStyle", "inputSt", "audioSteam", "thisSteam", "inSteam", "innerStream", "thisSource", "outputStyle", "inPort", "inputFile", "inputPort", "ipStyle", "thisStream", "jsonSteam", "errorstream", "innerSteam", "audioStream", " inputstream", " inputFile", "inputSource", "inputStreamer", "outStream", "errorStream", "outStreamer", "errorMode", "instream", "jsonStream"], "reader": ["field", "runner", "dr", "owner", "builder", "per", "ger", "rar", "penter", "instance", "user", "worker", "author", "peer", "manager", "review", "definition", "rer", "loader", "master", "image", "variable", "parser", "read", "row", "iterator", "test", "editor", "older", "er", "red", "draft", "client", "wrapper", "operator", "write", "key", "inner", "rule", "readable", "reading", "handler", "dd", "stream", "service", "mr", "oder", "Reader", "ner", "entry", "prototype", "Writer", "layer", "rl", "driver", "actor", "document", "query", "finder", "r", "ler"], "oldSize": ["oldFontSize", "OLDFontSize", "oldersize", "OLDSize", "olderSize", " oldFontSize", "OLDsize", " oldsize", "oldsize", "oldLength", "olderLength", " oldLength", "olderFontSize", "OLDLength"], "writer": ["runner", "buffer", "message", "builder", "owner", "adder", "node", "penter", "method", "buf", "worker", "draw", "author", "manager", "review", "wrote", "definition", "riter", "loader", "writers", "variable", "parser", "weight", "writing", "read", "row", "test", "er", "draft", "rw", "wrapper", "write", "key", "inner", "written", "handler", "w", "wb", "service", "player", "storage", "ter", "vector", "Reader", "ner", "entry", "Writer", "ler", "driver", "actor", "walker", "document", "finder", "format", "r", "word", "editor"], "b": ["B", "bf", "db", "binary", "n", "nb", "a", "bp", "f", "bis", "ob", "bs", "p", "h", "bound", "bb", "erb", "fb", "t", "bits", "v", "bin", "emb", "ab", "g", "bit", "ib", "mb", "d", "gb", "w", "wb", "l", "u", "base", "batch", "m", "br", "sb", "r", "c", "rb"], "outputStream": ["outputSteam", "resultSteam", "inputstream", "Outputstream", " outputForm", "resultForm", "OutputString", "inputView", "resultstream", "writeSteam", " outputPoint", "outputForm", "writeView", "outputstream", "OutputSteam", "writePoint", "resultString", "inputSteam", "outputView", "inputPoint", "inputForm", "outputString", "writeStream", "OutputStream", " outputString", "outputPoint", " outputSteam", "resultStream", "OutputForm", " outputView"], "injectedClasses": ["injectUsES", "injectedClassets", "injectedSuccessets", "injectedSuccessES", "injectedUses", "injectedClassES", "injectedCountES", "injectedSuccesses", "injectedUsets", "injectUses", "injectedCountBytes", "injectClassets", "injectedClassBytes", "injectUsets", "injectedUsES", "injectedCountets", "injectedUsBytes", "injectUsBytes", "injectClassBytes", "injectedCountes", "injectClasses", "injectedSuccessBytes", "injectClassES"], "newSize": ["oldFontSize", "NewMax", "newFontSize", "NewName", " newMax", " newFontSize", "newMax", "oldName", "NewSize", " newName", "oldMax", "NewFontSize", "newName"]}}
{"id1": "646016", "id2": "4481712", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"elimina": ["eligino", "alimine", "elimino", "allimine", "alimina", "elitino", "elimine", "ellimina", "ellimine", "alimino", "alimisa", "eligine", "allimino", "elitine", "elitisa", "eligisa", "elitina", "elimisa", "ellimino", "allimina", "ellimisa", "eligina", "allimisa"], "cli": ["grid", "multi", " CLI", "cu", "ln", "cci", "cho", "gil", "ui", "lu", "prot", "udi", "gui", "console", "util", "uci", "ctl", "ci", "dl", "Client", "client", "lc", "cfg", "eric", "e", "clus", "cgi", "coe", "l", "idi", "c", "conn", "cl", "GUI", " cl", "ctrl", "i", "coni", "pi", "cmd", "aci", "li", "dial", "Cl", "exe"], "id": ["out", "ident", "db", "mail", "ide", "Id", "it", "sd", "type", "is", "and", "rid", "ip", "ad", "del", "f", "no", "h", "end", "num", "pid", "ida", "mid", "kid", " fid", "with", "rand", "iden", "ref", "e", "ids", "code", "key", "null", "name", "bid", "d", "aid", "index", "uid", "md", "wid", "sid", "hash", "status", "value", "vid", "did", "i", "info", "oid", "url", "start", "in", "res", "ID"], "sql": ["fn", "expression", "spr", "db", "mail", "json", "html", "ms", "lex", " SQL", "ping", "ls", "sl", "ln", "lua", "pel", "msg", "sd", "sal", "sys", "pkg", "wal", "shell", "ql", "socket", "ds", "util", "inv", "SQL", "xs", "ssl", "dl", "nl", "pp", "security", "spec", "ps", "lock", "services", "js", "QL", "ship", "ns", "sol", "ips", "xml", "ll", "owl", "details", "string", "scl", "csv", "software", "sb", "sp", "https", "sv", "s", "format", "what", "query", "sk", "url", "eps", "sq"], "stmt": ["Stmm", "STm", "stMT", "strmt", "Stm", "scm", "STmn", "stm", "tm", "StMT", "stmm", "STmm", "strMT", "Sttm", "Stmb", "Stmt", "strmb", "scmm", "tmt", "ttm", "Stmn", "scmt", "stmn", "STMT", "tmm", " stm", "stmb", " stMT", " stmb", " stmm", "strm", " sttm", "sttm", " stmn", "STmt", "sctm"]}}
{"id1": "8973505", "id2": "19747399", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["readfileInfo", "writePageType", "writefileType", "writeContenttype", "writeContentInfo", "writePagetype", "writePageInfo", "readfileType", "readFileName", "readFileType", "writefileName", "readFiletype", "writeFileName", "writeFileInfo", "readfiletype", "writeContentName", "writePageName", "readFileInfo", "writeFiletype", "readfileName", "writefiletype", "writeContentType", "writefileInfo"], "uriFile": ["urifile", "fileFilename", "irifile", "filefile", "rangeFile", "filenameFilename", "URIfile", "rangefile", "rangeData", "uriFiles", "URIFiles", "uriData", "rangeFILE", "fileFile", "iriFILE", "URIFILE", "uriFILE", "URIFilename", "iriFile", "iriData", "URIData", "filenameFiles", "uriFilename", "fileFiles", "URIFile", "filenameFile", "filenamefile"], "outputfile": ["OutputFILE", " outputf", "outf", "inputFILE", "outputFILE", "imageFILE", "outputFile", "imagefile", "Outputport", " outputbase", "imageFile", "outputbase", "Outputfile", "outputf", "inputbase", "outbase", "outfile", "inputf", "inputFile", "imageport", "OutputFile", " outputFile", "inputport", "outputport", "outFile", "inputfile"], "num": ["multi", "con", "add", "x", "n", "nb", "um", "count", "Num", "nm", "mult", "no", "alph", "end", "Number", "np", "NUM", "current", "total", "cmp", "all", "done", "mon", "required", "index", "number", "nam", "check", "m", "nom", "zero", "max", "random"], "writer": ["runner", "usher", "function", "window", "term", "author", "connection", "processor", "riter", "writers", "writing", "to", "timer", "linger", "inner", "written", "external", "service", "utils", "file", "storage", "wire", "buffer", "link", "ender", "variable", "maker", "liner", "operator", "write", "w", "player", "entry", "comment", "document", "width", "data", "memory", "commit", "RW", "builder", "worker", "manager", "loader", "iterator", "writ", "er", "client", "resource", "server", "will", "journal", "Reader", "ner", "Writer", "table", "driver", "ener", "owner", "thus", "caster", "flush", "console", "read", "test", "creator", "wright", "wrapper", "handler", "stream", "director", "event", "record", "layer", "format", "widget", "editor", "network"], "uri": ["http", "location", "ri", "sofar", "connection", "folder", "wiki", "basic", "qi", "channel", "verb", "inner", "du", "form", "file", "query", "origin", "ugi", "obo", "description", "uni", "link", "ui", "ur", "rid", "umi", "uno", "queue", "qu", "hi", "remote", "details", "domain", "chain", "https", "ip", "doi", "multi", "prefix", "phrase", "address", "via", "id", "ource", "iri", "iterator", "subject", "resource", " URI", "browser", "uu", "unit", "uid", "directory", "result", "ei", "copy", "pi", "phi", "hyper", "user", "reference", "mi", "filename", "general", "ref", "ni", "bid", "username", "URI", "ir", "href", "source", "i", "range", "image"], "counter": ["buffer", "message", "const", "pointer", "term", "phrase", "time", "instance", "book", "cover", "money", "another", "TER", "controller", "loop", "currency", "processor", "Counter", "manager", "count", "ounter", "loader", "norm", "common", "machine", "iterator", "card", "creator", "cms", "nr", "frequency", "ier", "conv", "total", "scope", "timer", "continue", "browser", "key", "clock", "inner", "ctr", "index", "mill", "number", "container", "mr", "ter", "sequence", "entry", "amount", "mer", "meter", "cookie", "system", "walker", "finder", "memory", "context", "random", "outer", "coll", "editor", "order"], "reader": ["buffer", "runner", "builder", "rar", "method", "rx", "processor", "address", "loader", "parser", "read", "row", "iterator", "older", "er", "resource", "liner", "server", "timer", "journal", "inner", "dd", "handler", "player", "redo", "upper", "Reader", "ner", "entry", "roller", "input", "iter", "rl", "layer", "file", "driver", "ro", "document", "yer", "context", "r", "editor"], "url": ["http", "mail", "location", "sl", "open", "build", "bel", "link", "ur", "Url", "address", "URL", "rel", "github", "re", "ssl", "dl", "loc", "nl", "resource", "client", "browser", "gl", "ref", "google", "str", "mount", "name", "ll", "get", "l", "char", "www", "base", "https", "web", "r", "li", "hl", "il"], "myConnection": ["myConnect", " myLink", "yourConnector", " myconnection", " myConnect", " myConn", "myConn", "newLink", "yourLink", "thisLink", "yourconnection", "thisConnection", "newConnection", "MyLink", "MyConnection", "Myconnection", "thisConn", "myLink", "newConnect", "myConnector", "yourConnection", "thisConnect", "newConn", "MyConnector", " myConnector", "myconnection"], "myReader": ["MyReader", "myWriter", "yourRead", "myFr", "MyWriter", "MyParser", "yourParser", "yWriter", "MyRead", "ySer", "myRead", "mxSer", "mxWriter", " mySer", "yFr", "yReader", "mxFr", "myParser", "mxReader", "yourWriter", " myFr", " myParser", " myRead", "mySer", "yourReader", " myWriter"], "line": ["message", "style", "text", "part", "cell", "block", "lin", "ln", " Line", "user", "lo", "eline", "detail", "link", "normal", "ip", "lane", "definition", "body", "raw", "no", "row", " LINE", "sample", "frame", "ole", "channel", "liner", "email", "le", "code", "inline", "ine", "rule", "label", "ode", "edge", "LINE", "one", "l", "char", "page", "online", "sequence", "entry", "point", "iter", "stroke", "log", "range", "comment", "side", "ge", "trace", "cli", "word", "Line"], "linecount": ["strokeconsider", "strokecount", "Linecount", "inlineconst", "lineconfig", "linerconfig", " linecounter", " linefound", "linamount", "linconsider", "elineconst", "linefound", " lineconfig", "LineCount", "linelength", "strokenumber", "Lineconfig", " linelength", "inlinecount", " lineamount", "linenumber", "inlinelength", "linnumber", "linecounter", "linerCount", "elinelength", " lineconsider", "linerfound", "strokeamount", "elinecount", " lineconst", " linenumber", "lineconst", "Linefound", "lineamount", "inlinecounter", "lineCount", "elinecounter", " lineCount", "lineconsider", "lincount", "linercount"], "hasOWL": ["hasOHLP", "hasROL", "hasOWNLP", "HasOWSB", "HasOWSL", "hasOWSL", "HasOWL", "hasOWSNL", "hasOHL", "hasEWL", "hasROLP", "hasOWB", "hasOWSLS", " hasOWLS", " hasEWL", "hasOWNNL", " hasEWLS", " hasOWSL", "hasOWSR", " hasOWLP", "hasEWS", " hasEWR", "hasOHB", "hasOWSB", "hasSOL", "hasEWR", "hasOWR", "hasSOLP", "hasROR", "HasOWS", "HasOWB", " hasOWSLP", "hasOWSS", "hasRONL", "hasOWNL", "hasOWSLP", "hasSOR", "hasOHS", "HasOWSLP", "hasOWLS", "hasOWLP", " hasOWSNL", "hasOWNR", "hasSOLS", " hasOWSR", " hasEWLP", "hasEWLS", " hasOWR", "hasEWB", "hasEWLP", "HasOWLP", "hasOWS", " hasOWNL", "HasOWSS"], "hasRDFS": ["hasRdfDS", "hasSRDSB", "hasRRIs", "hasRDFB", "hasRdfB", "hasRdfM", "hasRDSB", "hasRDSDS", "hasSRDFCS", "hasSRDSS", "hasXDFDS", "hasRDSS", "hasRNFM", "hasORDFS", "hasORDSS", "hasRRICS", "hasXDFM", "hasRNFS", "hasSRDSs", "hasRRIB", "hasORDFs", "hasXDSs", "hasRDSM", "hasRMLS", "hasRDSs", "hasRDSCS", "hasORDFM", "hasORDSs", "hasRdfS", "hasRRIS", "hasRMLM", "hasRDFDS", "hasXDSS", "hasXDFs", "hasRMLDS", "hasSRDSCS", "hasRDFCS", "hasXDSDS", "hasRMLs", "hasORDFDS", "hasSRDFs", "hasSRDFB", "hasRDFs", "hasORDSDS", "hasSRDFS", "hasRdfCS", "hasRDFM", "hasXDFS", "hasRNFs", "hasORDSM", "hasRdfs", "hasRNFDS", "hasXDSM"], "hasRDF": ["hasRRDI", "hasRdf", "hasRCNF", "hasORNF", " hasDDF", "hasRRNF", " hasRDR", "hasRADF", "hasREDI", "hasRTDS", " hasRRDF", "hasRDS", "hasRDR", "hasRTDF", "hasDDF", " hasDNF", "hasDdf", "hsRDF", "hasRCD", "hasORDF", " hasRDS", "hsRRDT", "hasRRDR", "hasRRDT", "hasRADI", "hasRDT", "hsRDS", "hsRRDS", " hasRRDS", "hasRRCD", " hasDCD", "hasRCDF", "hasORDR", "hasREDT", "hsRRDF", "hasRTDR", "hasRRDF", " hasRRDR", "hasRRDS", "hasDCD", "hasDNF", "hasRNF", " hasRdf", "hasORDS", "hsRDI", "hasRTNF", "hasRCCD", " hasDdf", "hasREDF", " hasRCD", "hasRADS", "hasRRdf", " hasRRNF", " hasRNF", "hasRDI", "hasREDS", "hsRRDI", "hasRCdf", "hasRADT", "hsRDT"]}}
{"id1": "8973505", "id2": "8665321", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"writeFileType": ["readfileInfo", "writePageType", "writefileType", "writeContenttype", "writeContentInfo", "writePagetype", "writePageInfo", "readfileType", "readFileName", "readFileType", "writefileName", "readFiletype", "writeFileName", "writeFileInfo", "readfiletype", "writeContentName", "writePageName", "readFileInfo", "writeFiletype", "readfileName", "writefiletype", "writeContentType", "writefileInfo"], "uriFile": ["urifile", "fileFilename", "irifile", "filefile", "rangeFile", "filenameFilename", "URIfile", "rangefile", "rangeData", "uriFiles", "URIFiles", "uriData", "rangeFILE", "fileFile", "iriFILE", "URIFILE", "uriFILE", "URIFilename", "iriFile", "iriData", "URIData", "filenameFiles", "uriFilename", "fileFiles", "URIFile", "filenameFile", "filenamefile"], "outputfile": ["OutputFILE", " outputf", "outf", "inputFILE", "outputFILE", "imageFILE", "outputFile", "imagefile", "Outputport", " outputbase", "imageFile", "outputbase", "Outputfile", "outputf", "inputbase", "outbase", "outfile", "inputf", "inputFile", "imageport", "OutputFile", " outputFile", "inputport", "outputport", "outFile", "inputfile"], "num": ["multi", "con", "add", "x", "n", "nb", "um", "count", "Num", "nm", "mult", "no", "alph", "end", "Number", "np", "NUM", "current", "total", "cmp", "all", "done", "mon", "required", "index", "number", "nam", "check", "m", "nom", "zero", "max", "random"], "writer": ["runner", "usher", "function", "window", "term", "author", "connection", "processor", "riter", "writers", "writing", "to", "timer", "linger", "inner", "written", "external", "service", "utils", "file", "storage", "wire", "buffer", "link", "ender", "variable", "maker", "liner", "operator", "write", "w", "player", "entry", "comment", "document", "width", "data", "memory", "commit", "RW", "builder", "worker", "manager", "loader", "iterator", "writ", "er", "client", "resource", "server", "will", "journal", "Reader", "ner", "Writer", "table", "driver", "ener", "owner", "thus", "caster", "flush", "console", "read", "test", "creator", "wright", "wrapper", "handler", "stream", "director", "event", "record", "layer", "format", "widget", "editor", "network"], "uri": ["http", "location", "ri", "sofar", "connection", "folder", "wiki", "basic", "qi", "channel", "verb", "inner", "du", "form", "file", "query", "origin", "ugi", "obo", "description", "uni", "link", "ui", "ur", "rid", "umi", "uno", "queue", "qu", "hi", "remote", "details", "domain", "chain", "https", "ip", "doi", "multi", "prefix", "phrase", "address", "via", "id", "ource", "iri", "iterator", "subject", "resource", " URI", "browser", "uu", "unit", "uid", "directory", "result", "ei", "copy", "pi", "phi", "hyper", "user", "reference", "mi", "filename", "general", "ref", "ni", "bid", "username", "URI", "ir", "href", "source", "i", "range", "image"], "counter": ["buffer", "message", "const", "pointer", "term", "phrase", "time", "instance", "book", "cover", "money", "another", "TER", "controller", "loop", "currency", "processor", "Counter", "manager", "count", "ounter", "loader", "norm", "common", "machine", "iterator", "card", "creator", "cms", "nr", "frequency", "ier", "conv", "total", "scope", "timer", "continue", "browser", "key", "clock", "inner", "ctr", "index", "mill", "number", "container", "mr", "ter", "sequence", "entry", "amount", "mer", "meter", "cookie", "system", "walker", "finder", "memory", "context", "random", "outer", "coll", "editor", "order"], "reader": ["buffer", "runner", "builder", "rar", "method", "rx", "processor", "address", "loader", "parser", "read", "row", "iterator", "older", "er", "resource", "liner", "server", "timer", "journal", "inner", "dd", "handler", "player", "redo", "upper", "Reader", "ner", "entry", "roller", "input", "iter", "rl", "layer", "file", "driver", "ro", "document", "yer", "context", "r", "editor"], "url": ["http", "mail", "location", "sl", "open", "build", "bel", "link", "ur", "Url", "address", "URL", "rel", "github", "re", "ssl", "dl", "loc", "nl", "resource", "client", "browser", "gl", "ref", "google", "str", "mount", "name", "ll", "get", "l", "char", "www", "base", "https", "web", "r", "li", "hl", "il"], "myConnection": ["myConnect", " myLink", "yourConnector", " myconnection", " myConnect", " myConn", "myConn", "newLink", "yourLink", "thisLink", "yourconnection", "thisConnection", "newConnection", "MyLink", "MyConnection", "Myconnection", "thisConn", "myLink", "newConnect", "myConnector", "yourConnection", "thisConnect", "newConn", "MyConnector", " myConnector", "myconnection"], "myReader": ["MyReader", "myWriter", "yourRead", "myFr", "MyWriter", "MyParser", "yourParser", "yWriter", "MyRead", "ySer", "myRead", "mxSer", "mxWriter", " mySer", "yFr", "yReader", "mxFr", "myParser", "mxReader", "yourWriter", " myFr", " myParser", " myRead", "mySer", "yourReader", " myWriter"], "line": ["message", "style", "text", "part", "cell", "block", "lin", "ln", " Line", "user", "lo", "eline", "detail", "link", "normal", "ip", "lane", "definition", "body", "raw", "no", "row", " LINE", "sample", "frame", "ole", "channel", "liner", "email", "le", "code", "inline", "ine", "rule", "label", "ode", "edge", "LINE", "one", "l", "char", "page", "online", "sequence", "entry", "point", "iter", "stroke", "log", "range", "comment", "side", "ge", "trace", "cli", "word", "Line"], "linecount": ["strokeconsider", "strokecount", "Linecount", "inlineconst", "lineconfig", "linerconfig", " linecounter", " linefound", "linamount", "linconsider", "elineconst", "linefound", " lineconfig", "LineCount", "linelength", "strokenumber", "Lineconfig", " linelength", "inlinecount", " lineamount", "linenumber", "inlinelength", "linnumber", "linecounter", "linerCount", "elinelength", " lineconsider", "linerfound", "strokeamount", "elinecount", " lineconst", " linenumber", "lineconst", "Linefound", "lineamount", "inlinecounter", "lineCount", "elinecounter", " lineCount", "lineconsider", "lincount", "linercount"], "hasOWL": ["hasOHLP", "hasROL", "hasOWNLP", "HasOWSB", "HasOWSL", "hasOWSL", "HasOWL", "hasOWSNL", "hasOHL", "hasEWL", "hasROLP", "hasOWB", "hasOWSLS", " hasOWLS", " hasEWL", "hasOWNNL", " hasEWLS", " hasOWSL", "hasOWSR", " hasOWLP", "hasEWS", " hasEWR", "hasOHB", "hasOWSB", "hasSOL", "hasEWR", "hasOWR", "hasSOLP", "hasROR", "HasOWS", "HasOWB", " hasOWSLP", "hasOWSS", "hasRONL", "hasOWNL", "hasOWSLP", "hasSOR", "hasOHS", "HasOWSLP", "hasOWLS", "hasOWLP", " hasOWSNL", "hasOWNR", "hasSOLS", " hasOWSR", " hasEWLP", "hasEWLS", " hasOWR", "hasEWB", "hasEWLP", "HasOWLP", "hasOWS", " hasOWNL", "HasOWSS"], "hasRDFS": ["hasRdfDS", "hasSRDSB", "hasRRIs", "hasRDFB", "hasRdfB", "hasRdfM", "hasRDSB", "hasRDSDS", "hasSRDFCS", "hasSRDSS", "hasXDFDS", "hasRDSS", "hasRNFM", "hasORDFS", "hasORDSS", "hasRRICS", "hasXDFM", "hasRNFS", "hasSRDSs", "hasRRIB", "hasORDFs", "hasXDSs", "hasRDSM", "hasRMLS", "hasRDSs", "hasRDSCS", "hasORDFM", "hasORDSs", "hasRdfS", "hasRRIS", "hasRMLM", "hasRDFDS", "hasXDSS", "hasXDFs", "hasRMLDS", "hasSRDSCS", "hasRDFCS", "hasXDSDS", "hasRMLs", "hasORDFDS", "hasSRDFs", "hasSRDFB", "hasRDFs", "hasORDSDS", "hasSRDFS", "hasRdfCS", "hasRDFM", "hasXDFS", "hasRNFs", "hasORDSM", "hasRdfs", "hasRNFDS", "hasXDSM"], "hasRDF": ["hasRRDI", "hasRdf", "hasRCNF", "hasORNF", " hasDDF", "hasRRNF", " hasRDR", "hasRADF", "hasREDI", "hasRTDS", " hasRRDF", "hasRDS", "hasRDR", "hasRTDF", "hasDDF", " hasDNF", "hasDdf", "hsRDF", "hasRCD", "hasORDF", " hasRDS", "hsRRDT", "hasRRDR", "hasRRDT", "hasRADI", "hasRDT", "hsRDS", "hsRRDS", " hasRRDS", "hasRRCD", " hasDCD", "hasRCDF", "hasORDR", "hasREDT", "hsRRDF", "hasRTDR", "hasRRDF", " hasRRDR", "hasRRDS", "hasDCD", "hasDNF", "hasRNF", " hasRdf", "hasORDS", "hsRDI", "hasRTNF", "hasRCCD", " hasDdf", "hasREDF", " hasRCD", "hasRADS", "hasRRdf", " hasRRNF", " hasRNF", "hasRDI", "hasREDS", "hsRRDI", "hasRCdf", "hasRADT", "hsRDT"]}}
{"id1": "20920051", "id2": "19667000", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"copyTo": [" copyOver", " copyPhoto", "transferTo", "copyFile", "copyDir", "copyFrom", "CopyFile", "copyOver", "CopyFiles", "transferFile", "transferFiles", "movePhoto", " copyFiles", "CopyTo", " copyDir", "moveDir", " copyFile", "opyDir", "moveTo", "opyTo", "opyPhoto", "CopyFrom", " copyFrom", "opyOver", "copyPhoto", "moveOver", "copyFiles", "transferFrom"], "source": ["style", "se", "config", "sin", "shell", "size", "scan", "pse", "Source", "parent", "component", "src", "service", "ace", "status", "iter", "file", "secure", "query", "origin", "sl", "template", "init", "SOURCE", "sort", "seed", "old", "sql", "from", "scope", "name", "details", "entry", "oss", "sp", "search", "start", "flat", "sf", "site", "part", "missing", "ie", "id", "ource", "local", "subject", "use", "resource", "null", "original", "unit", "get", "input", "copy", "select", "target", "visible", "raw", "sample", "note", "spec", "store", "none", "base", "s", "empty", "image"], "dest": ["path", "deg", "self", "est", "st", "orig", "dev", "it", "des", "tmp", "del", "master", "dat", "opt", "folder", "to", "end", "dir", "test", "desc", "pro", "loc", "parent", "nt", "ref", "this", "src", "dist", "tom", "null", "doc", "name", "d", "dc", "w", "good", "txt", "result", "Dest", "trans", "port", "nom", "target", "origin", "out", "rest"], "temp": ["path", "buffer", "fake", "emp", "orig", "template", "EMP", "unt", "tmp", "rem", "tar", "em", "tm", "tab", "p", "dat", "make", "local", "por", "test", "stem", "mm", "mt", "rm", "pl", "t", "pt", " temporary", "parent", "null", "alt", "cp", "w", "mp", "txt", "mk", "mod", "porary", "Temp", "Tem", " Temp", " tmp", "tem", "empty", "out", "zip"], "sel": ["nel", "ser", "kel", "selection", "ls", "Se", "cell", "lf", "sl", "se", "sels", "fol", "nav", "so", "rol", " sl", "del", "ml", "sc", "elect", "ele", "ael", "pl", "El", "nl", "el", "syn", "le", "ial", "sen", "sol", " lic", "zh", "fl", "Sel", "kl", "mil", "cl", "selected", "rl", "select", "sv", "sil", "cel", "lv"], "tempDest": [" temporaryTemp", "tempDir", "ptNeg", "porarydest", "temDe", "destTemp", "mmTemp", " tempNeg", " temporarydest", "tempLoc", "tempdest", "mmLoc", " tempTemp", "temdest", " tempdest", "tempTemp", " tempDe", "ptdest", "poraryDec", " temporaryNeg", "tempNeg", "poraryTemp", "ptDest", "destLoc", "poraryDir", "destDest", "poraryDest", "poraryDe", "poraryLoc", "ptTemp", "tempDec", "tempDe", " temporaryDest", "destDec", "temDir", "mmDest", "temDest", "mmDec", " tempDir"], "sourceCh": ["ourceCr", "srcch", "srcCH", "statusCol", "seedCol", "srcChan", "sourceComp", " sourceCor", "samplech", "seedColl", "sourcech", "startCH", "statusCr", "sourceChan", "sourceCol", "ourceColl", "srcColl", "startComp", " sourceCH", " sourceCr", " sourceCol", "seedCh", "startCol", "sourceColl", "startCh", "sourceCH", "sampleCh", "statusCh", " sourceComp", "sourceCr", "srcCor", "ourceChan", "ourceCh", "srcCh", "sampleCor", "ourceComp", " sourcech", "ourceCol", "ourceCH", "seedChan", "srcCol", "sampleComp", "statusCH", "sourceCor", "srcComp"], "destCh": ["estCl", " destCol", "targetC", "usrChan", " destCl", "tempC", "estCh", "targetChar", "destChan", "destC", "tempCol", "usrChar", "estDest", "restChan", " destChar", "destCol", "usrC", " destChan", "tempCh", "tempChan", "targetCh", " destDest", "destDest", "restC", "usrCh", "tempCl", "targetChan", "estC", "restCh", "destChar", "restCol", "destCl", " destC"]}}
{"id1": "7468819", "id2": "9687813", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"run": ["runner", "task", "block", "hello", "runs", "loop", "Run", "invoke", " Run", "execute", "test", "call", "running", "process", "poll", "unit", "thread", "go", "submit", "wait", "launch", "profile", "func", "work", "start", "begin", "exec"], "con": ["ch", "nc", "mos", "cos", "const", "Con", "cone", "connect", "ln", "cal", "open", "sin", "connection", "ct", "acon", "ain", "can", "rc", "pen", "en", "create", "re", "conv", "client", "win", "fin", "xc", "bur", "fc", "cm", "syn", "canon", "cp", "cons", "comm", "don", "pc", "un", "conn", "cont", "gc", "conf", "cl", "cn", "CON", "clean", "cc", "ran", "ctrl", "construct", "co", "url", "cf", "act", "com", "cmd", "res", "dial", "Conn", "c", "cur"], "encodedPassword": ["encodingData", "decodedpassword", "encressedPassword", "encachedUser", "decachedPassword", "decodedResponse", "enccodedPassword", "encachedPassword", "encachedpassword", "encressedUser", "decodingpassword", "encressedResponse", "decodingPassword", "encuredpassword", "encodedResponse", "decachedResponse", "encryptedPass", "decachedUser", "encryptedData", "encodedUser", "encryptedpassword", "encressedpassword", "decodedUser", "encuredUser", "decodedPassword", "encodedData", "encodingPass", "encuredResponse", "decodedData", "encodingPassword", "encuredPassword", "enccodedpassword", "decodingData", "decachedpassword", "encachedResponse", "decodedPass", "encodedPass", "encryptedPassword", "decodingPass", "enccodedPass", "encodingpassword", "encodedpassword", "enccodedData"], "encoder": ["ecoder", " encoding", "decoding", "decoser", " encoser", "encoding", "encater", "enoding", "decoded", "encoded", "Encoser", "encODE", "enoder", "ecoding", "decoder", "ecODE", "decODE", "enoded", "Encoder", "Encater", " encater", "encoser", "ecoded", "enODE", "decater", "Encoding"], "is": ["ist", "ists", "im", "ais", "ms", "isc", "es", "asin", "se", "ris", "it", "iso", "ai", "ri", "ic", "sys", "isl", "nis", "bs", "isa", "as", "its", "iss", "os", "ys", "are", "ins", "rs", "il", "isf", "ib", "si", "Is", "isin", "ir", "fs", "sit", "iris", "isi", "i", "ios", "s", "sis", "in", "was", "lis", "IS"], "rd": ["dr", "rh", "din", "nd", "rar", "ri", "erd", "nder", "bd", "rod", "rx", "rid", "cd", "rc", "hr", "ind", "red", "fr", "rg", "rand", "rs", "rw", "cr", "rt", "ld", "reader", "dd", "d", "mr", "rr", "rect", "sr", "ra", "rob", "rl", "rn", "RD", "xd", "r", "ren", "ru", "rb"], "line": ["message", "cell", "lin", "block", "phrase", "se", "ln", "lo", "header", "eline", "link", "detail", "lane", "row", " LINE", "sample", "frame", "re", "nl", "liner", "le", "code", "inline", "ine", "name", "label", "LINE", "ice", "l", "page", "sequence", "record", "base", "entry", "command", "point", "string", "print", "stroke", "log", "file", "comment", "chain", "column", "word", "Line"], "response": ["output", "collection", "buffer", "message", "application", "json", "description", "model", "template", "database", "detail", "onse", "connection", "sheet", "console", "reset", "relation", "frame", "answer", "pos", "resp", "server", "continue", "relative", "summary", "library", "request", "tree", "this", "next", "xml", "view", "service", "position", "respons", "vector", "Response", "sequence", "page", "command", "print", "table", "value", "reply", "csv", "results", "document", "data", "display", "memory", "format", "trace", "res", "array", "image", "report", "list", "network"], "lastIteraction": ["lastIterate", "lastInterations", " lastIterate", " lastRelations", " lastIterated", " lastInterate", " lastiterations", "lastIteration", "lastInterate", " lastiterate", " lastIterations", " lastInterations", " lastRelate", "lastIterations", " lastRelated", " lastiteration", " lastRelation", " lastInteration", "lastInteration", " lastInterated", "lastIterated", " lastIteration", " lastiterated", "lastInterated"], "result": ["buffer", "message", "out", "reason", "json", "ret", "answer", "current", "content", "request", "str", "page", "err", "string", "status", "value", "results", "query", "data", "success", "url", "res", "r", "report", "cache", "Result"], "e": ["ev", "eu", "es", "or", "x", "se", "n", "exc", "ent", "te", "a", "ie", "ze", "ep", "b", "me", "f", "p", "eg", "o", "h", "xe", "eeee", "en", "re", "note", "ex", "er", "t", "ee", "v", "E", "le", "oe", "g", "ine", "be", "error", "ec", "d", "ue", "l", "ae", "u", "err", "pe", "ei", "ne", "m", "i", "s", "r", "c", "ate"]}}
{"id1": "15580610", "id2": "18433984", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainClassification", " trainObjectizer", " trainClassizer", " trainClassifer", " runclassizer", " trainObjectifer", " runClassifier", " trainModification", " trainModifer", " trainObjectifier", " trainclassifer", " trainModizer", " runclassifier", " runclassifer", " trainObjectification", " trainclassifier", " runClassifer", " runClassification", " trainclassification", " runclassification", " trainModifier", " runClassizer", " trainclassizer"], "dir": ["output", "path", "disk", "dr", "db", "addr", "prefix", "config", "pkg", "tmp", "root", "grad", "wd", "folder", " directory", "direct", "local", "io", "rad", "dm", "dl", "files", "loc", "pos", "this", "done", "src", "dist", "module", "DIR", "doc", "null", "dd", "d", "ir", "lib", "directory", "md", "Dir", "base", "log", "data", "div", "url", "report"], "command": ["Command", "buffer", "message", "expression", "application", "binary", "function", "text", "history", "description", "password", "program", "template", "method", "menu", "config", "button", "volume", "shift", "force", "multiple", "link", "and", "attribute", "statement", "response", "connection", "condition", "shell", "send", "pretty", "execute", "sudo", "control", "power", "argument", "initial", "relative", "component", "content", "clear", "request", "three", "key", "script", "group", "delete", "operation", "mpeg", "mac", "position", "call", "sequence", "directory", "event", "form", "base", "string", "set", "archive", "option", "chain", "comment", "document", "query", "search", "display", "requisite", "paste", "column", "cmd", "pattern"], "length": ["collection", "strip", "load", "depth", "shape", "space", "volume", "now", "shift", "build", "last", "available", "count", "ength", "character", "duration", "size", "end", "factor", "creator", "loc", "Length", "power", "total", "deep", "transform", "ctors", "bus", "number", "dump", "position", "ENGTH", "level", "SIZE", "sequence", "upper", "form", "limit", "capacity", "value", "max", "given", "distance", "full", "pad", "append", "height", "pieces", "fleet", "needs", "diff", "prototype", "len"], "process": ["output", "proc", "message", "session", "connect", "function", "task", "node", "load", "term", "program", "method", "worker", "link", "handle", "class", "processor", "p", "console", "flow", "pid", "use", "pp", "channel", "component", "call", "Process", "run", "processing", "request", "script", "mpeg", "view", "post", "cp", "service", "thread", "position", "event", "result", "record", "complex", "check", "object", "status", "parse", "system", "search", "display", "in", "cmd", "start", "exec", "network"]}}
{"id1": "8093133", "id2": "22441244", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlWithFile", "loadXMLFormURL", "loadXmlFormFile", "loadXMLFormFile", "loadXmlFromURL", "loadXmlAsWeb", "loadXmlFromFile", "loadXmlFormWeb", "loadXMLFormUrl", "loadXmlAsUrl", "loadXmlFormUrl", "loadXMLFromFile", "loadXMLFromURL", "loadXMLFromWeb", "loadXmlFormURL", "loadXmlWithWeb", "loadXmlWithURL", "loadXMLFromUrl", "loadXMLFormWeb", "loadXmlWithUrl", "loadXmlAsURL", "loadXmlAsFile", "loadXmlFromWeb"], "url": ["path", "http", "html", "location", "abs", "sl", "n", "open", "user", "build", "bel", "link", "ur", "b", "Url", "address", "URL", "id", "ssl", "uri", "loc", "nl", "request", "name", "str", "xml", "ll", "get", "l", "char", "page", "u", "base", "input", "file", "log", "job", "domain", "web", "document", "in", "res", "host"], "timeout": ["buffer", "out", "sleep", "blocking", "window", "password", "time", "monitor", "term", "it", "resolution", "type", "latest", "exclusive", "duration", "size", "to", "io", "frequency", "period", "t", "client", "total", "server", "mode", "until", "length", "course", "version", "unit", "number", "policy", "directory", "delay", "OUT", "limit", "amount", "padding", "wait", "capacity", "max", "height", "Timeout", "seconds", "network"], "xmlType": [" xmlTyp", " xmlUnit", " xmlTypes", "mlUnit", "imageTypes", "xmlTypes", "complexType", "imageStyle", "complexTyp", "xmlBlock", "xmlUnit", " xmlBlock", " xmlStyle", "fileStyle", "complexUnit", "mlType", "fileTypes", "fileType", "imageType", "xmlStyle", "mltype", "xmlTyp", "fileBlock", "mlTyp", "xmltype", "complextype", " xmltype", "imageBlock"], "connection": ["nc", "session", "connect", "pointer", "cone", "Connection", "con", "application", "ion", "close", "builder", "description", "config", "open", "user", "database", "link", "response", "statement", "condition", "manager", "generation", "internet", "reference", "socket", "usage", "character", "to", "relation", "io", "creator", "subject", "uri", "client", "channel", "resource", "current", "creation", "communication", "still", "opening", "number", "established", "position", "connected", "directory", "conn", "command", "entry", "system", "city", "c", "computer", "network"], "buffInputStream": ["buffIOSteam", "BuffOutputField", "BuffInputField", "buffIOForm", "BuffInputStream", "buffOutputForm", "buffOutputSteam", "BuffInputChannel", "buffOutputChannel", "buffInputField", "BuffInputSteam", "buffIOStream", "buffInputSteam", "BuffOutputStream", "buffInputForm", "buffOutputField", "buffInputChannel", "BuffInputForm", "BuffOutputChannel", "buffEarSteam", "buffOutputStream", "BuffOutputForm", "BuffOutputSteam", "buffEarField", "buffEntityStream", "buffEarForm", "buffEntityForm", "buffIOField", "buffEntityChannel", "buffEarStream"]}}
{"id1": "6418781", "id2": "9236363", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"client": ["http", "window", "cell", "block", "force", "controller", "and", "connection", "to", "channel", "component", "tree", "service", "ace", "cl", "secure", "web", "query", "url", "cli", "list", "con", "close", "template", "response", "util", "row", "control", "Client", "cm", "google", "obj", "conn", "remote", "entry", "batch", "chain", "co", "sim", "cmd", "builder", "bolt", "prefix", "manager", "local", "resource", "server", "nt", "contact", "get", "check", "cache", "system", "man", "self", "patch", "type", "plugin", "console", "ce", "wrapper", "call", "key", "store", "tc", "policy", "command", "base", "c", "pattern"], "names": ["states", "nos", "strings", "some", "ls", "ms", "n", "olds", "users", "types", "orders", "prints", "aos", "roots", "mas", "lines", "files", "rs", "books", "these", "said", "ns", "ids", "members", "terms", "sts", "AMES", "ans", "chains", "keys", "named", "nam", "ons", "models", "pres", "nets", "spe", "s", "idents", "papers", "aps", "ren", "ames", "objects"], "name": ["path", "nan", "node", "core", "n", "member", "user", "a", "me", "nm", "p", "id", "common", "create", "t", "filename", "NAME", "ame", "ename", "e", "key", " named", "str", " NAME", "l", "named", "nam", "entry", "string", "cn", "brain", "Name", "value", "comment", " Name", "data", "in", "out", "word", "c"], "ftpFiles": ["ftpsFiles", "afpOps", "aftpFiles", "ftfFile", "fttpFile", "ftnFiles", "ftniles", "fttpfiles", "etpfiles", "ftpsFile", "etpsiles", "fttpiles", "afpFiles", "fttpOps", "ftfTypes", "ftpsfiles", "afpTypes", "ftnFile", "etpFile", "ftpsiles", "fttpTypes", "etpsFiles", "etpsfiles", "ftfOps", "ftfFiles", "ftpTypes", "ftnfiles", "ftnOps", "aftpTypes", "ftpOps", "etpFiles", "aftpFile", "ftpiles", "afpFile", "etpiles", "fttpFiles", "ftpfiles", "etpsFile", "ftnTypes", "aftpOps"], "ftpFile": ["aftnFile", "ftpnfile", " ftpItem", "ftpDocument", "fttpItem", "fttpfile", " ftnFiles", "fltpFile", " ftnFile", "fltpfile", "ftnStyle", " ftpfile", " ftnfile", "flpFiles", "ftPStyle", "ftpfile", "ftpStyle", "ftnfile", "fttpFile", "ftnFiles", "ftnEntity", "aftpStyle", "ffpfile", "fftpDocument", "ftpnFiles", "ftrItem", " ftnItem", "ftpItem", "fftpFiles", "fttpStyle", "fttpDocument", "aftnStyle", "flpfile", "ftrEntity", "fttpEntity", "ftnFile", "ftpnDocument", "flpEntity", "aftnFiles", "ffpFiles", "flpFile", "ftrFiles", "ffpDocument", "ftnItem", "ftnDocument", "ftpEntity", "ffpFile", "aftpFiles", "aftpFile", "ftpnFile", "fltpEntity", "fftpFile", "fltpFiles", "ftPFiles", "ftrfile", "fttpFiles", "ftPFile", "fftpfile", "ftrFile"]}}
{"id1": "4481712", "id2": "732800", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"deleteObject": ["destroyObj", " deleteItem", "destroyobject", "getObj", "destroyObject", "deleteobject", "getobject", " deleteObj", "deleteObj", " deleteobject", "getObject", "deleteItem", "getItem", "destroyItem"], "id": ["path", "message", "ident", "db", "description", "n", "Id", "it", "type", "link", "rid", "f", "p", "h", "row", "pid", "mid", "t", "kid", "tag", "ref", "ids", "delete", "key", "name", "d", "uid", "k", "md", "event", "sid", "object", "hash", "value", "vid", "i", "info", "data", "url", "oid", "ID"], "conn": ["priv", "bo", " cmd", "core", "connection", "ca", "pg", "nick", "wp", " ce", "canon", "cp", "cons", " con", "err", " cont", "port", "ctrl", "cf", "com", " cc", " c", "ch", " win", "nc", "cur", "db", "con", "close", " comm", "org", "pub", " rc", "tp", " conv", "enc", "ws", "ssl", "conv", "pos", "win", "cb", " mc", " dc", "dc", " net", "obj", "net", " db", "ann", "oss", "co", " ac", "urg", "cmd", "conf", " col", "n", " cp", "mc", " compat", "lang", "ct", " ex", "ens", "col", "en", "local", "loc", "resp", "client", "cfg", " mem", "nt", "ld", " ch", "comm", "cert", " core", "coll", "Conn", " cx", "connect", " cs", "addr", "open", "pkg", "sys", "gate", "socket", "rel", "cat", "ce", "auth", "pas", "pt", " pc", "ns", "ll", "nw", " connection", "here", "ctx", "cn", "cc", "mn", "jp", "act", "host", "c", "gen"], "stmt": ["Stmm", "STm", "astmm", "stpt", "ststat", "formmt", "strmt", "stMT", "utm", "ostmt", "formstat", "Stm", "stm", "utmt", "StMT", "stmm", "Stst", "strMT", "STmm", "ostpt", "strmn", "formm", "Ststat", "statpt", "astmt", "Stmp", "statmb", "Stmb", "statm", "Stmt", "strmb", "astpt", "utmp", "STmp", "formMT", "ostmm", "Stmn", "stmp", "Stpt", "ostm", "STst", "stmn", "utst", "STMT", " stm", "stmb", " ststat", " stmb", " stpt", " stMT", "statmt", "stst", " stmm", "strm", "astm", " stmn", "STmt"], "dbConn": ["DBObj", "dbRec", "dbObj", "DbConnect", "dbConnect", "dbColl", "DbRec", " dbCon", "dbCon", "DbCt", "DBRec", " dbColl", "DbObj", "DBColl", "dsCon", "DbColl", "DbCon", " dbRec", " dbConnect", "dsCt", "dsConn", "dbCt", "DbConn", " dbObj", "dsConnect", " dbCt", "DBConn"], "selfConnection": ["SelfThread", " selfInfo", "ownOnly", "reConnection", "SelfCategory", "selfCategory", "SelfFree", "SelfInfo", "selfconnection", "ownLink", "Selfconnection", "selfThread", "SelfConnection", "SelfConnect", "selfConnect", "selfFree", "alsoConnect", " selfFree", "alsoConnection", "ownThread", "selfLink", "reConnect", " selfCategory", "selfOnly", "ownConnect", "selfInfo", "SelfOnly", " selfLink", " selfconnection", " selfConnect", " selfOnly", "ownFree", " selfThread", "reLink", "alsoLink", "SelfLink", "ownConnection", "alsoCategory", "reconnection"]}}
{"id1": "13122204", "id2": "6171406", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipModel", "unlatemodel", "Unarchivemodel", "unlateModule", "unarchiveModule", "uncodeModule", "unzipModule", "UnarchiveModule", "unlateImage", "unzipmodel", "uncodemodel", "unarchiveModel", "UnarchiveImage", "UnzipImage", "unzipImage", "unarchiveImage", "uncodeImage", "unarchivemodel", "uncodeModel", "Unzipmodel", "unlateModel", "UnzipModule", "UnarchiveModel"], "filename": ["fn", "path", "nil", "output", "location", "jpg", "ln", "n", "fil", "title", "fle", "nm", "sql", "mson", "FN", "Filename", "download", "fp", "stem", "subject", "nl", "ename", "til", "journal", "river", "name", "original", "println", "username", "txt", "directory", "kl", "FILE", "source", "ivo", "file", "wl", "origin", "dra", "FIL", "SourceFile"], "tempdir": ["temfolder", "tempdirectory", "tmpDIR", "tempDir", "testDir", "temDIR", " tempdirectory", "testpath", " tempfile", "tmpfolder", "testfolder", "temdir", "TempDir", "tmpdir", "Tempfile", "tempath", "temdirectory", "temppath", " tempDIR", "tmpDir", "tempDIR", "Tempdir", "tmpdirectory", "tempfolder", "testdir", "Tempdirectory", "temDir", "tmpfile", "tempfile", "tmppath", " tempDir"], "dest": ["output", "buffer", "st", "est", "dev", "peer", "des", "tmp", "del", "send", "master", "dat", "inv", "generated", "coord", "desc", "test", "default", "pos", "loc", "pipe", "deep", "bin", "foreign", "parent", "nt", "slave", "write", "src", "dist", "store", "writer", "ctr", "null", "dc", "stream", "ptr", "tr", "sum", "obj", "result", "Dest", "cont", "source", "trans", "nom", "port", "table", "decl", "document", "target", "comb", "tail", "origin", "display", "out", "usr", "temp", "rest"], "fis": ["ifos", "zi", "ifatis", "fjs", "ljs", "ifi", "fi", "fli", "ifis", "flos", "flis", "fljs", "zatis", "zos", "flatis", "zjs", "los", "fatis", "li", "lis"], "BUFFER": ["BABER", "BULT", "BLBER", "LOCKFR", "FFERMT", "LOCKFFER", " BUULT", "BAOUNT", " BUMT", "BUOUNT", "BFFER", "CUFFER", "BUBuffer", "BUFR", "BLBuffer", "BOUNT", "BAULT", "BLFFER", "BAFFER", "BUULT", "LOCKBER", " BUBuffer", "MAXBuffer", "CUBER", "MAXFFER", "CUBuffer", "FFERBER", "BUMT", "LOCKBuffer", "CUFR", "FFERBuffer", "BufferFFER", "BufferMT", "BUBER", "BBER", "MAXBER", " BUBER", "BLOUNT", "FFERFFER", " BUOUNT", " BUFR", "BufferBER", "BufferBuffer", "MAXOUNT"], "zis": [" ziss", "zeris", " zi", "zeiss", " zris", "zoneiss", "Zi", "zi", "zris", " zIS", "ozi", "zits", "ziIS", "zeIS", "fiss", "fi", " zits", "xis", "zies", "zIS", "Zos", "zes", "xiss", "zees", "ozis", "Zis", "xos", " zip", "Ziss", "zos", "zios", "oziss", "zeis", "zoneits", " zes", "zoneis", " zos", "zeits", "ziis", "fip", "xi", "zeos", "ziss", "ozip", "zoneris", "zip"], "entry": ["part", "cell", "or", "existent", "se", "member", "ent", "jo", "header", "ie", "ze", "link", "piece", "item", "connection", "je", "ry", "row", "ce", "jar", "card", "element", "nt", "e", "key", "name", "index", "inter", "char", "result", "record", "pe", "source", "def", "table", "file", "log", "match", "zo", "comment", "system", "chain", "escape", "Entry", "enter", "word", "image", "way", "zip"], "count": ["buffer", "part", "counter", "core", "cell", "cond", "add", "n", "nb", "force", "ct", "f", "common", "read", "size", "ce", "num", "current", "total", "length", "acc", "nt", "call", "OUNT", "Count", "cloud", "code", "all", "ctr", "index", "number", "sum", "ount", "page", "cont", "base", "batch", "check", "amount", "child", "cc", "match", "max", "z", "comment", "found", "start", "c", "cache", "len"], "data": ["output", "buffer", "message", "text", "part", "step", "window", "n", "valid", " DATA", "ata", "raw", "p", "dat", "rel", "size", "area", "sample", "accept", "DATA", "dl", "content", "all", "done", "str", "next", "d", "bytes", "dec", "result", "batch", "table", "value", "zero", "results", "format", "ATA", "out", "mat", "image", "cache"], "fos": [" fOS", " foses", "Foss", "lios", "fOS", "voss", " foes", "FOS", "Fios", "vos", "Foses", "Fos", " fios", "foes", "lOS", "voses", " foss", "los", "loss", "fios", "foses", "foss", "Foes", "voes"]}}
{"id1": "3024987", "id2": "13657103", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStreamWithEncending"], "in": ["IN", "din", "gin", " IN", "con", "init", "n", "it", "rin", "ini", "is", "mc", "sin", "p", "as", "read", "local", "inc", "from", "mm", "mi", "ind", "Input", "ins", "up", "ac", "bin", "inner", "isin", "r", "l", "In", "cont", "input", "source", "copy", "iter", "m", "i", "info", "data", "inn", "act", "inside", "inf", "cin"], "reader": ["rise", "buffer", "dr", "per", "rar", "phrase", "rx", "loader", "parser", "read", "row", "iterator", "io", "red", "er", "oe", "inner", "req", "writer", "reading", "handler", "rot", "mr", "rr", "ocker", "Larry", "Reader", "ner", "input", "iter", "rl", "file", "driver", "ro", "query", "data", "r"], "baout": ["caout", "baOut", "baos", "beanout", "haouts", "beanouts", "cain", "beanin", "haout", "oaos", "BAout", "bares", "haOut", "yaout", "BAin", "caOut", "boOut", " baot", "yain", "baouts", "beanOut", "bain", "oaout", "oain", "hain", "boos", "boout", "BAot", "caos", "BAres", "oaOut", "yares", "caouts", " bain", " bares", "baot", "boin", "yaot"], "out": ["output", "bo", "cos", "update", "con", " Out", "n", "auto", "Out", "sys", " OUT", "b", " output", "o", "to", "os", "io", "OU", "conv", "outs", "t", "client", "ex", "ou", "all", "stable", "null", " bout", "ao", " outs", "net", "OUT", "batch", "gt", "ne", "copy", "cn", "oss", " os", "cmd", "outer", "res"], "bytes": ["faces", "binary", "units", "strings", "es", "words", "pdf", "gets", "des", "users", "versions", "gs", "bps", "bs", "latest", "comments", "raw", "frames", "its", "pages", "les", "cells", "outs", "bits", "files", "classes", "lines", "unks", "ones", "services", "letters", "terms", "ips", "ites", "values", "parts", "ings", "reports", "vals", "videos", "resources", "tes", "results", "Bytes", "names", "pieces", "data", "blocks", "groups", "issues", "seconds", "objects", "ies", "reads"]}}
{"id1": "20623709", "id2": "20091126", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"split": ["Split", "disk", "part", "sync", "open", "align", "count", "transfer", "read", "scan", "use", "slice", "map", "lock", "write", "process", "unit", "share", "upload", "scale", "batch", "copy", "parse", "join", "format", "append", "seek"], "targetDirectory": ["TargetDirect", "testDir", "targetFolder", " targetFile", "baseDir", "targetFile", "TargetFolder", " targetFolder", "targetLocation", "baseMemory", "localdirectory", "targetdirectory", "baseFolder", "localDirectory", "localFile", "testDirectory", "baseDirectory", "targetDirect", " targetdirectory", "testDirect", " targetDirect", "TargetMemory", "Targetdirectory", " targetMemory", " targetLocation", "TargetDir", " targetDir", "testLocation", "baseFile", "TargetDirectory", "targetDir", "localDir", "targetMemory", "basedirectory", "TargetLocation", "baseDirect"], "prefix": ["path", "PRE", "password", "template", "type", "pkg", "title", "Pref", "root", "p", "size", "uri", "FIX", "filename", "fixed", "tag", "pre", "this", "key", "fixes", "name", "fix", "index", "version", "division", "username", "directory", "localhost", "base", "command", "padding", "status", "ix", "zero", "pres", "pi", "format", " suffix", "alias", "pattern"], "maxUnitBases": ["maxUnitChades", "maxUnitLounds", "maxUnityLounds", "maxUnitChias", "maxUnitChounds", "maxUnityBicas", "maxUnitLages", "maxUnitReplounds", "maxUnityBades", "maxUnityBias", "maxUnitAliias", "maxUnitChases", "maxUnityLages", "maxUnitLases", "maxUnitReplages", "maxUnitChages", "maxUnitBias", "maxUnitbounds", "maxUnityAliades", "maxUnityBages", "maxUnitChicas", "maxUnitBicas", "maxUnityBases", "maxUnitAliounds", "maxUnitBages", "maxUnitbias", "maxUnityBounds", "maxUnitbades", "maxUnityLicas", "maxUnityAliounds", "maxUnityAliias", "maxUnityAliases", "maxUnitAliades", "maxUnitLicas", "maxUnitAliases", "maxUnitBounds", "maxUnitReplicas", "maxUnitbases", "maxUnityLases", "maxUnitReplases", "maxUnitBades"], "maxUnitEntries": ["maxUnityentrs", "maxUnitEntriers", "maxUnitEntryires", "maxUnitentrys", "maxUnityEntrys", "maxUnitEntryrys", "maxUnitErires", "maxUnityentires", "maxUnitentrs", "maxUnitEntryries", "maxUnityEntries", "maxUnitIntegries", "maxUnitErrys", "maxUnitIntegires", "maxunitEntires", "maxUnitErrs", "maxunitEntrys", "maxUnitEntryriers", "maxUnitIntegrys", "maxUnitEntires", "maxUnitErries", "maxunitEntrs", "maxUnitIntegriers", "maxUnitEntrys", "maxUnitentires", "maxUnityentrys", "maxUnitentries", "maxUnitEntrs", "maxUnityentries", "maxUnityEntires", "maxUnityEntrs", "maxunitEntries"], "fis": [" fi", " fiss", "viss", "fii", "Fii", "fiss", "Fis", "fi", "Fiss", "ifis", "Fic", "vic", "ific", "ifii", " fic", "vis", "Fi", "fic", "Fci", "ifci", " fii", "vi"], "fci": ["Fico", "cfis", "cfci", "mco", "cfini", "mci", "fii", "fico", "cfai", "Fis", " fcu", "fai", "cfic", "mii", "Fco", "Fai", "cfco", "Fic", "mcu", "tci", "tcu", "Fini", "tii", "tco", "fcu", " fic", "fic", "Fci", " fini", "fini", " fii", "cfico", " fico", " fai"], "fos": ["faos", " fOS", "Foss", "ybos", "fOS", "fbos", "yios", "flaos", "Faos", "wbos", "yos", "FOS", "flos", "yaos", "Fos", " fios", "flOS", "floss", " fbos", " foss", "fios", "wios", " faos", "foss", "waos", "wos"], "fco": ["Fdo", "Foco", "Fso", "cco", "cdo", "Fcon", "fcon", "cso", " fcon", " foco", "pco", "pcos", "Fco", " fdo", "fso", "fcos", " fso", "Fcos", "tdo", "tcos", "foco", " fcos", "tco", "pci", "fdo", "ccon", "pso", "toco", "Fci"], "buffer": ["message", "Buffer", "binary", "pause", "function", "black", "window", "timeout", "block", "phrase", "buf", "template", "button", "callback", "database", "filter", "flush", "address", "holder", "complete", "reset", "row", "sample", "read", "queue", "note", "channel", "buff", "length", "library", "index", "position", "bridge", "char", "sequence", "result", "event", "record", "print", "command", "batch", "limit", "source", "entry", "padding", "iter", "table", "match", "comment", "stack", "document", "data", "order", "memory", "append", "temp", "cache"], "currentBasesCount": ["currentBasesCode", "currentbaseCode", "currentBadesCount", "currentBasedLength", "currentbaseLength", "currentBaseLength", "currentbasesCount", "currentBaseCode", "currentbasesCode", "currentbaseCount", "currentBaseCount", "currentBadesLength", "currentBasesLength", "currentBadesCode", "currentBasedCount", "currentbasesLength", "currentBasedCode"], "currentEntriesCount": ["currentEntrysCode", "currentEntrysFlag", "currentEntriesFlag", "currentEntiesCount", "currentEntrsFlag", "currentEntriesCode", "currentEntrsCode", "currentEntiesFlag", "currentEntiesCode", "currentEntrsCount", "currentEntrysCount"], "targetCount": ["argetInfo", "argetAmount", "argetNum", "TargetAmount", "targetInfo", "TargetInfo", "TargetCount", " targetAmount", "TargetNum", "argetCount", "targetNum", "targetAmount", " targetNum", " targetInfo"], "fastaChannel": [" fastaProvider", "fastpaProvider", "fastaButton", "fastaiQueue", "fastoProvider", "fastaiChannel", "fastityChannel", " fastaConnection", " fastaStream", "fastaiChan", "fastoChannel", "fastaQueue", "fastpaChannel", " fastoChannel", "fastpaButton", "fastityQueue", "fastaChan", "fastoStream", " fastaButton", "fastoButton", " fastaQueue", " fastoStream", "fastityChan", "fastoQueue", "fastaiStream", "fastoConnection", " fastoChan", "fastityStream", "fastpaConnection", " fastoQueue", " fastaChan", "fastaConnection", "fastoChan", "fastaStream", "fastaProvider"], "totalSeqCount": ["totalSeQCounter", "totalSeqsCode", "totalSegCount", "totalSegCounter", "totalSegSize", "totalSeqCounter", "totalSeQCode", "totalSeQSize", "totalSeqsCount", "totalSeqsSize", "totalSeqSize", "totalSeqsCounter", "totalSegCode", "totalSeQCount", "totalSeqCode"], "totalResiduesCount": ["totalResIdueCode", "totalResIdueCount", "totalResidusFlag", "totalResIduesFlag", "totalResidueCount", "totalResiduationsFlag", "totalResidueCode", "totalResidusCount", "totalResIduesCount", "totalResiduationsCode", "totalResidusCode", "totalResiduationsCount", "totalResIdueFlag", "totalResiduesCode", "totalResidueFlag", "totalResiduesFlag", "totalResIduesCode"], "prevTime": ["prevT", " prevT", "parTime", " prevThread", " previousThread", "parT", "parThread", " previousT", " previousTime", "prevThread"], "fastaFileSize": ["fastoFileOwner", "fastaTableSIZE", "fastoTableSIZE", "fastaChainOwner", "fastaFilesSize", "fastoTableOwner", "fastaReaderHeight", "fastaTableLength", "fastAFileName", "fastATableHeight", "fastaFileName", "fastaFilesHeight", "fastafileSIZE", "fastafileLength", "fastaFilesName", "fastATableSize", "fastaFileSIZE", "fastoFileSize", "fastoTableSize", "fastaChainLength", "fastaFileHeight", "fastaReaderName", "fastaTableSize", "fastaChainSize", "fastaReaderLength", "fastaChainSIZE", "fastATableName", "fastaFileLength", "fastoTableLength", "fastaTableName", "fastafileSize", "fastoFileLength", "fastaFilesLength", "fastaReaderSize", "fastaTableHeight", "fastATableLength", "fastaTableOwner", "fastAFileSize", "fastAFileHeight", "fastAFileLength", "fastoFileSIZE", "fastaFileOwner", "fastafileOwner"], "fastaFileReadOffset": ["fastaFileWriteOrder", "fastaPageLoadOrder", "fastaFileLoadOrder", "fastaFilesReadOrder", "fastaFileViewOrder", "fastaFileInputOrder", "fastaFileInputLength", "fastaPageReadPos", "fastaChainCurrentLocation", "fastaFileWriteAmount", "fastaFileReadPos", "fastaFilesLoadOffset", "fastaFilesLoadOrder", "fastaPageReadOrder", "fastaFileLoadPos", "fastaFileInputLocation", "fastaChainReadOffset", "fastaFileReaderoffset", "fastaFileLoadOffset", "fastaFileWriteLength", "fastaFileCurrentoffset", "fastaFileReadPosition", "fastaFileReaderPosition", "fastaFileViewPos", "fastaChainReadPosition", "fastaPageLoadAmount", "fastaFilesReadLength", "fastaPageReadOffset", "fastaFilesReadAmount", "fastaFilereadPos", "fastaFilesLoadAmount", "fastaFileReaderLocation", "fastaFileCurrentLocation", "fastaChainCurrentoffset", "fastaChainCurrentPosition", "fastaFileViewAmount", "fastaFileLoadLength", "fastaPageReadAmount", "fastaFileReadAmount", "fastaFilereadOrder", "fastaFileReadoffset", "fastaPageLoadPos", "fastaFilesLoadLength", "fastaFileLoadAmount", "fastaFileReadOrder", "fastaFileWriteOffset", "fastaFilereadOffset", "fastaFileInputoffset", "fastaFileReaderOffset", "fastaChainCurrentOffset", "fastaFileViewOffset", "fastaChainReadLocation", "fastaFileCurrentPosition", "fastaFilereadAmount", "fastaChainReadoffset", "fastaFileInputPosition", "fastaPageLoadOffset", "fastaFileReadLength", "fastaFilesReadOffset", "fastaFileInputAmount", "fastaFileCurrentOffset", "fastaFileReadLocation", "fastaFileInputOffset"], "partitionStartOffset": ["partitionStartPoint", "partitionEndPoint", "partitonStartingPosition", "partitionDataOffset", "partitionEndOff", "partitionStartOff", "partitionDataPosition", "partitionDataPoint", "partitionStartingOffset", "partitonStartingOff", "partitonStartPoint", "partitionEndPosition", "partitionDataOff", "partitonStartOffset", "partitionStartPosition", "partitionStartingPosition", "partitonStartPosition", "partitonStartingPoint", "partitonStartOff", "partitionStartingPoint", "partitionStartingOff", "partitonStartingOffset"], "bufferSize": ["bufferCode", "tableSIZE", "buffSize", "buffSIZE", "bufferSIZE", "BufferLength", "BufferSIZE", "tableName", "BufferName", "bufSize", "sequenceSIZE", " bufferSIZE", "tableLength", " bufferLength", " bufferCode", "sequenceLength", "bufCode", "tableSize", "buffName", "BufferSize", "sequenceCode", "bufferLength", "bufferName", "sequenceSize", "buffLength", "bufSIZE", "bufLength"], "fastaBuffer": ["FastaBuffer", "wildanBuff", "fastasRequest", "fastsaQueue", "fastmaChannel", "FastaRequest", "fastmaBuffer", "fastasCounter", " fastaCounter", "FastmaBuff", "fastoBuff", "fastsaChannel", "fastuBuff", "fastalBuff", "wildaBuff", "fastoQueue", "fastanBuff", "wildaBuffer", "FastmaBuffer", "fastuMemory", "fastasQueue", " fastaBuilder", "fastcaBuffer", "fastoRequest", "fastaCounter", "wildanRequest", "fastaQueue", "fastaStore", " fastaBuff", "wildanBuffer", "fasteBuff", "fastmaBuilder", "wildaCache", " fastaCache", "wildanCache", "fastaBuff", " fastoCounter", "fastmaCache", "fastaBuilder", "fastanRequest", "fastcaRequest", "fastaDB", "fastaCache", "FastaBuff", "fastmaRequest", "fasteDB", "fastcaBuff", "fastmaBuff", "wildaRequest", " fastoBuff", "fastsaBuff", "FastmaRequest", "fastaRequest", "fastasBuilder", "fastasStore", "fasteMemory", " fastaMemory", "fastalCounter", "fastsaBuffer", " fastoQueue", "fastasBuff", "fastanCache", "fastmaStore", "fastcaCache", "FastmaStore", "FastaStore", " fastoBuffer", "fastasBuffer", "fastalBuffer", "fastalQueue", "fastoCounter", "fastuDB", "fastoStore", "fastoBuffer", " fastaDB", "fastmaQueue", "fastanBuffer", "fastasCache", "fastaMemory", " fastaQueue", "fastuBuffer", "fasteBuffer"], "fastaReadState": ["fastaReadSTATE", "fastoReaderType", "fastaCurrentState", "fastaReaderType", "fastaLoadState", "fastaLoadStatus", "fastoReadStatus", "fastaReaderSTATE", "fastoReaderSTATE", "fastaReaderState", "fastoReaderState", "fastaReaderStatus", "fastoReadType", "fastaCurrentType", "fastoReadSTATE", "fastoReaderStatus", "fastaLoadSTATE", "fastoReadState", "fastaReadType", "fastaCurrentStatus", "fastaCurrentSTATE", "fastaReadStatus", "fastaLoadType"], "nBytes": [" nParts", "nsbytes", "nsBytes", "nrBytes", "nobytes", "nKeys", " nbytes", "nParts", " nBlocks", "numBytes", "nsParts", "nbytes", " nWords", "nrbytes", "NItems", "noBlocks", "nrKeys", "NWords", "numBlocks", "NParts", "numbytes", " nItems", "NKeys", "noBytes", "nsWords", "nItems", " nKeys", "numNs", " nNs", "nBlocks", "noNs", "NBytes", "Nbytes", "nrItems", "nNs", "nWords"]}}
{"id1": "17193692", "id2": "300397", "code1": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"execUpdate": [" ExecSet", " executeUpdate", " ExecUpdate", "ExecUpdate", "executeSelect", "ExecSet", "executeAction", " executeSet", " ExecSelect", " ExecAction", "ExecAction", "ExecSelect", "executeSet", " executeAction", " executeSelect", "executeUpdate"], "sqlStmts": ["sqlStrmnt", "sqlStrmms", "sqlSylts", "sqlStrrths", "sqlSylms", "sqlStmls", "sqlStrmths", "sqlStmths", "sqlStlsts", "sqlStrrments", "sqlStarmts", "sqlSttmnt", "sqlStmtters", "sqlStrmns", "sqlStrmps", "sqlStamuts", "sqlStrrls", "sqlSylsts", "sqlStrmuts", "sqlStmns", "sqlStamters", "sqlStlps", "sqlStamts", "sqlStrrms", "sqlSymsts", "sqlStrruts", "sqlStrths", "sqlStmrks", "sqlStmtsts", "sqlStmms", "sqlStarmms", "sqlStrps", "sqlStrks", "sqlStrrmters", "sqlStmtms", "sqlStrrns", "sqlStrts", "sqlStlms", "sqlStmrts", "sqlStsps", "sqlSymms", "sqlStlments", "sqlSttmps", "sqlStmtps", "sqlStrrnt", "sqlStrmsts", "sqlStmters", "sqlStmks", "sqlStmtns", "sqlStmuts", "sqlStsnt", "sqlStrters", "sqlStarmters", "sqlStmnt", "sqlStlters", "sqlStrmks", "sqlStarmments", "sqlStrrks", "sqlStmsts", "sqlStrmments", "sqlSttmts", "sqlStmtts", "sqlStamths", "sqlStrmls", "sqlStrments", "sqlStrrters", "sqlStrms", "sqlSymts", "sqlStmrters", "sqlStlts", "sqlSttmls", "sqlStrns", "sqlStmtks", "sqlStmps", "sqlStrrmnt", "sqlStrrts", "sqlStruts", "sqlStmments", "sqlStrrmts", "sqlStsls", "sqlSylps", "sqlSymps", "sqlStrmters", "sqlStrrmps", "sqlSttmters", "sqlStrmts", "sqlStrls", "sqlStmrns", "sqlStrnt", "sqlStsts", "sqlStrrps"], "i": ["multi", "ims", "im", "zi", "x", "j", "n", "phi", "it", "my", "ini", "ai", "is", "ic", "a", "ui", "ie", "me", "ri", "iu", "id", "y", "o", "ci", "mi", "ind", "uri", "slice", "ii", "qi", "ma", "v", "asi", "gi", "hi", "key", "g", "bi", "ti", "ji", "index", "si", "I", "u", "ei", "yi", "point", "m", "xi", "us", "cli", "ori", "z", "di", "sim", "pi", "ij", "info", "in", "ip", "li", "c", "\u0438", "ix"], "stmt": ["ostMT", "st", "stMT", "ostmt", "smp", "Stt", "Stm", "stm", "styMT", "StMT", "Stg", "stt", "stymsg", "Stmsg", "Stmp", "sm", "stym", "Stmt", " stmp", " stmsg", "stymt", "stmp", "ostm", "stg", "ostg", " stm", "stmsg", " stMT", " stg", "smt", " stt"]}}
{"id1": "2168610", "id2": "15362793", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"update": ["equal", "http", "offset", "change", "count", "size", "num", "component", "exit", "where", "fill", "set", "status", "date", "insert", "report", "init", "now", "msg", "updated", "row", "create", " UPDATE", "op", "continue", "run", "delete", "write", "print", "batch", "remove", "handle", "commit", "diff", "edit", "add", "touch", "draw", "put", "latest", "id", "use", "dates", "resource", "current", "up", "index", "get", "u", "result", "check", "action", "select", "find", "UPDATE", "Update", "load", "save", "user", "database", " Update", "ul", "grade", "send", "state", "login", "call", "value", "info", "out"], "o": ["onet", "bo", "n", "iso", "oin", "lo", "O", "a", "fo", "q", "ob", "p", "h", "to", "os", "ilo", "t", "oo", "oco", "e", "oa", "ao", "aco", "l", "obj", "k", "cont", "om", "object", "m", "po", "i", "mo", "co", "oid", "ooo", "out", "c"], "contact": ["panel", "message", "conduct", "mail", "cell", "ACT", "add", "close", "addr", "config", "compliance", "hello", "force", "controller", "detail", "title", "connection", "ct", "address", "claim", "transfer", "charge", "character", "att", "control", "pp", "client", "CONT", "international", "content", "component", "translation", "fax", "group", "module", "communication", "responsible", "cp", "comm", "aco", "service", "char", "l", "cont", "form", "print", "details", "entry", "check", "acts", "company", "consider", "action", "port", "trans", "lead", "match", "impact", "cc", "info", "country", "work", "format", "display", "act", "Contact", "report", "phone"], "pst": ["jpSt", " pct", "vpct", "bpost", "jpset", "presth", "pingth", "dct", "phpnt", "prest", " pnt", "bpstan", "drest", "perest", "pST", "lse", "psth", "pse", "phpstal", "pmt", "pstan", "pset", "vpset", "epnt", "ipst", "jpsy", "Pst", "tpct", " psth", "phpst", " pmt", "apst", "pingct", "Pse", "bpst", "ipSt", "pnt", "phpct", "pstal", "preth", "ppt", "presta", "pSt", "pster", "ipsth", "preSt", "ipmt", "prST", "dst", "jpmt", "dpct", "Prest", " post", "jpster", "jpst", "tpst", "ipST", "pect", "jply", "apost", "dpt", "bpSt", "dpster", "prse", " pster", "pingstra", " pstan", "dpst", " pset", "pingSt", "PST", "psta", " pST", "Pct", "tpstal", "jpST", "pest", "jpct", "apSt", "epct", " ply", "dpsy", "ipct", " pstra", "tpstra", "pct", "vpst", "epstal", "pingstal", "epst", " pstal", "pept", "apstan", "pingsta", "psy", "ipsta", "lST", "prst", "prct", "lct", "prect", "pstra", "pingst", "pth", "lst", "Ppt", "post", " pSt", "ipth", " psy", "vply", "ply"]}}
{"id1": "19050432", "id2": "11005804", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["opennamedRes", "opennamingResource", "opennamingClass", "openNumberedStream", "openNestedStream", "openNestedRes", "openNamingClass", "openNamingRes", "openNamingStream", "openNumberedRes", "opennamedClass", "openNumberedResource", "openNamedRes", "openNamedClass", "opennamingStream", "openNestedClass", "openNamedStream", "opennamingRes", "opennamedResource", "openNamingResource", "openNestedResource", "opennamedStream", "openNumberedClass"], "name": ["path", "message", "part", "missing", "description", "password", "prefix", "n", "template", "type", "link", "title", "address", "id", "nm", "p", "local", "size", "use", "uri", "resource", "initial", "filename", "NAME", "ame", "ref", "key", "null", "str", "named", "string", "Name", "file", "value", "names", "search", "full", "url", "alias", "word"], "in": ["IN", "on", "din", "gin", "con", "asin", "n", "oin", "ini", "rin", "is", "vin", "mc", "f", "body", "ain", "as", "pin", "o", "to", "en", "from", "tin", "mi", "pid", "ind", "ins", "login", "up", "bin", "serv", "inner", "impl", "reader", "stream", "isin", "In", "conn", "input", "m", "i", " din", "inn", "out", "conf", "inf", " out", "cin"], "propsURL": ["ProrsURL", "proprNR", "propsURI", "projsUrl", "proPSCH", "PropsURI", "proPSURL", "propertiesURL", "probsurl", "Propsurl", "proppsUrl", "PropsUrl", "progsURL", "prorsURL", "proprsURL", "proprurl", "prorsEL", "progsUR", "PropsNR", "progsurl", "probsUrl", "PropsEL", "ProPSUR", "proppsCL", "propsEL", "proPSCL", "protsUrl", "proPSNR", "PropsUR", "ProPSURI", "propertiesURI", "proppsUR", "projsURL", "proprsCL", "progsCL", "proPSUrl", "proprURL", "probsURI", "PropsCL", "ProPSUrl", "propsSSL", "projsEL", "proppsURL", "progsEL", "PropsSSL", "propsUrl", "proppsCH", "proPSurl", "proPSUR", "prorsUrl", "ProPSCL", "projsUR", "propertiesUR", "propertiesUrl", "proprsUrl", "proPSSSL", "ProPSCH", "ProrsEL", "propsurl", "proppsSSL", "PropsURL", "progsUrl", "protsurl", "probsURL", "propertiesCH", "prorsCL", "progsURI", "propsCL", "propsCH", "prorsUR", "propertiesCL", "protsURL", "ProPSSSL", "propertiesurl", "propsUR", "ProPSurl", "ProrsUR", "protsNR", "propsNR", "ProrsUrl", "protsURI", "proprsUR", "propertiesSSL", "ProPSNR", "ProPSURL", "proPSURI", "PropsCH", "proprUrl"], "urlConn": ["UrlCon", "httpConn", "webconn", "handleCon", "urlconn", "urlInit", "slMem", "urlConnect", "lsInit", "fileMem", "URLConn", "urlMem", "slObj", "lsconn", " urlInit", "lsConnect", " urlconn", "fileConn", "urlConnection", "handleConnect", "slConn", "slCons", "UrlConnect", "handleConnection", "fileObj", "handleConn", "httpMem", "URLConnect", "urlCons", "webConnect", "webConn", "lsConn", "UrlConnection", "URLConnection", " urlConnect", "urlCon", "httpCons", "webInit", "UrlConn", "httpObj", "urlObj", "fileCons", "URLCon"], "httpURL": ["httpsurl", "healthurl", "httpUR", "ttpURL", "HttpURL", "httpDB", " httpDB", "healthUR", "httpsURL", " httpSSL", "httpsUR", "hoverUrl", "Httpurl", "HTTPUrl", "hoverurl", "httpURI", "ttpurl", "HttpUrl", "healthURL", "HttpSSL", "httpSSL", "ttpURI", " httpUrl", "hoverURL", " httpURI", "httpUrl", "HTTPDB", "ttpDB", " httpurl", "healthUrl", "hoverUR", "HTTPURI", "httpsUrl", "ttpSSL", "ttpUrl", "httpurl", "HTTPURL"], "hdrVal": ["hheaderVal", "hdrEl", "hDRVal", "hlrValue", "httpVal", "hDRLen", "hlrLen", " hheaderLen", "hDRVAL", "ohdrVal", "hdrValue", "hheaderEl", " hdrLen", "hheaderVAL", "hlrval", " hheaderval", "hDRval", "hdrVAL", "hheaderval", "httpValue", "HheaderVal", "hDREl", "hDRValue", "httpVAL", "ohDREl", "HdrVal", " hheaderValue", " hheaderVal", "hdrLen", "hlrVal", "hstrVal", " hdrValue", "ohdrEl", "httpEl", "hdrval", "hheaderValue", "hstrEl", "hheaderLen", "HdrEl", "HheaderVAL", "HdrValue", "ohdrValue", "hstrValue", "ohDRVal", " hdrval", "ohDRValue", "HheaderEl", "HheaderValue", "HdrVAL"], "code": ["ch", "message", "text", "reason", "description", "close", "cue", "se", "msg", "type", "header", "response", "color", "currency", "ct", "ck", "count", "body", "id", "state", "no", "rc", "size", "ce", "desc", "mode", "length", "component", "content", "cycle", "key", "cod", "error", "xxx", "magic", "xx", "ode", "index", "number", "codes", "coe", "one", "ack", "ace", "level", "go", "event", "result", "cont", "sec", "check", "string", "status", "zero", "cc", "value", "comment", "coded", "country", "age", "url", "city", "Code", "c", "zip"]}}
{"id1": "22603577", "id2": "23291583", "code1": "    public static String getFileContentFromPlugin(String path) {\n        URL url = getURLFromPlugin(path);\n        StringBuffer sb = new StringBuffer();\n        try {\n            Scanner scanner = new Scanner(url.openStream());\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sb.append(line + \"\\n\");\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return sb.toString();\n    }\n", "code2": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getFileContentFromPlugin": ["getFileContentFormUrl", "getFileContentsForProvider", "getFileContentForPlugin", "getFileContentForUrl", "getFileContentsForUrl", "getFileContentsFromPlugin", "getFileContentForProvider", "getFileContentsFromUrl", "getFileContentsFromProvider", "getFileContentfromUrl", "getFileContentFormPlug", "getFileContentfromPlug", "getFileContentFromUrl", "getFileContentFromProvider", "getFileContentfromPlugin", "getFileContentsForPlugin", "getFileContentForPlug", "getFileContentFormPlugin", "getFileContentFromPlug", "getFileContentfromProvider", "getFileContentFormProvider", "getFileContentsFromPlug", "getFileContentsForPlug"], "path": ["text", "location", "Path", "prefix", "PATH", "template", "ath", "plugin", "root", "p", "local", "dir", "kind", "uri", "th", "with", "spec", "filename", "pod", "transform", "key", "module", "name", "mount", "directory", "project", "string", "input", "file", "log", "join", "full", "alias", "image", "pattern"], "url": ["http", "db", "mail", "html", "sl", "org", "user", "hub", "build", "bel", "link", "ur", "Url", "address", "URL", "ssl", "uri", "dl", "loc", "nl", "client", "el", "resource", "browser", "gl", "ref", "impl", "name", "mount", "ll", "l", "char", "base", "lr", "file", "domain", "job", "web", "r", "host", "hl"], "sb": ["ub", "bf", "db", "buf", "nb", "SB", "bd", "b", "bp", "lb", "bs", "lp", "kb", "ob", "bsp", "bn", "bb", "sa", "erb", "ssl", "fb", "obs", "bt", "sm", "buff", "eb", "bg", "xb", "pb", "ib", "zb", "cb", "mb", "gb", "wb", "sg", "rob", "bh", "sp", "sv", "BB", "sf", "sq", "rb", " SB"], "scanner": ["scaninner", "searchner", "caner", " scanener", "caninner", " scaninner", "scanifier", " Scanifier", "canener", "Scaninner", "searchning", " Scaner", "scanter", "Scanter", " scanifier", "canning", "Scanifier", "canner", " scanning", "scanener", " scanter", "scaner", " Scanner", "Scanner", "Scaner", " Scanter", " scaner", "searchter", "Scanener", "canter", "searcher", "scanning"], "line": ["message", "text", "cell", "lin", "block", "ln", "user", "eline", "detail", "piece", "statement", "zone", "link", "row", "frame", "nl", "liner", "le", "inline", "ine", "group", "next", "LINE", "day", "l", "page", "sequence", "entry", "string", "command", "source", "point", "file", "stroke", "comment", "chain", "lined", "column", "word", "Line"]}}
{"id1": "18114701", "id2": "5707205", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"resolveEntity": ["resloveEnt", "consolveEnt", "consolveObject", "resolvingEntity", "resolvingInternal", "consolvingObject", "resolvingEnt", "resolvingObject", "resolvedObject", "resloveObject", "resloveInternal", "resloveEntity", "consolveInternal", "consolvingInternal", "resolvedEnt", "resolvedInternal", "resolvedEntity", "resolveObject", "resolveEnt", "resolveInternal", "consolvingEntity", "consolveEntity", "consolvingEnt"], "publicId": ["openPart", "ublicId", "fullInt", "publicTime", "privateId", " publicLink", " publicAnd", "privateInt", "privatePart", "ublicID", "openID", "publicLink", "publicAnd", "ublicPart", "primaryTime", " publicInt", "fullLink", "fullID", "openId", "primaryID", " publicID", "publicInt", "primaryId", "publicPart", "privateAnd", "primaryPart", "privateID", "publicID", "openAnd", " publicPart", "ublicTime", " publicTime", "privateLink", "fullId"], "systemId": ["userId", "externalName", " systemUrl", "userID", "systemID", " systemName", "externalId", "externalUrl", "sysId", "systemName", "userName", " systemID", "systemUrl", "userUrl", "sysName", "sysID", "externalID", "sysUrl"], "resolved": ["revolution", "presolver", "involved", "Resolver", "rolution", "resultsolution", "Resolve", "remolves", "resolution", "presolve", "revolved", "involution", "resolver", "remolution", "resolve", "Resolved", "solves", " resolver", "Resolving", " reserved", "resolving", "reserved", "involve", "presolution", "solving", "resultsolved", "solve", " resolve", "presolved", "served", "involving", "rolved", "rolving", " resolving", "consolving", "revolving", "remolved", "resolves", "resultsolver", "preserved", "rolve", "consolves", "consolution", " resolution", "solution", "Resolution", "presolving", "remolving", "revolver", "solved", "resultsolving", "consolved"], "iSource": [" iService", " iSourceFile", "qiSource", "iuSources", "uiSourceFile", "iSourceFile", "IMember", "iSOURCE", "liSources", "qiSOURCE", " iSources", "iiMember", "iiSite", "uiSite", "iuSourceFile", "ISource", "IResource", "liSite", "iMember", "aiStream", "iuSOURCE", "iResource", "iniResource", "iiSource", "iService", "liSource", "aiSource", " iSOURCE", "iuSource", "iSources", "iniMember", "iSite", "liService", "ISite", "uiSource", "aiService", "iniSource", "aiSourceFile", "qiSources", "uiSources", "qiSourceFile", "iniSite", " iSite", "liSourceFile", "iiResource", "liStream"], "url": ["path", "http", "mail", "html", "ls", "location", "sl", "arl", "user", "build", "bel", "link", "ur", "Url", "f", "address", "ul", "URL", "rel", "mol", "re", "ssl", "dl", "uri", "nl", "resource", "browser", "gl", "ref", "null", "str", "mount", "name", "mb", "ll", "l", "u", "char", "rl", "log", "web", "r", "hl"], "iStream": ["riStream", "ipstream", "uStreamer", "ipStream", "ipStreamer", "inputRead", "sourceSteam", "riSteam", "inputStream", "sourceStream", "sourceStreamer", "inputStack", "ipSteam", "sourcestream", "inputSteam", "riStack", "uStream", "istream", "ustream", "riRead", "iStreamer", "iSteam", " iRead", "uSteam", " iStack", "iRead", "iStack", " iSteam"]}}
{"id1": "16673769", "id2": "2398448", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"Start": ["Command", "Continue", " Continue", " Serve", "Next", "Init", " Activate", " Init", "Run", "Services", " Stop", "Runtime", "Config", "Application", "Configuration", "run", "Load", " start", "Loader", " Launch", " Startup", " restart", "Launch", " starting", "start", " START", " resume"], "resources": ["uploads", "states", "faces", "links", "parents", "headers", "users", "types", " Resources", "Resources", "times", "rooms", "images", "ues", "writers", "pages", "roots", "files", "classes", "packages", "ions", "actions", "works", "these", "ids", "builders", "features", "they", "cles", "archives", "bytes", "ables", "models", "reports", "apps", "relations", "flows", "modules", "stores", "names", "https", "issues", "groups", "events", "options", "seconds", "objects", "services"], "url": ["path", "buffer", "http", "json", "html", "ls", "location", "addr", "sl", "config", "ret", "bel", "link", "item", "handle", "b", "ur", "Url", "f", "address", "URL", "raw", "sql", "rel", "loader", "util", "id", "row", "uri", "dl", "nl", "t", "resource", "server", "browser", "gl", "ref", "this", "request", "key", "name", "mount", "impl", "str", "ll", "external", "xml", "get", "l", "char", "un", "remote", "base", "entry", "rl", "file", "log", "domain", "web", "res", "r", "host", "pattern"], "configFileContents": ["configStreamContent", "configFILEContents", "configStreamBytes", "jsonFileContent", "jsonfileBytes", "configDocumentBytes", "configfileContents", "configFileSettings", "configDocumentContents", "textFileContent", "jsonfileContents", "configfileRest", "jsonPageSettings", "configFileBytes", "configDocumentRest", "configStreamRest", "configFileCont", "textfileCont", "configfileCont", "configPageContents", "jsonPageContents", "jsonFileContents", "configFILEContent", "configFILECont", "configfileBytes", "jsonfileRest", "configfileContent", "configPageSettings", "textFileCont", "textFileContents", "configStreamSettings", "configStreamContents", "configPageCont", "jsonFileSettings", "configFileContent", "textfileContents", "jsonFileRest", "jsonFileBytes", "textfileContent", "configPageContent", "jsonPageContent", "configfileSettings", "configFileRest"], "configurable": ["mututable", "Configuable", "formured", "confurable", "Configurer", "figuable", "figurable", "capturable", "configured", "logorable", "cturable", " configurer", "Configutable", "controlured", " configutable", "configure", "confured", "captorable", "confcrete", "logure", "mutcrete", "capturer", " configure", "figurer", "configutable", "logurable", "figured", " configured", "configuable", "cturer", "ctured", "configcrete", "confure", "configorable", "formurer", " configorable", "confurer", " configuable", "controlurer", "mutuable", "ctutable", "configurer", "controlurable", " configcrete", "Configured", "Configcrete", "muturable", "captured", "logcrete", "controlutable", "formurable", "formuable", "Configurable", "conforable"], "jsonData": [" jsonEntry", " jsonDat", "configTime", "logData", " jsonContent", "jsonPart", "configData", "logDat", "JSONInfo", "configPart", "logPart", "sonDat", " jsondata", "sondata", "JSONdata", "jsonEntry", "logInfo", "jsondata", "xmlInfo", "xmlData", "sonEntry", "xmldata", "xmlEntry", "jsonContent", "sonTime", "JSONDat", "JSONData", "configInfo", "configdata", " jsonPart", " jsonInfo", "sonInfo", "sonData", "xmlContent", "configContent", "configDat", "xmlDat", "jsonInfo", " jsonTime", "jsonTime", "jsonDat"]}}
{"id1": "4895903", "id2": "20920051", "code1": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"load": ["loads", "save", "init", "sync", "open", "build", "link", "oad", "LOAD", "loader", "read", "download", "sample", "execute", "install", "use", "map", "lock", "transform", "call", "Load", "store", "dump", "loading", "launch", "show", "insert"], "sourceType": ["componentTYPE", "unittype", " sourceClass", "templateSpec", "typeType", "sourceCopy", " sourceStyle", "secretTyp", "noTyp", "serviceTyp", "typeEmail", "componentClass", "speType", "statusTyp", "scantype", "scopeTyp", "messageTyp", "licenseTyp", "templateType", "sourceTYPE", "styleTyp", "noStyle", "versionDefault", "statusType", " sourceTYPE", "scopeStyle", "sequenceTYPE", "notetype", "scopeType", "styleTYPE", "messageDefault", "ourceTy", "licenseTYPE", "sourceEmail", "speCopy", "serviceType", "statusVersion", "SOURCEType", "templateTyp", "templateStyle", "sourceStyle", "ourceTyp", "SOURCEtype", " sourceField", "templateCopy", "licenseType", "licensetype", "licenseUnit", "styleClass", " sourceTyp", "scanType", "serviceApp", "scanTyp", "sourcetype", "licenseEmail", "scopetype", "causetype", "SOURCEVersion", "messageTy", "componentTyp", "templatetype", "typeUnit", "scoreTyp", "versionTyp", "componentType", "statusTy", "notype", "ourceDefault", "sourceSpec", "scoreType", "componentField", "sourceTyp", "sourceTy", "sourceVersion", "versionTy", "statustype", "SOURCEApp", "styleType", "licenseVersion", "unitType", "noteTy", "causeType", "scopeSpec", "sourceDefault", "versionType", "unitTyp", "sourceApp", "sourceField", " sourceSpec", "secretApp", "servicetype", "scoretype", "scopeCopy", "secrettype", "versionStyle", "sequenceType", "sourceUnit", "scanField", "sourceClass", "noteType", "SOURCETyp", "causeTy", "sequenceEmail", "spetype", "messageType", " sourcetype", "versiontype", "componenttype", "speTyp", "sequenceUnit", "typeTYPE", "secretType", "ourceType", "causeTyp", "noteTyp", "noType"], "source": ["style", "function", "core", "se", "instance", "config", "force", "see", "size", "scan", "Source", "parent", "content", "component", "src", "any", "service", "license", "sequence", "status", "iter", "file", "query", "origin", "storage", "report", "list", "series", "text", "json", "description", "init", "template", "SOURCE", "seed", "sql", "create", "from", "slot", "slice", "feature", "scope", "remote", "details", "string", "object", "parse", "comment", "sp", "search", "start", "handle", "expression", "site", "missing", "draw", "ie", "me", "address", "via", "body", "ource", "subject", "use", "resource", "settings", "view", "unit", "get", "input", "copy", "table", "join", "target", "find", "alias", "message", "update", "reason", "node", "send", "raw", "state", "sample", "ce", "note", "spec", "filename", "key", "module", "store", "stream", "none", "show", "format", "context", "image", "supp", "cache"], "param": ["path", "arg", "prom", "pm", "attr", "model", "prefix", "monitor", "init", "member", "config", "method", "arm", "cal", "term", "msg", "item", "rem", "attribute", "property", "params", "asm", "reference", "p", "prop", "mm", "rm", "argument", "Param", "typ", "par", "tag", "ref", "pai", "pre", "rpm", "req", "name", "Parameter", "index", "cp", "aram", "perm", "problem", "m", "meter", "comment", "query", "admin", "format", "start", "conf", "rest"], "location": ["path", "history", "message", "expression", "owner", "ion", "shape", "description", "Location", "peer", "condition", "property", "address", "reference", "root", "usage", "region", "local", "center", "area", "sample", "folder", "bound", "feature", "loc", "resource", "initial", "filename", "scope", "translation", "library", "direction", "where", "key", "module", "LOC", "name", "operation", "mount", "position", "family", "event", "directory", "sequence", "remote", "activity", "ocation", "entry", "point", "padding", "device", "language", "value", "availability", "comment", "document", "target", "search", "info", "media", "origin", "context", "layout", "trace", "color"], "type": ["style", "function", "part", "shape", "description", "ping", "term", "time", "method", "types", "link", "sort", "class", "title", "tp", "ver", "address", "id", "root", "state", "pretty", "test", "kind", "t", "op", "typ", "scope", "length", " Type", "operator", "tag", "all", "where", "key", "TYPE", "error", "name", "unit", "ype", "position", "ime", "family", "Type", "event", "form", "pe", "command", "action", "status", "language", "port", "comment", "option", "info", "what", "format", "options", "trace", "color", "role", "ty"], "inputsource": ["acceptsource", "InputSource", "Inputsrc", " inputresource", "inputsrc", "submitsample", "inputsum", "inputscope", "inputsample", "helpsource", "uploadservice", " inputobject", "inputource", "outputobject", "helpiterator", " inputservice", " inputSOURCE", "operatorseed", "Inputresource", "inputSource", "insertsource", "insertiterator", "insertsite", "inputsequence", "Inputsource", " inputstore", "pullsource", "submitsrc", "inputSOURCE", " inputsrc", " inputSource", "inource", "inSource", "inputseed", "Inputobject", "operatorsource", "uploadstore", "acceptresource", "outputstore", "outputresource", "submitsource", "outputscope", "Inputource", "inputservice", "operatorstream", "uploadsum", " inputseed", "othersource", "submitsequence", "helpstore", "insertsum", "inputstream", "insertservice", "inputobject", "acceptscope", "inputstore", "pullseed", " inputsite", "inputiterator", "othersrc", "helpsite", "Inputstore", "outputsource", " inputource", "pullstream", "acceptsrc", "othersequence", " inputscope", "insertstore", "outputsrc", " inputiterator", "pullSOURCE", "uploadsource", "othersample", "operatorSOURCE", "inputresource", " inputsum", " inputstream", "inputsite", " inputsequence", "insource", "insrc", " inputsample"], "url": ["path", "buffer", "http", "text", "mail", "html", "abs", "term", "sl", "user", "open", "bel", "link", "ur", "Url", "f", "ml", "address", "URL", "p", "sql", "rel", "api", "download", "ssl", "dl", "uri", "nl", "client", "resource", "browser", "gl", "ref", "str", "impl", "xml", "mount", "ll", "external", "l", "u", "char", "net", "base", "string", "rl", "file", "git", "web", "cert", "r", "host"], "ds": ["dr", "db", "ms", "ls", "sd", "des", "sys", "gs", "bs", "ss", "dos", "ws", "uds", "qs", "hs", "Ds", "xs", "eds", "dt", "cs", "DS", "dl", "ys", "ps", "rs", "dh", "js", "ads", "ns", "sts", "gd", "ks", "dd", "dc", "md", "fs", "dds", "pd", "df", "di", "ees", "ysis", "eps", "ts", "sq"], "mbeans": ["cmbs", "cmovies", "mxbean", " mbs", "Mubes", " mbean", "Mbs", "umovies", "mxbeans", "movies", "umbean", "mxubes", "mbs", "lbean", "cmbeans", "Mbean", "mubes", "mxbs", "cmbean", "Mbeans", " movies", "umbs", "umbeans", "lbs", "lbeans", "mbean", "lubes"]}}
{"id1": "21063400", "id2": "2461169", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doMediaWork", "doImagesWork", " doImagesWork", "doItemImageprocess", "doItemImageSort", " doImagesprocess", "doItemImageProcess", "doImagesSort", " doImageprocess", " doImagesProcess", " doImageSort", "doImageWork", "doItemImageWork", "doMediaSort", "doImagesProcess", " doImagesSort", " doImageWork", "doImagesprocess", "doMediaProcess", "doMediaprocess", "doImageSort", "doImageprocess"], "request": ["message", "application", "session", "model", "QUEST", "template", "attribute", "address", "reference", "frame", "re", "client", "resource", "server", "version", "view", "quest", "command", "input", "Request", "select", "document", "query", "context", "start", "image", "question"], "response": ["output", "collection", "ve", "message", "http", "application", "site", "json", "description", "window", "model", "block", "user", "fire", "detail", "onse", "connection", "console", "reset", "relation", "frame", "respond", "re", "answer", "resp", "server", "continue", "parent", "content", "exit", "write", "tree", "version", "next", "xml", "view", "position", "one", "page", "Response", "sequence", "result", "print", "entry", "hash", "status", "reply", "document", "search", "display", "success", "format", "query", "res", "image", "report", "list", "cache", "network"], "imgSize": ["imagsize", "imgShape", "imageSIZE", "appsize", "appShape", "certSIZE", "imageName", "augOwner", "propsize", "imagError", "propName", "augsize", "imagSize", " imgsize", "imageStyle", "imgStyle", " imgStyle", "divsize", "imgName", " imgError", "imgInfo", " imgInfo", " imgShape", "certSize", "propSize", "augShape", "appType", "dimsize", "imgOwner", "divSIZE", " imgOwner", " imgName", "imageScale", "certName", "imageType", "appSize", "imgError", "imageSize", "propError", "imgSIZE", "imageInfo", " imgScale", "appInfo", "divSize", "dimSize", "imgsize", "imagName", " imgType", "appOwner", "dimSIZE", "certScale", "augSize", "imgScale", " imgSIZE", "appStyle", "imgType"], "imageInputStream": [" imageStreamStream", "imageInterfaceSteam", "imageOutputstream", "fileRawView", "imageByteSteam", " imageInputPath", "imageInputView", "imageInputSteam", "fileInputView", "photoInputSteam", "imageInView", "imageIntPath", "mediaInputReader", "photoIntSteam", "mediaInputSteam", "imageOutputSteam", "imageIntSteam", "photoIntstream", "imageIntStream", "imageInputstream", "fileInputSteam", "imageIntstream", "photoIntStream", "fileRawStream", "fileInputStream", "imageRawStream", "imageStreamSteam", "imageRawSteam", "imageStreamStream", " imageStreamSteam", "mediaInputForm", " imageStreamPath", "photoInputstream", "mediaInputStream", "fileInputstream", "imageInputReader", "imageByteForm", "imageInterfaceStream", "imageOutputStream", "imageInputForm", "imageOutputReader", "imageInSteam", "imageByteStream", "imageStreamPath", " imageInputSteam", "imageInStream", "imageInterfacestream", "fileRawstream", "imageOutputForm", "fileRawSteam", "imageInterfaceView", "imageRawView", "imageInstream", "photoInputStream", "imageRawstream", "imageByteReader", "imageInputPath"], "imageBytes": ["imgBytes", "audioBytes", "pictureGs", "photoParts", "imgBs", "imageGs", " imageGs", "photoBytes", "audioSeries", "imgParts", "imageSeries", "pictureByte", "photoGs", "audioParts", "issueBytes", "issueParts", " imageByte", " imageParts", " imageBs", "pictureBytes", "imageParts", "issueKeys", "photoByte", "imgGs", "audioBs", "imgSeries", "imageKeys", "imageByte", "photoKeys", "imgKeys", "imageBs", "pictureParts", "issueGs", " imageSeries"]}}
{"id1": "9954926", "id2": "18974466", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"simulate": ["modulates", "modure", "smulation", "modulate", " simure", "smulate", "modulation", "smulates", "smure", "simure", "simulates", "simulation", " simulation", " simulates"], "out": ["gov", "it", "aos", "to", "nr", "t", "content", "at", "tree", "inner", "error", "sum", "err", "hit", "gc", "OUT", "set", "report", "list", "buffer", "on", "con", "ger", "init", "ent", "last", "f", "o", "help", "ex", "outs", "conv", "ou", "e", "write", "group", "writer", "name", "w", "obj", "go", "net", "conn", "print", "batch", "co", "res", "cmd", "outer", "conf", "handle", "output", "n", "put", "manager", "can", "pool", "os", "OU", "ins", "client", "up", "cfg", "nt", "null", "copy", "cache", "exp", "gr", "Out", "sys", "b", "flush", "raw", "p", "state", "pretty", "inv", "io", "v", "all", "store", "screen", "base", "cn", "log", "in", "c", "gen"], "file": ["output", "buffer", "path", "message", "db", "model", "template", "type", "handle", "b", "connection", "f", "console", "pool", "fp", "io", "File", "t", "channel", "resource", "filename", "lock", "le", "library", "e", "name", "play", "l", "ile", "result", "FILE", "base", "input", "source", "set", "port", "table", "log", "document", "data", "format", "report"], "obtainUserReputationRequest": ["obtainUserRepetitionTarget", "obtainUserReputationsTarget", "obtainUserRepationResponse", "obtainUserRelutationResponse", "obtainUserRepositoryResponse", "obtainUserReputationsResponse", "obtainUserRepresentationTarget", "obtainUserReplutationResponse", "obtainUserReputationsQuery", "obtainUserRepositoryQuery", "obtainUserReputationsrequest", "obtainUserRelutationsRequest", "obtainUserReputionRequest", "obtainUserRelutationsResponse", "obtainUserRepationRequest", "obtainUserRepresentutationTarget", "obtainUserReporationResponse", "obtainUserReporationError", "obtainUserReputationsError", "obtainUserRepresentutationrequest", "obtainUserReputationTarget", "obtainUserReplutationRequest", "obtainUserReputionrequest", "obtainUserRelutationTask", "obtainUserRepationrequest", "obtainUserReputationrequest", "obtainUserRepresentutationQuery", "obtainUserRelutationQuery", "obtainUserRepresentutationResponse", "obtainUserRepresentationResponse", "obtainUserReputionTarget", "obtainUserReputationsRequest", "obtainUserReputationsTask", "obtainUserRepresentationQuery", "obtainUserRepationQuery", "obtainUserRepresentutationRequest", "obtainUserRepetitionResponse", "obtainUserReputationTask", "obtainUserReputionResponse", "obtainUserRepationTarget", "obtainUserRepositoryTask", "obtainUserReputionTask", "obtainUserRelutationsTask", "obtainUserRepresentationrequest", "obtainUserReputationQuery", "obtainUserRelutationsQuery", "obtainUserReporationQuery", "obtainUserRepresentationRequest", "obtainUserRepetitionRequest", "obtainUserReputationError", "obtainUserRepresentationError", "obtainUserRepationError", "obtainUserRepresentutationError", "obtainUserRepositoryRequest", "obtainUserReporationRequest", "obtainUserReputionQuery", "obtainUserRelutationRequest", "obtainUserReplutationTarget"], "obtainUserReputationResponse": ["obtainUserRepositoryService", "obtainUserReportositoryAnswer", "obtainUserReportutationResp", "obtainUserRepositoryResponse", "obtainUserRepulationAnswer", "obtainUserReputationsResponse", "obtainUserRepulationService", "obtainUserReportutationAnswer", "obtainUserReportositoryResp", "obtainUserReputationsAnswer", "obtainUserRepositoryAnswer", "obtainUserReputationResp", "obtainUserReputationService", "obtainUserRepositoryResp", "obtainUserReportositoryService", "obtainUserReportutationService", "obtainUserRepulationResponse", "obtainUserReputationAnswer", "obtainUserReputationsService", "obtainUserReportositoryResponse", "obtainUserReportutationResponse", "obtainUserRepulationResp", "obtainUserReputationsResp"], "rateUserRequest": ["rateUsersQuery", "RateUserQUEST", "rateUserCommand", "rateUserChange", "rateClientResponse", "rateUsersAccess", "rateRowResponse", "scaleOwnerAccess", "RateUserGrant", "rateProxyResponse", "rateuserRequ", "RateUserQuery", "rateOwnerRecord", " rateUserQuery", "rateLineRequ", "scaleOwnerResponse", "raceUserRecord", "rateRowrequest", "rateuserRequest", "RateUserResponse", "raceRowRequest", "rateLineCommand", "rateuserQuery", "rateJobResponse", "RateUsersRequest", "rateOwnerResponse", "RateUsersChange", "rateOwnerRequest", "scaleUserRequest", "RateClientRequest", "rateUsersrequest", "rateJobRequest", "rateRowJob", " rateUserJob", "RateUsersQUEST", "rateOwnerrequest", "rateLinerequest", "scaleUserAccess", "rateuserQUEST", "RateUsersrequest", "rateDateResponse", "rateUserQUEST", "createuserRequest", "rateDateRequest", "rateUserQuery", "RateLineRequest", "rateUserJob", "createUserRequest", "rateUsersChange", "RateUserRequest", "createUserRequ", "rateLineQuery", "RateUsersQuery", "RateLineQuery", "rateLineGrant", "rateuserAccess", "scaleUserResponse", "rateLineRequest", "rateUserGrant", "rateuserResponse", "RateUserrequest", "rateUsersRequest", "raceUserRequest", "rateTimeResponse", "rateSampleRequest", "rateuserCommand", "rateTimerequest", "rateLineResponse", "raceRowrequest", " rateUserrequest", "rateClientJob", "RateUserChange", "createUserrequest", "rateUserRecord", "rateUserrequest", "rateSampleRequ", "createuserRequ", "RateClientResponse", "rateProxyQuery", "rateDateGrant", "rateUsersQUEST", "rateProxyRequest", "raceRowRecord", "raceUserrequest", "rateOwnerAccess", "RateClientGrant", "rateSampleCommand", "rateClientRequest", "rateClientGrant", "rateClientrequest", "rateTimeRequest", "rateRowRecord", "scaleOwnerRequest", "RateLinerequest", "rateJobChange", "RateLineResponse", "rateuserrequest", "createuserCommand", "rateSamplerequest", "createuserrequest", "rateUsersResponse", "rateRowRequest", "rateProxyQUEST", "createUserCommand", "rateUserRequ", "rateUserAccess", "RateUsersResponse"], "rateUserResponse": ["rateMemberResponse", "rateClientReturn", "rateClientresponse", "rateUserReply", "rateUserReturn", "rateTimeStatus", "rateUsersStatus", "RateUserVersion", " rateUserReturn", "rateClientResponse", "rateMethodResponse", "rateClientResp", "rateuserRequest", "RateUserResponse", "rateMethodRequest", "rateWordresponse", "ratesClientMessage", "RateUsersRequest", "rateUserMessage", " rateClientResponse", " rateUserresponse", "RateUsersresponse", "rateManagerResponse", "ratesClientResponse", "RateUserresponse", " rateClientRequest", "rateMemberRequest", "rateWordResponse", "rateDateVersion", " rateUserAnswer", "rateUsersresponse", "rateDateResponse", "rateUserAnswer", "rateDateRequest", "rateWordReturn", "rateFileResponse", "RateUserRequest", "rateUserData", "RateUserData", "rateUserResp", "rateFileRequest", "RateUsersReply", "rateuserResponse", "rateUsersRequest", "rateManagerRequest", "rateTimeResponse", "rateControllerResponse", "rateMethodData", "rateMemberReply", " rateClientReturn", "rateFileReturn", "rateManagerResp", "rateMethodVersion", "rateuserReply", "ratesUserResponse", "rateUserresponse", " rateClientresponse", "ratesUserResp", "ratesUserMessage", "ratesClientRequest", "ratesUserRequest", "rateClientMessage", "rateUserStatus", "rateUsersAnswer", "rateControllerRequest", "rateClientRequest", "rateManagerMessage", "rateDateData", "rateTimeRequest", "rateMemberresponse", "rateUserVersion", "rateControllerResp", "rateControllerMessage", "rateTimeAnswer", " rateUserStatus", "rateuserresponse", "rateUsersResponse", "rateWordRequest", "ratesClientResp", "rateUsersReply", "RateUserReply", "rateFileresponse", "RateUsersResponse"], "fis": [" fi", "sfiss", "FIs", "lIS", "sfIS", "bis", "lIs", "fiss", "fisa", "fi", "Fis", "sfIs", "Fiss", "fIS", "fli", "flis", "FIS", "bi", "bisa", "liss", "fIs", "flisa", " fisa", "sfis", "lis"], "br": ["ch", "wr", "gr", "dr", "bf", "shr", "ger", "buf", "bd", "bp", "bm", "BR", "bn", "bl", "hr", "pr", "nr", "fr", "bt", "browser", "Br", "cr", "bro", "be", "bi", "str", "ctr", "gb", "vr", "mr", "tr", "bridge", "sr", "lr", "adr", "bh", "kr", "div", "ber"], "call": ["message", "word", "function", "update", "cell", "block", "add", "n", "cal", "callback", "draw", "send", "inv", "test", "execute", "frame", "use", "continue", "request", "all", "code", "name", "str", "play", "label", "contact", "bridge", "char", "result", "c", "line", "command", "check", "action", "status", "ell", "Call", "log", "called", "comment", "info", "query", "url", "trace", "dial", "report", "list", "cin"]}}
{"id1": "23215235", "id2": "8011262", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"readFile": [" readFiles", "parsefile", "readFiles", " readSourceFile", "parseFiles", "ReadFiles", "ReadSourceFile", "readfile", "readSourceFile", "parseFile", " readfile", "Readfile", "ReadFile", "parseSourceFile"], "url": ["path", "http", "db", "html", "ls", "location", "abs", "sl", "bel", "link", "item", "b", "ur", "Url", "address", "ml", "URL", "p", "id", "rel", "ssl", "uri", "dl", "loc", "nl", "channel", "client", "browser", "gl", "ref", "name", "mount", "str", "impl", "ll", "fl", "l", "char", "page", "u", "base", "string", "cl", "rl", "pattern", "file", "log", "job", "domain", "web", "document", "full", "host", "il"], "IOException": [" ioError", "BioError", "BioException", "IOError", " ioException", " IOError"], "ParserConfigurationException": ["ParserConfError", "parserConfigurationError", "ParserizationException", "ParserConfigurationError", "parserConfigError", "ParserConfigFailure", "ParserizationError", "parserConfigurationFailure", "ParserConfException", "parserConfigFailure", "parserConfigException", "ParserConfigurationFailure", "parserConfigurationException", "ParserConfigException", "ParserizationFailure", "ParserConfFailure", "ParserConfigError"], "SAXException": ["DAVException", "DAXError", "SAXMException", "SAXMError", "SAXError", "SAVException", "SAVError", "SAIError", "DAVError", "DAXException", "SAIFailure", "SAXMFailure", "SAIException", "DAVFailure", "SAXFailure", "DAXFailure", "SAVFailure"], "zipFileName": ["zipFolderId", "zipfilePath", "zipFolderName", "zipfileId", "zipPageID", "archivefileName", "zipFolderID", "zipFileId", "archiveFilePath", "zipfileID", "zipPageName", "zipFolderPath", "archivefileId", "zipFilePath", "archivefileID", "zipFileID", "zipfileName", "archiveFileId", "archivefilePath", "zipPageId", "archiveFileName", "archiveFileID", "zipPagePath"], "urlConnection": ["inputConnection", "sslControl", "urlConnect", "clientConn", "UrlClient", "sslConnection", "urlReader", "sslConnect", "sslClient", "inputControl", "clientConnection", "UrlConnect", "urlConn", "UrlControl", "clientReader", "UrlConnection", "clientConnect", " urlReader", "UrlReader", "urlControl", " urlConnect", "urlClient", "UrlConn", "inputConnect", " urlConn", "inputClient"], "inputStream": ["InputStream", " InputSteam", "InputSteam", "inputView", "inContext", " InputScript", "InputScript", "inputContext", " inputScript", "inView", " inputSteam", "InputView", " InputStream", "inputSteam", "inStream", " InputFile", "inputScript", "inSteam", "InputContext", "inputFile", " inputFile", "InputFile", " inputContext", " inputView"]}}
{"id1": "22993368", "id2": "6188784", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeString2String", "decodeFileToString", "decodeString2file", "decodeStringToFiles", "decodeFileFileFiles", "decodeString2File", "decodeFileFilefile", "decodeFileAsfile", "decodeFile2File", "decodeFile2file", "decodeFileTofile", "decodeFileAsFiles", "decodeFileAsString", "decodeFileToFiles", "decodeString2Files", "decodeFileAsFile", "decodeStringToString", "decodeStringTofile", "decodeFileFileString", "decodeStringToFile", "decodeFile2Files", "decodeFileFileFile"], "infile": ["outname", "outfolder", "fromfile", "infolder", "isinname", "frombase", "infilename", "fromfilename", "InFile", "inputfolder", "Infile", "isinfile", "fromFile", "isinfolder", "Inbase", "outfilename", "outbase", "inputname", "inputFile", "inname", "inFile", "isinFile", "inbase", "outFile", "Infilename", "inputfile"], "outfile": ["Outfile", "tofilename", "outname", " outname", " outFile", "outdir", "todir", "infilename", "OutFile", "Outdir", "tofile", "otname", "otFile", "otfile", "outfilename", "toFile", "inname", "otFILE", "inFILE", "indir", "inFile", "Outfilename", "outFile", "outFILE", " outFILE"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "auto", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "shape", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "frame", "note", "bone", "initial", "total", "buff", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "display", "paste", "append", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "shift", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "index", "reading", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " okay", "valid", "ceed", " succeed", "support", "response", "town", "condition", "exist", " succeeds", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "scope", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "done", "photo", "sufficient", "error", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first"]}}
{"id1": "1798720", "id2": "20735941", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"save": ["update", "saving", "init", "pkg", "send", " seal", "Save", "folder", "export", "download", "accept", "install", "register", "filename", "release", "delete", "store", "version", "dump", "upload", "archive", " Save", "data", "aw", "pack", "zip"], "packageName": ["packageCode", "PackageName", " packageNames", " packageCode", "moduleNames", "modulename", "packagename", " packageType", "moduleCode", "packageType", "PackageType", "pkgname", "packageNames", "PackageNames", "moduleName", " packageKey", "PackageId", "moduleKey", "pkgNames", "packageId", "pkgId", "pkgType", "pkgCode", "pkgKey", "pkgName", "packageKey", "moduleId", " packageId", " packagename"], "fileContents": ["byteContent", "FileValues", "fileContent", "FileBytes", "fileItems", " fileItems", "FileContent", "FileIngredients", "byteContents", "pageContents", " fileContent", "packageContents", "packageContent", "packageNames", " fileValues", "pageBytes", "pageItems", "FileItems", "FileContents", "fileBytes", "pageNames", "packageIngredients", "fileIngredients", "byteValues", " fileIngredients", "fileValues", "byteNames", "FileNames", " fileBytes"], "fileNames": ["fileLeaks", "moduleNames", "FileValues", "fieldNames", "fileVaults", " fileVaults", "FileName", "FileKeys", "fieldNumbers", "moduleContents", "messageNames", "dirTypes", "FileTypes", "issueName", "issueVaults", "moduleVaults", " fileValues", "FileLeaks", "fileName", "resourceNames", "fileTypes", "FileContents", "messageValues", " fileLeaks", "fileKeys", "resourceTypes", "moduleName", "dirKeys", "issueContents", "resourceValues", "issueNames", "dirLeaks", "resourceContents", "fileValues", "messageKeys", "fieldContents", " fileTypes", "fieldTypes", "resourceNumbers", " fileNumbers", "FileNames", " fileKeys", "dirNames", "fileNumbers", " fileName", "messageName"], "dirBase": ["DIRBuilder", "DirBas", " directoryBottom", "pkgSet", "directoryBase", "dirSet", "pkgBase", "DIRBottom", "dirBuilder", "directorybase", "directorySet", " directoryBase", "pathBasic", "irBase", "dirBasic", "pathBas", " directoryBuilder", "dirBottom", "folderBas", " directoryBas", "folderBase", "irbase", "pathbase", "dirBas", "DIRBas", "DirBottom", "dirbase", "irBas", "pkgbase", "DirBase", "irSet", "pkgBas", "folderbase", "DirBuilder", "DIRBase", "pathBase", "directoryBasic", "directoryBas", "folderBasic"], "packageDir": [" packageFolder", "modulePath", "podD", " packagePath", "packageDef", "pkgDir", "installD", " packageD", "packageFolder", " packageDist", "installDir", "moduleRel", "moduleDir", "pkgPath", " packageRel", "packageD", "podDir", "podDist", "pkgRel", "installDef", "installDist", "pkgFolder", "moduleDef", "moduleFolder", "pkgDef", "podDef", "packageRel", " packageDef", "packageDist", "packagePath"], "created": ["joined", "loaded", "existent", "printed", "added", "released", "present", " generated", "creat", "installed", " started", "registered", "locked", "create", "generated", "produced", "checked", "creator", "associated", "filled", "made", "started", "raised", "ready", "confirmed", "creation", "founded", "recorded", "Created", "mounted", "TED", "defined", "ced", "called", "given", "activated", "developed", "arted", "provided", "reported", "successful", "allowed", "forced"], "currentPath": [" currentName", "recentParent", " currentParent", " currentFile", "currentParent", "currentlyName", "currentName", "currentlyCh", "currentlyPath", "currentPoint", "recentPoint", " currentPoint", "CurrentName", "CurrentPath", "CurrentCh", "recentPath", "currentCh", "CurrentParent", "CurrentPoint", " currentCh", "currentlyFile", "currentFile", "recentName", "CurrentFile"], "i": ["it", "ri", "ic", "iu", "iii", "ind", "qi", "gi", "status", "iy", "ij", "cli", "li", "oi", "zi", "j", "init", "my", "ini", "ui", "f", "jj", "q", "o", "ex", "uri", "slice", "this", "hi", "g", "ji", "bi", "ti", "go", "batch", "ami", "chain", "sim", "ip", "multi", "im", "ity", "ie", "me", "major", "id", "os", "ci", "ii", "index", "u", "ei", "yi", "m", "xi", "iq", "exp", "pi", "phi", "ai", "ski", "p", "y", "mi", "ki", "v", "key", "cgi", "si", "I", "them", "mu", "di", "info", "in", "ix"], "file": ["path", "buffer", "disk", "db", "template", "fo", "header", "type", "link", "f", "et", "body", "p", "pool", "h", "local", "row", "dir", "io", "File", "resource", "parent", "le", "rule", "name", "play", "handler", "l", "page", "ile", "FILE", "base", "source", "set", "child", "port", "table", "log", "comment", "info", "format", "handle", "sf"], "fos": ["faos", " fOS", " fo", "ffaos", "ffoes", "oos", "fow", "fo", " foses", "Foss", "woses", "oaos", "sfOS", "fOS", "sfoss", "fbos", "flaos", " fow", " foes", "Faos", "sfaos", "Foes", "FOS", "flo", "oo", "flos", "floes", "Fos", "fbo", "floses", "foes", "Fo", "floss", "sfos", " foss", "fbaos", "ffo", "woes", "oow", "foses", " faos", "foss", "woss", "ffos", "wos", "fbow"], "fileSrc": ["jobNrc", "fileDrc", "jobSci", "jobNrl", "fileNrl", "fileInssrc", "fileDource", " fileInsRC", "jobNci", "fileErl", " fileSsrc", "fileNri", "jobSrc", " fileInsource", "fileDri", "fileSrl", " fileInssrc", "fileSci", "fileInrc", "fileDrl", "jobNri", "fileEci", "fileInource", "jobSrl", " fileSource", "fileInsrc", " fileSRC", "fileInRC", "fileDci", "fileDsrc", "jobSri", "fileSource", "fileSsrc", "fileSRC", "fileInsRC", " fileInsrc", "fileEri", "fileSri", "fileErc", "fileDRC", "fileNrc", "fileInsource", "fileNci"], "fileDst": ["FileDcr", "FileSld", "FileDnd", "FileSlt", "fileSlt", "fileNlt", "fileSst", "fileNld", "FileSst", "FileDpl", "FileDld", "fileSnd", "fileDcr", "filedld", "fileSld", "FileDlt", "filedst", "fileDot", "FileSot", "fileSpl", "fileDnd", "fileDpl", "FileScr", "fileNot", "FileDst", "fileWot", "fileWlt", "fileNnd", "fileDld", "FileSnd", "fileDlt", "filednd", "fileNst", "filedcr", "FileDot", "fileWst", "fileSot", "fileScr", "fileNpl", "FileSpl", "fileWpl", "fileNcr"], "reader": ["buffer", "runner", "dr", "rar", "book", "ri", "author", "controller", "rx", "review", "rer", "loader", "parser", "rc", "read", "row", "iterator", "er", "resource", "inner", "readable", "reading", "handler", "stream", "rot", "rr", "ocker", "upper", "Reader", "Larry", "roller", "oder", "ner", "entry", "iter", "rl", "driver", "actor", "ro", "query", "context", "ader", "r", "ler"], "writer": ["buffer", "runner", "word", "function", "builder", "adder", "window", "caster", "user", "worker", "draw", "manager", "flush", "riter", "loader", "writers", "variable", "console", "parser", "writing", "read", "iterator", "test", "maker", "creator", "later", "client", "liner", "server", "wright", "wrapper", "browser", "operator", "write", "store", "wire", "handler", "println", "w", "service", "stream", "player", "ter", "print", "Reader", "entry", "Writer", "iter", "table", "driver", "document", "walker", "format", "query", "outer", "storage", "report", "editor", "order"], "line": ["message", "style", "text", "node", "cell", "block", "lin", "ln", "valid", "user", "header", "eline", "detail", "link", "entity", "row", "sample", "frame", "ole", "nl", "liner", "continue", "le", "code", "inline", "ine", "rule", "label", "edge", "LINE", "number", "l", "kin", "page", "sequence", "record", "pe", "entry", "print", "source", "point", "string", "port", "date", "stroke", "range", "comment", "chain", "lined", "column", "word", "Line"]}}
{"id1": "20247400", "id2": "8320469", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"in": ["IN", "on", "din", "gin", "con", "init", "it", "rin", "ai", "is", "ze", "and", "inc", "io", "from", "ind", "ins", "up", "bin", "inner", "isin", "In", "net", "check", "input", "source", "file", "i", "info", " din", "inn", "inf", "cin"], "out": ["output", "list", "con", "or", "ln", "n", "Out", "auto", "it", "msg", "sys", "b", "o", "to", "os", "dir", "io", "OU", "ex", "ins", "t", "outs", "client", "ou", "exit", "at", "write", "null", "writer", "name", "str", "println", "w", "screen", "r", "obj", "other", "err", "net", "print", "OUT", "line", "check", "gt", "ne", "log", "oss", "ot", "cmd", "outer", "we", "report"], "buffer": ["output", "message", "Buffer", "binary", "db", "function", "pause", "history", "shape", "window", "block", "buf", "template", "phrase", "se", "header", "database", "bar", "available", "b", "attribute", "filter", "processor", "flush", "address", "variable", "sample", "size", "queue", "channel", "total", "buff", "length", "component", "library", "clear", "key", "view", "index", "position", "bridge", "event", "result", "sequence", "command", "batch", "limit", "source", "iter", "table", "match", "comment", "stack", "document", "data", "display", "memory", "trace", "append", "temp", "cache"]}}
{"id1": "7757297", "id2": "2910383", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"submit": ["edit", "update", "close", "save", "open", "apply", "send", "download", "accept", "execute", "create", "sub", "login", "Submit", "run", "request", "process", "post", "upload", "form", "print", "input", "launch", "format", "display", " submission", "report"], "uri": ["path", "doi", "http", "message", "description", "password", "location", "prefix", "term", "ri", "msg", "link", "ui", "ur", "title", "address", "URL", "id", "iri", "wiki", "subject", "campus", "resource", "filename", " URI", "course", "du", "name", "URI", "href", "directory", "source", "file", "i", "range", "pi", "info", "origin", "report"], "Exception": ["API", "T", "Connection", "Failure", "X", "Message", "Application", "E", "Default", "Class", "null", "Status", "Result", "Warning", "Throw", "Exit", "EX", "Response", "ception", "Document", "Error", "Event"], "encodedrdf": ["encodingrdfx", "encodingrdl", "encodingrdfs", "encodeddrfc", "encodingrsf", "encodedridfc", "encodedwsfx", "encodingrsfx", "encodeddrf", "encodedrsf", "encuredrl", "encodedrsl", "encodedrtfs", "encuredrfc", "encuredrp", "encodedrfc", "encodedrtfx", "encuredrdfc", "encuredrdl", "encodedridl", "encodedrtf", "encodedridf", "encodedrsfx", "encodedridp", "encodedrdfx", "encodeddrp", "encodedrdl", "encodedrp", "encodeddrl", "encodedwsfs", "encuredrdp", "encodedrdfs", "encodedrtl", "encodedrl", "encodedrdp", "encuredrdf", "encodedwsl", "encodedrf", "encodingrsl", "encodedrdfc", "encodedrsfs", "encodingrsfs", "encodingrdf", "encuredrf", "encodedwsf"], "url": ["http", "con", "ls", "location", "sl", "open", "build", "link", "b", "ur", "Url", "address", "ul", "socket", "URL", "p", "ssl", "loc", "nl", "client", "resource", "browser", "str", "mount", "name", "ll", "service", "l", "conn", "base", "m", "file", "log", "sb", "https", "web", "cert", "r", "li"], "connection": ["output", "message", "session", "connect", "ion", "application", "Connection", "con", "description", "function", "using", "n", "open", "link", "database", "response", "generation", "condition", "statement", "socket", "relation", "io", "creator", "client", "resource", "channel", "server", "writer", "communication", "index", "still", "handler", "number", "position", "l", "established", "connected", "result", "conn", "command", "entry", "web", "document", "https", "in", "context", "ticket", "c", "network"], "lastUser": ["lastAuthor", " lastDate", "LastCategory", "lastDate", "latestDate", " lastAuthor", "latestUser", "latestCategory", "LastUser", "lastCategory", " lastCategory", "LastAuthor", "LastDate", "latestAuthor"], "out": ["output", "ch", "gr", "list", "json", "con", "timeout", "window", "n", "init", "Out", "it", "ent", "sys", "rem", "raw", "p", "pretty", "o", "aos", "to", "inv", "pool", "io", "help", "ex", "outs", "conv", "client", "up", "server", "v", "ou", "serv", "nt", "at", "write", "all", "inner", "null", "writer", "screen", "obj", "txt", "net", "err", "cont", "conn", "print", "OUT", "line", "check", "conf", "set", "table", "log", "chain", "co", "query", "format", "in", "cmd", "res", "report", "cache"]}}
{"id1": "20091126", "id2": "12306305", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["load", "save", "sync", "open", "move", "y", "transfer", "cat", "download", "create", "to", "io", "map", "Cop", "call", "delete", "write", "store", "cp", "get", "upload", "Copy", "file", " Copy", "system", "Transfer", "clone", "paste"], "in": ["IN", "din", "gin", "init", "n", "ini", "rin", "b", "ck", "old", "ain", "id", "en", "inc", "io", "from", "mm", "ind", "ins", "el", "up", "inner", "isin", "r", "l", "In", "input", "source", "file", "i", "info", " din", "inn", " input", "inf", "cin"], "out": ["output", "ch", "self", "or", "x", "n", "Out", "it", "msg", "tmp", "b", " output", "as", "y", "p", "o", "to", "os", "end", "io", "ex", "outs", "t", "channel", "v", "ou", "nt", "e", "at", "write", "null", "w", "bytes", "one", "l", "_", "err", "result", "net", "OUT", "gt", "file", "log", " it", "co", "ot", " os", "s", "res", "c"], "inChannel": ["binRow", " inRow", " inCommand", "innChan", " inSection", "incChannel", "inChuck", "binSection", "inConnection", " inConnection", "conListener", "innConnection", "ginChain", "cinChannel", "insideChannel", "cinchannel", "inchannel", "InChannel", "InConnection", "conChannel", "INChannel", " inchannel", "ginChannel", "inChan", " inListener", "binCommand", "Inchannel", "binChuck", "INListener", "INConnection", "outBlock", " inChan", "outchannel", "inBlock", "inChain", "insideCommand", "inRow", "inSection", "inCommand", "incChuck", "INChan", "inListener", "ginChuck", "binPanel", "inPanel", "binChannel", "incPanel", " inBlock", "innChannel", "cinBlock", "cinCommand", "insideRow", "insideSection", "innchannel", "InChan", "conConnection", "conChan", "outCommand", "binChain", "ginPanel", "incChain"], "outChannel": ["inCh", "outCh", "OutChan", " outCh", "cosSlot", "moduleChannel", "skyChannel", "outputPassword", "OutChannel", "outputManager", "outUser", "outManager", "cmdChannel", "skyMany", "inchannel", "cmdMany", " outchannel", " outGate", "inChan", "OutCh", "cmdGate", "outGate", "outchannel", "OUTChannel", "OUTSlot", "OUTUser", "skyGate", "moduleChan", "cmdChan", "cosUser", "outSlot", "moduleManager", "outMany", "cosChannel", "inSlot", "outputChan", " outPassword", " outChan", "outChan", "skyChan", "inUser", "outputChannel", " outMany", "Outchannel", "OUTChan", " outManager", "cosChan", "modulePassword", "outPassword"]}}
{"id1": "3584508", "id2": "20735941", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" copiedFile", "copyAddress", " copiedAddress", " copiedResource", " copyUrl", " copiedUrl", " copyFile", "copyUrl", "downloadUrl", "downloadFile", "downloadResource", " copyAddress", "copyFile", "downloadAddress"], "url": ["path", "http", "mail", "html", "ls", "sl", "ret", "link", "ur", "Url", "f", "address", "ml", "ul", "gif", "URL", "rel", "util", "github", "re", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "browser", "gl", "ref", "null", "str", "mount", "mb", "ll", "fl", "service", "l", "char", "base", "string", "source", "cl", "rl", "file", "https", "web", "cert", "r", "host", "hl"], "input": ["http", "eval", "text", "missing", "focus", "add", "access", "unknown", "config", "it", "init", "qa", "open", "user", "ip", "feed", "ain", "raw", "can", "state", "local", "accept", "read", "Input", "ssl", "op", "initial", "up", "request", "null", "inner", "pull", "reader", "index", "stream", "get", "upload", "sum", "form", "cont", "base", "before", "PUT", "source", "acl", "iter", "select", "file", "active", "enter", "parse", "info", "inside", "empty", "start", "context", "in", "act", "image", "exec", "audio"], "output": ["text", "update", "unsigned", "auto", "Output", "four", "response", "put", "connection", "entity", "console", "o", "icon", "ilo", "bool", "beta", "client", "current", "ou", "continue", "component", "exit", "write", "null", "group", "next", "position", "hidden", "online", "other", "net", "you", "print", "remote", "object", "ne", "table", "file", "secure", "secondary", "web", "display", "success", "format", "out", "outer", "image", "network"], "b": ["B", "bf", "db", "binary", "block", "by", "j", "nb", "bp", "f", "body", "ob", "bs", "p", "y", "bb", "t", "bits", "fb", "v", "buff", "ab", "eb", "be", "bi", "bit", "g", "ib", "mb", "d", "cb", "gb", "wb", "l", "char", "k", "obj", "bc", "u", "base", "m", "ba", "z", "i", "br", "ble", "sb", "r", "c", "rb"]}}
{"id1": "15241397", "id2": "335223", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "DoGET", "Doget", "doGET", "DoPut", "doget", "DoGet", "handleGet", "handlePut", "doPut", " doPut", "handleget", " doget"], "request": ["each", "message", "http", "application", "QUEST", "hello", "user", "attribute", "connection", "address", "reference", "complete", "reset", "create", "frame", "re", "client", "initial", "current", "server", "transform", "setup", "forward", "req", "quest", "get", "position", "command", "input", "Request", "the", "document", "query", "in", "start", "context", "report", "first", "question"], "response": ["output", "ve", "message", "http", "application", "site", "session", "json", "description", "block", "fire", "onse", "connection", "send", "body", "console", "reset", "ce", "frame", "respond", "answer", "resp", "resource", "server", "content", "exit", "write", "version", "next", "xml", "view", "service", "position", "page", "Response", "result", "sequence", "form", "print", "object", "status", "reply", "document", "success", "context", "res", "image", "report", "network"], "rewrittenQueryString": ["rewartedQueryStream", "rewrittenquerystring", "rewwrittenquerystring", "rewrittenURLString", "rewartedHeaderStr", "rewwrittenqueryStr", "rewartedHeaderStream", "rewliedqueryStr", "rewrittenQuerystring", "rewwrittenQueryStr", "rewrittenqueryStream", "rewrittenURLstring", "rewrittenQuStr", "rewwrittenQueryString", "rewrittenURLStr", "rewliedqueryStream", "rewwrittenqueryString", "rewartedQuerystring", "rewrittenHeaderString", "rewrittenRequestQuery", "rewartedQueryString", "rewrittenRequeststring", "rewrittenURLStream", "rewwrittenqueryQuery", "rewliedQueryString", "rewrittenHeaderStream", "rewartedHeaderstring", "rewrittenQuestionString", "rewliedqueryString", "rewrittenHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentQuery", "rewliedQueryStr", "rewrittenCurrentStr", "rewrittenHeaderStr", "rewrittenQueryQuery", "rewartedQueryStr", "rewrittenQueryStream", "rewrittenqueryQuery", "rewliedQueryStream", "rewrittenQuString", "rewrittenqueryStr", "rewrittenQuStream", "rewwrittenQuerystring", "rewartedHeaderString", "rewrittenQuestionStr", "rewrittenQueryStr", "rewrittenQustring", "rewrittenRequestString", "rewrittenCurrentstring", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenqueryString", "rewrittenRequestStr"], "rewrittenUrl": ["rewwrittenPort", "rewriddenURL", "rewroteLink", "RewwrittenString", "rewriteurl", "RewrittenUrl", "RewrittenPosition", "rewrownURL", "rewwrittenUrl", "rewrapedUrl", "rewittenURL", "RewrittenString", "rewroteUr", "RewwrittenLink", "Rewwrittenurl", "RewwrittenUrl", "rewartedPosition", "RewwrittenURL", "RewrittenUr", "rewedUrl", "rewrownUrl", "rewrapedURL", "RewwrittenPosition", "rewrittenPort", "rewrownUr", "rewroteurl", "rewrapedPort", "rewedString", "RewrittenPort", "rewriddenPosition", "rewrittenLink", "rewartedUrl", "rewrittenUr", "RewrittenLink", "rewittenUrl", "Rewrittenurl", "rewriteUrl", "rewriterString", "rewartedUr", "rewriterUr", "rewittenurl", "rewrownPosition", "rewwrittenUr", "rewadjustedUrl", "rewrittenString", "RewwrittenPort", "rewadjustedPort", "rewwrittenURL", "rewwrittenLink", "rewartedURL", "rewrotePosition", "rewwrittenPosition", "rewrittenurl", "rewedUr", "rewadjustedUr", "rewriddenUrl", "rewroteURL", "rewriteURL", "rewedURL", "rewriteUr", "rewadjustedURL", "rewwrittenString", "rewriterURL", "rewartedurl", "rewwrittenurl", "rewrapedUr", "rewrittenPosition", "rewittenLink", "rewriddenUr", "rewroteUrl", "RewrittenURL", "rewriterUrl", "rewrittenURL", "RewwrittenUr"], "httpURLConnection": ["HttpURLConnection", "httpURLConnect", "httpUrlApplication", "HttpURLConnect", "ttpURLConnect", "HttpHTTPConnect", "httpSRApplication", "httpHTTPConnect", "ttpUrlConnect", "ttpUrlConn", "ttpUrlApplication", "httpURLApplication", "httpFileConn", "httpURLConn", "ttpURLApplication", " httpUrlApplication", "httpUrlConfiguration", "HttpURLApplication", "httpMLConnect", "HttpHTTPConfiguration", "httpHTTPControl", "httpMLconnection", "httpUrlConnect", "ttpURLConnection", "httpHTTPconnection", "httpURLControl", "ttpUrlconnection", " httpUrlConnection", "ttpUrlControl", "httpRLConnect", "httpRLconnection", "httpFileConnection", " httpUrlconnection", "httpHTTPConn", "HttpUrlConnect", " httpUrlConnect", "httpURLconnection", "httpFileApplication", "httpHTTPConnection", "ttpURLConn", "HttpUrlconnection", "httpSRconnection", "httpURLConfiguration", "HttpHTTPConnection", "httpMLApplication", "ttpURLconnection", "httpMLConnection", " httpURLconnection", "httpSRConnect", "httpSRConnection", "ttpUrlConnection", "httpSRControl", " httpURLConnect", "httpUrlConnection", "httpHTTPConfiguration", "httpUrlconnection", "HttpURLconnection", "HttpUrlConnection", "httpHTTPApplication", " httpURLApplication", "HttpURLConfiguration", "ttpURLControl", "HttpHTTPconnection", "httpFileConnect", "httpRLConnection", "httpSRConfiguration", "httpUrlControl", "httpUrlConn", "HttpHTTPApplication", "httpRLApplication"], "header": ["field", "buffer", "dr", "part", "core", "term", "block", "init", "prefix", "head", "section", "user", "peer", "headers", "shift", "detail", "attribute", "heading", "metadata", "title", "zone", "filter", "address", "holder", "state", "token", "variable", "h", "relation", "er", "feature", "client", "argument", "wrapper", "tag", "component", "operator", "rule", "version", "handler", "hidden", "policy", "ter", "page", "event", "line", "meta", "check", "hash", "Header", "layer", "status", "padding", "device", "port", "comment", "option", "info", "query", "format", "column", "handle"], "value": ["field", "VALUE", "message", "expression", "text", "json", "description", "password", "save", "hello", "val", "instance", "des", "attribute", "zone", "see", "example", "property", "address", "sample", "create", "test", "default", "element", "current", "server", "v", "email", "content", "pair", "Value", "key", "version", "label", "name", "unit", "ue", "values", "vector", "sequence", "record", "entry", "string", "hash", "language", "python", "job", "comment", "sv", "data", "format"], "inputStream": ["InputStream", "outputSteam", " inputThread", "inputWindow", "inputstream", "inputView", "errorSteam", "errorWindow", " inputLoop", " inputSteam", "InputView", "InputLoop", "outputstream", "inputThread", "inputSteam", "outputView", "outputLoop", "outputThread", "inputLoop", "InputThread", " inputWindow", "errorstream", " inputstream", "errorStream", " inputView", "outputWindow"], "outputStream": ["outputSteam", "responseLength", " outputLength", "inputstream", " outputForm", "inputView", "displayView", "displaySteam", "displayStream", "OutputLength", "outputForm", "responseSteam", "outputstream", "OutputSteam", "responseStream", "outputLength", "inputSteam", "outputView", "displaystream", " outputstream", "OutputStream", "responseForm", " outputSteam", "OutputForm", " outputView"]}}
{"id1": "17683082", "id2": "530882", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"IOException": ["DownloadProblem", " ioProblem", "IOProblem", " ioError", "DownloadException", " ioEx", "IOError", " ioException", " IOEx", "DownloadEx", "IOEx", " IOProblem", "DownloadError", " IOError"], "url": ["path", "http", "ls", "abs", "sl", "access", "org", "ret", "bel", "link", "ur", "Url", "ul", "URL", "rel", "util", "re", "att", "pl", "ssl", "dl", "loc", "nl", "resource", "client", "channel", "gl", "str", "mount", "impl", "ll", "fl", "l", "char", "conn", "gc", "base", "file", "log", "sb", "web", "https", "hl"], "connection": ["application", "connect", "session", "pointer", "Connection", "database", "link", "response", "condition", "socket", "pool", "relation", "io", "channel", "client", "resource", "engine", "handler", "page", "connected", "conn", "object", "port", "system", "document", "context", "c", "network"], "ns": ["fn", "ms", "ls", "es", "n", "sys", "gs", "bs", "nm", "ss", "ds", "cs", "ny", "ps", "rs", "nt", "NS", "na", "Ns", "fs", "net", "sn", "ne", "cn", "names", "s", "res", "ts"]}}
{"id1": "17999474", "id2": "7908169", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipToFile", "getBoxAsLocal", "getBoxFromFile", "getZipInfile", "getZipInLocal", "getZipFromFile", "getBoxAsfile", "getZipAsPath", "getBoxAsPath", "getZipAsLocal", "getZipToLocal", "getZipAsfile", "getZipFromPath", "getZipFromLocal", "getZipFromfile", "getBoxAsFile", "getBoxFromLocal", "getZipTofile", "getZipInFile", "getBoxFromPath", "getZipToPath", "getBoxFromfile", "getZipInPath"], "digOb": ["DigOcc", " digObj", "divObject", "digObj", "digOB", "gradObject", "divObj", " digEx", "DigObj", "digOcc", "digObject", " digObject", " digOcc", "DigObject", "gradObj", "gradOb", "gradOB", "chemEx", "chemOB", " digOB", "DigOb", "DigOB", "chemObj", "divOcc", "digEx", "chemOb", "DigEx", "divOb"], "folderName": [" folderNames", "FolderPath", "fileSize", " folderKey", "foldPath", "FolderName", "folderNames", "fileNames", " folderSize", "Foldername", "fileName", "foldNames", " folderPath", "foldname", "folderSize", " foldername", "foldKey", "fileKey", "folderKey", "foldName", "foldername", "folderPath", "FolderNames", "foldSize"], "tmpFolder": ["tempParent", "tempDir", "cmpParent", "tmpfolder", "cmpDir", "mpDirectory", " tmpDirectory", "mpDir", "tempDirectory", "tmpDirectory", "cmpFolder", "cmpfolder", "mpfolder", "mpParent", " tmpfolder", "tempFolder", "tmpDir", "tmpParent", "tempfolder", "mpFolder", " tmpDir"], "zip": ["mail", "json", "wrap", "pdf", "template", "se", "pkg", "link", "tmp", "ip", "tar", "zone", "feed", "sheet", "f", "body", "proxy", "bag", "pool", "folder", "sample", "row", "col", "report", "test", "install", "io", "lock", "content", "library", "cloud", "box", "gz", "Zip", "ow", "xml", "post", "upload", "quote", "form", "entry", "project", "drop", "archive", "file", "csv", "z", "sp", "exp", "cf", "temp", "pack", "sea", "jar"], "out": ["output", "cos", "list", "n", "auto", "Out", "ent", "it", "ln", "tmp", "flush", "o", "inv", "to", "os", "en", "aos", "io", "OU", "conv", "ex", "t", "outs", "ins", "up", "v", "serv", "ou", "all", "write", "null", "inner", "writer", "one", "net", "print", "OUT", "check", "set", "copy", "us", "i", "oss", "co", "sp", "s", "in", "res"]}}
{"id1": "8320469", "id2": "3536332", "code1": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5": [" md6", "MD4", "md4", "md6", " md2", " md4", "MD6", "sha4", "MD5", "sha2", "sha6", "sha5", "MD2", "md2"], "text": ["path", "output", "buffer", "message", "binary", "password", "prefix", "TEXT", "font", "config", "msg", "ext", "title", "secret", "Text", "read", "bound", "t", "pt", "email", "nt", "content", "translation", "confirmed", "code", "hex", "str", "name", "required", "aut", "txt", "event", "print", "string", "input", "source", "log", "published", "document", "data", "word", "image", "pattern"], "encrypted": ["message", "password", "plain", "loaded", "unsigned", "pdf", "printed", "marked", "added", "approved", "interrupted", "used", "seed", "installed", "secret", "updated", "enc", "locked", "generated", "initialized", "checked", "ebook", "sent", "ed", "rendered", "created", "Secure", " secured", "qualified", "tested", "confirmed", "rypted", "colored", "hex", "packed", "required", "written", "bytes", "ended", "connected", "rounded", "signed", "secure", "empty", "ressed", "verified"], "md": ["dr", "db", "pm", "ms", "nd", "sd", "msg", "mc", "bd", "od", "and", "del", "MD", "grad", "der", "ds", "cd", "mg", "met", "dir", "mm", "dm", "rm", "mt", "ind", "red", "down", "sm", "dh", "det", "ld", "dd", "d", "mb", "mp", "exec", "mk", "amd", "mod", "managed", "pd", "m", "df", "di", "mn", "mand", "cmd", "med", "hd", "ng"]}}
{"id1": "10214218", "id2": "15500892", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" encrypted", " encryption", "Encrypted", " encode", "Encode", "encode", "Encryption", "decrypted", "decode", "encryption", "Encrypt", "encrypted", "decryption", "decrypt"], "plaintext": ["preterm", "plainpassword", "plainterm", "preText", " Plaintext", "longtext", "prepassword", " plainterm", "plaincontext", "longcontext", "richcontext", "plainText", " plainText", "richText", "plainprotein", "longprotein", " plainprotein", "pretext", "richtext", " Plainpassword", " plaincontext", " PlainText", "longText", " Plainterm", " plainpassword", "richprotein"], "md": ["dr", "ms", "nd", "msg", "mc", "bd", "od", "me", "metadata", "del", "MD", "grad", "der", "cd", "mg", "deb", "mm", "dm", "mt", "ind", "rm", "red", "sm", "dh", "nt", "det", "e", "ld", "doc", "mb", "d", "dd", " mc", "esm", "mac", "mp", " mo", "mk", "mod", "managed", "dig", "mem", "pd", "m", "mo", "mn", "mand", "cmd", "med", "hd", "ng"], "raw": ["message", "rew", "orig", "unsigned", "n", "buf", "unknown", "valid", "draw", "available", "known", "bare", "row", "hook", "rendered", "clear", "all", "hex", " Raw", "box", "original", "sh", "stream", "bytes", "RAW", "good", "cooked", "result", "custom", "base", "extra", " RAW", "input", "clean", "value", "data", "full", "array", "random", "aw", "out", "Raw", "pack"], "hash": ["message", "json", "rh", "html", "password", "mask", "Hash", "hed", "has", "sha", "id", "ssh", "ashes", "h", "ASH", "total", "alert", "tag", "code", "hex", "key", "sh", "zh", "mac", "shadow", "hidden", "sum", "tr", "href", "result", "print", "check", "bh", "cert", "search", "height", "array", "proof", "handle", "cache", "ash"]}}
{"id1": "10445819", "id2": "13783549", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"getReader": ["newReader", "getreader", "newRead", "newStream", "newreader", "Getreader", " getStream", " getRead", "getRead", "getStream", " getreader", "GetRead", "GetStream", "GetReader"], "stream": ["buffer", "message", "style", "proc", "st", "window", "sl", "instance", "user", "open", "draw", "present", "metadata", "feed", "filter", "body", "socket", "console", "sample", "row", "iterator", "sw", "ssl", "channel", "pipe", "Stream", "resource", "wrapper", "inner", "store", "reader", "engine", "ream", "page", "sequence", "form", "cont", "trans", "input", "clean", "port", "secure", "log", "system", "stack", "chain", "data", "url", "context", "out", "list"]}}
{"id1": "6470716", "id2": "3767903", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"st": ["ist", "ust", "step", "est", "nd", "se", "stri", "tt", "ST", "stra", "St", "sw", "ost", "std", "ft", "t", "th", "sm", "ast", "stable", "rt", "store", "ld", "sts", "str", "sh", "d", "stream", "service", "sth", "www", "sta", "sn", "ste", "sty", "set", "sp", "inst", "start", "rest"], "url": ["ch", "http", "mail", "html", "ls", "addr", "host", "location", "sl", "abs", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "address", "shell", "URL", "rel", "github", "pl", "ssl", "dl", "uri", "loc", "nl", "client", "el", "browser", "gl", "ref", "null", "impl", "mount", "str", "ll", "fl", "l", "char", "www", "rect", "base", "string", "cl", "file", "domain", "web", "cert", "r", "li", "hl", "rest", "il"], "fis": [" fi", " fiss", "tiss", "tis", "efi", "xfier", "Fais", "fiss", "xfis", "fi", "f\u00eds", "Fis", "flisl", "fier", " fais", "Fiss", "fei", "efis", "fli", "xfi", "flis", "fisl", "feois", "feis", "fais", "Fos", "feier", "fliss", "uf\u00eds", "Fier", "Fi", "fois", "ufisl", "ufi", "ufiss", "tos", " fisl", "ufis", "Fois", " f\u00eds", "tais", "efiss", "ef\u00eds", "xfois"], "zis": [" ziss", " zris", "zhisin", "ozisin", "fisi", "zhis", "zris", "czits", "czis", "zIs", "ozes", "zits", "zipIs", "zipisin", "fiss", " zits", "zisa", " zisi", "zisin", "zipis", "ozisa", "zes", "zenisi", "ozis", "zos", "zipos", "zhes", "ozIs", "czisa", "zeniss", " zos", "fits", "zhIs", "zisi", " zIs", "zenris", "zenis", " zisa", "zipes", "ziss", "zipits", "ozits", "czIs", "fris"], "entry": ["field", "de", "cell", "or", "existent", "member", "se", "ent", "valid", "ie", "link", "tmp", "item", "attribute", "way", "ry", "entity", "row", "ce", "jar", "card", "element", "fr", "nt", "e", "key", "null", "be", "office", "name", "index", "inter", "char", "obj", "event", "result", "record", "form", "line", "source", "def", "log", "match", "zo", "comment", "chain", "info", "system", "sp", "Entry", "out", "enter", "word", "jo", "list", "pattern", "zip"], "count": ["ch", "buffer", "depth", "counter", "add", "cell", "core", "n", "nb", "force", "last", "ct", "read", "size", "end", "num", "ind", "t", "current", "total", "length", "nt", "acc", "call", "Count", "code", "name", "ctr", "index", "number", "char", "ount", "page", "sum", "err", "cont", "base", "batch", "check", "amount", "child", "iter", "cc", "match", "max", "comment", "found", "start", "c", "len"], "data": ["output", "buffer", "message", "text", "json", "reason", "part", "step", "block", "n", "buf", " DATA", "ata", "raw", "dat", "sample", "size", "area", "DATA", "bin", "length", "all", "done", "name", "next", "d", "number", "bytes", "good", "result", "string", "batch", "def", "mem", "source", "table", "value", "mu", "zero", "chain", "format", "out", "image", "cache"], "fos": [" fOS", "fool", "hos", "fol", "Foss", "fooss", "fOS", "fiops", "fops", "foops", "Fos", "wis", "hoss", "Fops", " foss", "hOS", "fios", "his", "foos", "foss", "Fol", "fiol", "woss", "wOS", "wos", "fioss"], "dest": ["output", "est", "nd", "member", "des", "gate", "send", "master", "dat", "transfer", "gest", "cat", "coord", "test", "desc", "pas", "std", "loc", "crit", "pipe", "bin", "foreign", "parent", "nt", "det", "comp", "done", "src", "dist", "writer", "dc", "ptr", "sum", "result", "cont", "Dest", "them", "mem", "source", "trans", "nom", "decl", "exp", "target", "comb", "origin", "out", "usr", "temp", "rest", "way"]}}
{"id1": "1122585", "id2": "14450108", "code1": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"copyImageFile": ["copyimagefile", "cpimagefile", "cpImageFile", "copyImagesFile", "copyItemImageFile", "copyItemImageHeader", "copyImageHeader", "copyimageHeader", "copyImagePhoto", "copyImagesPhoto", "cpImageHeader", "copyImagefile", "copyItemImagePhoto", "cpImagePhoto", "copyImagesfile", "cpimageHeader", "cpImagefile", "cpimageFile", "copyImagesHeader", "copyimagePhoto", "cpimagePhoto", "copyimageFile", "copyItemImagefile"], "urlString": ["UrlString", "urlRest", "uriRest", " urlChain", "uriString", " urlService", "imageString", "UrlRest", "urlstring", "urlStr", "linkStr", "linkString", "UrlChain", " urlRest", "linkRest", "uriStr", "uriChain", "linkstring", "uriService", "urlService", "imageStr", "urlChain", "UrlService", "imagestring", "uristring", "imageRest"], "filePath": ["filepath", " filepath", "FileName", "FilePATH", "givenStream", "givenpath", " FileName", "fileStream", "outputpath", "givenPATH", "FilePath", "resourcepath", "fileName", "resourcePath", " Filepath", "outputPATH", " FilePath", "resourcePATH", "filePATH", " filePATH", "resourceStream", "Filepath", " FilePATH", "outputStream", "outputPath", "givenPath", " fileName"], "destination": ["portinator", "destinator", "Destation", "terminository", " destachment", "delinated", "contension", "srcaration", "portinated", "commentacement", "destignment", "portension", "destachment", "destaration", " destignment", "contination", "destinate", "destinated", "terminaration", "terminachment", "portation", "Destension", "methodachment", "destinity", "Destination", "Destinator", "srcacement", " destinated", "continator", "destificate", "Destinate", "targetinator", "targetribution", " destacement", "portinity", "destacement", "destension", "methodination", "methodository", "identinator", " destinator", "srcificate", "identination", "identinate", "termininator", "identinated", "destository", "delination", "terminignment", "delinator", "targetinated", "methodinator", "Destinity", "commentinate", "commentination", " destribution", "combination", "combinity", "destribution", "srcinate", "terminination", " destository", " destaration", " destension", "continate", "commentificate", "destation", "srcignment", " destificate", "identension", "srcination", "portination", "srcinator", "combinator", "delribution", "targetination", "combation", " destinate"], "destination_file": ["destinator_FILE", "destination_library", "destinator_dir", "destATION_name", "destination_no", "destociation_dir", "destATION_file", "destociation_file", "destination__name", "destinator_name", "destinator_file", "destation_ile", "destination___ile", "destination____name", "destination__full", "destinator_File", "destATION____file", "destociation_ile", "destinator___file", "destination_entity", "destination_full", "destATION_entity", "destATION_no", "destociation_library", "destination____no", "destination_name", "destinator_port", "destination___file", "destination_File", "destATION____name", "destination_port", "destation_file", "destATION____no", "destination____entity", "destination_dir", "destATION____entity", "destination_table", "destinator___full", "destination__ile", "destation_name", "destination_ile", "destination____file", "destinator___name", "destinator_table", "destinator_full", "destination___name", "destination__file", "destination___full", "destinator_ile", "destination_FILE", "destinator___ile", "destation_File"], "inLine": ["inliner", "Inliner", "binliner", "inline", "binLine", "InString", "InLine", "binline", " inString", "binString", " inliner", " inline", "inString", "Inline"], "dest_name": [" dest_Name", "destnfile", " dest_names", "dest_system", "dest_NAME", "destinationName", "destopsan", "desttname", "dest_path", " dest__name", "desttsystem", "destJsize", "dest_lock", "dest_ame", "img_data", "dest_key", "ident_name", "src_file", "Dest_name", "destationnames", " dest_ame", "Dest_Name", "destationName", "Dest_san", "src_Name", "destationcall", "destationname", "destinalfile", "dest_size", "decl_file", "img_file", "destinalma", "dest_ma", " dest_filename", "dest__ame", "dest_entry", "destJNAME", "Dest_system", "dest__NAME", "destinalword", "src_filename", " dest_path", " dest__filename", "img_name", "dest_filename", "dest_data", "dest_call", "destDsan", "destJterm", "destopdescription", "Dest_description", "dest_san", " dest_NAME", " dest_lock", "destnname", "destJname", " dest_term", "destinalname", "decl_word", "destDdescription", "destDname", "dest__filename", "decl_ma", " dest_file", "ident_entry", "dest_file", "src_name", "destndescription", "destinationfile", "destopname", "dest_Name", "dest_term", "dest__Name", "img_Name", " dest__Name", " dest__NAME", "dest_names", "destinationfilename", "dest__name", "Dest_key", "destinationname", "Dest_file", "ident_word", " dest_size", " dest_call", "dest_description", "desttkey", "desttName", "decl_name", "dest_word"], "buffer": ["message", "Buffer", "binary", "text", "function", "update", "shape", "window", "password", "block", "phrase", "buf", "database", "bar", "b", "feed", "address", "raw", "variable", "FFER", "read", "sample", "row", "queue", "frame", "channel", "buff", "length", "stream", "char", "page", "sequence", "result", "base", "command", "batch", "source", "iter", "device", "table", "value", "parse", "comment", "stack", "document", "data", "memory", "append", "paste", "cache"], "bytes_read": ["bytes_send", " bytes_write", " bytes2read", " bytes_reading", "bytes_Read", "bytes_reading", " bytes_count", " bytes_Read", " bytes2readable", "bytes2read", "bytes_length", "Bytes_read", " bytes_readable", "bytes_mix", "bytes_readable", "Bytes_mix", "bytes2readable", " bytes2Read", "Bytes_write", "bytes67read", "bytes67write", "bytes_write", "bytes2reading", "bytes2Read", "bytes67mix", "bytes_count", "Bytes_send", "bytes67send", " bytes2reading", " bytes_length", "bytes2length"], "last_offset": ["last__index", "last_index", "last___position", "last__offset", "Last_page", "Last_offset", "last___Offset", "last_page", "last_name", " last_start", "Last_flag", "Last_pointer", " last_name", "last_position", "last__name", "last_Offset", "last_flag", "last__Offset", " last_index", "Last_Offset", "last_start", "last___offset", " last_Offset", "Last_position", "last___pointer", "last_pointer"], "offset": ["mask", "location", "timeout", "window", "attribute", "size", "bound", "element", "component", "inner", "error", "operation", "ace", "other", "set", "padding", "scroll", "origin", "auto", "after", "slot", "pos", "offer", "Offset", "inline", "name", "entry", "batch", "skip", "off", "append", "start", "outer", "onet", "field", "output", "pointer", "part", "prefix", "unsigned", "volume", "section", "tile", "shift", "address", "no", "reset", "iterator", "frame", "OFF", "original", "index", "offs", "amount", "table", "alias", "left", "order", "article", "seek", "step", "addr", "type", "et", "end", "associated", "length", "always", "key", "store", "alt", "next", "position", "point", "option", "pad", "empty"], "imageFile": ["imageReader", " imagefile", "pictureStream", "ImagePlace", "imageSourceFile", " imageStream", "ImageSourceFile", " imageSourceFile", "picturePlace", "messageReader", "imagefile", "messagefile", " imagePlace", "mediaFile", "photoFile", "ImageStream", "mediaSourceFile", "messageStream", "imagePlace", "Imagefile", "mediafile", "messageFile", "photoStream", "ImageFile", "photofile", "picturefile", "mediaStream", "photoReader", " imageReader", "pictureFile", "imageStream"], "url": ["http", "mail", "html", "abs", "sl", "open", "build", "bel", "link", "b", "ur", "ul", "Url", "f", "q", "gif", "address", "URL", "ml", "image", "api", "rel", "github", "re", "ssl", "dl", "uri", "nl", "resource", "up", "browser", "gl", "google", "str", "mount", "impl", "ll", "get", "l", "char", "base", "rl", "web", "r", "hl"], "parentdir": ["parentfolder", "tmpdict", "childdir", "parentdiv", "rootfolder", "Parentdir", "Parentlib", "parendir", " parentlib", "parenir", "parentdirectory", "childlib", "tmpdir", "childdiv", "parentdict", "Parentdict", "parentir", "childDir", "parentDir", "childir", " parentDir", "rootdiv", "Parentdirectory", "tmpDir", " parentdirectory", "rootdir", "ParentDir", "parentlib", "parenfolder", "tmpdirectory", "rootir", "childdirectory", "parendiv", " parentdict", "childfolder"]}}
{"id1": "14688886", "id2": "11962480", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "label": 1, "substitutes": {"populateResources": ["populatesResources", "PopureResource", "populatedFiles", "populatesFiles", "populatedResource", "populatedReferences", "popureResource", "PopulateResource", "popureFiles", "populateResource", "populatesResource", "populatesReferences", "PopulateFiles", "popureReferences", "popureResources", "populateFiles", "PopureReferences", "populatedResources", "PopureResources", "PopulateResources", "populateReferences", "PopulateReferences", "PopureFiles"], "templates": ["typles", "timples", "tctions", "memples", "Temports", "sequplates", "Temples", "tmeters", "tiles", "timporary", "temeters", "teniles", "Temmen", "filports", "tmports", "temctions", "sequeters", "memeters", "filplates", "temmen", "teters", "tples", "memables", "tenables", "filples", " temctions", "tables", "temporary", "sequples", "tmporary", "temports", "tmmen", "sequporary", "tyables", "tenctions", " temiles", "tmples", "tenplates", "temables", "tyeters", "timeters", "tmplates", "memplates", "Templates", "filmen", " temables", "tplates", "typlates", "temiles", "timplates", "temples"], "url": ["path", "http", "mail", "html", "location", "term", "sl", "n", "a", "link", "item", "handle", "b", "ur", "Url", "f", "address", "ml", "URL", "p", "rel", "row", "pl", "ssl", "uri", "dl", "nl", "resource", "browser", "gl", "ref", "e", "key", "name", "mount", "mb", "ll", "get", "l", "u", "char", "base", "entry", "string", "rect", "m", "rl", "file", "web", "res", "r", "li", "pattern"], "fileName": ["fileFamily", "FILEname", "fBody", "filenamename", "fileLoad", "Filename", "tilename", "filenamePart", "fName", "ilePath", "fileTime", "FILEName", "moduleTitle", " filePath", "urlName", "FileString", "templateString", "blockname", "ileName", "urlPath", "fileKey", "tileName", "namePart", "FILELine", "blockLoad", "resourceName", "blockTime", "filenameParent", " fileFamily", "fileString", " filename", "namename", "FileFamily", " filePart", "moduleKey", "familyLoad", "FileFull", "fPath", "familyTime", "ileCopy", "urlFamily", "templateName", "filenameName", "fileBody", "urlKey", "FileName", "ileLine", "fileParent", "ilename", "fileTitle", "fileLine", " fileTime", " fileParent", "templatePath", "FilePath", "FileBody", "resourceKey", "filePath", " fileKey", "moduleName", "blockName", " fileType", "familyname", "tileCopy", " fileBody", "fileFull", "ileFull", "fname", " fileFull", "ilePart", "resourceTitle", "FilePart", "filePart", "FileKey", "resourceType", "filename", " fileLoad", "fileType", "templatename", "FILECopy", " fileTitle", "tileLine", "fileCopy", "nameParent", "moduleType", " fileString", "familyName", "nameName"], "templateResource": [" templateEntry", "documentResource", "TemplateReference", " templateReference", "TemplateResources", "TemplateProperty", "templateRes", "documentRole", "componentRes", "resourceEntry", "TemplateResource", "resourceRes", "resourceResource", "TemplateEntry", "componentResource", "componentResources", "resourceProperty", " templateProperty", " templateRes", " templateResources", "templateEntry", "templateReference", "componentReference", "resourceRole", " templateRole", "templateProperty", "documentRes", "templateResources", "TemplateRes", "templateRole"], "is": ["ais", "im", "es", "isc", "iso", "ris", "sels", "ri", "ic", "sys", "isl", "nis", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "are", "ins", "fr", "rs", "rys", "isf", "\u00eds", "Is", "ir", "fs", "iris", "us", "ios", "sis", "in", "isi", "IS"], "strBuff": ["arrComb", "drBuffer", " strComp", "stringBas", "brBuffer", "arrbuff", " strBu", "strBas", " strbuff", "Strbuff", "strFac", "arrFac", "strbuff", " strBuffer", "brComp", "stringBuffer", "arrBuffer", "drComp", "arrBas", "stringComb", "brBuff", "StrBuffer", "strBu", "strComp", "arrBuff", "StrBuff", "drBuff", "brBu", "stringBuff", " strBas", "StrFac", "strComb", " strComb", "strBuffer", "drBu", " strFac"], "br": ["ch", "wr", "gr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "bm", "bs", "BR", "bn", "bl", "hr", "pr", "er", "fr", "bt", "Br", "cr", "bg", "bro", "bi", "next", "ctr", "vr", "mr", "tr", "bc", "sr", "lr", "bh", "kr", "ber", "r", "yr", "rb"], "str": ["gr", "dr", "ust", "text", "st", "n", "sl", "msg", "draw", "del", "p", "St", "bl", "pr", "cs", "seq", "t", "arr", "fr", "pt", "spec", "cr", "stable", "g", "name", "ctr", "STR", "sts", "tr", "obj", "txt", "err", "cont", "print", "string", "set", "sp", "chain", "cert", "s", "ocr", "res", "r", "Str", "coll", "list"], "images": ["uploads", "ims", "assets", "faces", "vs", "ms", "games", "types", "versions", "times", " pictures", "rooms", "image", "frames", "pages", "boxes", "eds", "views", "xs", "amps", "ins", "files", "pins", "raphics", "styles", "photos", "actions", "ids", "ages", "scripts", " photos", "Textures", " Images", "reports", "apps", "resources", "videos", "modules", "media", "arms", "names", "blocks", "eps", "thumbnails", "atts", "items", "ups", "Images"], "i": ["http", "it", "qi", "gi", "status", "ij", "cli", "li", "j", "my", "ini", "ui", "this", "hi", "ti", "bi", "name", "_", "def", "us", "ami", "sim", "ip", "multi", "im", "n", "ie", "me", "Exception", "id", "ci", "ii", "index", "get", "u", "ei", "m", "xi", "pi", "x", "phi", "ai", "p", "y", "io", "mi", "gu", "ki", "v", "key", "si", "I", "mu", "di", "info", "ix"], "img": ["im", "html", "j", "jpg", "amp", "buf", "a", "pkg", "tmp", "gif", "f", "pg", "iam", "medium", "aug", "p", "small", "mg", "av", "bl", "att", "png", "fig", "fm", "bg", "g", "src", "gd", "mp", "obj", "md", "mk", "anim", "imp", "gm", "m", "file", "ami", "pic", "ij", "div", "r", "Image", "li", "image"], "imgProperty": [" tmpProp", "imageImage", " imgProp", "imageProperty", " imgImage", "imgProp", " imgPro", "imageProp", " tmpPro", "imgImage", " tmpImage", "imgPro", " tmpProperty", "imagePro"]}}
{"id1": "1769771", "id2": "6371589", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" CopyLine", "CopyFile", "CopyLine", " copyFiles", "CopyStream", "CopyFiles", " copyLine", " copyStream", "copyLine", "copyStream", " CopyStream", " CopyFiles", " CopyFile", "copyFiles"], "in": ["IN", "on", "din", "gin", "init", "rin", "ini", "is", "ic", "b", "old", "en", "inc", "io", "from", "mm", "ind", "ins", "el", "up", "bin", "inner", "isin", "l", "r", "In", "input", "source", "i", "inn", " input", "inf", "cin"], "out": ["output", "update", "n", "Out", "it", "msg", "b", "p", "o", "to", "os", "io", "help", "ex", "outs", "t", "op", "up", "v", "ou", "serv", "nt", "at", "w", "l", "net", "err", "OUT", "gt", "file", "log", "po", "ot", "s", "res", "c"], "inChannel": [" inCommand", "insideCategory", "intCommand", "sinButton", " inButton", "dinchannel", "inConnection", " inConnection", "cinChannel", "cinRoom", "inScope", "insideChannel", "sinChannel", "ainScope", "inchannel", "InChannel", "inCategory", " inchannel", " inScope", "inChan", "Inchannel", "inRoom", " inChan", "dinChan", "outchannel", "ainClient", " inRoom", "sinCommand", "innButton", "ainChannel", "inCommand", "innClient", "insideScope", "insideClient", "intChannel", "sinClient", "innCase", "innChannel", "outChan", "inCase", "cinCommand", "dinConnection", "dinChannel", "ainCategory", " inCategory", "intChan", "intchannel", "outConnection", "sinRoom", "InChan", " inCase", "sinCase", "InCommand", "inButton", " inClient", "inClient"], "outChannel": ["neSection", "inCh", "outCh", "blockMany", " outCh", "neChan", "aosChan", "blockChannel", "aosMember", "outputManager", "parentChan", "outManager", "blockGate", "inchannel", "blockChan", "inMember", " outchannel", " outGate", "parentGate", "inChan", "aosSection", "parentMany", "outMember", "outGate", "outchannel", "parentChannel", "outputchannel", "inSection", "cnManager", "neMember", "outMany", "outputChan", "cnChan", " outChan", "outChan", "cnChannel", "outputChannel", " outMany", "outSection", " outManager", "outputCh", "neChannel", "aosChannel"]}}
{"id1": "18891988", "id2": "3430784", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"getFile": ["selectfile", "getFilename", "createFilename", "GetFile", "selectFilename", "createString", "GetString", "createFile", "getfile", "createfile", "GetFilename", "getString", "selectFile", "Getfile", "selectString"], "serviceName": [" serviceCode", "libraryName", "ServiceFamily", "libraryType", "serverCode", "ServiceType", "serviceType", "serverType", "libraryFamily", "serviceCode", "serviceNames", "ServiceName", " serviceFamily", "ServiceNames", "ServiceCode", "libraryNames", "serviceFamily", "serverName", " serviceType", " serviceNames"], "wsdlLocation": ["wslLocation", "wlLoc", "awsdlURL", "wslLoc", "wssdFolder", "wslFolder", "wssdlocation", "awsdlocation", "wsdLoc", "wsDLlocation", "wsdllocation", "wsDLPath", "wsdlURL", "wsdLocation", "wsDLLoc", "wsDLFolder", "wsollocation", "wlFolder", "awsdllocation", "wsdURL", "wdlLocation", "wlPath", "wsolLoc", "awsdlLocation", "awsdlLoc", "wsolLocation", "wsDLURL", "wssdPath", "wssdLocation", "awsolLocation", "wsdlPath", "wsdlocation", "wsDLLocation", "wsdlFolder", "awsdURL", "wdlLoc", "awsolURL", "awsdLocation", "awsollocation", "wdlFolder", "wdlPath", "wlLocation", "wslPath", "wsdlLoc", "awsdLoc", "wssdLoc", "wsolURL", "wssdURL", "awsolLoc"], "endpoint": ["endword", "bindport", "startPoint", "idpoints", "bindpoints", "bindpoint", "endPoint", "Endpoint", "startpoints", "beginPoint", " endpoints", "beginword", "bindPoint", " endline", "idPoint", " endport", "Endpoints", "EndPoint", "beginpoint", "startword", "Endport", "startpoint", "idpoint", "Endword", "startline", "endport", "endline", " endPoint", "endpoints", "beginpoints", "idline"], "fileLocation": ["FileLoc", "Filelocation", "FileLocation", "fileLoc", "filePosition", " fileLoc", " filelocation", "documentLoc", " filePosition", "documentPosition", "filelocation", "FilePosition", "documentLocation", "documentlocation"], "tempDir": ["tmpUrl", "TempUrl", "TempPath", "TempDir", "tempDirectory", "tmpDirectory", "tmpdir", "tmpPath", " tempFolder", "tmpFolder", "tempPath", " tempdir", " tempUrl", "tempFolder", "TempDirectory", "TempFolder", " tempDirectory", "tmpDir", "tempUrl", "Tempdir", " tempPath", "tempdir"], "url": ["http", "mail", "ls", "window", "location", "sl", "open", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "socket", "URL", "rel", "sur", "pl", "re", "ssl", "uri", "dl", "loc", "nl", "up", "browser", "gl", "cr", "str", "mount", "ll", "cp", "service", "l", "char", "un", "conn", "base", "m", "job", "ctrl", "web", "https", "cert", "r", "li", "github", "il"], "WSDLFile": ["WSDLLFilename", "WSDLString", "WSDQLFile", "WIDDLString", "WHDLfile", "WIDDLType", "WSDDLString", "WIDLFile", "WHDDLFile", "WSDDLFILE", "WNDLFILE", "WSDDLType", "WHDDLfile", "WSDLLString", "WSDLLFILE", "WIDDLFile", "WNDLFile", "WSDDLFile", "WNDDLfile", "WSDLLType", "WHDDLFILE", "WSDELfile", "WSDLSFile", "WNDLFilename", "WIDLType", "WIDLString", "WSDQLfile", "WIDLfile", "WNDDLFILE", "WSDLLfile", "WSDMLfile", "WSDQLFILE", "WSDMLFILE", "WSDLLFile", "WSDMLFile", "WSDELFILE", "WNDLfile", "WSDLSType", "WSDLSString", "WSDLFILE", "WSDLType", "WSDLSfile", "WSDDLfile", "WHDLFILE", "WSDLFilename", "WSDLfile", "WSDELFile", "WNDDLFilename", "WSDDLFilename", "WHDLFile", "WIDDLfile", "WNDDLFile", "WSDELFilename"], "tmpWSDLFile": ["tmpWSDDLFiles", "tmpWSDlFile", "tmpWSDLDFilename", "tmpWIDDLFILE", "tmpWNDDLFilename", "tmpWSDLDFILE", "tmpWIDDLfile", "tmpWSDLLFilename", "tmpWSDLLFiles", "tmpWNDDLfile", "tmpWNDDLFiles", "tmpWSDlFiles", "tmpWSDlfile", "tmpWSDLFiles", "tmpWNDDLFile", "tmpWNDLFile", "tmpWSDlFilename", "tmpWIDDLFilename", "tmpWSDLLFILE", "tmpWNDLFiles", "tmpWSDLDFile", "tmpWSDDLFILE", "tmpWSDLDfile", "tmpWIDLfile", "tmpWSDLLfile", "tmpWIDDLFile", "tmpWSDLFilename", "tmpWSDDLFilename", "tmpWIDLFILE", "tmpWSDDLFile", "tmpWNDLFilename", "tmpWIDLFilename", "tmpWNDLfile", "tmpWSDLLFile", "tmpWIDLFile", "tmpWSDLFILE", "tmpWSDLfile", "tmpWSDDLfile"], "inputFile": ["inputPlace", "InputStream", "inputPath", "indexFILE", "indexStream", "intFiles", "inputSourceFile", "tmpFILE", "inputFILE", "outputFILE", "clientPath", "outputFile", "clientFiles", " inputfile", "indexfile", "errorFile", "tmpSourceFile", " inputPlace", "interfacePlace", "errorfile", "outputfile", "Inputfile", " inputFILE", "inputStream", "interfaceSourceFile", "InputFiles", "tmpStream", "clientFile", "intFILE", "inputFiles", "infile", "inputDo", "clientFILE", " inputFiles", "intfile", "errorFILE", " inputDo", "intFile", "tmpPlace", "inDo", "indexFile", "inFile", "interfaceFile", "inPath", " inputPath", "InputFile", "interfacefile", "tmpfile", " inputSourceFile", "InputPath", "InputDo", "errorStream", "InputFILE", "outputStream", "inputfile"], "tmpFile": ["tmpFILE", "inputFILE", "empFilename", "tmpFiles", "mpFile", " tmpPath", "empFILE", "mpfile", " tmpfile", "tmpPath", "tempFiles", "tempFILE", "tempPath", "mpFiles", "inputFilename", "empFile", "mpPath", "tempFile", "tempFilename", " tmpFiles", "empfile", "tmpFilename", "tmpfile", "tempfile", "inputfile"], "in": ["ch", "IN", "din", "init", "ln", "n", "it", "rin", "ri", "ai", "is", "ic", "ini", "sin", "ain", "id", "o", "inv", "en", "inc", "io", "from", "mi", "ind", "ins", "t", "client", "ar", "bin", "inner", "stream", "isin", "r", "In", "cont", "conn", "input", "source", "file", "inn", "inf", "c", "cin"], "out": ["output", "ch", "buffer", "on", "by", "n", "auto", "Out", "sys", "tmp", "connection", "can", "pool", "o", "inv", "to", "os", "en", "aos", "io", "OU", "ex", "outs", "t", "client", "conv", "ou", "lock", "cm", "all", "write", "at", "null", "group", "writer", "this", "ao", "w", "obj", "net", "conn", "OUT", "conf", "ne", "file", "log", "oss", "co", "we", "outer", "c", "cache"], "con": ["ch", "fn", "nc", "cos", "connect", "Con", "cone", "const", "cur", "ln", "cal", "exc", "mc", "connection", "acon", "ain", "can", "ws", "num", "re", "conv", "login", "win", "fc", "cm", "tc", "cp", "cons", "sec", "un", "conn", "cn", "CON", "ran", "func", "co", "cf", "com", "conf", "soc", "Conn", "c", "cin"], "fileLength": ["objectSize", "objectFontSize", "channelSize", "objectDuration", "FILESize", "channelLength", "ileLen", "FILELength", "fileDuration", "ileLength", " fileDuration", "fileSize", "FILEDuration", " fileLen", " fileSize", "FILELen", " fileFontSize", "fileLen", "ileDuration", "channelDuration", "fileFontSize", "channelFontSize", "ileSize", "objectLength"], "channelIn": ["channelIN", "chanIn", "consoleIn", "ChannelIn", "clientSet", "channelSet", "Channelin", "consoleedIn", "clientIn", "clientOut", "ChannelIN", "ChannelSet", " channeledIn", "ChanneledIn", "channeledIn", "ChannelOut", "channelin", "consoleOut", "consoleIN", "chanSet", "clientin", "chanIN", "chanOut", "clientIN", " channelIN", " channelin"], "channelOut": ["chanIn", "consoleIn", "ChannelIn", "channelOUT", " channelConn", "ChannelConn", "courseout", "courseOut", "courseOUT", "courseIn", "chanout", "chanConn", "ChannelOut", "consoleOUT", "channelout", "Channelout", "consoleout", "consoleOut", "chanOut", " channelout", "channelConn", " channelOUT", "ChannelOUT"], "tmpDocument": ["tmpDoc", "tpFile", "npDocument", "mkdocument", "npFile", " tmpDocuments", "mpDoc", "npMedia", "tpDocument", "tempDoc", "cpDocument", "tmDoc", "tpMedia", " tmpDoc", "tmDocument", " tmpMedia", "tmpDocuments", "cpDoc", "cpdocument", "tempdocument", " tmpdocument", "mpDocument", "mkDocument", "npDocuments", "mkDoc", "tmpdocument", "tpDocuments", "tmpMedia", "tmdocument", "mpdocument", "tempDocument"], "nl1": ["ln01", "rn6", "NL0", "pelOne", "sol0", "sol1", "nl01", "sol2", "nrOne", "nelOne", "rn3", "nl2", "ln2", "nl3", "pel1", "nel1", "lnOne", "ln6", "nel3", "nl6", "nlOne", "nr1", "sol9", "nr01", "ln3", "nel6", "nl0", "rn1", "pel01", "NL2", "nl9", "ln0", "ln9", "NL1", "ln1", "NL9", "rnOne"], "i": ["multi", "ims", "ms", "x", "j", "n", "init", "it", "ai", "a", "is", "ic", "ini", "ui", "ie", "me", "ri", "id", "y", "o", "io", "mi", "ci", "qi", "ii", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "span", "u", "k", "m", "xi", "cli", "us", "mu", "ami", "ori", "di", "sim", "pi", "info", "ij", "ip", "li", "\u0438", "ix"], "node1": ["Node2", "ode001", "nOne", "node91", "ode2", "component0", "node001", "NodeOne", "component2", "Node1", "layer91", "layer0", " node2", "layerOne", "ode1", "ode0", " node91", "node0", "Node001", " node0", " node001", "componentOne", " nodeOne", "layer1", "n1", "n0", "nodeOne", "node2", "n91", "Node0", "component1"], "tmpOut": ["tmpObj", " tmpIs", "tmpIs", "mpOut", "empIs", "mpout", "TempOUT", "npIn", "mpObj", "cmpIn", "cmpout", "TempIn", "tmpOUT", " tmpObj", "tempout", " tmpIn", "empout", "npout", "mpIn", " tmpOUT", "cmpOut", "TempObj", "tmpout", "tempObj", "tmpIn", "npObj", "tempIn", "tempOUT", "tempIs", "TempOut", "tempOut", "empOut", " tmpout", "npOut"], "retVal": ["retValue", "returnVal", "returnValue", "returnTrue", "returnval", "retval", "RetTrue", "RetValue", "Retval", "retTrue", " retValue", " retval", " retTrue", "RetVal"]}}
{"id1": "20426057", "id2": "16825994", "code1": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"createKeyStore": [" createTruststore", "createDefaultStore", "createDefaultStorage", "createCertStore", " createKeyStorage", " createKeyChain", "createKeystore", "createTruststore", "createKeyChain", "createTrustStore", " createTrustStore", "createDefaultstore", "createKeyStorage", "createTrustChain", " createTrustStorage", "createTrustStorage", "createCertStorage", " createTrustChain", "createCertstore", "createCertChain", "createDefaultChain", " createKeystore"], "url": ["path", "http", "mail", "html", "ls", "location", "addr", "add", "abs", "sl", "org", "user", "build", "link", "ur", "Url", "ul", "address", "q", "URL", "id", "util", "github", "au", "ssl", "uri", "dl", "loc", "nl", " URL", "el", "server", "email", "gl", "ref", "uu", "store", "ld", "str", "name", "xml", "mount", "ll", "upload", "l", "u", "char", "un", "rect", "string", "lr", "file", "log", "domain", "ud", "job", "web", "https", "cert", "context", "host", "image", "rest", "list", "pattern"], "password": ["message", "expression", " Password", "description", "words", "prefix", "phrase", "hello", "user", "another", "database", "attribute", "property", "secret", "address", "token", "reset", "auth", "power", "Password", "security", "email", "pass", "PASS", "key", "store", "sword", "shadow", "username", "crypt", "directory", "command", "project", "padding", "hash", "language", "device", "stroke", "comment", "wordpress", "provided", "remember", "word", "pattern"], "keystore": ["Keystore", "linkStore", " keyore", "printcase", " keycase", " keyStore", "Keystorage", " keystorage", "keyStore", "keycase", "keytool", "Keyore", " keybase", "kcache", "ekstore", "linkserver", "keyore", "keychain", "keystorage", "ktool", "printchain", "linkstorage", "KeyStore", "printstore", "Keychain", "Keycache", "linkcase", "keyserver", " keyserver", "Keybase", "linkore", "kbase", "linkchain", "keycache", "kstore", "linkstore", " keycache", "ekstorage", "ekchain", "kStore", "printstorage", "keybase", " keytool", "Keyserver", "ekStore", "Keytool", " keychain"]}}
{"id1": "20128728", "id2": "13783549", "code1": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopFile", "Copfile", "CopResource", "copyResource", " cpResource", " cpfile", "CopFiles", " cpFiles", " CopyResource", " Copyfile", " CopyFiles", "copyFiles", " CopyFile", "copyfile", " cpFile"], "src": ["ser", "st", "sl", "init", "sys", "rx", "via", "bs", "sc", "rc", "sel", "urus", "ins", "Source", "rs", "js", "syn", "rt", "req", "ctr", "dest", "upload", "txt", "sec", "sit", "sr", "source", "input", "rl", "ipl", "sb", "inst", "sv", "usc", "in", "start", "urg", "usr", "sf", "sq", "cur"], "dst": [" ddest", "pnd", "Dnd", "sest", "Dost", " dnd", "ddest", " dost", "Ddest", "hst", "Dst", "pdest", "pst", "hdest", "dest", "pest", "snd", "dnd", "Dest", "sdest", "dost", "hnd", "sst", "host"], "inChannel": ["intListener", "vinConnection", " inCommand", "orChan", " inButton", "inConnection", " inConnection", "vinChannel", "cinConnection", "cinChannel", "itByte", "itListener", "inchannel", "InChannel", "InConnection", "innerConnection", "INChannel", " inPanel", " inchannel", "inChan", " inStream", "inByte", " inListener", "Inchannel", "innerChan", "intChain", "INConnection", " inChan", "outchannel", "inChain", "inStream", "itChannel", "inCommand", "vinPanel", "cinPanel", "vinButton", "orStream", "netChannel", "INChan", "inListener", "netPanel", "intChannel", "cinButton", "orChannel", "inPanel", " inByte", "orCommand", " inChain", "innerPanel", "outChan", "intByte", "InStream", "outConnection", "INPanel", "outStream", "netConnection", "inButton", "outCommand", "itChain", "netChan", "innerChannel"], "outChannel": ["outCh", "OUTMachine", "OutChan", " outCh", "outMachine", "OutChannel", "atChannel", " outchannel", "conChannel", "inChan", "OutCh", "atButton", "outClient", " outConsole", "outchannel", "OUTChannel", "kChannel", "outputchannel", "conMachine", "kButton", "inSection", "atChan", "OUTSection", "conSection", " outButton", "outputChan", "kConsole", "inMachine", "outButton", " outChan", "outChan", "OutClient", "atConsole", "outputChannel", " outClient", "Outchannel", "OUTChan", "outSection", "outputCh", "conChan", "outConsole", "outputClient", "kChan"]}}
{"id1": "13024538", "id2": "19784131", "code1": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"getHash": ["getSum", "GetSum", " getKey", " getSum", " gethash", "gethash", "createHash", "GetKey", "createKey", "createSum", "GetHash", "getKey", "Gethash", "createhash"], "uri": ["path", "message", "http", "html", "description", "password", "uni", "ri", "msg", "link", "ui", "ur", "requ", "address", "iu", "q", "su", "via", "wiki", "dir", "io", "subject", "qi", " ur", "resource", "filename", " URI", "ou", "uu", "course", "this", "du", "name", "har", "unit", "URI", "u", "remote", "source", "file", "url"], "mDigest": ["mDefake", "mdigests", "mDests", " mDiger", "mDester", "mdigUse", "hdiget", "mDer", "hdigester", "mDesignests", " mDse", "mDigse", " mDer", "hDigests", "mDiget", "mDesignester", "mDigake", "mdigester", "mDigester", "mModake", "mDet", "mDigUse", "mDefest", "mCritester", "hDigest", "hDiget", "mDse", "mdiget", "mCritUse", " mDigse", "mdigest", "hdigest", "mModer", "hDigester", "mDesignet", "dDigUse", "mDesignest", "mDake", " mDigake", "ddigest", "mDigests", "hdigests", "ddigester", "mCritest", "mDiger", " mDake", "mModest", " mDest", "mDefse", "dDigest", "ddigUse", "mDest", "dDigester", "mModse", "mDefer"], "d": ["db", "nd", "j", "n", " D", "sd", "des", "bd", "b", "p", "dat", "ds", "cd", "h", "dm", "ed", "ind", "t", "with", "v", "dh", "D", "dot", "done", "g", "dist", "ld", "da", "dd", "dim", "dec", "l", "td", "md", "dict", "dig", "pd", "def", "m", "df", "s", "data", "diff", "c", "de"], "hash": ["output", "buffer", "message", "html", "shape", "password", "window", "block", "Hash", "hz", "now", "user", "shift", "build", "header", "used", "bar", "echo", "filter", "address", "ssh", "h", "reset", "test", "oh", "map", "total", "transform", "tag", "square", "always", "summary", "ah", "hex", "esh", "key", "sh", "dump", "shadow", "sum", "print", "check", "archive", "bh", "search", "memory", "array", "random", "host", "report", "cache", "ash"], "i": ["multi", "ims", "im", "ms", "zi", "x", "init", "j", "phi", "it", "my", "ini", "ai", "is", "ic", "a", "ui", "ski", "ie", "ri", "q", "y", "fi", "io", "ci", "gu", "ind", "mi", "ex", "qi", "ii", "v", "gi", "hi", "ti", "ji", "bi", "index", "si", "I", "span", "u", "err", "ei", "yi", "point", "m", "xi", "us", "cli", "di", "sim", "pi", "in", "ip", "li", "\u0438", "ix"]}}
{"id1": "822452", "id2": "838844", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "19307120", "id2": "21827619", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"sendPost": [" sendPOST", "doPost", "sendpost", "postPost", "sendPOST", " sendpost", "postText", "postpost", "doPOST", "postPOST", "doText", "dopost", " sendText", "sendText"], "url": ["path", "http", "mail", "ls", "location", "addr", "term", "sl", "ret", "build", "link", "ur", "Url", "ul", "address", "q", "URL", "pl", "ssl", "uri", "dl", "nl", "loc", "ref", "call", "str", "mount", "ll", "l", "u", "base", "string", "file", "log", "web", "https", "host", "pp"], "param": ["proc", "prom", "password", "ram", "prefix", "model", "term", "block", "config", "amp", "cal", "rem", "property", "params", "p", "prop", "row", "mm", "dem", "Param", "argument", "par", "tag", "pass", "key", "name", "post", "aram", "command", "mem", "project", "input", "string", "m", "meter", "padding", "option", "comment", "sp", "start", "conf", "commit"], "result": ["output", "buffer", "message", "reason", "description", "term", "cur", "valid", "ret", "response", "manager", "product", "p", "complete", "test", "true", "default", "answer", "feature", "current", "wrapper", "continue", "confirmed", "code", "request", "r", "sum", "command", "string", "status", "date", "value", "match", "comment", "results", "chain", "query", "data", "success", "memory", "found", "res", "diff", "temp", "report", "Result"], "httpurl": ["webconn", "httpsurl", "hconn", "webUrl", "webURL", "hUrl", "httpURL", "weburl", "workURL", "httpsURL", "workurl", " httpURL", "hURL", " httpUrl", "httpconn", "httpUrl", "workUrl", "httpsconn", "workconn", "httpsUrl", " httpconn", "hurl"], "httpConn": ["Httpconn", "hconn", "procConn", "HttpConn", "procObj", "httpCon", "httpCod", "httpConnection", "ttpObj", "procCod", "copCod", "hConnect", " httpCon", "httpsConnection", "copConn", "procCon", "httpsCon", "httpConnect", "copconn", "httpsConn", " httpConnection", "procConnection", "hoverConnection", "hoverconn", " httpCod", "hoverConn", "httpsConnect", "ttpCon", "HttpConnect", "ttpConn", "httpconn", "HttpCon", "httpsconn", "ttpConnection", "hoverConnect", " httpObj", "copCon", "hConn", "procconn", "ttpconn", "httpObj", " httpconn", "hConnection", " httpConnect"], "out": ["output", "ch", "cos", "timeout", "by", "n", "auto", "Out", "it", "init", "sys", "put", "flush", "p", "pretty", "o", "aos", "to", "os", "io", "OU", "ex", "outs", "conv", "up", "v", "ou", "nt", "all", "write", "inner", "writer", "w", "screen", "obj", "net", "print", "OUT", "check", "set", "oss", "co", "cmd", "outer"], "in": ["IN", "on", "per", "din", "gin", "by", "init", "se", "it", "oin", "rin", "ri", "is", "ic", "read", "en", "inc", "from", "mi", "re", "ind", "al", "ins", "er", "ma", "el", "bin", "inner", "reader", "isin", "In", "input", "iter", "i", "mn", " din", "inn", "inf", "cin"], "line": ["field", "message", "text", "cell", "lin", "block", "phrase", "ln", "se", "header", "eline", "link", "piece", "lane", "body", "row", "frame", "liner", "email", "continue", "le", "e", "code", "inline", "ine", "rule", "LINE", "ice", "l", "online", "page", "sequence", "record", "pe", "entry", "string", "print", "point", "iter", "port", "file", "stroke", "log", "comment", "chain", "lined", "ip", "Line"]}}
{"id1": "12106167", "id2": "22875895", "code1": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"init": ["load", "update", "ls", " help", "config", "properties", "Init", " Init", " merge", "loader", "local", "late", "default", "register", "run", "release", "home", " startup", "dump", "panic", "set", " setup", "construct", "info", "start", " deploy"], "lng": [" lang", " lmb", "Lbl", "lgn", "lbl", "lang", "lmb", "olgn", "llang", "leng", "olang", " leng", "Leng", "Lng", "llong", "Lang", "olong", "llbl", "Lgn", "lleng", " lbl", "Lmb", " lgn", "llmb", "llng", "olng"], "toLoad": ["toload", "toLink", "etoLoad", "toFind", " toLink", "doLink", "pleaseload", "pleaseLink", "TOLink", "etoload", " toFind", "doFind", "etoLink", "pleaseLoad", "pleaseUse", "doLoad", "TOLoad", "TOUse", "toUse", "TOload", " toload", "doload", "etoFind", " toUse"], "url": ["path", "buffer", "out", "http", "load", "db", "ls", "or", "sl", "open", "ret", "link", "ur", "ul", "Url", "ml", "q", "ob", "URL", "id", "loader", "rel", "util", "row", "ssl", "uri", "dl", "nl", "channel", "resource", "browser", "gl", "ref", "fail", "null", "impl", "str", "xml", "mount", "ll", "external", "alt", "get", "l", "err", "result", "kl", "entry", "batch", "cl", "rl", "file", "job", "sb", "web", "cert", "full", "res", "r", "hl", "list", "il", "len"]}}
{"id1": "19910627", "id2": "14617444", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getData": ["getResponse", " getResponse", "getDATA", "updatedata", "exportData", " getdata", "exportdata", " getDATA", "exportResponse", "updateData", "updateDATA", "exportDATA", "updateResponse", "getdata"], "httpclient": ["Httpparent", "httpscell", " httpcell", "httpconfig", "httpconnection", "httpcell", "Httpclient", "httpsClient", "httpsconfig", "socketclient", "HttpClient", "socketconfig", "socketcell", "socketClient", "httpparent", "httpsparent", "httpsconnection", "httpClient", " httpClient", "ttpclient", "ttpparent", "ttpconnection", " httpconfig", "Httpconnection", "ttpClient", "httpsclient"], "get": ["http", "patch", "add", "init", "open", "force", "gets", "build", "put", "see", "send", "body", "make", "read", "create", "execute", "use", "like", "give", "op", "current", "require", "call", "request", "delete", "g", "pre", "need", "name", "pull", "post", "service", "Get", "got", "check", "GET", "set", "select", "show", "parse", "find", "query", "ge", "start", "handle", "play", "exec", "cache"], "response": ["output", "ve", "message", "application", "function", "json", "description", "block", "open", "example", "connection", "onse", "see", "body", "console", "re", "respond", "answer", "pos", "resp", "resource", "yes", "still", "page", "sequence", "result", "Response", "remote", "entry", "that", "object", "status", "reply", "document", "given", "success", "trace", "res", "successful", "report"], "entity": ["orm", "message", "json", "ity", "model", "voice", "instance", "ent", "type", "detail", "em", "person", "ce", "icon", "resource", "el", "email", "ITY", "component", "le", "e", "eric", "name", "unit", "Entity", "quote", "obj", "event", "result", "pe", "line", "activity", "entry", "details", "object", "comment", "document", "query", "info", "image"], "instream": [" inpod", "Instream", "excase", "outpod", " incase", "inputstream", "inconsole", "inspod", "instack", "instore", "fromcase", " inconsole", "inputconsole", "outconsole", " inStream", "fromstream", "inputproc", "inputStream", " incomplete", "infield", "inStream", "inproc", "incomplete", "outstream", "fromstack", "inpod", "insfield", " inproc", " instack", "outproc", "fromconsole", " infield", "outcomplete", "insStream", "Incomplete", "insstream", "exstack", "outfield", "InStream", "exstream", "outStream", "outstore", " instore", "Instore", "exconsole", "incase"], "responseMessage": ["ResponseValue", " responseValue", " responseText", "responseValue", " responsemessage", "answerMsg", "answerMessage", "ResponseMsg", " responseString", "answerString", "Responsemessage", "ResponseText", "resMsg", " responseMsg", "responseMsg", "responseString", "responsemessage", "ResponseMessage", "resmessage", "responseText", "answerValue", "ResponseString", "resMessage", "resText"]}}
{"id1": "2521141", "id2": "20190303", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["edit", "load", "close", "replace", "save", "sync", "link", "move", "cut", "crop", "transfer", "export", "download", "create", "clip", "io", "slice", "delete", "write", "cop", "cp", "share", "get", "upload", "Copy", "set", "source", "drop", "archive", "file", "select", "clone", "paste", "remove", "insert", "opy", "ate", "zip"], "from_name": [" from_part", " from_no", "from_resource", " from_names", " from_info", "fromamekey", "fromkcase", "from_names", "fromkName", "fromkname", " from_filename", " from_resource", "fromkpart", "from_filename", "fromameName", "from_info", "fromamename", "fromamefilename", " from_case", " from_Name", "from_no", "from_case", "from_key", " from_key", "from_part", "from_Name"], "to_name": ["to7name", " to_nm", "to_new", "to_get", "from_new", "from_get", "eto_Name", "tolyfile", "eto_word", "toNamefile", "tolynm", "to_number", "tolynumber", "to7file", "toNamenew", "toNameget", " to_number", "to7new", "toNamename", "to_nm", "to_word", "to_Name", "to7get", "tolyname", "eto_name"], "from_file": ["or_name", "or_File", " from_type", "or_run", " from_node", "from_resource", "from_dir", "fromlynode", "from_File", "fromsfile", "fromsname", "from_type", " from_File", "from_time", " from_resource", "from_port", "fromlyfile", "or_file", "fromlyFile", "fromsdir", "fromlyresource", " from_time", "from_do", "from_node", " from_do", "to_dir", "from_run", " from_port"], "to_file": ["to_block", "to_local", "that_file", "toJblock", "to_create", " to_create", "to_element", " to_block", "to_port", "that_tree", " to_local", "TO_port", "to_drop", "toJfile", "from_dir", "to_FILE", "that_File", " to_drop", "that_link", "from_type", "to_base", " to_dir", "TO_FILE", "TO_files", "to_type", "to_link", "toJdrop", "to_File", " to_base", "toJFile", " to_run", "TO_file", "to_files", " to_File", "to_tree", "TO_name", "TO_element", "to_run", "to_dir"], "parent": ["path", "owner", "part", "top", "shape", "per", "parents", "timeout", "prefix", "block", "man", "my", "instance", "user", "peer", "tar", "percent", "params", "holder", "master", "root", "p", "id", "pool", "paren", "Parent", "folder", "test", "desc", "default", "pid", "pa", "global", "ma", "client", "up", "server", "par", "spec", "cmp", "relative", "tree", "where", "null", "home", "rule", "name", "prop", "unit", "position", "mother", "family", "page", "event", "directory", "pixel", "form", "remote", "base", "source", "child", "point", "def", "port", "file", "comment", "chain", "sp", "ip", "temp"], "dir": ["path", "dr", "self", "db", "part", "addr", "vol", "cond", "init", "rec", "del", "rel", "wd", "cd", "folder", "local", "ind", "dep", "red", "loc", "det", "dist", "module", "DIR", "str", "dd", "d", "dim", "tr", "good", "md", "ir", "directory", "cont", "mod", "Dir", "dict", "def", "iter", "file", "di", "sp", "div", "fd", "cmd", "coll", "cur"], "from": ["style", "on", "con", "st", "window", "or", "vol", "by", "term", "se", "init", "ent", "user", "orig", "false", "com", "ie", "normal", "From", "and", "so", "link", "old", "no", "reset", "bound", "en", "local", "re", "io", "pos", "fr", "with", "client", "back", "inner", "store", "error", "fun", "stream", "form", "before", "base", "entry", "check", "source", "set", "ra", "file", "func", "query", "empty", "in", "start", "out", "left"], "to": ["output", "on", "top", "or", "eto", "by", "auto", "te", "ato", "tt", "so", "b", "into", "sys", "toc", "two", "too", "tto", "ta", "token", "o", "no", "pretty", "can", "t", "op", "client", "total", "ma", "will", "nt", "e", "stable", "null", "must", "ts", "go", "please", "base", "tty", "that", "ne", "table", "po", "co", "pi", "target", "TO", "To", "out"], "buffer": ["message", "Buffer", "binary", "function", "window", "password", "block", "phrase", "buf", "template", "button", "database", "bar", "available", "attribute", "variable", "character", "sample", "row", "queue", "frame", "buff", "char", "page", "sequence", "event", "command", "batch", "base", "entry", "iter", "table", "stroke", "stack", "document", "memory", "append", "paste", "word", "temp", "cache"], "bytes_read": ["bytes__Read", "bytes_write", " bytes2range", "words_len", "wordsyncread", "Bytes_write", "bytesyncreport", "words_report", "bytes2Read", "wordsyncreport", "words_read", "bytes_run", " bytes_write", "bytes__read", " bytes2read", "bytes_range", "wordsynclen", "bytes2write", "bytes_report", "bytes_Read", "bytes__range", "bytes2range", "bytesyncwrite", "words_write", "wordsyncwrite", "bytes_len", " bytes_Read", " bytes2write", " bytes_range", "Bytes_run", "bytes2read", "bytes__write", "bytesyncread", " bytes2Read", "bytesynclen", "Bytes_read"]}}
{"id1": "11968328", "id2": "14865947", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getMD5": [" getMDState", " calculateMD2", " getMT2", " calculateMD5", " getMD1", " getMD2", " calculatemd1", " getmdState", " getmd1", " getmd2", " getHash5", " getHashState", " getMT1", " calculatemd2", " calculateMDState", " getMT5", " getmd5", " getMTState", " calculateMD1", " calculatemdState", " calculatemd5", " getHash2", " getHash1"], "_pwd": ["_wppriv", "_passwd", "_passfx", " _pw", "_vpwd", "_spfx", " _sppriv", " _passwd", "_cw", "_pwords", " _passwords", "_vppriv", "_spwd", "_cfx", " _ppriv", "_spwords", "_pword", "_wpwd", "_passw", " _spword", "_pw", " _passfx", " _spw", "_passwords", " _pwords", "_spw", " _pword", "_pfx", "_spword", "_ppriv", "_wpword", " _spwd", "_sppriv", "_vpword", "_cwords", " _pfx", "_vpw", "_cwd", " _passw", "_wpw"], "md": ["bf", "db", "pm", "mail", "ms", "add", "nd", "sd", "msg", "mc", "tmp", "od", "bd", "and", "del", "MD", "der", "cd", "mg", "h", "dir", "mm", "dm", "mt", "ind", "down", "red", "rm", "sm", "dh", "det", "ld", "mb", "d", "dd", " Md", "mp", "mk", "mod", "dig", "pd", "m", "df", "mn", "mand", "cmd", "man", "hd", "ng", "de"]}}
{"id1": "62362", "id2": "16215393", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["consverting", "converted", "converts", "Conversion", "converting", "compversion", "CONverting", "conprocess", "compprocess", "CONversion", "consversion", "consVERT", "unverted", "compverts", "CONfer", "ConVERT", "CONVERT", "Converting", "unprocess", "unvert", "unversion", "Converted", "unverts", "compvert", "conversion", "Convert", "conVERT", "unfer", "confer", "Conprocess", "Converts", "consvert", "CONvert", "CONverted", "Confer"], "src": ["path", "ser", "http", "attr", "st", "orig", "addr", "RC", "config", "SOURCE", "img", "pkg", "sys", "rx", "sin", "ur", "ource", "sc", "rel", "rc", "its", "scan", "scene", "from", "ebin", "buster", "uri", "ins", "loc", "filename", "Source", "rs", "iv", "rest", "dist", "req", "str", "stream", "upload", "txt", "href", "cont", "sit", "sr", "source", "input", "file", "cc", "ipl", "usr", "func", "inst", "s", "url", "start", "host", "hl", "sq", "SourceFile", "cur"], "dest": ["disk", "gin", "est", "orig", "img", " Destination", "dat", " orig", "dir", "test", "foreign", "write", "dist", " destinations", "txt", " destination", "result", "Dest", "tif", "source", "port", "table", "target", " dst", "mat", "temp", "rest", " Dest"], "in": ["IN", "din", "st", "rin", "is", "b", "as", "sql", "en", "io", "from", "ind", "ins", "ar", "el", "up", "bin", "serv", "inner", "reader", "d", "stream", "isin", "r", "l", "In", "input", "source", "m", "file", "i", "inn", "res", "inf", "ad", "cin"], "p": ["vp", "dp", "P", "pm", "per", "part", "ping", "j", "rep", "it", "pkg", "b", "prot", "f", "tp", "pg", "lp", "parser", "wp", "pa", "h", "fp", "pl", "pro", "er", "t", "op", "pt", "ps", "pre", "at", "g", "ap", "pb", "cp", "d", "post", "l", "pc", "c", "pe", "pd", "m", "ph", "parse", "i", "sp", "pi", "py", "pers", "jp", "php", "r", "pp"], "ds": ["loads", " ads", "workers", "ports", "bs", "iffs", "ss", "its", "aws", "dt", "obs", "lists", "yes", "ils", "dh", "ads", "terms", "ats", "nas", "dds", "tes", " dd", "db", "vs", " des", "des", "tp", "ws", "uds", "qs", "hs", "cs", "dl", "outs", "ks", "dd", "points", "pd", "edes", "ls", " d", "sd", "gs", " DS", "cks", "os", "Ds", "DS", "dates", "tests", "rs", "ags", "ods", "gd", "scripts", "d", "docs", "ands", "els", "ras", "ts", "dp", "posts", "drivers", "dos", "ys", "xs", "eds", "amps", "ps", "tags", "mys", "js", "ns", "sts", "df", "di", " os", "s", "eps", "hd", "sets"], "format": ["output", "path", "style", "top", "shape", "template", "it", "type", "title", "filter", "ct", "f", "id", "pretty", " Format", "size", "sche", "lat", "mt", "feat", "feature", "t", "Format", "spec", "mode", "fc", "fm", "tag", "settings", "at", "module", "version", "ats", "MAT", "unit", "name", "l", "policy", "form", "source", "set", "status", "table", "file", "parse", "pi", "cf", "layout", "act", "mat", "pattern"], "hasPixelData": ["hasFrameData", "HaspixelDATA", "HasPixelDATA", "HasPixelData", "hasixelDATA", "hasPixeldata", "hasixeldata", " hasPixelDATA", "hasPixelDATA", "haspixelData", "HasPixeldata", "Haspixeldata", " hasPixeldata", "haspixeldata", "hasFrameDATA", "haspixelDATA", "HaspixelData", "hasixelData", "hasFramedata"], "inflate": ["Inflated", "infolated", " invalidate", "Informate", "inFLate", " invalidicate", "invalidate", "inFLated", "Informated", "inflicate", "invalidicate", "informocate", "inflat", "invalidocate", "Inflate", "inflATE", "inflated", " inflicate", " inflATE", "informat", "informate", "Informat", "incelocate", "inFlate", "Informocate", "Inflat", "incelicate", "infolocate", "incelate", "inFlATE", "inFlocate", "inFLat", "inFLocate", " invalidATE", "incelATE", "infolate", "Inflocate", "informated", "invalidATE", "infolat", " inflocate", " invalidocate", "inflocate", "inFlicate"], "pxlen": ["xyln", "xylength", "mxdec", "packln", "packfun", "tmplen", "phplen", "mxlength", "cplength", "packlength", "pexls", "mmlength", "pexlen", "pxdec", "pixelfun", "pexfun", "tmpln", "mxlen", "pixellength", "pixellen", "pxden", "mmln", "xplen", "cplen", "packlen", "packls", "mmlen", "pixells", "pxls", "pxfun", "phplength", "phpln", "pexln", "pexlength", "pexden", "xplength", "pxlin", "mmlin", "phpdec", "pxlength", "xpden", "xpln", "tmplength", "cpden", "pxln", "packdec", "xylen", "tmplin", "cpln", "xylin", "mxln"], "out": ["output", "gr", "gov", "prefix", "init", "ln", "Out", "user", "msg", "sys", "pretty", "inv", "aos", "dir", "io", "ex", "outs", "crit", "client", "up", "cfg", "ou", "group", "writer", "store", "name", "inter", "screen", "sum", "obj", "net", "err", "conn", "print", "OUT", "log", "res", "outer", "cmd", "temp", "list"]}}
{"id1": "18748516", "id2": "8011262", "code1": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["printf", "load", "save", "replace", "sync", " cp", "move", "transfer", "export", "cat", "download", "create", "read", " replicate", "rm", "slice", "map", "Cop", "delete", "cp", "println", "upload", "Copy", " Copy", "csv", "clone", " copying", "paste"], "fromFile": ["inputPlace", "inputName", "outPlace", "toByte", "toUrl", "fromFilename", " fromName", "inByte", "inPage", " fromPlace", "toPage", "outFilename", "fromByte", "inputFilename", "inputUrl", "fromPage", " fromFilename", "fromName", "inputByte", "outName", "inFile", "fromUrl", "inUrl", "inputPage", "outFile", "fromPlace"], "toFile": [" tofile", "intofile", "targetFilename", "outputFilename", " toFilename", "outputPage", "intoPage", "targetFile", "toPlace", "outputPlace", "outputfile", "toPage", "outFilename", " toPlace", "tofile", "outPage", "outfile", "toFilename", "targetPlace", "targetfile", "intoFilename", "intoFile", "outFile"], "inputFile": ["outputTime", "fromTime", "inputTime", "innerBe", "acceptMail", "outputPage", "innerMail", "acceptFile", "fromfile", "innerDo", "outputfile", "Inputfile", "acceptDo", "InputTime", "innerFile", "inputDo", "fromPage", "inBe", "inMail", "inputBe", "InputPage", "inDo", "inputMail", "inFile", "inputPage", "InputFile", "acceptBe", "inputfile"], "outputFile": ["webPlace", "resultFile", "webFile", "outputPlace", "webfile", "writePlace", "writefile", "outputPath", "outputfile", "outputTable", "toFiles", "writeFile", "outFiles", "webTable", "tofile", " outputTable", "resultPath", "resultfile", "outPath", " outputfile", "outfile", " outputPlace", "resultFiles", "outputFiles", "toPath", "writeTable", "outFile"], "in": ["IN", "on", "per", "din", "gin", "im", "con", "init", "it", "oin", "rin", "ri", "is", "ze", "ic", "ai", "ini", "sin", "ain", "read", "en", "inc", "io", "ind", "al", "ins", "up", "bin", "inner", "reader", "isin", "ir", "In", "form", "input", "iter", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "on", "con", "by", "n", "auto", "Out", "it", "user", "sys", "and", "b", "put", "o", "aos", "to", "os", "io", "conv", "outs", "t", "client", "up", "v", "nt", "at", "write", "g", "inner", "all", "writer", "w", "obj", "net", "print", "OUT", "check", "ne", "cn", "co", "ot", "we", "outer", "res", "cache"], "c": ["ch", "nc", "cos", "C", "x", "n", "uc", "mc", "ct", "f", "count", "sc", "cd", "rc", "o", "character", "ce", "cs", "conv", "t", "lc", "current", "unc", "ac", "v", "cm", "cr", "code", "cod", "jc", "d", "cp", "cb", "dc", "char", "r", "k", "u", "bc", "pc", "cont", "l", "gc", "cl", "m", "cap", "cc", "z", "i", "arc", "chain", "cf", "conf", "ca", "cache"]}}
{"id1": "14650352", "id2": "720361", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfUserExist", "checkIfUserExEx", "checkIfFileExists", "checkIfUserLEx", "checkIfUserPersist", "checkIfFileExEx", "checkIfUserExisted", "checkIfUserLists", "checkIfUserPersEx", "checkIfFileExisted", "checkIfFileExist", "checkIfUserPersists", "checkIfUserPersisted", "checkIfUserList", "checkIfUserListed"], "username": ["path", "message", "text", "owner", "description", "password", "term", "prefix", "unknown", "config", "hello", "user", "human", "account", "title", "attribute", "person", "aka", "token", "rue", "subject", "auth", "login", "filename", "email", "john", "pai", "ame", "ename", "key", "ername", "name", "uid", "result", "remote", "string", "input", "profile", "whatever", "ugi", "phone"], "url": ["http", "ls", "abs", "ol", "sl", "org", "open", "user", "build", "pkg", "bel", "ur", "lb", "Url", "f", "b", "ul", "ml", "URL", "re", "ssl", "uri", "dl", "nl", "loc", "atl", "el", "ref", "ld", "str", "ll", "get", "l", "char", "gc", "ocl", "file", "log", "job", "https", "web", "r", "il"], "conn": ["ch", "nc", "connect", "con", "close", "init", "open", "sys", "connection", "ct", "rel", "inv", "ws", "enc", "ssl", "conv", "pas", "resp", "client", "gn", "soc", "fin", "nt", "syn", "cp", "cb", "comm", "cons", "coll", "exec", "net", "cont", "nn", "tn", "yn", "ctx", "cn", "jp", "cmd", "res", "act", "dial", "Conn", "c", "cur"], "is": ["mis", "ms", "im", "isc", "ais", "tis", "ris", "dis", "ic", "sys", "isl", "has", "nis", "bis", "bs", "isa", "its", "iss", "css", "xs", "are", "ys", "cs", "nic", "ins", "pas", "ps", "js", "isf", "si", "Is", "fs", "iris", "set", "us", "isi", "i", "ios", "sis", "in", "ip", "lis", "IS"]}}
{"id1": "22479286", "id2": "12246545", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"md5": [" MD4", "md4", "MD4", " MD3", " md3", "MD3", " md4", " MD5", "md3", " md2", " MD2", "MD5", "MD2", "md2"], "plainText": ["flatForm", "batSync", "ainSync", "batTerm", "alttext", " plaintext", "initialTrans", "altString", "fullString", "altPrint", "longString", "longTEXT", "longPrint", "batString", "aintext", "plainForm", "plainDelete", "externalText", "richPrint", "ainTerm", " plainTrans", "maintext", "mainString", "richString", "positionString", "initialText", "fullPrint", "richText", " plainForm", "plainMessage", "fullText", "fulltext", " plainSync", "mainText", " plainString", "externalDelete", "ainTEXT", "ainPrint", "batText", "plainPrint", "mainTEXT", " plainTEXT", "plainSync", "initialtext", "plainString", "positionText", "altTEXT", "plainTrans", "ainForm", " plainMessage", "plainTerm", " plainDelete", "flatTEXT", "plainTEXT", "richTEXT", "flatText", "externalTEXT", "initialString", "ainMessage", "externalString", "flatMessage", "ainString", "positionTEXT", " plainTerm", "ainTrans", "altText", "longText", "plaintext", "ainText", "positiontext", "ainDelete"], "md": ["dr", "pm", "ms", "add", "pdf", "sd", "mc", "bd", "od", "ad", "MD", "grad", "der", "cd", "mg", "h", "dir", "desc", "mm", "dm", "mt", "ind", "down", "red", "sm", "dh", "nt", "det", "ld", "mb", "d", "dd", " Md", "mac", "mp", "mk", "mod", " MD", "pd", "m", "df", "di", "mn", "mand", "cmd", "man", "hd", "ng", "de"], "digest": ["compest", "digute", "presentests", "defEST", " digse", " digests", "defested", "digity", "compidate", "presentEST", " digested", "digested", "Digest", "presentute", " digEST", "digum", "Digum", " digity", "candidate", "candest", "presentested", "defest", "Digests", "DigEST", "mdested", "candum", "candute", "mdEST", "digse", "digEST", "Digested", "digests", "digidate", "Digity", "defse", "Digidate", "compum", "compute", "mdest", "presentest", "presentity", " digute", "mdse", "Digute"], "hexString": ["exString", "expstring", " hexSingle", " hexstring", " Hexstring", "expText", "expBuffer", "exArray", "hexstring", " HexText", " hexText", "exBuffer", "hexSingle", "charArray", "rexString", " HexBuffer", "rexArray", " hexArray", "exText", " hexBuffer", "hexBuffer", "rexBuffer", "hexText", "expString", "charBuffer", "hexArray", "charString", "rexSingle", "charText", "exSingle", " HexString"], "i": ["multi", "im", "x", "j", "n", "init", "it", "phi", "my", "a", "ai", "is", "ic", "ski", "ui", "ie", "b", "me", "q", "iu", "id", "y", "to", "io", "ci", "gu", "ind", "mi", "ex", "conv", "qi", "ii", "uri", "v", "gi", "hi", "key", "g", "ti", "ji", "bi", "index", "si", "I", "u", "err", "batch", "yi", "set", "m", "xi", "iq", "z", "di", "sim", "pi", "info", "chain", "in", "ip", "li", "c", "\u0438", "ix"]}}
{"id1": "20306677", "id2": "21827619", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"update": ["edit", "UPDATE", "Update", "load", "patch", "json", "offset", "add", "save", "init", "replace", "touch", "now", "user", "draw", "build", "change", "database", " Update", "put", "updated", "flush", "send", "latest", "id", "state", "local", "size", "create", "execute", "test", "num", " UPDATE", "use", "login", "op", "current", "up", "oo", "run", "call", "delete", "write", "where", "all", "version", "ask", "index", "get", "upload", "u", "print", "batch", "check", "fill", "set", "push", "status", "date", "value", "match", "find", "query", "out", "insert", "commit", "report"], "o": ["onet", "bo", "n", "iso", "oin", "a", "O", "fo", "b", "ob", "p", "y", "to", "os", "t", "oo", "v", "e", "oa", "ao", "oice", "u", "obj", " mo", "k", "om", "object", "m", "po", "i", " os", "mo", "vo", "oid", "ooo", "out"], "bill": ["bo", "iban", "lex", "kick", "gross", "nb", "book", "money", "bean", "build", "bar", " Bill", "b", "handle", "inv", "bb", "BILL", "pay", "phy", "Bill", "fax", "ship", "ll", " billing", "service", "bank", "quote", "net", "nn", "conn", "trade", "stuff", "batch", "project", "biz", "company", "ann", "work", "vo", "unk", "sk", " billed", "fund", "report"], "pst": [" pct", "apct", " psp", "tpse", "tpST", "tpsp", "cstra", "pstro", "opst", "apsp", "opse", "picstro", "pstra", "pST", "cstro", "picst", "pse", "tpstra", "opct", "pth", " pST", "pkgth", "cth", "tpct", "pkgstro", "opstra", "tpst", "apst", " pse", "picth", "pkgstra", "pkgst", "cst", " pstra", "psp", "apST", "picstra", "pct"]}}
{"id1": "22441244", "id2": "17999474", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 1, "substitutes": {"send": ["message", "mail", "add", "save", "init", "msg", "build", "apply", "transfer", "export", "end", "create", "execute", "sent", "security", "write", "post", "get", "Send", "print", "submit", "set", "reply", "parse", "push", "report"], "hsession": ["hessions", "hsess", " HSess", "HSettings", "hsettings", "HSession", "HSsession", "rsession", "hettings", "rsess", "rssession", "HSpace", "HSess", "hhettings", "hssession", "hhessions", " HSpace", "hhsession", "hhhip", "HShip", "rspace", " HSsession", "HSessions", "hession", "hspace", "hhip", "hsessions", "hship", " HSession", "hhession"], "session": ["message", "password", "instance", "Session", "account", "connection", "manager", "state", "client", "lock", "parent", "content", "store", "name", "ession", "view", "ess", "event", "sid", "set", "object", "driver", "job", "document", "context", "ip", "cache"], "repositoryName": ["repositoryPath", "repoositoryname", "repoitoryname", "reposositoryName", "repositionName", "repositableName", "repositorName", "reposoryData", "repositorPath", "repoositoryNAME", "repositoryData", "reposoryname", "repositionNAME", "reposoryName", "repoositoryTitle", "repositorNAME", "repositoryname", "reposositoryNAME", "repositableNAME", "repositablename", "repoositoryName", "repositorTitle", "repositionPath", "repositoryNAME", "repositoryTitle", "reposositoryname", "repositableData", "repoitoryName", "repositionTitle", "repoitoryTitle", "repoositoryData", "reposositoryData", "reposoryNAME", "reposositoryTitle", "reposositoryPath", "repoositoryPath", "repoitoryNAME", "repoitoryPath", "repoitoryData"], "ideIdint": ["ideInfoINT", "IDEIdst", "ideThint", "ideIdINT", "IDEidINT", "ideThind", "ideIdind", "ideIDno", "ideDINT", "ideidst", " ideIdno", "ideIDint", " ideIdind", "ideInfoint", "ideIDline", "IDEidint", "ideIdentint", "ideInfost", "ideIdno", "ideidint", "ideIdentind", "ideIdst", "ideIDind", "ideDint", "ideIdline", " ideThline", "IDEIdint", "IDEidst", " ideThind", "IDEIdINT", "ideThno", "ideDst", " ideThint", "ideIdentno", " ideIdline", "ideThline", " ideThno", "ideidINT", "ideIdentline"], "to": ["topic", "site", "top", "st", "addr", "eto", "by", "tel", "auto", "ato", "tt", "tp", "address", "toc", "too", "no", "ta", "token", "o", "os", "pro", "t", "about", "client", "pos", "contact", "tr", "company", "po", "range", "co", "target", "TO", "To", "route", "phone"], "cc": ["cy", "cci", "mc", "ic", "ct", "ck", "toc", "sc", "cd", "rc", "ce", "ico", "cv", "ci", "cs", "cca", "control", "ac", "fc", "cm", "cr", "cmp", "cloud", "ec", "tc", "cb", "cp", "dc", "CC", "cl", "company", "cn", "ctrl", "co", "cf", "cmd", "ca", "cin"], "bcc": ["vck", "sbcy", "sbce", "cbcc", "vcc", "bce", " bck", "cbck", "vce", "bck", "rbck", "vcy", " bcm", "sbcc", "bcy", "cbcm", "bCC", " bCC", "rbCC", "rbce", "rbcy", "rbcm", "sbck", "bcm", "cbCC", "rbcc"], "subject": ["topic", "message", "text", "mail", "html", "description", "face", "prefix", "template", "head", "author", "header", "heading", "title", "metadata", "id", "note", "uri", "security", "filename", "content", "name", "Subject", "form", "source", "comment", "host"], "body": ["output", "buffer", "message", "binary", "text", "mail", "part", "json", "description", "html", "top", "template", "head", "news", "response", "b", "title", "shell", "params", "bill", "no", "h", "Body", "note", "default", "ody", "files", "back", "content", "summary", "code", "inline", "hex", "null", "inner", "any", "name", "background", "post", "bytes", "other", "business", "line", "base", "parts", "source", "object", "padding", "ODY", "comment", "bh", "query", "data", "url", "layout", "handle", "report", "zip"], "attachments": ["achmentachment", "attresses", "Attachments", "achmenttypes", "attachtypes", "atttypes", "achmentresses", "attments", "achmentments", "attachachment", "Attachtypes", "Attachachment", "attachresses", "Attachresses"], "isHtml": ["IsHtml", "isJttp", "isHip", "isChhtml", "isHHTML", " isWhhtml", "isHhtml", "isChHTML", "isVtml", "isJap", " isHHTML", "isChip", "isWhHTML", "ishttp", "isHttp", "ishhtml", " isHhtml", " isWhtml", "IsHttp", "IsHap", " isWhHTML", "isVhtml", " isWhip", "isWhhtml", "isHap", "ishtml", "isVHTML", "isChtml", "isWhip", "isVip", "isWhtml", "isJtml", "ishap", "isJhtml", " isHip", "IsHhtml"], "charset": ["charpett", "charsET", "Charsetic", "chippett", "charpetic", "CHippet", "CHippett", "clarsets", "ChARSet", "chARSet", "channelsET", "ChARSetter", "chactersetter", "quatsale", "CHarsets", "channelsetic", "clersets", "quarsec", "chARSET", "charspace", "chippale", "chippET", "chippets", "CHippET", "chablesec", "chARSetter", "channelsetter", "CharsET", "chARSetic", "clarsetter", "quatsetter", "chippec", "chableset", "charpET", "quarsale", "charsett", "chablesetter", "chersetter", "CHarset", "charpet", "cherset", "clarspace", "charsets", "ChARSetic", "quarsetter", "chatsec", "chacterset", "chatsale", "charsetic", "charsale", "chippet", "quatset", "chacterspace", "channelset", "CHarsett", "Charset", "charpets", "clarset", "chactersets", "chARSets", "chatsetter", "ChARSET", "chippetter", "Charsetter", "cherspace", "charsec", "clerset", "quatsec", "chARSpace", "charsetter", "clersetter", "charpetter", "chatset", "clerspace", "CHippets", "quarset", "chersets", "chablesale", "CHarsET"], "headers": ["ters", "dr", "limits", "head", "users", "header", "types", "ppers", "metadata", "ors", "params", "comments", "files", "lines", " trailers", "ers", "authors", "codes", "keys", " heads", "heads", "details", "fields", "relations", "names", "ilers", "members"], "priority": ["description", "password", "prefix", " severity", "properties", " urgency", "title", "grade", "id", "comments", "state", "flags", "security", "pos", "due", "serial", "position", "policy", "level", "company", "primary", "status", "profile", "origin", "context", "order", "phone"], "email": ["output", "message", "http", "mail", "html", "description", "password", "model", "template", "instance", "voice", "msg", "database", "detail", "response", "example", "echo", "link", "em", "address", "shell", "et", "console", "reset", "Email", "sample", "ome", "test", "note", "ilo", "er", "element", "ssl", "initial", "el", "liner", "ee", "server", "fax", "call", "e", "oe", "all", "delete", "office", "label", "xml", "view", "external", "contact", "license", "event", "gmail", "result", "print", "line", "entry", "object", "ne", "company", "ell", "domain", "log", "comment", "die", "document", "search", "url", "enter", "report", "il"], "user": ["output", "ident", "owner", "by", "author", "human", "used", "users", "account", "connection", "manager", "person", "me", "id", "entity", "usage", "util", "from", "creator", "User", "use", "auth", "client", "login", "browser", "name", "USER", "uid", "username", "result", "match", "actor", "profile", "system", "student", "admin", "ip", "usr", "usa"], "identity": ["instentity", "idality", "ethnicity", "idity", "recognance", "primicate", "entularity", "personificate", "ethnicitate", "IDENTality", "instularity", "presentularity", "identITY", "instifier", "idiciary", "solidularity", "equentity", "IDENTentity", "entity", "primificate", "solidality", "presentitate", "entifier", "IDENTator", "identifier", "idITY", "identality", "personicate", "identalty", "identance", "IDENTiciary", "presententity", "recognicate", "recognentity", "identator", "IDENTicate", "identificate", "equalty", "IDENTitate", "ententity", "primance", "personiciary", "IDENTITY", "instalty", "IDENTalty", "idententity", "idularity", "ethnicentity", "IDENTularity", "identiciary", "identularity", "personentity", "personITY", "equity", "primentity", "IDENTifier", "identicate", "IDENTificate", "identitate", "recognity", "equator", "instator", "IDENTity", "instity", "presentity", "personity", "IDENTance", "primity", "solidentity", "ethnicularity", "solidity"], "_returnPath": ["setsavepath", "_deletePath", "_retPath", "_replyDir", "_resultPoint", "_retUrl", "setsaveUrl", "setreturnPath", "_deleteTo", " _errorPoint", "_ReturnPoint", "_requestAddress", "setsavePath", "_getDir", "_retDir", "_returnLocation", "_requestPoint", "_retCode", "_returnUrl", "_retLocation", "_returnpath", " _errorAddress", " _errorPath", " _returnName", "_errorAddress", "_deletepath", "setreturnpath", "_replyPath", "_replyCode", "_getPath", "_returnName", "_ReturnAddress", "_returnDir", "_getTo", "_errorName", "setreturnTo", "_requestName", "_errorUrl", "_errorTo", "_returnPoint", "_errorLocation", "_retPoint", "_ReturnPath", "_returnTo", "_savepath", " _returnPoint", "_resultPath", " _errorName", "setsaveTo", "_retpath", "_resultLocation", "_ReturnName", "_saveUrl", "_requestPath", "_savePath", "_errorPath", "_returnCode", "_deletePoint", "setreturnUrl", " _returnAddress", "_errorpath", "_saveTo", "_returnAddress", "_errorPoint", "_resultTo", "_getCode", "_retTo"], "_from": ["_owner", "longsource", "remaddr", "_form", "_addr", " _form", "remfrom", "letabout", "\tfrom", " _actor", " _author", "longfrom", " _reset", "letsource", "\tauthor", " _source", "longreset", "_author", " _about", "remlocal", "remowner", "_actor", "_reset", "_source", "letto", "_about", "longto", "\tactor", "letfrom", "_local", "\tform"], "_replyTo": ["_respondTo", "_responseTO", "_replyFrom", "_backPath", "_respondOnly", "_replyLine", "_replyPath", "_commentOf", "_replyTO", "_returnTo", "_backTO", "_ReplyFrom", "_responseFrom", "_returnOnly", "_respondTO", "_closeLine", "_commentLine", "_closeOf", "_responseLine", "_closeTo", "_responsePath", "_ReplyTO", "_returnFrom", "_commentTo", "_ReplyOnly", "_responseTo", "_backTo", "_returnTO", "_ReplyTo", "_closeTO", "_ReplyPath", "_respondFrom", "_responseOf", "_replyOf", "_backFrom", "_commentTO", "_replyOnly"], "_to": ["successtopic", "successto", "successta", "_ta", "prisite", "_site", "_topic", "successsite", "prito", "prita", "pritopic"], "_cc": ["_cs", " _cca", "_subject", "_cca", " _subject", " _cs"], "_bcc": ["_racc", "_wca", "_rck", "_rbck", "_bacc", "_wcc", "_bca", "_rcc", "_wck", "_rbacc", "_rbcc", "_wacc", "_rca", "_rbca", "_bck"]}}
{"id1": "13233761", "id2": "539195", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["startQueryTx", "executeWriteTransaction", "executeWriteTask", "executeQueryTx", "executeQueryTask", "executeInsertStatement", "executeWriteTx", "executeQueryStatement", "executeInsertTx", "startUpdateTx", "startUpdateTask", "executeInsertTransaction", "executeInsertTask", "startQueryStatement", "executeUpdateStatement", "startUpdateTransaction", "startQueryTransaction", "executeUpdateTask", "startQueryTask", "executeUpdateTx", "executeWriteStatement", "executeQueryTransaction", "startUpdateStatement"], "queries": ["quiries", "Queries", "Quarks", "aquiries", "gallenges", "aquands", "Quues", "quearks", "quenges", "qualeries", "gallands", "aqueries", "quands", "aquenges", "quarks", "qualenges", " Quands", " Queries", "galliries", "queeries", "qualands", "galleries", " Quarks", "quues", "queues", "queands", "qualiries", "Quands", " Quues"], "autoCommit": ["autoAmport", "autoAbscommit", "AutoCommit", "AutoClport", "autoCompate", "automaticCompate", "autoCompist", "automaticCompcommit", "AutoClmit", "autoClmit", "AutoCommmit", "automaticCommcommit", "autoDebate", "autoAbsit", "autoDebcommit", "autoCommcommit", "AutoClits", "automaticCommate", "autoCommits", "autoBeits", "autoDebist", "autoClport", "autoCompit", "autoBeit", "autoCommmit", "AutoClit", "autoAbsate", "automaticCompist", "autoCommport", "AutoCommport", "autoAbsist", "automaticCommist", "autoAmit", "autoCommist", "automaticCommit", "autoAmits", "autoBemit", "automaticCompit", "autoAmmit", "autoCompcommit", "autoClit", "autoDebit", "AutoCommits", "autoBeport", "autoCommate", "autoClits"], "iterator": ["collection", "udder", "series", "runner", "list", "rounder", "pler", "ator", "instance", "menu", "ski", "loop", "pour", "oser", "processor", "interstitial", "bis", "internet", "pee", "loader", "integer", "folder", "rows", "starter", "sample", "size", "creator", "pie", "encer", "started", "video", "current", "liner", "continue", "operator", "river", "inner", "writer", "next", "reader", "number", "stream", "values", "ter", "sequence", "upper", "vector", "page", "directory", "taker", "ner", "former", "set", "giving", "iter", "gener", "zero", "walker", "finder", "issues", "immigrant", "trace", "seconds", "outer", "members", "storage", "Iterator", "information"], "query": ["series", "message", "update", "task", "description", "password", "term", "prefix", "menu", "condition", "title", "q", "sql", "row", "execute", "test", "subject", "resource", "lock", "qu", "request", "code", "key", "script", "name", "version", "quest", "quote", "family", "sequence", "result", "command", "string", "check", "table", "Query", "comment", "parse", "join", "escape", "sq", "question"], "statement": ["ment", "message", "expression", "session", "binary", "task", "description", "block", "phrase", "template", "fire", "connection", "condition", "shell", "sql", "usage", "state", "Statement", "execute", "mt", "slot", "resource", "continue", "confirmed", "call", "group", "rule", "quote", "sequence", "minute", "print", "command", "batch", "line", "set", "status", "table", "parse", "comment", "system", "word"]}}
{"id1": "2381663", "id2": "16623181", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedAndrethrown", "malformedGadgetSpecIsCachedAndrethThrow", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedandthows", "malformedGadgetSpecIsCachedandThows", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndThThrow", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedandThThrow", "malformedGadgetSpecIsCachedAndthThrow", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndThows", "malformedGadgetSpecIsCachedAndrethrows", "malformedGadgetSpecIsCachedAndrethows", "malformedGadgetSpecIsCachedAndthows", "malformedGadgetSpecIsCachedandthThrow", "malformedGadgetSpecIsCachedAndthrows"], "request": ["message", "http", "task", "instance", "response", "requ", "condition", "reference", "q", "p", "create", "frame", "map", "client", "resource", "initial", "call", "pair", "this", "forward", "req", "next", "xml", "pull", "quest", "result", "record", "command", "project", "input", "object", "Request", "parse", "document", "query", "url", "context", "ip", "report", "first", "question"]}}
{"id1": "539195", "id2": "8932510", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["load", "ls", "save", "replace", "init", "sync", " cp", "link", "move", "transfer", "cat", "download", "create", "to", " cop", "slice", "Cop", "delete", "cop", "cp", "println", "dump", "upload", "gc", "Copy", " Copy", "csv", "clone"], "src": ["ser", "ident", "spr", "attr", "st", "ls", "orig", "addr", "host", "init", "img", "pkg", "sys", "rx", "sin", "sc", "rel", "rc", "desc", "from", "sel", "uri", "ins", "loc", "filename", "Source", "rs", "spec", "iv", "comp", "rt", "req", "dist", "str", "ctr", "this", "txt", "sec", "sit", "imp", "sr", "source", "input", "rl", "pres", "sb", "inst", "url", "urg", "start", "in", "usr", "sq", "cur"], "dest": ["deg", "est", "st", "orig", "it", "tmp", "del", "master", "p", "opt", "id", "end", "cat", "dir", "test", "loc", "dist", "home", "req", "d", "nw", "sup", "cont", "Dest", "mem", "them", "source", "trans", "gt", "nom", "decl", "https", "target", "exp", "origin", "usr", "temp", "rest", "way"], "ifp": [" ifcp", "ify", "ffp", "ihe", "alfpp", "ifsp", "iftpc", " ifpa", "ibpa", "ibsp", "iby", " ifsp", "ifop", "ibp", "Ifop", "afpp", "Ife", "ifpp", "afp", "ife", "ihop", "afpc", "ifttp", "alfp", " ify", " ife", "ifcp", "ifpa", "ihcp", "ffpa", "alftp", "iftpp", "ihp", "ffy", "Ifcp", "alfpc", "ifpc", "aftp", " ifop", "Ifp", "iftp", "ffsp"], "ofp": ["ofd", "Ofjp", "Ofsp", "OFP", "ofproc", "offd", "Ofproc", "offp", "ofP", "ofjp", "orfp", " ofsp", "offP", "OFd", "offjp", "orfd", "orfsp", "Ofp", "OFp", "OfP", "Ofd", " ofd", "orfproc", "ofsp", "OFjp", " ofproc"], "fis": [" fi", " fiss", "flai", "wiss", "fiis", "fiiss", "gais", "Fais", "fiss", "Fis", "fi", "fai", " fais", "Fiss", "Fist", "flais", "flis", "Fai", "gi", "fiist", "wi", "fais", "Fos", "fist", "giss", "fliss", "wis", "gis", "wais", "fios", " fist", " fai"], "fos": ["faos", "fiis", " foses", "Foss", "woses", "flaos", " foes", "Foes", "flos", "flis", "floes", "Foses", "Fos", "flios", " fios", "foes", " foss", "woes", "fios", "wios", "foses", " faos", "foss", "fiaos", "fioes", "woss", "waos", "wos"], "b": ["ch", "B", "binary", "db", "j", "nb", "bd", "bar", "f", "bis", "body", "ob", "bs", "p", "y", "h", "bb", "fb", "bits", "v", "ab", "eb", "bg", "g", "bit", "bi", "be", "reb", "pb", "mb", "d", "cb", "gb", "wb", "blue", "l", "k", "bc", "lib", "base", "batch", "z", "br", "sb", "rb"]}}
{"id1": "646016", "id2": "22611968", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"elimina": ["eligino", "alimine", "elimino", "allimine", "alimina", "elitino", "elimine", "ellimina", "ellimine", "alimino", "alimisa", "eligine", "allimino", "elitine", "elitisa", "eligisa", "elitina", "elimisa", "ellimino", "allimina", "ellimisa", "eligina", "allimisa"], "cli": ["grid", "multi", " CLI", "cu", "ln", "cci", "cho", "gil", "ui", "lu", "prot", "udi", "gui", "console", "util", "uci", "ctl", "ci", "dl", "Client", "client", "lc", "cfg", "eric", "e", "clus", "cgi", "coe", "l", "idi", "c", "conn", "cl", "GUI", " cl", "ctrl", "i", "coni", "pi", "cmd", "aci", "li", "dial", "Cl", "exe"], "id": ["out", "ident", "db", "mail", "ide", "Id", "it", "sd", "type", "is", "and", "rid", "ip", "ad", "del", "f", "no", "h", "end", "num", "pid", "ida", "mid", "kid", " fid", "with", "rand", "iden", "ref", "e", "ids", "code", "key", "null", "name", "bid", "d", "aid", "index", "uid", "md", "wid", "sid", "hash", "status", "value", "vid", "did", "i", "info", "oid", "url", "start", "in", "res", "ID"], "sql": ["fn", "expression", "spr", "db", "mail", "json", "html", "ms", "lex", " SQL", "ping", "ls", "sl", "ln", "lua", "pel", "msg", "sd", "sal", "sys", "pkg", "wal", "shell", "ql", "socket", "ds", "util", "inv", "SQL", "xs", "ssl", "dl", "nl", "pp", "security", "spec", "ps", "lock", "services", "js", "QL", "ship", "ns", "sol", "ips", "xml", "ll", "owl", "details", "string", "scl", "csv", "software", "sb", "sp", "https", "sv", "s", "format", "what", "query", "sk", "url", "eps", "sq"], "stmt": ["Stmm", "STm", "stMT", "strmt", "Stm", "scm", "STmn", "stm", "tm", "StMT", "stmm", "STmm", "strMT", "Sttm", "Stmb", "Stmt", "strmb", "scmm", "tmt", "ttm", "Stmn", "scmt", "stmn", "STMT", "tmm", " stm", "stmb", " stMT", " stmb", " stmm", "strm", " sttm", "sttm", " stmn", "STmt", "sctm"]}}
{"id1": "19549577", "id2": "1097147", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"callApiPost": ["callUapiPOST", "callApiPut", "callUpiPut", "callUpiDelete", "callAiPut", "callAiDelete", "callApiDelete", "callActionsPut", "callActionsPOST", "callUapiPut", "callApiPOST", "callUapiPost", "callAapiPOST", "callActionsPost", "callAiPOST", "callActionsDelete", "callUapiDelete", "callAapiPost", "callUpiPost", "callAapiPut", "callAiPost", "callUpiPOST", "callAapiDelete"], "apiUrl": ["piPath", "resourceName", "apiName", "piURL", " apiName", "apiUr", "baseURL", " apiURL", "baseUr", "resourceURL", "apiPath", "baseUrl", "resourceUrl", "basePath", "piUr", "apiURL", " apiUr", "apURL", "piName", "resourceUr", "piUrl", "apUr", "apPath", "apUrl"], "parameters": ["queters", "authorants", "payeters", "paramels", "pParameters", "paytons", "paramants", "paramParameters", "qutons", "paramtons", "mions", "quels", "paramions", "payels", "payants", "mperties", "questParameters", "questperties", "mParameters", "meters", "authortons", "authoreters", "pions", "peters", "pperties", "paramperties", "authorels", "questions", "questeters", "quants"], "expected": ["json", " expect", " expects", "pects", "hello", " expecting", "force", "type", "example", "future", "count", "size", "checked", "test", "sent", "ped", "default", "pected", "encrypted", "actual", "needed", "current", "odd", "posted", "sex", "e", "code", "done", "error", "required", " expectation", "event", " unexpected", "finished", "set", "seen", "received", "value", "pect", "foo", "empty", "safe", "reported", "failed", "allowed"], "url": ["http", "mail", "ls", "abs", "sl", "arl", "build", "bel", "link", "ur", "Url", "f", "address", "q", "ml", "ul", "URL", "loader", "pl", "re", "ssl", "uri", "dl", "nl", "loc", "gl", "str", "mount", "impl", "ll", "get", "service", "l", "www", "gc", "base", "rl", "log", "https", "oul", "r", "hl"], "request": ["header", "change", "requ", "root", "complete", "re", "reverse", "require", "parent", "exit", "version", "Request", "web", "query", "begin", "report", "buffer", "close", "QUEST", "access", "response", "condition", "q", "create", "friend", "run", "pair", "release", "forward", "name", "pull", "quest", "rate", "remote", "project", "object", "parse", "document", "search", "memory", "remove", "session", "application", "volume", "worker", "reset", "register", "use", "client", "resource", "xml", "get", "first", "order", "question", "message", "connect", "over", "open", "user", "reference", "send", "socket", "accept", "initial", "setup", "call", "req", "store", "process", "position", "record", "command", "java", "media", "enter"], "headerName": ["methodSpec", "componentNAME", "attributename", "propertyname", "headerSpec", "profileLetter", "authorNAME", "profileName", "attributeSet", "componentFamily", "headername", "profileHandle", "headerHandle", "headerSet", "propertySet", " headerFamily", "profileSpec", "headingSpec", "headingFamily", "headingNAME", "methodHandle", "headerLetter", "headingName", "authorSet", "attributeName", "headingHandle", "headingLetter", "headerNAME", "methodName", "methodLetter", " headerNAME", "propertyNAME", "authorName", "headerFamily", "attributeNAME", "authorname", "componentName", "propertyName"], "out": ["output", "timeout", "init", "n", "auto", "Out", "ent", "sys", "tmp", "flush", "can", "console", "pretty", "o", "to", "os", "aos", "io", "help", "conv", "outs", "ex", "client", "t", "server", "up", "ou", "at", "write", "all", "inner", "null", "writer", "stream", "net", "print", "OUT", "check", "source", "set", "cn", "table", "log", "comment", "co", "s", "in", "res", "outer"]}}
{"id1": "9272325", "id2": "20855053", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["sendGet", "doPost", "executeGet", "sendPOST", "executePost", "httpGet", "executeRequest", "doPOST", "httpRequest", "sendRequest", "httpPost", "doRequest", "doGet", "executePOST", "httpPOST"], "reqUrl": ["requestURL", " reqURL", "reqURL", "seqURL", "seqUrl", "reqName", "resUrl", "requestStr", " reqName", "reqPath", "requestPath", "resStr", "seqLink", "reqStr", " reqPath", "reqLink", " reqLink", "requName", " reqStr", "requURL", "resURL", "requUrl", "requLink", "seqName", "resPath", "requestUrl"], "parameters": ["paramuments", "promams", "parameter", "promuments", "publiceters", "equams", "paramations", "parmes", "equeters", "publications", "arameters", "promations", "parammes", "paruments", "prometers", "pareters", "publiceter", "prommes", "publicams", "equeter", "arammes", "arameter", "prometer", "pareter", "equations", "paramams", "aramuments"], "urlConn": ["httpConn", "relConnection", "implCond", "resourceconn", "urlCtrl", "utilConn", "implConn", " urlCo", "urlDesc", "belDesc", "objCo", " urlConnection", "nlConnection", "objconn", " urlCon", "relconn", "leftconn", "belConn", "URLCon", "sslConn", "URLconn", "httpConnector", "resourceLink", "httpConnection", "sslConnector", "leftConnect", "mountconn", "urlConnection", "resourceConn", "sslDesc", "urlConnector", "URLConnect", "webConnect", "rowConnection", "urlCond", "implDesc", "implConnection", "relConnector", "retConn", " urlConnector", "mountConn", "utilConnect", "webconn", "rowConn", " urlWr", "leftConn", "fileconn", " urlLink", "URLConn", "utilConnection", "mountCo", "belConnection", "urlWr", "nlConn", "rowCo", "leftCon", "relCo", "retConnect", "utilConnector", "nlConnector", "objCtrl", "mountLink", "urlCon", "fileConnection", "rowconn", "urlconn", "relConn", "urlConnect", "sslConnection", "sslConnect", " urlconn", "httpConnect", "mountWr", "sslCond", "fileCon", "fileConn", "objConn", "sslCo", "urlLink", "mountCtrl", "webConn", "mountConnector", " urlConnect", "belCond", "retconn", "urlCo", " urlCtrl", "sslconn", "resourceWr", "nlConnect", "sslCon"], "params": ["units", "json", "password", "prefix", "properties", "config", "pps", "posts", "types", "ams", "p", "AMS", "pins", "files", "ps", "param", "tags", "rs", "v", "changes", "terms", "bytes", "keys", "points", "values", "Parameters", "base", "string", "m", "padding", "results", "names", "data", "s", "options", "phys", "conf", "services"], "url": ["out", "http", "self", "ls", "location", "abs", "sl", "build", "pkg", "bel", "ur", "lb", "Url", "f", "ul", "URL", "loader", "au", "ssl", "dl", "uri", "nl", "loc", "t", "el", "uu", "name", "str", "mount", "ll", "get", "l", "base", "rl", "log", "sb", "web", "https", "r", "hl", "il"], "b": ["buffer", "B", "bf", "db", "binary", "block", "buf", "nb", "n", "it", "a", "bp", "f", "bis", "ob", "bs", "p", "bb", "fb", "bits", "v", "buff", "bin", "eb", "orb", "be", "bit", "mb", "d", "cb", "gb", "w", "bytes", "l", "u", "obj", "bc", "base", "batch", "m", "z", "i", "sb", "br", "s", "r", "rb"]}}
{"id1": "3053403", "id2": "21824901", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"fc": ["fn", "uc", "ic", "irc", "rc", "inc", "unc", "xc", "ac", "ec", " con", "fs", "form", "gc", "cl", "acl", "cf", "cas", "nc", "con", "wic", "abc", "f", "sc", "icc", "util", "cv", "cs", "conv", "dl", "lc", "win", "fr", "fab", "cm", "frac", "disc", " dc", "dc", "bc", "ff", "imp", "co", "fd", "iac", "soc", "hl", "isc", "cond", "mc", "raf", "football", "fp", "RFC", "mac", "pc", "FC", "func", "exp", "vc", "coll", "fa", "las", "bf", "console", "aft", "anc", "fps", "fb", "fm", "tc", "fl", "owl", "ocl", "ctx", "df", "pic", "full", "ric", "act", "tf", "c"], "buff": ["orm", "bo", "alg", "proc", "ust", "alf", "cell", "bed", "fo", "tt", "tmp", "xy", "bound", "bb", "att", "ind", "bin", "gz", "src", "aux", "pb", "prof", "form", "grow", "ph", "xff", "fw", "buffer", "beck", "printf", " Buff", "lf", "qq", "gold", "f", "tm", "fr", "mb", "cb", "obb", "obj", "td", "ff", "batch", "def", "uff", "off", "urg", "cmd", "inf", "Buffer", "html", "nd", "cond", "pdf", "buf", "hz", "cho", "dat", "fred", "h", "resp", "th", "kw", "nt", "ott", "bg", "butt", "pred", "ld", "interest", "vt", "mem", " buffs", "func", "exp", "sb", "important", "pp", "rb", "bf", "bind", "font", "hold", "b", "bis", "ob", "Buff", "tab", "rend", "norm", "alph", "zz", "np", "note", "fb", "FF", "back", "ref", "uf", "emb", "comp", "hex", "fl", "txt", "bj", "ctx", "utf", "boost", "act", "hd", "tf", "supp"], "encoding": [" encryption", " encoder", "encode", "decoding", "encusing", "convusing", "enoding", "coder", "convaching", "deccode", "encoded", "continaching", "escapoding", "escapending", "encryption", "encending", "enoder", "escapoder", "cending", " enccode", "convryption", "enending", " encaching", "coding", "decoder", "encaching", " encusing", "enoded", "continoding", "enryption", "convoding", "decryption", "continryption", "escapoded", "continusing", "enccode", "encoder", "coded"]}}
{"id1": "4602568", "id2": "23273706", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"storeImage": ["StoreFile", "saveFile", " storePicture", "StoreImages", "savePicture", "storePicture", "saveImages", "StoreImage", "StorePicture", "storeImages", " storeImages", "storeFile", " storeFile", "saveImage"], "inStream": ["cinView", " inSteam", "inputView", "cinStream", "outSteam", "inView", "fileStream", "inputStream", "fileFile", "fileForm", " inView", "inputSteam", "cinFile", " inForm", "inSteam", "inputFile", "inForm", "fileSteam", "inFile", "cinSteam", "outForm", "outFile", " inFile"], "fileName": ["imagePath", "resourceName", " fileInfo", "FILEname", "FILEPath", "imageName", "FileName", "FileTime", "fileInfo", "imageTime", "Filename", "FileType", "FilePath", "imagename", "filename", "resourceType", "resourceTime", "fileTime", " filename", "resourcePath", "fileType", "imageType", "FILEName", "filePath", " filePath", "imageInfo", "FileInfo", " fileType", "FILEInfo"], "resize": ["renizes", "Ressize", "resizes", "rensize", " resized", "ressize", "Resizes", "renized", "renize", "resized", " resizes", "Resized", " ressize", "Resize"], "rightNow": [" RightNow", "rightNOW", "westToday", " RightNOW", " RightCurrent", "westCurrent", "rServer", "westServer", "westNow", "westThen", "westFuture", "correctFuture", "correctToday", " RightThen", "rightThen", "westNOW", "RightNow", "rightToday", "rNOW", "rightFuture", " rightNOW", "RightFuture", "rNow", " rightFuture", " rightServer", "RightCurrent", "rToday", " rightThen", "rightCurrent", "RightToday", "correctNow", " rightCurrent", " rightToday", "rightServer", "correctNOW"], "dayNamedFolderName": ["dayNamingFolder1", "dayNamedFolderSize", "dayNamedFolderNames", "dayNamedAreaName", "dayNamedDirectoryName", "dayNamedThemeSize", "dayNamingFileName", "dayNamedFileSize", "dayNamedfoldername", "dayNamedfolderName", "dayNamedFileNames", "dayNamedAreaname", "dayNamedDirectory1", "dayNamedDirectoryname", "dayNamingFilename", "dayNamedArea1", "dayNamedFilePath", "dayNamingFolderNames", "dayNamedThemePath", "dayNamedfolderPath", "dayNamingFoldername", "dayNamedThemeNames", "dayNamingFilePath", "dayNamingDirectoryName", "dayNamedFoldername", "dayNamedAreaNames", "dayNamingFileSize", "dayNamedfolderNames", "dayNamingFolderName", "dayNamingDirectory1", "dayNamedFolderPath", "dayNamingDirectoryname", "dayNamingFolderPath", "dayNamedFilename", "dayNamedThemename", "dayNamedThemeName", "dayNamedFileName", "dayNamedfolder1", "dayNamedFolder1", "dayNamingFileNames", "dayNamedDirectoryNames", "dayNamingFolderSize", "dayNamingDirectoryNames"], "uploadDirRoot": ["saveDirParent", "uploaddirroot", "uploadDirectoryroot", "UploadDbroot", "uploadDirPath", "uploadDirectoryRoot", "saveDbRoot", "uploaddirBase", "uploadNetroot", " uploadDirPath", "uploadDbroot", " uploadRelroot", " uploadDirroot", "saveDbroot", "uploadUrlParent", "uploadFolderBase", "uploadDbRoot", "UploadDirRoot", "uploadFolderPath", "saveDirRoot", "uploadDirParent", "uploaddirCover", "UploadDirroot", " uploadRelBase", "UploadDbRoot", " uploadDirBase", "uploadFolderRoot", "UploadDbCover", "uploadRelPath", "uploadFolderroot", "uploadUrlRoot", "uploadDirCover", "uploadDbCover", "uploadDirBase", "UploadDirCover", "uploadNetBase", "uploadUrlPath", "uploadRelBase", "saveDirroot", "UploadDirBase", "uploadRelroot", " uploadRelPath", "uploadDirroot", "UploadDbBase", "uploadDbParent", "uploadDbBase", "uploadRelRoot", "uploadNetRoot", "uploadUrlBase", "uploadDirectoryParent", " uploadRelRoot", "uploaddirRoot", "saveDbParent", "uploadNetCover", "uploadUrlroot"], "file": ["top", "task", "node", "time", "open", "force", "type", "link", "class", "f", "entity", "no", "pool", "folder", "local", "to", "dir", "h", "File", "t", "channel", "resource", "el", "up", "op", "parent", "run", "tree", "key", "null", "name", "get", "page", "ile", "base", "project", "FILE", "source", "port", "table", "work", "full", "handle", "image", "il"], "extension": ["expend", "extendant", "exension", "xtention", "EXTention", "EXTend", "expension", "xtension", "extend", "expensions", "dimension", "xtend", "xtended", "dimendant", "exensions", "expendant", "EXTension", "dimention", "dimensions", "expention", "extention", "extended", "exendant", "exention", "expended", "extensions", "EXTended"], "outFileName": ["outfilePath", "outLogName", "outLogKey", "outLogPath", "infilename", "outFilesName", "outLogname", "outDirName", "outImagePath", "OutfilePath", "OUTLogname", "outFieldSize", "outImageKey", "OutFilePath", "outLinePath", "OutFileKey", "outFileKey", "outLogVersion", "infileType", " outFileNames", " outLineNames", "outImageNames", "infileSize", "outDirPath", "outfileVersion", "OutFilename", "outImageInfo", "OUTFileKey", "OutfileKey", "outFilenamename", "outFilesname", "OUTLogPath", "outFieldPath", "OutFileName", "OUTFieldPath", "outFilenameType", "outDirname", "outfileType", "outFieldType", "outFilenameNames", "outLogNames", " outFileVersion", "Outfilename", "OUTLogKey", "outFilenameKey", "OUTFilename", "outfileName", "OUTFilePath", "inFileName", " outFilename", "outImageName", "outfileKey", "outFileType", "outFileInfo", " outLinePath", "outFilenameVersion", "outFilesPath", " outLogname", "OUTFileName", "outfilename", " outLineInfo", "outFilenameInfo", "outFileNames", "inFileType", "outFieldName", "outFileVersion", "inFileSize", "outLineName", "outLineNames", " outFileInfo", "outfileSize", "OUTFieldName", " outFilePath", "outFilenameName", "OUTFieldname", "OUTLogName", "outFilenameSize", "outLineKey", "outLineInfo", " outLogVersion", " outLogNames", "infileName", "outFilename", "outImagename", "outFileSize", "OutfileName", "inFilename", "outFilenamePath", " outLineName", "outFilePath", "outfileNames", "outLinename", "outFieldname", " outLogName"], "outPathAndName": ["outPathANDName", "outPathOrSize", "outPathandNames", "outPortAndPath", "outPathAndPath", "outPathAndNames", "outPathButKey", "outPathAndSize", "outTimeButName", "outLocationandNames", "outPathAndLike", "outLocationAndSize", "outPathOrTime", "outTimeAndTime", "outLocationandKey", "outPathandKey", "outPathButPath", "outPathOrKey", "outPathOrNames", "outPortAndKey", "outPathOrLike", "outPathandName", "outPathButName", "outPathAndKey", "outPathandPath", "outPathOrPath", "outTimeAndPath", "outPortButName", "outTimeButPath", "outPathandSize", "outPortAndName", "outTimeAndLike", "outPathANDTime", "outPathANDLike", "outLocationAndNames", "outPathButLike", "outTimeButLike", "outPathButTime", "outTimeAndName", "outTimeButTime", "outLocationAndKey", "outPathOrName", "outLocationandName", "outLocationandSize", "outPathANDPath", "outPortButPath", "outLocationAndName", "outPathAndTime", "outPortButKey"], "uploadedFile": ["uploadmedPlace", "uploadifiedFile", "uploadpedUnit", "uploadedFILE", "uploadtedFILE", " uploadedifiedLine", "uploadashedfile", "uploadtedfile", " UploadedFile", "uploadmedGlobal", "presenttedField", "uploadedFormat", "uploaderFile", "uploadedF", "uploadifiedF", " uploadedifiedF", "uploadpedFile", "uploadtedField", "uploadpedF", "uploadededFormat", "uploadededPlace", "uploadedLine", " uploadededUnit", "uploadpedLine", "presentedField", " uploadededFile", " uploadededLine", "presentedFile", "uploadedUnit", " UploadmedGlobal", "uploadashedField", "uploaderfile", "uploadifiedLine", "uploaderFILE", "presenttedFILE", "uploadifiedUnit", " UploadmedFormat", "uploadredFile", "uploadmedFormat", "presenttedfile", "uploadtedFile", "uploadededFile", "uploadedField", " uploadededF", " UploadedFormat", "uploadedfile", "uploadededGlobal", "presentedFILE", "uploadiedUnit", "uploadiedFile", "uploaderField", "uploadredPlace", "uploadashedFILE", "uploadiedLine", " UploadedPlace", "uploadiedF", " UploadmedPlace", "uploadredGlobal", " UploadmedFile", " UploadedGlobal", "presentedfile", "presenttedFile", "uploadashedFile", "uploadredFormat", "uploadedGlobal", " uploadedifiedUnit", " uploadedifiedFile", "uploadedPlace", "uploadmedFile"], "outStream": [" outSteam", " outFile", "oSteam", "outSteam", "inView", "outView", "oStream", "oView", "oFile", "inSteam", "_", "inFile", " outView", "outFile"]}}
{"id1": "16798376", "id2": "12246545", "code1": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["runner", "task", "block", "hello", "apply", "runs", "handle", "Run", "invoke", " Run", "execute", "test", "call", "process", "stop", "service", "go", "command", "submit", "launch", "show", "profile", "work", "start", "cmd", "exec"], "ftp": ["gitping", "ftping", " ftphp", "ffp", "afc", " ftcp", "afl", "wtp", "aftl", " ftz", "wtcp", "ftc", "ftt", "iftz", " ftr", " ftjp", " ftc", "ftxp", "ftz", "ftop", "fft", "aftjp", " fttp", "cttp", "iftxp", "aftping", "fth", "afttp", "aftt", "aft", "wtping", "ctl", " fth", "ftf", "aftz", "iftf", "gitf", "iftt", "aftcp", "iftr", "ftcp", "afping", "afp", "aff", " ftxp", "afth", "aftc", "aftxp", "gitp", "iftjp", "aftop", "iftphp", "ftl", "aftf", "aftr", " ftt", "ftphp", "aftphp", "fttp", "aftp", " ftping", "fftp", " ftop", "ffcp", "ftjp", " ftl", " ftf", "ftr", "gitt", "iftp", "wth", "iftop", "ctcp", "ctp"]}}
{"id1": "10214218", "id2": "14733078", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" encrypted", " encryption", "Encrypted", " encode", "Encode", "encode", "Encryption", "decrypted", "decode", "encryption", "Encrypt", "encrypted", "decryption", "decrypt"], "plaintext": ["preterm", "plainpassword", "plainterm", "preText", " Plaintext", "longtext", "prepassword", " plainterm", "plaincontext", "longcontext", "richcontext", "plainText", " plainText", "richText", "plainprotein", "longprotein", " plainprotein", "pretext", "richtext", " Plainpassword", " plaincontext", " PlainText", "longText", " Plainterm", " plainpassword", "richprotein"], "md": ["dr", "ms", "nd", "msg", "mc", "bd", "od", "me", "metadata", "del", "MD", "grad", "der", "cd", "mg", "deb", "mm", "dm", "mt", "ind", "rm", "red", "sm", "dh", "nt", "det", "e", "ld", "doc", "mb", "d", "dd", " mc", "esm", "mac", "mp", " mo", "mk", "mod", "managed", "dig", "mem", "pd", "m", "mo", "mn", "mand", "cmd", "med", "hd", "ng"], "raw": ["message", "rew", "orig", "unsigned", "n", "buf", "unknown", "valid", "draw", "available", "known", "bare", "row", "hook", "rendered", "clear", "all", "hex", " Raw", "box", "original", "sh", "stream", "bytes", "RAW", "good", "cooked", "result", "custom", "base", "extra", " RAW", "input", "clean", "value", "data", "full", "array", "random", "aw", "out", "Raw", "pack"], "hash": ["message", "json", "rh", "html", "password", "mask", "Hash", "hed", "has", "sha", "id", "ssh", "ashes", "h", "ASH", "total", "alert", "tag", "code", "hex", "key", "sh", "zh", "mac", "shadow", "hidden", "sum", "tr", "href", "result", "print", "check", "bh", "cert", "search", "height", "array", "proof", "handle", "cache", "ash"]}}
{"id1": "1180878", "id2": "23510383", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fectURLStream", "fetchURLStream", "fetchStringStream", "fectUrlData", "fetchGETData", "fetchUrlFrame", "fetchGETFrame", "fectUrlFrame", "fectUrldata", "fectURLFrame", "fetchStringdata", "fetchURLFrame", "fectURLdata", "fetchStringFrame", "fetchStringData", "fetchUrlStream", "fetchGETdata", "fetchUrldata", "fetchGETStream", "fetchURLdata", "fectUrlStream", "fectURLData", "fetchUrlData"], "url": ["path", "http", "mail", "html", "ls", "location", "sl", "link", "ur", "b", "Url", "ul", "address", "URL", "sql", "rel", "pl", "default", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "lim", "gl", "ref", "null", "name", "mount", "xml", "ll", "l", "print", "base", "string", "cl", "file", "log", "domain", "https", "web", "full", "host", "pattern"], "proxyHost": ["roxyOver", "proxyAddress", "slavehost", " proxyCheck", "slaveLabel", "slaveAddress", " proxyAddress", "slaveOver", " proxyhost", "ProxyHost", "roxyCheck", "serverHost", "roxyhost", "slaveCheck", "proxyhost", "slaveHost", " proxyName", "serverhost", "slaveUrl", "proxyUrl", "roxyLabel", "ProxyName", "roxyHost", "ProxyLabel", "Proxyhost", "ProxyUrl", " proxyOver", "proxyOver", "proxyCheck", "roxyAddress", "serverPort", "proxyName", "roxyUrl", "serverName", "proxyLabel", "ProxyPort"], "proxyPort": [" proxyport", "proxyAddress", " proxyPORT", "aliasPort", " proxyAddress", "Proxyport", "ProxyHost", "proxyPORT", "serverHost", "serverport", "aliasAddress", "serverPORT", "serverAddress", "proxyport", "ProxyPORT", "aliasport", "serverPort", "aliasHost", "ProxyPort"], "con": ["bo", "nc", "proc", "cos", "ocon", "connect", "Con", "cone", "const", "close", "cond", "ln", "cal", "cover", "open", "com", "mc", "pan", "gate", "rec", "connection", "non", "ver", "ain", "can", "pen", "cat", "col", "en", "sub", "cs", "conv", "ex", "client", "fin", "xc", "lock", "fc", "syn", "call", "cgi", "canon", "cp", "cons", "fac", "comm", "don", "pc", "go", "bc", "un", "conn", "cont", "trans", "cn", "CON", "cc", "ran", "po", "ctrl", "func", "co", "mo", "cf", "cmd", "act", "conf", "dial", "Conn", "c", "cur"], "is": ["ist", "ims", "ists", "ains", "mis", "im", "ms", "isc", "ais", "abs", "init", "iso", "ris", "es", "dis", "ois", "ri", "sys", "isl", "has", "gets", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "ys", "xs", "are", "cs", "ins", "bits", "ps", "rs", "isf", "ts", "si", "Is", "isin", "fs", "iris", "isp", "iter", "us", "i", "oss", "ios", "s", "sis", "eps", "in", "ip", "was", "isi", "IS"], "u": ["U", " nu", "eu", "cu", "uni", "user", "pu", "ui", "ur", "ul", "tu", "iu", "su", "o", "au", "bu", "uri", "uj", "up", "ou", "uf", "uu", "g", "nu", "uv", "hu", "yu", "uid", "ue", "un", "c", "us", "fu", "mu", "ud", "i", "ut", "ru", "lu"], "proxy": ["bo", "http", "pointer", "cone", "password", "prime", "x", "ping", "timeout", "via", "link", " prox", "echo", "connection", "roxy", "xy", "Proxy", "embed", "address", "pin", " proxies", "pool", "token", "socket", "friend", "ssl", "pro", "map", "client", "pipe", "pse", "server", "browser", "translation", "XY", "slave", "pre", "library", "PRO", "null", "version", "cp", "aco", "phone", "shadow", "policy", "go", "pe", "base", "project", "gp", "port", "domain", "po", "profile", "web", "pi", "py", "https", "jp", "alias", "ip", "host", "cas", "cache", "zip"], "baos": ["naoss", "naows", "poose", "aoOS", " baoss", "BAOs", "vais", "bais", "BAows", "aooS", " bao", " baOs", "bao", "baOs", "vaOS", "aois", "baose", "baoS", " baoS", "naos", "baOS", "BAoss", " baose", "BAo", "vaoS", "poo", " baows", "baows", "aoos", "vaos", "nao", "poOs", "BAos", "baoss", " baOS", " bais", "poos", "BAose"]}}
{"id1": "807346", "id2": "16969205", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"runScript": ["callCode", " runCode", "executeCode", " runProgram", "runProgram", " runscript", "callScript", "executescript", "executeScript", "executeProgram", "callscript", "runscript", "runCode", "callProgram"], "scriptName": ["templateBody", "templateFile", "scriptPath", "ScriptPath", "ScriptName", "criptName", "scriptFile", "criptBody", " scriptPath", "scriptKey", "criptPath", "criptFile", "templatePath", "templateName", " scriptKey", "fileName", "filename", "scriptname", " scriptBody", "scriptBody", "filePath", "ScriptKey", " scriptFile", "fileKey", " scriptname", "Scriptname"], "data": ["output", "buffer", "message", "text", "rew", "json", "missing", "html", "step", "window", "description", "reason", "n", "some", "a", "type", "response", "ata", "title", "raw", "p", "dat", "rel", "comments", "to", "row", "default", "DATA", "t", "video", "alert", "content", "this", "all", "error", "str", "name", "debug", "next", "sequence", "result", "command", "extra", "partial", "input", "action", "source", "string", "padding", "table", "value", "log", "comment", "chain", "results", "info", "what", "empty", "format", "div", "res", "out", "image", "report", "list", "cache"], "url": ["out", "http", "mail", "abs", "sl", "open", "user", "build", "bel", "link", "b", "ur", "lb", "Url", "address", "f", "ul", "URL", "rel", "pl", "ssl", "dl", "uri", "loc", "nl", "resource", "browser", "gl", "str", "mount", "ll", "get", "l", "char", "base", "log", "job", "https", "web", "r", "hl"], "in": ["IN", "on", "din", "gin", "it", "val", "rin", "is", "mc", "body", "en", "inc", "io", "mm", "ind", "al", "ins", "ma", "bin", "serv", "all", "inner", "stream", "isin", "r", "l", "In", "check", "input", "source", "i", "info", " din", "pi", "inn", "out", "act", "mat", "inf", "cin"], "buffIn": ["buffIns", "bufferOut", "BuffedIn", "bufferIns", " BuffIns", "buffCon", " BuffOut", " buffOut", " BuffCon", "BuffOut", " BuffIn", "BuffCon", "bufIn", "bufferIn", "bufferCon", "bufedIn", " buffedIn", "buffOut", "BuffIn", "buffedIn", "bufOut", "BuffIns"], "temp": ["output", "buffer", "fake", "deg", "wr", "cell", "emp", "term", "j", "template", "tmp", "mint", "dat", "variable", "character", "read", "perature", "test", "stem", "t", "pt", "current", "acc", "relative", "length", "tc", "index", "thread", "ptr", "perm", "txt", "sequence", "result", "mod", "porary", "Temp", "tim", "input", "cap", "Temperature", "tem", "i", "cert", "there", "cel", "cur"]}}
{"id1": "16550855", "id2": "8266672", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "label": 0, "substitutes": {"readPage": ["writeArticle", "writePage", " readpage", "printpage", "printPage", "readArticle", "writePages", " readArticle", "readPages", "writepage", "printArticle", "printPages", " readPages", "readpage"], "ignoreComments": ["hideBlocks", "hideComments", " ignoreNotes", " ignoreComment", "ignoreComment", " ignoreBlocks", "ignoreBlocks", "oreLeaks", "oreQuotes", "oreComment", "oreTags", "oreComments", "ignoreTags", "oreBlocks", " ignoreTags", "ignoreQuotes", "hideNotes", "hideTags", "hideQuotes", "ignoreLeaks", " ignoreQuotes", " ignoreLeaks", "hideLeaks", "ignoreNotes", "oreNotes", "hideComment"], "in": ["out", "IN", "on", "din", "con", "add", "init", "it", "cal", "rin", "is", "mc", "ic", "and", "b", "ill", "old", "h", "read", "en", "inc", "io", "from", "mm", "ind", "al", "ins", "client", "ma", "up", "bin", "cm", "all", "inner", "doc", "reader", "get", "isin", "sum", "In", "check", "input", "copy", "m", "again", "i", "mn", " din", "info", "inn", "url", "r", "conf", "thin", "inf", "cin"], "inputLine": ["inName", "helloLo", "resultRecord", "inputName", "indexLin", "inputBlock", "rawRow", "latRow", " inputBlock", "inputRow", "helloLin", " inputCell", "rawLine", "resultLINE", "helloBlock", "helloLINE", "multiLine", "Inputline", "InputBlock", "outputRow", "multiLin", "outputBlock", "inLINE", " inputEntry", " inputLINE", "resultName", " inputRecord", "inputRecord", "outputline", "inputChain", "indexLine", "inputLin", "helloLine", "InputRow", " InputBlock", "multiLINE", " inputNet", " InputEntry", "inputline", "rawline", " inputChain", "helloRow", "inRecord", "helloCell", " inputName", " inputRow", "inputLo", " Inputline", " InputLine", "latLine", "InputLine", "InputEntry", "indexLINE", "inputCell", "latline", "rawChain", "resultLine", "multiLo", "helloNet", "latChain", "inputNet", "inputEntry", "outputLine", "inputLINE", "InputCell", "inLine", "InputNet", "indexLo", " inputline"], "html": ["http", "img", "header", "tt", "human", "available", "title", "css", "att", "alert", "content", "str", "err", "form", "web", "url", "layout", "db", "json", "template", "msg", "has", "built", "f", "enabled", "summary", "md", "details", "HTML", "theme", "https", "data", "output", "multi", "emphasis", "attr", "rss", "pdf", "body", "htm", "h", "hard", "esi", "rendered", "current", "browser", "flash", "xml", "view", "dump", "page", "ht", "result", "hash", "message", "mail", "plain", "hover", "detail", "raw", "p", "api", "pretty", "total", "wrapper", "js", "related", "sg", "value", "full", "format", "height", "embed", "hd", "tml", "cache"]}}
{"id1": "12097948", "id2": "9109613", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"systemID": [" systemId", "privateId", "SystemId", " systemVD", "privateVD", "SystemID", "sysVD", "systemId", " systemName", "sysIDs", "sysId", "SystemIDs", "systemName", "SystemName", "privateName", "systemIDs", " systemIDs", "privateID", "systemVD", "sysName", "sysID"], "id": ["path", "edit", "message", "ident", "ide", "part", "json", "mask", "description", "shape", "internal", "db", "init", "bind", "Id", "it", "link", "ip", "rid", "f", "q", "p", "no", "end", "create", "test", "pid", "uri", "mid", "kid", "iden", "ref", "hide", "ids", "delete", "key", "null", "name", "str", "gd", "aid", "d", "bid", "post", "uid", "one", "md", "form", "base", "sid", "source", "def", "hash", "show", "i", "query", "data", "oid", "layout", "in", "res", "hd", "wire", "ID"], "loader": ["load", "owner", "builder", "loads", "location", "loaded", "user", "pkg", "framework", "class", "manager", "lp", "pool", "parser", "older", "er", "nl", "lc", "qualified", "library", "where", "module", "Loader", "reader", "label", "handler", "container", "l", "cdn", "cl", "loading", "acl", "lr", "layer", "language", "rl", "system", "finder", "context", "hl", "kernel"], "url": ["path", "http", "load", "builder", "mail", "html", "ls", "location", "abs", "or", "sl", "org", "user", "ret", "bel", "link", "ur", "lb", "Url", "f", "address", "ul", "ml", "URL", "rel", "norm", "util", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "browser", "ref", "impl", "str", "name", "mb", "ll", "mount", "xml", "tool", "l", "lr", "rl", "file", "job", "web", "r", "il"], "inStream": ["Instream", " instream", "inputstream", " inSteam", "innSocket", "INstream", "INStream", "intStream", "InSteam", "intSteam", "inView", "innSteam", "onView", "InFile", "inputStream", " inView", "inBlock", " inSocket", "inputSteam", "INView", "inSteam", "innBlock", " inBlock", "inputFile", "intSocket", "onSteam", "innStream", "inFile", "InStream", "onStream", "onstream", "INSteam", "intBlock", "inSocket", "instream", " inFile"], "constraints": ["conStrats", "constsaints", "constats", "conStrains", "costraints", "costats", "costaint", "conStraint", "constrains", "constraint", "constsains", "constains", "constsaint", "costraint", "constaint", "constrats", "conStraints", "constsats", "costrains", "costrats", "costaints", "costains", "constaints"]}}
{"id1": "8932510", "id2": "16572931", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"doPost": [" doPOST", "actionPost", "DoPre", " doPre", "actionPOST", "doPre", "DoPOST", "DoPut", "doPOST", "DoPost", "actionPut", "doPut", " doPut", "actionPre"], "request": ["http", "block", "instance", "change", "requ", "connection", "complete", "re", "error", "form", "Request", "web", "query", "url", "art", "report", "have", "QUEST", "condition", "create", "pair", "this", "forward", "quest", "container", "remote", "project", "object", "document", "search", "memory", "start", "remove", "application", "session", "address", "reset", "frame", "subject", "register", "client", "resource", "current", "server", "xml", "get", "input", "copy", "select", "first", "order", "question", "message", "self", "time", "user", "reference", "initial", "setup", "call", "cgi", "req", "store", "post", "position", "record", "command", "java", "info", "context", "enter"], "response": ["output", "application", "session", "site", "description", "model", "onse", "connection", "send", "reset", "ce", "frame", "respond", "default", "resp", " responding", "write", " Response", "tree", "release", "version", "view", "one", "respons", "event", "Response", "result", "object", "reply", "render", "document", "success", "context", "res", "image", "report", "information"], "is": ["ims", "ists", "mis", "ais", "ms", "isc", "es", "tis", "init", "iso", "ris", "ois", "has", "isl", "bis", "isa", "as", "its", "iss", "ys", "xs", "ins", "bits", "obs", "ips", "si", "Is", "isin", "ir", "iris", "isp", "isi", "icks", "i", "info", "ios", "sis", "in", "ip", "image", "was", "lis", "IS"], "page": ["message", "session", "part", "html", "node", "menu", "link", "title", "address", "proxy", "p", "token", "pool", "o", "row", "wiki", "pages", "frame", "pos", "resource", "server", "browser", "content", "error", "next", "view", "index", "post", "stream", "go", "pc", "result", "form", "pe", "line", "entry", "point", "object", "port", "Page", "file", "table", "po", "sp", "document", "data", "age", "url", "out", "image", "pp", "cache", "article"], "os": ["offset", "ms", "es", "OS", "or", "oos", "iso", "ops", "so", "ui", " o", "pool", "o", "sw", "io", "pos", "op", "ps", "Os", "si", "po", "oss", "ios", "mo", "s", "oid", "res"], "rootUrl": ["parenturl", "parentURL", " rootURL", "parentUrl", "homeUr", "webURL", "rootURL", "baseUr", "baseURL", "baseDir", "webDir", "rootUr", "webUr", "homeUrl", "parentUr", "baseUrl", " rooturl", "rooturl", "homeurl", "rootDir", " rootUr", "homeURL", " rootDir"], "isMultipart": ["isMultiisparted", "isMultispand", "isManIPage", "isMultiplage", "isManIPand", "isManipand", "isMulticart", "isMultiisparts", "isMultiparts", "isMultisparted", "isMultIPand", "isMultiipart", "isMultipage", "isMultiispart", "isManipage", "isMultiplarts", "isMulticarted", "isManIPart", "isMultIPage", "isMultiiparts", "isMultiparted", "isManiparts", "isMultIParted", "isMultipand", "isMultisparts", "isMultIParts", "isMultiiparted", "isManIParts", "isMultiipage", "isMultipland", "isMulticarts", "isMultispage", "isMultiplart", "isMultispart", "isMultiispage", "isManipart", "isMultIPart", "isMulticage"], "rd": ["dr", "rh", "vd", "nd", "hd", "nder", "erd", "rid", "rod", "rer", "rend", "ard", "rc", "hr", "ind", "red", "fr", "rus", "rg", "rand", "rw", "rs", "rt", "ld", "yd", "gd", "dd", "hod", "ord", "ptr", "td", "rr", "dig", "ra", "rob", "rl", "rn", "adr", "ird", "rown", "ud", "ro", "dk", "RD", "xd", "fd", "r", "dra", "rb"], "upload": ["uploads", "load", "own", "update", "Upload", "add", "save", "move", "tmp", "grab", "imgur", "transfer", "util", "download", "create", "execute", "row", "install", "allow", "up", " Upload", "fax", "delete", "ow", "post", "ack", "form", "pload", "input", "archive", "file", "select", "ud", "attach", "art", "aw", "ut", "insert", "image"], "webUrl": ["wwwPath", "webURL", "webVer", "rootURL", "webPort", "rootPort", "Weburl", "weburl", "rootVer", "rootUr", "webUr", "wePort", "rootPath", "weUr", "netPath", "wwwUrl", "weURL", "netURL", "weVer", "wwwURL", "httpPort", "WebUrl", "WebUr", "httpUrl", "netUrl", "wwwUr", "netUr", "webPath", "neturl", "weurl", "httpVer", "weUrl", "httpUr", "WebURL"], "iter": ["ser", "ator", "iver", "iner", "init", "it", "valid", "Iter", "loop", "orient", "IT", "ver", "loader", "inv", "iterator", "dir", "ind", "er", "oper", "iz", "loc", "train", "iv", "where", "inner", "next", "ait", "reader", "inter", "coll", "ipper", "tr", "ter", "ir", "tif", "ner", "former", "fer", "i", "walker", "cer", "kit", "ip", "outer", "li", "order"], "item": ["json", "im", "step", "or", "block", "member", "instance", "it", "link", "attribute", "tab", "local", "row", "iterator", "area", "mm", "element", "Item", "el", "up", "atom", "key", "store", "rule", "error", "module", "unit", "container", "other", "obj", "event", "hit", "record", "base", "entry", "mem", "source", "object", "m", "stat", "status", "file", "value", "option", "info", "in", "ip", "li", "word", "image", "order"], "name": ["path", "part", "on", "block", "term", "n", "prefix", "a", "type", "normal", "class", "title", "old", "id", "no", "common", "o", "local", "size", "num", "channel", "resource", "ma", "NAME", "parent", "ame", "key", "module", "magic", "label", "one", "family", "event", "named", "sequence", "base", "string", "source", "cap", "Name", "file", "names", "data", "alias", "word", "order", "len"], "baos": ["kaoes", "baops", "aoOS", " baoss", " baops", "boOS", "daos", "boops", "bais", "gaoS", "aooss", "booS", "bois", "waoss", "gaOS", "booes", "aooS", " bao", "kaoss", "gaos", "gais", "BAoS", "bao", "booss", "baoes", "BAops", "daOS", "BAis", "baoS", " baoes", "boos", "kaos", "baOS", "BAoss", "daoes", "BAo", "waOS", "wais", "aoos", "gaoss", "BAoes", "BAos", "baoss", "daoss", "kaOS", "waos", "BAOS", "boo"], "wpIs": ["wordpressIm", "hwIs", "wtAre", "phpis", "wordpressUrl", "cpIs", "phpAre", "fwI", "WPUrl", "WPIS", "phpI", "wordpressis", "wtShares", "wpInst", "fwUrl", "fwIm", "xpShares", "xpI", "ipI", "WPI", "hwI", "wpIm", "wpis", "wordpressIS", "phpShares", "wpAre", "xpIs", "WPIm", "wpUrl", "phpIs", "phpIS", "fwIs", "wtIs", "cpis", "ipInst", "wtI", "xpAre", "cpIS", "wordpressIs", "hwIS", "hwInst", "ipIS", "ipIs", "WPIs", "WPInst", "wordpressI", "wpIS", "wpI", "wpShares"], "u": [" nu", "U", "eu", "cu", "it", "uni", "user", "ui", "ur", "ul", "f", "tu", "iu", "su", "p", "o", "io", "au", "gu", "bu", "uri", "uj", "ou", "uf", "uu", "nu", "hu", "uv", "w", "uid", "ue", "l", "us", "mu", "fu", "i", "ux", "url", "r", "ru", "lu"]}}
{"id1": "15971794", "id2": "18489832", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 0, "substitutes": {"getWave": ["setAudio", "setWar", "downloadAudio", "getwave", " getWar", "getAudio", "downloadWave", "setwave", "setWave", " getwave", "getWar", "downloadWar", " getAudio", "downloadwave"], "url": ["path", "out", "http", "ls", "password", "link", "b", "ur", "Url", "f", "ul", "q", "URL", "id", "api", "uri", "dl", "nl", "loc", "server", "v", "fc", "ref", "key", "str", "name", "ll", "fl", "l", "www", "base", "string", "input", "rl", "file", "web", "r", "host", "word"], "Word": ["Token", "Tag", "Work", "Key", "words", "Words", "Letter", "Hack", "bow", "Fix", "Weight", "Field", "wd", "Wr", "wp", "Text", "Term", "stem", "WF", "Po", "Message", "User", "File", "Length", "Password", "Week", "Form", "Nob", "Language", "Bank", "sword", "Wo", "w", "Label", "Wave", "War", "Wi", "W", "Char", "Name", "WC", "wo", "Query", "Part", "Win", "Str", " word", "word"], "FF": [" ff", "FD", " F", "Factory", "FO", "lf", "AF", "EF", "Pref", "f", "Field", "FN", "fi", "FP", "aft", "WF", "FB", "File", "IFF", "IF", "aff", "PF", "uf", "FS", "FL", "Aff", "DF", "UFF", "HF", "CC", "ff", "Temp", "Fi", "FILE", "FC", "UF", "tf", "uff", "F", "fd", "SF", "TF"], "url2": ["strRel", "lTwo", "ls2", " urlTwo", "ls4", "urlTwo", "urlRel", "uriRel", "Url2", "ls1", "url3", "url1", "UrlRel", "uriTwo", "UrlTwo", "l1", "strTwo", "lsTwo", "Url3", "uri2", " url1", "str2", " url4", "uri3", "l4", "l2", "url4", "str3"], "stream": ["path", "buffer", "message", "http", "history", "window", "progress", "now", "sync", "loop", "response", "ST", "feed", "ob", "sc", "console", "read", "sample", "iterator", "row", "size", "sw", "download", "ssl", "conv", "channel", "pipe", "Stream", "fr", " upstream", "v", "steam", "transform", "length", "inner", "src", "REAM", "reader", "view", "dd", "mount", "ream", "tr", "form", "standard", "line", "input", "speed", "source", "iter", "sam", "stack", "chain", "sv", "Steam", "context", "list", "zip"], "Fdel": ["Fdelete", "Fdes", "FDdes", " Fdep", "fDel", "FDel", " Fdes", " Fel", "Fdep", "PFdel", "PFdelete", "FMdep", "FMdel", "fdel", "FDdel", "fdes", "fel", "PFdep", " Fdelete", "Fel", " FDel", "FMDel", "FMdelete", "FDDel", "PFDel"], "outstream": ["newstream", "outputform", "outpipe", "outerstream", "outerpipe", "Outform", "outerfield", "inconsole", "endview", "newconsole", "instore", "upstream", "outerform", " outform", "outview", "outconsole", "outputpipe", "endform", "OutStream", "endconsole", "endstream", " outconsole", "outputstream", "inStream", "Outstore", "outform", "Outconsole", "Outview", "upfield", "uppipe", "Outstream", "newStream", "outfield", "outputfield", " outview", "newstore", "outStream", "outstore", "upform", "instream"], "bwriter": [" bcreator", "binwriter", " bler", "bworker", " bworker", "bWriter", "bener", "rrunner", "cbreader", "bcreator", " bWriter", "Bwriter", "greader", "Breader", " breader", "cbrunner", "Bener", "Bcreator", " bener", "cbworker", "gwriter", "bler", "gWriter", "gler", " brunner", "bincreator", "breader", "rwriter", "rworker", "cbwriter", "brunner", "binener", "BWriter", "binreader", "rreader", "Bler"], "binput": ["obinbutt", "bPut", "obinstr", "bpost", " binPut", "obinoutput", "bincut", " binbutt", " binpixel", "binarycut", "binarybutt", "binaryput", "bput", "binbyte", "binarystr", "binoutput", "boxput", "binaryoutput", "binaryPut", "binarypost", "boxbyte", "obincut", "boxcut", "boxstr", "binpost", " binstr", "binpixel", " binpost", "binarypixel", "obinbyte", "obinpixel", "binPut", " binoutput", "binarybyte", "bstr", "binstr", "binbutt", "obinput"], "len": ["lit", "ls", "lf", "cond", "ln", "n", "val", "den", "del", "ellen", "li", "lan", "lp", "no", "lon", "end", "en", "size", "num", "bl", "ind", "dl", "nl", "pos", "el", "contin", "lim", "bin", "length", "gl", "le", "nt", "all", "ld", "ll", "vec", "fun", "coll", "fl", "Len", "l", "compl", "wid", "kl", "iter", "ell", "log", "wl", "L", "elt", "fin", " le", "hl", "ler", " clen"]}}
{"id1": "9096319", "id2": "4461350", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNoderegainsSite", "handleNoderegainsService", "handleNodeRegainsSite", "handleNodeRegifiedServices", "handleNoderegainedSite", "handleNodeRegalledSite", "handleNodeRegalledServices", "handleNodeRegainsService", "handleNodeRegainedServices", "handleNoderegainedServices", "handleNoderegainsServices", "handleNodeRegifiedService", "handleNodeRegifiedSite", "handleNoderegainedService", "handleNodeRegalledService", "handleNodeRegainsServices", "handleNodeRegainedSite"], "eventID": ["eventName", "serviceUID", "nodeType", " eventName", "eventType", "serviceKey", "EventName", "eventUID", "EventID", "eventId", "nodeName", "EventUID", " eventUID", "nodeUID", "nodeTime", " eventId", "serviceTime", " eventType", "EventId", "EventTime", "eventKey", "nodeKey", " eventKey", "EventType", "nodeId", "serviceId"], "nodeID": ["nodeJS", " nodeInfo", " nodeIDs", " nodeIDE", "nodeid", " nodeid", "resourceName", "volumeID", "odeID", "odeId", "instanceID", " nodeIT", "entityID", "volumeName", "instanceId", "localId", " nodeName", "instanceIDs", " nodeId", "odeIDE", "moduleID", "nodeName", "Nodeid", " nodeJS", "nodeIDs", "moduleid", "nodeIDE", "nodeInfo", "volumeId", "serverIDs", "NodeIDs", "serverID", "NodeID", "NodeIT", "localJS", "resourceID", "NodeId", "resourceId", "serverInfo", "nodeIT", "NodeName", "nodeId", "localID", "moduleIT", "serverId", "entityId", "entityJS", "moduleId", "serverName", "volumeIT", "instanceInfo", "moduleIDE"], "ipAddr": ["ipSendr", "epAddl", "ipStorer", "ipAddsr", "ipAddrt", "ipAcrb", "ipAttp", " ipAddhr", "ipAddrs", "ipIntp", "ipAddsrb", "ipAddp", "epAddressrs", "epAddressl", "ipAddhr", "ipAddri", " ipAttr", "epAddressr", "ipAddrar", " ipAddaddr", "ipAndl", "ipaddrs", "ipAddsrs", " ipAtter", "ipAddressl", "epAddri", "epAddressri", "ipAndp", " ipAddressrs", "ipResrt", "ipAttrar", "ipAddressrar", " ipaddrt", "ipAddresser", "ipResrs", "ipAddl", " ipAddrar", "ipAtter", "ipAddn", " ipAdder", "ipAcn", " ipAddrs", "ipAddrb", " ipAddn", "ipStorehr", "ipaddp", "ipAddaddr", "ipIntaddr", "ipaddl", "ipAndr", " ipAddressaddr", " ipAddl", " ipAddrt", "ipStorers", "ipAddressaddr", " ipAddrb", " ipAttrar", "ipAdder", "ipAcr", "epAddrs", " ipaddrs", " ipAddressr", "ipAddressrs", "ipIntr", "ipAndrs", " ipAddp", "ipaddr", "ipAndrt", " ipaddp", "ipAddressr", " ipAttp", " ipAddressp", "ipAndri", "ipAttr", "epAddr", "ipaddrt", "ipAcrs", "ipResr", "ipStorert", " ipaddr", "ipAddressp", "ipAddressri", "ipSendrar", "ipSendp", "ipAddsn", "ipReshr", "ipIntrs", "ipSender"], "serviceID": ["ServiceKey", "sourceJO", " serviceId", "serviceJO", "ServiceId", "resourceName", "serviceName", "componentNOTE", "securityID", "serviceKey", "ServiceType", "serviceType", "sourceName", " serviceid", "ServiceNAME", "ServiceJO", " serviceNAME", " serviceName", "servid", "ServiceLAN", "resourceType", "securityName", "serviceNOTE", "servName", "ServiceID", " serviceJO", " serviceKey", "servNAME", " serviceNOTE", "Serviceid", "servId", " serviceLAN", "serviceLAN", "servKey", "ServiceName", "resourceID", "resourceId", "servLAN", "componentId", "securityId", "serviceid", "sourceId", "ServiceNOTE", "securityid", "sourceID", "componentID", "serviceNAME", "servID", "serviceId", "componentName", " serviceType"], "eventTime": ["ageType", " eventTimes", "eventtime", "eventTIME", "eventTimes", "eventType", "attributeTime", " eventtime", "attributeType", "ageTIME", "attributeTimes", "ventType", " eventType", "EventTime", "ventTime", "ageTime", "attributeTIME", "EventTIME", "Eventtime", "EventType", "agetime", " eventTIME", "ventTIME", "ventTimes"], "log": ["cell", "se", "config", "it", "ext", "and", "blog", "ome", "t", "channel", "email", "at", "error", "err", "set", "file", "og", "gob", "url", "com", "report", "zip", "db", "json", "ger", "or", "pel", "lo", "msg", "link", "sql", "Log", "util", "row", "pl", "ex", "be", "w", "scale", "l", "net", "entry", "conf", "iam", "en", "low", "use", "crit", "LOG", "lock", "tag", "debug", "xml", "ge", "bug", "message", "mail", "cal", "user", "tab", "cat", "note", "ar", "category", "le", "call", " logger", "store", "event", "cont", "base", "full", "out", "enter", "prot", "de"], "dbConn": ["tableConn", "userConnect", "userConn", "dbObj", "userObj", "bConn", "DbConnect", "bdObj", "dbConnect", " dbCons", "sbCon", "cbConnection", "DBConn", "gbConnect", "fbCon", "sbConnection", "sbConnect", " dbCon", "fbObj", "bConnect", "tableconn", "fbConn", "cbCon", "dbCon", "bdCon", "tableObj", "DbObj", "dbCons", "gbConnection", "DbCon", "userCon", "DBCons", "cbConn", "gbCon", "cbConnect", "dbconn", "gbConn", "Dbconn", "bdConn", " dbConnect", "bdConnect", "tableCon", "DbConn", " dbObj", "bCon", "sbObj", "fbConnect", " dbconn", "sbConn", "bCons", "DBCon", "dbConnection", "DBConnect"], "outageUpdater": ["outageUprager", "outageUpDatter", "outageUpdatedarer", "outageUpnitter", "outageUpdatemaser", "outageUpndATER", "outageUpddaser", "outageUdater", "outageUnndATER", "outageUptaters", "outageUpdbetter", "outageUPditter", "outageUpnarer", "outageUdoder", "outageUpdomer", "outageUpnater", "outageUpnomer", "outageUpDoder", "outageUPdatter", "outageUtdrer", "outageUpnoder", "outageUpdatedATER", "outageUpnter", "outageUpmter", "outageUpDaters", "outageUPtoder", "outageUnnditter", "outageUpmitter", "outageUptaser", "outageUptatter", "outageUPdaser", "outageUpdaser", "outageUpnatter", "outageUpmrer", "outageUpdatetter", "outageUpndater", "outageUpnaters", "outageUpnaser", "outageUndter", "outageUpmetter", "outageUprarer", "outageUplATER", "outageUpdrer", "outageUPdATER", "outageUptater", "outageUdatater", "outageUpmater", "outageUnndter", "outageUnndater", "outageUpdaters", "outageUPtater", "outageUdataser", "outageUpDager", "outageUpndter", "outageUplaters", "outageUdatoder", "outageUPdter", "outageUnditter", "outageUptarer", "outageUpddomer", "outageUpdatemomer", "outageUpdataser", "outageUptager", "outageUndATER", "outageUpddATER", "outageUpDrer", "outageUPtaser", "outageUpdaterarer", "outageUplarer", "outageUdatetter", "outageUpditter", "outageUpdatemATER", "outageUpDATER", "outageUPdater", "outageUPtatter", "outageUtDoder", "outageUpnditter", "outageUPdaters", "outageUpdager", "outageUpDarer", "outageUpdatoder", "outageUdetter", "outageUpdaterater", "outageUPdarer", "outageUplater", "outageUpDater", "outageUpmomer", "outageUpmoder", "outageUPtaters", "outageUpdatedomer", "outageUtDrer", "outageUndater", "outageUpnATER", "outageUptitter", "outageUpmaser", "outageUplitter", "outageUptter", "outageUpdboder", "outageUpDaser", "outageUpdatter", "outageUppoder", "outageUppaser", "outageUpprer", "outageUpraters", "outageUPtitter", "outageUpdetter", "outageUPdoder", "outageUPnaters", "outageUpdateraters", "outageUPnarer", "outageUpdter", "outageUPnATER", "outageUpdarer", "outageUtDaser", "outageUpmATER", "outageUtdaser", "outageUpdoder", "outageUpdatedaser", "outageUpdaterager", "outageUPnater", "outageUpdatedager", "outageUpdatemater", "outageUtdater", "outageUtdoder", "outageUpdbaser", "outageUpdatedater", "outageUprater", "outageUptoder", "outageUpdatedaters", "outageUplter", "outageUpdATER", "outageUtDater", "outageUpdbater", "outageUdaser", "outageUPtter", "outageUppater", "outageUploder", "outageUpddater", "outageUpdatater"]}}
{"id1": "16378239", "id2": "10391753", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"byReference": ["forResource", "ByResource", " byResource", "byResource", "ByRef", " byRef", " byreference", "Byreference", "forRef", "byRef", "forreference", "ByReference", "byreference", "forReference"], "inputStream": ["InputStream", "inputstream", "InputSteam", "readableSteam", "Inputstream", " inputSteam", "inputReader", "readableReader", "inStream", "inputSteam", "inSteam", "InputReader", "inputFile", " inputstream", "inFile", "readablestream", " inputFile", "InputFile", "readableStream", "instream", " inputReader"], "tempFile": ["tempDir", " temporaryFile", "tempChain", " temporaryChain", "tmpFile", "empDirectory", " tempfile", "TempUrl", "TempPath", "TempChain", "TempDir", " tempFiles", "empPath", " temporaryFiles", "poraryName", "tempDirectory", "tmpDirectory", "Tempfile", "tmpPath", "tempFiles", "TempFiles", "poraryfile", "tempPath", " tempChain", "empFile", "tmpName", "poraryUrl", " tempUrl", "tempPlace", "TempDirectory", "tempName", "empName", "poraryDir", "tempUrl", "empfile", "tmpPlace", "poraryFile", "poraryPlace", " temporaryfile", "empPlace", "TempFile", "tmpfile", "tempfile", " tempDir"], "out": ["output", "gr", "cos", "con", "n", "auto", "Out", "ent", "dis", "user", "msg", "sys", "lay", "as", "o", "aos", "to", "os", "io", "OU", "conv", "outs", "t", "ex", "ins", "up", "v", "serv", "ou", "all", "null", "writer", "ao", "one", "l", "sum", "net", "OUT", "source", "again", "us", "file", "oss", "co", "s", "in"]}}
{"id1": "1421557", "id2": "13595251", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "22611968", "id2": "411595", "code1": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"retrieveBitmap": ["retDownloadHeatimage", "retrieveBitMap", "retDownloadHeatmap", "retrieveHeatmap", "retrieveBitimage", "retDownloadHeatMap", "retDownloadBitimage", "retrievebitMap", "retrievebitimage", "retrievebitmap", "retrieveHeatMap", "retDownloadBitmap", "retrieveHeatimage", "retDownloadBitMap"], "urlString": ["urlRest", "UrlString", "uriList", "nameStr", "grabSTR", " urlSTR", "uriString", " urlstring", "urlSTR", "urlstring", "urlStr", "grabString", " urlRest", "imagestring", "urlList", "uriStr", " urlList", "UrlList", "Urlstring", "grabstring", "UrlStr", "imageStr", "nameRest", "namestring", "nameString", "grabStr", " urlStr", "imageString", "imageRest", "UrlSTR"], "bitmap": ["Bitmap", "bitsample", "bitscreen", "BITimage", "Bitimage", "bitsMap", " bitMap", "bitcode", "BITsample", "BITmap", "bitMap", " bitimage", " bitmaps", "bitsmaps", " bitcode", "BITap", "bitmaps", "bitsimage", " bitscreen", "Bitmaps", "Bitscreen", "bitap", "Bitsample", "bitimage", " bitap", "Bitap", "BITcode", "BITMap", "BITscreen", "Bitcode", "bitsmap", " bitsample", "BitMap"], "url": ["http", "con", "ls", "abs", "ol", "sl", "open", "build", "bel", "link", "ur", "b", "Url", "f", "ul", "URL", "ssl", "uri", "dl", "loc", "client", "nl", "resource", "atl", "browser", "name", "str", "ll", "cp", "get", "service", "l", "char", "log", "https", "cert", "cmd", "r", "il"], "conn": ["ch", "nc", "proc", "out", "connect", "con", "Connection", "addr", "close", "init", "open", "dial", "sys", "connection", "ct", "socket", "dat", "enc", "to", "col", "ssl", "pas", "conv", "pos", "client", "resp", "fin", "serv", "nt", "syn", "cp", "cb", "comm", "cons", "coll", "exec", "cont", "ctx", "cn", "cert", "jp", "res", "cmd", "act", "soc", "Conn", "c", "cur"]}}
{"id1": "17296916", "id2": "8754809", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"logging": [" loging", "Loging", "LogStorage", "debugger", "Logging", " logger", "debuging", "Logger", "logStorage", "debugStorage", "logger", " logStorage", "loging", "debugging"], "wrap": ["message", "rap", "shape", "wind", "ew", "window", "x", "add", "force", "build", "link", "gate", "xf", "me", "ad", " wrapper", "wa", "root", "ws", "reset", "sw", "create", "read", "use", "wrapper", "transform", "box", "ow", " wrapped", "store", "nw", "w", "get", "inter", "form", "W", "grow", "python", "parse", "chain", "sp", "web", "find", "work", "pad", "wra", "safe", "format", "we", "handle", "aw", "start", "word", "wire", "pack", "wx", "zip"], "buffer": ["output", "bo", "message", "Buffer", "binary", "builder", "face", "window", "block", "phrase", "template", "buf", "button", "header", "database", "bar", "attribute", "reference", "body", "ob", "console", "complete", "reset", "row", "size", "bb", "queue", "frame", "note", "buff", "wrapper", "library", "flag", "store", "writer", "flash", "pb", "view", "position", "screen", "bridge", "quote", "sequence", "directory", "print", "command", "batch", "line", "base", "iter", "layer", "table", "reply", "profile", "surface", "document", "display", "append", "memory", "trace", "word", "report", "cache"], "encoding": ["ecoder", "clanguage", "enumoding", "enoding", "ecryption", "coder", "cryption", "encoded", "enumoder", "cododer", "enumlanguage", "encryption", "enaling", "enclanguage", "enoder", "caling", "encaling", "encging", "cging", "ecoding", "coding", "enumging", "enoded", "enryption", "Encaling", "Encoder", "Encryption", "enging", "cododing", "ecoded", "encoder", "codryption", "Encoding", "enlanguage", "cododed"], "getEncoding": ["getExpging", " getEncging", "getOrigination", "getEnling", "getEncression", "getEncryption", "getExpryption", "getencoding", "getExpoding", "getencling", "getEncination", " getEnging", " getEnling", "getEnging", " getEncination", " getEnoding", " getEnination", "getencging", "getencryption", " getEncression", " getEnression", " getEnryption", "getEnryption", "getencination", "getOrigling", "getOrigryption", "getExpression", "getEnination", "getOrigoding", "getEnoding", "getEnression", "getencression", "getEncging", " getEncling", "getEncling", " getEncryption"], "headers": ["ters", "limits", "properties", "head", "users", "header", "ppers", "ports", "checks", "weights", "params", "drivers", "comments", "images", "writers", "frames", "boxes", "pins", "tags", "ers", "rs", "ctors", "styles", "holders", "authors", "builders", "ids", "codes", "terms", "chains", "keys", "values", "heads", "reports", "fields", "relations", "pres", "modules", "names", "blocks", "groups", "caps", "ilers", "members", "objects"], "is": ["ist", "ims", "ists", "mis", "ais", "ms", "isc", "tis", "or", "iso", "ris", "dis", "ois", "ic", "sys", "isl", "ui", "has", "nis", "lis", "ri", "bis", "osi", "bs", "isa", "as", "its", "iss", "os", "does", "ys", "ins", "obs", "isf", "\u00eds", "si", "Is", "isin", "isd", "fs", "iris", "us", "i", "ios", "sis", "in", "ip", "was", "isi", "IS"], "bos": ["bot", "bo", "cos", "oops", "nos", "ms", "tis", "oos", "banks", "jas", "des", "ows", "sys", "uts", "ui", "bis", "lets", "bs", "stats", "dos", "aos", "uds", "os", "ses", "boards", "ys", "cs", "ots", "obs", "bits", "ubis", "ps", "bones", "bin", "ones", "pod", "js", "bas", "ods", "bi", "bes", "eros", "fits", "oids", "bytes", "tops", "fs", "ols", "los", "oss", "tes", "bh", "ios", "ts", "windows", "soc", "isi"], "e": ["ev", "es", "x", "se", "n", "exc", "a", "ie", "me", "f", "p", "o", "h", "eeee", "en", "re", "ed", "ex", "er", "t", "ee", "v", "E", "le", "oe", "g", "error", "ate", "d", "ae", "err", "m", "ne", "i", "ge", "r", "c", "de"]}}
{"id1": "11341711", "id2": "812803", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makebackups", "createbackups", "makeDups", "makeDpoint", "createbackupid", "createBackup", "makeStpoint", "makebackup", "makebackpoint", "createbackpoint", "createBackups", "makeStups", "makebackupid", "createBackpoint", "makeBackpoint", "makeBackupid", "makeDupid", "makeStupid", "makeDup", "makeBackups", "createbackup", "makeStup", "createBackupid"], "dir": ["path", "disk", "dr", "db", "mail", "window", "or", " d", "vol", "addr", "dis", "draw", "pkg", "tmp", "handle", "del", "dat", "y", "wd", "folder", "local", "direct", "rad", "dm", "ind", "dep", "dl", "loc", "src", "dist", "store", "DIR", "doc", "dd", "d", "Directory", "md", "ir", "directory", "Dir", "base", "iter", "file", "data", "fd", "in", "url", "out", "zip"], "sourcedir": ["isourcedr", " sourcesir", "isourcer", "sourcesel", "senderr", "sourcedirs", " sourcesirs", "sourcedr", "sourceirs", "senderel", "sourcedire", "sourcesirs", "senderdir", "senderir", "sourcesire", "soreddir", "sourcesdir", "sourceir", "soredire", "soredir", "isourcedir", "sourceddir", "sourcesir", "isourceddir", "sourceel", " sourceddir", " sourcedire", "sourcer", " sourcesire", "sourcesr", "soredirs", "isourcedel", "sourceire", " sourcesdir", " sourcedirs", "sourcedel", "isourceel", "isourceir"], "destinationdir": ["estinatordb", "destensionfolder", "destinatorfolder", "stinationir", "stinationdir", "destinationsdb", "destensiondir", "destinatordir", "stinationsir", "destinatordiv", "destinationdiv", "estinationDir", "destiondb", "destiondir", "stinationdb", "stinationsdiv", "destensionDir", "destionfolder", "stinationsdir", "destineddb", "destinationsdiv", "destineddir", "stinationsdb", "destinationfolder", "estinatorfolder", "destinationsir", "destensiondb", "destinationdb", "destinedir", "destinatorir", "estinationfolder", "destinationDir", "estinatorDir", "destinatorDir", "destinatordb", "destineddiv", "destinationsdir", "estinationdb", "estinationdir", "estinatordir", "stinationdiv", "destionDir", "destinationir"], "destinationDirEnding": ["destinationDirEndging", "destinationDirFeediting", "destinationDirectoryEnding", "destinationDirectoryEnder", "destinationFileEveniting", "destinationDirectoryENDing", "destinationDirServing", "destinationDirEnder", "destinationDirENDding", "destinationDirENDing", "destinationDirectoryEndging", "destinationDirectoryENDding", "destinationDirENDer", "destinationFileEnditing", "destinationDirEveniting", "destinationDirENDiting", "destinationDirEvenging", "destinationDirectoryENDer", "destinationDirEvending", "destinationFileEnding", "destinationDirENDging", "destinationFileEvener", "destinationDirFeedING", "destinationDirFeeder", "destinationDirServging", "destinationFileEnder", "destinationDirFeeding", "destinationDirEnditing", "destinationDirectoryENDging", "destinationDirEvenING", "destinationDirServer", "destinationDirectoryEndding", "destinationDirEndding", "destinationDirServding", "destinationDirENDING", "destinationFileEndING", "destinationFileEvening", "destinationDirEndING", "destinationDirEvener", "destinationDirEvening", "destinationFileEvenING"], "files": ["uploads", "states", "faces", "assets", "strings", "ls", "links", "words", "parents", "plates", "headers", "users", "types", "ports", "prints", "facts", "iles", "lets", "bs", "images", "Files", "params", "its", "sections", "qs", "forms", "pages", "tests", "items", "lines", "obs", "filename", "classes", "actions", "ids", "features", "fixes", "ames", "bytes", "keys", "mails", "errors", "values", "fs", "projects", "parts", "details", "reports", "tools", "fields", "file", "resources", "docs", "modules", "names", "issues", "events", "members", "objects", "list"], "checkdir": [" checkdirectory", "checkir", "getfolder", "Checkfolder", "keydb", "getdir", " checkurl", "Checkir", "keydir", " checkdb", "checkeddir", "checkroom", "checkurl", "Checkblock", "workurl", " checkfolder", "ckthis", "keyfolder", "Checkroom", "checkblock", " checkblock", "Checkdb", "checkthis", "checkeddirectory", "workdir", "getdb", "keyroom", "Checkdir", "ckroom", "checkedDir", "checkdb", "ckdb", " checkthis", "checkeddb", "workDir", "checkedfolder", "ckDir", "checkfolder", "getblock", "ckdir", " checkir", "ckdirectory", "ckfolder", "checkedir", "Checkdirectory", "checkdirectory", "workthis", "CheckDir", "checkDir", "ckurl", " checkDir"], "date": ["close", "add", "iso", "time", "now", "cal", "user", "te", "msg", "zone", " Date", "dat", "ATE", "late", "dt", "note", "use", "month", "resource", "Date", "tag", " day", "key", "doc", "ate", "d", "day", "get", "none", "today", "event", "set", "file", "year", "data", "start", "diff", "de", "when"], "msec": [" mstr", "mstr", "mtstr", " msc", "cmsec", "gmsec", "MSec", "Msec", "mtcl", "cmisec", "msc", "mSec", " mcl", "mtisec", "mtct", "gmSec", "Mct", " mSec", "misec", " mct", "mcl", "cmsc", "gmsc", "mtsec", " misec", "mtsc", "gmstr", "mct", "cmcl", "mtSec"], "checkFile": ["readFiles", "CheckFILE", "readFile", " checkFiles", "readFILE", "CheckFiles", "updateFiles", "readfile", "readSourceFile", " checkSourceFile", "checkSourceFile", "Checkfile", "checkfile", "CheckFile", "updateSourceFile", "checkFILE", "updateFile", "checkFiles", "updateFILE", " checkfile", " checkFILE"], "i": ["multi", "im", "zi", "x", "j", "init", "phi", "it", "my", "ini", "ai", "is", "ic", "ie", "ui", "ri", "me", "major", "iu", "id", "y", "io", "ci", "mi", "gu", "ki", "ex", "ind", "ii", "qi", "gi", "hi", "key", "ti", "bi", "ji", "name", "index", "si", "I", "sequence", "ei", "base", "batch", "m", "xi", "cli", "iq", "di", "sim", "pi", "info", "exp", "ij", "in", "ip", "li", "ix"], "f": ["bf", "lf", "j", "fo", "fe", "fg", "b", "p", "o", "fi", "fp", "ft", "t", "fr", "fb", "v", "fc", "uf", "e", "d", "fl", "fac", "l", "u", "fs", "m", "df", "file", "fw", "F", "cf", "fd", "tf", "fa"], "g": ["j", "config", "msg", "graph", "fg", "b", "gs", "pg", "p", "eg", "mg", "gy", "gu", "t", "gg", "cfg", "v", "G", "gi", "gl", "e", "bg", "group", "gd", "d", "gb", "w", "l", "ig", "go", "vg", "ga", "gc", "gm", "m", "gp", "file", "tg", "og", "s", "ge", "out"], "destinationFile": ["destarationFiles", "destationFiles", "DestationFiles", "destinatorDirectory", "destinatedFile", "destationEmail", "destinateEmail", "DestationFile", "destarationDirectory", "destinatorFilename", "destarationFilename", "destationFilename", "destinationsFiles", "destinationsFile", "DestinationFilename", "transinatedFiles", "transinatedDirectory", "destinatorFile", "destinationFiles", "transinationDirectory", "destinatedFiles", "destinatedDirectory", "transinationFile", "transinationFiles", "transinatedFile", "destinationsFilename", "destarationFile", "destinatedFilename", "destinateFilename", "destinateFiles", "transinationFilename", "transinatedFilename", "destinationFilename", "DestinationFiles", "destinationsEmail", "DestationFilename", "destinationEmail", "DestinationFile", "destationFile", "destinationDirectory", "destinateFile", "DestinationEmail", "destinatorFiles", "DestationEmail"], "sourceFile": ["ourceFile", "Sourcefile", "ourcefile", "sourceLine", " sourceFILE", "sourceFiles", "staticFile", "sourceFILE", "SourceFilename", "ourceLine", "srcLine", "srcFile", " sourcefile", "SourceFiles", "staticfile", "sourceFilename", "srcfile", "srcFilename", "staticFILE", "SourceLine", "SourceFILE", "ourceFilename", "staticFiles", "sourcefile", " sourceFiles", "SourceFile"], "infile": ["Instream", " instream", "INfile", "pinline", "outFile", "INline", "pinfield", "inblock", "INFile", "inputblock", "insblock", "InFile", "Infile", " inline", "infield", "insFile", "inline", "insfile", "inputline", " inblock", " infield", "inputFile", "pinFile", "INfield", "insstream", "pinfile", "inFile", "Inblock", "outblock", "outline", "inputfile", "instream", " inFile"], "outfile": ["Outfile", "outerstream", " outline", " outbuffer", "inlink", "outpage", "outlink", " outFile", " outlink", "outview", "outputfile", "outputline", " outstream", "OutFile", "outputstream", "Outlink", "outerbuffer", " outpage", "inline", "outstream", "inpage", "outputpage", "inview", "Outstream", "outerview", "inFile", " outview", "inbuffer", "outline", "outFile", "outerfile", "outbuffer", "instream"], "c": ["ch", "nc", "cos", "C", "cu", "close", "x", "n", "a", "mc", "uc", "\u00e7", "ct", "count", "sc", "y", "cd", "rc", "o", "p", "col", "ce", "cs", "t", "lc", "unc", "ac", "v", "cm", "cr", "e", "code", "ec", "d", "cp", "dc", "cb", "char", "r", "k", "pc", "err", "bc", "u", "gc", "cl", "m", "cc", "z", "arc", "chain", "cf", "out", "conf", "ca", "cache"]}}
{"id1": "22503685", "id2": "20208819", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"readGeoParserResult": ["readGeoParserResults", "readGeaReaderResponse", "readGeoParserResponse", "readGeoarserRecord", "readGeoHandlerRecord", "readGeoReaderResponse", "readGeoHandlerResponse", "readGeoReaderResult", "readGeoarserResults", "readGeaReaderResult", "readGeoParserRecord", "readGeaParserResponse", "readGeaReaderRecord", "readGeoarserResponse", "readGeoReaderResults", "readGeaParserResult", "readGeaParserRecord", "readGeaParserResults", "readGeoarserResult", "readGeoReaderRecord", "readGeoHandlerResults", "readGeaReaderResults", "readGeoHandlerResult"], "recordContent": ["resourceText", "recordName", "resourceName", "RecordContents", "RecordContent", "recordData", "resourceString", "RecordText", "recContents", "recContent", "recData", "recordString", "RecordString", " recordText", " recordData", "RecordName", " recordName", "RecordData", "recordText", " recordContents", "resourceContent", " recordString", "recordContents", "recText"], "getGazeteerIds": ["getGazeteerNeedl", "getGazeteerByIds", "getGazeteerCounts", "getGazeteerNeeds", "getGazeteersIdl", "getGazeteerLoges", "getGazeteersByIdls", "getGazeteerByIdls", "getGazeteerCountes", "getGazeteerLogids", "getGazeteerNeedls", "getGazeteerCountl", "getGazeteerIdl", "getGazeteersIds", "getGazeteersIders", "getGazeteerIders", "getGazeteersIdes", "getGazeteerLogs", "getGazeteerInts", "getGazeteerByIdes", "getGazeteerByIders", "getGazeteerCountls", "getGazeteersByIdes", "getGazeteersByIdids", "getGazeteerLogers", "getGazeteersByIds", "getGazeteersIdids", "getGazeteerNeedes", "getGazeteerIdls", "getGazeteerByIdl", "getGazeteerIntes", "getGazeteerIntids", "getGazeteerByIdids", "getGazeteersByIders", "getGazeteerInters", "getGazeteerIdes", "getGazeteersByIdl", "getGazeteersIdls", "getGazeteerIdids"], "ret": ["lit", "arg", "reg", "buf", "rets", "ext", "tmp", "et", "ry", "opt", "reset", "test", "re", "mt", "rm", "att", "red", "Return", "t", "ft", "arr", "ar", "rg", "continue", "nt", "ref", "uf", "rt", "alt", "ts", "ll", "ert", "mb", "get", "r", "tr", "txt", "net", "Ret", "result", "cont", "print", "gc", "mem", "gt", "def", "set", "RET", "cert", "res", "out", "repl", "usr", "cur"], "retries": [" retriers", " retrys", "attries", "triers", "attrys", "attriers", "interies", "altrying", "attrying", "alties", "altries", "retriers", "interrying", "retrying", "interries", "reties", "altrys", " retrying", "trys", "trying", "ties", "tries", "interrys", "retrys"], "reqPre": ["reqPRE", "requestPRE", "requestPost", "requestPre", "RequestPRE", "RequestPre", " reqpre", "questPre", "questPRE", "RequestPost", "questpre", "reqpre", "requestpre", " reqPRE", "reqPost", " reqPost", "Requestpre"], "outputFormat": ["inputForm", "inputformat", "Outputformat", "outputType", "outputformat", "OutputType", " outputformat", "inputFormat", "OutputFormat", "outputForm", " outputType", "inputType", "OutputForm", " outputForm"], "doc": ["dr", "db", "json", "html", "window", "org", "pub", "msg", "ml", "body", "norm", "ds", "h", "dir", "desc", "js", "content", "tree", "du", "str", "xml", "unit", "comm", "dc", "Doc", "dec", "cam", "good", "md", "dict", "mk", "form", "def", "m", "date", "tx", "file", "parse", "di", "exp", "document", "py", "data", "Document", "div", "res", "man", "ad", "DOC"], "url": ["http", "ls", "addr", "sl", "org", "hub", "bel", "link", "ur", "Url", "ul", "address", "socket", "URL", "loader", "api", "parser", "au", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "ref", "str", "xml", "ll", "l", "char", "conn", "base", "rl", "file", "web", "https", "cert", "r", "hl"], "reader": ["buffer", "builder", " Reader", " parser", " loader", "loader", "parser", "read", "er", "resource", " read", "writer", "handler", "stream", " data", "Reader", " r", "input", " readers", "file", " scanner", "driver", "data", "r", " writer", " resource"]}}
{"id1": "15241397", "id2": "16719805", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "DoGET", "Doget", "doGET", "DoPut", "doget", "DoGet", "handleGet", "handlePut", "doPut", " doPut", "handleget", " doget"], "request": ["each", "message", "http", "application", "QUEST", "hello", "user", "attribute", "connection", "address", "reference", "complete", "reset", "create", "frame", "re", "client", "initial", "current", "server", "transform", "setup", "forward", "req", "quest", "get", "position", "command", "input", "Request", "the", "document", "query", "in", "start", "context", "report", "first", "question"], "response": ["output", "ve", "message", "http", "application", "site", "session", "json", "description", "block", "fire", "onse", "connection", "send", "body", "console", "reset", "ce", "frame", "respond", "answer", "resp", "resource", "server", "content", "exit", "write", "version", "next", "xml", "view", "service", "position", "page", "Response", "result", "sequence", "form", "print", "object", "status", "reply", "document", "success", "context", "res", "image", "report", "network"], "rewrittenQueryString": ["rewartedQueryStream", "rewrittenquerystring", "rewwrittenquerystring", "rewrittenURLString", "rewartedHeaderStr", "rewwrittenqueryStr", "rewartedHeaderStream", "rewliedqueryStr", "rewrittenQuerystring", "rewwrittenQueryStr", "rewrittenqueryStream", "rewrittenURLstring", "rewrittenQuStr", "rewwrittenQueryString", "rewrittenURLStr", "rewliedqueryStream", "rewwrittenqueryString", "rewartedQuerystring", "rewrittenHeaderString", "rewrittenRequestQuery", "rewartedQueryString", "rewrittenRequeststring", "rewrittenURLStream", "rewwrittenqueryQuery", "rewliedQueryString", "rewrittenHeaderStream", "rewartedHeaderstring", "rewrittenQuestionString", "rewliedqueryString", "rewrittenHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentQuery", "rewliedQueryStr", "rewrittenCurrentStr", "rewrittenHeaderStr", "rewrittenQueryQuery", "rewartedQueryStr", "rewrittenQueryStream", "rewrittenqueryQuery", "rewliedQueryStream", "rewrittenQuString", "rewrittenqueryStr", "rewrittenQuStream", "rewwrittenQuerystring", "rewartedHeaderString", "rewrittenQuestionStr", "rewrittenQueryStr", "rewrittenQustring", "rewrittenRequestString", "rewrittenCurrentstring", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenqueryString", "rewrittenRequestStr"], "rewrittenUrl": ["rewwrittenPort", "rewriddenURL", "rewroteLink", "RewwrittenString", "rewriteurl", "RewrittenUrl", "RewrittenPosition", "rewrownURL", "rewwrittenUrl", "rewrapedUrl", "rewittenURL", "RewrittenString", "rewroteUr", "RewwrittenLink", "Rewwrittenurl", "RewwrittenUrl", "rewartedPosition", "RewwrittenURL", "RewrittenUr", "rewedUrl", "rewrownUrl", "rewrapedURL", "RewwrittenPosition", "rewrittenPort", "rewrownUr", "rewroteurl", "rewrapedPort", "rewedString", "RewrittenPort", "rewriddenPosition", "rewrittenLink", "rewartedUrl", "rewrittenUr", "RewrittenLink", "rewittenUrl", "Rewrittenurl", "rewriteUrl", "rewriterString", "rewartedUr", "rewriterUr", "rewittenurl", "rewrownPosition", "rewwrittenUr", "rewadjustedUrl", "rewrittenString", "RewwrittenPort", "rewadjustedPort", "rewwrittenURL", "rewwrittenLink", "rewartedURL", "rewrotePosition", "rewwrittenPosition", "rewrittenurl", "rewedUr", "rewadjustedUr", "rewriddenUrl", "rewroteURL", "rewriteURL", "rewedURL", "rewriteUr", "rewadjustedURL", "rewwrittenString", "rewriterURL", "rewartedurl", "rewwrittenurl", "rewrapedUr", "rewrittenPosition", "rewittenLink", "rewriddenUr", "rewroteUrl", "RewrittenURL", "rewriterUrl", "rewrittenURL", "RewwrittenUr"], "httpURLConnection": ["HttpURLConnection", "httpURLConnect", "httpUrlApplication", "HttpURLConnect", "ttpURLConnect", "HttpHTTPConnect", "httpSRApplication", "httpHTTPConnect", "ttpUrlConnect", "ttpUrlConn", "ttpUrlApplication", "httpURLApplication", "httpFileConn", "httpURLConn", "ttpURLApplication", " httpUrlApplication", "httpUrlConfiguration", "HttpURLApplication", "httpMLConnect", "HttpHTTPConfiguration", "httpHTTPControl", "httpMLconnection", "httpUrlConnect", "ttpURLConnection", "httpHTTPconnection", "httpURLControl", "ttpUrlconnection", " httpUrlConnection", "ttpUrlControl", "httpRLConnect", "httpRLconnection", "httpFileConnection", " httpUrlconnection", "httpHTTPConn", "HttpUrlConnect", " httpUrlConnect", "httpURLconnection", "httpFileApplication", "httpHTTPConnection", "ttpURLConn", "HttpUrlconnection", "httpSRconnection", "httpURLConfiguration", "HttpHTTPConnection", "httpMLApplication", "ttpURLconnection", "httpMLConnection", " httpURLconnection", "httpSRConnect", "httpSRConnection", "ttpUrlConnection", "httpSRControl", " httpURLConnect", "httpUrlConnection", "httpHTTPConfiguration", "httpUrlconnection", "HttpURLconnection", "HttpUrlConnection", "httpHTTPApplication", " httpURLApplication", "HttpURLConfiguration", "ttpURLControl", "HttpHTTPconnection", "httpFileConnect", "httpRLConnection", "httpSRConfiguration", "httpUrlControl", "httpUrlConn", "HttpHTTPApplication", "httpRLApplication"], "header": ["field", "buffer", "dr", "part", "core", "term", "block", "init", "prefix", "head", "section", "user", "peer", "headers", "shift", "detail", "attribute", "heading", "metadata", "title", "zone", "filter", "address", "holder", "state", "token", "variable", "h", "relation", "er", "feature", "client", "argument", "wrapper", "tag", "component", "operator", "rule", "version", "handler", "hidden", "policy", "ter", "page", "event", "line", "meta", "check", "hash", "Header", "layer", "status", "padding", "device", "port", "comment", "option", "info", "query", "format", "column", "handle"], "value": ["field", "VALUE", "message", "expression", "text", "json", "description", "password", "save", "hello", "val", "instance", "des", "attribute", "zone", "see", "example", "property", "address", "sample", "create", "test", "default", "element", "current", "server", "v", "email", "content", "pair", "Value", "key", "version", "label", "name", "unit", "ue", "values", "vector", "sequence", "record", "entry", "string", "hash", "language", "python", "job", "comment", "sv", "data", "format"], "inputStream": ["InputStream", "outputSteam", " inputThread", "inputWindow", "inputstream", "inputView", "errorSteam", "errorWindow", " inputLoop", " inputSteam", "InputView", "InputLoop", "outputstream", "inputThread", "inputSteam", "outputView", "outputLoop", "outputThread", "inputLoop", "InputThread", " inputWindow", "errorstream", " inputstream", "errorStream", " inputView", "outputWindow"], "outputStream": ["outputSteam", "responseLength", " outputLength", "inputstream", " outputForm", "inputView", "displayView", "displaySteam", "displayStream", "OutputLength", "outputForm", "responseSteam", "outputstream", "OutputSteam", "responseStream", "outputLength", "inputSteam", "outputView", "displaystream", " outputstream", "OutputStream", "responseForm", " outputSteam", "OutputForm", " outputView"]}}
{"id1": "3401153", "id2": "22401746", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getHTML": ["getJS", " getJS", "processHTML", "printJS", "processJS", " getURL", "printHTML", " getPDF", "getPDF", "printPDF", "getURL", "processPDF", "processURL", "printURL"], "pageURL": ["baseURI", "pageurl", " pageUrl", "cacheURI", "baseURL", "pageURI", " pageurl", "cacheUrl", "cacheURL", " pageUR", "baseUrl", "Pageurl", "PageURL", " pageURI", "PageURI", "PageUrl", "cacheurl", "PageUR", "pageUrl", "pageUR", "baseUR"], "encoding": ["Encaching", "ecoder", "decoding", "decuation", "enoding", "enuation", "Encuation", "encoded", "uncoding", "enaching", "enoder", "uncaching", "ecoding", "ecaching", "uncoder", "encaching", "decoder", "Encoder", "ecoded", "Encoded", "encoder", "decaching", "encuation", "Encoding", "uncoded"], "dirPath": ["pathDir", "viewName", "pkgDirectory", "folderRoot", "viewPATH", "dirRoot", "pathRoot", " dirRoot", "pkgDir", "pathFile", "viewDir", "directoryDirectory", "folderDir", "pkgPath", "directoryPath", " dirFile", "directoryPATH", "dirFile", "pathPath", " dirDirectory", "directoryDir", "dirDir", "dirPATH", "dirName", "folderFile", "directoryName", " dirPATH", " dirName", "viewPath", " dirDir", "pkgName", "dirDirectory", "folderPath"], "pageHTML": ["viewJSON", "searchHT", "pointHTTP", "componentHTML", "PageHTTP", "viewMD", "pointHTML", "agePUT", "componentHT", "pageJS", "viewHTML", "entryJS", "ageWP", " pageAPI", "searchHTML", "ageHT", "PageJS", "PageHT", "pagePUT", " pageHTTP", "searchJS", " pageWP", "componentSQL", "PageHTML", "ageSQL", "entryHTML", " pagePUT", "pageAPI", "entryAPI", "pageSQL", "entryHTTP", "pointJS", " pageJS", "pageMD", "searchURL", "displayHTML", "displayJS", "pointAPI", " pageJSON", "pageHT", "ageHTML", " pageMD", "pageJSON", " pageHT", "displayURL", "componentWP", "PageURL", " pageSQL", "pageHTTP", "viewPUT", "pageWP", "displayHTTP", "ageJSON", "ageMD"], "connection": ["bo", "nc", "message", "http", "session", "connect", "application", "ion", "Connection", "con", "description", "close", "open", "user", "link", "database", "response", "generation", "condition", "statement", "processor", "internet", "reference", "socket", "console", "character", "to", "relation", "io", "creator", "uri", "client", "resource", "channel", "current", "server", "browser", "library", "creation", "government", "communication", "operation", "writer", "engine", "still", "number", "established", "position", "connected", "directory", "conn", "remote", "command", "entry", "web", "document", "c", "network"], "url": ["path", "http", "ls", "location", "sl", "open", "bel", "link", "b", "Url", "f", "address", "ur", "ul", "URL", "p", "loader", "rel", "api", "ssl", "uri", "dl", "nl", "atl", "resource", "client", "gl", "google", "name", "str", "ll", "get", "l", "net", "conn", "base", "rl", "https", "web", "r"], "br": ["ch", "wr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "bs", "BR", "bl", "hr", "bb", "pr", "er", "fr", "bt", "Br", "cr", "bro", "be", "str", "gb", "vr", "mr", "tr", "bridge", "bc", "sr", "lr", "bh", "sp", "kr", "ber", "r", "rb"], "line": ["field", "style", "text", "cell", "block", "lin", "phrase", "ln", "section", "user", "eline", "detail", "link", "entity", "row", "sample", "frame", "stay", "nl", "liner", "email", "continue", "le", "code", "inline", "ine", "label", "LINE", "number", "l", "quote", "page", "online", "sequence", "entry", "string", "print", "source", "point", "stroke", "log", "comment", "range", "chain", "word", "Line"], "e": ["ve", "ite", "es", "x", "se", "ent", "te", "fe", "ie", "ze", "see", "f", "je", "p", "eeee", "xe", "ce", "en", "re", "ke", "ed", "er", "ex", "ee", "E", "le", "oe", "eb", "ine", "esome", "be", "error", "ode", "he", "ue", "ae", "err", "event", "pe", "ne", "ge", "de"], "file": ["path", "buffer", "output", "db", "mail", "task", "tile", "link", "handle", "f", "et", "h", "dir", "fp", "io", " File", "File", "resource", "el", "lock", "email", "parent", "le", "name", "page", "ile", "directory", "print", "FILE", "base", "port", "table", "log", "web", "work", "data", "out", "ca", "image", "report"], "bufferedWriter": ["bufferedMember", "bufferedWrite", " bufferredWriter", "buffaredReader", "buffaredwriter", "builteredReader", "buffererMember", "bufferredwriter", "buffenedClient", "bufferingReader", " bufferedHelper", "bufferredWrite", "bufferedwriter", "bufferedReader", "bufferedStreamer", "bufferredClient", " bufferedwriter", " bufferedClient", "bufferingClient", "buffaredWrite", "buffenedWrite", "builteringMember", " bufferedStreamer", " bufferredWrite", "bufferredStreamer", "bufferredHelper", "bufferingWrite", "buffaredMember", "builteringReader", " bufferredwriter", "buffaredStreamer", "bufferedHelper", "buffenedWriter", "bufferingwriter", "buffenedHelper", "bufferingWriter", " bufferredStreamer", " bufferredHelper", " bufferredClient", "buffererReader", "bufferingHelper", " bufferedWrite", "buffaredWriter", "builteredWriter", "bufferedClient", "builteredMember", "buffererWriter", "bufferredWriter", "bufferingMember", "builteringWriter", "bufferingStreamer"]}}
{"id1": "7118860", "id2": "3024970", "code1": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 0, "substitutes": {"getEncoding": ["getEncoder", " getEnReading", "getChording", " getEnoder", "getEncording", "getEnoder", "getEnReading", "getChReading", " getEncReading", " getEnording", " getEnoding", " getEncoder", "getChoder", "getIntegording", "getIntegReading", "getIntegoding", "getEnording", "getChoding", " getEncording", "getEnoding", "getEncReading", "getIntegoder"], "reader": ["runner", "buffer", "owner", "builder", "rar", "volume", "instance", "user", "peer", "worker", "author", "controller", "manager", "review", "holder", "rer", "loader", "parser", "read", "row", "iterator", "older", "creator", "er", "client", "resource", "liner", "server", "timer", "wrapper", "length", "operator", "library", "inner", "linger", "writer", "dd", "reading", "handler", "stream", "event", "rr", "redo", "Reader", "ner", "source", "loading", "upper", "iter", "rl", "layer", "driver", "ro", "range", "query", "r"], "encoding": ["enaging", "ecoder", "decoding", "entension", "capping", "cryption", "enumoder", "enoder", "encination", "integryption", "enmentation", "continoding", "decryption", "increoded", "increapping", "increignment", "decension", "ecapping", "entination", "encasting", "coded", "enumension", "octoding", "entoding", "ecryption", "encoded", "encryption", "entryption", "cacheoding", "equapping", "enination", "encaling", "cending", "octaging", "integmentation", "ecaling", "continryption", "entging", "enictionary", "encignment", "integoding", "encacing", "increging", "enoding", "enumacing", "octending", "entoded", "acacing", "encending", "encapping", "acoder", "ecoding", "encmentation", "acension", "enoded", "encictionary", "enging", "increoding", "equination", "encoder", "decaling", "caging", "continasting", "enasting", "encaging", "increictionary", "entapping", "enumoding", "cacheapping", "enapping", "enignment", "cacheictionary", "integapping", "enaling", "encging", "enending", "acoding", "enacing", "coding", "entoder", "ecasting", "enryption", "ecension", "equension", "cmentation", "octoded", "increoder", "enension", "equoding", "encension", "cacheignment", "continoder"], "connection": ["management", "application", "connect", "session", "ion", "Connection", "con", "close", "config", "open", "database", "link", "response", "statement", "generation", "condition", "reference", "socket", "console", "character", "relation", "uri", "client", "resource", "channel", "office", "writer", "communication", "opening", "number", "service", "position", "established", "online", "directory", "conn", "command", "remote", "document", "url", "context", "network"], "header": ["output", "buffer", "history", "dr", "http", "block", "term", "template", "head", "menu", "headers", "attribute", "heading", "filter", "metadata", "title", "holder", "environment", "h", "client", "initial", "request", "rule", "version", "hidden", "position", "policy", "dict", "event", "meta", "Header", "layer", "status", "table", "comment", "profile", "document", "info", "column", "handle", "hd", "question"], "entry": ["node", "cell", "space", "se", "cue", "instance", "section", "ent", "member", "ie", "link", "attribute", "see", "q", "ary", "ry", "row", "ce", "card", "from", "element", "up", "pair", "e", "atom", "be", "inner", "key", "ace", "char", "obj", "pixel", "record", "command", "check", "let", "object", "set", "def", "directory", "escape", "info", "data", "search", "Entry", "alias", "enter", "word", "pattern"], "item": ["text", "attr", "im", "cell", "addr", "term", "prefix", "template", "instance", "it", "user", "link", "attribute", "title", "em", "id", "entity", "tab", "local", "row", "area", "mm", "element", "Item", "el", "tag", "pair", "atom", "key", "name", "label", "xml", "unit", "char", "event", "anything", "om", "string", "object", "iter", "layer", "value", "file", "app", "info", "ip", "items", "word", "image", "order", "question"], "line": ["message", "text", "part", "level", "cell", "model", "block", "lin", "phrase", "ln", "n", "se", "valid", "user", "lo", "msg", "eline", "link", "piece", "detail", "zone", "body", "entity", "sql", "row", "sample", "queue", "frame", "term", "note", "slice", "channel", "liner", "continue", "le", "e", "code", "inline", "ine", "where", "rule", "label", "edge", "LINE", "ice", "l", "online", "page", "char", "sequence", "err", "record", "pe", "print", "point", "iter", "port", "file", "log", "range", "comment", "chain", "lined", "query", "search", "ge", "trace", "cmd", "word", "Line", "network"]}}
{"id1": "5760649", "id2": "494226", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"createFile": ["saveFile", "createStream", "saveStream", "uploadStream", " createStream", " createFiles", "uploadFiles", "createfile", "saveFiles", " createfile", "createFiles", "uploadfile", "uploadFile", "savefile"], "src": ["ser", "st", "abs", "config", "SOURCE", "is", "sys", "pour", "rx", "sc", "rc", "fp", "from", "uri", "loc", "resource", "rs", "fc", "comp", "str", "ctr", "dest", "stream", "txt", "obj", "sec", "sit", "rect", "sr", "source", "input", "ipl", "sb", "inst", "url", "res", "start", "sq", "SourceFile", "cur"], "filename": ["fn", "path", "output", "nil", "bf", "location", "prefix", "jpg", "ln", "n", "fil", "title", "nm", "FN", "Filename", "fp", "stem", "subject", "nl", "png", "v", "ename", "xxx", "name", "println", "username", "family", "txt", "kl", "FILE", "string", "file", "ren", "SourceFile"], "fis": ["ffos", "sfiss", " fiss", "fisi", "bfios", "ffis", "afis", "afiss", "fiss", "Fis", " fais", "Fiss", "fIS", "ffisi", "Fios", "FIS", "sfios", "afios", "bfis", "ffIS", "fais", "Fos", " fios", " fisi", "afais", "fios", "Fisi", " fIS", "sfais", "sfis", "bfiss", "bfos"], "fos": [" fOS", "vOS", "tis", "boss", " foses", "Foss", "woses", "bos", "bis", "fOS", "Fis", " foes", "Foes", "vor", "flis", "flos", "vos", "Fos", "flios", "foes", "tios", "toss", "wis", "floss", "voses", " foss", "boes", "tos", "fios", "wor", "wios", "foses", "foss", "woss", "wOS", "wos"]}}
{"id1": "20232250", "id2": "5035872", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"sendRequest": ["sendCommand", " sendMessage", "executeCommand", "executeMessage", "processrequest", "sendrequest", "executeRequest", " sendrequest", "sendMessage", " sendCommand", "processRequest", "executerequest", "processMessage", "processCommand"], "seq": ["session", "cell", "block", "prefix", "buf", "config", "exc", "msg", "item", "q", "Sequ", "tab", "id", "state", "rez", "enc", "test", "queue", "desc", "frame", "sel", "sub", "que", "client", "pos", "pse", "serv", "ref", "clus", "comp", "protein", "req", "str", "next", "ence", "sec", "sequence", "err", "batch", "struct", "cl", "sequ", "ctx", "iter", "iq", "eq", "sim", "cmd", "cli", "res", "cas", "sq", "gen"], "IOException": ["ReadingException", "ioStatus", " IOStatus", " IOFailure", "ioFailure", "IOFailure", "ReadingFailure", "IOStatus", "ReadingStatus", "ioException"], "putBuf": ["putEBuf", "putLbuff", "posBUF", "putBeUF", "putPurg", "PUTGbuff", "putBbuff", "outputBbuff", "PUTGbuf", "posBuf", " putLuf", "PUTBuf", "putbagg", "PUTGurg", "putLagg", " putBpkg", "outputburg", "putbpkg", "PUTBbuff", "putLuf", "PUTMuf", "putDebuf", "putLpkg", "putBpkg", "putGuf", "putBurg", "posBeuf", "putbuf", "putbbuf", "putDebimg", "putBbuf", " putLbuf", "PUTMld", "posBeagg", "putCimg", "putGub", "PUTMuff", "PUTBurg", "outputGuff", "outputGuf", "putOutuf", "posBagg", "outputbbuf", "putPbuff", "PUTBimg", "putEBpkg", "outputBbuf", "outputbuf", "putEBbuf", "putbbuff", "putBub", "putMld", "PUTBuff", "putLuff", "putOutuff", "putGbuf", " putBagg", "putBeagg", "putDebuff", "putGbuff", "outputGub", "putCuff", "putBuff", "putGuff", "putMuf", "putLurg", "PUTBld", "posBebuf", "PUTMimg", "putBagg", " putLpkg", "outputBub", "putBebuf", " putBbuf", "putOutbuf", "posBeUF", "PUTBbuf", " putLagg", "outputBuff", "putCuf", "putBld", "putburg", "putCld", "putPbuf", "putBimg", "posBbuf", "putLub", "putBUF", "outputBuf", "PUTGuf", "putDebld", "putPuf", "putGUF", "putMimg", "putLbuf", "putGurg", "putBeuf", "putGagg", "putMuff", "outputbbuff", "outputGbuf", "putOutub", "putEBagg", "outputBurg"], "url": ["http", "ls", "abs", "addr", "sl", "open", "ret", "build", "pkg", "bel", "link", "ur", "lb", "Url", "URL", "p", "rel", "att", "ssl", "dl", "uri", "loc", "nl", "atl", "client", "browser", "str", "xml", "ll", "get", "l", "net", "rl", "log", "ctrl", "sb", "https", "cert", "oul", "cmd", "r", "hl"], "conn": ["ch", "nec", "nc", "connect", "db", "con", "addr", "close", "ln", "n", "open", "connection", "ct", "socket", "iw", "inv", "enc", "ws", "sw", "dl", "conv", "loc", "resp", "pas", "win", "client", "nt", "syn", "ns", "write", "ctr", "cb", "comm", "nw", "cp", "obj", "net", "cont", "tn", "cl", "ctx", "cn", "secure", "ann", "ctrl", "cert", "jp", "cmd", "res", "fin", "soc", "Conn", "exec", "cur"], "wr": ["fn", "dr", "spr", "wm", "rew", "WR", "ln", "wer", "vet", "wrote", "wa", "iw", "writers", "Wr", "mg", "ws", "sw", "writ", "pr", "fr", "rw", "wt", "write", "writer", "nw", "vr", "w", "wb", "mr", "wid", "kl", "wk", "mk", "wn", "Writer", "tw", "wo", "mn", "fw", "kr", "we", "hw", "wy", "wx"]}}
{"id1": "14047629", "id2": "18217985", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "label": 0, "substitutes": {"source": ["output", "buffer", "proc", "message", "expression", "se", "SOURCE", "seed", "shell", "address", "q", "ource", "sql", "console", "sample", "iterator", "from", "channel", "resource", "Source", "content", "request", "src", "reader", "stream", "service", "position", "sequence", "event", "result", "input", "copy", "file", "system", "query", "data", "format", "in", "image"], "process": ["place", "proc", "session", "connect", "function", "task", "node", "pm", "term", "program", "method", "se", "init", "build", "link", "sys", "and", "class", "condition", "processor", "p", "state", "console", "make", "flow", "create", "execute", "frame", "pid", "use", "pp", "pipe", "component", "run", "Process", "code", "processing", "call", "script", "store", "post", "cp", "service", "thread", "complex", "command", "project", "check", "mem", "object", "status", "file", "job", "parse", "chain", "work", "memory", "context", "cmd", "handle", "exec", "network"], "processStdOut": ["processStrdIn", "processStrrEr", "processStstdOut", "processStstEx", "processStrdEx", "processStrIn", "processStrOut", "processStstdIn", "processStstdEx", "processStrrOut", "processStdEr", "processStstIn", "processStrdEr", "processStrrIn", "processStstOut", "processStdEx", "processStstEr", "processStrdOut", "processStstdEr", "processStrEr", "processStrrEx", "processStrEx"], "processStdIn": ["processStackdin", "processStackdIN", "processSttIns", "processStackdsIn", "processStsin", "processStsOut", "processStdsIn", "processStrIn", "processStsIn", "processStrIN", "processStrOut", "processStdIN", "processStackdsIN", "processStackdsOut", "processStrin", "processSTtIn", "processSTtOut", "processStackdOut", "processSTdIns", "processStdin", "processStsIN", "processStdIns", "processSTdIn", "processSttIn", "processSttIN", "processStrIns", "processStackdsin", "processSTdIN", "processSTdOut", "processStdsIN", "processStdsIns", "processStackdIn", "processSTtIns", "processStdsOut", "processStdsin", "processSTtIN", "processSttOut"]}}
{"id1": "1421557", "id2": "5299276", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "20623709", "id2": "2324868", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"split": ["Split", "disk", "part", "sync", "open", "align", "count", "transfer", "read", "scan", "use", "slice", "map", "lock", "write", "process", "unit", "share", "upload", "scale", "batch", "copy", "parse", "join", "format", "append", "seek"], "targetDirectory": ["TargetDirect", "testDir", "targetFolder", " targetFile", "baseDir", "targetFile", "TargetFolder", " targetFolder", "targetLocation", "baseMemory", "localdirectory", "targetdirectory", "baseFolder", "localDirectory", "localFile", "testDirectory", "baseDirectory", "targetDirect", " targetdirectory", "testDirect", " targetDirect", "TargetMemory", "Targetdirectory", " targetMemory", " targetLocation", "TargetDir", " targetDir", "testLocation", "baseFile", "TargetDirectory", "targetDir", "localDir", "targetMemory", "basedirectory", "TargetLocation", "baseDirect"], "prefix": ["path", "PRE", "password", "template", "type", "pkg", "title", "Pref", "root", "p", "size", "uri", "FIX", "filename", "fixed", "tag", "pre", "this", "key", "fixes", "name", "fix", "index", "version", "division", "username", "directory", "localhost", "base", "command", "padding", "status", "ix", "zero", "pres", "pi", "format", " suffix", "alias", "pattern"], "maxUnitBases": ["maxUnitChades", "maxUnitLounds", "maxUnityLounds", "maxUnitChias", "maxUnitChounds", "maxUnityBicas", "maxUnitLages", "maxUnitReplounds", "maxUnityBades", "maxUnityBias", "maxUnitAliias", "maxUnitChases", "maxUnityLages", "maxUnitLases", "maxUnitReplages", "maxUnitChages", "maxUnitBias", "maxUnitbounds", "maxUnityAliades", "maxUnityBages", "maxUnitChicas", "maxUnitBicas", "maxUnityBases", "maxUnitAliounds", "maxUnitBages", "maxUnitbias", "maxUnityBounds", "maxUnitbades", "maxUnityLicas", "maxUnityAliounds", "maxUnityAliias", "maxUnityAliases", "maxUnitAliades", "maxUnitLicas", "maxUnitAliases", "maxUnitBounds", "maxUnitReplicas", "maxUnitbases", "maxUnityLases", "maxUnitReplases", "maxUnitBades"], "maxUnitEntries": ["maxUnityentrs", "maxUnitEntriers", "maxUnitEntryires", "maxUnitentrys", "maxUnityEntrys", "maxUnitEntryrys", "maxUnitErires", "maxUnityentires", "maxUnitentrs", "maxUnitEntryries", "maxUnityEntries", "maxUnitIntegries", "maxUnitErrys", "maxUnitIntegires", "maxunitEntires", "maxUnitErrs", "maxunitEntrys", "maxUnitEntryriers", "maxUnitIntegrys", "maxUnitEntires", "maxUnitErries", "maxunitEntrs", "maxUnitIntegriers", "maxUnitEntrys", "maxUnitentires", "maxUnityentrys", "maxUnitentries", "maxUnitEntrs", "maxUnityentries", "maxUnityEntires", "maxUnityEntrs", "maxunitEntries"], "fis": [" fi", " fiss", "viss", "fii", "Fii", "fiss", "Fis", "fi", "Fiss", "ifis", "Fic", "vic", "ific", "ifii", " fic", "vis", "Fi", "fic", "Fci", "ifci", " fii", "vi"], "fci": ["Fico", "cfis", "cfci", "mco", "cfini", "mci", "fii", "fico", "cfai", "Fis", " fcu", "fai", "cfic", "mii", "Fco", "Fai", "cfco", "Fic", "mcu", "tci", "tcu", "Fini", "tii", "tco", "fcu", " fic", "fic", "Fci", " fini", "fini", " fii", "cfico", " fico", " fai"], "fos": ["faos", " fOS", "Foss", "ybos", "fOS", "fbos", "yios", "flaos", "Faos", "wbos", "yos", "FOS", "flos", "yaos", "Fos", " fios", "flOS", "floss", " fbos", " foss", "fios", "wios", " faos", "foss", "waos", "wos"], "fco": ["Fdo", "Foco", "Fso", "cco", "cdo", "Fcon", "fcon", "cso", " fcon", " foco", "pco", "pcos", "Fco", " fdo", "fso", "fcos", " fso", "Fcos", "tdo", "tcos", "foco", " fcos", "tco", "pci", "fdo", "ccon", "pso", "toco", "Fci"], "buffer": ["message", "Buffer", "binary", "pause", "function", "black", "window", "timeout", "block", "phrase", "buf", "template", "button", "callback", "database", "filter", "flush", "address", "holder", "complete", "reset", "row", "sample", "read", "queue", "note", "channel", "buff", "length", "library", "index", "position", "bridge", "char", "sequence", "result", "event", "record", "print", "command", "batch", "limit", "source", "entry", "padding", "iter", "table", "match", "comment", "stack", "document", "data", "order", "memory", "append", "temp", "cache"], "currentBasesCount": ["currentBasesCode", "currentbaseCode", "currentBadesCount", "currentBasedLength", "currentbaseLength", "currentBaseLength", "currentbasesCount", "currentBaseCode", "currentbasesCode", "currentbaseCount", "currentBaseCount", "currentBadesLength", "currentBasesLength", "currentBadesCode", "currentBasedCount", "currentbasesLength", "currentBasedCode"], "currentEntriesCount": ["currentEntrysCode", "currentEntrysFlag", "currentEntriesFlag", "currentEntiesCount", "currentEntrsFlag", "currentEntriesCode", "currentEntrsCode", "currentEntiesFlag", "currentEntiesCode", "currentEntrsCount", "currentEntrysCount"], "targetCount": ["argetInfo", "argetAmount", "argetNum", "TargetAmount", "targetInfo", "TargetInfo", "TargetCount", " targetAmount", "TargetNum", "argetCount", "targetNum", "targetAmount", " targetNum", " targetInfo"], "fastaChannel": [" fastaProvider", "fastpaProvider", "fastaButton", "fastaiQueue", "fastoProvider", "fastaiChannel", "fastityChannel", " fastaConnection", " fastaStream", "fastaiChan", "fastoChannel", "fastaQueue", "fastpaChannel", " fastoChannel", "fastpaButton", "fastityQueue", "fastaChan", "fastoStream", " fastaButton", "fastoButton", " fastaQueue", " fastoStream", "fastityChan", "fastoQueue", "fastaiStream", "fastoConnection", " fastoChan", "fastityStream", "fastpaConnection", " fastoQueue", " fastaChan", "fastaConnection", "fastoChan", "fastaStream", "fastaProvider"], "totalSeqCount": ["totalSeQCounter", "totalSeqsCode", "totalSegCount", "totalSegCounter", "totalSegSize", "totalSeqCounter", "totalSeQCode", "totalSeQSize", "totalSeqsCount", "totalSeqsSize", "totalSeqSize", "totalSeqsCounter", "totalSegCode", "totalSeQCount", "totalSeqCode"], "totalResiduesCount": ["totalResIdueCode", "totalResIdueCount", "totalResidusFlag", "totalResIduesFlag", "totalResidueCount", "totalResiduationsFlag", "totalResidueCode", "totalResidusCount", "totalResIduesCount", "totalResiduationsCode", "totalResidusCode", "totalResiduationsCount", "totalResIdueFlag", "totalResiduesCode", "totalResidueFlag", "totalResiduesFlag", "totalResIduesCode"], "prevTime": ["prevT", " prevT", "parTime", " prevThread", " previousThread", "parT", "parThread", " previousT", " previousTime", "prevThread"], "fastaFileSize": ["fastoFileOwner", "fastaTableSIZE", "fastoTableSIZE", "fastaChainOwner", "fastaFilesSize", "fastoTableOwner", "fastaReaderHeight", "fastaTableLength", "fastAFileName", "fastATableHeight", "fastaFileName", "fastaFilesHeight", "fastafileSIZE", "fastafileLength", "fastaFilesName", "fastATableSize", "fastaFileSIZE", "fastoFileSize", "fastoTableSize", "fastaChainLength", "fastaFileHeight", "fastaReaderName", "fastaTableSize", "fastaChainSize", "fastaReaderLength", "fastaChainSIZE", "fastATableName", "fastaFileLength", "fastoTableLength", "fastaTableName", "fastafileSize", "fastoFileLength", "fastaFilesLength", "fastaReaderSize", "fastaTableHeight", "fastATableLength", "fastaTableOwner", "fastAFileSize", "fastAFileHeight", "fastAFileLength", "fastoFileSIZE", "fastaFileOwner", "fastafileOwner"], "fastaFileReadOffset": ["fastaFileWriteOrder", "fastaPageLoadOrder", "fastaFileLoadOrder", "fastaFilesReadOrder", "fastaFileViewOrder", "fastaFileInputOrder", "fastaFileInputLength", "fastaPageReadPos", "fastaChainCurrentLocation", "fastaFileWriteAmount", "fastaFileReadPos", "fastaFilesLoadOffset", "fastaFilesLoadOrder", "fastaPageReadOrder", "fastaFileLoadPos", "fastaFileInputLocation", "fastaChainReadOffset", "fastaFileReaderoffset", "fastaFileLoadOffset", "fastaFileWriteLength", "fastaFileCurrentoffset", "fastaFileReadPosition", "fastaFileReaderPosition", "fastaFileViewPos", "fastaChainReadPosition", "fastaPageLoadAmount", "fastaFilesReadLength", "fastaPageReadOffset", "fastaFilesReadAmount", "fastaFilereadPos", "fastaFilesLoadAmount", "fastaFileReaderLocation", "fastaFileCurrentLocation", "fastaChainCurrentoffset", "fastaChainCurrentPosition", "fastaFileViewAmount", "fastaFileLoadLength", "fastaPageReadAmount", "fastaFileReadAmount", "fastaFilereadOrder", "fastaFileReadoffset", "fastaPageLoadPos", "fastaFilesLoadLength", "fastaFileLoadAmount", "fastaFileReadOrder", "fastaFileWriteOffset", "fastaFilereadOffset", "fastaFileInputoffset", "fastaFileReaderOffset", "fastaChainCurrentOffset", "fastaFileViewOffset", "fastaChainReadLocation", "fastaFileCurrentPosition", "fastaFilereadAmount", "fastaChainReadoffset", "fastaFileInputPosition", "fastaPageLoadOffset", "fastaFileReadLength", "fastaFilesReadOffset", "fastaFileInputAmount", "fastaFileCurrentOffset", "fastaFileReadLocation", "fastaFileInputOffset"], "partitionStartOffset": ["partitionStartPoint", "partitionEndPoint", "partitonStartingPosition", "partitionDataOffset", "partitionEndOff", "partitionStartOff", "partitionDataPosition", "partitionDataPoint", "partitionStartingOffset", "partitonStartingOff", "partitonStartPoint", "partitionEndPosition", "partitionDataOff", "partitonStartOffset", "partitionStartPosition", "partitionStartingPosition", "partitonStartPosition", "partitonStartingPoint", "partitonStartOff", "partitionStartingPoint", "partitionStartingOff", "partitonStartingOffset"], "bufferSize": ["bufferCode", "tableSIZE", "buffSize", "buffSIZE", "bufferSIZE", "BufferLength", "BufferSIZE", "tableName", "BufferName", "bufSize", "sequenceSIZE", " bufferSIZE", "tableLength", " bufferLength", " bufferCode", "sequenceLength", "bufCode", "tableSize", "buffName", "BufferSize", "sequenceCode", "bufferLength", "bufferName", "sequenceSize", "buffLength", "bufSIZE", "bufLength"], "fastaBuffer": ["FastaBuffer", "wildanBuff", "fastasRequest", "fastsaQueue", "fastmaChannel", "FastaRequest", "fastmaBuffer", "fastasCounter", " fastaCounter", "FastmaBuff", "fastoBuff", "fastsaChannel", "fastuBuff", "fastalBuff", "wildaBuff", "fastoQueue", "fastanBuff", "wildaBuffer", "FastmaBuffer", "fastuMemory", "fastasQueue", " fastaBuilder", "fastcaBuffer", "fastoRequest", "fastaCounter", "wildanRequest", "fastaQueue", "fastaStore", " fastaBuff", "wildanBuffer", "fasteBuff", "fastmaBuilder", "wildaCache", " fastaCache", "wildanCache", "fastaBuff", " fastoCounter", "fastmaCache", "fastaBuilder", "fastanRequest", "fastcaRequest", "fastaDB", "fastaCache", "FastaBuff", "fastmaRequest", "fasteDB", "fastcaBuff", "fastmaBuff", "wildaRequest", " fastoBuff", "fastsaBuff", "FastmaRequest", "fastaRequest", "fastasBuilder", "fastasStore", "fasteMemory", " fastaMemory", "fastalCounter", "fastsaBuffer", " fastoQueue", "fastasBuff", "fastanCache", "fastmaStore", "fastcaCache", "FastmaStore", "FastaStore", " fastoBuffer", "fastasBuffer", "fastalBuffer", "fastalQueue", "fastoCounter", "fastuDB", "fastoStore", "fastoBuffer", " fastaDB", "fastmaQueue", "fastanBuffer", "fastasCache", "fastaMemory", " fastaQueue", "fastuBuffer", "fasteBuffer"], "fastaReadState": ["fastaReadSTATE", "fastoReaderType", "fastaCurrentState", "fastaReaderType", "fastaLoadState", "fastaLoadStatus", "fastoReadStatus", "fastaReaderSTATE", "fastoReaderSTATE", "fastaReaderState", "fastoReaderState", "fastaReaderStatus", "fastoReadType", "fastaCurrentType", "fastoReadSTATE", "fastoReaderStatus", "fastaLoadSTATE", "fastoReadState", "fastaReadType", "fastaCurrentStatus", "fastaCurrentSTATE", "fastaReadStatus", "fastaLoadType"], "nBytes": [" nParts", "nsbytes", "nsBytes", "nrBytes", "nobytes", "nKeys", " nbytes", "nParts", " nBlocks", "numBytes", "nsParts", "nbytes", " nWords", "nrbytes", "NItems", "noBlocks", "nrKeys", "NWords", "numBlocks", "NParts", "numbytes", " nItems", "NKeys", "noBytes", "nsWords", "nItems", " nKeys", "numNs", " nNs", "nBlocks", "noNs", "NBytes", "Nbytes", "nrItems", "nNs", "nWords"]}}
{"id1": "16079868", "id2": "18114701", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"readIntoList": ["readIntoMenu", "readIntTolist", "readintintolist", "readIntToList", "readIntIntMap", "readIntIntlist", "readIntIntList", "readIntToMap", "readIntolist", "readintolist", "readIntToMenu", "readIntintolist", "readintoMap", "readintoMenu", "readintintoMenu", "readIntintoList", "readIntIntMenu", "readintintoList", "readIntoMap", "readintintoMap", "readIntintoMenu", "readIntintoMap", "readintoList"], "url": ["http", "mail", "location", "window", "hub", "open", "ret", "bel", "link", "ur", "b", "Url", "f", "address", "URL", "id", "mol", "from", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "browser", "ref", "name", "str", "xml", "mount", "ll", "l", "char", "rect", "string", "input", "file", "domain", "log", "web", "cert", "r", "image"], "list": ["collection", "out", "part", "top", "st", "add", "block", "n", "type", "is", "detail", "p", "state", "pool", "relation", "test", "rm", "map", "t", "lists", "v", "parent", "summary", "all", "tree", "module", "group", "name", "label", "view", "get", "l", "level", "only", "dict", "record", "print", "batch", "set", "m", "status", "port", "table", "show", "info", "format", "listed", "LIST", "cache", "network"], "in": ["out", "IN", "on", "din", "gin", "con", "add", "by", "val", "rin", "is", "ic", "and", "ill", "pin", "read", "en", "inc", "from", "re", "er", "ins", "up", "bin", "all", "inner", "doc", "reader", "get", "isin", "sum", "In", "line", "check", "input", "source", "file", "i", "mn", " din", "inn", "r", "conf", "inf", "cin"], "inputLine": [" inputBlock", "helloLINE", "latLINE", " inputLINE", "textLin", "contextLine", "nameLINE", "outputline", "httpL", "attLINE", "selectRow", "formBlock", "inputline", "httpLine", "nextLine", "nameLine", "InputLine", "selectText", "outputLine", "textL", "selectLine", "formline", "dataLine", "nameline", "commandLINE", "actline", " inputText", "htmlLINE", "formLine", "commandline", "inputLin", "htmlLine", "httpLin", "htmlline", "attLine", "inputText", "latLine", "actLine", "contextline", "formLINE", "htmlBlock", "inputLINE", "textLINE", "activeLine", "selectLINE", "helloLin", "InputBlock", "textLine", "contextLINE", "commandLine", "nextRow", "nextLINE", "inputL", "nameBlock", "helloL", "inputBlock", "inputRow", "httpLINE", "Inputline", "dataLINE", "actLINE", "activeLINE", "outputLINE", "helloLine", "nextText", " inputRow", "InputLINE", " inputline"], "commandNameBegin": ["commandnameMorning", "CommandNamesStart", "commandLinebegin", "commandFamilyBegin", "commandNamesStart", " commandOrderBegin", "commandLineBegin", "commandSizeBeg", "commandNameInitial", " commandNameBeg", "commandNAMEInitial", "commandNamebegin", "commandSizeEGIN", "commandNameBeg", "commandNAMEBeginning", " commandOrderStart", " commandOrderbegin", " commandNamebegin", "commandnamebegin", "commandTypeStart", "CommandNamesBegin", " commandNameEGIN", "commandNAMEBegin", "commandOrderBegin", " commandNameInitial", "commandLineStart", "commandNamesBegin", "commandnameBegin", "commandLineBeginning", " commandSizeBeg", " commandSizeEGIN", "CommandNamesbegin", "commandSizeBegin", "commandOrderStart", "commandTypeBeginning", "CommandNamesBeginning", "commandFamilyEGIN", "commandNameBeginning", "commandnameBeginning", "commandnameStart", "CommandNamebegin", " commandNameMon", "commandnameEGIN", "commandFamilyMorning", " commandNameMorning", " commandSizeMorning", "CommandNameBegin", "CommandNameStart", "commandNameMon", " commandNameBeginning", "commandOrderbegin", "commandFamilyMon", "commandTypeBegin", "commandNameEGIN", "commandNAMEMon", "commandTypebegin", "commandNameMorning", "commandNameStart", " commandNameStart", "commandFamilyInitial", "commandFamilyBeginning", "commandNamesbegin", "commandOrderBeginning", "CommandNameBeginning", "commandnameBeg", "commandNamesBeginning", " commandOrderBeginning", " commandSizeBegin", "commandFamilyBeg", "commandSizeMorning"], "commandNameEnd": ["commandStringEnd", "commandTypeStart", "formSizeend", "commandNameStart", "formSizeEnd", "commandSizeStart", "commandnameEnd", "commandLineEnd", " commandLineEnd", "formNameEND", "cmdTimeEnd", "formSizeEND", "commandTypeend", "commandNamesEND", "commandTimeEND", "commandNamesStart", "commandNamesEnd", "formNameStart", "commandTimeend", " commandNameStart", "commandTypeEnd", "formNameEnd", " commandLineEND", "commandNameEND", " commandNamesEND", "commandNamesBegin", "cmdTimeend", "commandSizeEnd", "commandStringStart", " commandNamesStart", "cmdNameend", " commandNameEND", "commandTypeEND", "commandNamesend", "commandStringBegin", "commandnameEND", "cmdNameEND", "cmdTimeEND", " commandLineend", "commandNameend", "formNameend", " commandNamesEnd", "commandLineEND", "commandTypeBegin", "formSizeStart", " commandNameend", "commandStringEND", " commandNamesBegin", "cmdNameEnd", "commandTimeEnd", "commandSizeend", "commandSizeEND", "commandLineend", "commandnameend"], "item": ["owner", "task", "im", "add", "or", "monitor", "template", "instance", "it", "member", "button", "menu", "type", "link", "mix", "bar", "title", "em", "p", "local", "row", "mm", "element", "Item", "items", "el", "tree", "this", "key", "inner", "module", "rule", "group", "label", "related", "index", "unit", "handler", "store", "article", "page", "obj", "hit", "event", "other", "command", "entry", "check", "base", "object", "m", "iter", "mem", "match", "i", "app", "sim", "option", "exp", "info", "li", "widget", "image", "question"], "e": ["ve", "ev", "eu", "es", "x", "n", "se", "ent", "a", "ef", "fe", "ie", "te", "ze", "b", "f", "et", "q", "p", "eg", "o", "h", "end", "eeee", "en", "ce", "re", "ed", "er", "ex", "t", "el", "ee", "v", "ea", "E", "le", "oe", "eb", "g", "be", "error", "ec", "d", "w", "ue", "l", "u", "ae", "one", "event", "err", "pe", "eur", "m", "ne", "i", "ge", "r", "c", "de"]}}
{"id1": "14783950", "id2": "19849797", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compresswithFiles", "composeWithFiles", "compressWithzip", "composeWithoutFiles", "compressByzip", "compresswithZip", "compressByZip", "compressWithFiles", "compressWithoutzip", "compressByFiles", "composeWithZip", "composeWithoutZip", "compressByExt", "composeWithExt", "compressWithExt", "compressWithoutExt", "compresswithzip", "compressWithoutZip", "composeWithoutExt", "composeWithoutzip", "compresswithExt", "composeWithzip", "compressWithoutFiles"], "fileList": ["pagelist", "pageCode", "pageList", "fileIterator", "ilelist", " filelist", "pageLIST", "pageL", "ileL", "wordList", " fileSet", " fileL", "ileLIST", "itemList", "ileList", "fileNames", " fileIterator", " fileNames", "wordLIST", "fileSet", "resourceNames", "pageSet", "wordIterator", "tileList", "resourceList", "itemLock", " FileCode", " FileList", "tileSet", " FileSet", "itemNames", " fileLIST", " FileLIST", "wordSet", "tileLIST", "fileL", " fileCode", " fileLock", "fileCode", "resourceLock", "fileLock", "tileIterator", "fileLIST", "filelist"], "zipFileName": ["zipfilePath", "zipDirFilename", "zipFileNames", "zipFilenamename", " zipfileName", " zipFilePath", " zipfileNames", " zipFileFilename", "zipilename", "zFilePath", "zipilePath", " zipFileNames", " zipfilePath", "zipFilenameNames", "zipFileFilename", "zipileFilename", "zipFilenameFilename", "zipFilenamePath", "zipFilePath", "zipDirNames", "zFilenamename", "zipfileName", "zipDirName", "zFilenameFilename", " zipfileFilename", "zipfileNames", "zipileName", "zipfileFilename", "zipFilename", "zipDirPath", "zFilename", "zipfilename", "zFilenamePath", "zFileFilename", "zFilenameName", "zipFilenameName", "zFileName"], "fos": ["lfoos", " fOS", "lfOS", "Foss", "lfis", "woos", "fOS", " foos", "FOS", "loos", "lfos", "flis", "flos", "Fos", "flOS", "lOS", "los", "loss", "foos", "floos", "Foos", "foss", "woss", "wOS", "wos"], "zos": ["ossus", "sbm", "zen", "zi", "es", "hz", "zik", "jas", "ze", "zu", "iaz", "zin", "zan", "za", "ss", "ez", "hess", "rez", "zers", "os", "ses", "ws", "zon", "css", "zag", "zes", "ippers", "zzle", "ps", "rys", "webkit", "js", "enos", "less", "zh", "zb", "bes", "enz", "eros", "ess", "cz", "zer", "los", "zero", "iners", "z", "zo", "zar", "oss", "sis", "han", "Sax", "nz", "zip"], "iter": ["ser", "izer", "ator", "ger", "iver", "iner", "it", "valid", "user", "is", "Iter", "loop", "orient", "ver", "loader", "its", "iterator", "maker", "re", "er", "oper", "loc", "liter", "el", "ee", "train", "iv", "where", "inner", "ait", "reader", "inter", "coll", "ipper", "ptr", "tr", "ter", "Iterator", "ir", "vis", "ner", "former", "here", "gener", "fer", "i", "exp", "walker", "cer", "kit", "ip", "outer", "li", "list", "order"], "fileName": ["fNumber", "fileBody", " fileBody", "fieldNAME", "fileCurrent", "getname", "shortStore", "fname", "shortSource", "getStore", "fBody", "FileName", " fileSet", "fSource", "ileNumber", "ileSet", " fileStore", "localNAME", "ilename", "localname", "Filename", "ileSource", "fileString", "fNames", "ileList", " fileCurrent", "ileNAME", "FilePath", "fileNames", "tableName", " fileNames", "fileStore", "filename", "ileCurrent", "fileSet", "tablePath", "fName", "ilePath", " filename", "fieldList", "filePath", "shortname", "localName", " filePath", "FileString", "tableSet", "getName", "fieldName", "localList", "fileNumber", "fieldname", "fString", "ileString", " fileSource", "getSource", "ileName", "FileCurrent", "ileBody", "fileSource", " fileString", "FileNames", "fileNAME", " fileNumber"], "ind": ["cand", "mind", "wind", "ded", "nd", "cond", "j", "n", "bind", "ent", "draw", "sign", "seed", "roll", "count", "Ind", "cd", "inc", "num", "kind", "pl", "att", "red", "dj", "pos", "loc", "hend", "typ", "stick", "butt", "pred", "IND", "ld", "inder", "req", "cod", "index", "d", "ptr", "td", "md", "mod", "i", "find", "inn", "div", "med", "dial"], "shortName": [" shortString", "recentname", "shortFilename", " shortType", "fullString", "shortString", "fullType", "fullName", "ShortString", "smallName", "shortType", "fullname", "quickKey", "shortCode", " shortname", "Shortname", "smallname", "shortKey", "ShortFilename", "ShortKey", "smallCode", "quickString", "shortname", "quickName", "smallFilename", "ShortCode", " shortKey", "recentCode", "ShortName", "recentFilename", "ShortType", "recentName", "quickname"], "fis": [" fIs", "cfis", "cfois", "pois", "FIs", "sfi", " fris", "Fis", "fi", "sfIs", "cfi", "cfris", "hois", "ufois", "wi", "ufIs", "hi", "hris", "fIs", "wis", "ufris", "fois", "ufi", "ufis", "his", "Fris", "pi", "wois", "sfois", "wIs", "pris", "fris", "sfis", "pis"], "buf": ["buffer", "Buffer", "db", "orig", "block", "bed", "img", "msg", "pkg", "fg", "var", "bar", "b", "aka", "bag", "Buff", "tab", "cat", "bl", "cv", "seq", "conv", "fb", "arr", "buff", "bin", "ref", "uf", "box", "bus", "vec", "cb", "wb", "bytes", "tr", "bc", "batch", "mem", "cap", "mu", "br", "fam", "cmd", "temp", "rb", "cur"], "bytesRead": [" bytesLoad", "usersFind", " bytesWrite", "secondsWrite", "BytesNeed", "bytesFind", "linesWritten", "linesNeed", "BytesWritten", "bytesLoad", "flowsFind", "usersLoad", "blocksRead", " bytesWritten", "BytesRead", "postsFind", "secondsLoad", "usersRead", "secondsWritten", "bytesReady", "bytesLength", "BytesLength", "secondsRead", "bytesWritten", "blocksWritten", "linesRead", "flowsReady", "bytesWrite", "postsReady", " bytesNeed", "usersReady", " bytesLength", "bytesNeed", "postsRead", "postsLoad", "flowsLoad", "linesLength", "blocksWrite", "flowsRead", "blocksLoad"]}}
{"id1": "21181542", "id2": "7948308", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteRoleTyp", "deleteRoleTypes", "DeleteRoleType", "deleteGroupTyp", "deleteResourceType", "deleteResourceTyp", "DeleteRoleTyp", "deleteGroupType", "deleteResourceTypes", "deleteGroupTypes", "DeleteRoleTypes"], "id": ["path", "edit", "ident", "ide", "ion", "part", "node", "add", "orig", "x", "time", "instance", "Id", "it", "val", "type", "is", "link", "and", "rid", " pid", "p", "no", "h", "end", "create", "pid", "like", "mid", "t", "kid", " tid", "created", "iden", "ref", "hide", "ids", "key", "name", "bid", "d", "aid", "index", "uid", "l", "only", "event", "sid", "def", "hash", "vid", "show", "i", "info", "oid", "url", "in", "ID"], "namespaceId": ["namesplaceRef", " namespaceIdent", "namespacesRef", "nameshipID", "namesspaceAnd", "namespaceLog", "typesACEId", "namesACEId", "namesspaceid", "namespointRef", "namespaceid", "namespointName", "namesositoryBirth", " namespaceOr", "workspaceName", "namesplaceid", " namesiteIdent", "namesenceOr", "typespaceID", "workshipKey", "worksplaceName", "namesistenceLog", "namespaceIdent", "namespaceName", "namesenceId", "namesenceID", "namespacesid", "worksetAnd", " namesenceID", "namesistenceIdent", "worksplaceRef", "namespaceOr", "namesadeAnd", "namespacesId", "namespointID", "namespacesID", "workshipid", "namesetid", "namesositoryID", "workshipID", "namesistenceOr", "namesACEID", "namesiteId", "worksplaceid", " namesiteOr", "worksetId", "worksplaceId", "namesistenceId", " namespaceLog", "namesaceID", "namespaceBirth", "namesadeID", "workspaceRef", "namespaceRef", "typesACEAnd", " namesiteLog", " namespaceBirth", "namesetID", "namesositoryId", "namesaceId", "namespacesAnd", "namespaceID", " namesenceId", "namesaceid", "namesaceKey", "namespaceKey", "typesACEID", "namesplaceName", "namespacesKey", "namesetId", "workspaceid", "namesiteIdent", "namesiteOr", "namespaceAnd", "namesetAnd", "namespacesBirth", "worksetid", "workspaceAnd", "namesenceBirth", "namespointAnd", "workspaceKey", "namesadeId", " namespaceID", "namespointid", "nameshipid", "nameshipKey", "namesiteLog", "namesACEAnd", "nameshipId", "worksetID", "namespacesName", "namesplaceId", " namesenceBirth", "typespaceAnd", "workshipId", "namesspaceID", "namesenceIdent", "namespointId", "namesspaceId", " namesiteId", "workspaceId", "namesenceLog", "workspaceID", "typespaceId"], "removeReferencesInRoleTypes": ["removeReferencesInRightFiles", "removeReferencesFromroleType", "removeReferencesInroleTypes", "removeReferencesFromroleTypes", "removeReferencesFromMultipleType", "removeReferencesInroleNames", "removeReferencesInRoleFiles", "removeReferencesInRightType", "removeReferencesInRightTypes", "removeReferencesFromroleFiles", "removeReferencesInRightNames", "removeReferencesFromMultipleNames", "removeReferencesInMultipleFiles", "removeReferencesFromRoleType", "removeReferencesInRoleType", "removeReferencesFromRoleTypes", "removeReferencesFromRoleFiles", "removeReferencesInRuleType", "removeReferencesInRoleNames", "removeReferencesInMultipleNames", "removeReferencesInRuleNames", "removeReferencesInroleType", "removeReferencesInMultipleType", "removeReferencesInMultipleTypes", "removeReferencesInRuleTypes", "removeReferencesInRuleFiles", "removeReferencesFromMultipleTypes", "removeReferencesFromroleNames", "removeReferencesInroleFiles", "removeReferencesFromMultipleFiles", "removeReferencesFromRoleNames"], "permit": ["permission", "PERMIT", "Permission", "PERmiss", "PERmit", "Permitted", "permiss", "promit", "PERmitted", "PerMIT", "Permiss", "proMIT", "promission", "promitted", "perMIT", "permitted", "Permit", " perMIT", "PERmission", " permitted", " permiss"], "exist": ["ist", "have", "icate", "connect", "missing", "mark", "add", "save", "existent", "present", "ext", "see", "purpose", "keep", "create", "existence", "respond", "register", "use", "login", "current", "filename", "require", "ready", "existing", "write", " extant", "define", "know", "meet", "cont", "status", "same", "find", "establish", "attach", "there", "alias", "include", "remember", "list"], "msgBuf": ["msgBsuf", "messageBlf", "messageBuf", "msgPbuf", "msgPuff", "msgRfg", "messageRbuff", "msgMuf", "messagePfg", "msgGbuf", " msgRlim", "messageMuf", "msgRuff", "msgBbuff", "msgBsfg", "msgRlim", " msgCfg", "messageMbuff", "msgGbuff", "msgAbuff", "messageBuff", "msgBlf", "msgMbuf", "msgCuff", "msgBefg", " msgMbuff", " msgBbuf", " msgCbuf", "msgMuff", "msgBeuf", "msgVbuf", " msgRuf", "messageMbuf", "msgVuff", "messageRuf", "msgRlf", " msgRbuff", " msgCuff", "msgBsuff", "messagePuf", "msgCbuff", "messageRbuf", " msgCuf", "msgRbuf", "msgBsbuf", "msgAuf", "msgRuf", "messageBbuff", " msgBlim", " msgMuff", " msgBfg", "msgAbuf", "messageBbuf", "msgBebuf", " msgBbuff", "msgBuff", "messageMuff", "messagePbuf", "msgBeuff", "msgVbuff", "msgBbuf", "msgPbuff", "messageBfg", "msgPuf", "messageRuff", "msgCuf", "msgGlim", "msgBfg", "msgGuf", "messageRlf", "msgBlim", "msgVuf", "messagePuff", "msgCfg", "msgMbuff", "msgCbuf", " msgRbuf", "msgPfg", " msgMuf", "msgPlf", "msgRbuff", " msgBuff", "msgAuff", " msgMbuf"], "objects": ["uploads", "assets", "faces", "units", "products", "links", "beans", "artifacts", "locks", "workers", "headers", "ports", "versions", "plugins", "ors", "articles", "images", "frames", "pages", "jobs", "airs", "obs", "lines", "classes", "files", "packages", "bits", "books", "ids", "builders", "authors", "codes", "points", "keys", "oids", "errors", "values", "projects", "models", "parts", "tools", "apps", "organisms", "relations", "docs", "resources", "flows", "blocks", "items"], "sqlRightId": [" sqlRightRef", " sqlrightById", " sqlRightById", "sqlRightName", "sqlHeadId", "sqlrightById", "sqlHeadid", "sqlrightRef", "qlRightId", "sqlLeftName", "qlrightId", "qlrightName", " sqlrightId", "sqlLeftId", "sqlHeadRef", "qlRightName", "sqlrightName", "sqlRightRef", "qlRightid", " sqlRightid", "sqlHeadById", "sqlrightId", "sqlRightById", " sqlrightid", "qlrightid", " sqlrightRef", "sqlRightid", "sqlLeftid", "sqlrightid"], "sqlParent": ["sqlOwner", "sprparent", "sysChild", "sprParent", "invChild", "sysParent", "sprOwner", "sysOwner", "invOwner", "invParent", "sqlChild", "sqlparent", "invparent", "sprChild", "sysparent"], "sql": ["orm", "session", "db", "json", "description", "password", "term", "template", "sys", "statement", "params", "ql", "body", "SQL", "execute", "dl", "security", "spec", "cfg", "md", "command", "drop", "acl", "action", "comment", "data", "cmd", "diff"], "pstmt": ["pondm", "pstatms", "pndm", "PStng", " pstatmt", "pndmk", "pndmt", "wpastmt", "wpastm", "PstatStatement", "NEW", "pndMT", "pastmm", " pstem", "pStm", " pstms", "pstatmm", "pstm", " pstatmp", "wpstMT", "Pstatm", "insert", "pstatem", "wpastMT", "pstatmp", "wpstm", "pthmp", " pstmp", "pondmt", "pastStatement", "wpastmk", "create", "PstStatement", "pstatm", "pastmk", " pstatem", "pstStatement", "pstartr", "pthmt", "PStr", "pStr", "NULL", "_", "def", "pstmm", "pstartmt", "Pstr", "pstatmt", "PStmt", "pstartm", "pstartng", "Pstng", "pstMT", "Exception", "pStmt", "pthem", "Delete", "pstem", "nt", "pStng", "pstmp", "pctms", "pstms", "wpstmt", "Pstatmm", "pstr", "pastmt", "tx", "postm", " pstatms", "pthms", "wpstmk", "Pstm", "PStm", "pstatStatement", "pastm", "Pstatmt", "pstng", "Pstmt", "pastMT", "pctem", "pctmt", "postMT", "pondStatement", "postmt", "Pstmm", "pondmm", "postmk", "pstmk", "context", "pctmp"], "typeGid": ["typeCno", "typeGenid", "typeCId", " typeCids", " typeCno", "TypeCid", "typeGuid", " typeGno", "TypeCID", "TypeCId", "typeGuno", "typeRegid", "TypeGID", "typeGids", "typeGno", "TypeGId", "typeGuID", "typeRegID", "typeRegId", " typeGids", "typeGID", "typeGenids", "typeGuId", "typeCids", "typeCID", " typeCid", "TypeGid", "typeGenno", "typeGuids", "typeCid", "typeGId"], "defaultLevel": ["defaultDepth", " defaultDepth", "Defaultlevel", "DefaultMode", "errorLevel", "DefaultLevel", " defaultMode", "errorDepth", "DefaultDepth", "defaultMode", " defaultlevel", "errorlevel", "defaultlevel", "errorMode"], "success": ["successfully", "progress", "close", "save", "unknown", " succeed", "state", "rc", "accept", "ok", "continue", "fail", "pass", "summary", "warn", "error", "good", "result", "submit", "primary", "status", "undo", "info", "Success", "successful", "failed", "first"]}}
{"id1": "7981642", "id2": "13891080", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"update": ["edit", "UPDATE", "place", "Update", "load", "printf", "text", "add", "save", "replace", "touch", "config", "init", "apply", "change", "move", "put", "updated", "feed", "alter", "read", "sample", "create", "test", "register", "auth", "login", "up", "delete", "write", "store", "post", "upload", "username", "mod", "check", "input", "set", "reply", "escape", "data", "append", "remove", "handle", "insert", "commit", "pack"], "mail": ["grid", "message", "http", "im", "addr", "n", "ln", "msg", "pkg", "com", "link", "hold", "del", "tp", "address", "old", "id", "dn", "local", "Email", "dir", "test", "mm", "dm", "pl", "dl", "Mail", "el", "server", "name", "mount", "alt", "label", "mill", "virtual", "mobile", "username", "mails", "mun", "md", "net", "gmail", "imp", "enter", "print", "mem", "m", "iter", "port", "file", "domain", "log", "cert", "url", "cmd", "ip", "host", "dial", "eth", "zip"], "email": ["message", "text", "html", "password", "addr", "n", "ln", "template", "link", "detail", "example", "echo", "del", "address", "et", "nm", "entity", "sql", "dn", "image", "Email", "sample", "test", "note", "ilo", "uri", "nl", "el", "server", "e", "atom", "ns", "name", "label", "xml", "external", "number", "phone", "virtual", "username", "enter", "line", "cdn", "object", "m", "cn", "date", "file", "domain", "log", "url", "ip", "host", "IL", "il", "zip"], "pwd": ["pressw", " pfx", "pw", "psw", "dpwd", "Pow", "dpw", "presspriv", "Ppriv", "pow", "pgen", " pws", "pword", "psfx", " pgen", "ppriv", " pw", " pword", " ppriv", "dpgen", "pws", "Pword", "Pwd", "dpword", "presswd", "pswd", "pressws", "pfx", "Pgen", " pow", "Pw", "Pws", "psow", "Pfx"], "firstname": ["lastnames", "FirstNAME", "firstparent", " firstName", "Firstname", " firstparent", "smallNAME", "lastNAME", "smallName", "smallname", " firstrun", "lastrun", "firstNAME", "Firstnames", "firstnames", "Firstparent", "FirstName", " firstNAME", "lastName", "lastparent", "smallrun", " firstnames", "firstrun", "firstName"], "lastname": ["longName", " lastnum", "longnum", "fullName", "lastnum", "fullname", " lastName", "lastame", "firstame", "fullame", "firstnum", "longame", "longname", "firsttype", "givenName", "lasttype", "lastName", "givennum", " lastame", "firstName", "givenname", "giventype", " lasttype"], "connection": ["collection", "onet", "nc", "management", "application", "connect", "session", "cone", "Connection", "con", "description", "ion", "database", "link", "response", "condition", "pool", "relation", "creator", "client", "resource", "communication", "engine", "handler", "connected", "event", "directory", "conn", "command", "entry", "system", "document", "context", "city", "c", "network"], "attrs": ["attras", "atters", "atrd", "attrics", "atrs", "attsrics", "attries", "addrs", "adns", "atrys", "avrics", "attrys", "attsras", "avributes", "attsps", "attachrs", "atras", "actrys", "atries", "atns", "adributes", "actters", "addRs", " attras", "avrs", "atrics", "attachras", "addras", " attns", "attachributes", "attsrs", "attsries", "attps", " attRs", "attrd", "avras", "atps", " attries", "atributes", "attsds", "adras", "attsributes", "addributes", "latrs", "attters", "attRs", "attds", "adrs", " attps", "attachRs", "latributes", "latrys", "actributes", "actrs", "atRs", "atds", "attns", "latters", " attributes", "attributes", " attds", "addrd", " attrd"], "sha": ["alpha", "cos", "iso", "ya", "auto", "a", "has", "tar", "HA", "shell", "SHA", "wa", "no", "ssh", "ha", "h", "pa", "sche", "sa", "ma", "sm", "total", "comp", "hi", "shared", "da", "sh", "ka", "mb", "mac", "sum", " SHA", "md", "go", "ppa", "mem", "acl", "shi", "sam", "git", "func", "ksh", "asha", "lambda", "ca", "sq"], "digest": ["Digse", " digests", "mdests", " digested", "Digest", "digested", "redests", " digEST", "Dighest", "dighest", "redest", "Digests", "DigEST", "dge", "divEST", "mdested", "mdEST", "digse", "dest", "digests", "Digested", "digEST", "divhest", "redge", "divse", "redested", "mdse", "dested", "mdest", "mdhest", "Digge", "divest", "digge", "dests"], "hash": ["each", "message", "rh", "html", "password", "Hash", "has", "filter", "ashes", "ha", "h", "ASH", "auth", "total", "tag", "key", "hex", "trust", "flash", "sh", "dump", "mac", "shadow", "sum", "md", "result", "dig", "print", "base", "check", "input", "bh", "search", "format", "proof", "handle", "score", "cache", "ash"], "ctx": [" cx", "nc", "con", "cu", "x", "pkg", "mc", "tmp", "ct", "ck", "pg", "tk", "sc", "rc", "np", "cv", "conv", "loc", "lc", "xc", "kw", "cm", "cmp", "nt", "ctr", "tc", "cp", "cb", "dc", " context", "obj", "txt", "bc", "kl", "mk", "conn", "gc", "gm", "tx", "ctrl", "Context", "co", "tz", "jp", "context", "cf", "ca", "Conn", "sq", "wx"], "newName": ["currentNAME", "NewKey", "oldNames", "Newname", "newNames", "newNAME", " newHome", "currentname", "currentName", " newNames", "newname", "newHome", "finalname", "finalNames", "newKey", "oldHome", "oldname", " newNAME", "NewName", " newname", "finalHome", "NewNAME", " newKey", "finalName", "currentKey"], "oldName": ["prevName", "olderKey", " oldname", "recentname", "oldOr", "oldername", "prevPref", "recentOr", "newAnd", "smallOr", "prevname", "oldKey", "smallName", " oldKey", "olderName", "olderPref", "recentAnd", "smallname", "newname", "prevKey", "smallAnd", "oldname", "oldPref", "newOr", "recentName", " oldPref", "oldAnd"]}}
{"id1": "23532405", "id2": "19739421", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"persist": ["persiste", "insister", "Persain", "remain", "persister", "remiste", "remister", "insain", "persain", "insiste", "Persister", "remist", "Persist", "Persiste", "insist"], "ffConfigurable": ["ffConfigurationURA", "ffCerturate", "uffConfigorable", "ffRequesturable", "efConfigural", "effPortutable", "effConfigurated", "ffLogurable", "ffPorturable", "effCertURA", "ffConfigurationurable", "effConfigurer", "effPorturable", "ffConfuring", "efconfigurable", "ffLogutable", "ffRequesturing", "ffCertURA", "ffConfutable", "ffSpecuring", "effPorturated", "ffconfigURA", "ffconfigured", "ffRequestuer", "ffCertural", "ffConfigURA", "effCertured", "effConfigURA", "efConfigurate", "ffConfurable", "ffCertured", "ffConfigurer", "ffPorturated", "ffConfigurate", "ffLogurated", "ffSpecural", "ffConfigurationured", "ffconfiguer", "effConfigutable", "uffConfigurable", "ffconfiguring", "efconfiguring", "ffConfiguer", "ffConfigurated", "ffconfigurable", "ffConfiguring", "uffconfiguer", "ffConfigutable", "ffConfigorable", "ffRequestorable", "ffSpecurable", "ffCerturable", "uffconfigurable", "uffconfiguring", "effConfigured", "efconfigural", "ffconfigurated", "ffCerturated", "uffconfigorable", "ffPortutable", "ffconfigurate", "ffConfigured", "ffConfigural", "effPorturer", "uffConfiguer", "effConfigurable", "ffConfuer", "efconfigurate", "ffconfigorable", "ffSpecurate", "ffConfurer", "effCerturable", "efConfigurable", "ffCerturing", "ffConforable", "effCerturated", "ffLogurer", "efConfiguring", "ffPorturer", "ffConfurated", "uffConfiguring", "ffconfigural", "ffConfigurationurated"], "relativePath": [" relativeUrl", "qualifiedDir", "absoluteRoot", "relativeFile", "absoluteUrl", "relativeRoot", "relativeName", "absoluteFile", " relativeName", "qualifiedFile", "absolutePath", " relativeRoot", "relativeDir", "relUrl", "relativeUrl", "relRoot", "absoluteName", "qualifiedPath", "relDir", "absoluteDir", " relativeDir", "qualifiedName", "relPath", " relativeFile"], "file": ["path", "output", "buffer", "message", "out", "db", "word", "template", "auto", "user", "force", "header", "link", "class", "fil", "f", "issue", "pool", "folder", "local", "to", "fp", "dir", "queue", "create", " File", "frame", "use", "File", "al", "resource", "filename", "spec", "lock", "le", "e", "store", "rule", "name", "play", "view", "stream", "page", "ile", "FILE", "project", "command", "base", "set", "string", "entry", "port", "table", "log", "document", "work", "full", "format", "memory", "url", "handle", "image", "list"], "is": ["ist", "ists", "im", "ms", "ls", "ais", "es", "isc", "iso", "ris", "ic", "isl", "nis", "lis", "bis", "bs", "isa", "ires", "its", "iss", " Is", "xs", "are", "ins", "bits", "js", "ib", "Is", "isin", "fs", "ir", "iris", "us", "i", "ios", "s", "sis", "in", "ip", "isi", "IS"], "os": ["cos", "ls", "es", "OS", "ms", "oos", "iso", "ops", "des", "sys", "ui", "bos", "osi", "bs", "ds", "o", "io", "ys", "pos", "obs", "ox", "oS", "oa", "mot", "oz", "si", "Os", "fs", "ols", "los", "us", "ose", "oss", "i", "ios", "ot", "oses", " Os"]}}
{"id1": "7396682", "id2": "12783713", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["load", "core", "replace", "split", "sync", "cross", "link", "move", "repeat", "proxy", "crop", "transfer", "clip", "read", "download", "create", "cat", "slice", "map", "fit", "Cop", "delete", "write", "cop", "cp", "share", "upload", "gc", "Copy", "archive", "clone", "py", "php", "pixel", "opy", "zip"], "srcFS": ["sourceFS", "srcOS", " srcVS", "srfs", "srcFs", "srcCS", "sourceCS", "rcCS", "rcSF", " srcCS", " srcSF", "sysFS", "srcSF", "sourceVS", "srcVS", "sysFs", "srFs", "sourcefs", "srcfs", " srcfs", "rcfs", "rcFS", "sourceFs", "srMS", "srFS", "rcMS", "sysOS", "srcMS", "rcFs", " srcMS", " srcOS", "sourceSF", " srcFs", "sourceOS", "rcOS", "sysVS", "rcVS"], "src": ["path", "nil", "ser", "http", "proc", "node", "st", "addr", "RC", "boot", "sync", "SOURCE", "img", "init", "pkg", "sys", "tmp", "rx", "lb", "sin", "via", "sc", "rel", "rc", "dir", "desc", "from", "subject", "sub", "uri", "loc", "th", "resource", "obs", "filename", "Source", "rs", "spec", "pri", "iv", "syn", "comp", "req", "str", "ctr", "dest", "txt", "sec", "obj", "sit", "cont", "sn", "sr", "check", "source", "input", "selected", "secure", "sb", "https", "target", "inst", "url", "start", "sci", "usr", "sq", "supp", "cur"], "dst": ["deest", " ddest", "ddlt", "desdest", "dhdest", "dhst", "dST", " dST", "ddst", "dddest", "Dlt", "DDest", "dedest", "ddest", "DST", "dlt", "dsnd", "dgt", "deslt", "dsdest", "dsest", "Ddest", "ddnd", " dlt", "dslt", "dsST", "Dst", "lst", " dest", "desst", " dDest", "dsgt", "dest", "dDest", "ldest", "desnd", "lgt", "Dest", "dnd", "lest", "dsst", "degt", "dhDest", "dhlt"], "deleteSource": ["closeSOURCE", "deleteSources", "removeSource", "removeParent", "delSOURCE", "leteResult", "closeSite", "leteParent", "destroySources", "deleteParent", " deleteTarget", "destroyResult", "delDest", "leteSOURCE", "leteDest", "updateSource", "removeDest", "leteTarget", "DeleteSite", "updateSite", "deleteResult", "leteSource", "deleteTarget", "deleteDest", "destroyTarget", "deleteSOURCE", "updateSOURCE", "closeSourceFile", "leteSources", "updateSourceFile", "delParent", "DeleteSOURCE", " deleteResult", "destroySource", "closeSource", "deleteSourceFile", "deleteSite", " deleteSources", "delSource", "removeSOURCE", "DeleteSourceFile", "DeleteSource"], "conf": ["ch", "plan", "con", "ln", "config", "ban", "f", "params", "q", "prop", "pool", "scan", "css", "irm", "mm", "cms", "conv", "map", "cfg", "param", "acc", "cm", "ref", "Conf", "req", "cb", "comm", "fs", "lib", "conn", "check", "def", "hash", "m", "cn", "ctx", "cc", "log", "job", "comment", "co", "info", "cf", "com", "ca", "report", "cache"], "contents": ["constaves", "Content", "Contodes", " contresses", "Contents", "CONTodes", "contends", " Contresses", " contENTS", "contodes", "contresses", "CONTends", "CONTants", "constents", "CONTents", "constENTS", "Contterms", "CONTaves", "contENTS", " Contents", "content", "ContENT", "CONTterms", "CONTENTS", " Content", "CONTent", "CONTresses", " contENT", "Contants", " contodes", " ContENTS", " content", "contterms", "constends", "CONTENT", " contants", " contaves", " contterms", "contENT", "contants", "contaves", " contends"], "i": ["ims", "multi", "json", "im", "ms", "x", "j", "init", "n", "phi", "my", "it", "ai", "ini", "is", "ic", "ski", "ui", "ie", "me", "q", "id", "y", "o", "ci", "mi", "ind", "ki", "qi", "ii", "client", "gi", "hi", "key", "ti", "ji", "inner", "bi", "index", "si", "I", "span", "u", "ori", "ei", "m", "iter", "xi", "us", "iq", "cli", "ami", "docker", "di", "sim", "pi", "ij", "chain", "ip", "li", "oi", "\u0438", "ix"], "in": ["IN", "din", "con", "add", "by", "ini", "is", "ze", "mc", "and", "body", "raw", "sql", "read", "sample", "en", "inc", "from", "re", "ind", "ins", "bin", "inner", "doc", "reader", "xml", "isin", "r", "char", "In", "check", "input", "source", " din", "inn", "out", "inf", "cin"]}}
{"id1": "22441244", "id2": "4481712", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"send": ["message", "mail", "add", "save", "init", "msg", "build", "apply", "transfer", "export", "end", "create", "execute", "sent", "security", "write", "post", "get", "Send", "print", "submit", "set", "reply", "parse", "push", "report"], "hsession": ["hessions", "hsess", " HSess", "HSettings", "hsettings", "HSession", "HSsession", "rsession", "hettings", "rsess", "rssession", "HSpace", "HSess", "hhettings", "hssession", "hhessions", " HSpace", "hhsession", "hhhip", "HShip", "rspace", " HSsession", "HSessions", "hession", "hspace", "hhip", "hsessions", "hship", " HSession", "hhession"], "session": ["message", "password", "instance", "Session", "account", "connection", "manager", "state", "client", "lock", "parent", "content", "store", "name", "ession", "view", "ess", "event", "sid", "set", "object", "driver", "job", "document", "context", "ip", "cache"], "repositoryName": ["repositoryPath", "repoositoryname", "repoitoryname", "reposositoryName", "repositionName", "repositableName", "repositorName", "reposoryData", "repositorPath", "repoositoryNAME", "repositoryData", "reposoryname", "repositionNAME", "reposoryName", "repoositoryTitle", "repositorNAME", "repositoryname", "reposositoryNAME", "repositableNAME", "repositablename", "repoositoryName", "repositorTitle", "repositionPath", "repositoryNAME", "repositoryTitle", "reposositoryname", "repositableData", "repoitoryName", "repositionTitle", "repoitoryTitle", "repoositoryData", "reposositoryData", "reposoryNAME", "reposositoryTitle", "reposositoryPath", "repoositoryPath", "repoitoryNAME", "repoitoryPath", "repoitoryData"], "ideIdint": ["ideInfoINT", "IDEIdst", "ideThint", "ideIdINT", "IDEidINT", "ideThind", "ideIdind", "ideIDno", "ideDINT", "ideidst", " ideIdno", "ideIDint", " ideIdind", "ideInfoint", "ideIDline", "IDEidint", "ideIdentint", "ideInfost", "ideIdno", "ideidint", "ideIdentind", "ideIdst", "ideIDind", "ideDint", "ideIdline", " ideThline", "IDEIdint", "IDEidst", " ideThind", "IDEIdINT", "ideThno", "ideDst", " ideThint", "ideIdentno", " ideIdline", "ideThline", " ideThno", "ideidINT", "ideIdentline"], "to": ["topic", "site", "top", "st", "addr", "eto", "by", "tel", "auto", "ato", "tt", "tp", "address", "toc", "too", "no", "ta", "token", "o", "os", "pro", "t", "about", "client", "pos", "contact", "tr", "company", "po", "range", "co", "target", "TO", "To", "route", "phone"], "cc": ["cy", "cci", "mc", "ic", "ct", "ck", "toc", "sc", "cd", "rc", "ce", "ico", "cv", "ci", "cs", "cca", "control", "ac", "fc", "cm", "cr", "cmp", "cloud", "ec", "tc", "cb", "cp", "dc", "CC", "cl", "company", "cn", "ctrl", "co", "cf", "cmd", "ca", "cin"], "bcc": ["vck", "sbcy", "sbce", "cbcc", "vcc", "bce", " bck", "cbck", "vce", "bck", "rbck", "vcy", " bcm", "sbcc", "bcy", "cbcm", "bCC", " bCC", "rbCC", "rbce", "rbcy", "rbcm", "sbck", "bcm", "cbCC", "rbcc"], "subject": ["topic", "message", "text", "mail", "html", "description", "face", "prefix", "template", "head", "author", "header", "heading", "title", "metadata", "id", "note", "uri", "security", "filename", "content", "name", "Subject", "form", "source", "comment", "host"], "body": ["output", "buffer", "message", "binary", "text", "mail", "part", "json", "description", "html", "top", "template", "head", "news", "response", "b", "title", "shell", "params", "bill", "no", "h", "Body", "note", "default", "ody", "files", "back", "content", "summary", "code", "inline", "hex", "null", "inner", "any", "name", "background", "post", "bytes", "other", "business", "line", "base", "parts", "source", "object", "padding", "ODY", "comment", "bh", "query", "data", "url", "layout", "handle", "report", "zip"], "attachments": ["achmentachment", "attresses", "Attachments", "achmenttypes", "attachtypes", "atttypes", "achmentresses", "attments", "achmentments", "attachachment", "Attachtypes", "Attachachment", "attachresses", "Attachresses"], "isHtml": ["IsHtml", "isJttp", "isHip", "isChhtml", "isHHTML", " isWhhtml", "isHhtml", "isChHTML", "isVtml", "isJap", " isHHTML", "isChip", "isWhHTML", "ishttp", "isHttp", "ishhtml", " isHhtml", " isWhtml", "IsHttp", "IsHap", " isWhHTML", "isVhtml", " isWhip", "isWhhtml", "isHap", "ishtml", "isVHTML", "isChtml", "isWhip", "isVip", "isWhtml", "isJtml", "ishap", "isJhtml", " isHip", "IsHhtml"], "charset": ["charpett", "charsET", "Charsetic", "chippett", "charpetic", "CHippet", "CHippett", "clarsets", "ChARSet", "chARSet", "channelsET", "ChARSetter", "chactersetter", "quatsale", "CHarsets", "channelsetic", "clersets", "quarsec", "chARSET", "charspace", "chippale", "chippET", "chippets", "CHippET", "chablesec", "chARSetter", "channelsetter", "CharsET", "chARSetic", "clarsetter", "quatsetter", "chippec", "chableset", "charpET", "quarsale", "charsett", "chablesetter", "chersetter", "CHarset", "charpet", "cherset", "clarspace", "charsets", "ChARSetic", "quarsetter", "chatsec", "chacterset", "chatsale", "charsetic", "charsale", "chippet", "quatset", "chacterspace", "channelset", "CHarsett", "Charset", "charpets", "clarset", "chactersets", "chARSets", "chatsetter", "ChARSET", "chippetter", "Charsetter", "cherspace", "charsec", "clerset", "quatsec", "chARSpace", "charsetter", "clersetter", "charpetter", "chatset", "clerspace", "CHippets", "quarset", "chersets", "chablesale", "CHarsET"], "headers": ["ters", "dr", "limits", "head", "users", "header", "types", "ppers", "metadata", "ors", "params", "comments", "files", "lines", " trailers", "ers", "authors", "codes", "keys", " heads", "heads", "details", "fields", "relations", "names", "ilers", "members"], "priority": ["description", "password", "prefix", " severity", "properties", " urgency", "title", "grade", "id", "comments", "state", "flags", "security", "pos", "due", "serial", "position", "policy", "level", "company", "primary", "status", "profile", "origin", "context", "order", "phone"], "email": ["output", "message", "http", "mail", "html", "description", "password", "model", "template", "instance", "voice", "msg", "database", "detail", "response", "example", "echo", "link", "em", "address", "shell", "et", "console", "reset", "Email", "sample", "ome", "test", "note", "ilo", "er", "element", "ssl", "initial", "el", "liner", "ee", "server", "fax", "call", "e", "oe", "all", "delete", "office", "label", "xml", "view", "external", "contact", "license", "event", "gmail", "result", "print", "line", "entry", "object", "ne", "company", "ell", "domain", "log", "comment", "die", "document", "search", "url", "enter", "report", "il"], "user": ["output", "ident", "owner", "by", "author", "human", "used", "users", "account", "connection", "manager", "person", "me", "id", "entity", "usage", "util", "from", "creator", "User", "use", "auth", "client", "login", "browser", "name", "USER", "uid", "username", "result", "match", "actor", "profile", "system", "student", "admin", "ip", "usr", "usa"], "identity": ["instentity", "idality", "ethnicity", "idity", "recognance", "primicate", "entularity", "personificate", "ethnicitate", "IDENTality", "instularity", "presentularity", "identITY", "instifier", "idiciary", "solidularity", "equentity", "IDENTentity", "entity", "primificate", "solidality", "presentitate", "entifier", "IDENTator", "identifier", "idITY", "identality", "personicate", "identalty", "identance", "IDENTiciary", "presententity", "recognicate", "recognentity", "identator", "IDENTicate", "identificate", "equalty", "IDENTitate", "ententity", "primance", "personiciary", "IDENTITY", "instalty", "IDENTalty", "idententity", "idularity", "ethnicentity", "IDENTularity", "identiciary", "identularity", "personentity", "personITY", "equity", "primentity", "IDENTifier", "identicate", "IDENTificate", "identitate", "recognity", "equator", "instator", "IDENTity", "instity", "presentity", "personity", "IDENTance", "primity", "solidentity", "ethnicularity", "solidity"], "_returnPath": ["setsavepath", "_deletePath", "_retPath", "_replyDir", "_resultPoint", "_retUrl", "setsaveUrl", "setreturnPath", "_deleteTo", " _errorPoint", "_ReturnPoint", "_requestAddress", "setsavePath", "_getDir", "_retDir", "_returnLocation", "_requestPoint", "_retCode", "_returnUrl", "_retLocation", "_returnpath", " _errorAddress", " _errorPath", " _returnName", "_errorAddress", "_deletepath", "setreturnpath", "_replyPath", "_replyCode", "_getPath", "_returnName", "_ReturnAddress", "_returnDir", "_getTo", "_errorName", "setreturnTo", "_requestName", "_errorUrl", "_errorTo", "_returnPoint", "_errorLocation", "_retPoint", "_ReturnPath", "_returnTo", "_savepath", " _returnPoint", "_resultPath", " _errorName", "setsaveTo", "_retpath", "_resultLocation", "_ReturnName", "_saveUrl", "_requestPath", "_savePath", "_errorPath", "_returnCode", "_deletePoint", "setreturnUrl", " _returnAddress", "_errorpath", "_saveTo", "_returnAddress", "_errorPoint", "_resultTo", "_getCode", "_retTo"], "_from": ["_owner", "longsource", "remaddr", "_form", "_addr", " _form", "remfrom", "letabout", "\tfrom", " _actor", " _author", "longfrom", " _reset", "letsource", "\tauthor", " _source", "longreset", "_author", " _about", "remlocal", "remowner", "_actor", "_reset", "_source", "letto", "_about", "longto", "\tactor", "letfrom", "_local", "\tform"], "_replyTo": ["_respondTo", "_responseTO", "_replyFrom", "_backPath", "_respondOnly", "_replyLine", "_replyPath", "_commentOf", "_replyTO", "_returnTo", "_backTO", "_ReplyFrom", "_responseFrom", "_returnOnly", "_respondTO", "_closeLine", "_commentLine", "_closeOf", "_responseLine", "_closeTo", "_responsePath", "_ReplyTO", "_returnFrom", "_commentTo", "_ReplyOnly", "_responseTo", "_backTo", "_returnTO", "_ReplyTo", "_closeTO", "_ReplyPath", "_respondFrom", "_responseOf", "_replyOf", "_backFrom", "_commentTO", "_replyOnly"], "_to": ["successtopic", "successto", "successta", "_ta", "prisite", "_site", "_topic", "successsite", "prito", "prita", "pritopic"], "_cc": ["_cs", " _cca", "_subject", "_cca", " _subject", " _cs"], "_bcc": ["_racc", "_wca", "_rck", "_rbck", "_bacc", "_wcc", "_bca", "_rcc", "_wck", "_rbacc", "_rbcc", "_wacc", "_rca", "_rbca", "_bck"]}}
{"id1": "12349563", "id2": "5543349", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceIsits", " resourceexistent", " resourceexisted", " resourceIsisted", " pathExits", " pathExisted", " pathexists", " resourceIsists", " resourceexists", " resourceExits", " pathexits", " resourceexits", " pathExists", " resourceExisted", " resourceIsistent", " pathexistent", " resourceExistent", " pathExistent", " pathexisted"], "location": ["path", "message", "history", "ion", "description", "window", "program", "template", "hello", "Location", "resolution", "human", "available", "connection", "zone", "address", "reference", "usage", "local", "area", "slot", "uri", "loc", "resource", "filename", "server", "translation", "library", "direction", "LOC", "where", "module", "name", "position", "family", "uration", "href", "directory", "remote", "command", "ocation", "string", "behavior", "point", "padding", "localhost", "file", "availability", "value", "zo", "system", "comment", "document", "country", "search", "layout", "color"], "url": ["out", "http", "mail", "con", "ls", "sl", "n", "open", "ret", "build", "pkg", "bel", "user", "b", "ur", "Url", "f", "address", "ul", "URL", "h", "pl", "ssl", "dl", "nl", "loc", "t", "client", "gl", "call", "google", "str", "mount", "ll", "l", "u", "char", "www", "base", "https", "cert", "cmd", "r", "res", "hl"], "cxn": ["Ctxnn", " cexN", " cxnor", "cwxns", "cxxns", "cxxnor", "Cxnn", "Cxns", "Cxn", "conN", "cexn", "cwxnn", "cwxN", "connn", "cexN", "CxN", "ctxn", "cxN", "ctxnor", "cxxN", "cxnor", " cxns", "conns", "cexnor", "cxxn", "Ctxn", "cwxn", "ctxnn", " cxN", "cexns", "CtxN", "conn", "cxns", "cxnn", " cexn", "Ctxns", "ctxns", " cexns", "ctxN", " cexnor"], "is": ["ims", "ists", "im", "ms", "ais", "isc", "abs", "es", "tis", "iso", "ris", "init", "dis", "ois", "sys", "isl", "has", "bis", "bs", "isa", "ires", "as", "its", "iss", "os", "does", "ys", "bits", "ps", "rs", "serv", "isf", "ts", "still", "si", "Is", "isin", "ir", "fs", "iris", "isi", "i", "oss", "ios", "info", "sis", "s", "in", "ip", "was", "lis", "IS"], "byteBuffer": [" byteWindow", "bufferWindow", "byteWindow", "binaryContext", "basicBuffer", "byteQueue", "binaryBuffer", "basicMatrix", "noteQueue", " byteMatrix", "byteFlow", "basicFlow", "basicQueue", "byteMatrix", "bufferSet", "noteMatrix", "noteFlow", "binaryWindow", " byteFlow", "bufferContext", "bufferBuffer", "byteSet", " byteQueue", "byteContext", "noteBuffer", " byteSet", "binarySet", " byteContext"]}}
{"id1": "12066447", "id2": "16719805", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["trvalidize", "truncicate", "extvalidate", "trvalidation", "extuncation", "trculicate", "trvalidate", "trunate", "truncize", "trculation", "trunation", "trunize", "extvalidize", "trculate", "trvalidicate", "extuncize", "extvalidation", "extvalidicate", "truncation", "extuncicate", "extuncate", "trunicate", "trculize"], "file": ["path", "message", "word", "model", "or", "block", "time", "template", "user", "type", "link", "handle", "class", "attribute", "f", "local", "to", "fp", "dir", "create", "from", "frame", "io", "size", "use", "File", "files", "channel", "resource", "current", "filename", "spec", "lock", "parent", "le", "run", "e", "tree", "this", "be", "null", "module", "name", "get", "page", "ile", "event", "line", "base", "FILE", "source", "object", "port", "table", "log", "range", "info", "foo", "data", "full", "format", "work", "out", "image", "report", "zip"], "backupRoot": ["workupidDir", " backuproot", "BackupidFolder", "workupidBoot", "backumpRoot", " backupidroot", "workupidHome", "backuproot", "backupidBox", "backupDir", "backupidBoot", "backupsroot", "backumpDir", "BackupidRoot", "workuproot", "backupidRoot", "backureBoot", "backuperroot", "backupidFolder", "backdownFolder", "backureHome", "backupHome", "workupDir", "backureDir", "BackupRoot", "backureroot", "backupBoot", "backflowDir", " backupidBox", "backdownRoot", "backmproot", "backupsRoot", "backupidDir", "backupidHome", "backuperHome", "backmpRoot", " backupDir", "backumproot", "backupsDir", " backupBox", "backdownDir", "backupFolder", "workupHome", "backupidroot", "backupsBox", "workupidroot", "backmpBoot", "backmpDir", "workupBoot", "backflowRoot", " backupidDir", "backupBox", " backupidRoot", "BackupidDir", "backuperRoot", "workupRoot", "backuperDir", "backflowFolder", "BackupFolder", "workupidRoot", "backureRoot", "BackupDir", "backumpBox"], "df": ["dp", "dr", "bf", "db", "Def", "lf", "pdf", "dx", "sd", "f", "raf", "ds", "cd", "deb", "mm", "dm", "dt", "dep", "dl", "uf", " pdf", "du", "gd", "DF", "d", "dd", "dc", "dim", "fun", "NF", "md", "tif", "pd", "def", "tf", "di", "format", "fd", "cf", "hd", "sf"], "date": ["output", "message", "update", "save", "time", "now", "cal", "zone", "grade", "future", " Date", "dat", "duration", "create", "late", "frame", "down", "default", "dt", "note", "month", "dates", "resource", "Date", "tag", "content", "run", " day", "module", "name", "version", "due", "days", "dated", "day", "number", "get", "today", "sum", "event", "standard", "daily", "string", "value", "match", "range", "data", "format", "year", "age", "start", "ate", "when"], "zipFile": ["zipStore", "logPath", "jsonFile", "pdfPath", "ZipPath", "jsonfile", "zipStream", "ZipStream", "logfile", "logFilename", "pdffile", "jsonFilename", "pdfStream", "logFile", "zipfile", "zFile", "logStream", "ZipFile", "pdfFile", "zStore", "zipFilename", "zFilename", "zfile", "zipPath", "Zipfile", "jsonStore", "logStore"], "zos": ["asio", "cos", "sbm", "zen", "zi", "asar", "hz", "zik", "jas", "ss", "ze", "zan", "bs", "za", "zin", "ez", "hess", " sands", "rez", "ozo", "zers", "ses", "os", "zon", "css", "hs", "zag", "zes", "zzle", "estro", "ones", "webkit", "js", "enos", "sol", "zb", "bes", "eros", "esm", "enz", "cz", "stice", "south", "zer", "los", "shed", "sch", "z", "zo", "zar", "oss", "ros", "tz", "sis", "oses", "zona", "Sax", "nz"], "fis": ["sfiss", " fiss", "sfits", "cfis", "Fia", "if\u00eds", "fiis", "FIs", "ofis", "ofois", "ifIs", "Fisc", "fiiss", "fiois", "foIs", "dfier", "ofits", "cfisc", "cfits", "lIs", "fib", "sfisc", "F\u00eds", "fiss", "f\u00eds", "Fis", "sfIs", "fi", "fier", "dfis", "foia", "Fiss", "foi", "lia", "efis", "ifis", "dfiss", "efisc", "efIs", "cfiss", " fib", "fits", "fIs", "ifisc", "fiib", "Fier", "dfIs", "fisc", "Fi", "ofib", " fois", "fois", "ofiss", "ef\u00eds", "fia", "li", "sfier", "ofisc", "sfis", "lis"], "entry": ["ment", "ion", "description", "cell", "add", "tex", "internal", "or", "cue", "rance", "member", "ent", "section", "se", "ie", "and", "attribute", "connection", "sheet", "ary", "entity", "ry", "row", "ce", "element", "resource", "deep", "e", "delete", "key", "office", "xml", "ace", "char", "obj", "event", "record", "command", "object", "set", "def", "comment", "zo", "escape", "option", "data", "search", "Entry", "insert", "word", "de", "zip"], "buffer": ["message", "Buffer", "binary", "window", "block", "phrase", "buf", "template", "volume", "button", "header", "available", "bar", "attribute", "variable", "sample", "letter", "queue", "frame", "buff", "category", "length", "library", "code", "view", "screen", "char", "page", "sequence", "command", "batch", "base", "padding", "iter", "table", "zero", "comment", "stack", "document", "memory", "paste", "append", "word", "temp", "cache"], "readed": ["findared", "readd", "counted", "counter", "indexED", "countd", "ReadED", "READd", "readableared", "finded", " readED", "readED", "readeded", "rededed", "readableED", "findied", "Readd", "READed", "reded", "redented", "readented", "reader", "readared", " readeded", "Reader", "readableied", "redED", "readableed", "Readed", "indexented", "indexeded", "countED", "indexed", "READED", "Readared", "Readied", "findED", "READer", " readented", "readied"]}}
{"id1": "14609912", "id2": "2511579", "code1": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 0, "substitutes": {"lastModified": ["LastVerification", "LastModUsed", "LastVerified", "lastQualUsed", "LastVerUsed", "lastModUsed", "lastQualification", "lastMinUsed", "lastModification", "LastModification", "lastMinification", "lastModmented", "lastVerification", "lastVerified", "lastMinmented", "lastQualmented", "LastVermented", "lastQualified", "lastVerUsed", "LastModmented", "lastVermented", "LastModified", "lastMinified"], "url": ["http", "abs", "sl", "user", "ret", "build", "link", "ur", "b", "Url", "address", "URL", "re", "ssl", "uri", "dl", "nl", "client", "browser", "ref", "run", "key", "name", "str", "mount", "ll", "dll", "get", "l", "char", "page", "un", "string", "file", "job", "web", "cert", "cmd", "in", "host"], "conn": ["ch", "nec", "nc", "connect", "db", "con", "cell", "close", "addr", "j", "n", "open", "gate", "connection", "ct", "socket", "sql", "dat", "enc", "pas", "conv", "loc", "client", "resp", "serv", "nt", "canon", "cb", "cons", "comm", "obj", "exec", "net", "ctx", "cn", "oss", "cert", "jp", "res", "cmd", "fin", "Conn", "c", "cur"]}}
{"id1": "14047629", "id2": "13063241", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"source": ["output", "buffer", "proc", "message", "expression", "se", "SOURCE", "seed", "shell", "address", "q", "ource", "sql", "console", "sample", "iterator", "from", "channel", "resource", "Source", "content", "request", "src", "reader", "stream", "service", "position", "sequence", "event", "result", "input", "copy", "file", "system", "query", "data", "format", "in", "image"], "process": ["place", "proc", "session", "connect", "function", "task", "node", "pm", "term", "program", "method", "se", "init", "build", "link", "sys", "and", "class", "condition", "processor", "p", "state", "console", "make", "flow", "create", "execute", "frame", "pid", "use", "pp", "pipe", "component", "run", "Process", "code", "processing", "call", "script", "store", "post", "cp", "service", "thread", "complex", "command", "project", "check", "mem", "object", "status", "file", "job", "parse", "chain", "work", "memory", "context", "cmd", "handle", "exec", "network"], "processStdOut": ["processStrdIn", "processStrrEr", "processStstdOut", "processStstEx", "processStrdEx", "processStrIn", "processStrOut", "processStstdIn", "processStstdEx", "processStrrOut", "processStdEr", "processStstIn", "processStrdEr", "processStrrIn", "processStstOut", "processStdEx", "processStstEr", "processStrdOut", "processStstdEr", "processStrEr", "processStrrEx", "processStrEx"], "processStdIn": ["processStackdin", "processStackdIN", "processSttIns", "processStackdsIn", "processStsin", "processStsOut", "processStdsIn", "processStrIn", "processStsIn", "processStrIN", "processStrOut", "processStdIN", "processStackdsIN", "processStackdsOut", "processStrin", "processSTtIn", "processSTtOut", "processStackdOut", "processSTdIns", "processStdin", "processStsIN", "processStdIns", "processSTdIn", "processSttIn", "processSttIN", "processStrIns", "processStackdsin", "processSTdIN", "processSTdOut", "processStdsIN", "processStdsIns", "processStackdIn", "processSTtIns", "processStdsOut", "processStdsin", "processSTtIN", "processSttOut"]}}
{"id1": "10218878", "id2": "18748516", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFromLog", "DecvertMAPFile", "DecvertMAPFiles", "DecodeToFiles", "DecodeTofile", "DecodeMapFiles", "DecvertMAPLog", "DecodeMapfile", "DecodeMAPLog", "DecodeMAPfile", "DecodeToFile", "DecvertMAPfile", "DecvertMapfile", "DecvertMapLog", "DecodeFromfile", "DecvertMapFile", "DecvertMapFiles", "DecodeFromFiles", "DecodeToLog", "DecodeMAPFile", "DecodeFromFile", "DecodeMapLog", "DecodeMAPFiles"], "mapFile": ["listFile", "imageFilename", "cacheFILE", "mapfile", "MapFile", " mapPath", "Mapfile", "imagefile", "MapStream", "imageFile", "listFILE", "listPath", "mapStream", "mapFILE", "cachePath", " mapFILE", " mapfile", "mapPath", "mapFilename", " mapFilename", " mapStream", "cacheFile", "imageStream", "MapFilename"], "outputFile": ["inputName", "outputName", "outputFilename", "outFile", "mapName", " outputPath", "OutputPath", "inputStream", "writeFile", "outFilename", "mapStream", "outputDir", "inputDir", "outPath", "OutputFilename", "writeName", "mapDir", "writeDir", " outputDir", "inputFile", "OutputFile", "writeStream", "OutputDir", " outputFilename", "outputStream", "outDir", "outputPath"], "magicKey": [" magicField", "magicCounter", "MagicName", "encryptedField", "anticField", "MagicId", "serialId", "magicName", "magicCode", "encryptedChar", " magicCode", "prefixCode", "magickey", "anticChar", "MagicKey", "magicId", "prefixKey", "uniqueCounter", "magicKEY", " magicId", " magickey", "uniqueKey", " magicName", " magicKEY", "anticKey", "magicField", "magicChar", "serialKey", "prefixCounter", "MagicKEY", " magicChar", "uniqueCode", "antickey", " magicCounter", "serialKEY", "uniqueValue", "encryptedKey", "encryptedkey", "prefixValue", "magicValue", "serialName", " magicValue"], "buffer": ["bo", "message", "Buffer", "binary", "history", "shape", "black", "window", "block", "program", "phrase", "buf", "template", "button", "header", "database", "detail", "attribute", "filter", "variable", "row", "sample", "queue", "frame", "bone", "total", "initial", "buff", "length", "code", "flash", "index", "stream", "screen", "bridge", "char", "page", "vector", "sequence", "sum", "print", "command", "batch", "base", "mem", "check", "iter", "table", "stroke", "stack", "document", "pad", "memory", "display", "paste", "append", "cache"], "nread": [" nwrite", "maxadd", " ntry", "nreader", "NRead", "nadd", " nreader", "nREAD", "renwrite", "Nreadable", "maxread", "rnRead", "rawwrite", " nRead", " nREAD", "ncread", "rnwrite", "nRead", "Nwrite", "rentry", "renreader", "NREAD", "rawreader", "nreadable", "ncwrite", "ncget", "rnREAD", " nreadable", "ncRead", "rawtry", "ncadd", "rawread", "Nadd", "Nget", "nwrite", "maxget", "maxRead", "rnread", "ntry", "renread", "ncreadable", "nget", "Nread"], "map": ["place", "load", "per", "shape", "mask", "window", "con", "block", "ape", "man", "config", "open", "MAP", "ip", "collect", "manager", "ml", "address", "master", "make", "read", "apping", "down", "mt", "pl", "pose", "op", "up", "apper", "lock", "cm", "clear", "mate", "where", "module", "ap", "maps", "mount", "view", "ace", "bridge", "mp", "mod", "form", "batch", "meta", "mem", "set", "m", "table", "file", "parse", "app", "co", "memory", "aps", "com", "image", "pack", "cache"], "output": ["update", "plain", "block", "auto", "open", "Output", "four", "response", "put", "latest", "socket", "can", "entity", "console", "o", "queue", "icon", "ilo", "client", "current", "ou", "exit", "oe", "write", "next", "stream", "blue", "hidden", "other", "online", "net", "result", "print", "batch", "input", "object", "port", "file", "log", "secure", "web", "target", "display", "format", "out", "outer", "cache", "network"], "i": ["multi", "ms", "x", "j", "n", "phi", "it", "spin", "ini", "ai", "is", "ic", "ie", "ui", "ri", "b", "q", "iu", "id", "y", "fi", "ish", "mi", "ci", "ind", "gu", "uri", "ii", "t", "qi", "v", "gi", "g", "ti", "bi", "ji", "ni", "index", "si", "I", "span", "u", "ei", "batch", "m", "xi", "cli", "us", "ami", "di", "sim", "pi", "ip", "li", "ix"]}}
{"id1": "14390569", "id2": "7143591", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"title": ["message", "text", "html", "description", "password", "prefix", "term", "notice", "template", "msg", "header", "type", "heading", "metadata", "holiday", "itle", "size", "subject", "help", "t", "filename", "setup", "content", "summary", " Title", "name", "label", "TIT", "parts", "details", "tip", "string", "padding", "theme", "hash", "lead", "layout", "start", "Title", "hd", "question"], "imageURL": ["imageUrl", "photoID", "photoString", "photoURL", " imageString", "mediaURI", "fileString", "ImageURL", "mediaURL", " imageUrl", "photoUR", "photoURI", "mediaID", "ImageURI", "imageUR", "ImageUrl", " imageURI", " imageUR", "fileURI", "fileURL", "mediaUrl", "ImageID", "imageURI", "photoUrl", "imageID", "ImageUR", "imageString", "fileUrl"], "jd": ["jobd", "ajds", "Jd", "simD", "jad", "zad", "Jmd", "jD", "javads", "kd", "djad", "JD", "jc", "ijd", "jsD", "Jbd", "jspd", "gds", "jsd", " jds", "gbd", "jds", "djc", "ajpd", "gdo", "qdo", "jsdm", "qds", " jdt", "jjd", "jjD", "ujD", "jjbd", "zd", "ijds", "ajd", " jc", " jad", "qD", "javapd", "jobdo", "jobdt", "javad", "kds", "ujmd", "kbd", "javadm", "qbd", "kdo", "djdo", "zsd", "Jds", "ujdt", "jjp", "Jp", "simd", "ijD", "djd", "Jdt", "Jc", "qd", "gd", " jdo", "Jdo", "jmd", "jdm", "ujad", "kdt", "jdo", "jdt", " jsd", "jpd", "ajdm", "jbd", " jD", "djds", "simmd", "simdt", "Jad", "djsd", "ujd", "qp", "jsds"], "jl": ["elt", "kel", "dyl", "jet", "j", "ln", " li", "elle", "isl", "ijk", "jj", "igl", "elly", "lp", "kj", " ol", "dj", "ja", "dl", "ibl", "nl", "uj", "yl", "bol", "js", "syn", "ji", "jin", "jc", "dll", "jac", "Label", "txt", "kl", "jah", "bj", "kn", "abl", "mil", "J", "ell", "rl", "ij", "gn", "li", "lv", "lu", "il"], "icon": [" lang", "iao", "fn", "ocon", " intent", " ion", " Icon", "ion", "iban", "con", " conn", "cil", " captcha", "icons", "font", "ICO", "ic", " ancestor", " widget", "pen", "ico", "conv", "nic", "ex", "png", "lock", "eric", "syn", "addon", "\u4e2d", "jc", "label", "icol", "Icon", " tip", "conn", "gc", " screen", "cn", "chron", "pic", " canvas", " fruit", "image", "fa"], "chooser": ["Choicer", " chooder", "comperer", "poose", " choose", "Choose", "composen", "CHOoser", "composer", "Chooder", " choerer", "compicer", " choosen", "poicer", "chooder", "choerer", "boerer", "booser", "pooser", "Choosen", "boose", "choicer", " choicer", "Chooser", "CHOicer", "CHOosen", "boosen", "compose", "choose", "pooder", "choosen", "CHOose"], "jp": [" je", "btn", " dj", "j", " gp", " pic", " cp", " pl", "bp", "p", "kj", " ip", "np", "ja", " sp", " joint", " mp", "js", "JP", " sip", "jc", "jin", " np", "bj", "pic", "sp", "ij", " ja", " ap"], "jb": ["jbd", " jbd", "kjbd", " jcb", "kjb", "Jcb", "qcb", "Jbd", "kjcb", "qb", "jcb", "qbd", "Jb"], "e": ["ev", "es", "or", "n", "it", "a", "te", "ie", "f", "p", "o", "en", "re", "ed", "er", "t", "ee", "v", "E", "g", "d", "w", "u", "event", "m", "s", "c", "Event"], "returnVal": ["getValid", "ReturnValue", "returnVol", "Returnval", "responseVAL", "getVol", "retValue", " returnVol", "returnValue", "returnval", "getVal", "returnValid", "responseVol", "returnVAL", "ReturnVal", "retval", " returnValue", "responseVal", "retVAL", " returnval", "ReturnVAL", "retVal", " returnVAL", " returnValid", "responseValid", "getVAL"], "file": ["path", "buffer", "real", "place", "http", "db", "word", "core", "model", "or", "valid", "open", "user", "fe", "type", "link", "class", "f", "body", "h", "to", "local", "fp", "dir", "io", "relation", "create", "File", "channel", "resource", "filename", "le", "library", "run", "tree", "be", "null", "rule", "name", "angle", "get", "page", "fs", "ile", "FILE", "base", "source", "drop", "status", "port", "table", "stat", "document", "foo", "target", "format", "full", "work", "info", "handle", "image", "report", "il"], "fileName": ["imagePath", "fileFace", "handlename", "FileSystem", "FILEPath", "imageName", "FileFace", "FileName", "fileClass", " fileSystem", "FileNAME", "ilename", "handleName", "Filename", "FileSet", "taskname", "ileNAME", "FilePath", "fileNames", "FILESystem", "imagename", " fileNames", "filename", "taskPath", "fileSet", "entityName", "handleClass", " filename", "FILEName", "FILESet", "entityNAME", "filePath", "FILENames", " filePath", "taskFace", "imageNAME", "taskName", "fileSystem", "entityPath", " fileClass", "ileName", "handleNAME", "FileExt", "FILEExt", " fileExt", "entitySet", "FileNames", "ileClass", "imageFace", "fileNAME", "FILENAME", "fileExt", " fileNAME"], "ext": ["part", "lex", "exe", "exc", "ct", "xt", "enc", "end", "dir", "test", "desc", "ind", "Ext", "ex", "t", "fr", "EXT", "sem", "typ", "ag", "xp", "vert", "hex", "req", "aux", "cod", "pat", "ec", "external", "ord", "txt", "lib", "cont", "eur", "def", "exp", "off", "cmd", "word", "prot", "ix", "len"], "i": ["j", "init", "phi", "it", "ini", "ai", "is", "ui", "iu", "id", "y", "fi", "mi", "ci", "ii", "qi", "gi", "hi", "ti", "bi", "index", "si", "I", "ei", "print", "m", "status", "xi", "ori", "di", "pi", "info", "cli", "li"], "doIt": ["diWhich", " doWhich", " doHe", "doneIt", "diHe", "odoIT", "waIT", "waIs", "didIs", " doIT", "odoIt", "donYou", "doWhich", " doYou", "doIT", "odoHe", "donIt", "doneit", "doYou", "doneIT", "donit", " doIs", "waIt", "didYou", " doit", "doIs", "odoWhich", "didit", "diit", "odoit", "doHe", "donIs", "didIt", "diIt", "doit", "donIT"], "src": ["ser", "http", "proc", "st", "sl", "init", "sys", "tmp", "rx", "lb", "gs", "ource", "crop", "sc", "rc", "rel", "from", "sub", "ssl", "conv", "ins", "loc", "rs", "syn", "rest", "comp", "rt", "ources", "inner", "impl", "ctr", "sh", "ptr", "sec", "cont", "sr", "source", "copy", "input", "rob", "rl", "trans", "sb", "https", "inst", "url", "start", "r", "usr", "sq", "rb"], "dest": ["output", "proc", "st", "est", "orig", "des", "sys", "tmp", "master", "can", "dat", "rel", "gest", "cat", "local", "dir", "coord", "desc", "pas", "loc", "pipe", "foreign", "slave", "dist", "cp", "nw", "pot", "Dest", "cont", "mem", "source", "trans", "iter", "nom", "port", "decl", "https", "target", "sp", "comb", "origin", "out", "usr", "temp", "rest", "way"]}}
{"id1": "10131427", "id2": "771802", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "Copyfile", " CopyImage", "CopyImage", "CopyStream", " cpfile", " cpStream", " copyStream", " copyImage", " CopyStream", " Copyfile", " cpImage", " CopyFile", " copyfile", " cpFile"], "in": ["IN", "on", "din", "gin", "st", "n", "it", "rin", "is", "ic", "vin", "b", "old", "o", "en", "inc", "from", "mm", "ind", "ins", "ar", "el", "up", "edIn", "isin", "l", "r", "In", "input", "source", "i", "s", "inn", "inf", "cin"], "out": ["output", "ch", "n", "Out", "it", "b", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "serv", "nt", "str", "w", "l", "net", "err", "OUT", "check", "gt", "ne", "file", "log", "po", "i", "oss", "ot", "s"], "sourceChannel": ["singleApplication", "seedChannel", "srcChannel", "sourceButton", "singleChuck", "inputConnection", "resourceConnection", "sourceApplication", "singleButton", "ourceChannel", "sourceChain", " sourcechannel", "srcStream", "matchChuck", "srcButton", "SourceStream", "ourceButton", "sourceChan", "srcchannel", "resourceChannel", "sourceChuck", "Sourcechannel", "ourceConnection", "inputChan", "seedButton", "SourceChannel", "inputChain", "sourceStream", "sourcechannel", "ourcechannel", "matchApplication", "resourcechannel", "ourceStream", "seedApplication", "matchChannel", "seedChuck", " sourceConnection", "ourceChan", " sourceStream", "ourceChain", "singleChannel", "SourceConnection", "resourceStream", " sourceChan", " sourceChain", "matchButton", " sourceButton", "sourceConnection", "inputChannel"], "destinationChannel": ["desticationCow", "destinatoryCow", "destinatedChannel", "destinationClient", "desticationChannel", "DestationChannel", "destinatoryBlock", "destensionClient", "destensionChan", "DestinationConnection", "destationConnection", "destinatedConnection", "DestationConnection", "destinationsChan", "DestationCow", "destinationsContext", "DestinationChannel", "DestinationBlock", "DestationChan", "destinatoryChan", "DestensionConnection", "destinationsChannel", "destinatedContext", "DestinationContext", "DestensionChan", "destensionConnection", "DestationContext", "DestinationChan", "destinationContext", "destroyChannel", "DestationBlock", "destinationCow", "destensionChannel", "destinationBlock", "DestinationCow", "destationChan", "destationBlock", "destroyClient", "destationChannel", "DestensionClient", "destinatoryChannel", "destationContext", "destinationChan", "destroyConnection", "destationCow", "desticationChan", "destinationsConnection", "DestensionChannel", "destinatedChan", "DestinationClient", "destinationConnection", "desticationBlock", "destroyChan", "destationClient"]}}
{"id1": "8069594", "id2": "14231545", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "Copyfile", " copyingDirectory", "CopyDirectory", " cpfile", " copyDirectory", " cpDirectory", " copyHeader", " copyingFile", " cpHeader", " copyingfile", " copyingHeader", " copyfile", " cpFile", "CopyHeader"], "in": ["IN", "on", "gin", "st", "im", "or", "by", "init", "n", "it", "rin", "ini", "is", "ic", "old", "id", "as", "o", "h", "local", "en", "inc", "from", "mm", "irm", "ind", "ins", "ar", "el", "bin", "inner", "xml", "isin", "l", "In", "input", "source", "i", "info", "s", "inn", "inf", "cin"], "out": ["output", "ch", "on", "update", "n", "Out", "it", "ent", "msg", "b", "o", "inv", "to", "end", "os", "io", "OU", "help", "ex", "outs", "t", "op", "up", "v", "ou", "parent", "nt", "at", "write", "null", "name", "w", "one", "l", "net", "OUT", "gt", "ne", "file", "log", "i", "oss", "ot", "target", "s"], "inChannel": ["innChan", "inputConnection", " inFace", " inCommand", "inChuck", " inButton", "inConnection", " inConnection", "InHandler", "inFace", "issueButton", "cinChannel", "inVolume", "cinFace", "cinFilter", "inHandler", "inchannel", "innFilter", "InChannel", "iChan", " inchannel", "inChan", "inputChan", "Inchannel", "binChuck", " inFilter", "iHandler", " inChan", "outchannel", "issueFace", "issueChannel", "inCommand", "issueCommand", "netChannel", "binClient", "netClient", "inputchannel", "inFilter", "cinButton", "binChannel", " inVolume", "innChannel", "iChannel", "binVolume", "outChan", "cinCommand", "netVolume", "outConnection", "netChuck", " inChuck", "InChan", " inHandler", "inButton", "ichannel", " inClient", "cinChan", "inputChannel", "inClient"], "outChannel": ["courseSection", "outerCategory", "netChain", "netSection", "noteChan", "tmpCategory", "inConnection", "noteCategory", "outField", "tmpChannel", "outerButton", "tmpButton", "outputConnection", " outCategory", "inchannel", "onCategory", "tmpChan", " outchannel", "inCategory", "noteButton", "courseField", "inChan", "outchannel", "outputchannel", " outConnection", "netChannel", " outSection", "onButton", "onChannel", " outButton", "outputChan", "outerChannel", " outChain", "outButton", "outChain", " outChan", "outChan", "courseChain", "outputChannel", "onChan", "outConnection", " outField", "courseChannel", "noteChannel", "outSection", "outCategory", "inButton", "netField", "outerChan"]}}
{"id1": "647224", "id2": "8079516", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["uploadfile", "saveFile", "putfile", "putFiles", "savefile", " uploadFiles", "uploadFiles", "putImage", "putFile", "saveFiles", " uploadImage", "uploadImage", "saveImage", " uploadfile"], "inputFile": ["updateLine", "inputPath", "infoFilename", "inputFILE", "infoFile", "targetField", "evalField", "inputLe", " inputfile", "fromField", "outputfile", "Inputfile", "inputField", "updateOne", " inputFILE", "thisFile", "evalFile", "InputFiles", "fromFile", "inputResource", " inputLine", " inputLe", "imgOne", "inputFilename", "imgFile", "inputFiles", " inputFiles", "evalResource", "fromResource", "thisPath", "inFilename", "targetResource", "imgLe", "imgLine", "thisfile", "InputLine", "targetFILE", "inFILE", "updateFile", "infoLine", "outputFiles", " inputOne", "inFile", "inputOne", " inputFilename", "InputFile", "inLine", "outputLine", " inputPath", "outputPath", "evalFILE", "thisLine", "inputLine", "fromFILE", "infoFILE", "updateLe", "inputfile"], "targetFile": ["detailDir", "targetDate", "targetFilename", "outputFolder", "outputFilename", "sourceFiles", "targetFolder", " targetDate", "TargetFILE", " targetPath", "sourceDir", "sourceFolder", "TargetFile", "TargetPath", "outputfile", "TargetFiles", "toDir", "targetPath", "tofile", "TargetString", "sourcePath", "sourceFilename", "outputDir", "detailFILE", "sourceDate", "toFile", "detailString", " targetString", "targetFILE", "detailFile", " targetDir", "TargetDir", "targetFiles", " targetFilename", "targetString", "targetDir", "sourceFile", "toFolder", "outputDate", "outputFiles", "sourcefile", " targetFILE", "targetfile", "outputPath"], "outputFile": ["displayFile", "outputLog", "displayPlace", "putfile", "targetFilename", "outputStore", "sourceFiles", "outputFilename", "outputGe", "displayStore", "outputFILE", "inputLog", " outputFiles", "putFile", "putPlace", " outputDo", "sourceDir", "noFile", "outputPlace", " outputFILE", "removePlace", "outStyle", " outputModel", " outputStore", "removeFile", "nullModel", "noPlace", "nullStyle", "outputfile", " outputStyle", "outModel", "removeFILE", "outFiles", "displayFILE", "outputDirectory", "targetDirectory", "inputFilename", "inputFiles", "outputDir", "noGe", "inputDo", "inputDirectory", "inputDir", "targetLog", "nullFile", " outputfile", "outputStyle", "outputDo", " outputDir", "outfile", " outputLog", "removeStore", " outputPlace", "targetFiles", " outputDirectory", "targetModel", "outputFiles", "sourceFile", "targetDir", "sourcefile", "targetfile", "putGe", " outputGe", "nofile", "outputModel", " outputFilename", "inputModel", "outDo", "outDir", "nullfile", "outFile", "inputfile"], "in": ["IN", "on", "per", "din", "con", "im", "by", "init", "it", "ini", "rin", "is", "ze", "mc", "ai", "ic", "ri", "ain", "read", "en", "inc", "io", "mm", "ind", "like", "al", "ins", "ar", "el", "bin", "inner", "isin", "l", "In", "input", "source", "iter", "i", "ro", "info", "inn", "act", "inside", "inf", "cin"], "out": ["output", "IN", "list", "on", "cos", "con", "vol", "by", "ln", "n", "Out", "auto", "it", "dis", "sys", "and", "b", "put", "can", "console", "o", "aos", "os", "to", "end", "io", "outs", "t", "ex", "client", "up", "v", "ou", "outer", "nt", "all", "write", "g", "null", "at", "writer", "name", "inner", "println", "screen", "sum", "obj", "err", "net", "print", "OUT", "cn", "log", "co", "ot", "s", "we", "conf", "res", "report", "cache"], "line": ["field", "message", "ide", "node", "cell", "block", "lin", "phrase", "ln", "lo", "eline", "detail", "link", "lane", "entity", "row", "sample", "frame", "nl", "lock", "code", "inline", "ine", "rule", "label", "edge", "LINE", "l", "page", "sequence", "record", "entry", "command", "point", "stroke", "log", "comment", "chain", "range", "query", "column", "word", "Line"], "bytes": ["uses", "units", "otes", "ls", "amples", "es", "lements", "gets", "sofar", "ows", "times", "gs", "bps", "bs", "comments", "odes", "frames", "ales", "rows", "pages", "reads", "les", "cells", "outs", "lines", "files", "bits", "steps", "classes", "xes", "books", "ones", "comes", "terms", "ips", "bes", "ites", "errors", "values", "parts", "ices", "vals", "oms", "gments", "tes", "Bytes", "nets", "ends", "ges", "blocks", "seconds", "ies", "bles"]}}
{"id1": "838844", "id2": "19096138", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["consverting", "converted", "converts", "Conversion", "converting", "compversion", "CONverting", "conprocess", "compprocess", "CONversion", "consversion", "consVERT", "unverted", "compverts", "CONfer", "ConVERT", "CONVERT", "Converting", "unprocess", "unvert", "unversion", "Converted", "unverts", "compvert", "conversion", "Convert", "conVERT", "unfer", "confer", "Conprocess", "Converts", "consvert", "CONvert", "CONverted", "Confer"], "src": ["path", "ser", "http", "attr", "st", "orig", "addr", "RC", "config", "SOURCE", "img", "pkg", "sys", "rx", "sin", "ur", "ource", "sc", "rel", "rc", "its", "scan", "scene", "from", "ebin", "buster", "uri", "ins", "loc", "filename", "Source", "rs", "iv", "rest", "dist", "req", "str", "stream", "upload", "txt", "href", "cont", "sit", "sr", "source", "input", "file", "cc", "ipl", "usr", "func", "inst", "s", "url", "start", "host", "hl", "sq", "SourceFile", "cur"], "dest": ["disk", "gin", "est", "orig", "img", " Destination", "dat", " orig", "dir", "test", "foreign", "write", "dist", " destinations", "txt", " destination", "result", "Dest", "tif", "source", "port", "table", "target", " dst", "mat", "temp", "rest", " Dest"], "in": ["IN", "din", "st", "rin", "is", "b", "as", "sql", "en", "io", "from", "ind", "ins", "ar", "el", "up", "bin", "serv", "inner", "reader", "d", "stream", "isin", "r", "l", "In", "input", "source", "m", "file", "i", "inn", "res", "inf", "ad", "cin"], "p": ["vp", "dp", "P", "pm", "per", "part", "ping", "j", "rep", "it", "pkg", "b", "prot", "f", "tp", "pg", "lp", "parser", "wp", "pa", "h", "fp", "pl", "pro", "er", "t", "op", "pt", "ps", "pre", "at", "g", "ap", "pb", "cp", "d", "post", "l", "pc", "c", "pe", "pd", "m", "ph", "parse", "i", "sp", "pi", "py", "pers", "jp", "php", "r", "pp"], "ds": ["loads", " ads", "workers", "ports", "bs", "iffs", "ss", "its", "aws", "dt", "obs", "lists", "yes", "ils", "dh", "ads", "terms", "ats", "nas", "dds", "tes", " dd", "db", "vs", " des", "des", "tp", "ws", "uds", "qs", "hs", "cs", "dl", "outs", "ks", "dd", "points", "pd", "edes", "ls", " d", "sd", "gs", " DS", "cks", "os", "Ds", "DS", "dates", "tests", "rs", "ags", "ods", "gd", "scripts", "d", "docs", "ands", "els", "ras", "ts", "dp", "posts", "drivers", "dos", "ys", "xs", "eds", "amps", "ps", "tags", "mys", "js", "ns", "sts", "df", "di", " os", "s", "eps", "hd", "sets"], "format": ["output", "path", "style", "top", "shape", "template", "it", "type", "title", "filter", "ct", "f", "id", "pretty", " Format", "size", "sche", "lat", "mt", "feat", "feature", "t", "Format", "spec", "mode", "fc", "fm", "tag", "settings", "at", "module", "version", "ats", "MAT", "unit", "name", "l", "policy", "form", "source", "set", "status", "table", "file", "parse", "pi", "cf", "layout", "act", "mat", "pattern"], "hasPixelData": ["hasFrameData", "HaspixelDATA", "HasPixelDATA", "HasPixelData", "hasixelDATA", "hasPixeldata", "hasixeldata", " hasPixelDATA", "hasPixelDATA", "haspixelData", "HasPixeldata", "Haspixeldata", " hasPixeldata", "haspixeldata", "hasFrameDATA", "haspixelDATA", "HaspixelData", "hasixelData", "hasFramedata"], "inflate": ["Inflated", "infolated", " invalidate", "Informate", "inFLate", " invalidicate", "invalidate", "inFLated", "Informated", "inflicate", "invalidicate", "informocate", "inflat", "invalidocate", "Inflate", "inflATE", "inflated", " inflicate", " inflATE", "informat", "informate", "Informat", "incelocate", "inFlate", "Informocate", "Inflat", "incelicate", "infolocate", "incelate", "inFlATE", "inFlocate", "inFLat", "inFLocate", " invalidATE", "incelATE", "infolate", "Inflocate", "informated", "invalidATE", "infolat", " inflocate", " invalidocate", "inflocate", "inFlicate"], "pxlen": ["xyln", "xylength", "mxdec", "packln", "packfun", "tmplen", "phplen", "mxlength", "cplength", "packlength", "pexls", "mmlength", "pexlen", "pxdec", "pixelfun", "pexfun", "tmpln", "mxlen", "pixellength", "pixellen", "pxden", "mmln", "xplen", "cplen", "packlen", "packls", "mmlen", "pixells", "pxls", "pxfun", "phplength", "phpln", "pexln", "pexlength", "pexden", "xplength", "pxlin", "mmlin", "phpdec", "pxlength", "xpden", "xpln", "tmplength", "cpden", "pxln", "packdec", "xylen", "tmplin", "cpln", "xylin", "mxln"], "out": ["output", "gr", "gov", "prefix", "init", "ln", "Out", "user", "msg", "sys", "pretty", "inv", "aos", "dir", "io", "ex", "outs", "crit", "client", "up", "cfg", "ou", "group", "writer", "store", "name", "inter", "screen", "sum", "obj", "net", "err", "conn", "print", "OUT", "log", "res", "outer", "cmd", "temp", "list"]}}
{"id1": "20568568", "id2": "13333160", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"createHTML": ["CreateSQL", "CreateHT", " createSQL", "seeHT", "seeSQL", "seeHTML", "seeURL", "createHT", " createHT", "createURL", "CreateURL", "createSQL", "CreateHTML", " createURL"], "requestPage": [" requestFrame", "responseFrame", "referenceApp", "questionApp", "RequestLine", "requestFrame", "questionpage", "referenceType", "RequestFrame", "RequestPage", "referencepage", "requestType", "RequestType", " requestLine", "Requestpage", "referencePage", "responseLine", "questionPage", "requestLine", "questionType", " requestType", "RequestApp", "requestApp", "requestpage", "responseType", "responsePage"], "result": ["output", "buffer", "message", "out", "function", "html", "json", "description", "reason", "prefix", "term", "section", "detail", "response", "product", "params", "root", "complete", "relation", "true", "answer", "cup", "feature", "summary", "all", "this", "request", "error", "figure", "page", "sequence", "line", "command", "source", "date", "value", "match", "render", "comment", "results", "join", "document", "work", "search", "success", "format", "memory", "trace", "res", "r", "word", "report", "cache", "Result"], "url": ["http", "html", "ls", "abs", "ol", "sl", "open", "link", "ur", "Url", "f", "URL", "loader", "rel", "ws", "re", "ssl", "uri", "dl", "nl", "resource", "browser", "gl", "ref", "str", "xml", "ll", "get", "l", "char", "fs", "base", "lr", "rl", "sb", "web", "in", "res", "r", "il"], "ins": ["als", "vs", "con", "ains", "gin", "asin", "din", "ls", "lins", "ln", "ris", "includes", "is", " in", "gs", "Ins", "bs", "ds", "its", "qs", "ws", "uds", "ars", "eds", "cs", "pins", "rus", "ics", "ints", "ils", "rys", "inner", "sts", "ks", "ats", "reader", "ips", "rates", "kins", "mr", "isin", "fs", "input", "INS", " din", "pers", "in", "res", "ts", "cin"], "bufferedReader": [" buffererReader", "buffedLoader", "buffaredReader", "buffiledreader", " buffedContainer", " buffedReader", " bufferedreader", "buffiledWriter", "buffaredBuilder", "bufferingReader", "bufferedreader", " bufferedLoader", "buffedReader", "bufferedBuilder", "buffedBuilder", "buffaredLoader", "buffererLoader", "bufferedContainer", "bufferingreader", " buffererBuilder", " buffedWriter", "buffiledContainer", " bufferedWriter", "buffedContainer", "buffedWriter", "buffiledReader", " buffererWriter", "bufferedWriter", " buffererLoader", "bufferingContainer", " bufferedBuilder", "bufferingWriter", "buffererReader", " buffedreader", "buffaredWriter", "bufferedLoader", "buffererWriter", " bufferedContainer", "buffererBuilder", "buffedreader"], "cssLine": ["ssLin", "cssData", "cosBody", "styleData", "rssBody", "ssLine", "ssRow", "cosLine", "ssBlock", "rssLine", "rssRow", "javascriptBlock", "javascriptRow", "cssline", "cosBlock", "styleLine", "CSSRow", "cssBlock", "styleRow", "cssBody", "cosRow", "ssBody", "csRow", "cssRow", "ssData", "csData", "csLine", "javascriptLin", "ssline", "csline", "rssBlock", "javascriptLine", "cssLin", "CSSLin", "CSSBlock", "styleline", "CSSLine"], "e1": ["e01", "e2", "E0", "ee5", "o5", "E1", " e3", "ee0", " e5", "e3", "ee1", " e2", "ee3", "o1", "o01", "e5", " e0", "ee2", "o0", "E3", "E2", "o2", " e01", "e0", "ee01"], "queryZoom": ["queryZoneolution", "viewZoo", " queryZooming", "queryXome", "queryzom", "queryzoo", "queryDom", "queryZoo", " queryZolution", "queryZoneom", "queryZome", " queryzolution", "queryzome", "viewZom", "viewZome", "queryZXolution", "queryZolution", "queryXoo", "viewzom", " queryzom", " queryzooming", "queryZXooming", "queryzooming", "viewzoom", "queryDoom", "queryZooming", "queryZoneoom", "queryZXom", "queryDoo", "viewzome", "queryZoneooming", "queryXoom", "queryDome", "queryzoom", "queryXom", "queryzolution", "queryZXoom", "viewzoo", " queryzoom", "viewZoom", " queryZom", "queryZom"], "appendToHome": ["appendTOHome", "appendToUrl", "appendtoMenu", "addtoMenu", "appendTOUrl", "addtoHome", "addtoUrl", "appendtoUrl", "appendtoQuery", "appendetoHome", "appendtoHome", "addtoQuery", "appendetoUrl", "addToQuery", "addToMenu", "addToHome", "addToUrl", "appendTOQuery", "appendetoMenu", "appendetoQuery", "appendTOMenu", "appendToQuery", "appendToMenu"], "sql": ["fn", "series", "expression", "spr", "db", "json", "ls", "ms", "sd", "sys", "statement", "condition", "params", "ql", "q", "rel", "inv", "SQL", "sel", "mt", "dl", "nl", "ma", "spec", "qu", "setup", "QL", "sol", "where", "xml", "quote", "imp", "sn", "string", "expr", "select", "scl", "csv", "table", "sp", "query", "sv", "cmd", "sq"], "pstmt": [" pstpr", "pSTMT", "pstmr", " pstrmr", "pstsql", "pStMT", "psem", "pmtpr", "prsthmt", " pstm", "pSTpr", "pstrmr", "pstpr", "prsthpr", "psthpr", "pstrsql", "pmtStatement", " pstms", "pstrbl", "pstm", "pstartMT", "pstatbl", "prsthStatement", " pStms", "pstrm", "pstatm", "psthmt", "psthst", "pstStatement", "postpr", " pstrm", "pstatmr", "pSTms", "pfrmt", "prsthst", "pstartmt", "pstrpr", "pstatmt", "psemt", " pstrmt", "pstMT", "pStms", "pStmt", "pstbl", "prstmt", " pStmt", "pstms", "pSTStatement", " pStMT", "pfrpr", "psebl", " pstrbl", " pstsql", "pstst", "postm", "psemr", "postsql", " pstMT", " pfrm", "pmtmt", "pSTmt", " pfrpr", "pstartms", "pStst", "prstpr", "prstStatement", " pfrmt", "pstrmt", " pStst", " pstmr", "postmt", "pfrsql", "prstst", "psthStatement", " pstbl", "pstartst", " pfrsql", "pfrm", "pmtst", "pSTst", " pstst"], "rs": ["ims", "ms", "ls", "ris", "ows", "gs", "bs", "ss", "ds", "rc", "ues", "rows", "ws", "its", "os", "ars", "ys", "xs", "cs", "rd", "ps", "rys", "rt", "sts", "ks", "ats", "rates", "mr", "fs", "Rs", "ras", "res", "ts", "RS"]}}
{"id1": "23517481", "id2": "23620712", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"md5": [" MD4", "md4", "MD4", " MD3", " md3", "MD3", " md4", " MD5", "md3", " md2", " MD2", "MD5", "MD2", "md2"], "uri": ["path", "message", "http", "description", "password", "location", "prefix", "term", "uni", "force", "ri", "msg", "link", "ui", "ur", "requ", "address", "q", "via", "util", "io", "subject", "qi", " ur", "resource", "filename", " URI", "uu", "course", "du", "name", "unit", "char", "URI", "u", "directory", "remote", "file", "domain", "i", "query", "url", "origin"], "messageDigest": ["Messagedigest", "messageDoment", "messagedigester", "messagedigse", "messageMDester", "messageDoest", " messagedigest", "messageDiger", "messagedigest", " messageDigment", "messageDigose", " messagedigse", "messagedigose", " messageDigose", "messageMDer", "messageMDse", "messagedigment", "messageDigester", "Messagedigester", "messageDigment", "messageDigEST", "MessagedigEST", "messageMDEST", " messageDigse", "Messagedigse", "messageDoose", "MessageDigester", "Messagediger", " messagedigment", "MessageDigse", "messagediger", "messagedigEST", "MessageDiger", "messageMDest", "MessageDigest", "messageDose", "messageDigse", " messagedigose", "MessageDigEST"], "bytes": ["buffer", "uses", "strings", "loads", "es", "words", "types", "gets", "sofar", "users", "times", "ors", "gs", "bps", "bs", "images", "odes", "frames", "pages", "xs", "les", "ces", "amps", "outs", "bits", "files", "classes", "steps", "ions", "terms", "bes", "gb", "values", "clips", "ings", "tes", "Bytes", "pieces", "s", "blocks", "groups", "seconds", "ies"], "stringBuffer": ["stringCenter", " stringLength", "libraryBuffer", "statusBlock", "Stringbuffer", "libraryBlock", "libraryCenter", "StringQuery", "ringQuery", "stringsBuff", " stringCenter", " stringBlock", "stringChannel", "StringBuff", "ringLength", " stringController", "stringController", "statusBuffer", "stringBlock", "stringBuilder", "stringbuffer", "soundbuffer", "StringLength", "stringLength", "soundBuffer", " stringView", "statusController", "ringBuff", "statusCenter", "stringQuery", "soundChannel", "StringChannel", "stringsBuilder", "ringBuilder", "stringsBuffer", " stringBuff", "StringView", " stringChannel", "ringBuffer", "soundBuff", "ringView", "stringsQuery", "stringBuff", "stringView", "libraryController", " stringbuffer"], "b": ["B", "ch", "out", "binary", "x", "j", "n", "nb", "a", "f", "bs", "id", "p", "y", "o", "h", "bb", "t", "v", "buff", "e", "be", "bi", "ib", "d", "gb", "w", "l", "u", "k", "obj", "value", "z", "i", "sb", "s", "r", "c", "rb"], "hex": ["ch", "alpha", "lit", "json", "html", "rex", "tex", "term", "x", "hello", "des", "pex", "ext", "xf", "percent", "raw", "prop", "h", "alph", "re", "rendered", "ex", "red", " Hex", "buff", "sex", "solid", "comp", "str", "sh", "dump", "serial", "none", "form", "print", "def", "hash", "uint", "tx", "ph", "oct", "escape", "bh", "exp", "sv", "full", "cf", "com", "imal", "mix", "hl", "color", "zip"]}}
{"id1": "3401153", "id2": "692738", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHTML": ["getJS", " getJS", "processHTML", "printJS", "processJS", " getURL", "printHTML", " getPDF", "getPDF", "printPDF", "getURL", "processPDF", "processURL", "printURL"], "pageURL": ["baseURI", "pageurl", " pageUrl", "cacheURI", "baseURL", "pageURI", " pageurl", "cacheUrl", "cacheURL", " pageUR", "baseUrl", "Pageurl", "PageURL", " pageURI", "PageURI", "PageUrl", "cacheurl", "PageUR", "pageUrl", "pageUR", "baseUR"], "encoding": ["Encaching", "ecoder", "decoding", "decuation", "enoding", "enuation", "Encuation", "encoded", "uncoding", "enaching", "enoder", "uncaching", "ecoding", "ecaching", "uncoder", "encaching", "decoder", "Encoder", "ecoded", "Encoded", "encoder", "decaching", "encuation", "Encoding", "uncoded"], "dirPath": ["pathDir", "viewName", "pkgDirectory", "folderRoot", "viewPATH", "dirRoot", "pathRoot", " dirRoot", "pkgDir", "pathFile", "viewDir", "directoryDirectory", "folderDir", "pkgPath", "directoryPath", " dirFile", "directoryPATH", "dirFile", "pathPath", " dirDirectory", "directoryDir", "dirDir", "dirPATH", "dirName", "folderFile", "directoryName", " dirPATH", " dirName", "viewPath", " dirDir", "pkgName", "dirDirectory", "folderPath"], "pageHTML": ["viewJSON", "searchHT", "pointHTTP", "componentHTML", "PageHTTP", "viewMD", "pointHTML", "agePUT", "componentHT", "pageJS", "viewHTML", "entryJS", "ageWP", " pageAPI", "searchHTML", "ageHT", "PageJS", "PageHT", "pagePUT", " pageHTTP", "searchJS", " pageWP", "componentSQL", "PageHTML", "ageSQL", "entryHTML", " pagePUT", "pageAPI", "entryAPI", "pageSQL", "entryHTTP", "pointJS", " pageJS", "pageMD", "searchURL", "displayHTML", "displayJS", "pointAPI", " pageJSON", "pageHT", "ageHTML", " pageMD", "pageJSON", " pageHT", "displayURL", "componentWP", "PageURL", " pageSQL", "pageHTTP", "viewPUT", "pageWP", "displayHTTP", "ageJSON", "ageMD"], "connection": ["bo", "nc", "message", "http", "session", "connect", "application", "ion", "Connection", "con", "description", "close", "open", "user", "link", "database", "response", "generation", "condition", "statement", "processor", "internet", "reference", "socket", "console", "character", "to", "relation", "io", "creator", "uri", "client", "resource", "channel", "current", "server", "browser", "library", "creation", "government", "communication", "operation", "writer", "engine", "still", "number", "established", "position", "connected", "directory", "conn", "remote", "command", "entry", "web", "document", "c", "network"], "url": ["path", "http", "ls", "location", "sl", "open", "bel", "link", "b", "Url", "f", "address", "ur", "ul", "URL", "p", "loader", "rel", "api", "ssl", "uri", "dl", "nl", "atl", "resource", "client", "gl", "google", "name", "str", "ll", "get", "l", "net", "conn", "base", "rl", "https", "web", "r"], "br": ["ch", "wr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "bs", "BR", "bl", "hr", "bb", "pr", "er", "fr", "bt", "Br", "cr", "bro", "be", "str", "gb", "vr", "mr", "tr", "bridge", "bc", "sr", "lr", "bh", "sp", "kr", "ber", "r", "rb"], "line": ["field", "style", "text", "cell", "block", "lin", "phrase", "ln", "section", "user", "eline", "detail", "link", "entity", "row", "sample", "frame", "stay", "nl", "liner", "email", "continue", "le", "code", "inline", "ine", "label", "LINE", "number", "l", "quote", "page", "online", "sequence", "entry", "string", "print", "source", "point", "stroke", "log", "comment", "range", "chain", "word", "Line"], "e": ["ve", "ite", "es", "x", "se", "ent", "te", "fe", "ie", "ze", "see", "f", "je", "p", "eeee", "xe", "ce", "en", "re", "ke", "ed", "er", "ex", "ee", "E", "le", "oe", "eb", "ine", "esome", "be", "error", "ode", "he", "ue", "ae", "err", "event", "pe", "ne", "ge", "de"], "file": ["path", "buffer", "output", "db", "mail", "task", "tile", "link", "handle", "f", "et", "h", "dir", "fp", "io", " File", "File", "resource", "el", "lock", "email", "parent", "le", "name", "page", "ile", "directory", "print", "FILE", "base", "port", "table", "log", "web", "work", "data", "out", "ca", "image", "report"], "bufferedWriter": ["bufferedMember", "bufferedWrite", " bufferredWriter", "buffaredReader", "buffaredwriter", "builteredReader", "buffererMember", "bufferredwriter", "buffenedClient", "bufferingReader", " bufferedHelper", "bufferredWrite", "bufferedwriter", "bufferedReader", "bufferedStreamer", "bufferredClient", " bufferedwriter", " bufferedClient", "bufferingClient", "buffaredWrite", "buffenedWrite", "builteringMember", " bufferedStreamer", " bufferredWrite", "bufferredStreamer", "bufferredHelper", "bufferingWrite", "buffaredMember", "builteringReader", " bufferredwriter", "buffaredStreamer", "bufferedHelper", "buffenedWriter", "bufferingwriter", "buffenedHelper", "bufferingWriter", " bufferredStreamer", " bufferredHelper", " bufferredClient", "buffererReader", "bufferingHelper", " bufferedWrite", "buffaredWriter", "builteredWriter", "bufferedClient", "builteredMember", "buffererWriter", "bufferredWriter", "bufferingMember", "builteringWriter", "bufferingStreamer"]}}
{"id1": "2676365", "id2": "23611215", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    public String uploadFile(String url, int port, String uname, String upass, InputStream input) {\n        String serverPath = config.getServerPath() + DateUtil.getSysmonth();\n        FTPClient ftp = new FTPClient();\n        try {\n            int replyCode;\n            ftp.connect(url, port);\n            ftp.login(uname, upass);\n            replyCode = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                ftp.disconnect();\n                return config.getServerPath();\n            }\n            if (!ftp.changeWorkingDirectory(serverPath)) {\n                ftp.makeDirectory(DateUtil.getSysmonth());\n                ftp.changeWorkingDirectory(serverPath);\n            }\n            ftp.storeFile(getFileName(), input);\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return serverPath;\n    }\n", "label": 0, "substitutes": {"reset": ["quit", "update", "close", "kick", "save", "init", "ping", "config", "touch", "replace", "kill", "flush", "state", "register", "alert", "setup", "exit", "clear", "delete", "request", "release", "write", "stop", "destroy", "command", "set", "clean", "remove", "report"], "currentPilot": [" currentPortail", "currentNilot", "currentCail", "currentCilot", "currentPolt", "currentPortail", " currentPolly", "currentPortilot", "currentPlan", " currentPlan", " currentPortane", "currentpolt", "currentCane", "currentNlan", "currentpolly", " currentPortolt", " currentPortilot", "currentPortlan", "currentNail", "currentNane", " currentPortlan", "currentPail", "currentPane", " currentPortolly", " currentPail", " currentPane", "currentPolly", "currentpilot", "currentClan", " currentPolt", "currentpail", "currentPortolt", "currentPortane", "currentPortolly"], "psta": ["apsta", "Psha", "Psta", " pstan", "apstan", "Pstan", "ppsa", "ppstan", "psha", " psha", "pesta", "ppsta", "apesta", "pstan", "ppesta", " pesta", " psa", "apsa", "Pesta", "psa", "Psa", "apsha"]}}
{"id1": "5760649", "id2": "8625346", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"createFile": ["saveFile", "createStream", "saveStream", "uploadStream", " createStream", " createFiles", "uploadFiles", "createfile", "saveFiles", " createfile", "createFiles", "uploadfile", "uploadFile", "savefile"], "src": ["ser", "st", "abs", "config", "SOURCE", "is", "sys", "pour", "rx", "sc", "rc", "fp", "from", "uri", "loc", "resource", "rs", "fc", "comp", "str", "ctr", "dest", "stream", "txt", "obj", "sec", "sit", "rect", "sr", "source", "input", "ipl", "sb", "inst", "url", "res", "start", "sq", "SourceFile", "cur"], "filename": ["fn", "path", "output", "nil", "bf", "location", "prefix", "jpg", "ln", "n", "fil", "title", "nm", "FN", "Filename", "fp", "stem", "subject", "nl", "png", "v", "ename", "xxx", "name", "println", "username", "family", "txt", "kl", "FILE", "string", "file", "ren", "SourceFile"], "fis": ["ffos", "sfiss", " fiss", "fisi", "bfios", "ffis", "afis", "afiss", "fiss", "Fis", " fais", "Fiss", "fIS", "ffisi", "Fios", "FIS", "sfios", "afios", "bfis", "ffIS", "fais", "Fos", " fios", " fisi", "afais", "fios", "Fisi", " fIS", "sfais", "sfis", "bfiss", "bfos"], "fos": [" fOS", "vOS", "tis", "boss", " foses", "Foss", "woses", "bos", "bis", "fOS", "Fis", " foes", "Foes", "vor", "flis", "flos", "vos", "Fos", "flios", "foes", "tios", "toss", "wis", "floss", "voses", " foss", "boes", "tos", "fios", "wor", "wios", "foses", "foss", "woss", "wOS", "wos"]}}
{"id1": "8328527", "id2": "17729554", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"insertJobLog": ["insertJlog", " insertJobHistory", "insertChecklog", " insertJHistory", "insertLogHistory", "insertJHistory", "insertJobConfig", "insertLoglog", " insertJConfig", "insertLogConfig", "insertJoblog", "insertJConfig", "insertCheckLog", "insertJLog", "insertJobHistory", " insertJobConfig", " insertJoblog", " insertJlog", "insertCheckConfig", "insertCheckHistory", " insertJLog", "insertLogLog"], "userId": ["authorPart", "usernameDir", "UserID", "userIn", "UserPart", "usersIn", "UserById", "usaDir", "usaId", "usernameDef", "usernameById", "UserName", "userID", "usaDef", " userName", "usernameId", "userDir", "usersName", "checkID", "userName", " userIn", "usaById", " userDef", "checkName", "authorID", "userDef", "userPart", " userById", "checkPart", "userById", "UserIn", "UserId", " userDir", "authorId", "usersById", "authorName", "usersId"], "checkId": ["workInt", "testId", "workID", "workById", "cleanid", "workInfo", "objById", "testById", "CheckID", "CheckInfo", "checkInfo", "cleanInt", "testInfo", "cleanId", "objID", "ckInfo", "checkid", " checkIdent", " checkById", "ckId", "CheckId", "testID", " checkInt", " checkid", "cleanIdent", " checkInfo", "checkById", "checkIdent", "checkID", "CheckById", "ckID", "checkInt", "Checkid", "objInfo", "objId", "workId", "workid", "workIdent", "ckById", " checkID"], "checkType": ["defTYPE", "defType", "okType", "CheckKey", "CheckID", "testType", "checkInfo", "checkTYPE", "defInfo", "checkKind", "ckInfo", "checkedTYPE", "okKey", "testTYPE", "ckTYPE", "checkTypes", " checkTypes", "CheckId", "testID", "okId", "ckType", " checkInfo", "checkedID", "CheckType", "checkedKind", "checkID", "okID", "ckID", " checkKey", "testKind", "checkKey", "checkedType", " checkTYPE", "ckKind", "defTypes", "ckTypes", " checkID"], "objType": ["objTYPE", "bjTheme", "rtType", "rtTypes", "cmdTy", " objName", "objTheme", "bjTy", "objVersion", " objVersion", "checkTYPE", " objTypes", "objTy", "checkTypes", "cmdTYPE", "rtStyle", "ObjVersion", "ObjType", "tmpTYPE", "rtTYPE", "cbVersion", " objStyle", "tmpType", "ObjName", "cbName", "ObjTYPE", "cmdType", "bjType", "tmpTy", "bjTYPE", "objTypes", "objStyle", "checkStyle", "cbType", "cmdTheme", "cbTYPE", "tmpTheme", " objTYPE", "objName"], "dbo": ["doBo", "dbc", "rdBo", "dbf", "rdbc", "DBo", "Dpo", "dobo", "dtBO", "Dbu", "DBO", "dobf", "rdbo", "doBO", "dBo", "pBO", "dtbo", " dBo", " dbu", "rdbu", "pbo", "dBO", "pBo", "ppo", " dbc", "rdBO", "Dbo", " dBO", "dtBo", "dbu", "rdpo", "dpo", "Dbc", " dbf", "dtbf", " dpo"], "connection": ["output", "bo", "collection", "management", "application", "connect", "session", "cone", "Connection", "con", "pointer", "ion", "function", "close", "db", "config", "instance", "open", "database", "generation", "response", "link", "condition", "statement", "manager", "reference", "socket", "usage", "pool", "pen", "relation", "creator", "associated", "subject", "t", "client", "resource", "current", "server", "library", "settings", "government", "communication", "writer", "operation", "engine", "handler", "position", "connected", "net", "directory", "conn", "command", "information", "table", "po", "document", "query", "context", "c", "computer", "network"], "preStm": ["priSTem", "preSTcm", " preStn", " prePutm", "presStpm", "preStrcm", "PreStrn", "preStrdm", "PreStn", "prePostem", "prestr", "Prestmi", "preWdm", "preTrm", "prestmt", "preWr", "prePutl", "preStrm", "preStpm", "presSTpm", "preSTm", "presttm", "Prestmt", "preSTpm", "preFormm", "preTrem", " preStM", "preShm", "priSTm", "prePutm", "preWm", "preStsm", "Prestm", " preTrm", "preEstsm", " preSTl", " prePutl", "preStrn", "preStmn", "preRestr", " prestn", " prePutr", "PreSttm", "preStrM", "preStdm", "preRestl", "prefixSTem", " prePutmn", "preFormmt", "preRestm", "preSTr", "prePutM", "preShmt", "prefixSTmt", "prePutr", "prePostam", " preStam", "preSTn", "prestem", "preSTmt", " prePutam", "prefixSTm", " preStr", "preStl", "preStam", " preSTm", "prestarm", "Presttm", "preTrM", "preStrr", "preFormn", "preWmt", "preTrmt", "priSTr", "presSTm", "prefixStarm", " preTrem", " prestr", "preStrmt", "PreStrdm", " preStl", "prefixSTarm", "prePutmn", "preSTsm", "presStm", "preSTmn", "preRestmt", "prestl", " preSTr", " prePutem", "prestpm", "PreStrmt", "prePostm", "presSTem", "prestsm", "PreStrm", "preSTem", "prePutem", "preStcm", "preShtm", "PreStmt", "preStarm", " preStmt", " prePutmt", "priSTcm", "preSTarm", "prestm", "priStm", "preEstm", "preStn", "preStM", "priStcm", "preEstpm", "prePutam", "PreStm", "prefixStem", "prefixStm", "presStem", " preTrM", " prestm", "preStem", "presStsm", "prePutarm", " prestmt", "preStr", " preStem", "preStmi", "preSTl", "preWn", "preEstem", " preTrmt", "prePostmn", "preStmt", "priStr", "prestmi", "preStrem", " preStmn", "priStem", "PreStdm", "preStrl", "PreStmi", "prePutmi", "presSTsm", "prePutmt", "preSttm", "preShmi", " preSTmt", "prestn", "prePuttm", "prefixStmt", "preFormdm", "preSTam"], "sql": ["fn", "san", "spr", "db", "json", "ls", "description", "template", "sd", "pkg", "sys", "seed", "q", "ql", "su", "SQL", "ssl", "dl", "nl", "spec", "setup", "js", "sol", "script", "xml", "ll", "quote", "conn", "sn", "string", "scl", "csv", "log", "sb", "sp", "query", "sv", "s", "eps", "sk", "cmd", "sq"], "cleanSql": ["cleanPq", "cleanSyq", "cleanStql", "removeSq", "cleanSQL", "cleanDSQL", "removeSql", "emptyStml", "cleanDSuff", "cleanAsql", "cleanSuff", "cleanStq", "cleanDSql", "emptyStql", "cleanStmt", "emptySml", "cleanSymt", "cleanInsql", "cleanSyql", "removePql", "emptyStmt", "cleanPuff", "cleanSml", "cleanAsq", "cleanAsmt", "removePQL", "cleanInsq", "removePuff", "cleanSq", "emptyStq", "cleanAsml", "emptySql", "cleanPQL", "cleanPql", "removeSQL", "cleanInsQL", "removePq", "cleanSyml", "cleanStml", "emptySq", "cleanDSq", "removeSuff", "cleanInsuff", "cleanSmt", "emptySmt"], "dCount": ["outRes", "dLimit", "outLimit", "dlRes", "udCount", "dlCount", "udRes", "udMax", "dlLimit", "udLimit", "outMax", "dMax", "dlMax", "dRes", "outCount"], "sHaveIns": [" sHaveINS", "SHadIns", "SHaveCons", "shaveIns", "sSeeIns", "sHaveCons", "sHavingins", "shaveINS", "sSaveCons", "sHadins", "sHaveINS", "sSaveins", "sSeeINS", "sHadIns", "sHasIns", "shaveins", "sHasINS", "sHadEx", "sHadEls", "SHaveins", "sHaveEls", "SHaveEls", "SHaveIns", "sSaveIns", " shaveIns", "sSaveEls", "sHasCons", " sHaveins", "sSeeins", " shaveins", "sHavingEx", "sHasins", "sHavingIns", " shaveINS", "SHadins", "sHaveins", "SHadCons", "sHasEx", "SHadEls", "sHadCons", "sHasEls", "sHaveEx"], "j": ["bot", "Ja", "json", "jl", "x", "by", "n", "it", "Journal", "msg", "jack", "b", "aj", "f", "jj", "q", "p", "y", "kj", "o", "att", "jit", "ind", "dj", "jen", "ja", "uj", "v", "js", "key", "ji", "g", "jc", "ju", "index", "_", "jump", "k", "batch", "bj", "Job", "m", "J", "job", "z", "i", "br", "exp", "ij", "off", "jp", "out", "oj", "jo", "left", "ix"]}}
{"id1": "3330944", "id2": "5299276", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractImage": ["ExtractFrame", "extractorImage", "extlateimage", "extprocessImage", "extractFrame", "extlateImages", "extlateFrame", "ExtractImage", "ExtractImages", "extractorFrame", "extractimage", "Extractimage", "extprocessFrame", "extractImages", "extlateImage", "ExtprocessImages", "ExtprocessImage", "Extprocessimage", "extprocessImages", "ExtprocessFrame", "extractorimage", "extprocessimage", "extractorImages"], "input": ["path", "buffer", "out", "text", "internal", "prefix", "init", "config", "it", "hello", "qa", "img", "tmp", "seed", "address", "q", "raw", "p", "rc", "local", "accept", "sample", "from", "Input", "uri", "ins", "initial", "current", "request", "this", "null", "error", "background", "str", "xml", "index", "hidden", "upload", "txt", "before", "base", "partial", "check", "source", "string", "select", "file", "i", "query", "data", "empty", "format", "audio", "start", "ip", "context", "origin", "image", "url", "pattern"], "output": ["path", "prefix", "Output", "type", "response", "put", "STDOUT", "image", "pretty", "o", "to", "generated", "OU", "icon", "current", "filename", "oe", "write", "name", "hidden", "result", "print", "OUT", "PUT", "source", "port", "file", "target", "success", "display", "format", "out", "temp"], "params": ["eters", "ims", "proc", "las", "units", "json", "parents", "properties", "config", "phi", "pps", "types", "pkg", "users", "ports", "gs", "devices", "ams", "p", "stats", "images", "pretty", "prop", "ars", "mm", "pas", "pro", "AMS", "pins", "fps", "spec", "ps", "param", "par", "styles", "photos", "tags", "actions", "rs", "settings", "changes", "abilities", "Par", "marks", "terms", "chains", "points", "keys", "Parameters", "parts", "details", "packages", "tools", "m", "ctx", "docs", "requires", "modules", "results", "pi", "names", "s", "jp", "eps", "options", "phys", "arms", "caps", "conf", "members", " parameters"], "w": ["wr", "window", "ew", "n", "wal", "f", "q", "wa", "wh", "p", "wd", "o", "wp", "ws", "h", "sw", "v", "rw", "kw", "e", "wt", "write", "writer", "d", "nw", "wb", "Ws", "Writer", "W", "m", "wl", "wo", "we", "out", "word", "hw", "wx"], "in": ["path", "IN", "din", "gin", " IN", "con", "init", "ln", "it", "ini", "rin", "is", "vin", "mc", "sin", "f", "old", "raw", "sql", "id", "p", "local", "read", "en", "mm", "from", "mi", "nin", "Input", "al", "ins", "win", "ma", "ar", "bin", "edIn", "e", "all", "inner", "null", "name", "one", "isin", "In", "include", "base", "source", "copy", "file", "po", "i", "info", " din", "inn", "phys", "out", "conf", "inf", "cin"], "dest": ["path", "lit", "deg", "shape", "st", "orig", "save", "buf", "img", "des", "tmp", "p", "dat", "opt", "prop", "ws", "cat", "end", "dir", "to", "desc", "pas", "loc", "resp", "pipe", "oe", "write", "src", "dist", "alt", "wb", "txt", " destination", "result", "Dest", "cont", "tif", "mem", "source", "trans", "nom", "port", "csv", "decl", "target", "comb", "data", "display", "origin", " dst", "out", "usr", "temp", "rest", "way"], "bi": ["obo", "bo", "beck", "bf", "obi", "zi", "BI", "nb", "phi", "ibe", "ai", "ini", "b", "bp", "bie", "bis", "umi", "abi", "bm", "jiang", "bs", "iri", "fi", "ali", "bb", "mi", "ki", "bits", "qi", "bone", "phy", "bin", "buff", "gi", "bg", "bil", "bas", "ji", "be", "ni", "ib", "pb", " nib", "bank", "bc", "yi", "ba", "bra", "rob", "mu", "isi", "hog", "i", "di", "bh", "ble", "pi", "Bi", "vi", "li", "oi", "ibi"], "os": ["mos", "cos", "ls", "es", "OS", "or", "oos", "ops", "is", "sys", "ows", "bos", "osi", "et", "bs", "ds", "o", "aos", "io", "css", "ys", "cs", "obs", "pos", "oo", "ox", "ns", "mot", "ow", "acs", "ks", "Os", "fs", "ons", "ols", "los", "us", "ose", "oss", "ros", "ot", "ios", "s", "oes", "oses", "oid", "ts"]}}
{"id1": "21181542", "id2": "22431487", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteRoleTyp", "deleteRoleTypes", "DeleteRoleType", "deleteGroupTyp", "deleteResourceType", "deleteResourceTyp", "DeleteRoleTyp", "deleteGroupType", "deleteResourceTypes", "deleteGroupTypes", "DeleteRoleTypes"], "id": ["path", "edit", "ident", "ide", "ion", "part", "node", "add", "orig", "x", "time", "instance", "Id", "it", "val", "type", "is", "link", "and", "rid", " pid", "p", "no", "h", "end", "create", "pid", "like", "mid", "t", "kid", " tid", "created", "iden", "ref", "hide", "ids", "key", "name", "bid", "d", "aid", "index", "uid", "l", "only", "event", "sid", "def", "hash", "vid", "show", "i", "info", "oid", "url", "in", "ID"], "namespaceId": ["namesplaceRef", " namespaceIdent", "namespacesRef", "nameshipID", "namesspaceAnd", "namespaceLog", "typesACEId", "namesACEId", "namesspaceid", "namespointRef", "namespaceid", "namespointName", "namesositoryBirth", " namespaceOr", "workspaceName", "namesplaceid", " namesiteIdent", "namesenceOr", "typespaceID", "workshipKey", "worksplaceName", "namesistenceLog", "namespaceIdent", "namespaceName", "namesenceId", "namesenceID", "namespacesid", "worksetAnd", " namesenceID", "namesistenceIdent", "worksplaceRef", "namespaceOr", "namesadeAnd", "namespacesId", "namespointID", "namespacesID", "workshipid", "namesetid", "namesositoryID", "workshipID", "namesistenceOr", "namesACEID", "namesiteId", "worksplaceid", " namesiteOr", "worksetId", "worksplaceId", "namesistenceId", " namespaceLog", "namesaceID", "namespaceBirth", "namesadeID", "workspaceRef", "namespaceRef", "typesACEAnd", " namesiteLog", " namespaceBirth", "namesetID", "namesositoryId", "namesaceId", "namespacesAnd", "namespaceID", " namesenceId", "namesaceid", "namesaceKey", "namespaceKey", "typesACEID", "namesplaceName", "namespacesKey", "namesetId", "workspaceid", "namesiteIdent", "namesiteOr", "namespaceAnd", "namesetAnd", "namespacesBirth", "worksetid", "workspaceAnd", "namesenceBirth", "namespointAnd", "workspaceKey", "namesadeId", " namespaceID", "namespointid", "nameshipid", "nameshipKey", "namesiteLog", "namesACEAnd", "nameshipId", "worksetID", "namespacesName", "namesplaceId", " namesenceBirth", "typespaceAnd", "workshipId", "namesspaceID", "namesenceIdent", "namespointId", "namesspaceId", " namesiteId", "workspaceId", "namesenceLog", "workspaceID", "typespaceId"], "removeReferencesInRoleTypes": ["removeReferencesInRightFiles", "removeReferencesFromroleType", "removeReferencesInroleTypes", "removeReferencesFromroleTypes", "removeReferencesFromMultipleType", "removeReferencesInroleNames", "removeReferencesInRoleFiles", "removeReferencesInRightType", "removeReferencesInRightTypes", "removeReferencesFromroleFiles", "removeReferencesInRightNames", "removeReferencesFromMultipleNames", "removeReferencesInMultipleFiles", "removeReferencesFromRoleType", "removeReferencesInRoleType", "removeReferencesFromRoleTypes", "removeReferencesFromRoleFiles", "removeReferencesInRuleType", "removeReferencesInRoleNames", "removeReferencesInMultipleNames", "removeReferencesInRuleNames", "removeReferencesInroleType", "removeReferencesInMultipleType", "removeReferencesInMultipleTypes", "removeReferencesInRuleTypes", "removeReferencesInRuleFiles", "removeReferencesFromMultipleTypes", "removeReferencesFromroleNames", "removeReferencesInroleFiles", "removeReferencesFromMultipleFiles", "removeReferencesFromRoleNames"], "permit": ["permission", "PERMIT", "Permission", "PERmiss", "PERmit", "Permitted", "permiss", "promit", "PERmitted", "PerMIT", "Permiss", "proMIT", "promission", "promitted", "perMIT", "permitted", "Permit", " perMIT", "PERmission", " permitted", " permiss"], "exist": ["ist", "have", "icate", "connect", "missing", "mark", "add", "save", "existent", "present", "ext", "see", "purpose", "keep", "create", "existence", "respond", "register", "use", "login", "current", "filename", "require", "ready", "existing", "write", " extant", "define", "know", "meet", "cont", "status", "same", "find", "establish", "attach", "there", "alias", "include", "remember", "list"], "msgBuf": ["msgBsuf", "messageBlf", "messageBuf", "msgPbuf", "msgPuff", "msgRfg", "messageRbuff", "msgMuf", "messagePfg", "msgGbuf", " msgRlim", "messageMuf", "msgRuff", "msgBbuff", "msgBsfg", "msgRlim", " msgCfg", "messageMbuff", "msgGbuff", "msgAbuff", "messageBuff", "msgBlf", "msgMbuf", "msgCuff", "msgBefg", " msgMbuff", " msgBbuf", " msgCbuf", "msgMuff", "msgBeuf", "msgVbuf", " msgRuf", "messageMbuf", "msgVuff", "messageRuf", "msgRlf", " msgRbuff", " msgCuff", "msgBsuff", "messagePuf", "msgCbuff", "messageRbuf", " msgCuf", "msgRbuf", "msgBsbuf", "msgAuf", "msgRuf", "messageBbuff", " msgBlim", " msgMuff", " msgBfg", "msgAbuf", "messageBbuf", "msgBebuf", " msgBbuff", "msgBuff", "messageMuff", "messagePbuf", "msgBeuff", "msgVbuff", "msgBbuf", "msgPbuff", "messageBfg", "msgPuf", "messageRuff", "msgCuf", "msgGlim", "msgBfg", "msgGuf", "messageRlf", "msgBlim", "msgVuf", "messagePuff", "msgCfg", "msgMbuff", "msgCbuf", " msgRbuf", "msgPfg", " msgMuf", "msgPlf", "msgRbuff", " msgBuff", "msgAuff", " msgMbuf"], "objects": ["uploads", "assets", "faces", "units", "products", "links", "beans", "artifacts", "locks", "workers", "headers", "ports", "versions", "plugins", "ors", "articles", "images", "frames", "pages", "jobs", "airs", "obs", "lines", "classes", "files", "packages", "bits", "books", "ids", "builders", "authors", "codes", "points", "keys", "oids", "errors", "values", "projects", "models", "parts", "tools", "apps", "organisms", "relations", "docs", "resources", "flows", "blocks", "items"], "sqlRightId": [" sqlRightRef", " sqlrightById", " sqlRightById", "sqlRightName", "sqlHeadId", "sqlrightById", "sqlHeadid", "sqlrightRef", "qlRightId", "sqlLeftName", "qlrightId", "qlrightName", " sqlrightId", "sqlLeftId", "sqlHeadRef", "qlRightName", "sqlrightName", "sqlRightRef", "qlRightid", " sqlRightid", "sqlHeadById", "sqlrightId", "sqlRightById", " sqlrightid", "qlrightid", " sqlrightRef", "sqlRightid", "sqlLeftid", "sqlrightid"], "sqlParent": ["sqlOwner", "sprparent", "sysChild", "sprParent", "invChild", "sysParent", "sprOwner", "sysOwner", "invOwner", "invParent", "sqlChild", "sqlparent", "invparent", "sprChild", "sysparent"], "sql": ["orm", "session", "db", "json", "description", "password", "term", "template", "sys", "statement", "params", "ql", "body", "SQL", "execute", "dl", "security", "spec", "cfg", "md", "command", "drop", "acl", "action", "comment", "data", "cmd", "diff"], "pstmt": ["pondm", "pstatms", "pndm", "PStng", " pstatmt", "pndmk", "pndmt", "wpastmt", "wpastm", "PstatStatement", "NEW", "pndMT", "pastmm", " pstem", "pStm", " pstms", "pstatmm", "pstm", " pstatmp", "wpstMT", "Pstatm", "insert", "pstatem", "wpastMT", "pstatmp", "wpstm", "pthmp", " pstmp", "pondmt", "pastStatement", "wpastmk", "create", "PstStatement", "pstatm", "pastmk", " pstatem", "pstStatement", "pstartr", "pthmt", "PStr", "pStr", "NULL", "_", "def", "pstmm", "pstartmt", "Pstr", "pstatmt", "PStmt", "pstartm", "pstartng", "Pstng", "pstMT", "Exception", "pStmt", "pthem", "Delete", "pstem", "nt", "pStng", "pstmp", "pctms", "pstms", "wpstmt", "Pstatmm", "pstr", "pastmt", "tx", "postm", " pstatms", "pthms", "wpstmk", "Pstm", "PStm", "pstatStatement", "pastm", "Pstatmt", "pstng", "Pstmt", "pastMT", "pctem", "pctmt", "postMT", "pondStatement", "postmt", "Pstmm", "pondmm", "postmk", "pstmk", "context", "pctmp"], "typeGid": ["typeCno", "typeGenid", "typeCId", " typeCids", " typeCno", "TypeCid", "typeGuid", " typeGno", "TypeCID", "TypeCId", "typeGuno", "typeRegid", "TypeGID", "typeGids", "typeGno", "TypeGId", "typeGuID", "typeRegID", "typeRegId", " typeGids", "typeGID", "typeGenids", "typeGuId", "typeCids", "typeCID", " typeCid", "TypeGid", "typeGenno", "typeGuids", "typeCid", "typeGId"], "defaultLevel": ["defaultDepth", " defaultDepth", "Defaultlevel", "DefaultMode", "errorLevel", "DefaultLevel", " defaultMode", "errorDepth", "DefaultDepth", "defaultMode", " defaultlevel", "errorlevel", "defaultlevel", "errorMode"], "success": ["successfully", "progress", "close", "save", "unknown", " succeed", "state", "rc", "accept", "ok", "continue", "fail", "pass", "summary", "warn", "error", "good", "result", "submit", "primary", "status", "undo", "info", "Success", "successful", "failed", "first"]}}
{"id1": "13596891", "id2": "15904772", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"doTransfer": [" doDownload", "doDownload", "handleSend", "DoTransfer", "handleRequest", "handleTransfer", "DoRequest", " doSend", "handleDownload", "doSend", " doRequest", "doRequest", "DoSend", "DoDownload"], "request": ["have", "message", "http", "application", "session", "QUEST", "config", "user", "header", "change", "requ", "connection", "attribute", "address", "reference", "params", "raw", "complete", "reset", "create", "frame", "subject", "re", "use", "client", "resource", "initial", "server", "current", "parent", "setup", "call", "this", "req", "process", "version", "xml", "name", "quest", "get", "position", "result", "record", "remote", "command", "input", "object", "Request", "log", "document", "query", "context", "remove", "in", "report", "order", "question"], "response": ["output", "message", "http", "application", "session", "site", "json", "description", "block", "onse", "connection", "proxy", "send", "body", "reset", "ce", "frame", "default", "answer", "respond", "pos", "resp", "server", "wrapper", "content", "exit", "summary", "write", "this", "version", "next", "view", "service", "one", "position", "respons", "page", "Response", "result", "sequence", "print", "object", "status", "reply", "document", "success", "context", "res", "out", "image", "report"], "method": ["message", "http", "ETHOD", "reason", "timeout", "prefix", "instance", "type", "property", "send", "dir", "num", "subject", "period", "th", "right", "transform", "length", "direction", "call", "verb", "name", "version", "hod", "post", "service", "tr", "other", "form", "mod", "command", "string", "m", "Method", "METHOD", "report", "eth"], "servletContext": ["servletDefinition", "servletEvent", "servLETChain", "servletsContext", "ServletConfig", "ServletsConfig", "ServletsContext", "servLETConfig", "servantComponent", "servantContext", "servLETDefinition", "servlerContext", "servLETComponent", "servLETEvent", "servLETcontext", "servfileContext", "servLETContext", "servlerConfig", " servletComponent", "servletComponent", "servletsConfig", "servfileComponent", "servletcontext", "servlerEvent", " servantcontext", " servantDefinition", "servletsChain", "ServletEvent", " servantComponent", "servletConfig", "ServletChain", "servantcontext", "servantDefinition", "ServletContext", "servfileDefinition", "ServletsEvent", "servlerChain", " servletDefinition", "servfilecontext", "servletsEvent", " servantContext", "ServletsChain", "servletChain", " servletcontext"], "wac": ["wbacs", "wAC", "wbAC", "wacc", "wacs", "wbac", " wacs", " wAC", "bAC", "bac", "bacs", "bacc", " wacc", "wbacc"], "szUrl": [" szPath", "szeURL", " szeLoc", "szUr", "sgzUr", " szeGl", "sldPath", "szeStr", "sizURL", "sldGl", "szeLoc", "sgzUrl", "szPath", "szaURL", "deszPath", "szaUr", "deszUrl", "deszStr", "desgzUrl", "desgzURL", "szarPath", " szeUrl", "szeGl", "sziUr", "szePath", " szePath", "szGl", " szURL", "szLoc", "sizStr", "sgzLoc", "szaUrl", "sizPath", "sizUrl", " szurl", " szLoc", "sldUrl", "szeurl", "sgzURL", "szeUrl", "desgzPath", " szeUr", " szGl", "szStr", "szurl", "sziUrl", " szeURL", " szUr", "desgzStr", "sZurl", "szarUrl", "sZGl", "sldUr", "deszURL", "sgzPath", " szeurl", "szaLoc", "szURL", "szarUr", "sgzStr", "sziGl", "sZUrl", "szarGl", "sZUr", "sziurl", "szeUr"], "url": ["http", "mail", "ls", "location", "ol", "sl", "org", "open", "ret", "build", "bel", "link", "ur", "lb", "ul", "Url", "f", "ml", "address", "ob", "URL", "connection", "socket", "util", "re", "pl", "ssl", "uri", "t", "nl", "loc", "client", "browser", "gl", "ref", "impl", "name", "str", "xml", "ll", "mount", "l", "u", "char", "www", "un", "conn", "gc", "base", "rl", "date", "file", "web", "https", "cert", "host", "prot", "il"], "is": ["ms", "es", "isc", "tis", "iso", "ris", " cis", "ri", "ic", "sys", "ois", "nis", "bis", "bs", "id", "isa", "as", "its", "iss", "os", "cs", "ins", "ii", " bis", "ps", "serv", "si", "Is", "isin", "ir", "ism", "us", "isi", "i", "info", "ios", "sis", "s", "in", "res", "ip", "lis", "IS"], "sout": ["wsj", " sin", "osouth", " sos", "wsos", "osin", "sin", "lsOut", " sOut", " scho", "scho", "wscho", " south", "lsos", "wsout", "lscho", "lsout", "sOut", "lsj", "lsouth", "sos", "lsin", "osOut", "south", "sj", " sj", "osout"], "con": ["http", "ion", "cell", "ln", "config", "change", "connection", "ain", "rc", "num", "re", "syn", "code", "canon", "cp", "cons", "fac", "ctrl", "cf", "com", "dial", "cur", "nc", "const", "on", "cone", "internal", "condition", "util", "create", "cv", "control", "conv", "cm", "apache", "don", "obj", "bc", "un", "conn", "ran", "co", "res", "cmd", "conf", "thin", "cos", "cond", "acon", "can", "pen", "h", "local", "en", "client", "current", "fc", "comm", "compl", "stat", "coll", "Conn", "connect", "Con", "cal", "ven", "ver", "socket", "common", "call", "cgi", "req", "fl", "ctx", "cn", "CON", "log", "act", "c", "cache"], "hNames": ["tStates", "tKeys", "hrKeys", "hmNames", "dhWords", " hAMES", "dhKeys", " hWords", "hrWords", "hrNames", "hKeys", "dhNames", "tNs", "bNames", " hKeys", "tNames", "htKeys", "bNs", " hUsers", "hAMES", "hmAMES", "bStates", "hmUsers", "htAMES", "hStates", "hrIDs", "bKeys", " hNs", " hStates", "htUsers", "hIDs", "hmKeys", "hNs", "dhIDs", "hUsers", "hWords", "htNames", " hIDs"], "txt": ["fn", "btn", "text", "qt", "TEXT", "te", "msg", "pkg", "tt", "ext", "tmp", "ct", "tm", "lt", "xt", "tk", "nm", "tab", "kt", "dat", "htm", "test", "mt", "dj", "t", "XT", "pt", "bt", "filename", "typ", "kw", "nt", "cmp", "wt", "ns", "nu", "xxx", "str", "xx", "nv", "obj", "ht", "gt", "tx", "sp", "elt", "lv", "tf"], "inBody": ["inputBox", " INBox", " inThread", "Inbody", " INBoot", " inReader", "inputBody", " INBody", "InReader", " inBoot", "cinBoot", "InThread", "dinbody", "inReader", "inBox", "inBlock", "dinReader", "inputThread", " inbody", "cinBody", "dinBody", "InBox", " INBlock", " inBlock", "inThread", "cinBox", " inBox", "inBoot", "inbody", "InBody", "cinBlock"], "bufCh": [" bufComp", "bufferch", "buffch", " bufch", "bufferCH", "bufCH", "ufCH", "bufch", "BufferCh", "BufferCH", "cbCol", "BufferComp", "ufCh", "bufferCh", " bufBuff", "bufComp", "bufChar", " bufChar", "ufCol", "cbCH", " bufCol", "BufferChar", "buffComp", "bufCol", "buffCh", " bufCH", "bufferBuff", "ufChar", "buffCH", "cbCh", "buffBuff", "buffChar", "cbChar", "bufBuff"], "r": ["ch", "gr", "out", "dr", "R", "or", "x", "rar", "n", "rec", "f", "q", "p", "rc", "o", "h", "hr", "re", "rd", "er", "nr", "t", "arr", "ar", "rs", "rw", "v", "cr", "e", "rt", "d", "w", "l", "u", "k", "mr", "err", "rr", "rate", "sr", "lr", "z", "i", "res", "c", "rb"], "outReq": ["outFrej", "outConj", "outConek", " outReQ", "inSeq", "outConquest", "outReck", "outRequest", "outFrech", "outTeqs", " outConj", " outReqs", "outSequest", "inSej", "outRecqs", "outSech", "outResq", "outResquest", " outConch", "outFreck", "outReek", " outRej", "outRecek", "outReqs", "outConqs", "inReq", " outConquest", " outRecque", "outConQ", "outConck", "outResch", "outRecque", "outConch", "inRequest", "outRecquest", " outReck", " outRecek", "outConq", " outRecq", "outTeq", "outREq", "inRech", "outREqs", "outTequest", " outRech", "inRej", "outTeQ", "outSeck", "outFreq", "outSej", "outREque", " outReque", "outResj", "outRecQ", "outSeq", " outRequest", " outConq", "outREek", "outConque", "inSequest", "outRech", "outRecq", "outRej", "outReQ", " outConqs", "outReque", "inSech", " outReek", " outConck", " outConQ", " outRecqs"], "buff": ["buffer", "nd", "cond", "buf", "font", "eng", "img", "cho", "Buff", "alph", "bb", "bin", "ref", "uf", "emb", "comp", "be", "cod", " buf", "cb", "ff", "mem", "bj", "ph", "off", "info", "cmd", " buffers"]}}
{"id1": "12146394", "id2": "5142039", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "label": 0, "substitutes": {"md5Crypt": ["md4Crypt", "md2Enc", "md4Enc", " Md5Dec", "md5crypt", "md5Dec", "md3Crypt", "md2crypt", "md2Dec", "md3Enc", " Md3Crypt", " Md3crypt", "md2Crypt", " Md5Crypt", " Md3Dec", "md3Dec", " Md3Enc", "md5Enc", "md3crypt", " Md5Enc", "md4Dec", "md4crypt", " Md5crypt"], "key": ["ion", "window", "block", "by", "ek", "change", "ca", "root", "to", "icon", "poly", "code", "any", "str", "version", "ace", "sum", "form", "ey", "air", "file", "query", "word", "list", "text", "json", "link", "seed", "token", "ke", "ex", "iv", "pair", "box", "name", "ice", "char", "k", "net", "entry", "string", "chain", "data", "start", "ip", "password", "prefix", "phrase", "address", "id", "no", "er", "client", "KEY", "null", "index", "mac", "check", "input", "hash", "table", "gem", "cert", "message", "Key", "prime", "x", "user", "type", "item", "piece", "p", "y", "state", "ce", "test", "default", "note", "length", "none", "keys", "policy", "event", "base", "source", "value", "blow", "act", "host", "image"], "salt": ["hALT", "halt", "psass", "siv", "save", "seash", " sass", "slil", " salted", "hig", "sash", "slash", "slalt", " sert", "seALT", "psalt", "Sass", "sealt", " sint", "Save", " sig", "Sash", "Salted", "tsALT", "sig", "seil", "pALT", " sALT", " save", " shet", "Sert", "tsalt", "piv", "unsig", "Salt", "Sig", "psALT", "shet", "sol", "tsol", "Sil", "sint", "chet", "cig", "sert", "salted", "Siv", "unsalted", "unsALT", "SALT", "slALT", "unsalt", "sALT", " sol", "Sol", "hiv", "sass", "pig", "cass", "palt", "calt", "sil", "psave", "tsave", "Sint"], "_md": ["_sd", "___mn", "___MD", "_mp", "_cmd", " _dm", "_mn", " _df", " _mn", "_____md", "_df", " _cmd", "_____mb", "_mk", "_mb", "_____mg", "___md", "_____dm", "___dm", "_mand", " _MD", "_MD", "_____mp", "_____mn", " _mand", " _sd", "_dm", "_mg"], "md2": ["rm2", "cmdto", " md6", "mdto", "ddTwo", "mand4", "cmd2", "sdTwo", "modetwo", "dd5", "mand5", "md5", "rm4", "cmd6", "dd1", "dd4", "mdtwo", "cmd5", "mode4", "cmdtwo", "mode2", "dd2", "rm5", "mode5", "mand2", " md52", "mdTwo", "sd2", "cmd52", "md4", " md1", "md6", "mb52", "sd5", "mb4", "md52", " md5", "mb5", "ddtwo", " mdTwo", "md1", "sd1", "cmd4", " mdto", "rm6", "mandto", " md4", "mb2"], "abyFinal": ["abyReal", "uyInitial", "abyZero", "aberFin", "uffyFixed", "abyInitial", "seatFinal", "washingAll", "abyFin", "boatInitial", "boatReal", "inessFinal", "uyFin", "washingZero", "abyFixed", "satLast", "aberFinal", "aberInitial", "inessReal", "uffyUpdated", "sayFinal", "agusUpdated", "phiFull", "phiFinal", "andyAll", "uffyTotal", "phiReal", "inessFixed", "alyFinal", "seatTotal", "alyFixed", "abyLast", "boatFull", "uyFinal", "abyAll", "washingFin", "alyAll", "BabyFin", "boatDual", "washingFinal", "seatInitial", "alyComplete", "sayFixed", "BabyFinal", "satZero", "washingFull", "inessInitial", "abyComplete", "agusFinal", "satFinal", "agusTotal", "uyTotal", "washingLast", "washingFixed", "sayReal", "andyFixed", "abyFull", "abyUpdated", "aberTotal", "sayTotal", "uffyFinal", "phiDual", "washingReal", "seatFin", "satFin", "abyTotal", "andyComplete", "abyDual", "BabyLast", "andyFinal", "washingDual", "sayInitial", "washingComplete", "boatFixed", "boatFinal", "BabyZero", "agusFixed", "sayUpdated"], "n": ["nc", "nan", "out", "con", "nb", "ln", "ng", "non", "ul", "count", "nm", "p", "no", "norm", "y", "o", "dn", "size", "en", "np", "num", "note", "nr", "nl", "t", "el", "v", "nt", "syn", "na", "ns", "nor", "g", "nu", "all", "name", "ni", " N", "d", "number", "nw", "w", "l", "k", "net", "N", "un", "nn", "sn", "c", "yn", "an", "ne", "cn", "m", "z", "network", "mn", "names", "gn", "ren", "pn", "len"], "j": ["json", "im", "jl", "x", "it", "b", "aj", "jj", "q", "ia", "p", "y", "kj", "jit", "dj", "ja", "uj", "v", "js", "at", "g", "ji", "bi", "jc", "index", "si", "I", "jump", "obj", "k", "bj", "J", "z", "br", "ij", "jp", "out", "oj", "ix"], "i": ["multi", "phi", "it", "init", "ini", "ri", "ai", "ic", "ia", "iu", "p", "y", "ci", "mi", "gu", "ki", "ii", "qi", "v", "gi", "hi", "ti", "bi", "ji", "ni", "si", "I", "l", "u", "k", "ei", "m", "xi", "cli", "ami", "di", "ij", "pi", "info", "ip", "li", "c", "ix"], "sbPasswd": ["sbPushrc", "cbMassenc", "ebPassweight", "cbPassenc", "cbpassrc", "zbPassweight", "cbPassw", "sbPassrc", "sbPushw", "sbPushenc", "sbWorkwd", "sbPassgrad", "cbpassgrad", "sbPassenc", "sbPASSwd", "sbPassWD", "ebPassWD", "sbChainwd", "ebChainwd", "sbPassword", "ebChainweight", "sbPASSw", "sbPushWD", "cbMassess", "cbMassWD", "sbWorkweight", "sbAssweight", "cbPassgrad", "sbGuenc", "cbpasswd", "zbPassw", "zbDefweight", "sbpassrc", "sbPushess", "sbpassweight", "zbPasswd", "sbDefweight", "sbpasssword", "sbMassWD", "sbDefwd", "sbAsswd", "zbDefsword", "sbChainweight", "sbChainWD", "ebChainWD", "cbPasswd", "sbGuess", "sbGuwd", "zbDefw", "ebChainword", "cbPassrc", "sbWorksword", "sbMasswd", "sbPassw", "sbChainword", "sbGuWD", "cbMasswd", "ebPassword", "sbWorkw", "zbDefwd", "sbPASSrc", "sbPushwd", "ebPasswd", "zbPasssword", "sbPasssword", "sbpassgrad", "sbpassw", "sbAssword", "sbPassweight", "sbMassenc", "sbAssWD", "cbPassWD", "sbPassess", "sbDefsword", "sbDefw", "sbPASSgrad", "sbMassess", "sbPushgrad", "cbPassess", "sbpasswd", "cbpassw"], "md3": ["rm3", "md30", "cmdThree", "MD43", "cmd2", "MD3", "md5", "mt33", "cmd03", "mt43", "cmd5", "m43", "mdThree", "dm33", "mt03", "m5", "rm5", "mt5", "md03", "MD2", "mb43", "md33", "md4", "dm5", "m3", "rm30", "mb4", " md5", "mb3", "mb5", "mtThree", "cmd33", "dm3", "mt30", "mt2", "mt3", "cmd3", "cmd30", "dm03", "m4", "md43", "cmd43", "MD5", " md43", " md4", "rmThree"]}}
{"id1": "771802", "id2": "15166511", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createFileStream", "createInputstream", " createOutputFile", " createFilestream", " createInputSteam", " createFileSteam", " createOutFile", "createOutputstream", "createInputFile", " createOutStream", "createInputStream", " createOutputSteam", "createOutputSteam", " createFileFile", " createInputStream", " createOutSteam", "createInputSteam", " createInputFile", " createOutstream", " createInputstream", "createOutputFile", " createOutputstream"], "inFile": ["inputPath", "inDir", "dinPort", "ninPath", "dinPath", "dinDir", " infile", "outFilename", " inPort", "infile", "ninFilename", "inputDir", " inPath", "ninFile", "outPath", "inFilename", "inPort", "outfile", "inputFile", "inputPort", "dinFile", " inDir", "inPath", " inFilename", "ninfile"], "outFile": ["Outfile", "exfile", "outPlace", "outPort", "outputFilename", "OutFilename", "outputFile", "outputPlace", "exFile", "newfile", "OutPort", "outputfile", "exPlace", "OutFile", "toPort", "outFilename", "newFilename", "tofile", "infile", "newFile", "toFile", "inFilename", "inPort", "outfile", "toFilename", "exFilename", "newPlace"], "k_blockSize": ["k_BlockTime", "k4BlockName", "k_BlockStyle", "k2byteLength", "k_byteSize", "k2blockLength", "k_blockName", "k4blockSize", "k2byteTime", "k4blockCount", "k2blockTime", "k_blockTime", "k_byteName", "k_batchLength", "k4BlockStyle", "k_BlockLength", "k_BlockSize", "k_BlockCount", "k2blockSize", "k4BlockSize", "k_byteTime", "k_batchTime", "k_blockCount", "k4BlockCount", "k2byteCount", "k_blockLength", "k_byteLength", "k4blockStyle", "k2byteSize", "k_blockStyle", "k_BlockName", "k_batchSize", "k4blockName", "k_byteCount", "k2blockCount", "k_batchCount", "k_byteStyle"], "byteCount": ["byteLength", "wordN", "bitN", "byteSize", "byteCode", "charPtr", "bitSize", "bitCounter", "linePtr", "bytecount", "wordCode", " byteLength", "bitCount", "bytePtr", "charCount", "lineLength", "byteCounter", " bytecount", "bbCode", "wordSize", "bitLength", " bytePtr", "bbN", "blockCounter", "blockLength", "charLength", "bitCode", "byteCheck", "blockCount", "bbSize", " byteCheck", "byteN", "wordCount", "charcount", "bbCount", " byteCounter", "linecount", "lineCount", "bitCheck", "blockCheck"], "buf": ["buffer", "proc", "Buffer", "db", "block", "img", "msg", "pkg", "fg", "b", "bag", "raw", "Buff", "bn", "alph", "cat", "bl", "queue", "cv", "seq", "conv", "arr", "buff", "uf", "bg", "cast", "pb", "ctr", "str", "vec", "cb", "doc", "bytes", "txt", "bc", "batch", "mem", "ctx", "tx", "cap", "exp", "cmd", "rb", "cur"], "ofp": ["owlpa", " ofpa", "ofd", "OFP", "owlp", "ofl", " ofP", "ofP", "owlP", "Ofpa", "Ofl", " ofl", "ofpa", "OFd", "Ofp", "OfP", "Ofd", "OFp", " ofd", "OFl", "owld"], "zos": ["ossus", "cos", "sbm", "esa", "zen", "zi", "es", "rss", "tis", "init", "hz", "amia", "zik", "jas", "ze", "zy", "zu", "psy", "gs", "osi", "zin", "bs", "za", "socket", "ez", "hess", "rez", "ws", "os", "zers", "zon", "css", "zag", "zes", "std", "zzle", "LOS", "ps", "webkit", "js", "enos", "rose", "settings", "zh", "zb", "bes", "eros", "zl", "cz", "south", "zer", "los", "python", "sch", "z", "zo", "oss", "sis", "jp", "zona", "nz", "zip"], "osw": ["iswx", "aosW", "osiw", "cosw", "ospace", "osd", "aosw", "sysw", "sysW", "aosd", "cosew", "oW", "syswd", "isw", "owa", "cosd", "issw", "osew", "ossw", "cosws", "osrw", "sysrw", "aoswd", "osws", " ossw", "osswx", "osiW", "opace", "ow", " oswx", "aoswa", "aospace", "aosrw", "osswd", "osiwa", "osipace", " osew", "ossrw", " osW", "osW", "isW", "aosew", " osd", "ossW", "oswa", "oswx", "osssw", "aosws", "oswd", " osws"], "bw": ["nbwe", "abwe", "besw", "bbx", "pbwb", "sbwb", "bex", "pbz", "sbw", "pbwe", "bwk", " bem", " bx", "bbz", " bwl", "obwb", "bwp", "bsw", "bbend", "nbew", "bwl", "bewk", "bbwp", " bex", "pbwt", "rbw", " bz", "bwb", "abew", "bwy", "nbw", "obwl", "bewl", "pbw", "wbw", "sbz", "pbwy", " bsw", "bew", "bem", "bbws", " bwp", "rbex", "wbz", "wbwp", " bwk", "wbem", " bwt", "bwt", "bwe", "obsw", "abwy", "bbex", "wbwt", "nbwy", " bend", "rbws", "wbend", "pbew", "bbw", "bz", "bws", "bx", "wbx", "abw", "sbwt", "obwt", " bws", "rbz", "obw", "obwk", "bbwt", "obz", "bend", "bbem"], "zot": ["ziot", "zerot", "zeronet", "zeror", "zonet", "zipot", "Zot", " ziat", "zoor", "Zit", " zott", "zott", " zo", "zerote", "zoot", "ziphot", "zoonet", "zoo", "zipiat", "zerit", "zeriat", " ziot", " zor", "zor", "zerhot", "zerott", "zipiot", " zonet", "Zote", "zhot", "zero", "Zott", "zote", "ziat", "zeriot", "zo", " zote", " zhot"], "ifp": [" ifd", " ifr", "iwd", " ifth", "iwp", " ifP", " iftp", "ifP", "isP", "Ifth", " ifjp", "iwr", "ifjp", "isjp", "ihp", "Ifjp", "isp", "ifr", "ihr", "ihtp", "iwtp", "IfP", "ifth", "ihd", "Ifp", "iftp", "ifd", "isth"], "zis": [" ziss", "izis", "zeris", " zi", "ezis", "zi", "izisa", "izi", "zoisa", " zIS", "zipic", "zoinit", "eziss", "zois", "zisa", "zerIS", "zIS", "zipis", " zic", "zisc", "zoiss", "zinit", "izinit", "ziinit", "izisc", "zic", "zeric", "ziisa", "ziis", "zipIS", "iziss", "ziss", "ziiss", " zisc", "ezi", "ezisc"], "isr": ["sisrs", "ispr", "iosstr", "itssr", "iospr", "isalr", "issrc", "iossr", "isscr", "issrs", "iosr", "itsstr", "isstr", "iscr", "issr", "isalpr", " isrs", "sisr", "siscr", "itspr", " isrc", "isalstr", "isrs", "sisrc", "isalsr", " iscr", "itsr", "isrc"], "br": ["wr", "gr", "dr", "shr", "bf", "bd", "b", "bp", "bm", "BR", "rel", "bn", "bl", "hr", "pr", "fr", "bt", "js", "Br", "cr", "bro", "bi", "obl", "str", "ctr", "Fr", "vr", "mr", "tr", "ptr", "bj", "sr", "lr", "ba", "bh", " Br", "kr", "ber", "r", "yr", "rb"], "zit": ["zeop", "zipIT", "iziti", "ziti", "zipit", "izip", "zist", "ozit", "czip", "czit", "ezlit", "zite", "ozunit", "ezIT", "lexIt", "ziit", "lexIT", "czop", "czunit", " zlit", "ziplit", "zIT", "zipist", "ziIt", "zlit", "ezite", " zip", " zIT", "cziti", "lexist", "zipite", "zunit", "lexit", "oziti", "ziIT", "zeit", "zipIt", "ezit", "zeip", "czot", "izit", "ozip", " zite", "zIt", "ziist", "zeot", "zop", " zop", "izunit", "zip"]}}
{"id1": "17580775", "id2": "11952735", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"runInternal": ["processIntern", "mainImpl", "processinternal", "mainIntern", "runImpl", "processInternal", "loadinternal", "runIntern", "processImpl", "loadIntern", "runinternal", "loadImpl", "loadInternal", "mainInternal", "maininternal"], "connection": ["collection", "bo", "ion", "function", "controller", "character", "to", "channel", "created", "component", "version", "operation", "con", "description", "close", "method", "link", "condition", "create", "creation", "writer", "engine", "established", "entry", "document", "computer", "application", "session", "pointer", "Connection", "statement", "address", "no", "pool", "reset", "machine", "relation", "subject", "client", "resource", "current", "server", "government", "page", "directory", "device", "table", "information", "message", "connect", "open", "database", "generation", "reference", "socket", "console", "default", "creator", "associated", "encrypted", "initial", "general", "setup", "translation", "communication", "number", "position", "connected", "event", "command", "language", "context", "c", "network"], "visited": ["shownited", "vitted", "VisITED", "VISited", "shownitted", "showniting", "vited", "visiting", "Vised", "comitted", "vised", "VISitted", "Visitialized", "vITED", "Visitted", "VISed", "visITED", "viting", "visitialized", "visitted", "VISitialized", "comed", "comited", "comitialized", "shownITED", "Visiting", "Visited"], "startTimeStamp": ["startTimstamps", "startTimeStramp", "startTimStAMP", "startTimeMillamps", "startTimstis", "startTimstamp", "startTimeStrAMP", "startTimeMillAMP", "startTimeMillis", "startTimestAMP", "startTimstAMP", "startTimStamps", "startTimeStris", "startTimestamp", "startTimeStramps", "startTimestis", "startTimestamps", "startTimeStis", "startTimStis", "startTimeStamps", "startTimeMillamp", "startTimeStAMP", "startTimStamp"], "delayedProgress": ["delayingprogress", "deliverProgress", "dayProgress", "delayProgress", "delayingContent", "deliverContent", "dayedprogress", "dayprogress", "delayprogress", "delayedContent", "deliverprogress", "dayedContent", "delayContent", "dayedProgress", "delayedprogress", "delayingProgress", "dayContent"], "conn": ["ch", "nc", "connect", "con", "Connection", "addr", "cell", "j", "n", "org", "open", "mc", "pg", "ct", "alloc", "enc", "col", "att", "conv", "dl", "loc", "resp", "client", "cfg", "adj", "nt", "cmp", "js", "cp", "cb", "comm", "nw", "l", "txt", "obj", "err", "bc", "ht", "exec", "cont", "conf", "ctx", "cn", "cc", "cert", "jp", "res", "cmd", "act", "hw", "Conn", "c", "cur"], "fileName": ["resourceName", "displayValue", "FileName", " fileValue", "Filename", "FileType", "FilePath", "filename", "resourceType", "FileValue", " filename", "resourcePath", "fileValue", "displayname", "fileType", "filePath", " filePath", "displayName", "displayPath", " fileType", "resourcename"], "disp": ["nlp", "serp", " dispi", " disn", "disr", "desr", "dispend", "DIScp", "dispat", "Disr", "sern", "lyn", "Dispat", "disP", "lypi", "disccp", "DISp", "discp", "laycp", "serpa", "defr", "wordpat", "discpol", "defp", "DISpend", "Disp", "Dispi", "defpi", "desp", "dispa", "lypa", "layp", "nlpat", "desP", "dispol", "defP", "disn", "Dispo", "DisP", "despi", "lyp", "wordP", "dispo", "laypend", "nlpo", "discpend", "laypol", "wordpo", "serpi", " dispa", "nlP", "wordp", "dispi", "DISpol"], "p": ["vp", "dp", "P", "pointer", "part", "ping", "j", "n", "pkg", "change", "bp", "f", "tp", "pg", "lp", "h", "pa", "wp", "np", "pid", "pro", "conv", "t", "pos", "op", "par", "v", "ps", "pre", "pat", "d", "cp", "perm", "pc", "c", "point", "m", "primary", "padding", "ph", "i", "sp", "pi", "pers", "pad", "jp", "php", "r", "pp"], "response": ["message", "application", "roads", "function", "json", "description", "timeout", "block", "time", "type", "onse", "example", "environment", "no", "reset", "duration", "relation", "frame", "pos", "resp", "escription", "total", "server", "more", "yes", "length", "continue", "relative", "exit", "code", "tree", "request", "error", "version", "next", "index", "number", "none", "bytes", "position", "page", "respons", "Response", "result", "sequence", "remote", "entry", "amount", "ne", "status", "zero", "value", "reply", "success", "res", "image", "network"], "contentType": ["ContentLength", " contentLength", "messageLen", "commandTypes", "contentTYPE", "documentType", "ContentTy", "documentTYPE", "contentTypes", "ContentType", "messageType", "documentLength", "commandLength", "contentLength", "cellType", "cellLen", "messageLength", "contentTy", " contentTypes", "cellLength", "documentLen", "cellTYPE", "ContentTypes", "messageTYPE", "commandType", "commandTy", " contentTy"], "contentEncoding": ["contentDecLength", "contentEnryption", "contentEncryption", " contentEncryption", "contentEvoding", " contentEnoring", "contentencryption", "contentencoding", "contentDecoding", " contentEnoding", "contentEncoded", " contentEnryption", " contentEncLength", "contentEnLength", "contentDecoded", "contentEvoded", "contentDecoring", "contentDecoder", "contentencoring", " contentEncoder", " contentEncoring", "contentEncoring", "contentEnoder", "contentencoder", "contentDecryption", " contentEncoded", "contentEvoder", " contentEnoded", "contentEnoded", "contentEncoder", "contentEnoding", " contentEnLength", "contentEnoring", "contentEncLength", " contentEnoder", "contentEvLength"], "contentLen": [" contentNet", "ContentLength", " contentLength", "messageLen", " contentColl", "contentNet", " contentlen", "ContentSize", "ContentNet", "ontentLen", "componentColl", "contentLength", "contentColl", " contentSize", "messageColl", "ontentSize", "messageSize", "componentlen", "messagelen", "ontentNet", "contentSize", "componentSize", "ontentLength", "contentlen", "componentLen", "ContentLen"], "is": ["ist", "ims", "http", "ists", "im", "es", "isc", "ie", "IS", "id", "ss", "its", "iss", "does", "ih", "ize", "iz", "ii", "version", "ice", "Is", "isd", "ism", "network", "i", "pi", "ip", "are"], "url": ["path", "http", "site", "html", "ls", "location", "org", "build", "bel", "link", "ur", "Url", "address", "URL", "id", "ssl", "uri", "dl", "client", "channel", "server", "browser", "ref", "str", "mount", "name", "xml", "ll", "version", "l", "char", "page", "www", "base", "string", "domain", "git", "https", "web", "host", "pattern"], "loadNext": [" loadednext", " loadedMore", "loadedNext", "loadednext", "loadMore", " loadedNext", " loadMore", " loadedFirst", "loadedMore", "loadFirst", " loadnext", "loadedFirst", "loadnext", " loadFirst"], "itemsLoadedPartially": ["itemsLoadedPosully", "itemsLoadedpartial", "itemsLoadedPartfully", "itemsLoadedOnlyfully", "itemsLoadsPosially", "itemsLoadedPosially", "itemsLoadedPosfully", "itemsLoadedPartial", "itemsLoadsPartially", "itemsLoadedOnlyully", "itemsLoadsPartial", "itemsLoadsPosully", "itemsLoadedpartially", "itemsLoadedPosial", "itemsLoadsPartully", "itemsLoadsPosial", "itemsLoadedpartully", "itemsLoadsPartfully", "itemsLoadedOnlyial", "itemsLoadedpartfully", "itemsLoadedOnlyially", "itemsLoadsPosfully", "itemsLoadedPartully"]}}
{"id1": "7945594", "id2": "20306677", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"fileDownload": ["urlDownload", "FileUpdate", " fileGet", "filedownload", "urldownload", " filedownload", "urlUpdate", "FileGet", "Filedownload", "urlGet", "FileDownload", "fileUpdate", " fileUpdate", "fileGet"], "fAddress": ["fiAdd", "fContact", "FAddress", "eAdmin", "fdAdd", "fAdmin", "fdURL", "pURI", "fiURL", "fAdd", "faddress", "vaddress", "pAddress", "hValue", "sfContact", "xfAdd", "fiLocation", "fOrder", "fURI", "fdAddress", "fmContact", "sfOrder", "FPart", "xfLocation", "fiAlias", "feAdd", "fURL", "fValue", "fPart", "fDomain", "fmOrder", "feOrder", "FAdmin", "fiDomain", "eOrder", " fAdd", "xfURI", "sfAddress", "fAlias", "xfAddress", "fLocation", "feAdmin", "hURI", "FAdd", "vAddress", "vDomain", "FContact", "eAddress", "fmAddress", "fmPart", "FOrder", "fiaddress", "hAddress", "feAddress", "hAdd", " fAlias", " fURL", "pValue", "xfaddress", "xfDomain", "eAdd", "sfPart", "fiAddress", "fdAlias", "pAdd", "xfValue", "vLocation"], "destinationDir": ["destificationDirectory", "destarationDirector", "destinationdir", "destificationdir", "declinationDirectory", "DestificationFolder", "declificationDir", "DestinationFolder", "Destinationdir", "destinationsDirectory", "destarationDir", "destinedDirector", "declificationFolder", "destacementdir", "destificationDirector", "destinationDirector", "destinationsDir", "DestinationDirector", "destificationFolder", "destarationFolder", "DestificationDir", "DestinationDir", "declificationDirectory", "declinationDir", "destinationsFolder", "destacementDir", "destinationFolder", "declinationdir", "destacementFolder", "destineddir", "destinedDir", "declinationFolder", "DestificationDirector", "destinedFolder", "Destificationdir", "destinationsdir", "destificationDir", "destarationdir", "destinationDirectory", "declificationdir", "destacementDirectory"], "slashIndex": ["flashPosition", "sllashIndex", "slashesPosition", "slashedCount", "slashedIndex", "swashIndex", "slasherCount", "slugPosition", "sllashindex", "slashNumber", "slasherPosition", "slashesIndex", "flashInd", "swashPosition", "slugInd", "slashInd", "slugIndex", "sllashNumber", "swashNumber", "slashCount", "swasherIndex", "slasherIndex", "swashCount", "fllashIndex", "fllashInd", "slugindex", "sllashPosition", "slashedPosition", "swasherPosition", "flashindex", "swasherCount", "fllashPosition", "swasherNumber", "sllashCount", "slashesInd", "slashedNumber", "slashindex", "flashIndex", "slasherNumber", "slashPosition", "sllashInd", "fllashindex", "slashesindex"], "periodIndex": ["dollarIndex", "tickMax", "periodCounter", "dollarMax", "tickIndex", "tickCounter", "pieCounter", "periodMax", "pieMax", "dollarPosition", "periodPosition", "tickPosition", "piePosition", "pieIndex", "dollarCounter"], "fileName": ["pageKey", " filename", "pagename", "fileKey", "Filename", "FileInfo", " fileKey", " fileInfo", "pageInfo", "pageName", "FileKey", "FileName", "filename", "fileInfo"], "url": ["http", "mail", "con", "or", "sl", "org", "cal", "ret", "build", "com", "bel", "link", "ur", "ul", "Url", "ml", "address", "URL", "raw", "rel", "util", "github", "re", "pl", "ssl", "uri", "loc", "nl", "client", "el", "browser", "gl", "impl", "str", "mount", "xml", "ll", "l", "u", "char", "www", "un", "conn", "base", "cl", "rl", "job", "web", "https", "cert", "r", "hl", "il"], "uc": ["ub", "nc", "oc", "con", "cu", "cus", "mc", "ul", "ucc", "um", "sc", "rc", "auc", "anc", "ci", "loc", "lc", "unc", "fc", "cr", "uf", "uu", "UC", "tc", "ec", "dc", "bc", "cl", "us", "cc", "userc", "co", "ux", "usc", "soc", "c", "cur"], "in": ["IN", "on", "din", "gin", "con", "init", "ln", "it", "rin", "is", "ze", "ic", "and", "mc", "f", "ill", "body", "read", "en", "inc", "io", "mm", "re", "ind", "al", "ins", "bin", "inner", "reader", "isin", "r", "l", "In", "input", "iter", "i", " din", "inn", "conf", "inf", "il", "cin"], "file": ["output", "path", "message", "db", "task", "model", "pdf", "fo", "type", "piece", "handle", "fil", "f", "to", "local", "fp", "io", "File", "resource", "filename", "spec", "name", "view", "page", "ile", "result", "form", "print", "FILE", "base", "port", "table", "log", "po", "document", "data", "format", "image", "zip"], "fos": ["flof", " fof", "fo", "Foss", "tOS", "fOS", "woss", "to", " foes", "FOS", "Fios", "flos", "fof", "Fof", "floes", "Fos", "flios", " fios", "foes", "toss", "Fo", "tos", "fios", "wo", "foss", "Foes", "wOS", "wos"], "out": ["output", "gr", "cos", "con", "st", "n", "Out", "it", "dis", "news", "flush", "o", "inv", "to", "os", "end", "io", "OU", "ex", "outs", "crit", "conv", "v", "ou", "nt", "at", "write", "g", "inner", "all", "writer", "w", "sum", "net", "print", "OUT", "conf", "set", "co", "ot", "outer"], "inputLine": ["textLINE", "inputBlock", "inputRow", " inputBlock", "configLine", "Inputline", "InputBlock", "submitLINE", "inLINE", " inputLINE", " inputCode", "configRow", "textLine", "inCode", "inputCode", "configFile", "configline", "InputRow", "inRow", "inputline", " inputRow", "submitRow", "inputFile", "InputLine", "textRow", "InputLINE", "submitBlock", " inputFile", "InputFile", "inputLINE", "inLine", "submitLine", "textCode", " inputline"]}}
{"id1": "12128591", "id2": "5836744", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"hash": [" mac", " check", "update", " sum", "Hash", " version", " text", " address", " equals", " signature", " key", "id", "h", " hashing", " fingerprint", "code", " code", "hex", " salt", "dump", " body", " message", "print", " h", " id", " Hash"], "data": ["output", "buffer", "message", "text", "json", "html", "password", "window", "block", "hello", "a", "ata", "secret", "raw", "dat", "rel", "accept", "DATA", "content", "this", "any", "bytes", "sequence", "result", "command", "batch", "string", "input", "action", "padding", "table", "value", "mu", "info", "what", "out", "image"], "digest": [" digist", "deest", "digly", "dese", "digist", "deist", "Digse", " digse", "Digester", "initEST", "mdests", " digave", " digested", "Digest", "digested", "displayest", " digit", "mdester", "displayested", "equse", "initested", "redly", " digEST", "digave", "mailly", "equest", "redgest", "redest", "displayse", "equave", "Digests", "DigEST", "digit", "displayests", "mdested", "redester", "digse", "diggest", "Digested", "mdly", "digEST", "digests", "Digist", "mailester", "mailest", "initester", "equit", "digester", "mdgest", "mdest", "mailgest", " digester", "initest", "mdit", "mdave", "mdse", "deested"]}}
{"id1": "6871529", "id2": "14865947", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"readUrlFile": [" readURLStream", "readurlPage", "readPathfile", "readURLfile", " readURLPage", "readURLStream", "readPathStream", "readurlStream", " readUrlStream", "readUrlfile", "readurlFile", "readPathFile", " readUrlfile", "readurlfile", "readUrlStream", "readPathPage", " readURLfile", " readURLFile", "readURLFile", "readUrlPage", " readUrlPage", "readURLPage"], "fullUrl": ["fullUr", "fullPath", "FullUrl", "pathName", "partialURL", "FullURL", "FullRoute", "fulURL", " fullName", "fullName", "completeURL", "pathUr", "FullName", "pathURL", "partialPath", "fulRoute", "completeurl", "Fullurl", "fullURL", "completeUrl", "pathUrl", "FullUr", " fullurl", " fullURL", "partialRoute", "fulUrl", "completePath", "fulurl", "partialurl", " fullUr", "partialUrl", "fullurl", "fullRoute", " fullPath"], "out": ["output", "ch", "json", "n", "Out", "it", "msg", "b", "flush", "p", "pretty", "o", "ws", "to", "os", "aos", "io", "outs", "t", "client", "ou", "nt", "write", "writer", "w", "screen", "txt", "net", "c", "print", "OUT", "table", "file", "log", "us", "s", "res", "report"], "url": ["path", "http", "mail", "ls", "sl", "config", "open", "build", "bel", "link", "b", "ur", "Url", "f", "ul", "URL", "rel", "ssl", "dl", "uri", "nl", "client", "resource", "browser", "ref", "google", "str", "mount", "ll", "service", "l", "char", "conn", "base", "file", "job", "sb", "web", "git", "oul", "r"], "encoding": ["Encaching", "Encapping", "rcoding", "capping", "ENCoder", "coder", "rcryption", "cryption", "encoded", "ENCoding", "encryption", "encapping", "ENCapping", "caching", "coding", "encaching", "ENCoded", "Encoder", "Encryption", "rcaching", "Encoded", "encoder", "rcoded", "coded", "Encoding"], "in": ["IN", "din", "gin", "user", "rin", "and", "f", "body", "id", "sql", "io", "from", "ind", "er", "ins", "el", "bin", "inner", "reader", "stream", "l", "r", "sum", "In", "conf", "input", "source", "m", "file", "i", "info", " din", "data", "inn", "inside", "inf", "cin"]}}
{"id1": "21125261", "id2": "7468827", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"test": ["load", "T", "hello", "testing", " evaluate", "example", "read", "sample", "evaluate", "execute", "feature", "t", "tests", "fit", "server", "train", "run", "volt", "debug", "unit", " tests", " testing", "Test", " sample", "show", "launch"], "is": ["mis", "ais", "es", "isc", "tis", "ms", "ls", "iso", "ris", "ai", "ri", "sys", "has", "lis", "bs", "isa", "as", "its", "ws", "os", "does", "xs", "are", "ps", "rs", "serv", "xml", "stream", "Is", "fs", "sit", "input", "us", "i", "ios", "s", "sis", "in", "out", "isi", "IS"], "byteArrayOutputStream": ["byteArrayApplicationForm", "byteArrayInputStyle", "byteArrayOutputView", "byteArrayByteForm", "byteArrayApplicationStream", "byteStringInputView", "byteArrayOutputSteam", "byteStringoutputString", "byteStringoutputSteam", "byteStringOutputStream", "byteStreamInputStream", "byteArrayoutputStream", "byteArrayInputString", "byteStringOutputSteam", "byteArrayApplicationSteam", "byteArrayoutputForm", "byteArray4View", "byteArray4Steam", "byteStringInputStream", "byteStringOutputString", "byteArrayoutputString", "byteArray4Stream", "byteStreamOutputStream", "byteArrayOutputForm", "byteArrayByteView", "byteArrayApplicationStyle", "byteArrayByteSteam", "byteArrayInputView", "byteArrayInputStream", "byteArrayOutputStyle", "byteStreamOutputStyle", "byteArrayInputForm", "byteStreamInputStyle", "byteStreamOutputSteam", "byteArray4String", "byteArrayOutputString", "byteStreamOutputForm", "byteStringoutputStream", "byteStringInputSteam", "byteStreamInputForm", "byteStringOutputView", "byteArrayoutputSteam", "byteArrayInputSteam", "byteArrayByteStyle", "byteStreamInputSteam", "byteStringoutputForm", "byteStringInputString", "byteStringOutputForm", "byteArrayByteStream", "byteArrayByteString"], "def": ["db", "json", "ded", "Def", "dev", "ef", "sd", "des", "del", "definition", "cd", "ds", "sche", "desc", "dem", "default", "crit", "pro", "dl", "det", "Definition", "DEF", "da", "define", "d", "dal", "dec", "DE", "md", "dict", "df", "defined", "decl", "conf", "hd", "de"], "se": ["ve", "ser", "ide", "est", "Se", "es", "ase", "sl", "te", "sd", "ie", "ze", "so", "me", "see", "ene", "she", "su", "ense", "sche", "ses", "sa", "ce", "ke", "sel", "ane", "sem", "pse", "ee", "ade", "le", "e", "be", "ine", "ode", "engine", "he", "ae", "sec", "SE", "pe", "ste", "ne", "set", "ese", "sed", "parse", "sp", "spe", "ge", "we", "sea", "de"], "linkId": ["LinkName", "lineid", "chainId", "linkID", "lineId", " linkName", "LinkID", "lineID", "Linkid", "linkedId", "connectionIdent", " linkID", "linkid", "chainID", "LinkId", "linkedID", "connectionId", "linkedIdent", "chainIdent", " linkid", "connectionID", "lineName", "linkIdent", "linkName"], "segmentId": ["segementName", "begmentId", "segroupName", "sementRef", "segmentID", "segroupById", "semissionName", "sementId", "sementid", "segementID", "semissionId", "begroupId", "segroupId", "idegmentRef", "segementId", "segementRef", "begmentID", "sementID", "idegementName", "semissionid", "segmentName", "idegementid", "begroupById", "segmentById", "segementid", "segmentid", "idegmentName", "idegmentid", "begroupID", "segementById", "sementName", "begmentById", "idegementRef", "segmentRef", "segroupID", "semissionRef", "idegementId", "begmentName", "idegmentId", "sementById", "begroupName"], "linkSegments": ["linkFragments", "linkFraggments", "linkParlements", " linkSegment", "linkConnectets", "linkSeggments", " linkThreadlements", "linkBuildment", " linkBuildments", " linkGments", "linkGment", "linkConnectables", "linkFragment", " linkGment", " linkSeggments", "linkSeglements", "linkBuildets", "linkConnectroups", " linkSeglements", "linkGgments", "linkConnectgments", " linkSegables", " linkThreadroups", "linkSegment", " linkThreadments", " linkGroups", " linkSegroups", "linkSements", "linkConnectlements", "linkThreadgments", "linkSegables", "linkThreadlements", " linkThreadgments", "linkConnectments", " linkBuildgments", "linkGments", " linkBuildets", "linkBuildables", " linkSegets", "linkBuildgments", "linkSeets", "linkSeables", "linkSegets", " linkBuildables", "linkParroups", "linkThreadroups", "linkBuildroups", "linkGroups", "linkFragroups", "linkThreadments", "linkParments", "linkSegroups", " linkGgments", "linkBuildments", "linkPargments"], "segments": [" Seges", "usegins", "vegments", " sements", "sements", "segins", "parsectors", " segins", "megments", "velements", "parsegments", "megins", "bements", " segs", "segs", "bevals", "vectors", " Sements", "sectors", "usements", "selements", "mements", "begments", " Segments", " seges", "seges", " sevals", "vements", " Sevals", "parsements", " sectors", "parselements", " selements", "beges", "megs", "usegs", "sevals", "usegments"], "frameProperties": ["framePropptions", " frameByperties", "framePrps", "frameComptions", "frameByperties", "framePropperties", "frameParptions", " framePrptions", " frameProrics", "framePrperties", " frameProptions", "frameProfps", "frameParps", "frameProfperties", "frameByptions", " frameByptions", " framePrps", "framePropps", "framePrrics", "frameProfilities", "frameParperties", " framePrperties", " frameProps", "frameProilities", " frameByilities", " frameByps", "frameProps", "framePropilities", " frameProilities", "frameByps", "frameProfptions", "frameProptions", "frameProrics", " framePrrics", "frameComrics", "frameByilities", "frameComperties", "frameParrics", "framePrptions", "frameComps"], "time": ["each", "second", "message", "TIME", "task", "depth", "step", "timeout", "window", "x", "think", "now", "counter", "money", "tt", "times", "count", "runtime", "duration", "size", "frequency", "Time", "t", "etime", "total", "timer", "length", "transform", "trust", "clock", "version", "estamp", "ime", "sequence", "event", "delay", "rate", "tim", "before", "check", "set", "speed", "point", "tx", "date", "value", "system", "distance", "slow", "year", "context", "start", "ts", "trace"], "vehicle": ["Vehic", "heroicles", "verticles", "vehendor", "heroocity", "verendor", "heroICLE", "vericle", "verogram", "survogram", "ventic", " vehocity", "survicle", "yardogram", "vertocity", "Vehicles", "yardicle", "Vehicle", "vehICLE", "venticle", "VehICLE", "survendor", "yardocity", "vehocity", "yardendor", "vehogram", "venticles", "vertic", "verocity", "heroicle", "survocity", "vehic", " vehICLE", " vehicles", "ventocity", "verticle", "vehicles", "Vehocity"]}}
{"id1": "15202804", "id2": "9479502", "code1": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getDigest": ["getDigested", "getdigested", "getDests", "getMDested", "getMDester", "getDested", "getMDests", " getdigester", "getdigest", " getDigested", "getDester", "getdigests", " getDigester", "getDigester", "getdigester", "getMDest", "getDest", " getDigests", " getdigests", "getDigests", " getdigested", " getdigest"], "user": ["http", "owner", "host", "by", "org", "force", "author", "human", "change", "me", "account", "manager", "person", "ome", "from", "User", "use", "login", "client", "back", "name", "post", "USER", "username", "form", "project", "string", "device", "actor", "job", "ud", "system", "usr", "admin", "ip", "bug", "word", "usa", "role", "order"], "realm": ["realme", "realmi", "Realmn", "realms", "Realme", "tenmi", "Realmi", "almi", "realmid", "Realmid", "realmn", "alme", "alm", "calm", "calme", "cheme", "Realms", "Realm", "calmid", "alms", "chemn", "tenm", "tenms", "tenme", "calmn", "chemid", "chem"], "password": ["message", "session", "description", "words", "phrase", "hello", "database", "property", "wd", "wp", "reset", "create", "power", "Password", "encrypted", "confirmed", "pass", "PASS", "sword", "post", "productive", "username", "policy", "crypt", "form", "hash", "device", "port", "wordpress", "data", "paste", "php", "remember", "word"], "method": ["path", "message", "http", "function", "time", "force", "type", "class", "property", "api", "prop", "util", "subject", "op", "resource", "spec", "mode", "verb", "where", "module", "process", "version", "view", "hod", "get", "service", "go", "mod", "form", "command", "action", "hash", "select", "gem", "Method", "METHOD", "format", "url", "man", "eth"], "uri": ["path", "doi", "http", "location", "term", "phi", "ri", "database", "ui", "ur", "connection", "address", "via", "iri", "util", "subject", "resource", " URI", "direction", "course", "ouri", "du", "unit", "username", "URI", "archive", "i", "range", "web", "pi", "query", "https", "url", "host"], "nonce": ["doncer", "donCE", "Noncause", "vincer", " nonces", " nonced", "Nonces", "noncer", "NonCE", "donce", "bonced", "nonCE", "nonces", "vincause", " noncer", "noncause", "boncer", "nonced", "vinCE", "vince", "Noncer", "Nonce", "bonce", "bonces", "doncause", "Nonced"], "digest1": ["digace1", "digist2", "digester1", "digaceEx", "Digestone", "digesterOne", "digester2", "digested1", "DigEST1", "DigesterOne", "digaceOne", "digaceone", "digested2", "Digester1", "Digester0", "digist0", "digestedOne", "Digest2", "digester0", "DigESTOne", "digESTone", "Digest1", "digist1", "DigestEx", "digESTEx", "DigESTone", "digestedone", "DigestOne", "digESTOne", "digistOne", "Digester2", "Digest0", "DigESTEx", "digested0", "digEST1", "digest0", "digestedEx", "digestone", "digestEx"], "digest2": [" digesterTwo", "Diggest2", "diggest3", "digist2", "digester1", "digistTwo", "Diggest1", "digester2", "diggestTwo", "digested1", "digesterTwo", "Digesttwo", "digestertwo", "digist3", "digesttwo", "digestedTwo", "digested2", "digester3", "Digest2", "diggest2", "Diggesttwo", "Digest1", "digist1", "DiggestTwo", " digester1", "digestedtwo", " digester3", "diggesttwo", "diggest1", " digester2", "DigestTwo"], "digestOne": ["digerOnce", "digseOne", "digseSingle", "digester1", "digestedOnce", "Digestone", "digesterOne", "digerSingle", "digseOnce", "DigesterSingle", "digested1", "DigesterOnce", "DigesterOne", "Digesterone", "digestedSingle", "DigestOnce", "Digester1", "digerOne", "digse1", "digestedOne", "digesterone", "digistone", "digesterOnce", "Digest1", "digist1", "digestSingle", "digistOnce", "DigestOne", "digistOne", "digistSingle", "DigestSingle", "digesterSingle", "digestOnce", "diger1", "digestone", "digestedone"], "hexDigestOne": ["hexDigestedInit", "hexdigist1", "hexDigesterTwo", "hexdigestName", "hexdigistName", "hexDigistTwo", "hexDigesterName", "hexDigist1", "hexDigistInit", "hexDigseOnce", "hexDigester1", "hexdigseOne", "hexDigistOne", "hexDigestInit", "hexdigest1", "hexDigestedOne", "hexDigseInit", "hexDigesterOne", "hexDigestOnce", "hexdigestInit", "hexdigseInit", "hexDigested1", "hexDigestedOnce", "hexDigestedTwo", "hexdigistTwo", "hexdigistOne", "hexDigestedName", "hexdigseOnce", "hexdigestOnce", "hexdigestTwo", "hexDigestName", "hexDigest1", "hexdigestOne", "hexdigse1", "hexDigse1", "hexDigistName", "hexDigseOne", "hexDigistOnce"], "digestTwo": ["digisticTwo", "mixseTw", "mixestTw", "digist2", "mixseTwo", "digistTwo", "diggestAnother", "digester2", "digrateThree", "diggestTwo", "digestingtwo", "digse2", "digistic2", "digseTwo", "Digesttwo", "digestertwo", "ddestTwo", "digesterTwo", "digsetwo", "digesttwo", "ddestAnother", "ddistAnother", "digestingTwo", "digestTaylor", "digestingTaylor", "Digestertwo", "digesterTaylor", "Digest2", "ddest2", "digseTw", "ddist2", "digistictwo", "diggest2", "digistTaylor", "digrateTwo", "diggestTw", "mixsetwo", "digrateAnother", "diggestThree", "DigestTwo", "digistThree", "DigesterTaylor", "ddestThree", "Digester2", "digisttwo", "digestTw", "digestAnother", "ddistThree", "ddistTwo", "DigesterTwo", "diggesttwo", "digistAnother", "mixest2", "digesting2", "mixestTwo", "digisticTw", "digrate2", "mixse2", "DigestTaylor", "mixesttwo"], "hexDigestTwo": ["hexDigESTThree", "hexDigestaTwo", "hexDigesterAnd", "hexDigistThree", "hexDigesterTwo", "hexDigestaAnd", "hexDigistTwo", "hexDigEST2", "hexDigist2", "hexDigesta2", "hexDigestedAnd", "hexdigesterAnd", "hexDigestaOne", "hexDigestedOne", "hexdigesterOne", "hexDigesterOne", "hexdigest2", "hexDigESTTwo", "hexDigester2", "hexDigestedTwo", "hexdigestAnd", "hexDigestAnd", "hexdigestTwo", "hexdigestOne", "hexDigesterThree", "hexDigest2", "hexDigested2", "hexdigesterThree", "hexdigesterTwo", "hexdigestThree", "hexdigester2"], "digest3": ["digistThird", "diggest3", "DigestThird", "diggestThird", "DigistThird", "digESTThird", "DigesterThree", "digesterThree", "Digest3", "digEST3", "digist3", "digetThree", "digetThird", "digestThird", "Digester003", "diggestthree", "digester3", "Digist3", "DigesterThird", "digestthree", "digESTThree", "digistthree", "Digester3", "diggestThree", "digesterThird", "digistThree", "DigistThree", "Digistthree", "diggest003", "digest003", "diget003", "diget3", "Digest003", "Digestthree", "digester003", "DigestThree", "digESTthree"], "digestThree": ["digistThird", "DiggestThird", "diggest3", "DigestThird", "DiggestThree", "diggestThird", "DigesterThree", "digesterThree", "ddgest3", "digester5", "Diggestthree", "Digest3", "digist3", "digestThird", "diggestthree", "ddestthree", "digester3", "digsethree", "DigesterThird", "digestthree", "digesting3", "digesterthree", "digistthree", "ddgestThree", "Digester3", "Diggest3", "digesterThird", "diggestThree", "digistThree", "ddestThree", "ddgestThird", "Digest5", "Digester5", "digesting5", "digest5", "digse3", "ddest3", "digestingThree", "Digestthree", "digestingThird", "DigestThree", "digseThird", "ddgestthree", "diggest5", "ddestThird", "digseThree"], "hexDigestThree": ["hexDigistRight", "hexDigestthree", "hexDigistThree", "hexdigistRight", "hexdigests3", "hexDigested3", "hexDigestedThree", "hexdigestsThree", "hexDigestsThree", "hexdigeststhree", "hexDigesting4", "hexDigesterRight", "hexDigestsThird", "hexDigester4", "hexDigestThird", "hexdigistThree", "hexdigest4", "hexDigestingThree", "hexdigestsThird", "hexDigesting3", "hexDigests3", "hexDigestRight", "hexdigist3", "hexdigest3", "hexdigestRight", "hexDigester3", "hexdigist4", "hexDigest3", "hexDigesterThird", "hexDigestedthree", "hexdigestThird", "hexDigesterThree", "hexDigest4", "hexDigestedThird", "hexDigist3", "hexdigestthree", "hexDigesterthree", "hexDigestingRight", "hexDigist4", "hexDigeststhree", "hexdigestThree"]}}
{"id1": "20717531", "id2": "5299276", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["decryption", "Encrypted", "uncryption", "uncrypt", "Encryption", "decipher", "decrypted", "encryption", "encipher", "Encrypt", "uncipher", "Encipher", "encrypted", "uncrypted", "decrypt"], "plainText": ["ainTextColor", "formTEXT", "hardText", " plaintext", "longString", "broadPassword", "ainPassword", " plainString", "ainTEXT", "plainOutput", "realtext", "floatTEXT", "floatPassword", "cleanName", " plainTextColor", "ainString", "longText", "hardTEXT", "ainDelete", "plainData", "broadText", "broadTEXT", "aintext", "plainDelete", "cleanText", "publicOutput", "ainName", "tableUrl", "ainPath", "longTextColor", "ainOutput", " plainTEXT", "cleantext", "formText", "realText", "plainPassword", "longSource", "plainWord", "tableText", "plaintext", "ainText", " plainUrl", " plainName", "publictext", "leadtext", " plainSource", "publicText", "longtext", "leadPath", "tableConfig", "formtext", "formWord", "plainSource", "ainConfig", "ainUrl", "hardtext", "realSource", "realTEXT", " plainPath", "plainPath", " plainConfig", " plainOutput", "ainData", "leadText", "ainWord", "cleanTEXT", "floatDelete", "longTEXT", "publicData", " plainData", "plainName", "floatText", "plainTextColor", "tableTEXT", "plainConfig", "hardWord", "leadTEXT", "plainString", "plainUrl", "plainTEXT", "broadDelete"], "text": ["path", "output", "buffer", "message", "binary", "prefix", "TEXT", "template", "tt", "ext", "title", "ct", "ut", "Text", "read", "cat", "end", "ind", "t", "nt", "content", "translation", "all", "write", "writer", "process", "view", "aut", "quick", "quote", "txt", "sum", "net", "event", "cont", "print", "struct", "input", "source", "tx", "select", "log", "comment", "math", "format", "start", "act", "word", "image", "left"], "i": ["ims", "it", "ri", "ic", "iu", "qi", "t", "gi", "iter", "ori", "iy", "cli", "li", "oi", "zi", "j", "init", "my", "uni", "ini", "is", "ui", "f", "q", "o", "uri", "asi", "hi", "g", "ti", "bi", "ji", "print", "us", "ami", "chain", "sim", "ip", "\u0438", "multi", "im", "ity", "n", "id", "ci", "ii", "index", "u", "ei", "yi", "m", "xi", "z", "pi", "eu", "ms", "x", "phi", "ai", "ski", "p", "y", "io", "mi", "gu", "ki", "v", "cgi", "ni", "si", "I", "point", "di", "in", "ix"], "mDigest": ["mExecest", "mDester", "mdigse", "Mdigest", "MDigest", " mDigested", "mDested", "mHashum", " mHashger", "mHashested", " mDse", "mdiger", "mDose", "mDigse", "MDigse", "mHashger", "mExecger", "mDoher", "mDigher", "mdigester", "mDigester", "mMacested", "mHashest", " mDigger", " mDester", " mDigum", " mHashest", "mFindse", "mdigger", "Mdiggest", "mMDer", "mDiggest", "mMacester", "mDoest", "mdigher", "mFindgest", "mFindest", "mMacse", "mDigger", "mDigested", "MDiggest", "mDse", "mMacest", "mDoested", "MDiger", "mdiggest", "mdigested", " mDigse", " mHashum", "mdigest", " mDigester", "Mdiger", "mMDgest", " mDigher", " mHashested", " mDher", " mDested", "mExecested", "mDiger", "mdigum", "mMDse", " mDest", "mMDest", "Mdigse", "mDher", "mFinder", "mDest", "mDigum", "mExecum"], "d": ["db", "nd", "j", "n", " D", "x", "dx", "sd", "a", "bd", "b", "f", "p", "dat", "ds", "cd", "y", "h", "ed", "t", "with", "v", "dh", "e", "D", "dot", "g", "done", "ld", "da", "dd", "dc", "w", "dec", "l", "u", "md", "dict", "pd", "m", "df", "di", "s", "fd", "r", "diff", "c", "de"], "hash": ["buffer", "message", "style", "our", "rh", "html", "password", "block", "save", "Hash", "hz", "shift", "header", "filter", "sha", "id", "ssh", "h", "checked", "test", "oh", "total", "dh", "tag", "square", "always", "summary", "radius", "ah", "all", "hex", "key", "code", "flash", "sh", "shadow", "sum", "tr", "dict", "href", "print", "check", "table", "search", "array", "random", "div", "handle", "her", "report", "cache", "ash"]}}
{"id1": "22268798", "id2": "11933797", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"getContent": ["getContents", "GetContents", " getEntity", " getObject", "GetEntity", "getEntity", "GetObject", "createContents", "getObject", "GetContent", " getContents", "createContent", "createEntity", "createObject"], "principal": ["pricity", " prPrinciple", "pricipal", "priciple", "prPrincipal", "pricipipal", "principle", " prPrincity", " principle", "prPrincity", " prPrincipal", " princicate", "prPrincicate", "pricipicate", "prPrinciple", "pricipiple", " princity", "princicate", "princity", "pricipity", "pricicate", " prPrincicate"], "path": ["location", "Path", "prefix", "PATH", "template", "config", "ath", "type", "link", "address", "reference", "p", "usage", "kind", "uri", "resource", "transform", "parent", "ref", "key", "name", "policy", "route", "form", "cont", "parts", "entry", "object", "file", "log", "chain", "info", "query", "full", "format", "context", "cmd", "alias", "image", "pattern"], "version": ["part", "json", "n", "generation", "versions", "Version", "ver", " versions", "draft", "channel", "v", "VERSION", "release", " Version", "name", "index", "unit", "serial", "virtual", "sequence", "VER", "object", "hash", "date", "document", "format"], "properties": ["beans", " props", "perties", "sites", "metadata", "property", "params", "images", "prop", "packages", "ps", "tags", "settings", "features", "policy", "values", "parts", "details", "reports", "fields", "resources", "children", "media", "owners", "groups", "options", "items", "objects"], "uniqueName": ["sampleAnn", "randomId", "uniqueCase", "UniqueName", "uniqueAnn", "newNum", "uniqueLength", "iqTime", "iqId", "iqName", "UniqueTime", "newNames", " uniqueNames", "newCase", "sampleNum", " uniqueLength", "sampleName", "uniqueTime", "uniqueKey", " uniqueKey", "uniqueNum", "iqKey", "randomTime", "newName", " uniqueId", "UniqueLength", "uniqueNames", "iqAnn", "newKey", "newAnn", "iqNum", "randomName", "uniqueId", "sampleCase", "randomKey", "iqCase", "UniqueNames", " uniqueTime", "UniqueKey", "UniqueId", "newLength"], "url": ["http", "db", "mail", "html", "ls", "location", "abs", "sl", "auto", "bel", "link", "handle", "ur", "Url", "address", "URL", "rel", "util", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "server", "browser", "gl", "this", "null", "name", "mount", "str", "xml", "ll", "l", "u", "page", "char", "result", "base", "rl", "domain", "file", "web", "https", "cert", "res", "r", "host", "pattern"], "content": ["output", "message", "load", "Content", "text", "update", "description", "core", "access", "time", "compliance", "section", "config", "instance", "header", "type", "item", "response", "condition", "metadata", "ct", "title", "address", "raw", "claim", "ontent", "relation", "create", "control", "client", "resource", "current", "wrapper", "continue", "cm", "summary", "parent", "write", "key", "inner", "label", "contact", "get", "page", "license", "obj", "result", "cont", "remote", "entry", "object", "action", "status", "value", "file", "comment", "document", "data", "format", "display", "context", "search", "layout", "image", "report", "cache", "article"], "connection": ["collection", "application", "connect", "pointer", "cone", "Connection", "ion", "session", "close", "description", "open", "link", "database", "response", "generation", "condition", "reference", "socket", "character", "relation", "io", "associated", "uri", "closure", "client", "resource", "channel", "category", "communication", "index", "opening", "number", "position", "connected", "directory", "conn", "command", "entry", "system", "document", "c", "network"], "mimeType": ["cmimeHandler", "mimesType", "cmimetype", "cmimeType", "mIMEHandler", "mgeType", "MimeIndex", "mimeIndex", "mIMELength", "cmimesHandler", "mIMETypes", "cmimesTypes", "mimesLength", "mixedHandler", "mimeHandler", "MIMEIndex", "MIMEType", "mimesTypes", "mimestype", "cmimestype", "mixedtype", "MimeLength", "mimeLength", "cmimesType", "mgeTypes", "mimeTypes", "mixedTypes", "MimeTypes", "mimetype", "mIMEtype", "mimesIndex", "mgeLength", "MIMELength", "MimeType", "mIMEType", "mgeIndex", "MIMETypes", "mimesHandler", "mIMEIndex", "mixedType", "cmimeTypes"]}}
{"id1": "13666876", "id2": "19113613", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformOneSourceFile", "transformMultiFile", "TransformSingleRecord", "transformsingleRecord", "processSingleFiles", "transformSingleRecord", "transformMultiRecord", "TransformSimpleFile", "processsingleFile", "transformSimpleFile", "transformSimplePage", "processSinglefile", "transformOneFile", "transformsingleModel", "transformMultiModel", "transformSingleModel", "processSingleFile", "transformMultifile", "transformSimpleRecord", "processSingleSourceFile", "transformSinglefile", "processsingleFiles", "transformSimpleModel", "transformsingleFiles", "transformMultiPage", "transformOnefile", "transformOneFiles", "TransformSimpleRecord", "transformsinglePage", "transformSingleFiles", "TransformSimplePage", "transformsinglefile", "transformSinglePage", "TransformSingleModel", "transformsingleSourceFile", "TransformSinglePage", "transformSingleSourceFile", "processsingleSourceFile", "transformsingleFile", "transformMultiFiles", "TransformSingleFile", "transformMultiSourceFile", "processsinglefile", "TransformSimpleModel"], "xed": ["wxed", "Xeded", "xED", " xied", "xeds", "exed", "rxed", "wxEd", "exeded", "wxented", "passed", "passED", "xeded", "uxed", "txer", "txED", "wxred", "Xeds", "pxeds", "uxied", " xED", "txeds", "xied", "uxented", "xer", "rxED", "pxed", "Xed", "xred", "pxeded", " xented", "passred", "exeds", "pxED", "wxied", "XED", "Xer", "rxeds", "wxED", "xented", "exED", "rxer", "xEd", " xEd", "uxED", "passEd", " xred", "txed"], "node": ["our", "load", "n", "link", "and", "seed", "entity", "no", "row", "create", "Node", "scene", "note", "feature", "map", "channel", "resource", "right", "parent", "component", "station", "hand", "tree", "name", "process", "ode", "index", "view", "edge", "day", "post", "one", "event", "directory", "line", "stage", "remote", "entry", "object", "set", "job", "range", "array", "word", "image", "de"], "dob": ["dod", "doy", " doy", " dobb", "adoy", "dobar", "drod", "adob", "Dob", " dab", " dobar", "drob", " dod", "diod", "Dab", "dobb", "drab", "dab", "drobb", "Doy", "diobb", "adab", "diob", "diab", "Dobar", "adobar"], "mySrc": ["MySsrc", "myDesRC", "myInsfc", "MySRC", "mySourceource", "myDesources", "mySelsrc", "myInssrc", "mySfc", "myAsRC", "MySources", "myDessrc", "mySRC", "mySourcesrc", "mySingRC", "mySourcerc", "mySingfc", " mySRC", "MySrc", " mySsrc", "mySources", "myDesrc", "myAsource", "mySelRC", "mySource", "mySelources", "myAsrc", "mySourceRC", " mySfc", "mySingsrc", "myInsRC", "mySelrc", "myInsrc", "myAssrc", "MySource", "mySingrc", "mySsrc"], "mySrcF": ["mySufO", "mySsrcO", "myMrcFP", "mySourceV", "mySrtF", "mySsrcC", "mySRCC", "mySrcC", "mySrtP", "mySRCF", "mySRCI", "mySsrcF", "myMrcF", "mySufFP", "myMrcO", "mySrcV", "mySsrcI", "mySrcI", "mySourceO", "mySourceF", "mySufF", "myMourceF", "mySrcP", "myMourceFP", "mySsrcV", "mySourceFP", "mySRCP", "mySsrcFP", "mySrtI", "myMourceV", "mySrcFP", "myMrcV", "myMourceO", "mySsrcP", "mySrcO", "mySufV", "mySrtC"], "myOutF": ["myoutL", "myInL", "myCoF", " myOutL", "myNetW", "MyOutV", "mysNetF", "MyOutF", " myOutFile", "myNetFile", "myoutC", " myOutV", "myObjF", "myOutputF", "myOutL", "myNetL", "MyInV", "MyInF", "mysOutL", "MyInFs", "mysNetW", "myNetE", "mysNetL", " myNetE", "myOutFL", "myOutFs", " myOutE", "MyOutFs", "myoutV", "myOutputL", "myObjFile", "myInFs", " myoutC", " myoutL", "myArtF", " myNetF", "myOffDF", "myArtFL", "myObjV", "myOffF", "myOutputDF", "myOutE", "myArtL", "mysOutF", "myOutputV", "MyInFile", "myCoFL", "myOutW", "myObjFs", "myInF", " myoutV", "myNetF", "myOutFile", "myCoW", "myoutF", " myNetFile", "myOutputE", "myInFile", "myOutV", "myOutputC", "myOutC", "myArtW", "myOutputFile", "myInV", " myNetDF", " myOutC", "mysNetFL", "myCoL", "mysOutFL", " myoutF", "myOutputFs", "myOffFile", "mysOutW", "myOutDF", "myNetFL", " myOutDF", "myInC", "myOffE", "MyOutFile", "myNetDF"], "co": ["nc", "oc", "cos", "con", "cu", "cal", "cover", "cho", "fo", "ror", "lo", "so", "ck", " Co", "can", "no", "o", "col", "coord", "ce", "ico", "cv", "ci", "io", "cs", "loc", "lc", "flo", "xc", "Co", "yes", "CO", "fc", "cm", "ho", "cod", "cop", "aco", "ace", "obj", "go", "gc", "cl", "copy", "cc", "wo", "po", "ctrl", "ko", "mo", "ro", "roc", "com", "ca", "soc", "coll", "c", "cache"], "x3dvFile": ["x3dbFilename", "x3dvsFile", "x3dVPath", "x3cdVPath", "x3dtfile", "x3pdbFilename", "x3dvfile", "x3dVfile", "x3dbString", "x3dbfile", "x3pdbFile", "x3davFilename", "x3dvFilename", "x3davPath", "x3davFile", "x3dvPath", "x3dbFile", "x3pdbfile", "x3cdVFilename", "x3dVString", "x3dVFile", "x3dtFile", "x3dvsFilename", "x3pdvFilename", "x3dVFilename", "x3dvString", "x3pdbString", "x3dtFilename", "x3dvsPath", "x3dtString", "x3pdvFile", "x3pdvString", "x3cdVFile", "x3cdvFilename", "x3pdvfile", "x3cdvPath", "x3cdvFile"], "fis": [" fiss", "biss", "fisi", "fileis", "friss", "frisi", "bie", "bis", "fileiss", "fiss", " fiz", " fie", "fliz", "bisi", "flis", "flires", " fisi", "fliss", " fires", "fiz", "fie", "frie", "fileiz", "fires", "fileires", "fris"], "gzos": ["gtnos", "gzo", "gties", "goss", "ssloss", "sslos", "gtoss", "gaos", "zaos", "ggos", "gos", "gsops", "gznos", "ziposs", "zies", "zipnos", "gzaos", "zoes", "gtoes", "zoss", "zops", "zos", "gzies", "zipos", "gtos", "gzops", "sslo", "gsoss", "ggoes", "go", "gzoss", "gtops", "sslaos", "ggops", "zo", "zipops", "gzoes", "gsnos", "ggies", "gsos"], "buf": ["buffer", "Buffer", "orig", "block", "font", "img", "pkg", "var", "bar", "b", "aka", "bag", "raw", "Buff", "tab", "cat", "cv", "seq", "conv", "fb", "arr", "buff", "ref", "uf", "emb", "cast", "box", "bus", "vec", "cb", "wb", "bytes", "cam", "good", "batch", "mem", "cap", "mu", "max", "br", "cf", "cmd", "rb", "cur"], "ret": ["out", "elt", "deg", "arg", "val", "rets", "ext", "et", "ry", "end", "pret", "test", "re", "att", "mt", "red", "ft", "v", "back", "continue", "nt", "ref", "rt", "aux", " Ret", "alt", "ctr", "inter", "ptr", "r", "ter", "obj", "err", "Ret", "tr", "print", "cont", "gt", "def", "iter", "RET", "cert", "res", "repl", "cmd", "len"]}}
{"id1": "11153282", "id2": "823074", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": ["existUrl", "existingHTTP", "existsUR", "existUR", " existHTTP", "existingUR", "exitsHTTP", " existsUrl", " existUR", "exitsURL", " existsUR", "exitsUrl", "exitsUR", "existsUrl", "existHTTP", "existingUrl", " existUrl", "existURL", "existsHTTP", " existsHTTP", " existURL", "existingURL"], "urlStr": ["uriSt", "uriSpec", " urlWr", "URLStr", " urlString", "uriString", " urlSpec", "urlWr", "uriWr", "urlSpec", "UrlSt", " urlSt", "uriStr", "URLSpec", "urlString", "UrlObj", "UrlStr", "URLString", "UrlSpec", "URLWr", " urlObj", "urlSt", "urlObj", "uriObj"], "url": ["http", "ls", "abs", "sl", "arl", "org", "build", "bel", "link", "ur", "lb", "ul", "Url", "b", "arch", "URL", "p", "sur", "pl", "ssl", "uri", "dl", "loc", "nl", "this", "null", "name", "mount", "str", "ll", "l", "char", "conn", "gc", "base", "acl", "rl", "file", "log", "job", "https", "r", "il"], "con": ["fn", "ch", "nc", "proc", "cos", "connect", "Con", "on", "close", "cond", "n", "ln", "open", "user", "dial", "rec", "connection", "ain", "can", "pen", "col", "en", "num", "re", "sub", "cs", "conv", "client", "fin", "fc", "cm", "syn", "inner", "canon", "cp", "cons", "comm", "coll", "compl", "bc", "un", "conn", "cont", "cn", "CON", "ran", "ctrl", "co", "cf", "res", "com", "conf", "soc", "Conn", "c", "cur"], "responseCode": ["answerCode", " responseType", "ResponseCode", "replyMessage", " responseZone", "responseZone", "replyCode", "responseMessage", "Responsecode", "conditionType", " responseCount", "responseCount", "conditionZone", "conditionMap", "replycode", "ResponseCount", "answerMap", "replyCount", "responseMap", "answerType", " responsecode", "answerZone", "ResponseMessage", " responseMessage", "responsecode", "conditionCode", "responseType", " responseMap"]}}
{"id1": "13720140", "id2": "13666876", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"modifyProperty": ["ModifiesProperty", "modifiesProp", "ModifyAttribute", "ModifiesValue", "ModifiesAttribute", "modateProp", "ModifiesProp", "ModifyValue", "modifyAttribute", "modateProperty", "modifiesAttribute", "modureAttribute", "modifiesValue", "modureProperty", "modateAttribute", "ModifyProperty", "modifiesProperty", "modureValue", "modifyProp", "modureProp", "modateValue", "ModifyProp", "modifyValue"], "valueID": ["versionIDs", " valueId", "VALUEMD", "valueIDs", "valueUID", " valueIDs", "versionUID", "propertyIDs", "versionMD", " valueid", "propertyId", "versionid", " valueUID", "versionId", "valueId", "propertyID", "valueMD", " valueMD", "VALUEUID", "VALUEID", "valueid", "versionID", "propertyid", "VALUEId"], "value": ["output", "field", "VALUE", "message", "expression", "application", "text", "update", "function", "buffer", "description", "password", "save", "instance", "val", "hello", "type", "example", "attribute", "address", "state", "variable", "default", "current", "v", "content", "code", "Value", "key", "name", "version", "label", "get", "values", "vector", "entry", "string", "input", "padding", "comment", "data", "format", "memory"], "userID": ["UserURL", "UserID", "usernameURL", "ownerType", "usernameID", "UserType", "userId", "UserName", "usernameName", " userType", " userName", "usernameId", " userId", " userURL", "ownerName", "userName", "ownerID", "userType", "UserId", "ownerId", "userURL"], "property": ["field", "second", "message", "style", "expression", "function", "description", "term", "prefix", "properties", "config", "method", "section", "type", "item", "attribute", "title", "metadata", "address", "p", "state", "claim", "prop", "to", "relation", "associated", "feature", "resource", "setup", "operator", "translation", "Property", "this", "key", "module", "pair", "name", "label", "position", "policy", "license", "pe", "print", "command", "project", "object", "language", "table", "profile", "option", "media", "data", "display", "alias", "prototype", "ty"], "newValue": ["oldName", " newMessage", " newName", " newResult", "NEWValue", "NewString", " newString", "oldValues", "uniqueName", "newVersion", "newValues", "oldResult", "newName", "oldVersion", "newString", "oldValue", "newMessage", " newvalue", "NEWvalue", "oldString", " newValues", "uniqueMessage", "oldMessage", "oldvalue", "uniqueValue", "uniqueVersion", "newvalue", "NewValues", "newResult", " newVersion", "NEWResult", "NewValue", "Newvalue", "NEWString"], "crypt": ["ch", "cos", "rh", "password", "core", "coin", "init", "cy", "sync", "sys", "rem", "arch", "CR", "ct", "bec", "enc", "reset", "col", "auth", "ssl", "cs", "conv", "pt", "sm", "cot", "Crypt", "cr", "cm", "cmp", "nt", "code", "hex", "roy", "trust", "magic", "ctr", "cp", "comm", "mac", "rypt", "rot", "dec", "go", "dict", "cont", "gc", "mem", "check", "hash", "cc", "cook", "cry", "cert", "ocr", "cmd", "coll", "prot", "cur"], "digest": [" DigEST", "dester", "hexester", "mdestamp", "Digester", "mdests", " digested", "Digest", "digested", "hashests", " Digert", "hashge", "mdester", " Digest", " digEST", "hexert", " Digester", "Digestamp", "Digests", " digestamp", "DigEST", "hexest", "digestamp", "hashest", "mdested", "Digert", "mdEST", "diggest", "digEST", "digests", "dest", "Digested", "digert", "digester", "mdgest", "dested", "hexEST", "mdest", "mdge", "dEST", "Digge", "digge", "Diggest", "hashgest"], "hexString": ["hashStr", "exString", "hashArray", " hexstring", "shortString", "exArray", "formStr", "hexstring", " hexStr", "exBuffer", "hashString", " hexArray", "exstring", " hexBuffer", "exBytes", "hexBuffer", "shortstring", "shortBuffer", "formBytes", "hexStr", "hexArray", "formString", "exStr", "hexBytes", "hashstring", "formBuffer", "shortStr", " hexBytes"], "i": ["multi", "im", "ms", "x", "j", "init", "phi", "it", "ai", "a", "is", "ic", "ini", "ui", "ie", "major", "q", "id", "y", "o", "io", "ci", "mi", "ind", "gu", "uri", "ex", "qi", "ii", "ki", "slice", "v", "gi", "e", "hi", "ti", "ji", "bi", "index", "si", "number", "I", "span", "u", "ei", "point", "m", "us", "cli", "di", "sim", "pi", "info", "chain", "ip", "li", "\u0438", "ix"]}}
{"id1": "7351534", "id2": "12782570", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdentification", "getStreamFromSystemIdentifiers", "getStreamFromSysIdentifiers", "getStreamFromSysIdentification", "getStreamFromSysidentifier", "getStreamFromSystemIdifer", "getStreamFromSystemidentifiers", "getStreamFromSystemIdification", "getStreamFromSysidentification", "getStreamFromSystemidentifier", "getStreamFromSysIdentifier", "getStreamFromSystemIdifiers", "getStreamFromSysidentifiers", "getStreamFromSystemIdentifer", "getStreamFromSysidentifer", "getStreamFromSystemidentification", "getStreamFromSysIdentifer", "getStreamFromSystemidentifer", "getStreamFromSystemIdifier"], "systemId": ["localhostDoes", "cmsDoes", "publicIn", "ystemId", "ystemid", "publicName", "systemById", "systemMid", "sysIs", "systemid", "systemIs", " systemMid", "publicId", "ystemMid", "ystemName", "humanID", "ystemById", "systemID", " systemName", "localhostStart", "sysById", "sysId", "ystemIn", "systemName", "serverid", "humanIs", "systemIn", "humanDoes", "cmsStart", "publicid", "ystemID", "systemStart", "publicMid", "ystemIs", "serverById", "humanById", "cmsMid", "localhostMid", "systemDoes", " systemById", "publicById", "humanId", "localhostId", "serverId", "humanMid", "serverIn", "cmsId", "humanStart", "sysID"], "resolver": ["rsolution", "resolutionolver", "reserver", " reserver", "persolver", "reolver", "resolution", "reolving", "reolved", "resolve", "persolution", "resanger", "reolve", "resolving", "rsanger", " resolve", "resolved", "persolve", "reanger", "persolved", "perslove", " resanger", "resolutionlove", "reerver", "rserver", "rsolver", "persolving", " resolved", " resolution", "reolution", "resolutionolving", "resolutionolution", "reslove", "relove"], "source": ["series", "ser", "style", "site", "missing", "node", "init", "template", "instance", "se", "SOURCE", "peer", "force", "response", "attribute", "seed", "shell", "via", "proxy", "raw", "ource", "sql", "console", "local", "sample", "relation", "ce", "iterator", "from", "create", "subject", "uri", "channel", "resource", "spec", "Source", "scope", "parent", "component", "src", "store", "null", "inner", "rule", "reader", "unit", "cause", "service", "get", "sequence", "result", "remote", "base", "string", "input", "copy", "status", "object", "table", "file", "system", "sp", "target", "context", "origin", "storage", "image", "supp"], "stream": ["proc", "http", "window", "sync", "instance", "peer", "present", "complete", "export", "sw", "channel", "pipe", "content", "mount", "upload", "sequence", "form", "trans", "clean", "port", "file", "zip", "buffer", "progress", "response", "download", "row", "control", "ssl", "impl", "reader", "ream", "batch", "object", "stack", "chain", "data", "temp", "output", "our", "valid", "loop", "feed", "body", "pool", "iterator", "resource", "Stream", "pod", "null", "result", "input", "message", "load", "shape", "open", "hold", "socket", "console", "read", "sample", "test", "encrypted", "wrapper", "length", "REAM", "poll", "next", "cont", "log", "out", "cache"], "url": ["http", "mail", "ls", "location", "window", "term", "sl", "ret", "build", "bel", "link", "ur", "b", "ul", "Url", "f", "address", "URL", "rel", "ssl", "dl", "uri", "nl", "resource", "back", "browser", "gl", "ref", "key", "null", "mount", "ll", "external", "service", "l", "char", "rl", "job", "system", "web", "r", "hl"]}}
{"id1": "14168494", "id2": "17029388", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyByte", "CopyFile", "Copyfile", "CopyStream", " cpfile", " cpStream", " cpByte", " copyStream", " CopyStream", " Copyfile", " CopyByte", "CopyByte", " CopyFile", " copyfile", " cpFile"], "dest": ["st", "orig", "img", "pub", "des", "tmp", "del", "master", "to", "dir", "np", "loc", "v", "etc", "nt", "dist", "doc", "d", "nw", "w", "good", "www", "result", "Dest", "cont", "them", "source", "gt", "trans", "nom", "target", "origin", "out", "usr", "temp", "rest", "way"], "src": ["ser", "st", "ls", "init", "sl", "img", "sys", "rx", "sc", "rel", "rc", "desc", "from", "sel", "sub", "ins", "loc", "Source", "rs", "iv", "req", "upload", "sec", "cont", "sr", "source", "input", "file", "sb", "inst", "start", "usr", "sq", "cur"], "srcChannel": ["destChain", " srcchannel", " srcCommand", "srcChan", "sqPanel", "srcchannel", "sourceChan", "destMessage", " srcCh", "instCh", "sqChannel", "destChan", "instPanel", "sqCan", "bgChannel", " srcChan", "rcMessage", "rcChannel", "rcCommand", "srcCommand", "sourceCh", "bgCan", "bgChain", "sysCommand", "sysChan", "sourceChannel", "rcchannel", "rcChain", "instChain", "srcPanel", "rcChan", "srcCh", " srcMessage", "bgPanel", "destChannel", "srcMessage", "srcChain", " srcChain", "instChannel", "syschannel", "sysChannel", "sqChain", "srcCan", "instChan", "instCan"], "dstChannel": ["dbrChan", " dstCh", "pstButton", "dstChan", "dstCh", "ddestCh", " dstButton", "destClient", "dbrChannel", "destCommand", "pdestButton", "pdestCommand", "dndClient", " dotCh", " dotButton", "dstCommand", " dotChan", "ddestChannel", " dstChan", " dotHandler", "dotChannel", "dndButton", "ddestHandler", "dstClient", "dndChan", "ddestChan", "dbrCh", " dstHandler", "dndChannel", "dstHandler", "dndCh", " dotChannel", "dndCommand", "ddestButton", "pstClient", "destButton", "destChannel", "dstButton", "ddestClient", "ddestCommand", "pstCommand", "dotHandler", "dbrHandler", "dotButton", "pdestChannel", "pstChannel", "pdestClient", "dotCh", "dotChan"]}}
{"id1": "21425787", "id2": "6421904", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyByte", "CopyFile", "Copyfile", " copyFiles", "CopyFiles", "transferFile", "transferFiles", "copyFiles", "transferByte", "CopyByte", "copyByte", " copyfile", "copyfile", "transferfile"], "in": ["IN", "on", "din", "gin", "n", "it", "rin", "is", "ic", "ie", "vin", "b", "old", "o", "en", "inc", "from", "ind", "ins", "ar", "el", "up", "isin", "l", "In", "input", "source", "i", "inn", "inf", "cin"], "out": ["output", "n", "Out", "ent", "it", "b", "p", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "nt", "at", "g", "null", "str", "w", "l", "net", "err", "OUT", "source", "gt", "ne", "po", "i", "oss", "ot", "s", "c"], "sourceChannel": ["seedChannel", "srcChannel", "sourcePanel", "inputConnection", "srcChan", "systemPanel", "ourceChannel", " sourceClass", "sourceChan", "ourceCommand", "sourceClass", "ourceClass", "sourceCategory", "startChannel", " sourceManager", "seedPanel", "ourceConnection", "inputChan", "startCategory", "seedMachine", "sourceManager", "srcManager", "seedCategory", "inputCh", "sourceCh", "srcCommand", "startPanel", " sourceCommand", "ourceManager", "systemCategory", " sourceConnection", "sourceMachine", "ourceChan", "startMachine", "srcConnection", "srcCh", "srcClass", "systemChannel", " sourceChan", " sourceCh", "systemMachine", "sourceConnection", "inputChannel", "sourceCommand"], "destinationChannel": ["restinationChan", "destinatorChan", "destinationHandler", "destinatedChannel", "DestationChannel", "destensionChan", "DestinationHandler", "DestinationConnection", "destinoChannel", "destationConnection", "destinationsChan", "destationHandler", "Destationchannel", "destinatorHandler", "Destinationchannel", "DestinationChannel", "DestationChan", "DestensionConnection", "destinatedContext", "DestensionChan", "destinationsChannel", "destensionchannel", "destensionConnection", "restinochannel", "destinationchannel", "destinatedchannel", "Destensionchannel", "restinationchannel", "DestinationChan", "destinationContext", "destensionChannel", "destinochannel", "destinatorChannel", "destationChan", "destinoContext", "restinoChan", "restinoContext", "destationChannel", "destationContext", "destinationChan", "destinoChan", "DestationHandler", "destinationsConnection", "destinationschannel", "destationchannel", "DestensionChannel", "restinationChannel", "restinoChannel", "destinatedChan", "destinationConnection", "restinationContext", "destinatorchannel"]}}
{"id1": "12349563", "id2": "1097146", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceIsits", " resourceexistent", " resourceexisted", " resourceIsisted", " pathExits", " pathExisted", " pathexists", " resourceIsists", " resourceexists", " resourceExits", " pathexits", " resourceexits", " pathExists", " resourceExisted", " resourceIsistent", " pathexistent", " resourceExistent", " pathExistent", " pathexisted"], "location": ["path", "message", "history", "ion", "description", "window", "program", "template", "hello", "Location", "resolution", "human", "available", "connection", "zone", "address", "reference", "usage", "local", "area", "slot", "uri", "loc", "resource", "filename", "server", "translation", "library", "direction", "LOC", "where", "module", "name", "position", "family", "uration", "href", "directory", "remote", "command", "ocation", "string", "behavior", "point", "padding", "localhost", "file", "availability", "value", "zo", "system", "comment", "document", "country", "search", "layout", "color"], "url": ["out", "http", "mail", "con", "ls", "sl", "n", "open", "ret", "build", "pkg", "bel", "user", "b", "ur", "Url", "f", "address", "ul", "URL", "h", "pl", "ssl", "dl", "nl", "loc", "t", "client", "gl", "call", "google", "str", "mount", "ll", "l", "u", "char", "www", "base", "https", "cert", "cmd", "r", "res", "hl"], "cxn": ["Ctxnn", " cexN", " cxnor", "cwxns", "cxxns", "cxxnor", "Cxnn", "Cxns", "Cxn", "conN", "cexn", "cwxnn", "cwxN", "connn", "cexN", "CxN", "ctxn", "cxN", "ctxnor", "cxxN", "cxnor", " cxns", "conns", "cexnor", "cxxn", "Ctxn", "cwxn", "ctxnn", " cxN", "cexns", "CtxN", "conn", "cxns", "cxnn", " cexn", "Ctxns", "ctxns", " cexns", "ctxN", " cexnor"], "is": ["ims", "ists", "im", "ms", "ais", "isc", "abs", "es", "tis", "iso", "ris", "init", "dis", "ois", "sys", "isl", "has", "bis", "bs", "isa", "ires", "as", "its", "iss", "os", "does", "ys", "bits", "ps", "rs", "serv", "isf", "ts", "still", "si", "Is", "isin", "ir", "fs", "iris", "isi", "i", "oss", "ios", "info", "sis", "s", "in", "ip", "was", "lis", "IS"], "byteBuffer": [" byteWindow", "bufferWindow", "byteWindow", "binaryContext", "basicBuffer", "byteQueue", "binaryBuffer", "basicMatrix", "noteQueue", " byteMatrix", "byteFlow", "basicFlow", "basicQueue", "byteMatrix", "bufferSet", "noteMatrix", "noteFlow", "binaryWindow", " byteFlow", "bufferContext", "bufferBuffer", "byteSet", " byteQueue", "byteContext", "noteBuffer", " byteSet", "binarySet", " byteContext"]}}
{"id1": "8135072", "id2": "9479502", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"setImg": ["getIMg", "setIMg", "setImgs", "setIMgs", "setimg", "getImg", "setimG", "setimgn", "getIMgs", "getImgs", "setImageG", "setIMgn", "setImageg", "setimgs", "getIMgn", "setImG", "setImagegn", "setIMG", "setImgn", "getImgn", "getImG", "getIMG", "setImagegs"], "jFileChooser1": ["jFileSeose0", "jFileChoer4", "jFileComperOne", "jFileChoester2", "jFileChoickerOne", "jFileChoikerOne", "jFileChoerOne", "jFileSeose1", "jFileChicker1", "jFileChooser4", "jFileComposerOne", "jFileChooserFirst", "jFileComper1", "jFileCompicker1", "jFileChoister0", "jFileChoickerFirst", "jFileComposer2", "jFileChoester1", "jFileChoicker2", "jFileChooseOnce", "jFileChoicer1", "jFileChooserOne", "jFileSeoser1", "jFileChoose2", "jFileChoikerControl", "jFileChicker2", "jFileChoser2", "jFileChoose1", "jFileComposer1", "jFileChooserOnce", "jFileChickerOnce", "jFileChoserOnce", "jFileChoer1", "jFileChoicker1", "jFileChoister2", "jFileCompickerFirst", "jFileCompickerControl", "jFileSeoser2", "jFileChickerOne", "jFileComposerControl", "jFileChoose0", "jFileChoser1", "jFileSeoser0", "jFileComper4", "jFileCompickerOne", "jFileComposer4", "jFileChoikerFirst", "jFileChoserOne", "jFileChoickerOnce", "jFileChoicer2", "jFileChoicer4", "jFileChoickerControl", "jFileChopter1", "jFileChoister1", "jFileChooseOne", "jFileComposerFirst", "jFileSeose2", "jFileChopterOne", "jFileChoer2", "jFileChoiker1", "jFileChooserControl", "jFileChooser2", "jFileChopterFirst", "jFileComper2", "jFileChoose4", "jFileChopterControl", "jFileChoicerOne", "jFileChoester0", "jFileChoicerOnce", "jFileChooser0"], "separator": ["terminater", "semitter", "variate", "splater", "terminator", "generacer", "termininator", "generate", "separitter", "separativity", "generator", "semate", "splacer", " separinator", "collativity", "generater", "seator", " separATOR", "semator", " separigator", "seigator", "terminATOR", "seATOR", "separate", "splator", "variator", "separater", "separigator", "collator", "terminate", " separate", "variater", "generoder", " separater", " separacer", "seate", "separoder", "terminigator", "generATOR", "separATOR", "varioder", "semATOR", "collate", "separacer", "collATOR", "splATOR", "terminativity", "seinator", " separitter", "terminoder", " separativity", "separinator", "seitter"], "dirImg": ["DirIMig", "DirImg", "DirIMg", "dirIMge", "dirIfG", "dirIfig", "dirIfm", "DirIMgs", "dirImm", "dirIfg", "DirImG", "dirImge", "dirIG", "dirimig", "DirImgs", "DirIMic", "dirImgs", "folderIMg", "folderImG", "dirIgs", "folderIMG", "dirimg", "folderIMge", "DirImic", "folderImgs", "dirImvg", "dirIvg", "dirIfgs", "folderImg", "dirImG", "dirIMvg", "DirIMG", "dirImig", "dirimge", "dirIMgs", "dirIMg", "dirimG", "DirIMm", "dirimgs", "dirIMm", "folderImvg", "DirImm", "dirIMG", "dirIfic", "dirIg", "dirIMic", "dirimm", "folderIMgs", "dirImic", "DirImig", "folderIMvg", "dirIMig", "folderImge"], "index": ["second", "connect", "ion", "timeout", "add", "n", "open", "draw", "sign", "condition", "seed", "count", "address", "num", "test", "ind", "ex", "pos", "length", "exit", "all", "key", "sol", "IND", "Index", "number", "position", "level", "set", "point", "axis", "zero", "value", "match", "max", "i", "find", "info", "exp", "success", "height", "start", "diff"], "imgName": ["imgNo", "jpgname", " imgId", "jpgId", " imgname", "htmlPath", "imgname", "htmlName", "htmlNo", "jpgType", "jpgName", "imgId", " imgPath", "jpgNo", "animName", " imgNo", "animPath", "jpgPath", "htmlType", " imgType", "animname", "animId", "imgPath", "imgType"], "newPath": ["newsPath", "newUrl", "newPassword", "uniqueTh", "oldPart", " newName", "newPart", "oldTime", "newFormat", "newsTh", "newsPassword", "oldPassword", "newTime", " newFormat", "newTh", "validPath", "NEWPath", "newDir", "uniquePassword", "uniquePath", "oldDir", "newName", "oldTh", "validName", "NewUrl", "uniquePart", "newpath", "validUrl", "NEWDir", " newTime", " newUrl", "oldFormat", "NEWFormat", " newpath", "NewName", "newsPart", "validpath", "oldPath", " newDir", "NEWTime", "NewPath", "Newpath"], "inputFile": ["inputPlace", "inputPath", "saveFILE", "inputFILE", "outputFILE", "acceptPlace", "acceptFile", " inputfile", " inputPlace", " inputBe", "createFile", "inputStream", "createBe", "importStream", "importPlace", "inStream", "saveFile", "createfile", "importFile", "inFILE", "importPath", "inPlace", "saveStream", "inFile", "createPlace", "inPath", " inputStream", " inputPath", "outputStream", "inputfile", "acceptBe", "acceptfile", "inputBe"], "outputFile": ["displayFile", "inputDisk", "outputPage", "putFile", "putPage", "outputFormat", "newfile", "outputfile", "displayStream", "putModel", "outModel", "Outputfile", "outDisk", " outputStream", "outputDir", "inputDir", "newFile", "outPage", " outputBe", "outputDisk", " outputfile", "putDisk", "outfile", "outFormat", "outputBe", "OutputFile", "newStream", "OutputDir", "displayBe", "inputPage", "outputModel", "newBe", "inputModel", "displayfile", "outputStream", "inputFormat", "OutputFormat", "outDir", "outFile", "inputfile"], "in": ["IN", "per", "din", "con", "by", "init", "it", "ini", "rin", "is", "ic", "sin", "ain", "read", "en", "inc", "io", "from", "ind", "al", "ins", "ex", "ar", "el", "up", "bin", "inner", "isin", "In", "input", "source", "iter", "i", " din", "inn", "inside", "cin"], "out": ["output", "gr", "cos", "list", "on", "con", "n", "auto", "Out", "it", "dis", "sys", "put", "can", "o", "aos", "to", "os", "en", "end", "io", "OU", "help", "ex", "outs", "t", "v", "ou", "nt", "at", "write", "inner", "writer", "screen", "sum", "net", "OUT", "ne", "cn", "log", "co", "cmd", "outer", "cache"], "c": ["ch", "nc", "C", "cu", "n", "a", "uc", "mc", "ct", "f", "count", "q", "sc", "cut", "cd", "rc", "cat", "col", "ce", "cs", "ex", "t", "lc", "unc", "ac", "v", "cm", "cr", "e", "code", "cod", "ec", "d", "cp", "dc", "char", "u", "k", "go", "bc", "l", "cont", "r", "gc", "cl", "m", "cc", "max", "z", "i", "arc", "chain", "com"], "bckImg": ["bckIMge", "bckIMg", "bckIfg", "bckImn", "bckImgs", "bckIfgs", "bkgImgs", "bckIMgs", "bkgIMgs", "bckImge", "bckIfn", "bckimge", "bckIfge", "bckIMn", "bckimn", "bkgImg", "bckimgs", "bkgImge", "bkgIMge", "bkgImn", "bckimg", "bkgIMn", "bkgIMg"]}}
{"id1": "21348951", "id2": "5744992", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"processAddByURLSubmit": ["processAddByURlsubmit", "processAddByURlsummission", "processAddByURLSUBmission", "processAddByURLSubsmit", "processAddByURlsumit", "processAddByURLSummitted", "processAddByURlsummit", "processAddByURLSubit", "processAddByURLSUBit", "processAddByURLSubmitted", "processAddByURLSUBmitted", "processAddByURlsummitted", "processAddByURLSubsit", "processAddByURlsubit", "processAddByURLSubsmission", "processAddByURLSummission", "processAddByURLSubmission", "processAddByURlsubmitted", "processAddByURlsubmission", "processAddByURLSubsmitted", "processAddByURLSummit", "processAddByURLSumit", "processAddByURLSUBmit"], "url": ["path", "http", "mail", "html", "ls", "location", "addr", "sl", "force", "bel", "link", "item", "ur", "Url", "ul", "address", "q", "URL", "id", "util", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "use", "email", "browser", "ref", "run", "key", "name", "mount", "str", "impl", "ll", "external", "l", "char", "page", "u", "un", "base", "rect", "string", "input", "rl", "file", "web", "document"], "invalidUrlMsg": ["invalidUrStr", "invalidUrlLog", "inInvalidURLmsg", "invalidUrlStr", "inInvalidUrlLog", "inInvalidURLStr", "invalidFileMessage", "inInvalidStrMessage", "inInvalidUrlMessage", "invalidUrmsg", "invalidFileLog", "invalidUrMsg", "inInvalidStrStr", "invalidUrLog", "invalidURLmsg", "invalidFileStr", "invalidUrlMessage", "invalidUrlmsg", "inInvalidUrlStr", "invalidStrMsg", "invalidStrLog", "invalidURLMsg", "invalidurlmsg", "invalidFileMsg", "inInvalidStrMsg", "inInvalidUrlMsg", "invalidStrStr", "inInvalidURLMsg", "inInvalidUrlmsg", "invalidURLStr", "invalidUrMessage", "inInvalidStrLog", "invalidurlStr", "invalidStrMessage", "invalidurlMsg"], "xmlSourceWriter": ["xmlsourceWrite", " xmlSourceWrite", "xmlsourceBuilder", "xmlSourceFileWriter", "jsonSourceWriter", "xmlSourceWrite", "xmlSourceReader", "jsonSourceReader", "jsonSourceCode", "xmlsourceReader", "xmlStringCode", "xmlSourceFileRW", " xmlSourceBuilder", "xmlSourceWriting", " xmlSourceWriting", "xmlStringWriter", "xmlSourceRW", "xmlSourceCode", "xmlSourcesWriting", "jsonStringWriting", "xmlStringReader", "jsonStringCode", "jsonSourceWriting", "xmlsourceWriting", "xmlSourcesCode", "xmlSourceBuilder", " xmlSourceRW", "xmlSourcesReader", "xmlStringWriting", "xmlSourcesWriter", " xmlSourceReader", "xmlSourceFileWriting", "xmlsourceRW", "xmlSourceFileBuilder", "jsonStringWriter", "xmlsourceWriter", "jsonStringReader"]}}
{"id1": "17791385", "id2": "15645004", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpResource", "copyResource", " copyFiles", "cloneFile", " cpfile", "cloneResource", " copyResource", "clonefile", " cpFiles", "copyFiles", " copyfile", "copyfile", " cpFile", "cloneFiles"], "src": ["ser", "st", "init", "sys", "rx", "sin", "ck", "via", "bs", "sc", "rel", "rc", "sur", "sel", "ys", "from", "ins", "obs", "Source", "rs", "iv", "req", "ctr", "txt", "sec", "sit", "cont", "sr", "source", "input", "rl", "ipl", "sb", "ux", "inst", "usc", "start", "usr", "sf", "sq", "cur"], "dst": [" ddest", "wdest", "Dnd", "wnd", "wst", "ddst", "dddest", "dth", " dnd", "ddest", "Ddest", "ddnd", "Dst", "dnt", "snt", "Dnt", "snd", "dnd", "sdest", " dth", "ddnt", "sst", "wth", "Dth"], "in": ["IN", "on", "din", "con", "gin", "st", "im", "init", "ln", "it", "oin", "rin", "ai", "is", "ze", "ic", "rec", "sin", "ain", "en", "inc", "mm", "from", "ind", "al", "ins", "ar", "up", "bin", "inner", "isin", "In", "min", "input", "source", "iter", "i", "info", "inn", "act", "inside", "inf", "cin"], "out": ["output", "on", "con", "st", "by", "n", "auto", "Out", "it", "dis", "sys", "and", "can", "o", "aos", "to", "os", "io", "ex", "outs", "t", "client", "conv", "up", "bin", "ou", "nt", "oe", "at", "write", "g", "inner", "writer", "sum", "obj", "net", "OUT", "gt", "ne", "cn", "po", "oss", "ot", "co", "res", "outer"], "buf": ["buffer", "Buffer", "db", "block", "cur", "bed", "msg", "pkg", "var", "bar", "b", "ck", "aka", "bag", "Buff", "tab", "norm", "prop", "cat", "cv", "pl", "seq", "conv", "fb", "arr", "buff", "uf", "box", "bus", "vec", "cb", "cp", "bytes", "cam", "good", "batch", "tx", "cap", "mu", "log", "br", "bh", "stab", "cf", "cmd", "gen"], "len": ["ls", "lf", "vol", "n", "ln", "val", "lan", "count", "no", "rel", "h", "lon", "size", "en", "end", "num", "seq", "dl", "t", "pos", "loc", "el", "fin", "v", "lim", "length", "nt", "le", "cmp", "e", "all", "lic", "ld", "str", "ll", "fun", "fl", "Len", "l", "compl", "wid", "lib", "cap", "z", "exp", "L", "elt", "ren", "coll", "il"]}}
{"id1": "471804", "id2": "14619453", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoDateFix", "doVersionsCheck", "doLicenseUpdate", "DoVersionUpdate", "doVersionscheck", "doDateFix", "doDateUpdate", "doVersionsUpdate", "doLicenseFix", "DoVersionFix", "DoDateUpdate", "doDatecheck", "doVersionUpdate", "doLicenseCheck", "doVersionFix", "DoVersionCheck", "doDateCheck", "DoDatecheck", "doVersionsFix", "doLicensecheck", "doVersioncheck", "DoDateCheck", "DoVersioncheck"], "view": ["buffer", "http", "self", "update", "html", "window", "model", "block", "cell", "iew", "open", "controller", "manager", "see", "review", "q", "console", "util", "row", "cv", "views", "help", "VIEW", "subject", "client", "server", "v", "browser", "wrapper", "component", "call", "this", "tree", "doc", "index", "hl", "engine", "get", "page", "form", "eye", "print", "blade", "check", "input", "View", "tv", "file", "table", "show", "web", "document", "query", "display", "context", "layout", "out", "host", "widget", "image", "report"], "url": ["path", "http", "json", "html", "ls", "location", "sl", "org", "bel", "link", "b", "lb", "Url", "f", "address", "ur", "ul", "socket", "URL", "id", "rel", "github", "pl", "ssl", "uri", "dl", "nl", "loc", "client", "v", "browser", "gl", "null", "str", "mount", "ll", "l", "char", "string", "lr", "rl", "language", "file", "date", "log", "web", "oul", "r", "host", "hl"], "in": ["IN", " IN", "gin", "din", "asin", "init", "ln", "n", "rin", "is", "vin", "b", "sin", "f", "body", "ain", "inc", "ins", "inner", "reader", "stream", "isin", "l", "kin", "In", "input", "source", "file", "i", "mn", " din", "info", "inn", "out", "mat", "inf", "cin"], "bin": ["buffer", "cos", "binary", "din", "gin", "con", "by", "ln", "nb", "abin", "spin", "bed", "rin", "sin", "b", " Bin", "loader", "bn", "local", "bl", "ebin", "win", "pipe", "buff", "bur", "len", "bg", "inner", "bi", "mon", "reader", "stock", "lib", " bins", "conn", "mem", "obin", "file", "ran", "sam", " din", "inn", "out", "thin", "rb", "cache", "cin"], "line": ["path", "field", "style", "load", "text", "ide", "part", "ls", "cell", "lin", "block", "ln", "se", " Line", "section", "lo", "eline", "link", "lane", "body", "no", "state", "cat", "sample", "row", "col", "frame", "lines", "channel", "el", "liner", "le", "code", "inline", "ine", "store", "LINE", "ice", "one", "l", "level", "page", "char", "err", "record", "entry", "string", "base", "point", "print", "iter", "port", "file", "log", "job", "range", "comment", "chain", "trace", "cmd", "column", "word", "Line"], "version": ["update", "ion", "description", "iso", "volume", "type", "versions", "title", "Version", "major", "ver", "latest", "usage", "test", "feature", "client", "resource", "video", "spec", "v", "browser", "tag", "translation", "VERSION", "release", "river", "key", "vision", "name", "index", "number", "serial", "position", "scale", "virtual", "license", "sequence", "form", "VER", "command", "project", "string", "hash", "status", "date", "python", "value", "match", "vers", "language", "software", "info", "format", "image"], "build": ["style", "load", "binary", "builder", "db", "update", "bor", "add", "dev", "last", "link", "hold", "b", "built", "arch", "ver", "old", "latest", "make", "util", "test", "install", "use", "th", "tag", "fail", "ship", "release", "where", "be", "dist", "unit", "ward", "building", "other", "round", "lib", "print", "project", "struct", "hash", "date", "boost", "match", "log", "Build", "ble", "work", "full", "develop", "bug", "uild"]}}
{"id1": "1180878", "id2": "5148212", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fectURLStream", "fetchURLStream", "fetchStringStream", "fectUrlData", "fetchGETData", "fetchUrlFrame", "fetchGETFrame", "fectUrlFrame", "fectUrldata", "fectURLFrame", "fetchStringdata", "fetchURLFrame", "fectURLdata", "fetchStringFrame", "fetchStringData", "fetchUrlStream", "fetchGETdata", "fetchUrldata", "fetchGETStream", "fetchURLdata", "fectUrlStream", "fectURLData", "fetchUrlData"], "url": ["path", "http", "mail", "html", "ls", "location", "sl", "link", "ur", "b", "Url", "ul", "address", "URL", "sql", "rel", "pl", "default", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "lim", "gl", "ref", "null", "name", "mount", "xml", "ll", "l", "print", "base", "string", "cl", "file", "log", "domain", "https", "web", "full", "host", "pattern"], "proxyHost": ["roxyOver", "proxyAddress", "slavehost", " proxyCheck", "slaveLabel", "slaveAddress", " proxyAddress", "slaveOver", " proxyhost", "ProxyHost", "roxyCheck", "serverHost", "roxyhost", "slaveCheck", "proxyhost", "slaveHost", " proxyName", "serverhost", "slaveUrl", "proxyUrl", "roxyLabel", "ProxyName", "roxyHost", "ProxyLabel", "Proxyhost", "ProxyUrl", " proxyOver", "proxyOver", "proxyCheck", "roxyAddress", "serverPort", "proxyName", "roxyUrl", "serverName", "proxyLabel", "ProxyPort"], "proxyPort": [" proxyport", "proxyAddress", " proxyPORT", "aliasPort", " proxyAddress", "Proxyport", "ProxyHost", "proxyPORT", "serverHost", "serverport", "aliasAddress", "serverPORT", "serverAddress", "proxyport", "ProxyPORT", "aliasport", "serverPort", "aliasHost", "ProxyPort"], "con": ["bo", "nc", "proc", "cos", "ocon", "connect", "Con", "cone", "const", "close", "cond", "ln", "cal", "cover", "open", "com", "mc", "pan", "gate", "rec", "connection", "non", "ver", "ain", "can", "pen", "cat", "col", "en", "sub", "cs", "conv", "ex", "client", "fin", "xc", "lock", "fc", "syn", "call", "cgi", "canon", "cp", "cons", "fac", "comm", "don", "pc", "go", "bc", "un", "conn", "cont", "trans", "cn", "CON", "cc", "ran", "po", "ctrl", "func", "co", "mo", "cf", "cmd", "act", "conf", "dial", "Conn", "c", "cur"], "is": ["ist", "ims", "ists", "ains", "mis", "im", "ms", "isc", "ais", "abs", "init", "iso", "ris", "es", "dis", "ois", "ri", "sys", "isl", "has", "gets", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "ys", "xs", "are", "cs", "ins", "bits", "ps", "rs", "isf", "ts", "si", "Is", "isin", "fs", "iris", "isp", "iter", "us", "i", "oss", "ios", "s", "sis", "eps", "in", "ip", "was", "isi", "IS"], "u": ["U", " nu", "eu", "cu", "uni", "user", "pu", "ui", "ur", "ul", "tu", "iu", "su", "o", "au", "bu", "uri", "uj", "up", "ou", "uf", "uu", "g", "nu", "uv", "hu", "yu", "uid", "ue", "un", "c", "us", "fu", "mu", "ud", "i", "ut", "ru", "lu"], "proxy": ["bo", "http", "pointer", "cone", "password", "prime", "x", "ping", "timeout", "via", "link", " prox", "echo", "connection", "roxy", "xy", "Proxy", "embed", "address", "pin", " proxies", "pool", "token", "socket", "friend", "ssl", "pro", "map", "client", "pipe", "pse", "server", "browser", "translation", "XY", "slave", "pre", "library", "PRO", "null", "version", "cp", "aco", "phone", "shadow", "policy", "go", "pe", "base", "project", "gp", "port", "domain", "po", "profile", "web", "pi", "py", "https", "jp", "alias", "ip", "host", "cas", "cache", "zip"], "baos": ["naoss", "naows", "poose", "aoOS", " baoss", "BAOs", "vais", "bais", "BAows", "aooS", " bao", " baOs", "bao", "baOs", "vaOS", "aois", "baose", "baoS", " baoS", "naos", "baOS", "BAoss", " baose", "BAo", "vaoS", "poo", " baows", "baows", "aoos", "vaos", "nao", "poOs", "BAos", "baoss", " baOS", " bais", "poos", "BAose"]}}
{"id1": "14390569", "id2": "22625683", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"title": ["message", "text", "html", "description", "password", "prefix", "term", "notice", "template", "msg", "header", "type", "heading", "metadata", "holiday", "itle", "size", "subject", "help", "t", "filename", "setup", "content", "summary", " Title", "name", "label", "TIT", "parts", "details", "tip", "string", "padding", "theme", "hash", "lead", "layout", "start", "Title", "hd", "question"], "imageURL": ["imageUrl", "photoID", "photoString", "photoURL", " imageString", "mediaURI", "fileString", "ImageURL", "mediaURL", " imageUrl", "photoUR", "photoURI", "mediaID", "ImageURI", "imageUR", "ImageUrl", " imageURI", " imageUR", "fileURI", "fileURL", "mediaUrl", "ImageID", "imageURI", "photoUrl", "imageID", "ImageUR", "imageString", "fileUrl"], "jd": ["jobd", "ajds", "Jd", "simD", "jad", "zad", "Jmd", "jD", "javads", "kd", "djad", "JD", "jc", "ijd", "jsD", "Jbd", "jspd", "gds", "jsd", " jds", "gbd", "jds", "djc", "ajpd", "gdo", "qdo", "jsdm", "qds", " jdt", "jjd", "jjD", "ujD", "jjbd", "zd", "ijds", "ajd", " jc", " jad", "qD", "javapd", "jobdo", "jobdt", "javad", "kds", "ujmd", "kbd", "javadm", "qbd", "kdo", "djdo", "zsd", "Jds", "ujdt", "jjp", "Jp", "simd", "ijD", "djd", "Jdt", "Jc", "qd", "gd", " jdo", "Jdo", "jmd", "jdm", "ujad", "kdt", "jdo", "jdt", " jsd", "jpd", "ajdm", "jbd", " jD", "djds", "simmd", "simdt", "Jad", "djsd", "ujd", "qp", "jsds"], "jl": ["elt", "kel", "dyl", "jet", "j", "ln", " li", "elle", "isl", "ijk", "jj", "igl", "elly", "lp", "kj", " ol", "dj", "ja", "dl", "ibl", "nl", "uj", "yl", "bol", "js", "syn", "ji", "jin", "jc", "dll", "jac", "Label", "txt", "kl", "jah", "bj", "kn", "abl", "mil", "J", "ell", "rl", "ij", "gn", "li", "lv", "lu", "il"], "icon": [" lang", "iao", "fn", "ocon", " intent", " ion", " Icon", "ion", "iban", "con", " conn", "cil", " captcha", "icons", "font", "ICO", "ic", " ancestor", " widget", "pen", "ico", "conv", "nic", "ex", "png", "lock", "eric", "syn", "addon", "\u4e2d", "jc", "label", "icol", "Icon", " tip", "conn", "gc", " screen", "cn", "chron", "pic", " canvas", " fruit", "image", "fa"], "chooser": ["Choicer", " chooder", "comperer", "poose", " choose", "Choose", "composen", "CHOoser", "composer", "Chooder", " choerer", "compicer", " choosen", "poicer", "chooder", "choerer", "boerer", "booser", "pooser", "Choosen", "boose", "choicer", " choicer", "Chooser", "CHOicer", "CHOosen", "boosen", "compose", "choose", "pooder", "choosen", "CHOose"], "jp": [" je", "btn", " dj", "j", " gp", " pic", " cp", " pl", "bp", "p", "kj", " ip", "np", "ja", " sp", " joint", " mp", "js", "JP", " sip", "jc", "jin", " np", "bj", "pic", "sp", "ij", " ja", " ap"], "jb": ["jbd", " jbd", "kjbd", " jcb", "kjb", "Jcb", "qcb", "Jbd", "kjcb", "qb", "jcb", "qbd", "Jb"], "e": ["ev", "es", "or", "n", "it", "a", "te", "ie", "f", "p", "o", "en", "re", "ed", "er", "t", "ee", "v", "E", "g", "d", "w", "u", "event", "m", "s", "c", "Event"], "returnVal": ["getValid", "ReturnValue", "returnVol", "Returnval", "responseVAL", "getVol", "retValue", " returnVol", "returnValue", "returnval", "getVal", "returnValid", "responseVol", "returnVAL", "ReturnVal", "retval", " returnValue", "responseVal", "retVAL", " returnval", "ReturnVAL", "retVal", " returnVAL", " returnValid", "responseValid", "getVAL"], "file": ["path", "buffer", "real", "place", "http", "db", "word", "core", "model", "or", "valid", "open", "user", "fe", "type", "link", "class", "f", "body", "h", "to", "local", "fp", "dir", "io", "relation", "create", "File", "channel", "resource", "filename", "le", "library", "run", "tree", "be", "null", "rule", "name", "angle", "get", "page", "fs", "ile", "FILE", "base", "source", "drop", "status", "port", "table", "stat", "document", "foo", "target", "format", "full", "work", "info", "handle", "image", "report", "il"], "fileName": ["imagePath", "fileFace", "handlename", "FileSystem", "FILEPath", "imageName", "FileFace", "FileName", "fileClass", " fileSystem", "FileNAME", "ilename", "handleName", "Filename", "FileSet", "taskname", "ileNAME", "FilePath", "fileNames", "FILESystem", "imagename", " fileNames", "filename", "taskPath", "fileSet", "entityName", "handleClass", " filename", "FILEName", "FILESet", "entityNAME", "filePath", "FILENames", " filePath", "taskFace", "imageNAME", "taskName", "fileSystem", "entityPath", " fileClass", "ileName", "handleNAME", "FileExt", "FILEExt", " fileExt", "entitySet", "FileNames", "ileClass", "imageFace", "fileNAME", "FILENAME", "fileExt", " fileNAME"], "ext": ["part", "lex", "exe", "exc", "ct", "xt", "enc", "end", "dir", "test", "desc", "ind", "Ext", "ex", "t", "fr", "EXT", "sem", "typ", "ag", "xp", "vert", "hex", "req", "aux", "cod", "pat", "ec", "external", "ord", "txt", "lib", "cont", "eur", "def", "exp", "off", "cmd", "word", "prot", "ix", "len"], "i": ["j", "init", "phi", "it", "ini", "ai", "is", "ui", "iu", "id", "y", "fi", "mi", "ci", "ii", "qi", "gi", "hi", "ti", "bi", "index", "si", "I", "ei", "print", "m", "status", "xi", "ori", "di", "pi", "info", "cli", "li"], "doIt": ["diWhich", " doWhich", " doHe", "doneIt", "diHe", "odoIT", "waIT", "waIs", "didIs", " doIT", "odoIt", "donYou", "doWhich", " doYou", "doIT", "odoHe", "donIt", "doneit", "doYou", "doneIT", "donit", " doIs", "waIt", "didYou", " doit", "doIs", "odoWhich", "didit", "diit", "odoit", "doHe", "donIs", "didIt", "diIt", "doit", "donIT"], "src": ["ser", "http", "proc", "st", "sl", "init", "sys", "tmp", "rx", "lb", "gs", "ource", "crop", "sc", "rc", "rel", "from", "sub", "ssl", "conv", "ins", "loc", "rs", "syn", "rest", "comp", "rt", "ources", "inner", "impl", "ctr", "sh", "ptr", "sec", "cont", "sr", "source", "copy", "input", "rob", "rl", "trans", "sb", "https", "inst", "url", "start", "r", "usr", "sq", "rb"], "dest": ["output", "proc", "st", "est", "orig", "des", "sys", "tmp", "master", "can", "dat", "rel", "gest", "cat", "local", "dir", "coord", "desc", "pas", "loc", "pipe", "foreign", "slave", "dist", "cp", "nw", "pot", "Dest", "cont", "mem", "source", "trans", "iter", "nom", "port", "decl", "https", "target", "sp", "comb", "origin", "out", "usr", "temp", "rest", "way"]}}
{"id1": "3558512", "id2": "14598566", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"serialize": [" serialized", "initialization", "serialate", "Serialization", "finalize", "erialized", " serialate", "finalization", "serialze", "initialized", "initialze", "Serialate", "Serialize", "Serialized", "erialize", " serializer", "erialate", "initialize", "finalze", "Serialze", "Serializer", "serialization", "serialized", "serializer", "finalized", "erializer"], "out": ["output", "ch", "n", "Out", "it", "a", " OUT", "b", "f", "p", "pool", "o", "aos", "to", "os", "sw", "io", "OU", "outs", "t", "up", "v", "ou", "serv", "d", "w", "stream", "sum", "err", "result", "c", "OUT", "file", "log", "i", "res", "report"], "parser": ["style", "proc", "plan", "builder", "per", "part", "ger", "arser", "password", "now", "instance", "peer", "worker", "pkg", "jack", "tar", "processor", "tp", "manager", "rer", "loader", "p", "ker", "token", "util", "lp", "er", "asser", "Parser", "tree", "inner", "writer", "magic", "reader", "xml", "handler", "aser", "bank", "policy", "base", "command", "layer", "language", "file", "job", "parse", "walker", "format", "ler"], "on_disk": ["on_Disk", "On2file", "On_link", "on2file", "on_cloud", "on2link", " on_download", "on2disk", "on_volume", " on_volume", "On_Disk", "on_disc", "On_cloud", " on_Disk", "on_dis", " on_disc", " on_dis", "on_link", "On2link", "on_file", "on2Disk", "On2disk", "On2Disk", " on_file", "on_download", "On_disk", "On_file"], "in": ["IN", "on", "din", "gin", " IN", "it", "rin", "is", "vin", "and", "sin", "body", "ain", "id", "en", "inc", "io", "from", "mi", "ind", "ins", "bin", "inner", "isin", "r", "In", "min", "input", "i", " din", "inn", "inside", "inf", "ad", "cin"]}}
{"id1": "13886238", "id2": "4750967", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"init": ["load", "update", "ping", "save", " initialization", "open", "Init", " Init", " refresh", "reset", "download", "create", " initiate", "setup", "release", "version", "index", "get", "go", "gc", "base", " reset", "launch", "construct", "start", "rest"], "backupFile": ["backoreImage", "backoreStream", "Backipfile", "backakLog", "BackipLog", "BackipFile", "backipLog", "backopFile", "backoreFile", " backupImage", " backopFile", "backapFormat", "backusterFILE", "backipStream", "backupidfile", "backopImage", "backupidFormat", "Backupfile", " backopStream", "backopStream", "backupImage", "BackapFormat", "BackapFile", "backusterFormat", "backakfile", "backopfile", " backupfile", "backipLock", "backupLog", "backakLock", "backupidFile", "BackupLock", "backapFILE", "BackupLog", "backupidLog", " backupStream", "backupfile", "backipImage", "backupLock", "backapfile", "backupFormat", "backupidLock", " backopfile", "backapFile", "backusterfile", "BackapFILE", "BackupFILE", "backupidFILE", "backusterFile", "backupStream", "backupFILE", "backipFile", "BackupFormat", "BackupFile", " backopImage", "backorefile", "BackipLock", "Backapfile", "backakFile", "backipfile"], "buff": ["buffer", "printf", "bf", "binary", "text", "wind", "black", "nd", "cond", "buf", "font", "qq", "nb", "bed", "img", "msg", "hold", "b", "bis", "bm", "bs", "tab", "ob", "Buff", "end", "bl", "bound", "num", "bb", "ind", "fb", "bits", "bin", "lim", "ref", "uf", "emb", "bg", "butt", "comp", "null", "req", "pb", "xx", "cb", "bytes", "txt", "prof", "ff", "mem", "batch", "grow", "zero", "max", "uff", "xff", "append", "cmd", "tf"], "in": ["IN", "on", "din", "gin", "con", "im", "add", "it", "rin", "ri", "is", "ze", "ini", "mc", "ic", "ai", "ain", "body", "id", "o", "en", "inc", "io", "mm", "mi", "ind", "ex", "ins", "up", "bin", "inner", "get", "isin", "r", "l", "In", "conf", "input", "iter", "i", " din", "inn", "inside", "inf", "cin"], "out": ["output", "cos", "on", "ion", "con", "n", "auto", "Out", "sys", "can", "o", "aos", "to", "os", "end", "io", "OU", "conv", "outs", "ex", "op", "up", "v", "ou", "at", "write", "inner", "writer", "w", "one", "obj", "net", "conn", "OUT", "conf", "ne", "cn", "again", "i", "oss", "co", "full", "we", "outer", "res"], "read": ["buffer", "have", "load", "seek", "update", "shape", "add", "close", "bind", "take", "n", "open", "shift", "build", "Read", "hold", "count", "send", "old", "raw", "end", "scan", "size", "ok", "ind", "give", "READ", "pos", "length", "ready", "run", "write", " Read", "need", "next", "readable", "index", "reading", " write", "get", "stream", "tell", "before", "print", "mem", "check", "input", "copy", "iter", "pop", "skip", "max", "show", "find", "query", "scroll", "start", "remove", "push", "play", "reads", "len"], "reportWriter": ["reportManager", "repairWriting", "repairWriter", "detailHandler", "repairMember", "portWrite", " reportwriter", "createScope", " reportTimer", "serviceWriting", "repairManager", "reportWrite", "commentContent", "serviceApplication", "reportApplication", " reportApplication", "repairWrite", "reportwriter", "repairApplication", "repairScope", "reportHandler", "reportReader", "createWriter", "reportScope", "repairEntry", " reportManager", "repairContent", "reportEntry", "moduleMember", "reportTimer", "repairHandler", "portHandler", "detailWriter", "detailFile", "serviceWriter", "repairEditor", "summaryEditor", "repairTree", "commentWriting", "commentEngine", "xmlReader", "repairEngine", "commentWriter", "reportEditor", "listWrite", "portwriter", "summaryTimer", "portFile", "createwriter", "listWriter", " reportScope", "xmlWriter", "portReader", "xmlHandler", "reportPage", "summaryHandler", "reportFile", "portWriter", "reportEngine", "reportContent", "listPublisher", "detailReader", "reportPublisher", " reportTree", "repairTimer", " reportEngine", "createEntry", "summaryWriter", "xmlFile", "moduleWriter", " reportEntry", " reportEditor", " reportContent", "reportTree", " reportMember", " reportWriting", "repairPage", "moduleManager", "reportMember", "repairwriter", "portPublisher", "summaryWriting", "modulewriter", "repairPublisher", "summaryTree", " reportPage", " reportHandler", "listwriter", "servicePage", "reportWriting"], "restarting": ["restorting", "starteding", " restarted", " restorted", "restortating", "restartsing", "restrictinging", "restrictating", "restrupted", "startedating", "restartating", "restricted", "restortinging", "restruptbing", "restartedating", "restreatating", " restortinging", " restortating", " restorting", "started", "restartsating", "starteded", "restarteding", "restartbing", "restartsbing", "restricting", "restarteded", "startbing", " restartating", " restartinging", "restarted", "starting", "restartsed", "restruptating", "restreatinging", "startating", "startedbing", "restorted", "restrupting", "restreated", "restartedbing", "restreating", "restartinging"]}}
{"id1": "16079868", "id2": "9526031", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean register(Object o) {\n        String passwordAsText;\n        if (o == null) throw new IllegalArgumentException(\"object cannot be null\");\n        if (!(o instanceof User)) {\n            throw new IllegalArgumentException(\"passed argument is not an instance of the User class\");\n        }\n        User newUser = (User) o;\n        passwordAsText = newUser.getPassword();\n        newUser.setPassword(passwordEncoder.encodePassword(passwordAsText, null));\n        newUser.setRegDate(new Date());\n        logger.debug(\"Setting default Authority {} to new user!\", Authority.DEFAULT_NAME);\n        newUser.getAuthorities().add(super.find(Authority.class, 1));\n        logger.debug(\"Creating hash from email address! using Base64\");\n        newUser.setHash(new String(Base64.encodeBase64(newUser.getEmail().getBytes())));\n        logger.debug(\"Creating phpBB forum User, by calling URL: {}\", forumUrl);\n        try {\n            StringBuilder urlString = new StringBuilder(forumUrl);\n            urlString.append(\"phpBB.php?action=register\").append(\"&login=\").append(newUser.getLogin()).append(\"&password=\").append(passwordAsText).append(\"&email=\").append(newUser.getEmail());\n            sqlInjectionPreventer(urlString.toString());\n            logger.debug(\"Connecting to URL: {}\", urlString.toString());\n            URL url = new URL(urlString.toString());\n            URLConnection urlCon = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlCon.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) newUser.setForumID(Integer.valueOf(inputLine));\n            in.close();\n        } catch (IOException io) {\n            logger.error(\"Connecting failed! Msg: {}\", io.getMessage());\n            throw new RuntimeException(\"Couldn't conntect to phpBB\");\n        } catch (NumberFormatException e) {\n            logger.error(\"phpBB user generation failed! Msg: {}\", e.getMessage());\n            throw new RuntimeException(\"phpBB user generation failed!\");\n        }\n        entityManager.persist(newUser);\n        try {\n            sendConfirmationEmail(newUser);\n            return true;\n        } catch (MailException ex) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readIntoMenu", "readIntTolist", "readintintolist", "readIntToList", "readIntIntMap", "readIntIntlist", "readIntIntList", "readIntToMap", "readIntolist", "readintolist", "readIntToMenu", "readIntintolist", "readintoMap", "readintoMenu", "readintintoMenu", "readIntintoList", "readIntIntMenu", "readintintoList", "readIntoMap", "readintintoMap", "readIntintoMenu", "readIntintoMap", "readintoList"], "url": ["http", "mail", "location", "window", "hub", "open", "ret", "bel", "link", "ur", "b", "Url", "f", "address", "URL", "id", "mol", "from", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "browser", "ref", "name", "str", "xml", "mount", "ll", "l", "char", "rect", "string", "input", "file", "domain", "log", "web", "cert", "r", "image"], "list": ["collection", "out", "part", "top", "st", "add", "block", "n", "type", "is", "detail", "p", "state", "pool", "relation", "test", "rm", "map", "t", "lists", "v", "parent", "summary", "all", "tree", "module", "group", "name", "label", "view", "get", "l", "level", "only", "dict", "record", "print", "batch", "set", "m", "status", "port", "table", "show", "info", "format", "listed", "LIST", "cache", "network"], "in": ["out", "IN", "on", "din", "gin", "con", "add", "by", "val", "rin", "is", "ic", "and", "ill", "pin", "read", "en", "inc", "from", "re", "er", "ins", "up", "bin", "all", "inner", "doc", "reader", "get", "isin", "sum", "In", "line", "check", "input", "source", "file", "i", "mn", " din", "inn", "r", "conf", "inf", "cin"], "inputLine": [" inputBlock", "helloLINE", "latLINE", " inputLINE", "textLin", "contextLine", "nameLINE", "outputline", "httpL", "attLINE", "selectRow", "formBlock", "inputline", "httpLine", "nextLine", "nameLine", "InputLine", "selectText", "outputLine", "textL", "selectLine", "formline", "dataLine", "nameline", "commandLINE", "actline", " inputText", "htmlLINE", "formLine", "commandline", "inputLin", "htmlLine", "httpLin", "htmlline", "attLine", "inputText", "latLine", "actLine", "contextline", "formLINE", "htmlBlock", "inputLINE", "textLINE", "activeLine", "selectLINE", "helloLin", "InputBlock", "textLine", "contextLINE", "commandLine", "nextRow", "nextLINE", "inputL", "nameBlock", "helloL", "inputBlock", "inputRow", "httpLINE", "Inputline", "dataLINE", "actLINE", "activeLINE", "outputLINE", "helloLine", "nextText", " inputRow", "InputLINE", " inputline"], "commandNameBegin": ["commandnameMorning", "CommandNamesStart", "commandLinebegin", "commandFamilyBegin", "commandNamesStart", " commandOrderBegin", "commandLineBegin", "commandSizeBeg", "commandNameInitial", " commandNameBeg", "commandNAMEInitial", "commandNamebegin", "commandSizeEGIN", "commandNameBeg", "commandNAMEBeginning", " commandOrderStart", " commandOrderbegin", " commandNamebegin", "commandnamebegin", "commandTypeStart", "CommandNamesBegin", " commandNameEGIN", "commandNAMEBegin", "commandOrderBegin", " commandNameInitial", "commandLineStart", "commandNamesBegin", "commandnameBegin", "commandLineBeginning", " commandSizeBeg", " commandSizeEGIN", "CommandNamesbegin", "commandSizeBegin", "commandOrderStart", "commandTypeBeginning", "CommandNamesBeginning", "commandFamilyEGIN", "commandNameBeginning", "commandnameBeginning", "commandnameStart", "CommandNamebegin", " commandNameMon", "commandnameEGIN", "commandFamilyMorning", " commandNameMorning", " commandSizeMorning", "CommandNameBegin", "CommandNameStart", "commandNameMon", " commandNameBeginning", "commandOrderbegin", "commandFamilyMon", "commandTypeBegin", "commandNameEGIN", "commandNAMEMon", "commandTypebegin", "commandNameMorning", "commandNameStart", " commandNameStart", "commandFamilyInitial", "commandFamilyBeginning", "commandNamesbegin", "commandOrderBeginning", "CommandNameBeginning", "commandnameBeg", "commandNamesBeginning", " commandOrderBeginning", " commandSizeBegin", "commandFamilyBeg", "commandSizeMorning"], "commandNameEnd": ["commandStringEnd", "commandTypeStart", "formSizeend", "commandNameStart", "formSizeEnd", "commandSizeStart", "commandnameEnd", "commandLineEnd", " commandLineEnd", "formNameEND", "cmdTimeEnd", "formSizeEND", "commandTypeend", "commandNamesEND", "commandTimeEND", "commandNamesStart", "commandNamesEnd", "formNameStart", "commandTimeend", " commandNameStart", "commandTypeEnd", "formNameEnd", " commandLineEND", "commandNameEND", " commandNamesEND", "commandNamesBegin", "cmdTimeend", "commandSizeEnd", "commandStringStart", " commandNamesStart", "cmdNameend", " commandNameEND", "commandTypeEND", "commandNamesend", "commandStringBegin", "commandnameEND", "cmdNameEND", "cmdTimeEND", " commandLineend", "commandNameend", "formNameend", " commandNamesEnd", "commandLineEND", "commandTypeBegin", "formSizeStart", " commandNameend", "commandStringEND", " commandNamesBegin", "cmdNameEnd", "commandTimeEnd", "commandSizeend", "commandSizeEND", "commandLineend", "commandnameend"], "item": ["owner", "task", "im", "add", "or", "monitor", "template", "instance", "it", "member", "button", "menu", "type", "link", "mix", "bar", "title", "em", "p", "local", "row", "mm", "element", "Item", "items", "el", "tree", "this", "key", "inner", "module", "rule", "group", "label", "related", "index", "unit", "handler", "store", "article", "page", "obj", "hit", "event", "other", "command", "entry", "check", "base", "object", "m", "iter", "mem", "match", "i", "app", "sim", "option", "exp", "info", "li", "widget", "image", "question"], "e": ["ve", "ev", "eu", "es", "x", "n", "se", "ent", "a", "ef", "fe", "ie", "te", "ze", "b", "f", "et", "q", "p", "eg", "o", "h", "end", "eeee", "en", "ce", "re", "ed", "er", "ex", "t", "el", "ee", "v", "ea", "E", "le", "oe", "eb", "g", "be", "error", "ec", "d", "w", "ue", "l", "u", "ae", "one", "event", "err", "pe", "eur", "m", "ne", "i", "ge", "r", "c", "de"]}}
{"id1": "8490710", "id2": "21395184", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 1, "substitutes": {"actualizar": [" actualiser", " actualizeAR", " actualizAR", " actualizaAR", " actualizaar", " actualiziar", "ualizAR", " actualizer", " actualizeer", " actualizeiar", " actualisAR", " actualisiar", "ualizaiar", " actualizaiar", "ualizer", "ualizaer", "ualizaAR", " actualizear", " actualizaer", "ualizar", "ualiziar", " actualisar", "ualizaar"], "ClassNotFoundException": ["ClassNotfoundException", "ClassNotfoundError", "ClassNotPresentError", "ClassNotFoundError", "ClassNotPresentException"], "Exception": ["Instance", "T", "Connection", "Event", "None", "Example", "Message", "Handler", "File", "Time", "Exc", "Transaction", "Application", "Configuration", "E", " exception", "Un", "Class", "Status", "Index", "Warning", "Exit", "Throw", "I", "EX", "Response", "Type", "Null", "Ex", "End", "ION", "Operation", "ception", "Context", "Option", "Interface", "Error", "Result"], "conn": ["ch", "nc", "session", "connect", "Con", "db", "Connection", "con", "close", "init", "n", "config", "ln", "org", "open", "mc", "sys", "gate", "connection", "ont", "ct", "pg", "socket", "sc", "sql", "pool", "pen", "enc", "Connect", "ens", "en", "ws", "rc", "mt", "pas", "client", "yes", "rs", "js", "nt", "ns", "ks", "ec", "cp", "comm", "cb", " con", "exec", "obj", "yn", "ctx", "cn", "cc", "ann", "ctrl", "oss", "die", "cert", "jp", "cmd", "act", "conf", "Conn", "c"], "ms": ["Ms", "ims", "mos", "pm", "vs", "cus", "mes", "posts", "is", "mc", "sys", "uts", "ml", "bs", "inv", "ws", "qs", "ants", "os", "mm", "mi", "mt", "cms", "cs", "mx", "ys", "ces", "ma", "sm", "ins", "ps", "rs", "mys", "xs", "js", "eds", "ns", "mic", "ks", "terms", "ats", "mill", "mp", "fs", "md", "mod", "MS", "ems", "m", "uns", "mn", "arms", "s", "ents", "eps", "ocks", "pers", "res", "ts", "windows", "ies"], "fechaSystem": ["fechaeSys", "fochtaSTEM", "fochaSystem", "fechaeSTEM", "fetaSys", "fechiSystem", "fechoSTEM", "fechaeSystem", "fetisystem", "fechoaSystem", "fetaeSystem", "feshoSystem", "fechasystem", "fechlaSystem", "feshaServer", "fechiSys", "fetaSystem", "fechaSys", "fechtaServer", "fechtaSystem", "fechaServer", "fechaSTEM", "fochtaSystem", "fochaServer", "fechoasystem", "feshosystem", "fechisystem", "fetiSystem", "fechlasystem", "fechaesystem", "feshoServer", "fetasystem", "fechaeServer", "fetiSys", "fetaesystem", "fechoaSys", "fechlaSys", "fochtaServer", "fechoServer", "fechoSystem", "feshasystem", "fochaSTEM", "fetaeSys", "fechoSys", "fechoaServer", "fechtaSTEM", "feshaSystem", "fechosystem"], "aaaammdd": ["aaaammm", "aaaamldd", "aammdd", "aammd", "aaaaumdd", "aaammd", "aaammmd", "aaaamdd", "aaammds", "aaaammmm", "aaaammd", "aammmd", "aaaaammd", "aaaaammdd", "aaammdd", "aaaammmd", "aaaamlmm", "aaammmm", "aaaamd", "aammds", "aaaaumd", "aaaaamdd", "aaaamds", "aaaaummd", "aaaammds", "aaaaamd", "aaaaammm", "aaaaammmm", "aaaamld", "aaaaumds"], "fzafsis": ["fzeajsis", "fzeafses", "fzafesi", "fzamsis", "fzajses", "fzamsi", "fzajesi", "fzeajsi", "fzeafsi", "fzahses", "fzamesi", "fzahesi", "fzeafsis", "fzeafesi", "fzamses", "fzahsi", "fzajsi", "fzeajses", "fzafses", "fzeajesi", "fzafsi", "fzajsis"], "hhmmss": ["hhmmms", "hhmmmss", "hhmmess", "hhMMms", "hhMMse", "hhmmse", "hmmmse", "hhmbs", "HHmmss", "hhmmps", "hmmms", "hhmbess", "hhmmmess", "HHMMs", "hmmbs", "HHMMps", "hmmbess", "HHmms", "hhmmmse", "hhmmmps", "hhmbss", "hhMMss", "hhmbse", "hhmmmms", "hhMMps", "HHMMss", "hhms", "hhmms", "HHmmms", "hmmbss", "hhmss", "hhmps", "HHmmps", "HHMMms", "hmmbse", "hhMMs", "hhMMess", "hmmmess", "hmmmss"], "sss": ["essjs", "issl", "isses", "esss", "ssn", "ossjs", "ssjs", "isss", " ssjs", "ssss", " ssss", "essss", "rssss", "rssl", "ssl", "rsss", "osss", "essn", "essl", "ossn", "sses", "ossss", " ssn", "esses", "rsses", "issss"], "ss": ["SS", "ius", "rss", "sl", "se", "pps", "sd", "tt", "sys", "su", "bs", "sql", "ds", "hess", "stats", "ws", "iss", "ses", "hs", "css", "ys", "cs", "ssl", "lower", "pse", "ps", "rs", "styles", "js", "pass", "ns", "less", "\u00df", "str", "sh", "xx", "si", "ress", "ess", "txt", "good", "string", "tx", "pres", "ass", "sb", "oss", "https", "sv", "s", "tz", "ts", "sf", "sq"], "fzahsis": ["fizahorus", "fzaqsis", "fzaqsi", "fzaqorus", "fzabsis", "fzahses", "fzaforus", "fizahsis", "fizafses", "fizafsis", "fizafsi", "fzaqses", "fizaforus", "fzahsi", "fizahsi", "fizahses", "fzafses", "fzaborus", "fzahorus", "fzabses", "fzafsi", "fzabsi"], "afectados": ["afelectados", "affettados", "afectionarians", "afectionados", "affecturated", "afECTado", "affectado", "afECTurated", "affECTarians", "afettados", "affECTado", "afitectarians", "afettadas", "affectators", "afittulas", "afitecturated", "afitectado", "affECTados", "affectados", "afectadas", "afettators", "afelectulas", "afECTados", "afecturated", "afelectators", "afectulas", "affectarians", "afECTarians", "affECTurated", "affectulas", "afectionado", "afittados", "afectado", "afectators", "afitectados", "affettators", "afectarians", "afectionurated", "affettulas", "afittators", "afittadas", "afettulas", "affettadas", "affectadas", "afelectadas"]}}
{"id1": "18489832", "id2": "13207437", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 0, "substitutes": {"downLoadZippedFile": [" tryLoadXZipfile", " tryLoadZppedfile", " tryLoadXippedFile", " tryLoadZippedDir", " tryLoadXippedDir", " tryLoadZZipDir", " tryLoadZippedImage", " tryLoadXippedfile", " tryLoadZressedfile", " tryLoadZppedFile", " tryLoadXZipDir", " tryLoadZippedFile", " tryLoadZippedfile", " tryLoadZZipfile", " tryLoadZppedImage", " tryLoadZressedImage", " tryLoadZZipImage", " tryLoadZppedDir", " tryLoadZZipFile", " tryLoadZressedFile", " tryLoadXippedImage", " tryLoadZressedDir", " tryLoadXZipFile", " tryLoadXZipImage"], "url": ["http", "location", "sl", "open", "ret", "build", "link", "ur", "b", "ul", "Url", "address", "URL", "loader", "raw", "row", "ssl", "uri", "dl", "nl", "browser", "ref", "call", "request", "key", "str", "name", "mount", "xml", "ll", "external", "get", "l", "char", "err", "un", "base", "file", "log", "parse", "web", "https", "r"], "destDir": ["srcDIR", "originDir", " destDirectory", " destDIR", "destDIR", "targetFolder", "sourceDir", "srcFolder", "distDirectory", "sourceFolder", "srcFile", " destFolder", "originDirectory", "targetDIR", "targetDirectory", "destDirectory", "distFolder", "sourceDirectory", " destFile", "originDIR", "srcDir", "originFolder", "destFolder", "targetDir", "sourceFile", "srcDirectory", "distDir", "distDIR", "destFile"], "urlConnection": ["streamCompany", "urlDialog", "UrlDialog", "streamClient", "urlCompany", "URLCompany", "httpConnection", " urlDialog", "urlConnect", " urlLink", "streamConnector", "URLClient", "httpDialog", "httpConnect", "httpLink", "urlLink", "UrlLink", "UrlConnect", "urlConnector", "UrlConnection", "streamConnection", "URLConnection", " urlConnect", " urlClient", "urlClient", "URLConnector", " urlConnector", " urlCompany"], "tmpFile": ["tmpBe", "empView", " tmpPage", "tempDir", "tmpView", "tempChain", "empFilename", "tempTile", "mpFile", " tmpView", "cmpfile", "tmpPage", "mpfile", "destPage", " tmpfile", "tempView", "empTile", "thisFile", "tempPage", " tmpBe", "thisFilename", "tempBe", "thisChain", " tmpFilename", "tmpChain", "empFile", " tmpTile", "empDir", "tempFile", "destfile", "destBe", "tmpDir", "tempFilename", "tmpTile", "empfile", "thisfile", "empChain", "tmpFilename", "cmpFilename", "cmpFile", "cmpPage", " tmpDir", "tmpfile", "tempfile", "destFile"], "in": ["IN", "on", "din", "gin", "im", "con", "ains", "or", "st", "ln", "n", "it", "by", "oin", "ini", "rin", "is", "ze", "ie", "ai", "sin", "old", "ain", "as", "en", "inc", "from", "mi", "re", "ind", "al", "ins", "ma", "win", "up", "el", "bin", "pass", "all", "inner", "index", "none", "one", "isin", "l", "In", "input", "source", "iter", "i", "co", "info", "init", "query", "inn", "inside", "inf", "cin"], "out": ["output", "ch", "cos", "on", "con", "or", "n", "Out", "ent", "it", "sys", "tmp", "flush", "can", "no", "o", "aos", "to", "col", "os", "io", "OU", "note", "ex", "outs", "t", "client", "conv", "up", "v", "ou", "nt", "exit", "oe", "at", "write", "na", "null", "all", "writer", "external", "one", "obj", "net", "print", "OUT", "ne", "cn", "po", "oss", "co", "outer"], "localURL": ["publicURL", "LocalUrl", "LocalID", "LocalUR", "LocalURI", "localURI", "localhostID", " localID", "localLL", " localLL", "LocalLL", " localURI", " localUR", " localUL", "localhostUL", "publicURI", "publicUR", "localUL", "localID", "LocalUL", " localUrl", "localUR", "LocalURL", "publicUrl", "localUrl", "localhostLL", "localhostURL"]}}
{"id1": "15241397", "id2": "21425787", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "DoGET", "Doget", "doGET", "DoPut", "doget", "DoGet", "handleGet", "handlePut", "doPut", " doPut", "handleget", " doget"], "request": ["each", "message", "http", "application", "QUEST", "hello", "user", "attribute", "connection", "address", "reference", "complete", "reset", "create", "frame", "re", "client", "initial", "current", "server", "transform", "setup", "forward", "req", "quest", "get", "position", "command", "input", "Request", "the", "document", "query", "in", "start", "context", "report", "first", "question"], "response": ["output", "ve", "message", "http", "application", "site", "session", "json", "description", "block", "fire", "onse", "connection", "send", "body", "console", "reset", "ce", "frame", "respond", "answer", "resp", "resource", "server", "content", "exit", "write", "version", "next", "xml", "view", "service", "position", "page", "Response", "result", "sequence", "form", "print", "object", "status", "reply", "document", "success", "context", "res", "image", "report", "network"], "rewrittenQueryString": ["rewartedQueryStream", "rewrittenquerystring", "rewwrittenquerystring", "rewrittenURLString", "rewartedHeaderStr", "rewwrittenqueryStr", "rewartedHeaderStream", "rewliedqueryStr", "rewrittenQuerystring", "rewwrittenQueryStr", "rewrittenqueryStream", "rewrittenURLstring", "rewrittenQuStr", "rewwrittenQueryString", "rewrittenURLStr", "rewliedqueryStream", "rewwrittenqueryString", "rewartedQuerystring", "rewrittenHeaderString", "rewrittenRequestQuery", "rewartedQueryString", "rewrittenRequeststring", "rewrittenURLStream", "rewwrittenqueryQuery", "rewliedQueryString", "rewrittenHeaderStream", "rewartedHeaderstring", "rewrittenQuestionString", "rewliedqueryString", "rewrittenHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentQuery", "rewliedQueryStr", "rewrittenCurrentStr", "rewrittenHeaderStr", "rewrittenQueryQuery", "rewartedQueryStr", "rewrittenQueryStream", "rewrittenqueryQuery", "rewliedQueryStream", "rewrittenQuString", "rewrittenqueryStr", "rewrittenQuStream", "rewwrittenQuerystring", "rewartedHeaderString", "rewrittenQuestionStr", "rewrittenQueryStr", "rewrittenQustring", "rewrittenRequestString", "rewrittenCurrentstring", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenqueryString", "rewrittenRequestStr"], "rewrittenUrl": ["rewwrittenPort", "rewriddenURL", "rewroteLink", "RewwrittenString", "rewriteurl", "RewrittenUrl", "RewrittenPosition", "rewrownURL", "rewwrittenUrl", "rewrapedUrl", "rewittenURL", "RewrittenString", "rewroteUr", "RewwrittenLink", "Rewwrittenurl", "RewwrittenUrl", "rewartedPosition", "RewwrittenURL", "RewrittenUr", "rewedUrl", "rewrownUrl", "rewrapedURL", "RewwrittenPosition", "rewrittenPort", "rewrownUr", "rewroteurl", "rewrapedPort", "rewedString", "RewrittenPort", "rewriddenPosition", "rewrittenLink", "rewartedUrl", "rewrittenUr", "RewrittenLink", "rewittenUrl", "Rewrittenurl", "rewriteUrl", "rewriterString", "rewartedUr", "rewriterUr", "rewittenurl", "rewrownPosition", "rewwrittenUr", "rewadjustedUrl", "rewrittenString", "RewwrittenPort", "rewadjustedPort", "rewwrittenURL", "rewwrittenLink", "rewartedURL", "rewrotePosition", "rewwrittenPosition", "rewrittenurl", "rewedUr", "rewadjustedUr", "rewriddenUrl", "rewroteURL", "rewriteURL", "rewedURL", "rewriteUr", "rewadjustedURL", "rewwrittenString", "rewriterURL", "rewartedurl", "rewwrittenurl", "rewrapedUr", "rewrittenPosition", "rewittenLink", "rewriddenUr", "rewroteUrl", "RewrittenURL", "rewriterUrl", "rewrittenURL", "RewwrittenUr"], "httpURLConnection": ["HttpURLConnection", "httpURLConnect", "httpUrlApplication", "HttpURLConnect", "ttpURLConnect", "HttpHTTPConnect", "httpSRApplication", "httpHTTPConnect", "ttpUrlConnect", "ttpUrlConn", "ttpUrlApplication", "httpURLApplication", "httpFileConn", "httpURLConn", "ttpURLApplication", " httpUrlApplication", "httpUrlConfiguration", "HttpURLApplication", "httpMLConnect", "HttpHTTPConfiguration", "httpHTTPControl", "httpMLconnection", "httpUrlConnect", "ttpURLConnection", "httpHTTPconnection", "httpURLControl", "ttpUrlconnection", " httpUrlConnection", "ttpUrlControl", "httpRLConnect", "httpRLconnection", "httpFileConnection", " httpUrlconnection", "httpHTTPConn", "HttpUrlConnect", " httpUrlConnect", "httpURLconnection", "httpFileApplication", "httpHTTPConnection", "ttpURLConn", "HttpUrlconnection", "httpSRconnection", "httpURLConfiguration", "HttpHTTPConnection", "httpMLApplication", "ttpURLconnection", "httpMLConnection", " httpURLconnection", "httpSRConnect", "httpSRConnection", "ttpUrlConnection", "httpSRControl", " httpURLConnect", "httpUrlConnection", "httpHTTPConfiguration", "httpUrlconnection", "HttpURLconnection", "HttpUrlConnection", "httpHTTPApplication", " httpURLApplication", "HttpURLConfiguration", "ttpURLControl", "HttpHTTPconnection", "httpFileConnect", "httpRLConnection", "httpSRConfiguration", "httpUrlControl", "httpUrlConn", "HttpHTTPApplication", "httpRLApplication"], "header": ["field", "buffer", "dr", "part", "core", "term", "block", "init", "prefix", "head", "section", "user", "peer", "headers", "shift", "detail", "attribute", "heading", "metadata", "title", "zone", "filter", "address", "holder", "state", "token", "variable", "h", "relation", "er", "feature", "client", "argument", "wrapper", "tag", "component", "operator", "rule", "version", "handler", "hidden", "policy", "ter", "page", "event", "line", "meta", "check", "hash", "Header", "layer", "status", "padding", "device", "port", "comment", "option", "info", "query", "format", "column", "handle"], "value": ["field", "VALUE", "message", "expression", "text", "json", "description", "password", "save", "hello", "val", "instance", "des", "attribute", "zone", "see", "example", "property", "address", "sample", "create", "test", "default", "element", "current", "server", "v", "email", "content", "pair", "Value", "key", "version", "label", "name", "unit", "ue", "values", "vector", "sequence", "record", "entry", "string", "hash", "language", "python", "job", "comment", "sv", "data", "format"], "inputStream": ["InputStream", "outputSteam", " inputThread", "inputWindow", "inputstream", "inputView", "errorSteam", "errorWindow", " inputLoop", " inputSteam", "InputView", "InputLoop", "outputstream", "inputThread", "inputSteam", "outputView", "outputLoop", "outputThread", "inputLoop", "InputThread", " inputWindow", "errorstream", " inputstream", "errorStream", " inputView", "outputWindow"], "outputStream": ["outputSteam", "responseLength", " outputLength", "inputstream", " outputForm", "inputView", "displayView", "displaySteam", "displayStream", "OutputLength", "outputForm", "responseSteam", "outputstream", "OutputSteam", "responseStream", "outputLength", "inputSteam", "outputView", "displaystream", " outputstream", "OutputStream", "responseForm", " outputSteam", "OutputForm", " outputView"]}}
{"id1": "10361370", "id2": "23620712", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["message", "update", "html", "password", "Hash", "header", "sign", "attribute", "filter", "ashes", "h", "test", "tag", "code", "key", "version", "index", "sum", "crypt", "print", "check", "match", "profile", "render", "array", "handle", "ash"], "saltBefore": [" sALTAfter", " sALTStart", "sALTStart", "SALTBefore", "sALTBefore", " sALTBefore", "SaltPrevious", "saltStart", "saltPrevious", "sALTAfter", "sadePrevious", "sashStart", "saveBefore", "sadeStart", " saltStart", "SaltAfter", "sALTPrevious", "SALTAfter", "sashBefore", "SALTPrevious", "sadeBefore", "sadeAfter", "saveAfter", "sashAfter", "savePrevious", "SaltBefore"], "content": ["output", "path", "message", "Content", "expression", "text", "json", "reason", "html", "password", "description", "time", "config", "present", "example", "title", "body", "raw", "entity", "subject", "initial", "current", "translation", "code", "null", "any", "str", "xml", "txt", "license", "sequence", "cont", "record", "string", "source", "input", "object", "value", "file", "comment", "media", "document", "data", "format", "url", "word", "image", "c"], "saltAfter": ["vintBefore", "valtBody", "valtAfter", "SALTBefore", "sALTBefore", "soltAfter", "sALTafter", "sALTAfter", "saveBody", "valtBefore", "sALTBody", "sintBody", "saveBefore", "sintAfter", "sALTResult", "SaltAfter", "sALTPost", "soltPost", "soltResult", "SALTResult", "saveafter", "saltPost", "SALTPost", "SaltResult", "SALTAfter", "sadeResult", "vintAfter", "valtafter", "SaltPost", "sadePost", "vintBody", "sadeBefore", "sadeAfter", "sintafter", "saltBody", "saveAfter", "saltafter", "sintBefore", "soltBefore", "vintafter", "saltResult", "SaltBefore"], "repeatedHashingCount": ["repeatedHASHCount", "repeatedRashLength", "repeatedHashLength", "repeatedRashingLength", "repeatedRashesCounter", "repeatedRashingCounter", "repeatedHachingCount", "repeatedRashesCount", "repeatedHachingCC", "repeatedHashesCounter", "repeatedHashingcount", "repeatedHashingCode", "repeatedRashesLength", "repeatedRashCount", "repeatedHashCounter", "repeatedHashCode", "repeatedRashingCC", "repeatedRashingCode", "repeatedHachingCode", "repeatedHASHLength", "repeatedHashcount", "repeatedHashesLength", "repeatedHASHCounter", "repeatedHashCC", "repeatedHashingCC", "repeatedRashingcount", "repeatedRashingCount", "repeatedHashesCode", "repeatedHASHcount", "repeatedHashescount", "repeatedRashCode", "repeatedRashCC", "repeatedHashesCount", "repeatedHachingLength", "repeatedRashescount", "repeatedHashingLength", "repeatedHashCount", "repeatedHashingCounter", "repeatedHashesCC"], "digest": ["compest", "commse", "Digse", " digested", "designesting", "digum", " dighest", "designested", "printest", "printEST", " Digester", "debugEST", "Digests", "hashute", "dighash", "algEST", "hashest", "digse", "dest", "digEST", "Digested", "descity", "digert", "digester", "mdest", " digester", "debugest", "fifEST", "digitude", "debugitude", " digse", "digity", "Digester", "diagnum", "digesting", "descse", " digert", "designest", "dfesting", " digitude", "Digum", "hashhash", "algest", "descested", "DigEST", "argest", "descest", "diagnests", "comphash", "fingerest", "fingerEST", "printhest", "dfester", "fifest", "dester", "digute", " digency", " digests", "digested", "Digest", " Digert", "mdester", "extester", "printesting", "extse", "algester", "argEST", "dert", "digency", "extested", "Dighash", "mdested", "designester", "fingerhest", " digesting", "diagnest", " digum", "hashEST", "fifitude", "dfest", "Digute", " digist", "commested", "digist", "compEST", "fingeresting", "dse", " Digested", "argester", " Digest", " digEST", "dighest", " digity", "commity", "debugency", "fifency", "extest", "digests", "dfested", "argested", "Digist", "commest", "dested", "compute", "algested", "mdse", "diagnist"], "digestLength": ["descesterLen", " digesterLen", "digseLen", "digesterLength", "digselength", "descestLen", "digistData", " digestType", "digesterLen", " digestLen", "digestlength", " digesterLength", "descestlength", "descesterlength", "descesterLength", "digesterType", "digesterlength", "digesterData", "digestType", " digesterType", "descesterOffset", "descestLength", "digestedType", "digestedOffset", "digseLength", "digesterOffset", "digseOffset", "digistLength", "digestedlength", "digestLen", "digestOffset", "digestedLen", "digistType", "digistLen", "digestedData", " digestData", "descestOffset", " digesterData", "digestData", "digestedLength"], "i": ["multi", "im", "ms", "x", "init", "n", "phi", "j", "my", "it", "ini", "ai", "is", "ic", "ski", "ui", "me", "q", "iu", "sql", "y", "ci", "gu", "ind", "mi", "ex", "uri", "qi", "client", "ii", "v", "gi", "uu", "ti", "bi", "index", "mill", "si", "I", "u", "err", "print", "ei", "batch", "m", "iter", "xi", "cli", "iq", "z", "di", "sim", "pi", "in", "ip", "li", "ix"]}}
{"id1": "12066447", "id2": "3745402", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"truncate": ["trvalidize", "truncicate", "extvalidate", "trvalidation", "extuncation", "trculicate", "trvalidate", "trunate", "truncize", "trculation", "trunation", "trunize", "extvalidize", "trculate", "trvalidicate", "extuncize", "extvalidation", "extvalidicate", "truncation", "extuncicate", "extuncate", "trunicate", "trculize"], "file": ["path", "message", "word", "model", "or", "block", "time", "template", "user", "type", "link", "handle", "class", "attribute", "f", "local", "to", "fp", "dir", "create", "from", "frame", "io", "size", "use", "File", "files", "channel", "resource", "current", "filename", "spec", "lock", "parent", "le", "run", "e", "tree", "this", "be", "null", "module", "name", "get", "page", "ile", "event", "line", "base", "FILE", "source", "object", "port", "table", "log", "range", "info", "foo", "data", "full", "format", "work", "out", "image", "report", "zip"], "backupRoot": ["workupidDir", " backuproot", "BackupidFolder", "workupidBoot", "backumpRoot", " backupidroot", "workupidHome", "backuproot", "backupidBox", "backupDir", "backupidBoot", "backupsroot", "backumpDir", "BackupidRoot", "workuproot", "backupidRoot", "backureBoot", "backuperroot", "backupidFolder", "backdownFolder", "backureHome", "backupHome", "workupDir", "backureDir", "BackupRoot", "backureroot", "backupBoot", "backflowDir", " backupidBox", "backdownRoot", "backmproot", "backupsRoot", "backupidDir", "backupidHome", "backuperHome", "backmpRoot", " backupDir", "backumproot", "backupsDir", " backupBox", "backdownDir", "backupFolder", "workupHome", "backupidroot", "backupsBox", "workupidroot", "backmpBoot", "backmpDir", "workupBoot", "backflowRoot", " backupidDir", "backupBox", " backupidRoot", "BackupidDir", "backuperRoot", "workupRoot", "backuperDir", "backflowFolder", "BackupFolder", "workupidRoot", "backureRoot", "BackupDir", "backumpBox"], "df": ["dp", "dr", "bf", "db", "Def", "lf", "pdf", "dx", "sd", "f", "raf", "ds", "cd", "deb", "mm", "dm", "dt", "dep", "dl", "uf", " pdf", "du", "gd", "DF", "d", "dd", "dc", "dim", "fun", "NF", "md", "tif", "pd", "def", "tf", "di", "format", "fd", "cf", "hd", "sf"], "date": ["output", "message", "update", "save", "time", "now", "cal", "zone", "grade", "future", " Date", "dat", "duration", "create", "late", "frame", "down", "default", "dt", "note", "month", "dates", "resource", "Date", "tag", "content", "run", " day", "module", "name", "version", "due", "days", "dated", "day", "number", "get", "today", "sum", "event", "standard", "daily", "string", "value", "match", "range", "data", "format", "year", "age", "start", "ate", "when"], "zipFile": ["zipStore", "logPath", "jsonFile", "pdfPath", "ZipPath", "jsonfile", "zipStream", "ZipStream", "logfile", "logFilename", "pdffile", "jsonFilename", "pdfStream", "logFile", "zipfile", "zFile", "logStream", "ZipFile", "pdfFile", "zStore", "zipFilename", "zFilename", "zfile", "zipPath", "Zipfile", "jsonStore", "logStore"], "zos": ["asio", "cos", "sbm", "zen", "zi", "asar", "hz", "zik", "jas", "ss", "ze", "zan", "bs", "za", "zin", "ez", "hess", " sands", "rez", "ozo", "zers", "ses", "os", "zon", "css", "hs", "zag", "zes", "zzle", "estro", "ones", "webkit", "js", "enos", "sol", "zb", "bes", "eros", "esm", "enz", "cz", "stice", "south", "zer", "los", "shed", "sch", "z", "zo", "zar", "oss", "ros", "tz", "sis", "oses", "zona", "Sax", "nz"], "fis": ["sfiss", " fiss", "sfits", "cfis", "Fia", "if\u00eds", "fiis", "FIs", "ofis", "ofois", "ifIs", "Fisc", "fiiss", "fiois", "foIs", "dfier", "ofits", "cfisc", "cfits", "lIs", "fib", "sfisc", "F\u00eds", "fiss", "f\u00eds", "Fis", "sfIs", "fi", "fier", "dfis", "foia", "Fiss", "foi", "lia", "efis", "ifis", "dfiss", "efisc", "efIs", "cfiss", " fib", "fits", "fIs", "ifisc", "fiib", "Fier", "dfIs", "fisc", "Fi", "ofib", " fois", "fois", "ofiss", "ef\u00eds", "fia", "li", "sfier", "ofisc", "sfis", "lis"], "entry": ["ment", "ion", "description", "cell", "add", "tex", "internal", "or", "cue", "rance", "member", "ent", "section", "se", "ie", "and", "attribute", "connection", "sheet", "ary", "entity", "ry", "row", "ce", "element", "resource", "deep", "e", "delete", "key", "office", "xml", "ace", "char", "obj", "event", "record", "command", "object", "set", "def", "comment", "zo", "escape", "option", "data", "search", "Entry", "insert", "word", "de", "zip"], "buffer": ["message", "Buffer", "binary", "window", "block", "phrase", "buf", "template", "volume", "button", "header", "available", "bar", "attribute", "variable", "sample", "letter", "queue", "frame", "buff", "category", "length", "library", "code", "view", "screen", "char", "page", "sequence", "command", "batch", "base", "padding", "iter", "table", "zero", "comment", "stack", "document", "memory", "paste", "append", "word", "temp", "cache"], "readed": ["findared", "readd", "counted", "counter", "indexED", "countd", "ReadED", "READd", "readableared", "finded", " readED", "readED", "readeded", "rededed", "readableED", "findied", "Readd", "READed", "reded", "redented", "readented", "reader", "readared", " readeded", "Reader", "readableied", "redED", "readableed", "Readed", "indexented", "indexeded", "countED", "indexed", "READED", "Readared", "Readied", "findED", "READer", " readented", "readied"]}}
{"id1": "13439950", "id2": "18962382", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["readLocalFile", "downloadStaticFile", "readRemoteRemote", "readremoteRemote", "readremoteFrom", "downloadRemoteFrom", "downloadStaticRemote", "readStaticFrom", "readremoteFile", "downloadStaticFilename", "readremoteFilename", "downloadStaticFrom", "readStaticFile", "readLocalRemote", "readRemoteFrom", "readLocalFilename", "readLocalFrom", "downloadRemoteRemote", "readStaticFilename", "readRemoteFilename", "readStaticRemote", "downloadRemoteFilename", "downloadRemoteFile"], "response": ["output", "message", "application", "json", "description", "block", "resolution", "onse", "example", "connection", "secret", "address", "body", "send", "reset", "sample", "relation", "answer", "resp", "server", "continue", "summary", "settings", "request", "version", "next", "view", "str", "service", "respons", "vector", "Response", "result", "sequence", "line", "command", "print", "string", "source", "status", "value", "reply", "data", "format", "res", "image", "report", "cache", "network"], "url": ["http", "mail", "abs", "sl", "ret", "build", "bel", "link", "ur", "lb", "Url", "b", "ul", "URL", "rel", "pl", "ssl", "dl", "uri", "nl", "loc", "resource", "el", "browser", "gl", "ref", "name", "mount", "str", "ll", "fl", "l", "char", "base", "lr", "rl", "https", "web", "cmd", "r", "hl"], "is": ["ists", "ais", "ms", "es", "isc", "ates", "iso", "ris", "it", "sels", "ri", "ic", "sys", "isl", "nis", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "does", " Is", "ins", "rs", "serv", "isf", "\u00eds", "Is", "ir", "fs", "iris", "i", "ios", "sis", "in", "ip", "isi", "IS"], "br": ["wr", "gr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "ver", "bm", "bs", "BR", "rel", "bn", "bl", "hr", "pr", "nr", "fr", "bt", "browser", "Br", "cr", "bro", "be", "bi", "str", "vr", "mr", "tr", "bridge", "bc", "lr", "rob", "adr", "ro", "bh", "sp", "jp", "ber", "res", "r", "repl", "rb"], "s": ["series", "strings", "ms", "es", "ls", "stats", "j", "n", "se", "a", "gets", "b", "sq", "gs", "bs", " gets", "ss", "p", "y", "its", "h", "os", "o", "qs", "sample", "ins", "t", "sym", "ps", "rs", "v", "js", "e", "ns", "less", "sports", "g", "str", "sts", "ats", "still", "w", "sql", "l", "r", "txt", "ves", "sn", "string", "m", "value", "csv", "z", "i", "sb", "tes", " ts", " samples", " inputs", "sv", "res", "ts", "S", "ies", "single"], "eof": ["eeol", "eeef", "eow", " eol", "seof", "Eov", "eov", "eot", "ef", " eow", "Eomp", "seef", "Eol", "eeif", " eef", " eos", "Eof", "eeow", "eef", " eomp", "eeot", " eot", "geif", "eeov", "EOf", " eOF", "eOf", "sef", "eOF", "eeOf", "eif", "eeOF", "Eef", " ef", "eomp", " eif", "seot", " eov", "eeos", "geow", "eeomp", "geOF", " eOf", "geof", "eeof", "eol", "Eos", "eos"]}}
{"id1": "21979462", "id2": "21642215", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURL2Text", " downloadURLToBytes", " downloadURLoString", " downloadURLToString", " downloadURLoBytes", " downloadURLtoText", " downloadURLToText", " downloadURL2String", " downloadurloString", " downloadURLoJSON", " downloadURLToJSON", " downloadurloJSON", " downloadURLtoJSON", " downloadURLtoBytes", " downloadurloText", " downloadurltoText", " downloadURL2Bytes", " downloadurloBytes", " downloadURL2JSON", " downloadURLoText", " downloadurltoString", " downloadurltoBytes", " downloadurltoJSON"], "url": ["http", "mail", "ls", "location", "sl", "ret", "bel", "link", "ur", "ul", "Url", "address", "URL", "id", "ssl", "uri", "dl", "resource", "browser", "gl", "ref", "run", "uu", "all", "mount", "name", "ll", "l", "char", "un", "rect", "base", "file", "log", "job", "domain", "web"], "in": ["IN", "on", "din", "gin", "con", "or", "by", "it", "oin", "ai", "is", "mc", "ic", "and", "ill", "read", "inc", "io", "from", "re", "ind", "er", "ins", "al", "ma", "up", "bin", "all", "inner", "reader", "isin", "sum", "In", "check", "input", "copy", "again", "i", "mn", "info", "inn", "out", "conf", "thin", "inf", "cin"], "sb": ["ub", "bf", "db", "nb", "SB", "sd", "bd", "b", "lb", "bp", "bis", "bs", "lp", "kb", "bsp", "bn", "pa", "sa", "bb", "erb", "ssl", "bt", "ab", "eb", "bg", "xb", "pb", "ib", "zb", "mb", "cb", "gb", "wb", "sg", "gc", "bj", "rob", "sam", "bh", "sp", "gob", "sk", "sf", "sq", "rb"], "str": ["ch", "gr", "dr", "text", "part", "st", "ls", "vol", "block", "j", "n", "sl", "msg", "b", "del", "p", "dat", "cat", "bl", "re", "t", "arr", "fr", "pt", "syn", "comp", "req", "sts", "STR", "next", "comm", "char", "l", "txt", "obj", "err", "bc", "tr", "print", "cont", "string", "source", "def", "m", "expr", "set", "iter", "i", "comment", "sp", "chain", "br", "s", "div", "r", "Str", "exec", "list", "cur"]}}
{"id1": "21491791", "id2": "22046596", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"run": ["runner", "eval", "apply", "runs", "Run", "su", "execute", "test", "use", "par", "call", "pre", "exit", "running", "process", "name", "unit", "fun", "don", "un", "command", "system", "work", "cmd", "exec"], "input": ["history", "http", "text", "json", "internal", "hello", "config", "it", "hub", "feed", "address", "state", "read", "local", "io", "from", "Input", "client", "initial", "back", "request", "inner", "background", "xml", "readable", "index", "view", "stream", "upload", "form", "cont", "print", "partial", "before", "source", "action", "iter", "select", "file", "active", "table", "parse", "system", "info", "data", " inputs", "context", "in", "audio", "out", "start", "image"], "output": ["binary", "text", "update", "block", "config", "Output", "header", "four", "response", "put", "connection", "latest", "console", "o", "export", "generated", "io", "ilo", "filename", "ou", "exit", "oe", "write", "external", "stream", "hidden", "net", "you", "result", "print", "directory", "command", "source", "port", "table", "file", "log", "web", "target", "admin", "data", "display", "format", "success", "column", "memory", "out", "outer", "image", "network"], "reader": ["proc", "dr", "builder", "owner", "window", "rar", "penter", "worker", "draw", "controller", "rx", "manager", "loader", "parser", "read", "row", "iterator", "er", "client", "resource", "rw", "wrapper", "inner", "readable", "reading", "handler", "stream", "ter", "Reader", "entry", "iter", "table", "file", "driver", "ro", "system", "data", "context", "in", "r", "usr"], "writer": ["ser", "builder", "word", "adder", "window", "close", "penter", "caster", "worker", "draw", "handle", "connection", "processor", "manager", "holder", "wrote", "riter", "loader", "writers", "variable", "writing", "iterator", "writ", "creator", "client", "yard", "pipe", "server", "rw", "wrapper", "widget", "write", "store", "wire", "written", "handler", "println", "w", "service", "player", "ter", "Writer", "file", "driver", "target", "out", "outer", "storage", "network"], "pump": ["PUMP", " pmp", "psumper", "deter", "pmp", " pong", "Podge", " peter", "camp", " podge", "cump", "peump", " pUMP", " pipe", "podge", " pumper", "dumper", "pemp", "Pump", " pamp", "pamp", "prong", "pipe", "psump", "peter", "Pumps", "Pumper", "prump", "pUMP", "pripe", "pumper", "prodge", "cumper", "pumps", "cUMP", "damp", " pumps", "dump", "peumper", "peumps", "Pong", "pong", "Pamp", "psipe", "Pipe", "psamp", "Peter", "Pmp"], "counter": ["collection", "second", "cell", "term", "peer", "controller", "currency", "processor", "count", "card", "created", "timer", "parent", "code", "inner", "sequence", "random", "const", "description", "book", "condition", "Counter", "row", "conv", "scope", "continue", "radius", "container", "ter", "batch", "entry", "comment", "memory", "column", "outer", "pointer", "phrase", "loop", "ounter", "loader", "buster", "client", "current", "clock", "index", "page", "vector", "unique", "amount", "hash", "seen", "system", "walker", "message", "history", "time", "console", "common", "frequency", "encrypted", "total", "key", "responsible", "ctr", "recorded", "number", "thread", "record", "zero", "cookie", "context", "average"], "buffer": ["message", "Buffer", "binary", "text", "block", "phrase", "buf", "header", "b", "address", "row", "size", "queue", "buff", "length", "uf", "key", "bytes", "vector", "sequence", "result", "base", "batch", "command", "source", "table", "value", "uffer", "document", "data", "context"], "off": ["offset", "now", "shift", " Off", "after", "no", "end", "att", " OFF", "pos", "op", "offer", "aff", "OFF", "Offset", "hand", "oa", "ow", "ap", "fun", "Off", "before", "ff", "offs", "un", "set", "def", "oct", "eff", "of", " offset", "origin", "art", "cmd", "ip"], "len": ["bf", "offset", "ls", "vol", "lf", "cond", "ln", "buf", "val", "del", "lan", "body", "mult", "lp", "rel", "enc", "lon", "end", "en", "size", "lvl", "pos", "nl", "length", "le", "all", "ld", "alt", "ll", "vec", "fun", "fl", "written", "bytes", "Len", "l", "compl", "lib", "kl", "line", "mem", "cl", "pent", "wl", "eff", "elt", "fin", "mat", "coll"], "rd": ["udd", "dr", "rh", "nd", "R", "sd", "ri", "bd", "rid", "rod", "cd", "rc", "ard", "rez", "hr", "ind", "red", "rand", "rs", "rw", "cr", "rt", "ld", "dd", "d", "mr", "ptr", "md", "rr", "dig", "sr", "lr", "ird", "adr", "rn", "rl", "mn", "RD", "xd", "r", "dra", "rb"]}}
{"id1": "20028790", "id2": "20660203", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleInfoNames", "setBundleFileNames", "setBundleDataTitle", "setBundleInfLabel", "setBundleDataLabel", "setBundleInfTitle", "setBundleFileName", "setBundleDataNames", "setBundleInfoTitle", "setBundleFileLabel", "setBundleInfNames", "setBundleFileTitle", "setBundleDataName", "setBundleInfoLabel", "setBundleInfName"], "location": ["path", "message", "history", "description", "program", "template", "Location", "address", "reference", "local", "area", "uri", "loc", "resource", "filename", "translation", "library", "LOC", "where", "name", "position", "l", "directory", "remote", "command", "ocation", "localhost", "point", "language", "availability", "comment", "document", "country", "layout", "color"], "list": ["collection", "ist", "out", "missing", "add", "block", "n", "detail", "p", "pool", "local", "dl", "map", "lists", "spec", "v", "all", "name", "l", "level", "sequence", "net", "print", "batch", "set", "m", "status", "table", "chain", "stack", "listed", "L", "LIST"], "url": ["http", "mail", "html", "abs", "sl", "open", "build", "bel", "link", "ur", "lb", "Url", "b", "f", "ul", "URL", "rel", "pl", "ssl", "dl", "uri", "nl", "loc", "el", "browser", "ref", "google", "str", "mount", "ll", "gb", "l", "char", "base", "lr", "rl", "job", "sb", "r", "hl"], "br": ["ch", "wr", "gr", "dr", "buf", "bd", "b", "bp", "bs", "BR", "rel", "read", "bl", "hr", "pr", "er", "nl", "fr", "bt", "browser", "Br", "cr", "bro", "be", "str", "next", "gb", "mr", "tr", "bridge", "sr", "lr", "bh", "kr", "div", "ber", "r", "rb"], "line": ["buffer", "message", "style", "text", "part", "cell", "block", "lin", "phrase", "ln", "se", "lo", "header", "eline", "link", "detail", "piece", "body", "sql", "row", "sample", "frame", "note", "linux", "stay", "nl", "liner", "lock", "le", "code", "inline", "ine", "store", "rule", "name", "next", "label", "LINE", "l", "online", "page", "char", "sequence", "record", "entry", "string", "source", "point", "print", "iter", "log", "comment", "chain", "data", "trace", "handle", "word", "Line"], "pos1": ["Pos0", "position3", "pos2", "PosOne", "pos0", "POS1", "poOne", " posOne", "index1", "Pos1", "posOne", "poone", " pos2", "Pos2", "position2", "POS0", "po1", "pos3", "po3", "positionone", "position0", "indexOne", "indexone", "POSOne", "posone", "index3", "POS2", "position1", " pos0", "positionOne"], "bundleSymbolicName": ["bundleSymbolicalName", "bundleSymbicNames", "bundleSymbololicFamily", "bundleSymbolicType", "bundleSyMBolicNames", "bundleSyMBolicCode", "bundleSyMBolicName", "bundleSymboryType", "bundleSyMBicalCode", "bundleSymbicalCode", "bundleSymbicalType", "bundleSyMBicalNames", "bundleSymboryVersion", "bundleSymbolicalType", "bundleSymbularFamily", "bundleSymboryName", "bundleSymbularNames", "bundleSymbularName", "bundleSyMBolicVersion", "bundleSymbolicNames", "bundleSymbicalname", "bundleSymbularname", "bundleSyMBicalname", "bundleSymbolicVersion", "bundleSymbicCode", "bundleSymbicalNames", "bundleSyMBolicType", "bundleSymbololicType", "bundleSymboryNames", "bundleSyMBicalVersion", "bundleSymbicalVersion", "bundleSymbololicNames", "bundleSymboryCode", "bundleSymbolicFamily", "bundleSyMBolicname", "bundleSyMBicalType", "bundleSymbolicalFamily", "bundleSymbicVersion", "bundleSyMBicalName", "bundleSymbolicCode", "bundleSymboryname", "bundleSymbicalFamily", "bundleSymbicalName", "bundleSymbicName", "bundleSymbolicname", "bundleSymbolicalNames", "bundleSymbularType", "bundleSymbololicName"], "bundleName": ["bundleType", "baleName", "bowerVersion", "branchName", " banchname", "fasketVersion", "fundleName", "basketType", "bowerType", "balename", "bowername", "bowerName", "fasketType", "baleVersion", "bachmentInfo", " banchName", " bundlename", "bachmentName", "brundleInfo", "basketName", "brundleString", " banchInfo", "basketname", "banchname", "banchString", "bundleString", "basketVersion", "bundleVersion", "brundlename", "banchInfo", "fundleVersion", "bundleInfo", "bachmentname", "baleType", "fasketname", "fundleType", "bowerString", "fasketName", "fundlename", "branchString", "banchName", "bowerInfo", "baleInfo", "brundleName", " bundleInfo", "bundlename", "branchname", "branchInfo"], "info": ["history", "http", "self", "update", "json", "block", "iso", "instance", "now", "dev", "user", "fo", "te", "ext", "detail", "item", "me", "f", "state", "local", "note", "INFO", "fit", "summary", "all", "inner", "error", "index", "obj", "event", "details", "entry", "check", "tip", "def", "status", "iter", "information", "value", "match", "job", "tf", "i", "comment", "Info", "data", "query", "context", "alias", "conf", "image", "report", "inf"]}}
{"id1": "6988216", "id2": "13063241", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" executeSimpleContent", " testRawQuestion", " testQueryQuery", " executeSimpleQuestion", " executeBasicQuestion", " testSimpleQ", " testQueryContent", " testBasicQ", " testSimpleQuestion", " testBasicQuestion", " testBasicQuery", " testQueryQ", " testQueryQuestion", " executeBasicQ", " testBasicContent", " executeBasicQuery", " executeBasicContent", " testSimpleContent", " testRawQ", " testRawContent", " executeSimpleQ", " executeSimpleQuery", " testRawQuery"], "dummySource": ["udeterminedParent", "daatumResource", "dummyFile", " duffySourceFile", "udummyFile", "daatumInput", "daummyInput", " duffySource", "dummSource", "dummSourceFile", "udummyContent", "dumpStore", "daatumStore", "daatumSource", "dumpInput", "dummiesSource", "dummiesInput", "udeterminedSource", "datumResource", "dummyResource", "dummInput", "dancyFile", "datumInput", "dummyParent", "dumpSource", "udeterminedFile", "datalFile", "dummySourceFile", "duffySource", "duffySourceFile", "daummySource", "dummiesResource", "datalSource", "udummyParent", "datalContent", "dancySource", "dancyContent", "dancySourceFile", " dummyInput", "udummySource", "duffyInput", "determinedParent", "datumSource", "dummyStore", "determinedFile", "udeterminedContent", "determinedContent", "daummyResource", " duffyInput", "determinedSource", "dumpResource", "daummyStore", "dancyInput", "dummContent", "datumStore", "dummiesStore", "dummyInput", "dancyParent", " dummySourceFile", "datalParent", "duffyContent", " duffyContent"], "os": ["mos", "cos", "ims", "ms", "es", "OS", "asis", "or", "oos", "ops", "dis", "is", "des", "sys", "ui", "ows", "uts", "ors", "bos", "osi", "et", "bs", "socket", "dos", "ds", "o", "aos", "ants", "ens", "io", "ost", "ys", "css", "pos", "obs", "ox", "oS", "js", "oa", "ats", "ts", "si", "Os", "oids", "fs", "om", "conn", "ols", "los", "ori", "ose", "oss", "oes", "ios", "ot", "ros", "s", "oses", "out", "windows"], "dummyContent": ["dumpMedia", "deltaMedia", "dummyInt", "DummyContent", "dummyTemplate", "dumpingContent", "dumpingCode", "dynamicCode", "dynamicContent", "DumpMedia", "DummyInt", "deltaText", "dummyText", "determinedInt", " dummiesCode", "dynamicTemplate", " dummyContents", "dynamicContents", "determinedMedia", " dummiesContent", "dummyContents", " dummyCode", "dumpingContents", "dummyMedia", "dumpContent", " dummyTemplate", "dumpInt", "dummiesContents", "dummiesCode", "DummyMedia", "determinedText", "DumpInt", "DumpContent", "dummiesTemplate", "dummiesContent", "deltaContent", "determinedContent", "dumpingTemplate", "dumpText", "DummyText", "deltaInt", " dummiesTemplate", "DumpText", "dummyCode", " dummiesContents"], "source": ["series", "ser", "site", "core", "space", "template", "instance", "se", "user", "SOURCE", "ie", "sys", "sin", "seed", "proxy", "ource", "sql", "sample", "relation", "from", "use", "uri", "resource", "pse", "Source", "scope", "server", "spec", "src", "inner", "store", "google", "service", "ace", "result", "sr", "status", "table", "join", "sp", "s", "search", "in", "image", "sf"], "content": ["output", "path", "message", "Content", "expression", "text", "application", "json", "node", "html", "description", "template", "config", " contents", "section", "header", "ext", "response", "example", "title", "body", "resource", "current", "summary", "code", "tree", "key", "script", "version", "xml", "quest", "txt", "license", "sequence", "result", "cont", "command", "activity", "action", "status", "tx", "cache", "value", "comment", "document", "data", "format", "context", "layout", "editor", "ontent", "article"], "qResult": ["QView", "iqResult", "dqResult", "dqresult", "dqView", " qResults", "qResponse", "iqResponse", " qResponse", "QRes", "Qresult", "queryReport", "qRes", "queryResult", "dqRes", "qresult", "queryResponse", "iqResults", "qResults", " qRes", "qReport", "iqReport", "qView", "queryResults", " qView", "queryRes", " qReport", " qresult", "QResult", "iqRes"], "results": ["assets", "roads", "Results", "Contents", "ms", "products", "posts", "olds", "users", "orders", "runs", "versions", "times", "ults", "ries", "its", "rows", "forms", "pages", "views", "hips", "tests", "xes", "photos", "lections", "actions", "settings", "ULTS", "missions", "features", "members", "terms", " Results", "chains", "archives", "values", "result", "RESULTS", "details", "reports", "relations", "resources", "children", "ands", "data", "events", "blocks", "thumbnails", "s", "res", "items", "objects"], "it": ["lit", "out", "mit", "ite", "st", "init", "pit", "is", "ic", "IT", "rit", "ul", "et", "id", "p", "its", "h", "read", "ci", "iz", "t", "op", "It", "v", "at", "ait", "he", "they", "hit", "MIT", "m", "iter", "stat", "i", "info", "in", "ip", "li", "exec"], "rSrc": [" rSsrc", "rSourceRC", "rSlrc", "rSyssrc", "crSrc", "rSourcerc", "rSers", "rSource", "rDesrs", "crDessrc", "crSrs", "rSRC", " rScs", "rDesrc", "rSerc", "crDesrc", "rSlRC", "crSRC", "crDesrs", " rSRC", "rSlrs", "rSlcs", "rSysRC", "rScs", "rDesRC", "rSrs", "rSecs", " rSrs", "rSysrc", " rSource", "rSysource", "rDessrc", "rSsrc", "rSourcesrc", "rSeRC", "crDesRC", "crSsrc", "rSourcers"], "rSrcIn": ["rSRCCon", "rSldOut", "rSRCIN", "rSetrcOut", "rSetrcIN", "rSncCon", "rSldIN", "rSRCOut", "rSsrcin", "rSncOut", "rSetsrcIn", "rSrcCon", "rSRCIn", "rSrsOut", "rSrsInput", "rSrcOut", "rSetsrcIN", "rSsrcIn", "rSldin", "rSetrcIn", "rSrcInput", "rSRCin", "rSncIn", "rSetsrcOut", "rSrcIN", "rSldCon", "rSldIn", "rSsrcIN", "rSetrcin", "rSrsIn", "rSsrcInput", "rSetsrcin", "rSsrcOut", "rSrsIN", "rSrcin", "rSldInput", "rSncin"], "actualOut": ["ualOut", "finalOut", "ualBytes", "actuallyIs", "realIn", "actualCopy", "realCopy", "actuallyIn", "realIs", "ualEnd", "actualIs", "virtualIn", "UALIn", " actualout", "actualBytes", "actuallyCopy", "finalIn", "UALEnd", " actualCopy", "actualEnd", " actualIn", "UALBytes", "realOut", " actualBytes", "actuallyOut", "ualIn", " actualIs", "ualout", " actualEnd", "actualout", "finalout", "UALOut", "virtualOut", "actualIn"]}}
{"id1": "5274228", "id2": "16825994", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"put": ["output", "http", "update", "patch", "replace", "head", "POST", "Put", "apply", "response", "send", "execute", "uri", "resource", "run", "request", "write", "delete", "operation", "pull", "post", "get", "upload", "PUT", "submit", "set", "GET", "exec"], "resourceID": ["resourceName", "clientId", "resourcesId", "ResourceId", "resourcesIL", "resTracker", "ResourceID", "resID", "resIL", " resourceTracker", "clientName", "resourceTracker", "resId", "requestId", "clientID", "ResourceName", "resourceId", "requestID", "requestName", " resourceId", "resourcesTracker", "resourceIL", "resourcesID", " resourceIL"], "headersMap": ["headsMap", "ilersMap", " headersAdd", "namesAdd", " headersSet", " headersWith", "ilersList", "namesMap", "headsSet", "headsAdd", "headersWith", "namesWith", "ilersWith", "headsList", "namesSet", "headersAdd", "headersSet", "namesList"], "httpClient": [" httpFactory", "HTTPClient", " httpStore", "httPut", "ttpCall", "httpBuilder", " httpclient", "hclient", "Httpclient", "HTTPclient", "ttpBuilder", "hPut", "httpsClient", "httNet", "HttpStore", "httpsCall", "HttpClient", "httpFactory", "hClient", " httpBuilder", "httpCall", "httpNet", " httpNet", "httpsBuilder", "HttpFactory", "HTTPFactory", "httClient", "HTTPStore", "ttpclient", "hNet", "httpclient", "httclient", " httpCall", "httpStore", "ttpClient", "httpsclient"], "httpPut": ["ttpWrite", "httpsPut", "servicePUT", "HttpGet", "HTTPPut", "buildPut", "httpput", "httpPutting", "httpPUT", "HTTPClient", "servicePut", "ttpCall", " httpDelete", "htmlput", "HTTPGet", "hDelete", "hPut", "consolePut", "httpsClient", "buildPUT", "consoleput", "htmlClient", "HttpPUT", "htmlPut", "htmlPutting", "consolePutting", "HttpClient", "HttpDelete", "httpDelete", "viewPut", "httpCall", "HTTPPUT", "HttpPut", "consolePUT", "HttpCall", "httpsPUT", "httpWrite", "ttpPUT", "viewWrite", "HttpWrite", "viewGet", "hGet", "ttpPut", "htmlPUT", "hPUT", "viewPUT", "httpGet", " httpGet", " httpCall", "httpsput", "buildPutting", "ttpGet", " httpPUT", "buildput", "serviceClient", "serviceput"], "headersList": ["headsMap", "headsLIST", "ersLIST", "headersLIST", "namesMap", "headersL", "headsL", "namesArray", "partsMap", "partsLIST", "headsArray", "partsL", "ersL", "headsList", "partsList", "ersMap", "ersList", "namesList"], "iterator": ["collection", "runner", "series", "list", "pointer", "pler", "rounder", "ator", "iner", "instance", "menu", "loop", "processor", "pee", "loader", "integer", "rows", "starter", "size", "sample", "creator", "encer", "later", "liner", "timer", "wrapper", "operator", "river", "inner", "writer", "icer", "next", "reader", "stream", "player", "ter", "values", "sequence", "vector", "ner", "ste", "former", "consider", "set", "gener", "iter", "driver", "race", "chain", "walker", "finder", "issues", "immigrant", "context", "trace", "outer", "li", "Iterator", "eni"], "headersArray": ["headsMap", "headersarray", "ersArea", "headersArea", " headersarray", "fieldsMap", "ersarray", "ersArray", "usersArray", "headsArray", "ctorsArea", "fieldsarray", "ctorsMap", "fieldsArray", "usersHash", "ctorsArray", "headersHash", "headsList", "ersMap", "usersMap", " headersHash", " headersArea", "headsHash", "usersList"], "fields": ["field", "states", "links", "properties", "gs", "comments", "rows", "sections", "qs", "pages", "dates", "lines", "files", "obs", "tags", "FIELD", "codes", "keys", "errors", "values", "fs", "relations", "names", "owners", "objects", "services"], "occiHeaders": ["occciMeters", "occiHandlers", "occiHanders", "occiMetels", "occiMeters", "occiMetlers", "occciMetels", "occiMetERS", "occiHandERS", "occiBufflers", "occiBuffels", "occciHeadels", "occciHeadlers", "occiBuffERS", "occciMetlers", "occiBuffers", "occiHeadlers", "occciHeadERS", "occiHeadels", "occciMetERS", "occiHandels", "occiHeadERS", "occciHeaders"], "H": ["B", "U", "P", "T", "C", "R", "Hash", "MH", "HE", "HI", "O", " HH", "X", "HA", "Counter", "High", "He", "GH", "PH", "M", "Handler", "HS", "TH", "HL", "G", "HEAD", "A", "OH", "D", "Y", "I", "Handle", "N", "HH", "HC", "W", "J", "Header", "HB", "Head", "CH", "L", "V", "F", "Z", "K", "HT", "S", "HER"], "header": ["field", "buffer", "dr", "part", "block", "head", "peer", "user", "item", "response", "attribute", "heading", "metadata", "filter", "title", "holder", "token", "variable", "frame", "er", "th", "argument", "channel", "wrapper", "request", "code", "key", "rule", "name", "handler", "hidden", "event", "line", "entry", "hash", "Header", "layer", "status", "value", "port", "cookie", "table", "info", "document", "data", "format", "column", "handle", "hd", "first"], "statusLine": ["versionString", "statSet", "versionLine", "StatusLine", "versionline", "versionCode", " statusSet", "statusSet", " statusString", " statusline", "statusline", "statusString", "Statusline", "StatusString", "statString", "StatusCode", "StatusSet", "statLine", "statCode"], "httpResponse": ["httpPage", "HTTPPage", " httpFour", "procBody", "httpFour", " httpStatus", "procAnswer", "HTTPClient", "adminAnswer", " httpRes", "httpsPage", "HttpResponse", "httpResp", "httpsBody", "ttpResponse", "hoverResp", "httpsAnswer", "webFour", "httpsClient", "httpsResponse", "viewAnswer", "hoverResponse", " httpBody", "procresponse", "HttpClient", "adminresponse", "phpFour", "procResponse", "ttpPage", "webResponse", "httpAnswer", "HTTPResponse", "phpAnswer", "viewResponse", " httpPage", "httpBody", "adminResponse", "adminPage", "Httpresponse", "httpsresponse", "phpResponse", "phpRes", "viewresponse", "httpresponse", " httpResp", "webAnswer", "viewBody", "webRes", "hoverClient", "httpsStatus", "hoverresponse", "httpRes", "ttpBody", " httpresponse", "HttpResp", "ttpClient", " httpAnswer", "HTTPStatus", "httpStatus", "ttpStatus"], "statusCode": ["scoreChain", "statusChain", "statusCo", "scoreCount", "statClass", " StatusCode", "StatusLine", "statCount", "StatusClass", " StatusCo", " statusString", " StatusChain", "StatusPoint", "statusClass", "statusString", " statusChain", "statPoint", "statusCount", " statusCo", "StatusCount", " statusClass", "StatusString", " statusPoint", "statusPoint", "statString", " statusCount", "StatusCode", "scoreCo", "scoreCode", "statLine", "statCode", " StatusCount"]}}
{"id1": "18011804", "id2": "1985677", "code1": "    public FileChooserTestFrame() throws HeadlessException, MalformedURLException {\n        super();\n        addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent aEvent) {\n                System.exit(0);\n            }\n        });\n        Dimension dim = getToolkit().getScreenSize();\n        Rectangle abounds = getBounds();\n        setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2);\n        setVisible(true);\n        URL url = new URL(\"ftp://cendantstp/\");\n        char[] password = \"spnr\".toCharArray();\n        PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password);\n        FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication);\n        JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView);\n        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        fileChooser.setMultiSelectionEnabled(true);\n        File[] selectedFiles = null;\n        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n            selectedFiles = fileChooser.getSelectedFiles();\n            for (int i = 0; i < selectedFiles.length; i++) {\n                if (selectedFiles[i] instanceof FTPFileFile) {\n                    FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i];\n                    logger.fine(ftpFile.getName());\n                    logger.fine(ftpFile.getPath());\n                } else {\n                    logger.fine(selectedFiles[i].toString());\n                    logger.fine(selectedFiles[i].getAbsolutePath());\n                }\n            }\n        }\n        remoteFileSystemView.disconnect();\n        try {\n            if (null != selectedFiles) {\n                FTPClient ftpClient = new FTPClient();\n                InetAddress inetAddress = InetAddress.getByName(url.getHost());\n                ftpClient.connect(inetAddress);\n                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                    throw new FTPBrowseException(ftpClient.getReplyString());\n                }\n                if (null != passwordAuthentication) {\n                    ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());\n                }\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    FTPFileFile file = (FTPFileFile) selectedFiles[i];\n                    logger.fine(file.getPath());\n                    FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\"));\n                    logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos));\n                    fos.close();\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"HeadlessException": ["Headlessception", " Headlessception", "HeadlesslyEvent", "HeadlessEvent", "HeadlevelError", "HeadlevelException", "HeadLessception", " HeadlesslyEvent", "HeadLessEvent", " HeadlesslyError", "Headlesslyception", "Headlevelception", " HeadlessEvent", "HeadlesslyException", " HeadlessError", "HeadLessException", " HeadlesslyException", "HeadlessError", "HeadLessError", " Headlesslyception", "HeadlevelEvent", "HeadlesslyError"], "MalformedURLException": ["MalformedURLExpion", "MalformedURLAexception", "MalformedURLEssption", "MalformedURLExpption", "MalformedURLExpression", "MalformedURLEssception", "MalformedURLExption", "MalformedURLExression", "MalformedURLEexption", "MalformedURLExion", "MalformedURLExpception", "MalformedURLEexception", "MalformedURLEssression", "MalformedURLAxression", "MalformedURLAxion", "MalformedURLAxception", "MalformedURLEexression", "MalformedURLAexion", "MalformedURLAxption", "MalformedURLAexption", "MalformedURLEexion", "MalformedURLEssion", "MalformedURLAexression"], "aEvent": [" anEvents", " anEvent", " aCommand", " oEvents", " aFolder", " oCommand", " anFolder", " oEvent", "iCommand", "iFolder", " aEvents", "iEvents", " anCommand", " oFolder", "iEvent"], "dim": ["ims", "dr", " dimension", "db", "shape", "im", "px", "ram", "sd", "ality", "tm", "iam", "Rect", "region", "size", "dir", "coord", "dimension", " Dim", "dm", "dem", "mm", "mid", "spec", "lim", "Dim", "du", "mb", "d", "cam", "sum", "wid", "mod", "vis", "details", "mem", "gm", "def", "sam", "di", "py", "height", "div", "dom"], "abounds": ["aporders", "abbles", "aborts", "abbounding", "bbles", "absounces", "aports", "abbqs", "bounds", "abbodies", "abbounds", "Abounds", "amborders", " abensions", " ABounding", "Abounding", " abounces", "abounces", "abqs", "rabounds", "raborders", "amborts", "aborders", " aborders", "Abodies", " ABounds", "apounds", "ambbles", "abensions", "borts", "absorders", "abounding", "borders", "ambounds", "absounds", "apbles", "absensions", "Abqs", "abodies", " ABodies", " ABqs", "rabensions", "rabounces"], "url": ["path", "http", "mail", "html", "ls", "location", "window", "abs", "term", "sl", "addr", "hub", "usb", "bel", "link", "ur", "connection", "Url", "f", "address", "socket", "URL", "api", "parser", "absolute", "ssl", "uri", "dl", "loc", "nl", "resource", "client", "server", "browser", "ref", "str", "ll", "l", "u", "www", "localhost", "base", "lr", "domain", "web", "https", "r", "host", "github"], "password": ["session", "description", "prefix", "words", "phrase", "hello", "user", "database", "attribute", "secret", "address", "definition", "token", "reset", "security", "Password", "encrypted", "login", "power", "pass", "key", "sword", "shadow", "username", "crypt", "directory", "command", "padding", "hash", "language", "profile", "wordpress", "random", "word", "pattern"], "passwordAuthentication": [" passwordAuthenticating", "passwordAuthentiction", "passwordauthentiction", "passwordCommunicating", "passwordauthentication", "passwordauthentications", "passwordAuthenticator", "passwordAuthicator", " passwordAuthenticator", "passwordCommunication", " passwordAuthicating", " passwordAuthification", "passwordAuthentications", " passwordAuthentification", " passwordAuthentications", "passwordAuthicating", "passwordAuthenticating", "passwordauthentification", "passwordAuthiction", "passwordAuthications", "passwordAuthification", " passwordAuthiction", "passwordAuthentification", "passwordCommunicator", "passwordCommuniction", "passwordAuthication", " passwordAuthentiction", "passwordCommunications", " passwordAuthicator", "passwordauthenticating", " passwordAuthications", "passwordauthenticator", " passwordAuthication", "passwordCommunification"], "remoteFileSystemView": ["remoteFileListContext", "remoteFilesSystemContext", "remoteFilesystemModel", "remoteFileSystemview", "remoteFilesystemResponse", "remoteFilesSystemview", "remoteFileSystemContext", "remoteFileystemResponse", "remoteFilesystemView", "remoteFilesSystemView", "remoteFileListView", "remoteFileListResponse", "remoteFileSystemDisplay", "remotePlaceSystemModel", "remoteFileListModel", "remoteFileystemView", "remoteFileSystemModel", "remoteFilesystemview", "remoteFileTreeContext", "remoteFileListview", "remoteFileListDisplay", "remoteFilesSystemModel", "remotePlaceSystemDisplay", "remoteFileSystemResponse", "remoteFileTreeModel", "remotePlaceSystemView", "remotePlaceSystemview", "remoteFileTreeView", "remoteFilesystemDisplay", "remoteFileystemDisplay", "remoteFileTreeview"], "fileChooser": [" fileSelecticker", "fileSelectressor", "fileSeoder", "channelChoorer", "fileCompicker", "resourceChoer", "fileComposer", "resourceCompicker", "fileCompressor", "channelChoicker", "fileClerer", "fileSeoser", "fileSelectose", "resourceChoose", "filechoerer", "resourceComper", " fileCompose", " fileSelectressor", " fileChoer", " fileComposer", " fileCompressor", "channelchoerer", " fileSelectoser", " fileChoose", "fileChoer", "fileSeerer", " fileChoressor", "resourceComposer", "fileSelectoser", "fileCloser", "channelchooser", "fileChoressor", "fileSelectoder", "fileClicker", "fileChoorer", "fileSelecter", "fileChooder", "filechoicker", "fileChoser", "resourceChooser", " fileChicker", "channelchoicker", " fileChooder", "fileComper", "fileCompoder", "fileSeose", " fileSelecter", "fileChicker", "channelChooser", "fileChoose", " fileCompoder", " fileChoicker", "fileSeressor", "fileChosen", "resourceCompose", "fileComposen", " fileChoosen", "channelchoorer", " fileChose", "filechooser", "fileSeicker", "fileChoicker", "fileClorer", "resourceChoicker", "fileChoosen", "fileChoerer", "fileSelecticker", "channelChoerer", "fileChose", "fileSeorer", " fileChoser", "filechoorer", " fileChosen", "fileCompose"], "selectedFiles": ["checkedfiles", "selectedResources", "printedOps", "verifiedFeatures", "verifiedBooks", "fetchedFiles", "linkedResources", "lectediles", "pressedBytes", "namedPhones", "namedOps", "selectedBytes", "pressedThings", "selectediles", "pressedBooks", "checkedFiles", "lectedResources", "selectedfiles", "reviewedBooks", "checkedItems", "selectedOps", "pressedFile", "linkedFiles", "pressedPhones", "fetchedItems", "pressediles", "pickedBooks", "lectedfiles", "checkedBooks", "verifiedFiles", "lectedFile", "selectedThings", " selectediles", "coloredFiles", "pickedFeatures", "fetchedThese", "coloredBytes", "printedFile", "identifiedItems", "reviewedFile", " selectedItems", "reviewedFiles", "selectedThese", "selectedFeatures", "selectedFile", "namedFiles", "linkedFile", "coloredThese", "printedPhones", " selectedOps", "identifiedBooks", "fetchedBooks", " selectedfiles", "selectedBooks", " selectedBooks", " selectedResources", "pressedItems", "selectedPhones", "lectedFiles", "identifiedFiles", "printedFiles", "electedBooks", "pressedThese", " selectedFile", "electedItems", "pressedOps", "linkedfiles", "pressedfiles", "coloredThings", "identifiedOps", "pickedItems", "electedFiles", "fetchedfiles", "namedFile", "electedFeatures", "fetchedThings", "lectedItems", "verifiedItems", "pickedFiles", "selectedItems", "fetchedBytes", "lectedBooks", "pressedFiles"], "i": ["multi", "history", "x", "j", "init", "phi", "it", "my", "ai", "ini", "is", "ic", "ri", "ui", "me", "iu", "id", "y", "io", "mi", "ci", "ki", "ex", "uri", "t", "ii", "qi", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "u", "sequence", "err", "ei", "print", "batch", "m", "status", "xi", "us", "iq", "mu", "cli", "ami", "di", "sim", "pi", "chain", "info", "exp", "ij", "s", "in", "ip", "li", "\u0438", "ix"], "ftpFile": [" fttpfile", "ftpifile", " ftpChat", "ftpaFile", " ftpChain", " fttpFile", " fttpResource", "fttpfile", "fttpFILE", "ftpingfile", "ftPAction", "ftapiAction", "fttpChat", "ftPfile", "ftpFolder", " ftpfile", "ftpingResource", "ftPChain", "ftpfile", "fttpChain", "fttpFile", "ftpChain", "iftpComment", "ftpaComment", "ftpingFile", "iftpFile", "ftpiChain", "iftapiComment", "ftapiFolder", " ftPChat", "ftpFILE", "ftpComment", "ftPComment", "ftpingFILE", "ftrResource", "iftapiAction", "iftapiFolder", " ftPChain", "ftpiChat", "ftpiFile", " fttpFILE", "ftPFolder", "ftpAction", "iftapiFile", "iftpFolder", " ftPfile", " ftPFile", "iftpAction", "ftapiFile", "ftPChat", "fttpResource", " ftpFILE", "ftpaFolder", "ftpaAction", "ftpResource", "ftrFILE", "ftrfile", "ftPFile", "ftapiComment", "ftpChat", "ftrFile", " ftpResource"], "ftpClient": ["fttClient", "ftcpClient", "ftcServer", "fttProxy", "aftcpProxy", " ftpServer", "fttServer", "aftcpClient", "fttclient", " ftpConnection", "fttpProxy", "fttpClient", " fttClient", "aftpClient", "aftpProxy", "fttpConnection", "ftcpConnection", " fttConnection", "ftpConnection", "fttConnection", "ftcConnection", "aftpConnection", "aftpclient", "ftcpServer", "ftpProxy", "aftcpConnection", "fttpclient", "ftcclient", " fttclient", "ftpServer", " fttServer", "ftcpclient", "ftcClient", "ftcpProxy", "ftpclient", "aftcpclient", " ftpclient"], "inetAddress": ["physHost", "ptonAddress", "networkAddress", "physAdd", "inetaddress", "ptonaddress", "networkHost", "inetClient", "networkAdd", "netAddress", "netaddress", "inetHost", "physAddress", "netClient", "inetAdd", "netHost", "networkClient", "etAddress", "physClient", "ptonAdd", "netAdd", "etaddress", "etAdd"]}}
{"id1": "21824901", "id2": "12744653", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copyExternalResource": ["downloadExternalReference", "copyExternalresource", "copyOptionalResources", "copyInternalresource", "downloadexternalresource", "copyInternalReference", "copyexternalresource", "copyexternalResource", "copyexternalResources", "copyexternalReference", "copyInternalResource", "downloadExternalResources", "copyInternalResources", "downloadExternalresource", "copyExternalReference", "copyOptionalresource", "downloadExternalResource", "downloadexternalResources", "copyExternalResources", "downloadexternalResource", "copyOptionalReference", "downloadexternalReference", "copyOptionalResource"], "sourceFile": ["ourceFile", "destLine", "sourceLine", "SourceDir", " sourceFilename", "sourceChain", "sourceDir", "destPage", "ourceDir", "SourceFilename", "srcLine", "srcFile", "srcPath", "sourcePath", "sourceFilename", " sourcePage", "destPath", " sourceLine", "ourceFilename", "ourceChain", "sourcePage", "srcPage", " sourceChain", " sourceDir", " sourcePath", "SourceChain", "SourceFile"], "destFile": ["optDir", "critDir", "srcPlace", " destFilename", " destFiles", " destDir", "optFiles", "DestFilename", "locDir", "srcFILE", "DestDir", "destDir", "DestFiles", "destFilename", "srcFile", "critFile", "destFiles", "srcPath", "locFile", " destfile", "optPlace", " destFILE", "srcfile", " destPlace", "locPath", "destfile", "destPath", "optFile", " destPath", "Destfile", "destPlace", "srcDir", "critfile", "srcFiles", "critFilename", "destFILE", "locFILE", "DestFile"], "source": ["series", "style", "load", "session", "owner", "update", "se", "init", "SOURCE", "force", "ie", "connection", "shell", "proxy", "body", "address", "ource", "sql", "console", "local", "sample", "iterator", "create", "ce", "from", "subject", "use", "pose", "resource", "channel", "scope", "Source", "back", "parent", "component", "less", "src", "store", "inner", "cause", "reader", "index", "stream", "service", "none", "sequence", "result", "before", "base", "check", "input", "copy", "iter", "cache", "table", "archive", "match", "target", "query", "search", "origin", "in", "start", "image", "score"], "destination": ["Destination", "destinator", "Destation", "Destinator", "potination", "destation", " destinated", "descinated", "notinate", "descinator", "compation", "catinator", "compination", "compinated", "descinate", "Destociation", "catinate", "Destinated", " destation", "destuation", "compinator", "destociation", "notinated", "combination", "descination", "catination", "combuation", " destuation", "potinator", "Destuation", "notinator", "potociation", "potation", "destinated", "destinate", "notination", "combinator", "combinated", " destociation", " destinator", "catinated"]}}
{"id1": "6403868", "id2": "8011262", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"extractUninstallFiles": ["extractUnpackItems", "extractUnInstallFiles", "extractunInstallFiles", "extractuninstallItems", "extractuninstallFiles", "extractunInstallItems", "extractUnpackFile", "extractUnpackFiles", "extractuninstallFile", "extractUninstallItems", "extractUnInstallItems", "extractUninstallFile", "extractUnInstallFile", "extractunInstallFile"], "_destPath": ["_DestPath", "_combPath", "_privDir", "_combDir", "_tempDir", "_destDir", "_srcPath", "_restPoint", "_DestKey", "_srcDir", "_DestPoint", "_restPath", "_combFormat", "_sourcePath", "_srcPoint", "_privPath", "_destFormat", "_destKey", "_restDir", "_sourceDir", "_DestDir", "_DestTh", "_privPoint", "_privTh", "_tempPath", "_tempFormat", "_tempTh", "_restKey", "_destPoint", "_destTh", "_srcKey", "_sourceFormat", "_tempPoint"], "upgrade": ["upcp", "exchange", "unate", " upchange", "upcheck", "equgrade", "excheck", "equcp", "equgrad", "downgrades", "downchange", "uncp", "equate", " upcp", "upchange", "ungrade", "exgrades", "upgrad", "upgrades", " upate", "exgrade", "downgrade", " upcheck", " upgrades", "ungrad", "upate", " upgrad", "downcheck"], "lastVer": [" lastVers", " lastServ", "lastServ", "lastVers", "nextVer", "latestServ", "LastVersion", " lastver", "nextServ", "latestRes", "lastRes", "oldVersion", "latestVers", "nextRes", " lastVersion", "nextVers", "oldver", "lastVersion", "LastVer", "oldVer", " lastRes", "lastver", "latestVer", "LastVers", "oldVers", "Lastver"], "oldlog": ["Oldlog", "OLDLog", "oldpath", "OLDlog", "Oldog", "OldLog", "olderog", "OLDpath", "OLDog", "olderpath", "oldog", " oldLog", " oldog", "olderLog", " olderr", "Oldpath", "olderlog", "oldLog", "olderr", "OLDerr", " oldpath", "oldererr"], "destPath": ["altParent", " destDirectory", "altNode", "destNet", "estPos", "originPath", "restDir", "gestNode", "declPath", "destFont", "descName", "locTime", "potPath", "identPort", "sortFont", "foreignPod", "altDir", "originPort", "sortDir", "foreignPath", "estDir", "DestPoint", "estRef", "DestPath", " destDir", " destPort", "destName", "estName", "destDir", "destLog", "DestParent", " destPos", "srcPath", "destRoot", "DestName", "privPath", "descPos", " destParent", "descDisk", "identPath", "altHost", "estPath", "privRoot", "destPos", "DestFont", "declFont", "DestStream", "DestFile", "destFile", "descPath", "destParent", "altPoint", "descTime", "potPod", "srcPort", "destTh", "DestDir", "destNode", "descNet", "descKey", "foreignStream", "DestPos", " destPoint", " destName", "restFile", "srcLog", "destHost", "locNet", "potStream", " destTh", "srcDir", "declFull", " destFile", "destRef", "restPath", "estKey", "destStream", " destHost", "sortFull", " destRef", " destNode", "destPoint", "destDisk", "gestDisk", "destTime", " destLog", "restPoint", "declDir", "DestFull", "privDir", "srcFile", "gestName", "altPath", "identPoint", "foreignDir", " destKey", "locDisk", "destPod", "DestPort", "DestRoot", "destDirectory", "destPort", "originPoint", "locPath", "sortPath", "destKey", " destRoot", "gestHost", "destFull", "DestRef", "DestPod", "DestLog", "potDir", "gestTime", "originTh", "altName", "srcDirectory", "privPos", "DestDirectory", "gestNet", "gestPath", "identTh"], "lastVerPath": ["lastVerForm", "highestVerFile", "lastverFile", "lastVersVal", " lastverDir", "lastVerFile", " lastVersPath", "lastVerVal", "lastverVal", "highestVERFile", "lastVerCh", "lastverForm", "highestVerpath", "lastVERDir", "lastVerpath", "lastVersLog", "lastverCh", "lastverName", "lastVersionCh", "lastVERFile", "lastVerDir", "lastVersFile", "lastVerLog", "lastVerName", "lastResPath", "highestVERVal", "lastverDir", " lastVersCh", "lastVERForm", "highestVerVal", " lastVersLog", "lastVersionpath", "lastVERpath", "lastVersPath", "lastVersionFile", "highestVERPath", " lastVerpath", "highestVerPath", "highestVERpath", " lastVerFile", "lastverPath", "lastResForm", "lastverLog", " lastverForm", "lastVERPath", "lastVersCh", "lastVERVal", " lastverpath", "lastverpath", " lastverPath", "lastRespath", " lastVerForm", "lastVersName", "lastVerspath", " lastVerName", " lastVerDir", " lastVersFile", "lastResDir", " lastVerCh", " lastVerLog", "lastVersionPath"], "bkdir": ["bakDir", "bqfd", "BkDIR", "blkgroup", " bkDir", "Bckdir", "bakdi", " bkkdir", "bckpath", "bkgrel", "bckfolder", "bkkDir", "bkkpath", " bakfolder", " bkkrel", "bckDir", "bkgDir", "blkdir", " bakdir", "bkgdir", "bukdir", "bkkdi", "bkjgroup", "bkpath", " bkdi", "bakrel", "bkgfolder", "bckdir", "bkfolder", "blkjdi", "bukpath", "BkDir", "bkDir", "bkjdi", "blkfd", "Bkpath", "bkgroup", "bqdir", "bkkDIR", "bqdi", "blkjdir", " bkfolder", "bakfolder", "bkfd", "Bkdir", "Bckpath", " bkkfolder", "bkdi", " bkkDir", "bckdi", " bakDir", "BckDIR", "bkrel", "blkjgroup", "bkkfolder", "bkkdir", "bkDIR", "BckDir", "bkkrel", "bakdir", " bakdi", "bkjdir", "bkjfd", "bukgroup", "bukDIR", "bqgroup", "bukdi", "bukfd", "blkjfd", "blkdi", " bkrel", "bukDir", "bckDIR"], "oldClassCopied": ["oldClassReplified", "oldClassReplied", "oldClassCopyified", "oldclasscopified", "oldClassCopie", "oldDirCopiated", "oldClassColied", "oldclassCopie", "oldClasscopried", "oldClassChied", "oldClasscopie", "oldclassCopies", "oldClassColaced", "oldClassReplried", "oldDirCopied", "oldClassCopyies", "oldDirRepliated", "oldClasscopies", "oldClassColified", "oldClasscopified", "oldClassCopies", "oldClassCopried", "oldclassCopied", "oldClassChiated", "oldClassCopiated", "oldclassCopified", "oldClassCopified", "oldclasscopie", "oldClassCopaced", "oldDirReplied", "oldClasscopiated", "oldclassCopaced", "oldDirReplried", "oldClassCopyie", "oldclasscopies", "oldClassChried", "oldClassCopyied", "oldClassColies", "oldDirCopies", "oldClassReplaced", "oldDirReplies", "oldClassChies", "oldClasscopied", "oldclasscopied", "oldClassReplies", "oldClassRepliated", "oldDirCopried"], "ls": ["las", "ists", "vs", "ms", "abs", "lf", "es", "ln", "sels", "la", "tl", "gs", "lt", "bs", "ds", "ws", "its", "qs", "ars", "xs", "les", "cs", "dl", "lines", "lc", "lists", "ics", "ps", "rs", "ils", "LS", "less", "ns", "ks", "ats", "l", "fs", "ols", "acts", "los", "lbs", "rl", "els", "ts", "lv", "irs", "lis"], "i": ["multi", "ims", "eu", "im", "zi", "x", "j", "init", "phi", "it", "a", "ini", "is", "ic", "ski", "ui", "ri", "b", "me", "fire", "id", "y", "io", "ci", "mi", "gu", "ki", "qi", "ii", "gi", "hi", "ti", "key", "bi", "ji", "index", "si", "I", "l", "u", "ei", "batch", "m", "xi", "us", "iq", "ami", "cli", "di", "sim", "pi", "chain", "ij", "ip", "li", "oi", "ix"]}}
{"id1": "19050432", "id2": "4593012", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["opennamedRes", "opennamingResource", "opennamingClass", "openNumberedStream", "openNestedStream", "openNestedRes", "openNamingClass", "openNamingRes", "openNamingStream", "openNumberedRes", "opennamedClass", "openNumberedResource", "openNamedRes", "openNamedClass", "opennamingStream", "openNestedClass", "openNamedStream", "opennamingRes", "opennamedResource", "openNamingResource", "openNestedResource", "opennamedStream", "openNumberedClass"], "name": ["path", "message", "part", "missing", "description", "password", "prefix", "n", "template", "type", "link", "title", "address", "id", "nm", "p", "local", "size", "use", "uri", "resource", "initial", "filename", "NAME", "ame", "ref", "key", "null", "str", "named", "string", "Name", "file", "value", "names", "search", "full", "url", "alias", "word"], "in": ["IN", "on", "din", "gin", "con", "asin", "n", "oin", "ini", "rin", "is", "vin", "mc", "f", "body", "ain", "as", "pin", "o", "to", "en", "from", "tin", "mi", "pid", "ind", "ins", "login", "up", "bin", "serv", "inner", "impl", "reader", "stream", "isin", "In", "conn", "input", "m", "i", " din", "inn", "out", "conf", "inf", " out", "cin"], "propsURL": ["ProrsURL", "proprNR", "propsURI", "projsUrl", "proPSCH", "PropsURI", "proPSURL", "propertiesURL", "probsurl", "Propsurl", "proppsUrl", "PropsUrl", "progsURL", "prorsURL", "proprsURL", "proprurl", "prorsEL", "progsUR", "PropsNR", "progsurl", "probsUrl", "PropsEL", "ProPSUR", "proppsCL", "propsEL", "proPSCL", "protsUrl", "proPSNR", "PropsUR", "ProPSURI", "propertiesURI", "proppsUR", "projsURL", "proprsCL", "progsCL", "proPSUrl", "proprURL", "probsURI", "PropsCL", "ProPSUrl", "propsSSL", "projsEL", "proppsURL", "progsEL", "PropsSSL", "propsUrl", "proppsCH", "proPSurl", "proPSUR", "prorsUrl", "ProPSCL", "projsUR", "propertiesUR", "propertiesUrl", "proprsUrl", "proPSSSL", "ProPSCH", "ProrsEL", "propsurl", "proppsSSL", "PropsURL", "progsUrl", "protsurl", "probsURL", "propertiesCH", "prorsCL", "progsURI", "propsCL", "propsCH", "prorsUR", "propertiesCL", "protsURL", "ProPSSSL", "propertiesurl", "propsUR", "ProPSurl", "ProrsUR", "protsNR", "propsNR", "ProrsUrl", "protsURI", "proprsUR", "propertiesSSL", "ProPSNR", "ProPSURL", "proPSURI", "PropsCH", "proprUrl"], "urlConn": ["UrlCon", "httpConn", "webconn", "handleCon", "urlconn", "urlInit", "slMem", "urlConnect", "lsInit", "fileMem", "URLConn", "urlMem", "slObj", "lsconn", " urlInit", "lsConnect", " urlconn", "fileConn", "urlConnection", "handleConnect", "slConn", "slCons", "UrlConnect", "handleConnection", "fileObj", "handleConn", "httpMem", "URLConnect", "urlCons", "webConnect", "webConn", "lsConn", "UrlConnection", "URLConnection", " urlConnect", "urlCon", "httpCons", "webInit", "UrlConn", "httpObj", "urlObj", "fileCons", "URLCon"], "httpURL": ["httpsurl", "healthurl", "httpUR", "ttpURL", "HttpURL", "httpDB", " httpDB", "healthUR", "httpsURL", " httpSSL", "httpsUR", "hoverUrl", "Httpurl", "HTTPUrl", "hoverurl", "httpURI", "ttpurl", "HttpUrl", "healthURL", "HttpSSL", "httpSSL", "ttpURI", " httpUrl", "hoverURL", " httpURI", "httpUrl", "HTTPDB", "ttpDB", " httpurl", "healthUrl", "hoverUR", "HTTPURI", "httpsUrl", "ttpSSL", "ttpUrl", "httpurl", "HTTPURL"], "hdrVal": ["hheaderVal", "hdrEl", "hDRVal", "hlrValue", "httpVal", "hDRLen", "hlrLen", " hheaderLen", "hDRVAL", "ohdrVal", "hdrValue", "hheaderEl", " hdrLen", "hheaderVAL", "hlrval", " hheaderval", "hDRval", "hdrVAL", "hheaderval", "httpValue", "HheaderVal", "hDREl", "hDRValue", "httpVAL", "ohDREl", "HdrVal", " hheaderValue", " hheaderVal", "hdrLen", "hlrVal", "hstrVal", " hdrValue", "ohdrEl", "httpEl", "hdrval", "hheaderValue", "hstrEl", "hheaderLen", "HdrEl", "HheaderVAL", "HdrValue", "ohdrValue", "hstrValue", "ohDRVal", " hdrval", "ohDRValue", "HheaderEl", "HheaderValue", "HdrVAL"], "code": ["ch", "message", "text", "reason", "description", "close", "cue", "se", "msg", "type", "header", "response", "color", "currency", "ct", "ck", "count", "body", "id", "state", "no", "rc", "size", "ce", "desc", "mode", "length", "component", "content", "cycle", "key", "cod", "error", "xxx", "magic", "xx", "ode", "index", "number", "codes", "coe", "one", "ack", "ace", "level", "go", "event", "result", "cont", "sec", "check", "string", "status", "zero", "cc", "value", "comment", "coded", "country", "age", "url", "city", "Code", "c", "zip"]}}
{"id1": "2198730", "id2": "3495460", "code1": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"importCSV": [" importWSDF", " importESVD", "importCSS", " importESDF", " importESV", " importWSS", " importESS", " importDSS", " importDSV", " importDSVD", "importDSVD", " importDSDF", " importCSS", "importDSDF", "importCSVD", "importDSS", " importWSVD", " importCSDF", " importCSVD", "importCSDF", " importWSV", "importDSV"], "csvfile": ["httpsFILE", "xmlstream", "csvresource", "cssresource", "svstream", "xmlFile", "txtFile", "svresource", "cssfile", "svfile", "httpsfile", "csvFile", "cssFile", "txtfile", "cssfiles", "txtfiles", "httpsFile", "svFile", "svFILE", "csvstream", "csvFILE", "txtresource", "xmlFILE", "xmlfile", "svfiles", "csvfiles", "httpsstream"], "qmarks": [" qarks", "qualmark", "qmarked", "Qgrades", "qualmarked", "qumarks", "Qmarked", "sqmarks", "dqmarks", "sqarks", "sqmark", " qgrades", " qparams", "qugrades", "qualarks", "qumarked", "Qarks", "qarks", "qualgrades", "qualmarks", "qgrades", " qmarked", "qmark", "quarks", "qumark", "dqmark", "qparams", "qualparams", "dqmarked", "dqparams", " qmark", "Qmarks", "sqmarked"], "i": ["ims", "ion", "it", "inx", "ri", "ic", "iu", "iii", "to", "ind", "t", "qi", "gi", "span", "err", "set", "status", "iter", "iy", "ij", "cli", "li", "oi", "list", "series", "json", "zi", "j", "init", "ini", "lo", "is", "ui", "f", "jj", "q", "o", "ex", "uri", "e", "hi", "g", "ti", "bi", "ji", "name", "ice", "l", "go", "you", "print", "batch", "ami", "chain", "sim", "ip", "multi", "im", "ity", "n", "ie", "me", "major", "id", "h", "ci", "ii", "index", "u", "ei", "m", "xi", "iq", "z", "exp", "pi", "history", "x", "phi", "ai", "b", "p", "y", "io", "mi", "gu", "ki", "v", "cgi", "si", "I", "point", "di", "info", "in", "ix"], "delsql": ["dletesfx", "diffsql", "delsfx", "dletessql", "delesql", "delesq", "delsq", "dysdl", "diffsQL", "deltq", "deelssql", "deltQL", "dlessql", "delssql", "diffsq", "deltsql", "deelsdl", "diffssql", "delsdl", "deletesdl", "deelsQL", "dlesq", "deelsq", "dlesQL", "deltfx", "deletesql", "deelsql", "delsQL", "deletesfx", "dletesdl", "dletesql", "dlesql", "deltdl", "dysfx", "dysql", "deletessql", "dyssql", "delesQL", "deelsfx", "deltql", "delessql"], "delstm": ["delstrn", "DelStn", "delStmt", "delSttm", "Delsttm", "DelSttm", "delstmt", "Delstem", " delStmt", "delstrem", "delstrm", "DelStm", "delctm", "delctmt", "DelStem", "delStm", " delStem", " delstmt", "delstn", " delStr", "delStn", "delstr", "delestem", "delsttm", "Delstn", "delctr", "delStr", "Delstm", "delestn", " delstem", "delstem", " delstr", "delestm", "delstrtm", "delctem", "delesttm", " delStm", "delStem"], "sql": ["orm", "fn", "expression", "plan", "json", "html", "ls", "description", "sl", "template", "sd", "pkg", "wal", "sys", "statement", "seed", "shell", "su", "ql", "asm", "socket", "raw", "rel", "inv", "qs", "SQL", "install", "ssl", "dl", "nl", "security", "login", "spec", "js", "setup", "script", "xml", "quote", "form", "command", "string", "select", "scl", "log", "sb", "sp", "query", "sv", "format", "url", "cmd", "repl", "sf", "sq", "zip"], "stm": [" stsm", "Stmt", " stam", "stsm", " stmt", "Stam", "thmt", "tham", "thsm", "Stm", "stmt", "thm", "stam", "Stsm"], "datatypes": ["datativities", "datAType", "datetpes", "datetypes", " datATtypes", "datAtypes", "dataattypes", "dataatype", "datmatype", "datetopes", " datattypes", "datetype", "datattypes", "datAtopes", " datatools", "dataatypes", "datamatypes", "datatpes", "datatsype", "datamatype", "datmattypes", " datATpes", "datATtypes", "datatopes", " datAType", "datmatypes", "datatstypes", "datATopes", "datatsypes", "datAtype", " datATypes", " datATools", "datmatools", " datATopes", "datamativities", " datatpes", "datATypes", "dataativities", "datatsools", "datatools", " datatopes", "datmativities", "datamattypes", "datATpes", "datATivities", "datAtpes", "datATools"], "tbl": ["atbody", "Tba", "ctba", " tamb", "Ttable", " tbody", "dbf", "dbody", "dbl", "tll", "damb", "Tll", "pttable", "rtpl", "torg", "Tbl", "ptbl", "tbf", "ctorg", "tba", " tbf", "Torg", "ptpl", "rttable", "atbl", "ttable", "tpl", "wtba", "ctpl", "Tpl", "tamb", "wtorg", "wtbl", "atbf", "ptll", "rtbl", "tbody", "ctbl", "rtll", "wtpl", "atamb"], "col": ["Col", "con", "cell", "ol", "cond", "cal", "var", "rol", "ct", "cor", "tab", "prop", "Column", "cat", "row", "local", "num", "crit", "conv", "loc", "COL", "pt", "pos", "el", "serv", "fc", "mon", "cop", "ll", "fl", "cp", "comm", "dc", "char", "crypt", "cont", "cl", "def", "chron", "ctrl", "co", "column", "cf", "cmd", "act", "coll", "c", "cur"], "datatype": ["datmatime", "datAType", " datatrace", "datatyp", "dataatyp", "datAtypes", "donatypes", "dataatype", "donatyp", "datmatype", "datcatyp", "datamatyp", " datmatypes", "datATty", "donatty", "datatty", "datAtime", "datcatty", "donatype", "datcatype", "dataatypes", "datamatypes", "datamatime", "datatime", "datamatype", " datmatype", "datantime", "datcatime", " datatime", "datantypes", "datATime", "datmatypes", " datmatrace", "doncatty", "datantrace", "dataatime", "datmatyp", "datAtype", "doncatype", "datAtyp", "datcatrace", "datantype", "datmatty", "doncatyp", "doncatypes", "datATypes", " datmatime", "datatrace", "datATyp", "datmatrace", "datcatypes"], "dtype": ["ctype", "Dvalid", "domstyle", "dltest", "datstyle", "ctest", "djmt", "dvalid", "dltry", "datype", "domype", "DType", " dword", " dype", "dtest", " dmt", "datcolor", "datword", "dcolor", "djtype", " dfield", " dvalid", "dType", "dlcolor", "djuffy", "dfield", "duffy", "dtry", "dbType", "ccolor", "dbfield", "ctry", "dbtype", "datuffy", "dattry", "dype", "datmt", "dbvalid", "dmt", " dType", "domuffy", "dltype", " dstyle", "domtype", "dstyle", "dattype", "djword", "Dtype", "dword", " duffy", "Dfield", "dattest"], "reader": ["buffer", "runner", "proc", "builder", "instance", "rx", "loader", "parser", "read", "row", "iterator", "er", "rs", "wrapper", "inner", "writer", "handler", "stream", "Reader", "ner", "input", "iter", "df", "file", "driver", "data", "r"], "line": ["field", "message", "mark", "cell", "lin", "block", "ln", "section", "header", "link", "item", "row", "lines", "el", "lock", "inline", "ine", "key", "label", "next", "LINE", "l", "char", "page", "record", "entry", "column", "Line"]}}
{"id1": "4778473", "id2": "14609912", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadPropps", "loadProproperties", "initProperties", "initProps", "loadPropproperties", "loadPropperties", "loadprops", "loadPrps", "loadPrdates", "loadPrproperties", "loadProps", "initProproperties", "initPrdates", "initPrproperties", "initPrps", "loadPrperties", "initPrperties", "loadproproperties", "loadprodates", "initProdates", "loadPropdates", "loadProdates", "loadproperties"], "properties": ["sheets", "states", "units", "beans", "posts", "types", "perties", "database", "ports", "notes", "metadata", "prints", "property", "facts", "params", "comments", "prop", "rows", "to", "jobs", "rules", "people", "pro", "tests", "packages", "ps", "changes", "abilities", "settings", "builders", "features", "this", "marks", "holders", "terms", "where", "keys", "policy", "values", "poses", "parts", "projects", "details", "reports", "bugs", "organisms", "relations", "modules", "results", "names", "options", "papers", "members", "objects"], "url": ["http", "ls", "location", "abs", "sl", "config", "open", "ret", "user", "build", "bel", "ur", "b", "Url", "f", "address", "URL", "loader", "p", "id", "uri", "dl", "nl", "resource", "browser", "ref", "str", "mount", "ll", "service", "l", "u", "obj", "char", "kl", "result", "rect", "rl", "file", "sb", "context"]}}
{"id1": "494226", "id2": "3197876", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"linesep": ["myseper", " linespeg", "ineset", "lineset", " lineseper", "despeg", "codesel", " linesip", "linepe", "lineop", "linep", "lineps", "linesel", " linesel", "deseper", "inesip", "ineseps", "mysep", "codesep", "lineep", "linesp", "linespeg", "myspeg", "lineet", "codesp", "inesel", "inespe", "desep", "lineseps", "codeset", "linesip", " lineseps", "inesp", "linesop", "linip", "myseps", "deseps", " linesp", "lineseper", "lineip", "linespe", "lineel", " lineset", "lineeps", " linespe", "inesep", " linesop", "codespe", "inesop"], "fos": ["bo", "fless", " fOS", "flom", "hos", "foS", "yoses", "fo", "utfess", "utfaos", "fom", "bos", "utfom", "flaos", "yos", "futs", "fess", " fess", "boses", "fulloa", "hoss", "eaos", "fortos", "woes", "foses", " foS", " faos", "bot", "fullos", " foa", "foa", "utfuts", "pos", "pows", "fullaos", "flos", "nows", "foes", "wess", "fluts", "fortoa", "po", "foss", "woss", "waos", "faos", "nos", " fo", " futs", "fortaos", "no", "eoes", "utfos", "eOS", "Fos", "flOS", "Fot", " fom", "hoes", "hOS", "fows", "eos", " fows", "wOS", "fortoS", "paos", "yo", "yot", "fOS", " foes", "Foses", "naos", "Fo", "floss", "fulloS", " foss", "fot", "wos", "utfoss", "haos"], "files": ["uploads", "states", "faces", "assets", "parents", "balls", "plates", "artifacts", "workers", "users", "sites", "ports", "iles", "lets", "images", "Files", "frames", "rows", "checked", "roots", "pages", "jobs", "lines", "classes", "obs", "tests", "books", "actions", "ids", "features", "fixes", "scripts", "chains", "bees", "archives", " Files", "fs", "projects", "models", "fields", "videos", "flows", "ails", "events", "thumbnails", "seconds", "items", "objects"], "i": ["multi", "im", "x", "j", "n", "phi", "it", "init", "ini", "ai", "is", "ic", "ri", "ui", "me", "iu", "y", "mi", "ci", "ki", "uri", "t", "ii", "gi", "hi", "ti", "ji", "bi", "index", "si", "I", "u", "ei", "point", "m", "status", "xi", "us", "iq", "cli", "di", "sim", "pi", "ij", "info", "ip", "li", "oi", "ix"], "metaprops": ["metiproeps", "metipproperties", "metapropps", "metapprops", "metAProvperties", "metipprops", "metAProms", "metapros", "metaparperties", "metapars", "metaprobpes", "metapromeps", "metapargs", "metAProbperties", "metaprobms", "metaprovperties", "metAProbps", "metaprps", "metipropes", "metapproeps", "metaprobPS", "metaparps", "metippropes", "metAProvPS", "metapromps", "metiproperties", "metapropes", "metapraeps", "metapropms", "metaprapes", "metaprperties", "metAProPS", "metapraps", "metaproveps", "metAProvps", "metaprms", "metAProbPS", "metaprobs", "metAProveps", "metAProps", "metaprobeps", "metaproeps", "metaprobgs", "metapraperties", "metAProeps", "metaprobps", "metAProbms", "metaproPS", "metAProperties", "metapromPS", "metapproperties", "metiprops", "metapprogs", "metipproeps", "metaproms", "metappros", "metapropperties", "metapromperties", "metaprovps", "metaprogs", "metappropes", "metaprPS", "metapropPS", "metaprovPS", "metaprobperties", "metaproperties"], "itsect": ["isector", "iclex", "icsect", " itsection", "icsection", " itsector", "isec", "itconnect", "isect", "tsect", "itlex", "icsections", " itsections", "ilex", " itlex", "isections", "itsection", "tsection", "itsector", "Itsection", "itsections", "isection", "entsect", " itconnect", "entsections", "Itsector", " itsec", "entconnect", "entsection", "Itsec", "tconnect", "tsections", "itsec", "Itsect"], "section": ["second", "session", "block", "library", "member", "config", "instance", "header", "establishment", "title", "connection", "body", "sector", "definition", "environment", "character", "sections", "row", "area", "test", "subject", "element", "client", "filename", "server", "tag", "sect", "component", "parent", "pair", "setting", "course", "key", "journal", "group", "Section", "name", "label", "container", "service", "page", "sec", "entry", "string", "set", "language", "file", "job", "option", "system", "context", "network"]}}
{"id1": "23666973", "id2": "21656668", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openResourceInternal", "openSteamRAW", "openFileInternal", "openStreamInternal", "openFileRAW", "loadStreamRaw", "openStreamSimple", "openResourceRaw", "loadSteamSimple", "loadSteamRAW", "loadSteamInternal", "openSteamSimple", "openSteamInternal", "openResourceSimple", "loadStreamInternal", "openResourceRAW", "openStreamRAW", "openFileSimple", "loadStreamSimple", "openSteamRaw", "loadSteamRaw", "loadStreamRAW", "openFileRaw"], "filename": ["fn", "path", "nil", "message", "bf", "missing", "description", "location", "prefix", "jpg", "lua", "fil", "title", "f", "metadata", "wikipedia", "reference", "nm", "sql", "mson", "Filename", "download", "fp", "stem", "subject", "uri", "bol", "initial", "png", "length", "ename", "ame", "journal", "river", "src", "name", "original", "mpeg", "LCS", "println", "upload", "username", "txt", "sequence", "directory", "kl", "FILE", "string", "source", "java", "file", "whatever", "document", "ren", "word", "til"], "stream": ["collection", "proc", "http", "window", "sync", "instance", "peer", "present", "export", "sw", "channel", "pipe", "transform", "parent", "content", "where", "mount", "upload", "form", "set", "iter", "port", "clean", "file", "status", "trace", "list", "zip", "buffer", "sl", "then", "link", "response", "old", "row", "download", "control", "conv", "ssl", "impl", "reader", "dd", "engine", "still", "ream", "chain", "stack", "temp", "rest", "output", "valid", " Stream", "draw", "loop", "feed", "body", "pool", "local", "iterator", "resource", "Stream", "pod", "view", "get", "result", "check", "input", "table", "find", "message", "load", "history", "shape", "head", "open", "filter", "socket", "console", "read", "sample", "test", "back", "wrapper", "length", "store", "poll", "next", "event", "cont", "source", "log", "context"], "url": ["path", "http", "mail", "ls", "sl", "cal", "build", "pkg", "bel", "link", "b", "ur", "Url", "ul", "URL", "rel", "pl", "ssl", "uri", "dl", "nl", "loc", "resource", "browser", "gl", "call", "impl", "mount", "str", "mb", "ll", "fl", "external", "l", "char", "kl", "lr", "rl", "file", "job", "web", "r", "hl"], "cl": ["load", "cle", "lf", "class", "ct", "ck", "CL", "lp", "sc", "loader", "pl", "ssl", "dl", "lc", "el", "gl", "cm", "cr", "fc", "Cl", "impl", "tc", "sh", "ll", "fl", "dll", "comm", "kl", "ocl", "acl", "rl", "scl", "cc", "log", "ctrl", "decl", "ctx", "cf", "com", "hl", "c"], "cn": ["fn", "nan", "san", "nc", "ocon", "aren", "atten", "CNN", "CN", "bean", "pan", "tan", "non", "ct", "can", "dn", "bn", "ern", "crow", "css", "cv", "nic", "uan", "enn", "unc", "arn", "cm", "avan", "sen", "ns", "jc", "tun", "unn", "nn", "conn", "gc", "hn", "yn", "cdn", "wn", "tn", "osen", "rn", "cap", "csv", "mn", "oul", "cf", "gn", "pn", "cin"]}}
{"id1": "10361370", "id2": "4501356", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 1, "substitutes": {"hash": ["message", "update", "html", "password", "Hash", "header", "sign", "attribute", "filter", "ashes", "h", "test", "tag", "code", "key", "version", "index", "sum", "crypt", "print", "check", "match", "profile", "render", "array", "handle", "ash"], "saltBefore": [" sALTAfter", " sALTStart", "sALTStart", "SALTBefore", "sALTBefore", " sALTBefore", "SaltPrevious", "saltStart", "saltPrevious", "sALTAfter", "sadePrevious", "sashStart", "saveBefore", "sadeStart", " saltStart", "SaltAfter", "sALTPrevious", "SALTAfter", "sashBefore", "SALTPrevious", "sadeBefore", "sadeAfter", "saveAfter", "sashAfter", "savePrevious", "SaltBefore"], "content": ["output", "path", "message", "Content", "expression", "text", "json", "reason", "html", "password", "description", "time", "config", "present", "example", "title", "body", "raw", "entity", "subject", "initial", "current", "translation", "code", "null", "any", "str", "xml", "txt", "license", "sequence", "cont", "record", "string", "source", "input", "object", "value", "file", "comment", "media", "document", "data", "format", "url", "word", "image", "c"], "saltAfter": ["vintBefore", "valtBody", "valtAfter", "SALTBefore", "sALTBefore", "soltAfter", "sALTafter", "sALTAfter", "saveBody", "valtBefore", "sALTBody", "sintBody", "saveBefore", "sintAfter", "sALTResult", "SaltAfter", "sALTPost", "soltPost", "soltResult", "SALTResult", "saveafter", "saltPost", "SALTPost", "SaltResult", "SALTAfter", "sadeResult", "vintAfter", "valtafter", "SaltPost", "sadePost", "vintBody", "sadeBefore", "sadeAfter", "sintafter", "saltBody", "saveAfter", "saltafter", "sintBefore", "soltBefore", "vintafter", "saltResult", "SaltBefore"], "repeatedHashingCount": ["repeatedHASHCount", "repeatedRashLength", "repeatedHashLength", "repeatedRashingLength", "repeatedRashesCounter", "repeatedRashingCounter", "repeatedHachingCount", "repeatedRashesCount", "repeatedHachingCC", "repeatedHashesCounter", "repeatedHashingcount", "repeatedHashingCode", "repeatedRashesLength", "repeatedRashCount", "repeatedHashCounter", "repeatedHashCode", "repeatedRashingCC", "repeatedRashingCode", "repeatedHachingCode", "repeatedHASHLength", "repeatedHashcount", "repeatedHashesLength", "repeatedHASHCounter", "repeatedHashCC", "repeatedHashingCC", "repeatedRashingcount", "repeatedRashingCount", "repeatedHashesCode", "repeatedHASHcount", "repeatedHashescount", "repeatedRashCode", "repeatedRashCC", "repeatedHashesCount", "repeatedHachingLength", "repeatedRashescount", "repeatedHashingLength", "repeatedHashCount", "repeatedHashingCounter", "repeatedHashesCC"], "digest": ["compest", "commse", "Digse", " digested", "designesting", "digum", " dighest", "designested", "printest", "printEST", " Digester", "debugEST", "Digests", "hashute", "dighash", "algEST", "hashest", "digse", "dest", "digEST", "Digested", "descity", "digert", "digester", "mdest", " digester", "debugest", "fifEST", "digitude", "debugitude", " digse", "digity", "Digester", "diagnum", "digesting", "descse", " digert", "designest", "dfesting", " digitude", "Digum", "hashhash", "algest", "descested", "DigEST", "argest", "descest", "diagnests", "comphash", "fingerest", "fingerEST", "printhest", "dfester", "fifest", "dester", "digute", " digency", " digests", "digested", "Digest", " Digert", "mdester", "extester", "printesting", "extse", "algester", "argEST", "dert", "digency", "extested", "Dighash", "mdested", "designester", "fingerhest", " digesting", "diagnest", " digum", "hashEST", "fifitude", "dfest", "Digute", " digist", "commested", "digist", "compEST", "fingeresting", "dse", " Digested", "argester", " Digest", " digEST", "dighest", " digity", "commity", "debugency", "fifency", "extest", "digests", "dfested", "argested", "Digist", "commest", "dested", "compute", "algested", "mdse", "diagnist"], "digestLength": ["descesterLen", " digesterLen", "digseLen", "digesterLength", "digselength", "descestLen", "digistData", " digestType", "digesterLen", " digestLen", "digestlength", " digesterLength", "descestlength", "descesterlength", "descesterLength", "digesterType", "digesterlength", "digesterData", "digestType", " digesterType", "descesterOffset", "descestLength", "digestedType", "digestedOffset", "digseLength", "digesterOffset", "digseOffset", "digistLength", "digestedlength", "digestLen", "digestOffset", "digestedLen", "digistType", "digistLen", "digestedData", " digestData", "descestOffset", " digesterData", "digestData", "digestedLength"], "i": ["multi", "im", "ms", "x", "init", "n", "phi", "j", "my", "it", "ini", "ai", "is", "ic", "ski", "ui", "me", "q", "iu", "sql", "y", "ci", "gu", "ind", "mi", "ex", "uri", "qi", "client", "ii", "v", "gi", "uu", "ti", "bi", "index", "mill", "si", "I", "u", "err", "print", "ei", "batch", "m", "iter", "xi", "cli", "iq", "z", "di", "sim", "pi", "in", "ip", "li", "ix"]}}
{"id1": "23273706", "id2": "8430178", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectNodeInfo", "getAppTreedata", "getProjectTreedata", "getProjecttreeList", "getProjectNodedata", "getApptreeInfo", "getApptreeData", "getApptreedata", "getProjectTreeInfo", "getProjecttreeInfo", "getProjectListData", "getProjecttreedata", "getProjecttreeData", "getProjectListList", "getAppTreeData", "getProjectListdata", "getProjectTreeList", "getApptreeList", "getProjectNodeList", "getAppTreeInfo", "getProjectListInfo", "getAppTreeList", "getProjectNodeData"], "treeData": ["tableDat", "tableValid", "cacheData", "towerValid", "cachePart", " treeInfo", "tableData", "reeData", "reeList", "tableMap", "reeDat", "towerDat", "treePart", " treeList", "reeMap", "treeValid", "treeDat", "treeMap", "towerData", "tableList", "tableInfo", "TreeInfo", "TreeMap", "reeInfo", "cacheDat", "listDat", "listData", "listPart", " treeDat", "treeList", "statusDat", " treeValid", " treePart", "TreeData", "statusMap", "statusData", " treeMap", "treeInfo"], "filename": ["fn", "path", "output", "nil", "json", "location", "prefix", "save", "jpg", "lua", "generation", "title", "metadata", "fil", "uno", "latest", "URL", "root", "sql", "FN", "Filename", "folder", "local", "fp", "uri", "fps", "KEY", "png", "ename", "fax", "FS", "key", "river", "name", "ername", "original", "println", "username", "URI", "txt", "fs", "directory", "localhost", "FILE", "string", "source", "file", "url", "ames", "temp", "FIL", "SourceFile"], "urlString": ["UrlString", "urlSite", "UrlSite", "uristring", "callstring", "callString", "URLSingle", "lService", "URLSite", "uriString", " urlService", " urlstring", "urlstring", "urlStr", "lString", "uriSite", "callService", "uriSingle", "lstring", "URLstring", "UrlSingle", "Urlstring", "urlSingle", "URLString", "urlService", "callStr", " urlStr", "lStr"], "urldata": [" urlddata", " urldeata", "urldeata", "uriledATA", "urldeatum", "uriledatum", "urldeATA", "urlenata", "uriledata", "urrdatum", "udlenescription", "urldescription", "urlfATA", "urledata", "urlfatum", "urrdata", "urileddata", "urleddata", " urldeatum", " urldatum", "udlenata", " urldeATA", "udldATA", "urldATA", "udlenatum", "urlddata", "urledatum", "urldedata", "udldescription", " urldedata", "urldatum", "urlfata", "udldatum", "urlfescription", "urlenatum", " urldATA", "urlenATA", "udlenATA", "urledATA", "urrdescription", "urrdATA", "udldata", "urlenescription"], "factory": ["votype", "Frozen", "affFactory", "Factory", "vFactory", " fFactory", "Fotype", "Facet", "efrozen", "FFactory", "facactory", "fixture", "facacter", "affactory", "efFactory", " facet", "facault", " fault", " fixture", "facet", "Fixture", "facixture", "vacter", "efactory", "affotype", "facter", "fFactory", "fault", "affacter", "efacet", "Fault", " facter", "frozen", " frozen", "Facter", "vactory", "fotype"], "parser": ["expression", "builder", "fascist", "arser", "x", "pdf", "instance", "jack", "processor", "manager", "loader", "p", "util", " parse", "fp", "io", "au", "conv", " df", "er", "power", "Parser", "apache", "writer", "actory", "xml", "reader", "sup", "utils", "policy", "bank", "Reader", "command", "df", " p", "file", "parse", " parsing", "walker", "php", "dom", "sf"], "u": ["U", "eu", "cu", "it", "ui", "ur", "ul", "tu", "iu", "su", "ut", "p", "o", "h", "util", "io", "au", "uri", "ua", "ou", "uf", "uu", "nu", "hu", "uv", "uid", "ue", "l", "un", "us", "mu", "fu", "url", "r", "ru", "lu"], "is": ["ist", "ims", "ists", "mis", "im", "ms", "isc", "ais", "es", "abs", "iso", "ris", "it", "dis", "ai", "ri", "ic", "sys", "ui", "has", "isl", "lis", "bis", "iu", "isa", "ires", "its", "iss", "io", "ys", "ost", "are", "ins", "obs", "ar", "rys", "il", "ib", "si", "Is", "ir", "fs", "iris", "us", "oss", "ios", "info", "sis", "in", "isi", "IS"], "os": ["mos", "cos", "ms", "es", "OS", "ls", "or", "oos", "ops", "des", "sys", "so", "uts", "ows", "bos", "osi", "et", "bs", "socket", "as", "ss", "dos", "o", "ens", "aos", "io", "css", "ost", "ys", "obs", "pos", "osa", "ox", "oa", "Os", "fs", "us", "oss", "ios", "ros", "oes", "ot", "oses", "s", "out"], "iBufSize": ["iBbufSize", "iLbufLen", "iLbufsize", "iRufSize", "iLbufCount", "iBuffLen", "iBbufSIZE", "iRufSIZE", "iRbufCount", "iRufCount", "iBufCount", "iBbufsize", "iLufsize", "iBulSize", "iBuffLength", "iBphLength", "iBufSIZE", "iBuffSIZE", "iBufLen", "iBufLength", "iRufLength", "iBuffSize", "iLufSize", "iBbufLength", "iLbufSize", "iBuffsize", "iBbufLen", "iRbufSIZE", "iBbufCount", "iBphSIZE", "iBufsize", "iLufLen", "iLufCount", "iBphSize", "iBulLen", "iBulCount", "iRbufLength", "iRbufSize", "iBuffCount", "iBphCount", "iBulsize"], "inBuf": ["outBuf", "inChbuf", "InBuff", "inBufferul", " inBbuf", "inBiguc", "InChuff", "inRuff", "inBigbuff", "InChbuf", "inRuc", "inBluf", "outRBuff", "outBBuff", "InChuf", "InBbuf", "inLbuf", "inBlul", "outRuf", "outRul", "InBBuff", " inRbuff", "inBiguf", "inBufferbuf", "inRBuff", "inBufferuff", "inRul", "inChuf", "inBbuff", " inRuc", "inChuff", "inChBuff", "inBufferBuff", "inRbuff", "outBul", " inBbuff", " inBuc", "inBul", " inRuf", "inBBuff", "InBuf", "outRbuf", "inLuf", "inRbuf", " inRbuf", "inBlBuff", "inBuff", "inLbuff", "outBbuf", "inBigbuf", "inBbuf", "inBlbuf", "inBufferuf", "inBuc", "inRuf", "InChBuff", "inLuc"], "iNumRead": ["iNUMNeed", "iFatFind", "inumDef", "iiNumDef", "aiNumRead", "iNUMRead", "iinumFind", "inumRead", "iNumDef", "iLenRun", "INumPrint", "INumNeed", "InumNeed", "iFatDef", "aiNumberFind", "iNumberRead", "iinumRead", "iRemWrite", "iLenNeed", "aiNumFind", "iiNumRead", "aiNumberRead", "iRemFind", "INumRead", "InumRun", "inumFind", "iiNumFind", "iNUMRun", "iNUMPrint", "iNumNeed", "iNumFind", "iFatRead", "aiNumWrite", "aiNumberWrite", "iLenPrint", "iinumDef", "iNumWrite", "inumRun", "INumRun", "inumPrint", "inumNeed", "iNumPrint", "iRemRead", "iNumberWrite", "iNumRun", "InumRead", "iLenRead", "InumPrint", "iNumberFind"], "f": ["af", "bf", "n", "fo", "fe", "b", "p", "y", "fi", "h", "o", "fp", "t", "fr", "v", "fc", "fm", "fax", "e", "fa", "g", "d", "fac", "w", "l", "fs", "df", "file", "F", "fd", "cf", "tf", "c", "sf"], "inputstream": ["InputStream", "inputstyle", "uploadstream", " inputform", "Inputscreen", "uploadStream", "Inputstream", "uploadform", "uploaddraw", "uploadstyle", "inputStream", " inputdraw", "Inputform", "inputdraw", "iterstream", "uploadscreen", "iterstyle", "Inputstyle", "Inputdraw", "iterStream", " inputStream", "inputscreen", "inputform", "iterscreen"], "document": ["collection", "message", "expression", "application", "html", "node", "window", "model", "template", "n", "present", "database", "ocument", "response", "ml", "raw", "complete", "ree", "browser", "content", "tree", "apache", "version", "doc", "xml", "number", "article", "page", "result", "directory", "command", "object", "m", "df", "language", "file", "media", "Document", "context", "dom", "information"], "nodelist": ["nostestyle", "nodeestyle", "nodedeline", "nodemark", "nODeline", "nnodeelist", "nondeman", "nondelist", " nodeline", "nanodist", "nodeeman", "neodest", "noyeline", "nomelist", "nodestyle", "nanodety", "nodeseline", "neodeeman", "nodedestyle", "nodeelist", "nodeety", "nomist", "nodesist", "noyist", "nODeto", "nosteline", "nodeto", "nODist", "noyeto", "nostelist", "nnodeemark", "nodest", "snodemark", "nodeseto", " nodeseline", "snodeemark", " nodist", "nomest", " nodeselist", "snodeelist", "nodist", "snodeestyle", "nomeman", "nanodelist", " nodeto", " nodeseto", "nodedety", "nodeemark", "snodelist", "nostemark", "snodeeline", "nondest", "neodeman", "nondist", "neodeest", "snodestyle", "nannodeelist", "nannodeist", "neodeist", "nODelist", "nodety", "snodeline", "nodeman", "nodeline", "nodeselist", "nodedelist", "nnodeety", "nodeist", "noyelist", "nodeest", "nodeeline", "nanodemark", "nodedemark", "nannodeemark", "neodist", "nodedist", "nnodeist", "nannodeety", " nodesist", "neodeelist", "neodelist"], "num": ["multi", "proc", "con", "n", "cal", "uni", "UM", "um", "count", "su", "mult", "Num", "nm", "no", "umi", "alph", "coord", "np", "Number", "NUM", "current", "total", "length", "all", "nu", "mon", "number", "dim", "perm", "sum", "net", "result", "nam", "om", "un", "mem", "set", "m", "nom", "zero", "mu", "max", "mn", "man", "umer", "list"], "i": ["multi", "history", "im", "zi", "x", "j", "n", "phi", "it", "init", "my", "ai", "a", "ini", "ie", "ui", "ic", "me", "ri", "major", "q", "iu", "p", "y", "io", "mi", "ci", "ex", "ii", "qi", "gi", "e", "wi", "hi", "ti", "ji", "bi", "this", "index", "si", "I", "l", "ei", "batch", "them", "m", "xi", "us", "iq", "cli", "ami", "z", "di", "sim", "pi", "info", "ij", "in", "ip", "li", "\u0438", "ix"]}}
{"id1": "10214218", "id2": "20208819", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" encrypted", " encryption", "Encrypted", " encode", "Encode", "encode", "Encryption", "decrypted", "decode", "encryption", "Encrypt", "encrypted", "decryption", "decrypt"], "plaintext": ["preterm", "plainpassword", "plainterm", "preText", " Plaintext", "longtext", "prepassword", " plainterm", "plaincontext", "longcontext", "richcontext", "plainText", " plainText", "richText", "plainprotein", "longprotein", " plainprotein", "pretext", "richtext", " Plainpassword", " plaincontext", " PlainText", "longText", " Plainterm", " plainpassword", "richprotein"], "md": ["dr", "ms", "nd", "msg", "mc", "bd", "od", "me", "metadata", "del", "MD", "grad", "der", "cd", "mg", "deb", "mm", "dm", "mt", "ind", "rm", "red", "sm", "dh", "nt", "det", "e", "ld", "doc", "mb", "d", "dd", " mc", "esm", "mac", "mp", " mo", "mk", "mod", "managed", "dig", "mem", "pd", "m", "mo", "mn", "mand", "cmd", "med", "hd", "ng"], "raw": ["message", "rew", "orig", "unsigned", "n", "buf", "unknown", "valid", "draw", "available", "known", "bare", "row", "hook", "rendered", "clear", "all", "hex", " Raw", "box", "original", "sh", "stream", "bytes", "RAW", "good", "cooked", "result", "custom", "base", "extra", " RAW", "input", "clean", "value", "data", "full", "array", "random", "aw", "out", "Raw", "pack"], "hash": ["message", "json", "rh", "html", "password", "mask", "Hash", "hed", "has", "sha", "id", "ssh", "ashes", "h", "ASH", "total", "alert", "tag", "code", "hex", "key", "sh", "zh", "mac", "shadow", "hidden", "sum", "tr", "href", "result", "print", "check", "bh", "cert", "search", "height", "array", "proof", "handle", "cache", "ash"]}}
{"id1": "18504192", "id2": "5237257", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "Copyfile", "CopyStream", " transferFiles", "CopyFiles", " transferfile", "copyStream", " CopyStream", " Copyfile", " transferStream", " CopyFiles", "copyFiles", " CopyFile", "copyfile", " transferFile"], "in": ["IN", "on", "din", "gin", "or", "n", "it", "rin", "is", "ic", "vin", "b", "old", "id", "as", "o", "en", "inc", "from", "mm", "ind", "ins", "el", "up", "edIn", "isin", "l", "In", "input", "i", "inn", "inf", "cin"], "out": ["output", "n", "Out", "it", "b", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "serv", "nt", "at", "g", "w", "l", "k", "net", "err", "OUT", "gt", "ne", "log", "po", "i", "oss", "ot", "s"], "source": ["style", "space", "template", "se", "init", "open", "force", "SOURCE", "volume", "ie", "instance", "sin", "seed", "me", "secret", "shell", "ource", "local", "sample", "scan", "create", "iterator", "from", "subject", "use", "resource", "pse", "Source", "scope", "spec", "back", "ources", "src", "store", "inner", "reader", "access", "service", "position", "sequence", "before", "input", "copy", "file", "match", "parse", "comment", "system", "info", "query", "search", "origin", "start", "inside"], "destination": [" destato", "Destination", "destinator", "Destation", "Destinator", "destation", "seeension", " destinated", "restination", " destregation", "destregation", "coordato", "Destinated", " destation", "seeinated", "seeinator", "destension", "destato", "destification", "comification", " destification", "restinator", "coordination", "restation", "Destension", "comato", "seeination", "destinated", "comregation", "coordification", "restinated", "coordregation", "comination", " destinator", " destension"]}}
{"id1": "1954410", "id2": "1966310", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "label": 0, "substitutes": {"doExecute": ["doEditute", "doCommutes", "doCommExec", "DoExecute", "DoExecit", "doCommit", "DoExecutes", "doExecutes", "doExecit", "doEditit", "DoExecExec", "doExecExec", "doEditutes", "doCommute", "doEditExec"], "mapping": ["smappings", " mappings", "mapper", "Mappings", "mapped", " mapped", "Mapper", "Mapped", " mapper", "smapped", "mappings", "Mapping", "smapper", "smapping"], "form": ["path", " forms", "orm", "session", "owner", "self", "template", "config", "type", "f", "raw", "forms", " Form", " FORM", "subject", "map", "Form", "parent", "fc", "view", "formed", "command", "FORM", "m", "sam", "app", "format"], "request": ["http", "window", "se", "instance", "sw", "parent", "version", "upload", "Request", "query", "url", "report", "QUEST", "template", "create", "allow", "this", "impl", "quest", "container", "_", "w", "remote", "project", "def", "document", "application", "session", "Upload", "model", "address", "Exception", "reset", "frame", "client", "resource", "current", "server", "xml", "view", "input", "first", "order", "question", "message", "open", "user", "reference", "true", "initial", "req", "store", "post", "cont", "command", "context", "host"], "response": ["output", "message", "application", "session", "connection", "send", "ce", "re", "respond", "frame", "resp", "server", "content", "write", "view", "xml", "Response", "result", "print", "status", "reply", "sp", "document", "success", "res", "report"], "errors": [" mess", " steps", " messages", " success", " managers", " logs", " messenger", " sessions", " manager", " storage", " changes", " fails", " requests", " flashes", " status", " statements", " error", " states", " problems", " state", " warnings", " flash", " updates", " moves", " elements", "Mess", "ages", " Messages"], "isMultipart": ["isMultipod", "isMultipain", "isMultIPare", "isMultiade", "isMultiplod", "isMultiIPod", "isMultifarts", "isMultiparts", "isMultosparts", "isMultiipart", "isMultiIPade", "isMultipare", "isMultIPain", "isMultiarts", "isMultifare", "isMultiIPain", "isMultiplarts", "isMultiIPare", "isMultiIPart", "isMultIPade", "isMultiiparts", "isMultifart", "isMultiipare", "isMultospart", "isMultIParts", "isMultospain", "isMultiart", "isMultiipain", "isMultiod", "isMultospare", "isMultiplade", "isMultIPod", "isMultipade", "isMultiplart", "isMultiipade", "isMultifain", "isMultiipod", "isMultiIParts", "isMultIPart"], "mailInstance": ["flexance", " mailance", " mailInst", "mailinstance", " mailBuilder", " MailInstance", " Mailinstance", "emailance", "emailBuilder", "mailance", " MailBuilder", "flexInstance", "mailInst", "flexinstance", "flexInst", "emailinstance", " MailInst", "mailBuilder", "emailInstance", "emailInst", " mailinstance"], "fields": ["field", "states", "faces", "strings", "links", "balls", "properties", "headers", "workers", "types", "orders", "posts", "users", "ports", "locks", "checks", "prints", "plugins", "drivers", "comments", "images", "frames", "sections", "qs", "forms", "rows", "boxes", "rules", "views", "flags", "pages", "packs", "files", "dates", "lists", "bits", "lines", "tags", "classes", "levels", "packages", "tests", "holders", "features", "members", "terms", "days", "keys", "parts", "details", "models", "reports", "phones", "relations", "lights", "modules", "names", "groups", "atts", "objects", "services"], "attachments": ["achensions", "attensions", " attachions", "payances", " attachresses", "attitions", "attachMENTS", "payements", "attachitions", "acheements", "attachensions", "Attachments", " attachements", "attachions", "achMENTS", "acheances", "Attachresses", "achements", "attMENTS", " attachitions", "AttachMENTS", " attachances", "payitions", "achitions", "Attachions", "achments", "attachresses", "attachements", "payments", "achresses", "attments", "achions", "Attachensions", "attachances", "Attachitions", "acheitions"], "items": ["cases", "links", "orders", " Items", "images", "Items", " images", "its", "rows", "pages", "qs", "files", "lines", "tests", "packages", "photos", " files", "actions", "ids", " results", "members", "ips", "archives", "keys", "parts", "reports", "phones", "apps", "resources", "results", "names", " samples", " inputs", "issues", "groups", "events", "objects", "services"], "iter": ["each", "ser", "ite", "ator", "iner", "init", "it", "Iter", "loop", "orient", "li", "its", "read", "iterator", "test", "maker", "altern", "re", "older", "ind", "dir", "er", "oper", "loc", "el", "cmp", "inner", "store", "writer", "ait", "reader", "inter", "coll", "ipper", "tr", "ter", "Iterator", "result", "tif", "upper", "ner", "former", "set", "gener", "i", "walker", "outer", "list", "order"], "item": ["cell", "member", "instance", "it", "change", "attribute", "att", "element", "atom", "inner", "other", "status", "file", "job", "url", "word", "zip", "on", "json", "internal", "or", "template", "link", "entity", "claim", "row", "ex", "group", "name", "obj", "anything", "details", "entry", "object", "data", "ip", "attr", "add", "local", "area", "mm", "er", "resource", "up", "rule", "xml", "unit", "one", "page", "stat", "app", "order", "step", "addr", "type", "detail", "raw", "Item", "initial", "el", "spec", "key", "related", "store", "module", "event", "record", "layer", "match", "info", "image", "ix", "single"], "aux": ["af", "eu", "abs", "cu", "auto", "used", "uds", "aim", "aos", "area", "av", "airs", "au", "ex", "AU", "etc", "ox", "lim", "aff", "buff", "fax", "uf", "du", "aus", "ax", "fx", "net", "fuck", "imp", "pet", "extra", "tx", "us", "vers", "mu", "max", "fu", "uff", "ux", "off", "foo", "fam", "pad", "aw", "ras", "ups", "ix", "fat"], "part": ["top", "block", "member", "peer", "tmp", "and", "zone", "bound", "card", "parent", "component", "pre", "inner", "version", "job", " parts", "work", "art", "word", "list", "split", "pos", "pair", "photo", "group", "mod", "print", "partial", "object", "sp", "Part", "start", "temp", "html", "add", "prefix", "section", "worker", "person", "local", "relation", "PART", "pod", " Part", "pet", "tx", "join", "admin", "message", "party", "patch", "step", "pkg", "detail", "piece", "tab", "p", "api", "sample", "pt", "par", "wrapper", "comp", "parts", "half", "base", "point", "primary", "layer", "pad", "format"], "baos": ["booses", "baops", "waols", "boOS", "cao", "kaops", "pois", "bais", "waoss", "caOs", "bios", "taos", "taoss", "baols", "pooss", "kaoss", "bio", "bao", "booss", "baOs", "kais", "vaOs", "caoss", "caOS", "vaols", "boOs", "tao", "biOS", "boos", "kaos", "baOS", "poops", "vaoss", "caos", "poo", "baoses", "caols", "bioses", "vaos", "tais", "poOS", "taOs", "waOs", "baoss", "waos", "poos", "taops", "pooses", "boo"], "body": ["output", "buffer", "message", "binary", "text", "json", "html", "description", "mail", "plain", "template", "head", "header", "detail", "loop", "title", "shell", "send", "bill", "rel", "Body", "size", "subject", "note", "default", "ody", "t", "content", "summary", "pass", "tree", "null", "name", "post", "foot", "business", "base", "port", "file", "log", "ODY", "comment", "data", "format", "tail", "display", "scroll", "layout", "report"], "preferencesInstance": ["prefiesinstance", "preffiesinstance", "prefferencesinstance", "prefutesObj", "preferencesObj", "preffiesObj", "preffiesImpl", "prefancesInstance", "prefutesImpl", "prefancesObj", "preferencesinstance", "prefancesImpl", "prefutesInstance", "prefferencesImpl", "prefancesinstance", "prefiesInstance", "preferencesImpl", "prefferencesInstance", "prefiesImpl", "prefferencesObj", "prefutesinstance", "prefiesObj", "preffiesInstance"]}}
{"id1": "5543349", "id2": "13368520", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"loadMFileViaWeb": ["loadMFileByWeb", "loadMFileUsingWeb", "loadMFilesviaWe", "loadMFilesviaweb", "loadMFileviaWe", "loadMFilesViaweb", "loadMFileViaWe", "loadMFileviaweb", "loadMFilesViaWeb", "loadMFileviaWeb", "loadMFileByWe", "loadMFileByweb", "loadMFilesViaWe", "loadMFileUsingweb", "loadMFileViaweb", "loadMFileUsingWe", "loadMFilesviaWeb"], "codeBase": ["uribase", "codeMark", " codeRoot", "fileBase", "CodeRoot", "fileBased", "filebase", "codebase", "CodeBased", "uriMark", "codeBased", "uriBase", "CodeBase", " codebase", " codeBased", " codeMark", "CodeMark", "uriBased", "Codebase", "fileRoot", "codeRoot"], "directoryAndFile": ["DirectoryandModel", " directoryAndDirectory", "directoryOrType", " directoryOrFile", "directoryandFile", "directoryAndType", "DirectoryandPath", "DirectoryAndFile", "directoryAndPath", "directoryButFile", " directoryAndfile", "directoryOrPath", "directoryOrDirectory", "directoryAndDirectory", " directoryOrDirectory", "DirectoryAndPath", "Directoryandfile", "directoryandPath", "directoryandfile", " directoryAndType", " directoryOrType", " directoryOrfile", "DirectoryandFile", "DirectoryAndModel", "directoryOrfile", "directoryOrFile", "directoryOrModel", "directoryandDirectory", "directoryButfile", "DirectoryAndfile", "directoryAndfile", "directoryButDirectory", "directoryandType", "directoryAndModel", "directoryandModel", "directoryButType"], "mFileName": ["mFilePath", "mSourceFileNames", "MFilenameNames", "mSourceFileName", "mFilenamePath", "mFolderName", "mTablePath", "mFolderPath", "mfileSource", "mFileType", "MFilename", "mfileName", "MFileName", "mFilename", "MFilePath", "mFilePart", "mFilenameSize", " mFileFile", " mfileName", "mFoldername", "mfilePath", "mSourceFileFile", "mfileFile", "mFilenameNames", "mFolderPart", "mSourceFilePath", "mFilenameFile", "MFileNames", "MFilePart", " mFileType", "MFileBody", "MFilenameName", "MFilenamePath", " mfileType", "mFilenameSource", "mFilenameType", "mfileSize", "mTablename", "MFileSource", "MFilenameSource", "mFilenamename", "mFileBody", "mFileFile", "mFileNames", "mFilenameName", "mfileType", "MFilenameSize", "mTablePart", "MFilenameBody", " mfileFile", " mfilePath", "MFilenamename", "mFileSize", "MFileSize", "mFileSource", "mSourceFileBody", "mTableName", "mFilenamePart", "mSourceFileSize", "mfileNames", "mfileBody", "mSourceFileSource", "mSourceFileType", " mFilePath", "mFilenameBody", "MFilenamePart"], "code": ["core", "cell", "program", "hello", " coding", "to", "scene", "t", "content", "component", "sequence", "form", "stroke", "coded", "query", "zip", "buffer", "text", "json", "template", "create", " to", "e", "done", "script", "l", "string", "comment", " content", "data", "Code", " data", "output", "expression", "html", "n", "body", "frame", "result", "input", "copy", "action", "func", "message", "reason", "node", "x", "time", "ce", "test", "length", "hex", "module", "cod", "codes", "ode", "coe", "event", "command", "source", "value", " Code", "c", "cache"], "function": ["fn", "expression", "foundation", "Function", "program", "method", "instance", "false", "callback", " func", "user", "normal", "and", "connection", "class", "f", "relation", "from", "feature", "closure", " command", "resource", "production", "foreign", "component", "library", "functional", "module", "process", "fun", "handler", "service", "family", "event", "result", " functions", " program", "form", "command", " functionality", "partial", "object", "action", "python", "file", "value", "job", "func", " computation", "document", "full", " Function", "FUN", "lambda", "role"], "url": ["out", "http", "mail", "location", "sl", "open", "build", "bel", "link", "ur", "b", "Url", "address", "URL", "p", "rel", "io", "re", "ssl", "dl", "nl", "loc", "resource", "el", "browser", "gl", "str", "mount", "ll", "get", "l", "char", "base", "rl", "file", "log", "job", "web", "r", "li", "hl", "il"], "in": ["out", "IN", "din", "gin", "n", "it", "rin", "is", "ic", "sin", "f", "body", "p", "inc", "from", "ind", "ins", "bin", "inner", "null", "reader", "stream", "isin", "l", "In", "input", "source", "file", "i", "info", " din", "inn", "r", "inf", "cin"], "inReader": ["innerReader", "fromRunner", "cinRunner", "cinWriter", "innerRunner", " inLine", "innLine", "innReader", "fromWriter", "inRead", "InReader", " inStream", "fromReader", "fromLoader", "inBuilder", " inLoader", "cinLoader", "inStream", "inRunner", "innerR", " inR", "fromR", "innerBuilder", " inWriter", "inLoader", " inBuilder", " inRead", "inWriter", "innStream", " inRunner", "InStream", "InRead", "innRead", "InLine", "cinReader", "inLine", "inR", "fromBuilder"], "line": ["message", "text", "cell", "lin", "block", "ln", "section", "header", "eline", "change", "link", "zone", "lane", "entity", "row", "sample", "frame", "stay", "element", "liner", "email", "le", "e", "inline", "ine", "key", "error", "rule", "ode", "LINE", "number", "l", "char", "page", "online", "sequence", "record", "entry", "string", "print", "point", "port", "stroke", "file", "comment", "lined", "column", "Line"], "end": ["load", "close", "block", "open", "class", "id", "END", "export", "reset", "ed", "length", "run", "e", "stop", "next", "ended", "End", "log", "info", "data", "start", "begin", "list"]}}
{"id1": "13666876", "id2": "11032546", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformOneSourceFile", "transformMultiFile", "TransformSingleRecord", "transformsingleRecord", "processSingleFiles", "transformSingleRecord", "transformMultiRecord", "TransformSimpleFile", "processsingleFile", "transformSimpleFile", "transformSimplePage", "processSinglefile", "transformOneFile", "transformsingleModel", "transformMultiModel", "transformSingleModel", "processSingleFile", "transformMultifile", "transformSimpleRecord", "processSingleSourceFile", "transformSinglefile", "processsingleFiles", "transformSimpleModel", "transformsingleFiles", "transformMultiPage", "transformOnefile", "transformOneFiles", "TransformSimpleRecord", "transformsinglePage", "transformSingleFiles", "TransformSimplePage", "transformsinglefile", "transformSinglePage", "TransformSingleModel", "transformsingleSourceFile", "TransformSinglePage", "transformSingleSourceFile", "processsingleSourceFile", "transformsingleFile", "transformMultiFiles", "TransformSingleFile", "transformMultiSourceFile", "processsinglefile", "TransformSimpleModel"], "xed": ["wxed", "Xeded", "xED", " xied", "xeds", "exed", "rxed", "wxEd", "exeded", "wxented", "passed", "passED", "xeded", "uxed", "txer", "txED", "wxred", "Xeds", "pxeds", "uxied", " xED", "txeds", "xied", "uxented", "xer", "rxED", "pxed", "Xed", "xred", "pxeded", " xented", "passred", "exeds", "pxED", "wxied", "XED", "Xer", "rxeds", "wxED", "xented", "exED", "rxer", "xEd", " xEd", "uxED", "passEd", " xred", "txed"], "node": ["our", "load", "n", "link", "and", "seed", "entity", "no", "row", "create", "Node", "scene", "note", "feature", "map", "channel", "resource", "right", "parent", "component", "station", "hand", "tree", "name", "process", "ode", "index", "view", "edge", "day", "post", "one", "event", "directory", "line", "stage", "remote", "entry", "object", "set", "job", "range", "array", "word", "image", "de"], "dob": ["dod", "doy", " doy", " dobb", "adoy", "dobar", "drod", "adob", "Dob", " dab", " dobar", "drob", " dod", "diod", "Dab", "dobb", "drab", "dab", "drobb", "Doy", "diobb", "adab", "diob", "diab", "Dobar", "adobar"], "mySrc": ["MySsrc", "myDesRC", "myInsfc", "MySRC", "mySourceource", "myDesources", "mySelsrc", "myInssrc", "mySfc", "myAsRC", "MySources", "myDessrc", "mySRC", "mySourcesrc", "mySingRC", "mySourcerc", "mySingfc", " mySRC", "MySrc", " mySsrc", "mySources", "myDesrc", "myAsource", "mySelRC", "mySource", "mySelources", "myAsrc", "mySourceRC", " mySfc", "mySingsrc", "myInsRC", "mySelrc", "myInsrc", "myAssrc", "MySource", "mySingrc", "mySsrc"], "mySrcF": ["mySufO", "mySsrcO", "myMrcFP", "mySourceV", "mySrtF", "mySsrcC", "mySRCC", "mySrcC", "mySrtP", "mySRCF", "mySRCI", "mySsrcF", "myMrcF", "mySufFP", "myMrcO", "mySrcV", "mySsrcI", "mySrcI", "mySourceO", "mySourceF", "mySufF", "myMourceF", "mySrcP", "myMourceFP", "mySsrcV", "mySourceFP", "mySRCP", "mySsrcFP", "mySrtI", "myMourceV", "mySrcFP", "myMrcV", "myMourceO", "mySsrcP", "mySrcO", "mySufV", "mySrtC"], "myOutF": ["myoutL", "myInL", "myCoF", " myOutL", "myNetW", "MyOutV", "mysNetF", "MyOutF", " myOutFile", "myNetFile", "myoutC", " myOutV", "myObjF", "myOutputF", "myOutL", "myNetL", "MyInV", "MyInF", "mysOutL", "MyInFs", "mysNetW", "myNetE", "mysNetL", " myNetE", "myOutFL", "myOutFs", " myOutE", "MyOutFs", "myoutV", "myOutputL", "myObjFile", "myInFs", " myoutC", " myoutL", "myArtF", " myNetF", "myOffDF", "myArtFL", "myObjV", "myOffF", "myOutputDF", "myOutE", "myArtL", "mysOutF", "myOutputV", "MyInFile", "myCoFL", "myOutW", "myObjFs", "myInF", " myoutV", "myNetF", "myOutFile", "myCoW", "myoutF", " myNetFile", "myOutputE", "myInFile", "myOutV", "myOutputC", "myOutC", "myArtW", "myOutputFile", "myInV", " myNetDF", " myOutC", "mysNetFL", "myCoL", "mysOutFL", " myoutF", "myOutputFs", "myOffFile", "mysOutW", "myOutDF", "myNetFL", " myOutDF", "myInC", "myOffE", "MyOutFile", "myNetDF"], "co": ["nc", "oc", "cos", "con", "cu", "cal", "cover", "cho", "fo", "ror", "lo", "so", "ck", " Co", "can", "no", "o", "col", "coord", "ce", "ico", "cv", "ci", "io", "cs", "loc", "lc", "flo", "xc", "Co", "yes", "CO", "fc", "cm", "ho", "cod", "cop", "aco", "ace", "obj", "go", "gc", "cl", "copy", "cc", "wo", "po", "ctrl", "ko", "mo", "ro", "roc", "com", "ca", "soc", "coll", "c", "cache"], "x3dvFile": ["x3dbFilename", "x3dvsFile", "x3dVPath", "x3cdVPath", "x3dtfile", "x3pdbFilename", "x3dvfile", "x3dVfile", "x3dbString", "x3dbfile", "x3pdbFile", "x3davFilename", "x3dvFilename", "x3davPath", "x3davFile", "x3dvPath", "x3dbFile", "x3pdbfile", "x3cdVFilename", "x3dVString", "x3dVFile", "x3dtFile", "x3dvsFilename", "x3pdvFilename", "x3dVFilename", "x3dvString", "x3pdbString", "x3dtFilename", "x3dvsPath", "x3dtString", "x3pdvFile", "x3pdvString", "x3cdVFile", "x3cdvFilename", "x3pdvfile", "x3cdvPath", "x3cdvFile"], "fis": [" fiss", "biss", "fisi", "fileis", "friss", "frisi", "bie", "bis", "fileiss", "fiss", " fiz", " fie", "fliz", "bisi", "flis", "flires", " fisi", "fliss", " fires", "fiz", "fie", "frie", "fileiz", "fires", "fileires", "fris"], "gzos": ["gtnos", "gzo", "gties", "goss", "ssloss", "sslos", "gtoss", "gaos", "zaos", "ggos", "gos", "gsops", "gznos", "ziposs", "zies", "zipnos", "gzaos", "zoes", "gtoes", "zoss", "zops", "zos", "gzies", "zipos", "gtos", "gzops", "sslo", "gsoss", "ggoes", "go", "gzoss", "gtops", "sslaos", "ggops", "zo", "zipops", "gzoes", "gsnos", "ggies", "gsos"], "buf": ["buffer", "Buffer", "orig", "block", "font", "img", "pkg", "var", "bar", "b", "aka", "bag", "raw", "Buff", "tab", "cat", "cv", "seq", "conv", "fb", "arr", "buff", "ref", "uf", "emb", "cast", "box", "bus", "vec", "cb", "wb", "bytes", "cam", "good", "batch", "mem", "cap", "mu", "max", "br", "cf", "cmd", "rb", "cur"], "ret": ["out", "elt", "deg", "arg", "val", "rets", "ext", "et", "ry", "end", "pret", "test", "re", "att", "mt", "red", "ft", "v", "back", "continue", "nt", "ref", "rt", "aux", " Ret", "alt", "ctr", "inter", "ptr", "r", "ter", "obj", "err", "Ret", "tr", "print", "cont", "gt", "def", "iter", "RET", "cert", "res", "repl", "cmd", "len"]}}
{"id1": "21182766", "id2": "18489832", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 0, "substitutes": {"load": ["loads", "add", "loaded", "save", "init", "config", "open", "build", "link", "loader", "read", "download", "create", "test", "register", "use", "map", "require", "Load", "store", "process", "name", "define", "dump", "get", "check", "set", "file", "parse", "construct", "system", "append", " reload", "include", "pack", "cache"], "propsName": ["propertiesName", "prorsName", "pepsFile", "pepsname", "provsFile", "prorsFile", "pevsname", "propertiesname", "provsName", " propsFile", "propertiesStr", "pepsName", " propsStr", "pepsPath", "prorsPath", " propertiesStr", "propsname", "pevsFile", "provsPath", "proPSPath", "pevsName", "proPSname", " propsname", "pevsPath", "provsname", "propsPath", " propertiesFile", "proPSFile", "proPSName", "prorsStr", "prorsname", " propertiesName", " propertiesname", "propsStr", "propsFile", "proPSStr", "propertiesFile"], "props": ["prept", " procs", "prcs", "probes", "Props", "properties", "prrs", "robpt", "schers", "prebes", "scheperties", "scheps", "propt", "procs", "robps", "preps", "preperties", "robbes", "prps", "prbes", "robperties", " prors", "prperties", "schevs", "Provs", " properties", "Procs", "prpt", " provs", "prors", "provs", "Properties", "Prors"], "url": ["path", "http", "ls", "abs", "location", "sl", "config", "open", "user", "build", "ur", "Url", "f", "address", "ul", "loader", "URL", "rel", "uri", "nl", "loc", "resource", "browser", "ref", "this", "str", "mount", "ll", "gb", "service", "char", "l", "obj", "err", "result", "lr", "cl", "rl", "file", "sb", "context"]}}
{"id1": "21488518", "id2": "11968328", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"createNew": ["CreateNext", "getResource", "getNext", "CreateNew", "getNew", "dataNext", "CreateFresh", "getFresh", "dataFresh", "createFresh", "dataNew", "dataResource", "CreateResource", "createNext", "createResource"], "name": ["path", "part", "missing", "description", "password", "prefix", "n", "template", "now", "time", "type", "normal", "handle", "title", "address", "old", "body", "id", "nm", "no", "common", "local", "size", "end", "create", "lat", "use", "client", "resource", "current", "filename", "NAME", "ename", "ame", "code", "key", "null", "version", "index", "none", "one", "only", "named", "event", "base", "string", "source", "action", "Name", "file", "value", "names", "data", "format", "alias", "word"], "in": ["IN", "din", "gin", "con", "asin", "it", "rin", "is", "vin", "mc", "b", "body", "p", "en", "from", "mm", "ind", "al", "ins", "t", "ma", "bin", "inner", "reader", "xml", "get", "isin", "r", "In", "err", "input", "source", "file", "i", "data", "s", "inn", "mat", "c", "cin"], "length": ["path", "buffer", "message", "text", "shape", "description", "password", "count", "body", "enc", "read", "size", "duration", "Length", "total", "content", "stream", "position", "bytes", "sequence", "input", "amount", "padding", "value", "max", "data", "height", "len"], "contentType": ["ContentTypes", "Contenttype", "contentLength", "mediatype", "ContentLength", " contentLength", "mediaTypes", " contentTypes", "mediaType", "contenttype", "mediaLength", " contenttype", "contentTypes", "ContentType"], "dest": ["path", "lit", "disk", "self", "orig", "tmp", "dat", "prop", "folder", "cat", "dir", "coord", "loc", "resp", "parent", "oe", "this", "src", "home", "d", "wb", "obj", " destination", "result", "cont", "Dest", "mem", "source", "copy", "trans", "iter", "nom", "table", "target", "comb", "origin", " dst", "there", "temp", "rest", " Dest"], "out": ["output", "cos", "ion", "con", "n", "Out", "ent", "it", "sys", "can", "o", "aos", "to", "col", "en", "os", "io", "OU", "end", "ex", "conv", "t", "client", "op", "outs", "up", "serv", "ou", "write", "null", "external", "w", "obj", "go", "net", "conn", "OUT", "copy", "set", "port", "file", "log", "po", "oss", "co", "off", "s", "res", "outer"], "request": ["message", "QUEST", "open", "user", "move", "response", "requ", "reference", "params", "claim", "reset", "create", "ire", "re", "current", "require", "relative", "library", "pair", "forward", "req", "ask", "quest", "result", "enter", "input", "child", "Request", "select", "query", "search", "url", "remove", "push", "report", "begin"]}}
{"id1": "15737836", "id2": "9109613", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["quit", "load", "update", "add", "save", "touch", "link", "move", "database", "del", "download", "create", "execute", "Delete", "lete", "clear", "write", "disable", "dump", "get", "destroy", "drop", "set", "clean", "select", "remove", "insert", "de"], "site": ["path", "isite", "http", "session", "ite", "node", "template", "config", "se", "sites", "item", "ze", "sys", "link", "environment", "sample", "scan", "test", "server", "pse", "settings", "at", "e", "course", "station", "group", "store", "name", "rule", "index", "unit", "service", "page", "sit", "Site", "base", "ste", "remote", "source", "set", "localhost", "theme", "file", "domain", "software", "chain", "info", "data", "network"], "dbo": ["odbo", "gBO", "Dbon", "odpo", "sdBO", "ddbu", " dado", "Dado", "sdbo", "DBo", "ddado", "Dpo", "pbu", "Dbu", "DBO", "drapo", "sdbu", "ddBo", "debugBo", "dbon", "lbo", "drabo", "draBo", "dBo", "dambo", " dBo", "delbo", " dbu", "pbo", "ddBO", "dBO", "odbu", "lBo", "debugpo", "ppo", " dbon", "lambo", "ddpo", "delpo", "gbo", "Dbo", " dBO", "debugambo", "lpo", "dbu", "dpo", " dambo", "gbu", "delbu", "dmu", "delmu", "drabon", "Dmu", "debugbo", "dado", "odBo", " dpo", "ddbo", "pmu"], "connection": ["output", "bo", "collection", "management", "session", "connect", "db", "cone", "Connection", "con", "application", "ion", "pointer", "function", "location", "binding", "config", "auto", "open", "database", "generation", "response", "statement", "condition", "link", "controller", "manager", "reference", "socket", "usage", "pool", "console", "character", "relation", "creator", "associated", "subject", "closure", "client", "resource", "current", "server", "created", "library", "settings", "office", " Connection", "writer", "communication", "government", "operation", "engine", "handler", "position", "container", "established", "connected", "net", "directory", "conn", "command", "table", "information", "po", "system", "chain", "document", "context", "city", "intention", "c", "computer", "network"], "preparedStatement": [" preparedQuery", "pparedStatus", "pretparedStatus", "preparedAdapter", "prelatedDevice", "preendedStatement", " preachedStatement", "prepparedCall", "preculatedQuery", "perachedComment", " prefixedCopy", "prepparedstatement", "Preparedstatement", "premittedComment", "prepletedStatement", "premedStatus", "postppedStatement", "preinitializedStatement", "prearedCall", "prepletedstatement", "preachedComment", "preculatedSQL", "prepferredStatement", "prepparedSQL", "prearedListener", "preparedStat", "prepferredstatement", "preachedAdapter", "preferredSQL", "paredStatement", "previsedStat", "pretparableStatus", "preparedStyle", "PrearedStatement", " preachedStat", "prepparedStatement", " preparedCall", "postparedstatement", " preparedGrant", "PreparedDevice", " preachedCall", "prearedStatement", "prejectedstatement", "prejectedCopy", "premedStatement", "premittedStyle", "prejectedQuery", "Prearedstatement", "prepparedQuery", "pparedQuery", " preparedstatement", "preparedCall", "previsedStatement", "pparedStatement", "prelatedComment", "preformedStat", "preendedQuery", "postparedStatement", "preinitializedStyle", " prefixedQuery", "previsedStatus", "preparedSQL", "PrearedComment", "pparedStat", "preachedstatement", "premedListener", "perparedComment", "prejectedStatement", "preferredStatement", "preinitializedComment", "prefixedCall", " prefixedStatement", "perachedAdapter", "prefixedQuery", "prearedCopy", "prearedStatus", "prepletedStat", "PreppedStatement", "preformedCall", "paredStat", "prefixedCopy", "preppedStatus", "pretparedStatement", "perparedStatement", "PrearedDevice", "preparedDevice", "prelatedstatement", "postparedCall", "preparedComment", "pretparableListener", "prearedstatement", "paredStatus", "preinitializedAdapter", "prefixedStatement", "prepletedComment", "postppedCall", "PreparedComment", "preparedStatus", "perparedStyle", "preferredQuery", "prepletedGrant", "paredQuery", "prelatedStatement", " preparedStat", "pretparableStatement", "preppedstatement", "perachedStyle", "preformedGrant", " preachedGrant", "prearedStat", "preculatedstatement", "premittedAdapter", "PreppedQuery", "preachedCall", "prearedComment", "perparedAdapter", "preparableListener", " prefixedstatement", "PreparedStatement", "perachedStatement", "preparableStatement", "prearedQuery", "PreparedQuery", "prearedSQL", "pretparedListener", "preferredstatement", " preparedCopy", "preachedGrant", "preparedQuery", "prepferredQuery", "preppedCall", "preparedListener", "preparableStatus", "prepletedDevice", "preppedQuery", "preachedStyle", "prepferredSQL", "preparedstatement", "postppedstatement", "premittedStatement", "previsedQuery", "preparedCopy", "preferredCall", "preparedGrant", "preendedstatement", "preppedStat", "preformedStatement", "preculatedStatement", "prepletedCall", "preachedStatement", "prearedDevice", "prefixedstatement", "preachedStat", "Preppedstatement", "preppedStatement"], "resultSet": [" resultList", "dataStream", "characterStream", "ResultList", "rowHandle", "resultHandle", "resultTime", "ResultSum", "rowSource", " resultHandle", "ResultSession", " resultSession", "resultList", "characterSet", "ResultStream", "responseStream", "characterSum", "resultPath", "resultsSet", " resultPath", "responseSet", "responseUn", "ResultSource", " resultSource", "resultSource", "dataTime", " resultTime", "resultsPath", " resultStream", "resultSession", "resultUn", "resultsUn", "ResultTime", "ResultPath", "ResultSet", "ResultHandle", "resultsList", "rowSession", "resultStream", "resultSum", "ResultUn", "dataSet", "rowSet", " resultSum", "resultsStream"], "chkSql": ["chKInsq", "chkSyl", "chkDq", "chkRSyl", "chKSk", "chKDql", "chKDQL", "chkRSQL", "chkDQL", "chkDql", "chKInsql", "chkSq", "chKSQL", "chkStrQL", "chkDyl", "chkInsql", "chKInsQL", "chKSyl", "chKSql", "chKSq", "chkSk", "chkInsq", "chkRSql", "chkRSk", "chkInsQL", "chkSQL", "chkDk", "chKDyl", "chKDk", "chkStrq", "chkStrql"], "selfDefinePath": ["selfdefinesPath", "selfDefiningKey", "selfDefidePath", "selfDefineDir", "selfdefinePath", "selfDefiningPattern", "selfDelinepath", "selfDefiningPath", "selfDefiningpath", "selfDefinespath", "selfDefidePattern", "selfDefiningDir", "selfDelinePath", "selfDefINEPath", "selfDefinePattern", "selfDeliningpath", "selfDefiningSet", "selfDefidepath", "selfDefINEKey", "selfDelineKey", "selfdefinesPattern", "selfDefinesDir", "selfDeliningSet", "selfdefinePattern", "selfDelineSet", "selfDefineKey", "selfDeliningKey", "selfdefinepath", "selfdefineDir", "selfDefinedPath", "selfDefinedpath", "selfDefINESet", "selfDefinesPattern", "selfdefinesDir", "selfDefinesPath", "selfDefineSet", "selfDefinedKey", "selfDefideDir", "selfDefinedSet", "selfdefinespath", "selfDefINEpath", "selfDefinepath", "selfDeliningPath"], "sqlStr": ["sqlSt", "qlName", "qlString", "SQLStr", " sqlWr", "SQLWr", "sqlWr", "sqString", "SQLstr", " sqlName", "SQLSt", "sqWr", " sqlString", "qlStr", " sqlstr", "sqStr", " sqlSt", "sqName", "sqstr", "sqlstr", "sqlName", "qlstr", "sqlString", "sqSt"]}}
{"id1": "14882263", "id2": "8815137", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": [" uploadActionOccceived", " uploadEventPeruted", " uploadActionOccuted", " uploadEventPerformed", " uploadActionOccformed", " uploadEventOcclected", " uploadActionPeruted", " uploadActionRelected", " uploadEventPerceived", " uploadEventOccceived", " uploadActionPerlected", " uploadEventOccuted", " uploadEventOccformed", " uploadActionReceived", " uploadEventPerlected", " uploadActionOcclected", " uploadActionPerceived", " uploadActionReformed", " uploadActionPerformed", " uploadActionReuted"], "evt": [" emt", " emte", "evte", "evtm", " EVtm", " emtd", " evte", "evtd", " EVtd", " EVte", " EVt", " evtm", " emtm", " evtd"], "chooser": ["Choicer", "chener", "compener", "choicker", " choose", "chose", "choener", "Choener", "CHOicker", "Choose", "chicker", "Choicker", "composen", "CHOoser", "composer", "chosen", " choicker", " choer", " choener", " choosen", "choser", "rooser", "roicer", "roer", "booser", "Choosen", "boose", "choicer", " choicer", "Chooser", "CHOener", "CHOosen", "boicker", "boosen", "compose", "choose", "roose", "choosen", "choer", "CHOose", "Choer"], "filter": ["function", "mask", "term", "type", "apply", "sort", "fil", "f", "util", "folder", "test", "use", "feature", "map", "filename", "spec", "transform", "ref", "xml", "handler", "service", "policy", "only", "check", "Filter", "set", "table", "file", "match", "profile", "range", "find", "finder", "search", "format", "query", "sf", "list", "pattern"], "dir": ["path", "db", "window", "pkg", "ext", "tmp", "manager", "id", "root", "dat", "rel", "wd", "folder", "desc", "ind", "dep", "dl", "loc", "pos", "ref", " Dir", "home", "dist", "DIR", "doc", "name", "d", "ir", "lib", "directory", "Dir", "base", "set", "def", "file", "log", "data", "div", "fd", "res", "out", "dial"], "parent": ["gr", "self", "owner", "part", "parents", "window", "close", "config", "instance", "tmp", "manager", "holder", "p", "root", "state", "pool", "Parent", "pid", "pos", "server", "component", "e", "tree", "this", "g", "null", "group", "cp", "container", "page", "obj", "form", "child", "ctx", "m", "sp", "context", "div", "out", "widget"], "returnVal": ["ReturnValue", "returnType", " returnType", "Returnval", "resultVal", "retValue", "submitType", "returnValue", "resultval", "returnval", "resultValue", "acceptValue", "acceptVal", "submitValue", "returnVAL", "ReturnVal", "retval", "submitVal", " returnValue", "acceptVAL", "submitVAL", "retVAL", "resultVAL", "ReturnVAL", "retVal", " returnVAL", "acceptType"], "client": ["collection", "out", "http", "connect", "con", "cell", "bolt", "core", "close", "template", "config", "window", "force", "controller", "and", "connection", "response", "manager", "proxy", "api", "console", "util", "local", "create", "ce", "io", "default", "ssl", "Client", "channel", "resource", "server", "rand", "wrapper", "browser", "call", "key", "cgi", "cod", "google", "contact", "service", "obj", "connected", "net", "lib", "conn", "remote", "cl", "acl", "pattern", "file", "secure", "system", "web", "co", "chain", "context", "url", "cli", "cmd", "dial", "c", "cache", "phone"], "reply": ["connect", "close", "notice", "voice", "nb", "response", "connection", "echo", "proxy", "shell", "body", "vote", "state", "bill", "intern", "respond", "answer", "nr", "back", "continue", "exit", "call", "write", "script", "trust", "poll", "next", "Reply", "result", "print", "command", "consider", "zero", "match", "comment", "py", "query", "cmd", "embed", "repl", " replied", "report", "nz", "route", "ply"], "in": ["IN", "din", "gin", " IN", "add", "by", "it", "ini", "rin", "is", "ic", "mc", "ai", "f", "body", "sql", "p", "o", "en", "inc", "io", "from", "mi", "ind", "ex", "ins", "ma", "login", "bin", "serv", "inner", "reader", "sum", "In", "conn", "input", "file", "i", "pi", " din", "s", "inn", "out", "cin"]}}
{"id1": "4852691", "id2": "4056444", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 1, "substitutes": {"hash": [" mac", " check", "update", " encoding", " sum", "Hash", " text", "sign", " equals", " signature", " key", "id", "h", " hashing", "run", " fingerprint", "code", "hex", " salt", "dump", "sum", " message", "print", "string", " h", " Hash"], "data": ["output", "buffer", "message", "text", "json", "password", "space", "hello", "ata", "secret", "raw", "dat", "state", "sample", "area", "DATA", "content", "this", "any", "name", "d", "dump", "bytes", "sequence", "result", "form", "command", "batch", "string", "input", "action", "padding", "value", "info", "what", "image"], "digest": [" digist", "deest", "digute", "dese", "digist", "deist", "Digse", " digse", " digests", "signEST", "duose", "Digester", " digested", "Digest", "digested", "mdester", " digEST", "duist", "duger", "redest", " digger", "Digests", "duest", " hexested", "redger", "DigEST", "mdested", "mdEST", " digose", "digse", "digEST", "digger", "Digested", " hexute", "signest", "digests", "Digist", "redist", "digester", "mdest", " hexests", " digester", "digose", " digute", "deEST", "redose", "signse", "signested", " hexest", "mdse", "Digute"]}}
{"id1": "19584877", "id2": "6188784", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "3375722", "id2": "20306677", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"importarSetor": [" importatSelectr", " importarDator", " importarDatr", " importarStors", " importarStor", " importatSelectors", " importarSetors", " importarStero", " importarSelectr", " importatSetero", " importarSelectors", " importatSetors", " importarDatero", " importarSelectero", " importarSetr", " importarSetero", " importarDators", " importarSelector", " importatSetor", " importatSelector", " importatSelectero", " importatSetr", " importarStr"], "pArquivoXLS": ["pArquiveXLS", "pArquivoEXLS", "pArquivoXML", "pArquivoXXCS", "pArquivoOXCS", "pArquivoEXCS", "pArquiveXls", "pArquiveEXCS", "pArquivoEXls", "pArquivoEXML", "pArquivoTXCS", "pArquivoTXML", "pArquivoDXLS", "pArquarioEXCS", "pArquarioXCS", "pArquivoXXLS", "pArquarioEXML", "pArquiveEXLS", "pArquivoDXML", "pArquivoXXls", "pArquarioEXls", "pArquarioXLS", "pArquivoTXLS", "pArquiveXML", "pArquarioXls", "pArquivoXXML", "pArquivoOXls", "pArquivoDXCS", "pArquivoOXLS", "pArquivoTXls", "pArquivoDXls", "pArquiveEXls", "pArquarioEXLS", "pArquivoOXML", "pArquarioXML", "pArquivoXls", "pArquiveEXML", "pArquiveXCS", "pArquivoXCS"], "pCabecalhoSetor": ["pCabecalhaSetr", "pCabecalhoStar", "pCabecalhaSetor", "pCabecalhoStr", "pCabecalhoStor", "pCabecalhaSetar", "pCabecalhaSetter", "pCabecalhoSetr", "pCabecalhoSetar", "pCabecalhoStter", "pCabecalhoSetter"], "pAndamento": ["pAndmentO", "pAndamente", "pandmento", "pAndmentos", "pAndimento", "pAndimentos", "pandamente", "pAndemento", "pAndementO", "pAndementos", "pandamentos", "pandmentos", "pAndamentos", "pandamentO", "pandmentO", "pAndmente", "pandamento", "pAndamentO", "pAndimentO", "pandmente", "pAndimente", "pAndemente", "pAndmento"], "iLinha": ["iLuha", "aiPlanva", "iLinva", "iEnva", "iPlanha", "iLuzo", "iEn\u00e7a", "aiPlan\u00e7a", "aiLin\u00e7a", "aiPlanha", "iPlan\u00e7a", "aiLinha", "aiPlanzo", "iPlanva", "iEnzo", "iPlanzo", "iLin\u00e7a", "aiLinzo", "iLu\u00e7a", "iEnha", "iLuva", "aiLinva", "iLinzo"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestinos", "stmtLimpezaInicialDecione", "stmtLimpezaInicioDestinos", "stmtLimpezaInicialEstination", "stmtLimpezaInitalDestINO", "stmtLimpezaInicialDecINO", "stmtLimpezaInitalEstino", "stmtLimpezaInicialEstINO", "stmtLimpezaInicialEstino", "stmtLimpezaInicioDestin", "stmtLimpezaInicioEstin", "stmtLimpezaInicioDestination", "stmtLimpezaIniciodestino", "stmtLimpezaInitalEstINO", "stmtLimpezaInicialDestione", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialDestin", "stmtLimpezaIniciodestinos", "stmtLimpezaInitalEstinos", "stmtLimpezaInitalDestione", "stmtLimpezaInicialdestination", "stmtLimpezaInitalDestino", "stmtLimpezaInicialDecino", "stmtLimpezaInicioEstino", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDecinos", "stmtLimpezaInicioEstINO", "stmtLimpezaInitalDestinos", "stmtLimpezaInicialEstione", "stmtLimpezaInitalEstione", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDestINO", "stmtLimpezaInicioDestINO", "stmtLimpezaInicioEstination", "stmtLimpezaInicialdestino", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialEstin", "stmtLimpezaInicioDestino", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialdestin", "stmtLimpezaIniciodestination"], "stmtDestino": ["stmDestin", "stmpDestoin", "stmDestination", "stmtOrigino", "stmpDestinos", "stmtOrigination", "stmtOrigoin", "stmtDecino", "stmtDesination", "stmtDestination", "stmdestano", "stmtdestano", "stmtdestoin", "stmtdestinos", "stmpOriginos", "stmOrigino", "stmpDestination", "stmtdestination", "stmtOrigined", "stmtDestined", "stmpOrigoin", "stmtDesin", "stmtDesino", "stmtdestin", "stmtDestin", "stmtStino", "stmtDescino", "stmOrigination", "stmtStinos", "stmtDecin", "stmDestined", "stmtStoin", "stmtOriginos", "stmpDestino", "stmdestin", "stmtDestoin", "stmtOrigin", "stmtDescination", "stmtdestino", "stmdestino", "stmtDestano", "stmpOrigino", "stmDestano", "stmtDecination", "stmtStination", "stmtDesano", "stmtDecano", "stmtDescined", "stmDestino", "stmtDescin", "stmOrigin", "stmdestination", "stmpOrigination", "stmtDestinos", "stmOrigined"], "arquivo": ["raquiva", " araquive", " araquiva", "araquario", "arqarius", "arquerarius", "rquivo", "raquivo", "arquive", "arquerario", "rquiva", "rquario", "raquarius", "arquarius", " arqiva", " arQuive", " arqivo", "raquario", " arquario", " arqive", "araquivo", "rquarius", " arQuario", "arqario", " arQuivo", "arquerivo", "arqiva", " araquivo", "arqueriva", "araquiva", "arqive", " arquiva", "arquiva", "arquario", " araquario", " arquive", "arqivo", " arqario", " arQuiva", "araquarius"], "plan1": ["panel0", "plan2", "Plan1", " plan2", "panel2", " plan0", "panel01", "plan01", "PlanOne", " planner1", " plan01", "Plan01", " planner2", " plannerOne", "Plan2", "plan0", "Plan0", " planOne", "planOne", " planner0", "panel1"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTRAS__", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTRos__", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTERos__", "QUANTIDADE_DE_REGISTROs__", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROs2", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRANS_", "QUANTIDADE_DE_REGISTROS2"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTERosON", "QUANTIDADE_DE_REGISTEROSON", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTRIES2", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTRATESON", "QUANTIDADE_DE_REGISTROSON", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRosON", "QUANTIDADE_DE_REGISTRATIONSON", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROS2"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROS_"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstIMada", "quantidadeDeRegistrosEstifated", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimated", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstipated", "quantidadeDeRegistrosEstifados", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstIMados", "quantidadeDeRegistrosEstIMated", "quantidadeDeRegistrosEstIMadas", "quantidadeDeRegistrosEstimadas"], "vSetor": ["valuesSetora", "valuesSetor", "valuesSetero", "vSelectora", "vSETero", "valuesSetar", "valuesSETor", "vSelectero", "vEndero", "vSetero", "vSetora", "vSETora", "vSETar", "vSelector", "vSetar", "vEndor", "vSETor", "vEndora", "valuesSETar", "vSelectar", "valuesSETero", "valuesSETora", "vEndar"], "vSubsetor": ["vSubmento", "vSubetOR", "vSubmentOR", "vSubeto", "vsubscriptor", "vSubscripto", "vsubseto", "vsubscriptOR", "vSubscriptation", "vSubmentation", "vsubsetor", "vsubscripto", "vSubscriptor", "vsubsetOR", "vSubscriptOR", "vSubetation", "vSubsetation", "vSubsetOR", "vSubmentor", "vsubsetation", "vSubetor", "vsubscriptation", "vSubseto"], "vSegmento": ["vSeggmentao", "vSegMENTao", "vIncrementano", "vSeggmentano", "vSegementao", "vIncreementano", "vSegementano", "vSegMENTO", "vSegMENTo", "vIncreementO", "vIncrementO", "vIncreemento", "vIncreementao", "vIncrementao", "vSegementO", "vSegmentao", "vSegemento", "vSeggmento", "vSegmentO", "vSegmentano", "vSegMENTano", "vIncremento", "vSeggmentO"], "registroAtual": ["Registroatual", "Registroatomic", "RegistrosAtual", "RegistroActUAL", "RegistrosAtuel", "RegistrosActuel", "RegistroATuel", "RegistroATUAL", "RegistrosAtomic", "RegistrosActual", "RegistroActual", "RegistroAtUAL", "RegistroATual", "RegistrosActomic", "RegistrosActUAL", "RegistroAtuel", "RegistroActomic", "Registroatuel", "RegistroATomic", "RegistrosAtUAL", "RegistroAtual", "RegistroatUAL", "RegistroAtomic", "RegistroActuel"], "vPapeisPorSegmento": ["vPapeisPorSegmentO", "vPapeisPorSegmentedo", "vPapeisPorSegmentede", "vPapeisPorGmentao", "vPapeisPorSegamentO", "vPapeisPorGamentao", "vPapeisPorSegamentao", "vPapeisPorSegmentedO", "vPapeisPorSegmentedao", "vPapeisPorSegmente", "vPapeisPorSegementao", "vPapeisPorSegamento", "vPapeisPorGamentO", "vPapeisPorSegementO", "vPapeisPorGmento", "vPapeisPorGmentO", "vPapeisPorGmente", "vPapeisPorSegamente", "vPapeisPorGamento", "vPapeisPorSegemente", "vPapeisPorGamente", "vPapeisPorSegemento", "vPapeisPorSegmentao"], "sql": ["fn", "orm", "series", "expression", "session", "spr", "mail", "json", "html", "description", "db", "ls", "prefix", "template", "pel", "sd", "wal", "sys", "statement", "condition", "seed", "pg", "params", "ql", "socket", "rel", "inv", "SQL", "install", "pr", "dl", "security", "nl", "spec", "cfg", "email", "js", "sol", "str", "xml", "details", "string", "expr", "table", "scl", "csv", "log", "select", "software", "comment", "sp", "query", "s", "sv", "eps", "url", "cmd", "sq"]}}
{"id1": "19584877", "id2": "17116123", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "9272325", "id2": "4389475", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"sendPost": ["sendGet", "doPost", "executeGet", "sendPOST", "executePost", "httpGet", "executeRequest", "doPOST", "httpRequest", "sendRequest", "httpPost", "doRequest", "doGet", "executePOST", "httpPOST"], "reqUrl": ["requestURL", " reqURL", "reqURL", "seqURL", "seqUrl", "reqName", "resUrl", "requestStr", " reqName", "reqPath", "requestPath", "resStr", "seqLink", "reqStr", " reqPath", "reqLink", " reqLink", "requName", " reqStr", "requURL", "resURL", "requUrl", "requLink", "seqName", "resPath", "requestUrl"], "parameters": ["paramuments", "promams", "parameter", "promuments", "publiceters", "equams", "paramations", "parmes", "equeters", "publications", "arameters", "promations", "parammes", "paruments", "prometers", "pareters", "publiceter", "prommes", "publicams", "equeter", "arammes", "arameter", "prometer", "pareter", "equations", "paramams", "aramuments"], "urlConn": ["httpConn", "relConnection", "implCond", "resourceconn", "urlCtrl", "utilConn", "implConn", " urlCo", "urlDesc", "belDesc", "objCo", " urlConnection", "nlConnection", "objconn", " urlCon", "relconn", "leftconn", "belConn", "URLCon", "sslConn", "URLconn", "httpConnector", "resourceLink", "httpConnection", "sslConnector", "leftConnect", "mountconn", "urlConnection", "resourceConn", "sslDesc", "urlConnector", "URLConnect", "webConnect", "rowConnection", "urlCond", "implDesc", "implConnection", "relConnector", "retConn", " urlConnector", "mountConn", "utilConnect", "webconn", "rowConn", " urlWr", "leftConn", "fileconn", " urlLink", "URLConn", "utilConnection", "mountCo", "belConnection", "urlWr", "nlConn", "rowCo", "leftCon", "relCo", "retConnect", "utilConnector", "nlConnector", "objCtrl", "mountLink", "urlCon", "fileConnection", "rowconn", "urlconn", "relConn", "urlConnect", "sslConnection", "sslConnect", " urlconn", "httpConnect", "mountWr", "sslCond", "fileCon", "fileConn", "objConn", "sslCo", "urlLink", "mountCtrl", "webConn", "mountConnector", " urlConnect", "belCond", "retconn", "urlCo", " urlCtrl", "sslconn", "resourceWr", "nlConnect", "sslCon"], "params": ["units", "json", "password", "prefix", "properties", "config", "pps", "posts", "types", "ams", "p", "AMS", "pins", "files", "ps", "param", "tags", "rs", "v", "changes", "terms", "bytes", "keys", "points", "values", "Parameters", "base", "string", "m", "padding", "results", "names", "data", "s", "options", "phys", "conf", "services"], "url": ["out", "http", "self", "ls", "location", "abs", "sl", "build", "pkg", "bel", "ur", "lb", "Url", "f", "ul", "URL", "loader", "au", "ssl", "dl", "uri", "nl", "loc", "t", "el", "uu", "name", "str", "mount", "ll", "get", "l", "base", "rl", "log", "sb", "web", "https", "r", "hl", "il"], "b": ["buffer", "B", "bf", "db", "binary", "block", "buf", "nb", "n", "it", "a", "bp", "f", "bis", "ob", "bs", "p", "bb", "fb", "bits", "v", "buff", "bin", "eb", "orb", "be", "bit", "mb", "d", "cb", "gb", "w", "bytes", "l", "u", "obj", "bc", "base", "batch", "m", "z", "i", "sb", "br", "s", "r", "rb"]}}
{"id1": "16673769", "id2": "23677128", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"Start": ["Command", "Continue", " Continue", " Serve", "Next", "Init", " Activate", " Init", "Run", "Services", " Stop", "Runtime", "Config", "Application", "Configuration", "run", "Load", " start", "Loader", " Launch", " Startup", " restart", "Launch", " starting", "start", " START", " resume"], "resources": ["uploads", "states", "faces", "links", "parents", "headers", "users", "types", " Resources", "Resources", "times", "rooms", "images", "ues", "writers", "pages", "roots", "files", "classes", "packages", "ions", "actions", "works", "these", "ids", "builders", "features", "they", "cles", "archives", "bytes", "ables", "models", "reports", "apps", "relations", "flows", "modules", "stores", "names", "https", "issues", "groups", "events", "options", "seconds", "objects", "services"], "url": ["path", "buffer", "http", "json", "html", "ls", "location", "addr", "sl", "config", "ret", "bel", "link", "item", "handle", "b", "ur", "Url", "f", "address", "URL", "raw", "sql", "rel", "loader", "util", "id", "row", "uri", "dl", "nl", "t", "resource", "server", "browser", "gl", "ref", "this", "request", "key", "name", "mount", "impl", "str", "ll", "external", "xml", "get", "l", "char", "un", "remote", "base", "entry", "rl", "file", "log", "domain", "web", "res", "r", "host", "pattern"], "configFileContents": ["configStreamContent", "configFILEContents", "configStreamBytes", "jsonFileContent", "jsonfileBytes", "configDocumentBytes", "configfileContents", "configFileSettings", "configDocumentContents", "textFileContent", "jsonfileContents", "configfileRest", "jsonPageSettings", "configFileBytes", "configDocumentRest", "configStreamRest", "configFileCont", "textfileCont", "configfileCont", "configPageContents", "jsonPageContents", "jsonFileContents", "configFILEContent", "configFILECont", "configfileBytes", "jsonfileRest", "configfileContent", "configPageSettings", "textFileCont", "textFileContents", "configStreamSettings", "configStreamContents", "configPageCont", "jsonFileSettings", "configFileContent", "textfileContents", "jsonFileRest", "jsonFileBytes", "textfileContent", "configPageContent", "jsonPageContent", "configfileSettings", "configFileRest"], "configurable": ["mututable", "Configuable", "formured", "confurable", "Configurer", "figuable", "figurable", "capturable", "configured", "logorable", "cturable", " configurer", "Configutable", "controlured", " configutable", "configure", "confured", "captorable", "confcrete", "logure", "mutcrete", "capturer", " configure", "figurer", "configutable", "logurable", "figured", " configured", "configuable", "cturer", "ctured", "configcrete", "confure", "configorable", "formurer", " configorable", "confurer", " configuable", "controlurer", "mutuable", "ctutable", "configurer", "controlurable", " configcrete", "Configured", "Configcrete", "muturable", "captured", "logcrete", "controlutable", "formurable", "formuable", "Configurable", "conforable"], "jsonData": [" jsonEntry", " jsonDat", "configTime", "logData", " jsonContent", "jsonPart", "configData", "logDat", "JSONInfo", "configPart", "logPart", "sonDat", " jsondata", "sondata", "JSONdata", "jsonEntry", "logInfo", "jsondata", "xmlInfo", "xmlData", "sonEntry", "xmldata", "xmlEntry", "jsonContent", "sonTime", "JSONDat", "JSONData", "configInfo", "configdata", " jsonPart", " jsonInfo", "sonInfo", "sonData", "xmlContent", "configContent", "configDat", "xmlDat", "jsonInfo", " jsonTime", "jsonTime", "jsonDat"]}}
{"id1": "11341711", "id2": "23677128", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"makeBackup": ["makebackups", "createbackups", "makeDups", "makeDpoint", "createbackupid", "createBackup", "makeStpoint", "makebackup", "makebackpoint", "createbackpoint", "createBackups", "makeStups", "makebackupid", "createBackpoint", "makeBackpoint", "makeBackupid", "makeDupid", "makeStupid", "makeDup", "makeBackups", "createbackup", "makeStup", "createBackupid"], "dir": ["path", "disk", "dr", "db", "mail", "window", "or", " d", "vol", "addr", "dis", "draw", "pkg", "tmp", "handle", "del", "dat", "y", "wd", "folder", "local", "direct", "rad", "dm", "ind", "dep", "dl", "loc", "src", "dist", "store", "DIR", "doc", "dd", "d", "Directory", "md", "ir", "directory", "Dir", "base", "iter", "file", "data", "fd", "in", "url", "out", "zip"], "sourcedir": ["isourcedr", " sourcesir", "isourcer", "sourcesel", "senderr", "sourcedirs", " sourcesirs", "sourcedr", "sourceirs", "senderel", "sourcedire", "sourcesirs", "senderdir", "senderir", "sourcesire", "soreddir", "sourcesdir", "sourceir", "soredire", "soredir", "isourcedir", "sourceddir", "sourcesir", "isourceddir", "sourceel", " sourceddir", " sourcedire", "sourcer", " sourcesire", "sourcesr", "soredirs", "isourcedel", "sourceire", " sourcesdir", " sourcedirs", "sourcedel", "isourceel", "isourceir"], "destinationdir": ["estinatordb", "destensionfolder", "destinatorfolder", "stinationir", "stinationdir", "destinationsdb", "destensiondir", "destinatordir", "stinationsir", "destinatordiv", "destinationdiv", "estinationDir", "destiondb", "destiondir", "stinationdb", "stinationsdiv", "destensionDir", "destionfolder", "stinationsdir", "destineddb", "destinationsdiv", "destineddir", "stinationsdb", "destinationfolder", "estinatorfolder", "destinationsir", "destensiondb", "destinationdb", "destinedir", "destinatorir", "estinationfolder", "destinationDir", "estinatorDir", "destinatorDir", "destinatordb", "destineddiv", "destinationsdir", "estinationdb", "estinationdir", "estinatordir", "stinationdiv", "destionDir", "destinationir"], "destinationDirEnding": ["destinationDirEndging", "destinationDirFeediting", "destinationDirectoryEnding", "destinationDirectoryEnder", "destinationFileEveniting", "destinationDirectoryENDing", "destinationDirServing", "destinationDirEnder", "destinationDirENDding", "destinationDirENDing", "destinationDirectoryEndging", "destinationDirectoryENDding", "destinationDirENDer", "destinationFileEnditing", "destinationDirEveniting", "destinationDirENDiting", "destinationDirEvenging", "destinationDirectoryENDer", "destinationDirEvending", "destinationFileEnding", "destinationDirENDging", "destinationFileEvener", "destinationDirFeedING", "destinationDirFeeder", "destinationDirServging", "destinationFileEnder", "destinationDirFeeding", "destinationDirEnditing", "destinationDirectoryENDging", "destinationDirEvenING", "destinationDirServer", "destinationDirectoryEndding", "destinationDirEndding", "destinationDirServding", "destinationDirENDING", "destinationFileEndING", "destinationFileEvening", "destinationDirEndING", "destinationDirEvener", "destinationDirEvening", "destinationFileEvenING"], "files": ["uploads", "states", "faces", "assets", "strings", "ls", "links", "words", "parents", "plates", "headers", "users", "types", "ports", "prints", "facts", "iles", "lets", "bs", "images", "Files", "params", "its", "sections", "qs", "forms", "pages", "tests", "items", "lines", "obs", "filename", "classes", "actions", "ids", "features", "fixes", "ames", "bytes", "keys", "mails", "errors", "values", "fs", "projects", "parts", "details", "reports", "tools", "fields", "file", "resources", "docs", "modules", "names", "issues", "events", "members", "objects", "list"], "checkdir": [" checkdirectory", "checkir", "getfolder", "Checkfolder", "keydb", "getdir", " checkurl", "Checkir", "keydir", " checkdb", "checkeddir", "checkroom", "checkurl", "Checkblock", "workurl", " checkfolder", "ckthis", "keyfolder", "Checkroom", "checkblock", " checkblock", "Checkdb", "checkthis", "checkeddirectory", "workdir", "getdb", "keyroom", "Checkdir", "ckroom", "checkedDir", "checkdb", "ckdb", " checkthis", "checkeddb", "workDir", "checkedfolder", "ckDir", "checkfolder", "getblock", "ckdir", " checkir", "ckdirectory", "ckfolder", "checkedir", "Checkdirectory", "checkdirectory", "workthis", "CheckDir", "checkDir", "ckurl", " checkDir"], "date": ["close", "add", "iso", "time", "now", "cal", "user", "te", "msg", "zone", " Date", "dat", "ATE", "late", "dt", "note", "use", "month", "resource", "Date", "tag", " day", "key", "doc", "ate", "d", "day", "get", "none", "today", "event", "set", "file", "year", "data", "start", "diff", "de", "when"], "msec": [" mstr", "mstr", "mtstr", " msc", "cmsec", "gmsec", "MSec", "Msec", "mtcl", "cmisec", "msc", "mSec", " mcl", "mtisec", "mtct", "gmSec", "Mct", " mSec", "misec", " mct", "mcl", "cmsc", "gmsc", "mtsec", " misec", "mtsc", "gmstr", "mct", "cmcl", "mtSec"], "checkFile": ["readFiles", "CheckFILE", "readFile", " checkFiles", "readFILE", "CheckFiles", "updateFiles", "readfile", "readSourceFile", " checkSourceFile", "checkSourceFile", "Checkfile", "checkfile", "CheckFile", "updateSourceFile", "checkFILE", "updateFile", "checkFiles", "updateFILE", " checkfile", " checkFILE"], "i": ["multi", "im", "zi", "x", "j", "init", "phi", "it", "my", "ini", "ai", "is", "ic", "ie", "ui", "ri", "me", "major", "iu", "id", "y", "io", "ci", "mi", "gu", "ki", "ex", "ind", "ii", "qi", "gi", "hi", "key", "ti", "bi", "ji", "name", "index", "si", "I", "sequence", "ei", "base", "batch", "m", "xi", "cli", "iq", "di", "sim", "pi", "info", "exp", "ij", "in", "ip", "li", "ix"], "f": ["bf", "lf", "j", "fo", "fe", "fg", "b", "p", "o", "fi", "fp", "ft", "t", "fr", "fb", "v", "fc", "uf", "e", "d", "fl", "fac", "l", "u", "fs", "m", "df", "file", "fw", "F", "cf", "fd", "tf", "fa"], "g": ["j", "config", "msg", "graph", "fg", "b", "gs", "pg", "p", "eg", "mg", "gy", "gu", "t", "gg", "cfg", "v", "G", "gi", "gl", "e", "bg", "group", "gd", "d", "gb", "w", "l", "ig", "go", "vg", "ga", "gc", "gm", "m", "gp", "file", "tg", "og", "s", "ge", "out"], "destinationFile": ["destarationFiles", "destationFiles", "DestationFiles", "destinatorDirectory", "destinatedFile", "destationEmail", "destinateEmail", "DestationFile", "destarationDirectory", "destinatorFilename", "destarationFilename", "destationFilename", "destinationsFiles", "destinationsFile", "DestinationFilename", "transinatedFiles", "transinatedDirectory", "destinatorFile", "destinationFiles", "transinationDirectory", "destinatedFiles", "destinatedDirectory", "transinationFile", "transinationFiles", "transinatedFile", "destinationsFilename", "destarationFile", "destinatedFilename", "destinateFilename", "destinateFiles", "transinationFilename", "transinatedFilename", "destinationFilename", "DestinationFiles", "destinationsEmail", "DestationFilename", "destinationEmail", "DestinationFile", "destationFile", "destinationDirectory", "destinateFile", "DestinationEmail", "destinatorFiles", "DestationEmail"], "sourceFile": ["ourceFile", "Sourcefile", "ourcefile", "sourceLine", " sourceFILE", "sourceFiles", "staticFile", "sourceFILE", "SourceFilename", "ourceLine", "srcLine", "srcFile", " sourcefile", "SourceFiles", "staticfile", "sourceFilename", "srcfile", "srcFilename", "staticFILE", "SourceLine", "SourceFILE", "ourceFilename", "staticFiles", "sourcefile", " sourceFiles", "SourceFile"], "infile": ["Instream", " instream", "INfile", "pinline", "outFile", "INline", "pinfield", "inblock", "INFile", "inputblock", "insblock", "InFile", "Infile", " inline", "infield", "insFile", "inline", "insfile", "inputline", " inblock", " infield", "inputFile", "pinFile", "INfield", "insstream", "pinfile", "inFile", "Inblock", "outblock", "outline", "inputfile", "instream", " inFile"], "outfile": ["Outfile", "outerstream", " outline", " outbuffer", "inlink", "outpage", "outlink", " outFile", " outlink", "outview", "outputfile", "outputline", " outstream", "OutFile", "outputstream", "Outlink", "outerbuffer", " outpage", "inline", "outstream", "inpage", "outputpage", "inview", "Outstream", "outerview", "inFile", " outview", "inbuffer", "outline", "outFile", "outerfile", "outbuffer", "instream"], "c": ["ch", "nc", "cos", "C", "cu", "close", "x", "n", "a", "mc", "uc", "\u00e7", "ct", "count", "sc", "y", "cd", "rc", "o", "p", "col", "ce", "cs", "t", "lc", "unc", "ac", "v", "cm", "cr", "e", "code", "ec", "d", "cp", "dc", "cb", "char", "r", "k", "pc", "err", "bc", "u", "gc", "cl", "m", "cc", "z", "arc", "chain", "cf", "out", "conf", "ca", "cache"]}}
{"id1": "947406", "id2": "8079516", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["printf", "load", "ls", "save", "init", "sync", " cp", "link", "move", "transfer", "cat", "download", "create", " replicate", " cop", "slice", "map", "Cop", "delete", "cp", "println", "upload", "gc", "Copy", " Copy", "csv", "clone", "paste"], "src": ["ser", "st", "ls", "orig", "init", "config", "img", "pkg", "sys", "tmp", "rx", "bs", "sc", "rel", "rc", "from", "subject", "ins", "obs", "Source", "rs", "iv", "req", "dist", "ctr", "fx", "sec", "sit", "sr", "source", "input", "rl", "sb", "inst", "url", "start", "usr", "sf", "sq", "cur"], "dest": ["deg", "est", "st", "orig", "pub", "des", "tmp", "del", "master", "id", "end", "dir", "test", "desc", "mm", "pas", "loc", "dist", "home", "req", "d", "nw", "good", "Dest", "cont", "mod", "source", "trans", "nom", "decl", "https", "target", "origin", "usr", "temp", "rest"], "in": ["IN", "on", "din", "gin", "con", "st", "or", "init", "ln", "it", "user", "rin", "ai", "is", "mc", "ini", "ie", "sin", "oin", "ck", "ain", "raw", "pin", "o", "read", "local", "en", "inc", "mm", "from", "mi", "ind", "al", "ins", "win", "ma", "up", "ac", "bin", "ar", "all", "inner", "doc", "isin", "l", "r", "In", "net", "conn", "min", "input", "m", "iter", "file", "i", "co", "info", "inn", "act", "inside", "inf", "cin"], "out": ["output", "cos", "list", "on", "mit", "con", "Out", "it", "user", "not", "sys", "rem", "flush", "can", "no", "o", "aos", "to", "os", "en", "io", "nin", "note", "ex", "outs", "t", "client", "conv", "up", "bin", "ou", "nt", "oe", "at", "write", "ns", "null", "inner", "writer", "one", "sum", "obj", "net", "conn", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "cmd", "outer", "res"], "buf": ["buffer", "Buffer", "db", "block", "cur", "font", "img", "msg", "pkg", "bar", "b", "aka", "bs", "bag", "Buff", "tab", "prop", "cat", "bl", "col", "queue", "cv", "seq", "conv", "fb", "buff", "ref", "uf", "box", "bus", "mb", "vec", "cb", "bytes", "cam", "good", "bc", "batch", "mem", "cap", "mu", "log", "br", "bh", "pad", "cf", "cmd", "rb", "gen", "len"], "n": ["nc", "nan", "nos", "on", "j", "nb", "ln", "b", "nm", "no", "y", "en", "num", "t", "nl", "gn", "v", "acc", "nt", "syn", "na", "ns", "nor", "nu", "ni", "d", "ll", "number", "span", "l", "k", "an", "un", "N", "nn", "yn", "sn", " l", "ne", "m", "cn", "max", "z", "i", "mn", "names", "ren", "len"]}}
{"id1": "14688886", "id2": "7891509", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"populateResources": ["populatesResources", "PopureResource", "populatedFiles", "populatesFiles", "populatedResource", "populatedReferences", "popureResource", "PopulateResource", "popureFiles", "populateResource", "populatesResource", "populatesReferences", "PopulateFiles", "popureReferences", "popureResources", "populateFiles", "PopureReferences", "populatedResources", "PopureResources", "PopulateResources", "populateReferences", "PopulateReferences", "PopureFiles"], "templates": ["typles", "timples", "tctions", "memples", "Temports", "sequplates", "Temples", "tmeters", "tiles", "timporary", "temeters", "teniles", "Temmen", "filports", "tmports", "temctions", "sequeters", "memeters", "filplates", "temmen", "teters", "tples", "memables", "tenables", "filples", " temctions", "tables", "temporary", "sequples", "tmporary", "temports", "tmmen", "sequporary", "tyables", "tenctions", " temiles", "tmples", "tenplates", "temables", "tyeters", "timeters", "tmplates", "memplates", "Templates", "filmen", " temables", "tplates", "typlates", "temiles", "timplates", "temples"], "url": ["path", "http", "mail", "html", "location", "term", "sl", "n", "a", "link", "item", "handle", "b", "ur", "Url", "f", "address", "ml", "URL", "p", "rel", "row", "pl", "ssl", "uri", "dl", "nl", "resource", "browser", "gl", "ref", "e", "key", "name", "mount", "mb", "ll", "get", "l", "u", "char", "base", "entry", "string", "rect", "m", "rl", "file", "web", "res", "r", "li", "pattern"], "fileName": ["fileFamily", "FILEname", "fBody", "filenamename", "fileLoad", "Filename", "tilename", "filenamePart", "fName", "ilePath", "fileTime", "FILEName", "moduleTitle", " filePath", "urlName", "FileString", "templateString", "blockname", "ileName", "urlPath", "fileKey", "tileName", "namePart", "FILELine", "blockLoad", "resourceName", "blockTime", "filenameParent", " fileFamily", "fileString", " filename", "namename", "FileFamily", " filePart", "moduleKey", "familyLoad", "FileFull", "fPath", "familyTime", "ileCopy", "urlFamily", "templateName", "filenameName", "fileBody", "urlKey", "FileName", "ileLine", "fileParent", "ilename", "fileTitle", "fileLine", " fileTime", " fileParent", "templatePath", "FilePath", "FileBody", "resourceKey", "filePath", " fileKey", "moduleName", "blockName", " fileType", "familyname", "tileCopy", " fileBody", "fileFull", "ileFull", "fname", " fileFull", "ilePart", "resourceTitle", "FilePart", "filePart", "FileKey", "resourceType", "filename", " fileLoad", "fileType", "templatename", "FILECopy", " fileTitle", "tileLine", "fileCopy", "nameParent", "moduleType", " fileString", "familyName", "nameName"], "templateResource": [" templateEntry", "documentResource", "TemplateReference", " templateReference", "TemplateResources", "TemplateProperty", "templateRes", "documentRole", "componentRes", "resourceEntry", "TemplateResource", "resourceRes", "resourceResource", "TemplateEntry", "componentResource", "componentResources", "resourceProperty", " templateProperty", " templateRes", " templateResources", "templateEntry", "templateReference", "componentReference", "resourceRole", " templateRole", "templateProperty", "documentRes", "templateResources", "TemplateRes", "templateRole"], "is": ["ais", "im", "es", "isc", "iso", "ris", "sels", "ri", "ic", "sys", "isl", "nis", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "are", "ins", "fr", "rs", "rys", "isf", "\u00eds", "Is", "ir", "fs", "iris", "us", "ios", "sis", "in", "isi", "IS"], "strBuff": ["arrComb", "drBuffer", " strComp", "stringBas", "brBuffer", "arrbuff", " strBu", "strBas", " strbuff", "Strbuff", "strFac", "arrFac", "strbuff", " strBuffer", "brComp", "stringBuffer", "arrBuffer", "drComp", "arrBas", "stringComb", "brBuff", "StrBuffer", "strBu", "strComp", "arrBuff", "StrBuff", "drBuff", "brBu", "stringBuff", " strBas", "StrFac", "strComb", " strComb", "strBuffer", "drBu", " strFac"], "br": ["ch", "wr", "gr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "bm", "bs", "BR", "bn", "bl", "hr", "pr", "er", "fr", "bt", "Br", "cr", "bg", "bro", "bi", "next", "ctr", "vr", "mr", "tr", "bc", "sr", "lr", "bh", "kr", "ber", "r", "yr", "rb"], "str": ["gr", "dr", "ust", "text", "st", "n", "sl", "msg", "draw", "del", "p", "St", "bl", "pr", "cs", "seq", "t", "arr", "fr", "pt", "spec", "cr", "stable", "g", "name", "ctr", "STR", "sts", "tr", "obj", "txt", "err", "cont", "print", "string", "set", "sp", "chain", "cert", "s", "ocr", "res", "r", "Str", "coll", "list"], "images": ["uploads", "ims", "assets", "faces", "vs", "ms", "games", "types", "versions", "times", " pictures", "rooms", "image", "frames", "pages", "boxes", "eds", "views", "xs", "amps", "ins", "files", "pins", "raphics", "styles", "photos", "actions", "ids", "ages", "scripts", " photos", "Textures", " Images", "reports", "apps", "resources", "videos", "modules", "media", "arms", "names", "blocks", "eps", "thumbnails", "atts", "items", "ups", "Images"], "i": ["http", "it", "qi", "gi", "status", "ij", "cli", "li", "j", "my", "ini", "ui", "this", "hi", "ti", "bi", "name", "_", "def", "us", "ami", "sim", "ip", "multi", "im", "n", "ie", "me", "Exception", "id", "ci", "ii", "index", "get", "u", "ei", "m", "xi", "pi", "x", "phi", "ai", "p", "y", "io", "mi", "gu", "ki", "v", "key", "si", "I", "mu", "di", "info", "ix"], "img": ["im", "html", "j", "jpg", "amp", "buf", "a", "pkg", "tmp", "gif", "f", "pg", "iam", "medium", "aug", "p", "small", "mg", "av", "bl", "att", "png", "fig", "fm", "bg", "g", "src", "gd", "mp", "obj", "md", "mk", "anim", "imp", "gm", "m", "file", "ami", "pic", "ij", "div", "r", "Image", "li", "image"], "imgProperty": [" tmpProp", "imageImage", " imgProp", "imageProperty", " imgImage", "imgProp", " imgPro", "imageProp", " tmpPro", "imgImage", " tmpImage", "imgPro", " tmpProperty", "imagePro"]}}
{"id1": "2113444", "id2": "539195", "code1": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"newVelocityEngine": ["newVerticleApplication", "newVeloForce", "newVeloApplication", "newVeloEngine", "newVertocityEngine", "newVelicleApplication", "newVelityEngine", "newVelocityEntity", "newVelocityApplication", "newVertocityApplication", "newVerticleEngine", "newVelicleForce", "newVertocityEntity", "newVeloEntity", "newVerticleEntity", "newVelityEntity", "newVertocityForce", "newVelityApplication", "newVelicleEntity", "newVelicleEngine", "newVerticleForce", "newVelityForce", "newVelocityForce"], "velocityEngine": ["velantomEngine", "velitationForce", "velixirDriver", "velviceEng", "aggocityEngine", "aggocityMachine", "velotonEngine", "validotonMachine", "velocityMachine", "proocityForce", "dialotionEngine", "velviceDriver", "proitationEngine", "aggviceMachine", "velisionEngine", "validocityEngine", "dialocityEngine", "proitationengine", "velixirForce", "dialotionengine", "velotionForce", "velocityStream", "dialocityForce", "velysicsForge", "proocityEngine", "velisionForce", "velitationEngine", "velityStream", "velotionEngine", "validotonForge", "validocityForce", "velocityDriver", "velityEngine", "velityForce", "aggviceEngine", "velixirEng", "aggocityDriver", "velocityForce", "velocityForge", "validocityMachine", "velocityEng", "velisionengine", "velantomDriver", "velantomForce", "proitationStream", "velotonMachine", "dialotionForce", "velantomEng", "velitationengine", "aggviceDriver", "velitationStream", "velviceMachine", "velotonForge", "proocityengine", "velysicsEngine", "proitationForce", "velityengine", "velixirEngine", "validotonEngine", "velantomForge", "velixirengine", "validocityForge", "aggocityEng", "validotonForce", "velixirMachine", "proocityStream", "velotionengine", "velocityengine", "velysicsForce", "velotonForce", "velixirStream", "dialocityengine", "velviceEngine", "velysicsMachine", "aggviceEng", "velantomMachine"], "is": ["ist", "ims", "ists", "ais", "ms", "es", "isc", "tis", "ls", "init", "iso", "ris", "mis", "dis", "abs", "ois", "gets", "sys", "ui", "has", "isl", "bis", "bs", "isa", "as", "stats", "ds", "ires", "its", "ws", "os", "iss", "ys", "mi", "xs", "ins", "bits", "ics", "rs", "serv", "isf", "stream", "Is", "isin", "fs", "iris", "los", "us", "isi", "i", "oss", "sim", "ios", "s", "sis", "needs", "ends", "in", "res", "ip", "lis", "IS"], "url": ["path", "http", "mail", "ls", "abs", "sl", "open", "ret", "user", "build", "bel", "link", "ur", "Url", "f", "address", "ul", "URL", "p", "util", "uri", "nl", "resource", "v", "browser", "gl", "ref", "null", "name", "mount", "str", "ll", "get", "service", "l", "u", "char", "rl", "file", "job", "web", "res", "r"], "props": ["prcs", "proprop", "Props", "properties", "pps", "propvs", "peperties", "prpp", "psyperties", "priPS", "propbs", "prPS", "peps", "psypl", "proppp", "pebs", "prprop", "procs", "ppl", "probs", "prips", "pprop", "prbs", "propp", "ProPS", "psyps", "propps", "prps", "prics", "prpl", "propl", "propperties", "prPs", "proPS", "prvs", "psyprop", "prperties", " properties", "Procs", "proPs", "pperties", " provs", "pepp", "priPs", "provs", "ProPs"]}}
{"id1": "7087108", "id2": "5148212", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", " handleSet", "doGET", " handleGet", "invokeGET", "doget", "doSet", " handleGET", " doSet", "invokeGet", " handleget", "invokeSet", "invokeget", " doget"], "request": ["each", "message", "http", "application", "core", "model", "QUEST", "hello", "instance", "open", "worker", "change", "controller", "attribute", "requ", "address", "reference", "raw", "complete", "reset", "local", "create", "frame", "re", "subject", "client", "initial", "server", "transform", "setup", "relative", "call", "forward", "req", "store", "version", "xml", "index", "post", "quest", "get", "position", "command", "project", "input", "Request", "select", "construct", "the", "document", "query", " Request", "search", "context", "remove", "handle", "begin", "enter", "url", "info", "report", "first", "order", "question"], "response": ["output", "message", "http", "application", "description", "onse", "connection", "body", "os", "ce", "frame", "respond", "re", "default", "resp", "server", "write", "next", "view", "xml", "one", "respons", "page", "Response", "result", "print", "status", "reply", "render", "success", "context", "res", "out", "image", "report"], "path": ["output", "text", "patch", "location", "Path", "prefix", "PATH", "template", "config", "ath", "pkg", "title", "p", "prop", "dir", "test", "uri", "th", "filename", "transform", "relative", "key", "where", "hex", "name", "mount", "dest", "route", "print", "base", "project", "string", "check", "select", "value", "log", "system", "chain", "query", "full", "url", "temp", "pattern"], "file": ["bo", "output", "real", "disk", "binary", "db", "word", "mail", "load", "model", "valid", "user", "fe", "link", "bar", "f", "console", "to", "local", "relation", "bool", "File", "channel", "resource", "filename", "spec", "lock", "le", "library", "e", "run", "tree", "be", "null", "rule", "name", "key", "view", "upload", "page", "ile", "result", "form", "FILE", "base", "check", "source", "object", "port", "table", "job", "chain", "document", "full", "handle", "ca", "image", "report"], "in": ["IN", "on", "din", "gin", "con", "asin", "or", "it", "ini", "rin", "is", "ic", "mc", "and", "sin", "ck", "as", "read", "sample", "en", "inc", "mm", "ind", "al", "ins", "up", "bin", "cm", "inner", "reader", "one", "isin", "sum", "kin", "l", "In", "input", "copy", "source", "again", "pic", "i", "mn", " din", "s", "inn", "out", "thin", "cin"]}}
{"id1": "9261777", "id2": "14317425", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"source": ["path", "style", "expression", "text", "site", "reason", "prefix", "init", "template", "se", "config", "SOURCE", "volume", "ui", "title", "address", "body", "ource", "sql", "clip", "sample", "ce", "size", "from", "subject", "use", "uri", "lower", "resource", "filename", "scope", "Source", "back", "spec", "parent", "content", "component", "tree", "where", "src", "script", "store", "str", "view", "index", "service", "char", "sequence", "form", "base", "details", "string", "input", "copy", "status", "language", "check", "file", "table", "target", "query", "search", "info", "origin", "context", "start"], "destination": ["destine", "portinator", "destinator", "declacement", "destino", "testination", " destine", "certinate", "certination", "certacement", "declinant", "portend", "testino", "goodination", "declinate", "originator", "testinator", "origination", "goodinate", "destinant", "tempinator", "declination", " destinator", "distinant", "declinations", "distinator", "destend", "testinate", "destacement", "combination", "combinations", "certinator", "distinations", "origend", "goodinator", " destino", "portination", "origine", "declinator", "portine", "tempination", "tempino", "destinate", "combinator", "destinations", " destend", "tempinate", "goodacement", " destinate", "distination", "combinant"], "is": ["ist", "ims", "ains", "im", "ms", "abs", "isc", "es", "mis", "init", "iso", "ris", "tis", "dis", "ri", "ie", "sys", "isl", "has", "ois", "nis", "lis", "ic", "bis", "bs", "isa", "ires", "its", "iss", "are", "zes", "bits", "obs", "ins", "ics", "ps", "js", "webkit", "ns", "isf", "vs", "ib", "ts", "si", "Is", "isin", "ir", "iris", "vis", "ais", "iter", "us", "icks", "i", "oss", "ios", "info", "sis", "s", "in", "ip", "mus", "was", "isi", "IS"], "os": ["mos", "cos", "on", "ms", "es", "OS", "asis", "or", "oos", "mes", "ops", "dis", "sys", "uts", "bos", "bis", "osi", "bs", "ob", "ss", "dos", "o", "aos", "ost", "css", "ys", "io", "\u00f3", "outs", "obs", "pos", "ones", "ox", "oS", "oa", "ns", "mot", "ks", "Os", "fs", "ols", "los", "zero", "ose", "oss", "oes", "ios", "ot", "s", "oses", "ts"], "buffer": ["message", "history", "binary", "Buffer", "shape", "window", "block", "buf", "template", "phrase", "button", "database", "bar", "available", "variable", "sample", "row", "queue", "frame", "total", "buff", "library", "background", "view", "sequence", "event", "command", "batch", "mem", "padding", "table", "comment", "stack", "document", "pad", "memory", "append", "display", "paste", "word", "temp", "cache"], "length": ["path", "ment", "collection", "load", "history", "text", "offset", "shape", "split", "volume", "time", "ith", "hello", "last", "type", "database", "loop", "count", "ength", "bow", " Length", "integer", "character", "end", "size", "duration", "ind", "frequency", "Length", "th", "needed", "total", "enth", "component", "angle", "stop", "bus", "reading", "ence", "number", "position", "span", "ENGTH", "family", "l", "sequence", "before", "partial", "string", "point", "padding", "capacity", "of", "distance", "width", "pad", "height", "start", "tail", "display", "full", "ty", "len"]}}
{"id1": "4686922", "id2": "18696387", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceAsFiles", "extractResource2File", "extractResourcesToFile", "extractResourceAsfile", "extractResourceAsStream", "extractResourceFromStream", "extractResources2File", "extractResourceTofile", "extractResourcesToFiles", "extractResourcesToStream", "extractResourcesTofile", "extractResource2Files", "extractResources2Files", "extractResourceFromFile", "extractResource2file", "extractResources2file", "extractResources2Stream", "extractResourceToFiles", "extractResourceAsFile", "extractResourceFromfile", "extractResourceFromFiles", "extractResource2Stream", "extractResourceToStream"], "resourcePath": ["Resourcepath", "templatepath", "resourceName", "ResourceIn", "templateIn", "uriUrl", " resourceIn", "resourceIn", "uriPath", "templatePath", "resourcepath", "ResourceLocation", "uriName", "ResourcePath", "resourceLocation", "attributeLocation", "resourceUrl", "attributeName", "ResourceName", "uriLocation", "attributeUrl", "ResourceUrl", " resourcepath", "attributePath", " resourceName", "templateName"], "dest": ["output", "lit", "gov", "self", "orig", "img", "des", "tmp", "opt", "dat", "prop", "to", "end", "dir", "coord", "desc", "cat", "loc", "etc", "parent", "this", "src", "dist", "null", "home", "w", "good", "result", "cont", "Dest", "mem", "source", "trans", "nom", "decl", "sp", "target", "comb", "origin", "temp", "rest"], "in": ["IN", "on", "din", "gin", "con", "or", "init", "ln", "it", "rin", "ini", "is", "mc", "sin", "f", "raw", "id", "no", "local", "inc", "from", "re", "mi", "ind", "al", "ins", "resource", "up", "bin", "all", "inner", "none", "isin", "r", "l", "In", "input", "source", "ne", "iter", "m", "file", "i", " din", "inside", "inn", "conf", "inf", "cin"], "out": ["output", "ch", "cos", "on", "con", " Out", "n", "Out", "it", "sys", "tmp", "b", "f", "can", "no", "o", "aos", "to", "col", "en", "os", "io", "pool", "note", "conv", "outs", "t", "client", "v", "ou", "nt", "exit", "at", "na", "stable", "null", "write", "writer", "inner", "w", "obj", "net", "print", "OUT", "ne", "cn", "again", "i", "oss", "co", "ot", "res", "outer", "cache"]}}
{"id1": "20623709", "id2": "23467091", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"split": ["Split", "disk", "part", "sync", "open", "align", "count", "transfer", "read", "scan", "use", "slice", "map", "lock", "write", "process", "unit", "share", "upload", "scale", "batch", "copy", "parse", "join", "format", "append", "seek"], "targetDirectory": ["TargetDirect", "testDir", "targetFolder", " targetFile", "baseDir", "targetFile", "TargetFolder", " targetFolder", "targetLocation", "baseMemory", "localdirectory", "targetdirectory", "baseFolder", "localDirectory", "localFile", "testDirectory", "baseDirectory", "targetDirect", " targetdirectory", "testDirect", " targetDirect", "TargetMemory", "Targetdirectory", " targetMemory", " targetLocation", "TargetDir", " targetDir", "testLocation", "baseFile", "TargetDirectory", "targetDir", "localDir", "targetMemory", "basedirectory", "TargetLocation", "baseDirect"], "prefix": ["path", "PRE", "password", "template", "type", "pkg", "title", "Pref", "root", "p", "size", "uri", "FIX", "filename", "fixed", "tag", "pre", "this", "key", "fixes", "name", "fix", "index", "version", "division", "username", "directory", "localhost", "base", "command", "padding", "status", "ix", "zero", "pres", "pi", "format", " suffix", "alias", "pattern"], "maxUnitBases": ["maxUnitChades", "maxUnitLounds", "maxUnityLounds", "maxUnitChias", "maxUnitChounds", "maxUnityBicas", "maxUnitLages", "maxUnitReplounds", "maxUnityBades", "maxUnityBias", "maxUnitAliias", "maxUnitChases", "maxUnityLages", "maxUnitLases", "maxUnitReplages", "maxUnitChages", "maxUnitBias", "maxUnitbounds", "maxUnityAliades", "maxUnityBages", "maxUnitChicas", "maxUnitBicas", "maxUnityBases", "maxUnitAliounds", "maxUnitBages", "maxUnitbias", "maxUnityBounds", "maxUnitbades", "maxUnityLicas", "maxUnityAliounds", "maxUnityAliias", "maxUnityAliases", "maxUnitAliades", "maxUnitLicas", "maxUnitAliases", "maxUnitBounds", "maxUnitReplicas", "maxUnitbases", "maxUnityLases", "maxUnitReplases", "maxUnitBades"], "maxUnitEntries": ["maxUnityentrs", "maxUnitEntriers", "maxUnitEntryires", "maxUnitentrys", "maxUnityEntrys", "maxUnitEntryrys", "maxUnitErires", "maxUnityentires", "maxUnitentrs", "maxUnitEntryries", "maxUnityEntries", "maxUnitIntegries", "maxUnitErrys", "maxUnitIntegires", "maxunitEntires", "maxUnitErrs", "maxunitEntrys", "maxUnitEntryriers", "maxUnitIntegrys", "maxUnitEntires", "maxUnitErries", "maxunitEntrs", "maxUnitIntegriers", "maxUnitEntrys", "maxUnitentires", "maxUnityentrys", "maxUnitentries", "maxUnitEntrs", "maxUnityentries", "maxUnityEntires", "maxUnityEntrs", "maxunitEntries"], "fis": [" fi", " fiss", "viss", "fii", "Fii", "fiss", "Fis", "fi", "Fiss", "ifis", "Fic", "vic", "ific", "ifii", " fic", "vis", "Fi", "fic", "Fci", "ifci", " fii", "vi"], "fci": ["Fico", "cfis", "cfci", "mco", "cfini", "mci", "fii", "fico", "cfai", "Fis", " fcu", "fai", "cfic", "mii", "Fco", "Fai", "cfco", "Fic", "mcu", "tci", "tcu", "Fini", "tii", "tco", "fcu", " fic", "fic", "Fci", " fini", "fini", " fii", "cfico", " fico", " fai"], "fos": ["faos", " fOS", "Foss", "ybos", "fOS", "fbos", "yios", "flaos", "Faos", "wbos", "yos", "FOS", "flos", "yaos", "Fos", " fios", "flOS", "floss", " fbos", " foss", "fios", "wios", " faos", "foss", "waos", "wos"], "fco": ["Fdo", "Foco", "Fso", "cco", "cdo", "Fcon", "fcon", "cso", " fcon", " foco", "pco", "pcos", "Fco", " fdo", "fso", "fcos", " fso", "Fcos", "tdo", "tcos", "foco", " fcos", "tco", "pci", "fdo", "ccon", "pso", "toco", "Fci"], "buffer": ["message", "Buffer", "binary", "pause", "function", "black", "window", "timeout", "block", "phrase", "buf", "template", "button", "callback", "database", "filter", "flush", "address", "holder", "complete", "reset", "row", "sample", "read", "queue", "note", "channel", "buff", "length", "library", "index", "position", "bridge", "char", "sequence", "result", "event", "record", "print", "command", "batch", "limit", "source", "entry", "padding", "iter", "table", "match", "comment", "stack", "document", "data", "order", "memory", "append", "temp", "cache"], "currentBasesCount": ["currentBasesCode", "currentbaseCode", "currentBadesCount", "currentBasedLength", "currentbaseLength", "currentBaseLength", "currentbasesCount", "currentBaseCode", "currentbasesCode", "currentbaseCount", "currentBaseCount", "currentBadesLength", "currentBasesLength", "currentBadesCode", "currentBasedCount", "currentbasesLength", "currentBasedCode"], "currentEntriesCount": ["currentEntrysCode", "currentEntrysFlag", "currentEntriesFlag", "currentEntiesCount", "currentEntrsFlag", "currentEntriesCode", "currentEntrsCode", "currentEntiesFlag", "currentEntiesCode", "currentEntrsCount", "currentEntrysCount"], "targetCount": ["argetInfo", "argetAmount", "argetNum", "TargetAmount", "targetInfo", "TargetInfo", "TargetCount", " targetAmount", "TargetNum", "argetCount", "targetNum", "targetAmount", " targetNum", " targetInfo"], "fastaChannel": [" fastaProvider", "fastpaProvider", "fastaButton", "fastaiQueue", "fastoProvider", "fastaiChannel", "fastityChannel", " fastaConnection", " fastaStream", "fastaiChan", "fastoChannel", "fastaQueue", "fastpaChannel", " fastoChannel", "fastpaButton", "fastityQueue", "fastaChan", "fastoStream", " fastaButton", "fastoButton", " fastaQueue", " fastoStream", "fastityChan", "fastoQueue", "fastaiStream", "fastoConnection", " fastoChan", "fastityStream", "fastpaConnection", " fastoQueue", " fastaChan", "fastaConnection", "fastoChan", "fastaStream", "fastaProvider"], "totalSeqCount": ["totalSeQCounter", "totalSeqsCode", "totalSegCount", "totalSegCounter", "totalSegSize", "totalSeqCounter", "totalSeQCode", "totalSeQSize", "totalSeqsCount", "totalSeqsSize", "totalSeqSize", "totalSeqsCounter", "totalSegCode", "totalSeQCount", "totalSeqCode"], "totalResiduesCount": ["totalResIdueCode", "totalResIdueCount", "totalResidusFlag", "totalResIduesFlag", "totalResidueCount", "totalResiduationsFlag", "totalResidueCode", "totalResidusCount", "totalResIduesCount", "totalResiduationsCode", "totalResidusCode", "totalResiduationsCount", "totalResIdueFlag", "totalResiduesCode", "totalResidueFlag", "totalResiduesFlag", "totalResIduesCode"], "prevTime": ["prevT", " prevT", "parTime", " prevThread", " previousThread", "parT", "parThread", " previousT", " previousTime", "prevThread"], "fastaFileSize": ["fastoFileOwner", "fastaTableSIZE", "fastoTableSIZE", "fastaChainOwner", "fastaFilesSize", "fastoTableOwner", "fastaReaderHeight", "fastaTableLength", "fastAFileName", "fastATableHeight", "fastaFileName", "fastaFilesHeight", "fastafileSIZE", "fastafileLength", "fastaFilesName", "fastATableSize", "fastaFileSIZE", "fastoFileSize", "fastoTableSize", "fastaChainLength", "fastaFileHeight", "fastaReaderName", "fastaTableSize", "fastaChainSize", "fastaReaderLength", "fastaChainSIZE", "fastATableName", "fastaFileLength", "fastoTableLength", "fastaTableName", "fastafileSize", "fastoFileLength", "fastaFilesLength", "fastaReaderSize", "fastaTableHeight", "fastATableLength", "fastaTableOwner", "fastAFileSize", "fastAFileHeight", "fastAFileLength", "fastoFileSIZE", "fastaFileOwner", "fastafileOwner"], "fastaFileReadOffset": ["fastaFileWriteOrder", "fastaPageLoadOrder", "fastaFileLoadOrder", "fastaFilesReadOrder", "fastaFileViewOrder", "fastaFileInputOrder", "fastaFileInputLength", "fastaPageReadPos", "fastaChainCurrentLocation", "fastaFileWriteAmount", "fastaFileReadPos", "fastaFilesLoadOffset", "fastaFilesLoadOrder", "fastaPageReadOrder", "fastaFileLoadPos", "fastaFileInputLocation", "fastaChainReadOffset", "fastaFileReaderoffset", "fastaFileLoadOffset", "fastaFileWriteLength", "fastaFileCurrentoffset", "fastaFileReadPosition", "fastaFileReaderPosition", "fastaFileViewPos", "fastaChainReadPosition", "fastaPageLoadAmount", "fastaFilesReadLength", "fastaPageReadOffset", "fastaFilesReadAmount", "fastaFilereadPos", "fastaFilesLoadAmount", "fastaFileReaderLocation", "fastaFileCurrentLocation", "fastaChainCurrentoffset", "fastaChainCurrentPosition", "fastaFileViewAmount", "fastaFileLoadLength", "fastaPageReadAmount", "fastaFileReadAmount", "fastaFilereadOrder", "fastaFileReadoffset", "fastaPageLoadPos", "fastaFilesLoadLength", "fastaFileLoadAmount", "fastaFileReadOrder", "fastaFileWriteOffset", "fastaFilereadOffset", "fastaFileInputoffset", "fastaFileReaderOffset", "fastaChainCurrentOffset", "fastaFileViewOffset", "fastaChainReadLocation", "fastaFileCurrentPosition", "fastaFilereadAmount", "fastaChainReadoffset", "fastaFileInputPosition", "fastaPageLoadOffset", "fastaFileReadLength", "fastaFilesReadOffset", "fastaFileInputAmount", "fastaFileCurrentOffset", "fastaFileReadLocation", "fastaFileInputOffset"], "partitionStartOffset": ["partitionStartPoint", "partitionEndPoint", "partitonStartingPosition", "partitionDataOffset", "partitionEndOff", "partitionStartOff", "partitionDataPosition", "partitionDataPoint", "partitionStartingOffset", "partitonStartingOff", "partitonStartPoint", "partitionEndPosition", "partitionDataOff", "partitonStartOffset", "partitionStartPosition", "partitionStartingPosition", "partitonStartPosition", "partitonStartingPoint", "partitonStartOff", "partitionStartingPoint", "partitionStartingOff", "partitonStartingOffset"], "bufferSize": ["bufferCode", "tableSIZE", "buffSize", "buffSIZE", "bufferSIZE", "BufferLength", "BufferSIZE", "tableName", "BufferName", "bufSize", "sequenceSIZE", " bufferSIZE", "tableLength", " bufferLength", " bufferCode", "sequenceLength", "bufCode", "tableSize", "buffName", "BufferSize", "sequenceCode", "bufferLength", "bufferName", "sequenceSize", "buffLength", "bufSIZE", "bufLength"], "fastaBuffer": ["FastaBuffer", "wildanBuff", "fastasRequest", "fastsaQueue", "fastmaChannel", "FastaRequest", "fastmaBuffer", "fastasCounter", " fastaCounter", "FastmaBuff", "fastoBuff", "fastsaChannel", "fastuBuff", "fastalBuff", "wildaBuff", "fastoQueue", "fastanBuff", "wildaBuffer", "FastmaBuffer", "fastuMemory", "fastasQueue", " fastaBuilder", "fastcaBuffer", "fastoRequest", "fastaCounter", "wildanRequest", "fastaQueue", "fastaStore", " fastaBuff", "wildanBuffer", "fasteBuff", "fastmaBuilder", "wildaCache", " fastaCache", "wildanCache", "fastaBuff", " fastoCounter", "fastmaCache", "fastaBuilder", "fastanRequest", "fastcaRequest", "fastaDB", "fastaCache", "FastaBuff", "fastmaRequest", "fasteDB", "fastcaBuff", "fastmaBuff", "wildaRequest", " fastoBuff", "fastsaBuff", "FastmaRequest", "fastaRequest", "fastasBuilder", "fastasStore", "fasteMemory", " fastaMemory", "fastalCounter", "fastsaBuffer", " fastoQueue", "fastasBuff", "fastanCache", "fastmaStore", "fastcaCache", "FastmaStore", "FastaStore", " fastoBuffer", "fastasBuffer", "fastalBuffer", "fastalQueue", "fastoCounter", "fastuDB", "fastoStore", "fastoBuffer", " fastaDB", "fastmaQueue", "fastanBuffer", "fastasCache", "fastaMemory", " fastaQueue", "fastuBuffer", "fasteBuffer"], "fastaReadState": ["fastaReadSTATE", "fastoReaderType", "fastaCurrentState", "fastaReaderType", "fastaLoadState", "fastaLoadStatus", "fastoReadStatus", "fastaReaderSTATE", "fastoReaderSTATE", "fastaReaderState", "fastoReaderState", "fastaReaderStatus", "fastoReadType", "fastaCurrentType", "fastoReadSTATE", "fastoReaderStatus", "fastaLoadSTATE", "fastoReadState", "fastaReadType", "fastaCurrentStatus", "fastaCurrentSTATE", "fastaReadStatus", "fastaLoadType"], "nBytes": [" nParts", "nsbytes", "nsBytes", "nrBytes", "nobytes", "nKeys", " nbytes", "nParts", " nBlocks", "numBytes", "nsParts", "nbytes", " nWords", "nrbytes", "NItems", "noBlocks", "nrKeys", "NWords", "numBlocks", "NParts", "numbytes", " nItems", "NKeys", "noBytes", "nsWords", "nItems", " nKeys", "numNs", " nNs", "nBlocks", "noNs", "NBytes", "Nbytes", "nrItems", "nNs", "nWords"]}}
{"id1": "8921716", "id2": "8665321", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"MD5": [" mdHash", "SHA2", "SHAHash", "SHA3", "MDHash", " MDHash", " md3", "MD3", " md2", " MD2", " MD3", " md5", "SHA5", "MD2"], "text": ["path", "buffer", "output", "message", "password", "prefix", "x", "TEXT", "term", "now", "msg", "ext", "title", "ct", "q", "Text", "read", "test", "subject", "t", "pt", "nt", "content", "translation", "code", "name", "str", "aut", "txt", "event", "form", "print", "command", "string", "input", "source", "tx", "select", "value", "log", "comment", "document", "data", "format", "url", "context", "act", "out", "word", "pattern"], "UnsupportedEncodingException": ["UnsupportedEncode ", "UnsupportedDecoderError", "UnsupportedDecodingException", "UnsupportedEncodedError", "UnsupportedEncodeException", "UnsupportedEncoderError", "UnsupportedEncodeError", "UnsupportedEncoderEx", "UnsupportedDecodingEx", "UnsupportedEncoder ", "UnsupportedEncoding ", "UnsupportedEncodingError", "UnsupportedDecoder ", "UnsupportedDecoderException", "UnsupportedEncodedException", "UnsupportedEncoded ", "UnsupportedEncoderException", "UnsupportedEncodeEx", "UnsupportedDecodingError", "UnsupportedEncodingEx", "UnsupportedDecoding ", "UnsupportedEncodedEx", "UnsupportedDecoderEx"], "md": [" dist", "dr", " cmd", "mail", "ms", "nd", "add", " de", "hd", " doc", "sd", " img", "pkg", "bd", "od", "MD", " done", " rand", "der", "grad", "mg", "h", "dir", "mm", "dm", "mt", "ind", " mk", " df", "red", "rm", "pt", "deep", "det", "ld", "ctr", "dd", "d", "mb", " def", "mp", " sch", " del", "mk", " ind", "mond", "dig", " ok", "Cmd", "mod", "pd", "m", "hash", "df", " exec", "di", "mn", "mand", " med", " cd", "cmd", " man", "ad"], "md5hash": [" md4hash", "md4sum", "md5key", " md3hash", "md4hash", "md5hex", "md2hash", "md5index", "md512index", " md4hex", "md5h", "md2sum", "md3h", "md7Hash", "MD5Hash", " md4index", "md3sum", "md3hex", "md5sum", "MD2h", "md512key", " md3Hash", " md4key", "md4Hash", "md3Hash", " md5hex", " md5h", "md3hash", "MD2sum", "MD5h", "md4index", "MD5hash", "md512hex", "MD2Hash", " md5key", "md3key", " md5Hash", "MD5sum", "md7hash", "md5Hash", "md3index", "md2h", "md512hash", " md3h", " md5index", "md7sum", "md4hex", "md2Hash", " md3sum", "md4key", "md4h", "md7h", "MD2hash", " md5sum"]}}
{"id1": "12236729", "id2": "344764", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "label": 0, "substitutes": {"copy": [" download", " upload", " operate", " cp", " duplicate", " clone", " merge", " restore", "transfer", "read", " replicate", " transfer", " append", " move", " parallel", " recover", " paste", "cp", " delete", " join", " cat", "Copy", " combine", " Copy", " seek", " copying", "paste", " dup"], "inputFile": ["inputPath", "argumentFile", "configPath", "inDir", "argumentfile", "argumentPost", " inputfile", "inputile", " inputile", "configfile", "configPost", "configFile", "outputDir", "inputDir", "inile", "argumentPath", " inputPost", "inFile", "outputile", " inputDir", "inPath", " inputPath", "inputPost", "outputPath", "inputfile"], "outputFile": ["inputPath", "outPlace", "outputFilename", "outputPlace", "targetFile", "writePlace", "outputPath", "outputfile", "writeFile", "outFilename", "targetPath", "outputDir", "inputDir", "outPath", "writeDir", "outfile", " outputDir", "writeFilename", " outputPlace", "targetDir", "targetfile", " outputFilename", "outDir", "outFile", "inputfile"], "in": ["IN", "on", "per", "din", "gin", "con", "init", "it", "rin", "ai", "is", "ze", "ic", "ini", "sin", "ri", "old", "read", "en", "inc", "from", "ind", "al", "ins", "up", "bin", "all", "inner", "reader", "isin", "ir", "In", "min", "input", "iter", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "cos", "on", "con", "by", "n", "auto", "Out", "it", "user", "dis", "sys", "flush", "can", "o", "aos", "to", "os", "en", "end", "io", "ex", "outs", "client", "v", "ou", "nt", "at", "write", "g", "null", "writer", "one", "obj", "net", "print", "OUT", "check", "ne", "cn", "log", "co", "ot", "res", "outer", "cache"], "c": ["ch", "nc", "cos", "C", "con", "cu", "x", "n", "uc", "mc", "f", "ct", "count", "cd", "rc", "character", "ce", "cs", "t", "lc", "current", "unc", "ac", "v", "cm", "cr", "code", "cod", "ec", "d", "cp", "cb", "char", "r", "k", "u", "bc", "l", "cont", "pc", "gc", "cl", "cap", "cc", "z", "i", "arc", "chain", "cf", "conf", "cache"]}}
{"id1": "20310134", "id2": "14317425", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" duplicateStream", " cpfile", " copyDirectory", " CopyDirectory", " duplicateDirectory", " cpStream", " cpDirectory", " duplicatefile", " duplicateFile", " copyStream", " CopyStream", " Copyfile", " CopyFile", " copyfile", " cpFile"], "in": ["IN", "on", "din", "gin", "init", "it", "rin", "ini", "is", "ic", "b", "old", "ain", "id", "as", "en", "inc", "io", "from", "mm", "ind", "ins", "el", "up", "isin", "l", "r", "In", "input", "source", "i", "inn", "inf", "cin"], "out": ["output", "n", "Out", "it", "msg", "b", "p", "o", "to", "os", "io", "help", "ex", "outs", "t", "op", "v", "ou", "serv", "nt", "at", "g", "null", "w", "l", "net", "err", "OUT", "gt", "ne", "log", "po", "ot", "s", "c"], "inChannel": [" inCommand", "intCommand", "sinButton", " inButton", "dinButton", "oinchannel", "cinClient", "inConnection", " inConnection", "dinCommand", "cinListener", "cinChannel", "cinRoom", "insideChannel", "oinApplication", "sinChannel", "inchannel", " inApplication", "outApplication", "intButton", " inchannel", " inListener", "inChan", " inPanel", "sinListener", "inRoom", " inChan", "dinChan", "outchannel", "inApplication", " inRoom", "oinChannel", "inputCommand", "insideCommand", "inCommand", "inListener", "intChannel", "sinClient", "cinButton", "inPanel", "cinCase", "inCase", "inputPanel", "dinChannel", "intChan", "outConnection", "sinRoom", " inCase", "sinCase", "insidePanel", "inButton", "oinConnection", " inClient", "inputChannel", "inClient"], "outChannel": ["outCan", "inCh", "fullChan", "outCh", " outCh", "cosMember", "noteChan", "noteCategory", "fullCan", " outCan", "outUser", " outCategory", "outputConnection", "fullChannel", "outerUser", "inchannel", "inMember", " outchannel", "inCategory", "inChan", "outMember", " outUser", "outchannel", "OUTChannel", "outputUser", "fullCategory", "outputchannel", "cosCategory", " outConnection", "noteMember", "OUTCan", "cosChannel", "outputChan", "outerChannel", " outChan", "outChan", "outputChannel", "outConnection", "OUTChan", "noteChannel", "outCategory", "outputCh", "cosChan", "outerConnection", "OUTCategory", "outerChan"]}}
{"id1": "1188100", "id2": "23370621", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"test": ["load", "some", "est", " evaluate", "testing", "example", " TEST", "sample", "execute", "evaluate", "use", "tests", "server", "tested", "store", "debug", "unit", " Test", " tests", " testing", "Testing", "print", "check", "Test", "show"], "s": ["state", "http", "session", "sc", "self", "ls", "ms", "st", "abs", "sl", "n", "j", "sd", "is", "sys", "so", "b", "gs", "bs", "socket", "stats", "ss", "ds", "p", "ws", "qs", "h", "ses", "os", "sa", "aws", "xs", "sw", "ssl", "cs", "t", "sm", "spec", "ps", "rs", "v", "y", "js", "e", "less", "ns", "sports", "store", "sts", "ats", "still", "comm", "w", "service", "sql", "l", "fs", "south", "c", "details", "m", "status", "z", "i", "sb", "https", "sv", "pers", "ts", "S", "sq"], "input": ["output", "buffer", "text", "json", "my", "hello", "open", "feed", "raw", "read", "sample", "accept", "iterator", "io", "Input", "initial", "current", "ahead", "request", "this", "inner", "null", "reader", "get", "upload", "stream", "cont", "form", "source", "file", "active", "i", "media", "data", "context", "in", "start", "ip", "inside", "image"], "writer": ["output", "buffer", "builder", "rew", "word", "window", "WR", "term", "caster", "worker", "draw", "processor", "manager", "wrote", "loader", "riter", "writers", "console", "writing", "to", "end", "writ", "maker", "creator", "wright", "operator", "write", "inner", "wire", "reader", "written", "handler", "external", "stream", "w", "service", "storage", "player", "winner", "temp", "Writer", "file", "driver", "format", "woman", "out", "her", "widget", "editor"]}}
{"id1": "14093044", "id2": "19322941", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"insert": ["load", "update", "add", "save", "init", "replace", "database", "put", "sql", "create", "scan", "execute", "login", "delete", "write", "index", "check", "submit", "set", "select", "query", "append", "Insert", "push", "commit", "exec"], "consulta": ["Consultana", "Consultas", "conscentla", "consulsas", "concentae", "concenta", "consertas", "consultar", "consumptionae", "consulsae", "Consultla", "Consumeras", "consertae", "Conscentable", "consumela", "consumeas", "consaultas", "conultae", "consumptionas", "conscentas", "conscentana", "Consumera", "consultae", "consultsaria", "ConsumerA", "Conscenta", "consultsas", "consultA", "consultable", "conscentar", "Consultable", "conultsaria", "conultaria", "consultsae", "consumerA", "consumptionable", "consumea", "conultar", "consumptionar", "conscenta", "Consulta", "conultsas", "consaulta", "consultas", "consaultae", "ConsultA", "consumeable", "consumerana", "consumera", "conscentA", "consaultana", "consertar", "Consumerana", "Conscentla", "conulta", "Conscentas", "consumptionla", "concentas", "conserta", "conultas", "conultsae", "consulsaria", "consaultaria", "consultana", "consumptiona", "consultla", "concentar", "conscentae", "consultsa", "consaultA", "conultsa", "consumeras", "conscentable", "consulsa", "consultaria"], "autocommit": ["autocomort", "autocondmit", "autoconombit", "autoconomate", "autOCommate", "autocompbit", "autocondit", "autocubite", "autocumnbit", "autoccelerulate", "autOComits", "autocondite", "autocumnate", "autocubmit", "autocomite", "autocommmit", "autocomulate", "autocompate", "autococomulate", "autOCommit", "autoccelermit", "autococomit", "autocondort", "autoccelerort", "autocommbit", "autoconommmit", "autocondits", "autocomate", "autOComort", "autocommulate", "autOCommite", "autocubits", "autocommite", "autOCommort", "autococommit", "autococomate", "autOComate", "autoconomit", "autocommate", "autocompmit", "autOCommmit", "autoconommbit", "autoconommate", "autoccelerit", "autocomit", "autocompit", "autocompulate", "autocomits", "autocumnmit", "autOCommulate", "autocommits", "autocommort", "autocumnit", "autocombit", "autOCommits", "autocubit", "autOComit", "autOComulate", "autoconommit", "autOComite", "autocondulate"], "transactionIsolation": ["transversionIdration", "transpointIsola", "transpointInterolation", "transactionIdavior", "transpointInterola", "transversionIsolation", "transactionAsolation", "transactionAsularity", "transactionISolation", "transactionISruption", "transactionInterola", "transactionIsola", "transactionIsolate", "transactionInterruption", "transversionIdavior", "transactionISolated", "transactionStyleolate", "transactionIsilon", "transceptionIolated", "transceptionIsOL", "transactionIsruption", "transceptionIsulation", "transactionIfola", "transactionInolation", "transactionIsavior", "transactionIOL", "transactionInsolate", "transceptionIsolation", "transactionInolated", "transactionIsOL", "transceptionIensitivity", "transceptionIsilon", "transactionISolate", "transactionAsolated", "transactionIfruption", "transactionIsulation", "transversionIdolation", "transactionStyleolation", "transactionIfolated", "transactionIsration", "transactionISOL", "transpointIsolated", "transactionInsolation", "transactionISavior", "transactionInolate", "transceptionIolate", "transactionIdolate", "transactionISulation", "transactionIularity", "transactionIensitivity", "transceptionIolation", "transversionIdolate", "transactionInterolation", "transactionStyleensitivity", "transceptionIsolate", "transactionAsolate", "transpointIsruption", "transactionInOL", "transpointInterolated", "transactionIsolated", "transactionIfolation", "transactionISration", "transactionStyleilon", "transactionInterulation", "transceptionIsularity", "transceptionIularity", "transactionISensitivity", "transceptionIsolated", "transactionInterularity", "transactionISola", "transactionInterolate", "transceptionIilon", "transactionInsavior", "transactionInterolated", "transversionIsolate", "transpointInterruption", "transceptionIulation", "transactionISilon", "transactionIdration", "transceptionIsensitivity", "transpointIsolation", "transactionIulation", "transactionIolate", "transactionIsensitivity", "transactionIdolation", "transactionIsularity", "transactionInsration", "transversionIsavior", "transactionIolated", "transversionIsration", "transactionIilon", "transceptionIOL", "transactionIolation"], "cx": ["actx", "cxi", " cxi", "acxt", " ctx", "ncxi", "acX", "Cxi", "Cxt", "cxt", " cX", "acx", "nctx", "Ctx", "CX", "Cx", "ncX", "ctx", " cxt", "ncx", "cX"], "filasInsert": ["filasaAdd", "filiasDelete", "filataDelete", "filasaInsert", "filinasEnter", "filasaUpload", "folASEnter", "folASInsert", "filASImport", "folASRow", "filataImport", " filasaInsert", " filasaAdd", "filasAdd", "folasEnter", "folASImport", "filaDelete", "filasUpdate", " filasUpload", "folasInsert", " filasUpdate", "folasRow", "filinasAdd", "fundaImport", "filinasRow", "filacsImport", "filacsRow", "filasDelete", "filASRow", "fundasInsert", "fundaInsert", "filaInsert", "filASEnter", "filiasInsert", "filrasUpload", "filrasUpdate", " filasaUpdate", "filinasImport", "filacsInsert", "filinasUpload", "filASInsert", "filrasInsert", "filaImport", "fundasImport", "filasUpload", "fundasDelete", "filasaUpdate", " filasaUpload", "filasEnter", "filasImport", " filasAdd", "fundaDelete", "filataInsert", "filinasUpdate", "filiasImport", "filrasAdd", "folasImport", "filasRow", "filinasInsert", "filacsEnter"], "tipoConsulta": ["tipoconsultada", "tipoConsresenta", "tipoConsulsa", "tipoConsultsa", "tipoConsultsA", "tipoConsistara", "tipoConultara", "tipoconsultsA", "tipoconsultsada", "tipoConsulsada", "tipoConsulsas", "tipoConistas", "tipoConsumptionas", "tipoCoulsao", "tipoCoultao", "tipoConsumeras", "tipoConsumerada", "tipoCoulsa", "tipoCoultar", "tipoconsultA", "tipoConsultar", "tipoCoulsada", "tipoConsultsada", "tipoConistao", "tipoConsultA", "tipoConultas", "tipoconsultsa", "tipoConsultao", "tipoconsultas", "tipoConsulsar", "tipoConsultsas", "tipoConsultara", "tipoConsulao", "tipoconsulta", "tipoConultao", "tipoCoulsar", "tipoConsistas", "tipoCoulta", "tipoCoultada", "tipoConsulsA", "tipoConsistao", "tipoConsulsao", "tipoConistara", "tipoConsumptionara", "tipoConsula", "tipoConulta", "tipoConsulara", "tipoConsultsao", "tipoConsumera", "tipoConsresentar", "tipoConsresentao", "tipoConsista", "tipoConsumptionao", "tipoConsumerA", "tipoConsultas", "tipoconsultsas", "tipoConsumptiona", "tipoConsulas", "tipoConsultada", "tipoConsultsar", "tipoConsresentada", "tipoConista"], "execConsulta": ["execCoerta", "execConsonseai", "execCoertai", "execCoertalpha", "execConsumear", "execCoultalpha", "execConsonsealpha", "execConsonsearea", "execConsultalpha", "execConsumela", "execConsultas", "execConsortiumai", "execConulta", "execConsaultas", "execConultla", "execConsertarea", "execConsultarea", "execConsortiumarea", "execCoultarea", "execConsaulta", "execCoulta", "execConsumeas", "execConserta", "execConultar", "execConsaultla", "execConsultai", "execConsonsea", "execConsertai", "execConsortiumalpha", "execCoertarea", "execConsertalpha", "execConsortiuma", "execConsultla", "execConsumea", "execConsaultar", "execConultas", "execConsultar", "execCoultai"], "conexion": ["coneexison", "coexione", "coneuxion", "cakexione", "coeexione", "coneXION", "cakexpison", "coneuxions", "coexinion", "coneplexION", "conexpions", "conextion", "caixression", "coexision", "coexond", "coneaxision", "Colexone", "coeuxION", "coexible", "conenexression", "coeuxions", "conenexone", "conextione", "coneixression", "conenexions", "conexision", "coneixion", "conexible", "conenexible", "coneXible", "coexison", "coneaxion", "coneexision", "coneaxione", "coeexion", "coneixison", "coeuxion", "coneaxison", "conexpond", "caxression", "Colexison", "caixion", "caixION", "conenexison", "cakexpion", "conexpion", "coneplexione", "coextision", "Colexpison", "conexION", "conexond", "coexion", "Colexions", "conexpone", "coeexond", "cakexpione", "coexions", "coneplexion", "coneexond", "coneexion", "conexpione", "conexone", "cakexison", "conextression", "Colexpions", "caixison", "conextinion", "conextison", "conenexION", "cakexION", "conextION", "conexions", "coeexible", "caxion", "coeuxinion", "cakexion", "coneixione", "conexpION", "coneexION", "conexione", "conextions", "Colexpion", "conexinion", "coneexible", "conenexinion", "coneexions", "coeexison", "coextion", "coextione", "conextision", "conenexione", "conexression", "coneplexison", "conexison", "caxison", "coeexION", "coneexione", "coneexone", "coneXione", "coneuxION", "coneXion", "coneixION", "conexpison", "coextison", "coneixond", "cakexpION", "Colexpone", "coexION", "caxION", "coneuxinion", "Colexion", "conenexion"], "st": ["ist", "ust", "est", "nd", "sl", "se", "it", " est", "tt", "ST", "tmp", "statement", "put", "ct", "ut", "St", "sc", "state", "end", "sw", "ost", "mt", "sle", "std", "t", "pt", "sm", "stable", "src", "null", "sts", "str", "sh", "stop", "sth", "obj", "pe", "sn", " ST", "ste", "stage", "sty", "cl", "set", "stat", "sp", "inst", "start", "ts", "rest"], "MySQL": ["mysDB", "myDB", "MyDB", "mysSQL", "MYQL", "MyQL", "MYSQL", "mysQL", "MYDB", "myQL", "mySQL"]}}
{"id1": "17583193", "id2": "16851955", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "label": 0, "substitutes": {"populateRecord": ["popupdateRec", "popupdateData", "populatesRecord", "populatedRec", " populatesRecord", "populatesrecord", "populatesData", "popupdaterecord", " populateRec", "populaterecord", " populatesData", "populateData", " populateData", " populatesrecord", "populatedRecord", "populatedrecord", "populatesRec", "populatedData", " populaterecord", "popupdateRecord", " populatesRec", "populateRec"], "attrIDs": ["attributeFiles", "attributeFS", "attrID", "permID", "cmpIDS", "sortids", "attributeIDs", "attrIDS", "addrKids", "aaaENTS", "filterids", "permIDs", "arrids", "rmIDS", "attrKids", "attrById", "attrENTS", "attrEMS", "attIDs", "attID", "attFiles", "errIDs", "attributeById", "rmID", "adjUES", "adjIDS", "sortFiles", "addrIDS", "urgLS", "addrUES", "aaaIDS", "attrUES", "arrKids", "arrIDs", "urgENTS", "attrFiles", "attributeENTS", "immID", "urgIDs", "permFS", "adjIDs", "attrFS", "sortKids", "attributeEMS", "cmpIDs", "attributeids", "filterIDS", "aaaIDs", "permIDS", "attributeID", "attrids", "attributeLS", "attFS", "filterIDs", "errIDS", "attIDS", "immEMS", "errUES", "immIDS", "addrIDs", "addrids", "arrIDS", "attributeIDS", "rmIDs", "attrLS", "attEMS", "sortID", "rmById", "immIDs", "sortIDS", "aaaLS", "filterKids", "urgIDS", "attById", "attributeKids"], "i": ["ims", "it", "ri", "ic", "iu", "ind", "qi", "parent", "gi", "any", "iti", "err", "status", "iter", "ori", "ij", "cli", "li", "list", "zi", "init", "my", "ini", "is", "ui", "f", "ia", "q", "o", "uri", "e", "wi", "hi", "g", "ti", "ji", "bi", "name", "l", "print", "us", "ami", "chain", "sim", "ip", "\u0438", "multi", "im", "ity", "n", "ie", "me", "h", "ci", "er", "ii", "index", "d", "u", "ei", "m", "xi", "iq", "z", "pi", "eu", "x", "phi", "ai", "p", "y", "io", "mi", "ki", "v", "ni", "ik", "si", "I", "ir", "base", "di", "info", "in", "c", "ix"], "sortIDs": ["sortMS", "SortIE", "successEMS", "servDetails", " sortDetails", "attrID", "sortDOS", " sortMS", "ortids", "sortids", "filterIDES", " sortDocuments", " sortResults", "attrIDS", "orderIDs", "successUES", "saveLS", "ortIDS", "successKids", "successIDs", "SortLS", "altBytes", " sortKids", "successIDS", " sortBS", "attrMS", "SortEMS", "parseIDs", "attrKids", "ortVs", "servResults", "saveIDs", "sortensions", "syncIDs", "servID", "attrEMS", "shareIDs", "parseIDS", "SortMembers", "updateIDs", "servIDs", "shareUES", "ortIDs", "altEMS", "ortBs", "syncEMS", " sortIDS", "sortVs", "sortFiles", "ortDocuments", "servTags", "altIDS", "saveIE", "ordEMS", "sortBytes", "syncIDS", "servEMS", "orderUES", "saveMS", "altIDES", "orderKids", "SortIDs", " sortBs", "sortLS", " sortids", "ordIDS", "attrFiles", "sortResults", "servBS", " sortBytes", "sortKids", "attrIE", " sortFiles", "sortMembers", "sortDocuments", "filterIDS", "relationIDs", "servids", "relationensions", "shareDOS", "syncBytes", "servMembers", "successDOS", "filterDocuments", "sortTags", "parseKids", "ortDetails", "attrids", " sortID", "sortDetails", "filterIDs", "successTags", "sortBs", "shareKids", "servIDS", "parseIDES", " sortensions", "attrLS", "sortBS", "servVs", "sortEMS", "ordIDs", "saveResults", "ortBS", "servensions", "saveIDS", "altIDs", "sortID", " sortTags", "filterBs", "updateEMS", "ortResults", "ortID", " sortMembers", "servKids", " sortEMS", "ordids", " sortIDES", "relationIDS", "orderDOS", "SortIDS", "sortIDS", "filterKids", "altKids", "successIDES", "updateIDS", "relationMembers", "sortUES", "sortIE", "saveIDES", "saveKids", " sortVs", "servFiles", "updateMembers", "sortIDES"], "j": ["bo", "json", "jet", "jl", "x", "n", "by", "it", "b", "aj", "jj", "q", "je", "y", "rel", "kj", "jit", "dj", "ja", "pr", "ind", "uj", "fr", "pt", "el", "er", "beta", "v", "adj", "js", "e", "g", "ji", "jc", "next", "d", "jac", "jump", "l", "r", "obj", "k", "err", "other", "tr", "bj", "m", "J", "job", "z", "br", "ij", "jp", "out", "oj", "jo", "c", "ix"], "temp": ["buffer", "fake", "emp", "orig", "term", "template", "prime", "EMP", "unt", "tt", "tmp", "rem", "tm", "variable", "read", "test", "cum", "t", "current", "length", "pre", "alt", "tc", "thread", "perm", "ptr", "txt", "mp", "mod", "porary", "Temp", "tim", "mem", "tty", "set", " Temp", "wait", " tmp", "tem"]}}
{"id1": "22536033", "id2": "19134229", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["SetPayload", "setShipment", "Setpayment", "setpayment", "getPayloads", "setMessagements", "Setpayload", "setMessageload", "setHeadload", "setpayloads", "setPayments", "setMessagement", "SetPayLoad", "getPayline", "setHeadLoad", "setHeadline", "SetpayLoad", "getPayLoad", "setShipments", "setpayments", "Setpayments", "setpayline", "setPayline", "setShipload", "setpayLoad", "setHeadloads", "getPayload", "SetPayment", "SetPayments", "setMessageLoad", "setpayload", "setPayloads", "setPayment", "setShipLoad", "setPayLoad"], "fos": ["faos", "hos", "fooss", "sfoss", "foic", "sfic", "wis", "hoss", "sfos", " foss", "fois", "his", "foos", " faos", "foss", "woss", "waos", "wos", "sfis", "haos"], "fis": ["sfiss", " fiss", " fics", "fiss", "fics", "Fis", "xfsis", "flic", " fsis", "xfis", "sfic", "Fiss", "flics", "flis", "Fic", "Fos", "xfic", "sfos", "xfics", "flsis", "fsis", "sfis"], "fic": ["ftic", "fric", " ficc", "sfics", " fics", "fico", "ufic", "affoc", "bfics", "sfric", "fics", "bfic", "bfci", "fci", "sfic", "ufico", "ufci", "cfic", "afftic", "cfics", "ufoc", "sfico", "Fic", "Ftic", "affics", " fric", "ufics", "ficc", " fci", "cficc", "bfico", " ftic", "affic", "uficc", "Foc", " fico", "ufric", "cfoc", "Fics"], "foc": [" fac", "sfac", "froc", "Froc", "floca", "flot", "sfoc", " foco", "floc", "flic", "cfoco", "sfic", "foca", "cfic", "flroc", " foca", "Fic", " froc", "foco", "sfoca", "fac", "Fot", "cfot", "flac", "fot", "floco", " fot", "Foc", "cfoc"], "Index": ["Update", "Size", "Instance", "Connection", "Key", "Se", "Row", "Mass", "Id", "Present", "Out", "Location", "Next", "Found", "Iter", "Socket", "State", "Version", "Counter", "Lock", "Prime", "Num", "Position", "Ind", "Weight", "Column", "Port", "Limit", "Series", "Max", "Exp", "Loop", "Time", "Length", "Zero", "Pos", "Offset", "Count", "Delta", "Value", "Section", "Rank", "Left", "index", "Other", "I", "Label", "Is", "Unique", "Handle", "In", "Foot", "Request", "Name", "Thread", "Current", "Info", "Now", "Insert", "Loc", "Fix", "Link"]}}
{"id1": "23118425", "id2": "13565787", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"encrypt": ["decryption", "Encrypted", "enrypted", "Encryption", "decipher", "decrypted", "enrypt", "encryption", "encipher", "Encrypt", "Encipher", "encrypted", "enryption", "decrypt", "enipher"], "plaintext": ["realtxt", "plainth", "broadstring", "plainpassword", "publictext", "broadText", "plaintxt", " Plaintext", "publicText", " plaintxt", "publicth", "plainText", " plainText", " plainstring", "plainstring", " Plainth", "broadtext", "broadtxt", "publicpassword", "realtext", "realText", " Plainpassword", " plainth", " PlainText", "realstring", " plainpassword"], "md": [" dd", "gr", "dr", "ms", "nd", "sd", "msg", "mc", "bd", "od", "metadata", "del", "MD", "grad", "der", "cd", "ds", "mg", "deb", "mm", "dm", "mt", "ind", "rm", "red", "sm", "dh", "nt", "det", "ld", "doc", "mb", "d", "dd", " mc", "esm", " Md", "mp", "good", "mk", "mod", "managed", "dig", "pd", "m", "df", "material", "mo", "mn", "cmd", "med", "hd", "ad"], "raw": ["message", "rew", "json", "html", "core", "orig", "unsigned", "n", "buf", "unknown", "valid", "draw", "available", "known", "bare", "row", "hook", "rendered", "clear", "all", "hex", " Raw", "pack", "original", "sh", "w", "RAW", "bytes", "cooked", "custom", "extra", " RAW", "input", "mem", "clean", "data", "full", "random", "aw", "out", "Raw", "ng"], "hash": ["message", "json", "html", "rh", "password", "mask", "Hash", "hed", "has", "sha", "id", "ssh", "ashes", "h", "ASH", "ashed", "total", "alert", "tag", "cloth", "component", "hex", "key", "name", "sh", "dump", "mac", "shadow", "sum", "tr", "href", "print", "check", "bh", "search", "height", "proof", "handle", "ash"]}}
{"id1": "3375724", "id2": "4593012", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" insertarEmissoresDosTitULosT", " insertarEmissoresDosTitULoT", " insertarEmissoresDosTitulasC", " insertarEmissoresDosTituloFe", " insertarEmissoresDosTitULosF", " insertarEmissoresDosTitulasT", " insertarEmissoresDosTitULosFe", " insertarEmissoresDosTitULoF", " insertarEmissoresDosTitulOsF", " insertarEmissoresDosTitulosFe", " insertarEmissoresDosTituloF", " insertarEmissoresDosTitULosC", " insertarEmissoresDosTitulosF", " insertarEmissoresDosTituloC", " insertarEmissoresDosTituloT", " insertarEmissoresDosTitulOsFe", " insertarEmissoresDosTitulasFe", " insertarEmissoresDosTitulasF", " insertarEmissoresDosTitULoFe", " insertarEmissoresDosTitulosT", " insertarEmissoresDosTitULoC", " insertarEmissoresDosTitulOsT", " insertarEmissoresDosTitulosC", " insertarEmissoresDosTitulOsC"], "pArquivoTXT": ["pArquivoTxt", "pArquivotxt", "pArquiveTBT", "pArquivTXT", "pArquivoDXT", "pArquivTIN", "pArquivRxt", "pArquivotIN", "pArquivoTEX", "pArquiveTXT", "pArquivoBEX", "pArquivNRL", "pArquivTEX", "pArquivotOX", "pArquivoTOX", "pArquivNxt", "pArquivNXT", "pArquivTxt", "pArquivoRIN", "pArquivoROX", "pArquivoFEX", "pArquivRXT", "pArquivoTRL", "pArquiveNBT", "pArquivoNXT", "pArquivoNBT", "pArquivoRxt", "pArquivTRL", "pArquiveNXT", "pArquivTOX", "pArquiveTEX", "pArquivoDRL", "pArquivoXTXT", "pArquivRIN", "pArquiveNxt", "pArquivotXT", "pArquivoXTxt", "pArquivoNxt", "pArquivoDEX", "pArquivoNRL", "pArquivNEX", "pArquivoFxt", "pArquivoFRL", "pArquivoTBT", "pArquivoBXT", "pArquivoXTIN", "pArquivoFXT", "pArquivoTIN", "pArquivoFBT", "pArquiveNEX", "pArquivoRXT", "pArquivoNEX", "pArquiveTxt", "pArquivoBBT", "pArquivoBxt", "pArquivROX", "pArquivoDxt", "pArquivoXTOX"], "pAndamento": ["pAndumentO", "pandamentoS", "pAndumentoS", "pAndmentO", "pandmento", "pAndmentos", "pAndumento", "pAndemento", "pandmentoS", "pAndementO", "pAndementos", "pandamentos", "pAndumentos", "pAndementoS", "pandmentos", "pAndamentos", "pAndmentoS", "pandamentO", "pandmentO", "pandamento", "pAndamentO", "pAndamentoS", "pAndmento"], "numeroDoRegistro": ["numeroDoRegendros", "numeroDoregestro", "numeroDoRegendro", "numeroDoregistro", "numeroDoRegistulo", "numeroDoRegistr", "numeroDoRegestros", "numeroDoRegendr", "numeroDoRegitros", "numeroDoregistr", "numeroDoregestr", "numeroDoregestros", "numeroDoRegestr", "numeroDoRegitulo", "numeroDoRegitr", "numeroDoRegitro", "numeroDoRegestulo", "numeroDoregestulo", "numeroDoRegestro", "numeroDoRegendulo", "numeroDoregistros", "numeroDoregistulo", "numeroDoRegistros"], "in": ["IN", " nin", " sin", "din", "gin", "con", "inf", "n", "inning", "ln", "rin", "vin", "sin", " inn", "f", "pin", "scan", "inc", "nin", "tin", "from", "ins", "bin", "edIn", "inner", "reader", "kin", "isin", "In", "min", "ner", "input", "m", " din", "inn", "out", "thin", " ins", " out", "cin"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestinos", "stmtLimpezaInicioDestinos", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialEstination", "stmtLimpezaIniciaDestinos", "stmtLimpezaIniciaEstINO", "stmtLimpezaInicialDestaine", "stmtLimpezaInicialDecINO", "stmtLimpezaInicialEstINO", "stmtLimpezaInicialStination", "stmtLimpezaInicialEstino", "stmtLimpezaIniciaEstination", "stmtLimpezaIniciaDestINO", "stmtLimpezaIniciaEstinos", "stmtLimpezaInicialStino", "stmtLimpezaInicialStaine", "stmtLimpezaInicialDestinos", "stmtLimpezaInicioEstaine", "stmtLimpezaInicialStinos", "stmtLimpezaInicialDecaine", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDecino", "stmtLimpezaInicialStINO", "stmtLimpezaInicioEstino", "stmtLimpezaInicioEstinos", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDecinos", "stmtLimpezaInicioDestaine", "stmtLimpezaInicioEstINO", "stmtLimpezaInicialDestination", "stmtLimpezaIniciaEstino", "stmtLimpezaInicialDestINO", "stmtLimpezaInicioDestINO", "stmtLimpezaInicialdestino", "stmtLimpezaIniciaDestination", "stmtLimpezaInicioDestino", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialEstaine"], "sql": ["fn", "expression", "session", "spr", "json", "html", "description", "ls", "lex", "template", "ln", "pel", "msg", "sd", "wal", "statement", "seed", "q", "ql", "socket", "params", "raw", "rel", "inv", "qs", "SQL", "xs", "ssl", "dl", "nl", "pp", "spec", "serv", "js", "sol", "script", "name", "str", "xml", "sn", "command", "details", "string", "select", "scl", "csv", "log", "join", "sp", "query", "sv", "format", "s", "url", "eps", "cmd", "sq"], "stmtDestino": ["stMTDestin", "stmtdestINO", "stMTDecino", "stMTDestinos", "stmtInstinos", "stmtStINO", "stmtDecino", "stmtDestination", "stmtdestinos", "stmmInstination", "stmtdestination", "stmmInstino", "stmmDestino", "stmtDecINO", "stmmDestinos", "stmtdestin", "stmtDestin", "stmtStino", "stMTDecinos", "stmtStin", "stmtDecinos", "stmtStinos", "stmtInstorno", "stmmDestorno", "stmtDecin", "stmmDestination", "stmmInstorno", "stMTDestINO", "stMTDestino", "stmtdestino", "stMTDecINO", "stMTDecin", "stmtStination", "stmtdestorno", "stmmInstinos", "stmtInstination", "stmtStorno", "stmtDestINO", "stmtDestinos", "stmtDestorno", "stmtInstino"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECILHI", "TAMANHO_DO_CABUCALHO", "TAMANHO_DO_CABUCALH", "TAMANHO_DO_CABUCALLHI", "TAMANHO_DO_CABECULH", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALHA", "TAMANHO_DO_CABECALH", "TAMANHO_DO_CABUCALLH", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECARH", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABUCALHI", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALLH", "TAMANHO_DO_CABECALLHA", "TAMANHO_DO_CABECILHO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECARHA", "TAMANHO_DO_CABUCALLHO", "TAMANHO_DO_CABUCALHA", "TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABECILHA", "TAMANHO_DO_CABUCALLHA", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECILH"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAP_FILE", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJFILE", "TAMANHO_DO_RODAPE_FILE", "TAMANHO_DO_RODAPE2Do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE2do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPE2DO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_DO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADS_", "TAMANHO_DOS_METADADSON", "TAMANHO_DOS_METADABOON", "TAMANHO_DOS_METADABOSON", "TAMANHO_DOS_METADABO_", "TAMANHO_DOS_METADADOON", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADABos_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADABOS_", "TAMANHO_DOS_METADADOSON", "TAMANHO_DOS_METADADDSON", "TAMANHO_DOS_METADADDS_"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_REGIN", "TAMANHO_MEDIO_POR_REGis", "TAMANHO_MEDIO_POR_REMES", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_RegESS", "TAMANHO_MEDIO_POR_RECis", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegIN", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_REMESS", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_POR_REMIN", "TAMANHO_MEDIO_POR_REMIS", "TAMANHO_MEDIO_POR_Regis", "TAMANHO_MEDIO_POR_RegIC"], "tamanhoDosArquivos": ["tamanhoDosArquesivalos", "tamanhoDosArquIVlos", "tamanhoDosArquIVo", "tamanhoDosArquivao", "tamanhoDosArqIVo", "tamanhoDosArquIVores", "tamanhoDosArquivalores", "tamanhoDosArquesivo", "tamanhoDosArqIVores", "tamanhoDosArquivelos", "tamanhoDosArquives", "tamanhoDosArquivores", "tamanhoDosArquivalo", "tamanhoDosArqIVos", "tamanhoDosArquivaos", "tamanhoDosArquesivoes", "tamanhoDosArquiveoes", "tamanhoDosArquivs", "tamanhoDosArquesivlos", "tamanhoDosArqivos", "tamanhoDosArquivalos", "tamanhoDosArquivlos", "tamanhoDosArquiveo", "tamanhoDosArqIVs", "tamanhoDosArquIVos", "tamanhoDosArquivals", "tamanhoDosArquesivao", "tamanhoDosArquivaoes", "tamanhoDosArqivo", "tamanhoDosArquivoes", "tamanhoDosArqivs", "tamanhoDosArquIVoes", "tamanhoDosArquiveores", "tamanhoDosArquivo", "tamanhoDosArquesivaoes", "tamanhoDosArquIVs", "tamanhoDosArqivores", "tamanhoDosArquesivos", "tamanhoDosArquiveos", "tamanhoDosArquesivaos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstamadas", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimmados", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstamada", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstamados", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstamado", "quantidadeDeRegistrosEstimadas"], "registro": ["registrob", "Regestros", "regdistrob", "Registr", "regitrob", "regdistro", "regitro", "regestro", "regdistr", "Registros", "Regestro", "Regestrob", "Registrob", "regitr", "Registro", "regestrob", "regestros", "regdistros", "registr", "regitros", "registros", "Regestr", "regestr"], "campos": ["taros", " campOS", "jamo", "tarOs", "jamos", " campOs", "taro", "jamOS", "campOs", "tarOS", "campo", "campOS", " campo", "jamOs"]}}
{"id1": "1798720", "id2": "1357662", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"save": ["update", "saving", "init", "pkg", "send", " seal", "Save", "folder", "export", "download", "accept", "install", "register", "filename", "release", "delete", "store", "version", "dump", "upload", "archive", " Save", "data", "aw", "pack", "zip"], "packageName": ["packageCode", "PackageName", " packageNames", " packageCode", "moduleNames", "modulename", "packagename", " packageType", "moduleCode", "packageType", "PackageType", "pkgname", "packageNames", "PackageNames", "moduleName", " packageKey", "PackageId", "moduleKey", "pkgNames", "packageId", "pkgId", "pkgType", "pkgCode", "pkgKey", "pkgName", "packageKey", "moduleId", " packageId", " packagename"], "fileContents": ["byteContent", "FileValues", "fileContent", "FileBytes", "fileItems", " fileItems", "FileContent", "FileIngredients", "byteContents", "pageContents", " fileContent", "packageContents", "packageContent", "packageNames", " fileValues", "pageBytes", "pageItems", "FileItems", "FileContents", "fileBytes", "pageNames", "packageIngredients", "fileIngredients", "byteValues", " fileIngredients", "fileValues", "byteNames", "FileNames", " fileBytes"], "fileNames": ["fileLeaks", "moduleNames", "FileValues", "fieldNames", "fileVaults", " fileVaults", "FileName", "FileKeys", "fieldNumbers", "moduleContents", "messageNames", "dirTypes", "FileTypes", "issueName", "issueVaults", "moduleVaults", " fileValues", "FileLeaks", "fileName", "resourceNames", "fileTypes", "FileContents", "messageValues", " fileLeaks", "fileKeys", "resourceTypes", "moduleName", "dirKeys", "issueContents", "resourceValues", "issueNames", "dirLeaks", "resourceContents", "fileValues", "messageKeys", "fieldContents", " fileTypes", "fieldTypes", "resourceNumbers", " fileNumbers", "FileNames", " fileKeys", "dirNames", "fileNumbers", " fileName", "messageName"], "dirBase": ["DIRBuilder", "DirBas", " directoryBottom", "pkgSet", "directoryBase", "dirSet", "pkgBase", "DIRBottom", "dirBuilder", "directorybase", "directorySet", " directoryBase", "pathBasic", "irBase", "dirBasic", "pathBas", " directoryBuilder", "dirBottom", "folderBas", " directoryBas", "folderBase", "irbase", "pathbase", "dirBas", "DIRBas", "DirBottom", "dirbase", "irBas", "pkgbase", "DirBase", "irSet", "pkgBas", "folderbase", "DirBuilder", "DIRBase", "pathBase", "directoryBasic", "directoryBas", "folderBasic"], "packageDir": [" packageFolder", "modulePath", "podD", " packagePath", "packageDef", "pkgDir", "installD", " packageD", "packageFolder", " packageDist", "installDir", "moduleRel", "moduleDir", "pkgPath", " packageRel", "packageD", "podDir", "podDist", "pkgRel", "installDef", "installDist", "pkgFolder", "moduleDef", "moduleFolder", "pkgDef", "podDef", "packageRel", " packageDef", "packageDist", "packagePath"], "created": ["joined", "loaded", "existent", "printed", "added", "released", "present", " generated", "creat", "installed", " started", "registered", "locked", "create", "generated", "produced", "checked", "creator", "associated", "filled", "made", "started", "raised", "ready", "confirmed", "creation", "founded", "recorded", "Created", "mounted", "TED", "defined", "ced", "called", "given", "activated", "developed", "arted", "provided", "reported", "successful", "allowed", "forced"], "currentPath": [" currentName", "recentParent", " currentParent", " currentFile", "currentParent", "currentlyName", "currentName", "currentlyCh", "currentlyPath", "currentPoint", "recentPoint", " currentPoint", "CurrentName", "CurrentPath", "CurrentCh", "recentPath", "currentCh", "CurrentParent", "CurrentPoint", " currentCh", "currentlyFile", "currentFile", "recentName", "CurrentFile"], "i": ["it", "ri", "ic", "iu", "iii", "ind", "qi", "gi", "status", "iy", "ij", "cli", "li", "oi", "zi", "j", "init", "my", "ini", "ui", "f", "jj", "q", "o", "ex", "uri", "slice", "this", "hi", "g", "ji", "bi", "ti", "go", "batch", "ami", "chain", "sim", "ip", "multi", "im", "ity", "ie", "me", "major", "id", "os", "ci", "ii", "index", "u", "ei", "yi", "m", "xi", "iq", "exp", "pi", "phi", "ai", "ski", "p", "y", "mi", "ki", "v", "key", "cgi", "si", "I", "them", "mu", "di", "info", "in", "ix"], "file": ["path", "buffer", "disk", "db", "template", "fo", "header", "type", "link", "f", "et", "body", "p", "pool", "h", "local", "row", "dir", "io", "File", "resource", "parent", "le", "rule", "name", "play", "handler", "l", "page", "ile", "FILE", "base", "source", "set", "child", "port", "table", "log", "comment", "info", "format", "handle", "sf"], "fos": ["faos", " fOS", " fo", "ffaos", "ffoes", "oos", "fow", "fo", " foses", "Foss", "woses", "oaos", "sfOS", "fOS", "sfoss", "fbos", "flaos", " fow", " foes", "Faos", "sfaos", "Foes", "FOS", "flo", "oo", "flos", "floes", "Fos", "fbo", "floses", "foes", "Fo", "floss", "sfos", " foss", "fbaos", "ffo", "woes", "oow", "foses", " faos", "foss", "woss", "ffos", "wos", "fbow"], "fileSrc": ["jobNrc", "fileDrc", "jobSci", "jobNrl", "fileNrl", "fileInssrc", "fileDource", " fileInsRC", "jobNci", "fileErl", " fileSsrc", "fileNri", "jobSrc", " fileInsource", "fileDri", "fileSrl", " fileInssrc", "fileSci", "fileInrc", "fileDrl", "jobNri", "fileEci", "fileInource", "jobSrl", " fileSource", "fileInsrc", " fileSRC", "fileInRC", "fileDci", "fileDsrc", "jobSri", "fileSource", "fileSsrc", "fileSRC", "fileInsRC", " fileInsrc", "fileEri", "fileSri", "fileErc", "fileDRC", "fileNrc", "fileInsource", "fileNci"], "fileDst": ["FileDcr", "FileSld", "FileDnd", "FileSlt", "fileSlt", "fileNlt", "fileSst", "fileNld", "FileSst", "FileDpl", "FileDld", "fileSnd", "fileDcr", "filedld", "fileSld", "FileDlt", "filedst", "fileDot", "FileSot", "fileSpl", "fileDnd", "fileDpl", "FileScr", "fileNot", "FileDst", "fileWot", "fileWlt", "fileNnd", "fileDld", "FileSnd", "fileDlt", "filednd", "fileNst", "filedcr", "FileDot", "fileWst", "fileSot", "fileScr", "fileNpl", "FileSpl", "fileWpl", "fileNcr"], "reader": ["buffer", "runner", "dr", "rar", "book", "ri", "author", "controller", "rx", "review", "rer", "loader", "parser", "rc", "read", "row", "iterator", "er", "resource", "inner", "readable", "reading", "handler", "stream", "rot", "rr", "ocker", "upper", "Reader", "Larry", "roller", "oder", "ner", "entry", "iter", "rl", "driver", "actor", "ro", "query", "context", "ader", "r", "ler"], "writer": ["buffer", "runner", "word", "function", "builder", "adder", "window", "caster", "user", "worker", "draw", "manager", "flush", "riter", "loader", "writers", "variable", "console", "parser", "writing", "read", "iterator", "test", "maker", "creator", "later", "client", "liner", "server", "wright", "wrapper", "browser", "operator", "write", "store", "wire", "handler", "println", "w", "service", "stream", "player", "ter", "print", "Reader", "entry", "Writer", "iter", "table", "driver", "document", "walker", "format", "query", "outer", "storage", "report", "editor", "order"], "line": ["message", "style", "text", "node", "cell", "block", "lin", "ln", "valid", "user", "header", "eline", "detail", "link", "entity", "row", "sample", "frame", "ole", "nl", "liner", "continue", "le", "code", "inline", "ine", "rule", "label", "edge", "LINE", "number", "l", "kin", "page", "sequence", "record", "pe", "entry", "print", "source", "point", "string", "port", "date", "stroke", "range", "comment", "chain", "lined", "column", "word", "Line"]}}
{"id1": "13657527", "id2": "3801655", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatasesResult", "getDatisetsStatus", "getDatisetsResult", "getDatasuresResult", "getDatasuresList", "getDatasetsResult", "getDatisetList", "getDatasetList", "getDatasesList", "getDatasuresStatus", "getDatasetsStatus", "getDatisetResult", "getDatisetStatus", "getDatasetStatus", "getDatasesStatus", "getDatisetsList", "getDatasetResult"], "surl": ["sURL", "jslim", "esURL", " suri", "lsUrl", "stsurl", "slim", "lsurl", "sysserver", "sysurl", "sysuri", "jsuri", "ssurl", "ssUrl", " sname", " smail", "suri", "jsurl", "slt", "sserver", "sname", "lsserver", "esUrl", "lslt", "ssURL", "stslt", "sslim", "esname", "stsserver", "lsuri", "sUrl", " sUrl", "smail", "jsUrl", "ssuri", "stsuri", "lsmail", "syslt", "esuri", "esurl"], "datasetsList": ["datassetsList", "datasagesSet", "datasetLock", "datasETSMap", "datasagesList", "datasetGroup", "datarsetSet", "datisetMap", "datisetsMap", "datasetlist", "datarsetsLock", "datmassetsList", "datasetsTable", "datasensList", "datmasetsLock", "datassetsSet", "datasagesTable", "datarsetList", "dataselinesName", "datarssetsLock", "datassetsTable", "datasagesMap", "datasETSName", "datasetsSet", "datasETSGroup", "datasourcesSet", "datarssetsList", "datmassetsData", "datmassetsMap", "datasuresMap", "datasourcesTable", "datarssetsTable", "datarsetsMap", "datasagesData", "datasETSList", "datasetMap", "datassetslist", "datasuresList", "datarsetsList", "datasetsData", "datasourcesLock", "datarsetsSet", "datasetsGroup", "datasetslist", "datmasetsData", "datasetsLock", "dataselinesList", "datasourcesList", "dataselinesGroup", "datmasetsList", "datisetsList", "datasetSet", "datasuresSet", "datmasetsMap", "datasamesSet", "datisetsGroup", "datasenslist", "datmassetsLock", "datarsetMap", "datasamesList", "datassetsData", "dataselinesMap", "datasensMap", "datasagesLock", "datarsetslist", "datarsetlist", "datarssetsSet", "datisetList", "datasetList", "datasetsMap", "datasamesMap", "datasureslist", "datisetsName", "datasetsName", "datassetsLock", "datisetName", "datasetName", "datisetGroup", "datassetsMap", "datarsetsTable", "datasetData", "datasameslist"], "result": ["buffer", "message", "successfully", "description", "first", "menu", "valid", "ret", "detail", "response", "exist", "complete", "folder", "relation", "test", "default", "answer", "contact", "sequence", "record", "form", "details", "set", "def", "status", "table", "comment", "results", "chain", "cert", "search", "success", "found", "res", "there", "successful", "diff", "report", "Result"], "reader": ["field", "buffer", "runner", "ser", "dr", "bo", "per", "rar", "peer", "author", "handle", "via", "body", "rer", "loader", "socket", "parser", "read", "row", "iterator", "test", "older", "rd", "er", "READ", "client", "resource", "liner", "timer", "wrapper", "operator", "river", "inner", "writer", "reading", "handler", "stream", "mr", "rr", "redo", "upper", "Reader", "ner", "roller", "iter", "rl", "layer", "file", "driver", "ro", "range", "query", "r"], "url": ["http", "mail", "ls", "location", "sl", "org", "user", "link", "ur", "Url", "ul", "address", "URL", "loader", "id", "row", "ssl", "uri", "dl", "nl", "client", "resource", "browser", "key", "null", "str", "mount", "ll", "stream", "l", "char", "lr", "rl", "file", "web", "r", "il"], "s": ["series", "strings", "ls", "ms", "abs", "es", "n", "gets", "is", "has", "b", "gs", "bs", "as", "ss", "y", "sql", "ds", "its", "qs", "os", "h", "ws", "hs", "sample", "sw", "cs", "ins", "t", "sym", "ps", "rs", "v", "js", "ids", "ns", "less", "str", "sts", "ats", "ts", "still", "l", "string", "source", "us", "csv", "i", "tes", "sb", "sv", "full", "r", "S", "sq"], "list": ["collection", "ist", "top", "part", "ls", "st", "add", "block", "member", "detail", "ml", "pretty", "pool", "local", "test", "left", "note", "dl", "lists", "all", "group", "ll", "l", "sequence", "form", "cont", "print", "batch", "set", "def", "table", "log", "stack", "chain", "join", "format", "listed", "array", "php", "layout", "LIST", "full", "li", "word", "L", "single"]}}
{"id1": "13362846", "id2": "20100809", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setCont\u00ednU", "setcontensenux", "setContensenu", "setCont\u00ednue", "setContenux", "setContensenux", "setCont\u00ednux", "setContennU", "setContensenue", "setcontenu", "setContenue", "setContenU", "setcontenU", "setcontensenU", "setContennu", "setContensenU", "setcontenue", "setcontensenu", "setcontenux", "setCont\u00ednu", "setContennux", "setContennue", "setcontensenue"], "contenuFichier": ["contenuVechier", "contenuFicheaire", "contenuFiveraire", "contenuFamilyachier", "contenuVichyr", "contenuVchIER", "contenuFichie", "contenuVchie", "contenuMicheiere", "contenuFsrenchaire", "contenuFicheiere", "contenuFihiere", "contenuFrenchier", "contenuFsrenchieri", "contenuFechier", "contenuFileochiere", "contenuFsrenchire", "contenuVchier", "contenuFuffer", "contenuFchiere", "contenuFamilyichie", "contenuFignaire", "contenuFecher", "contenuFihier", "contenuFsechier", "contenuFichtIER", "contenuFileochiers", "contenuFsicher", "contenuFithyr", "contenuFolfire", "contenuFsrenchier", "contenuFChier", "contenuFamilyachie", "contenuVichIER", "contenuFsichieri", "contenuMicheaire", "contenuFechiest", "contenuFileichiere", "contenuFihiest", "contenuFechieri", "contenuFrenchieri", "contenuVichier", "contenuFithier", "contenuFolfier", "contenuMichiere", "contenuFithiest", "contenuFamilyachiere", "contenuVechiere", "contenuMicheier", "contenuFChaire", "contenuFachiers", "contenuFochier", "contenuFsichaire", "contenuFachorie", "contenuFachier", "contenuFiverieri", "contenuFileochie", "contenuFolfer", "contenuVechyr", "contenuFichIER", "contenuFsecher", "contenuVchiere", "contenuFicher", "contenuFigniere", "contenuFichieri", "contenuFechiere", "contenuFechire", "contenuFolfieri", "contenuMichaire", "contenuMicheer", "contenuFochie", "contenuFichire", "contenuFamilyichorie", "contenuFichiest", "contenuFachie", "contenuFicheorie", "contenuFsechire", "contenuFchier", "contenuFochiere", "contenuFamilyichiere", "contenuFileochier", "contenuFachiere", "contenuFiverire", "contenuFchIER", "contenuFamilyachorie", "contenuFignier", "contenuFochiers", "contenuFichaire", "contenuFsichire", "contenuFichtie", "contenuFsechieri", "contenuFichiers", "contenuFicheieri", "contenuFechyr", "contenuFiverier", "contenuFCher", "contenuFichorie", "contenuFChiere", "contenuFichtiere", "contenuFithie", "contenuFileichiers", "contenuFamilyichier", "contenuFicheiers", "contenuFrenchaire", "contenuFicheer", "contenuFithorie", "contenuVichie", "contenuFchie", "contenuFrenchire", "contenuFithiere", "contenuFuffieri", "contenuFihyr", "contenuFileichier", "contenuFuffire", "contenuMichier", "contenuFichtier", "contenuFicheier", "contenuFichyr", "contenuFichiere", "contenuVechiest", "contenuFuffier", "contenuMicher", "contenuFigner", "contenuVichiest", "contenuVichiere", "contenuFicheie", "contenuFochIER", "contenuFileichie", "contenuFicheire", "contenuFsichier"], "fichierElectronique": ["fichierelectronier", "fichierCentronique", "fichierElectRONique", "fichierAdministroniques", "fichierElectroneic", "fichierelectroniques", "fichierElectrenicy", "fichierelectrenique", "fichierCentRONius", "fichierSelectroneiques", "fichierElectrontique", "fichierelectronic", "fichierElectonique", "fichierElectRONaire", "fichierCentronicy", "fichierElectoniques", "fichierElectromius", "fichierElectonier", "fichierAdministroneiq", "fichierElectromie", "fichierElectchronicy", "fichierCentRONique", "fichierElectrontipolar", "fichierTransferronic", "fichierAdministronique", "fichierElectronsie", "fichierElectrenique", "fichierTransferradorie", "fichierElectromicity", "fichierElectronicity", "fichierAdministroniq", "fichierElectronie", "fichierElectrontaire", "fichierSelectroniques", "fichierElectroneiq", "fichierTransferronius", "fichierAdministroneique", "fichierTransferradorique", "fichierCentronius", "fichierCentRONaire", "fichierElectronsiques", "fichierElectreniques", "fichierElectroneius", "fichierElectronsiq", "fichierElectrenaire", "fichierElectradorius", "fichierElectronsicity", "fichierElectronius", "fichierElectromaire", "fichierElectromipolar", "fichierElectRONius", "fichierSelectronicity", "fichierSelectronique", "fichierSelectroneique", "fichierElectronoch", "fichierElectroneie", "fichierTransferradorius", "fichierElectchronaire", "fichierElectricie", "fichierElectRONicy", "fichierElectchronique", "fichierElectronipolar", "fichierElectroneoch", "fichierelectreniques", "fichierElectronier", "fichierAdministroneie", "fichierelectrenier", "fichierelectronique", "fichierTransferronique", "fichierElectrenius", "fichierAdministroneiques", "fichierElectronic", "fichierElectroniq", "fichierElectronsoch", "fichierElectchroniques", "fichierElectroneaire", "fichierElectricique", "fichierElectromic", "fichierElectchronicity", "fichierTransferronie", "fichierElectradorie", "fichierElectradorique", "fichierElectrenic", "fichierelectrenic", "fichierTransferradoric", "fichierElectrenier", "fichierElectroneicity", "fichierCentronaire", "fichierElectroneipolar", "fichierCentRONicy", "fichierSelectroneicity", "fichierElectriciq", "fichierElectromique", "fichierElectronaire", "fichierElectronsier", "fichierElectroniques", "fichierElectroneique", "fichierElectradoric", "fichierElectronsic", "fichierElectronicy", "fichierElectriciques", "fichierElectronticity", "fichierElectroneiques", "fichierElectchronoch", "fichierElectronsique", "fichierElectchronius", "fichierAdministronie", "fichierSelectronoch", "fichierElectonic", "fichierSelectroneoch"], "utilisateurCourant": ["utilisateurParticipant", "utilisateurGovernants", "utilisateurRepresentant", "utilisateursCourant", "utilisateursCouriant", "utilisateursGovernante", "utilisateurRepresentiant", "utilisateurGoverniant", "utilisateurGovernant", "utilisateurParticipants", "utilisateurGovernante", "utilisateursGoverniant", "utilisateurRepresentante", "utilisateurCourants", "utilisateursGovernant", "utilisateurParticipiant", "utilisateursGovernants", "utilisateursCourante", "utilisateursCourants", "utilisateurRepresentants", "utilisateurCourante", "utilisateurParticipante", "utilisateurCouriant"], "support": ["collection", "history", "replace", "access", "cover", "force", "supported", "see", " Support", "accept", "install", "help", "control", "use", "feature", "allow", "pport", "library", "trust", "null", "share", "know", "service", "SUP", "please", "language", "cap", "port", "profile", "system", "document", "evidence", "media", "format", "success", "context", "proof", "storage", "prototype", "supp", "Support"], "ficheDocument": [" ficheDatabase", "bacheDocument", "ficiDocument", "fitimeDocument", "fitimeDatabase", "bacheDatabase", "ficiMatrix", "fiqueDescription", "FicheDatabase", "facheJournal", "ficiTransaction", "frenchDatabase", "foyerDoc", "FicheDocument", "fayeDocuments", "fcheDocument", "hacheJournal", "FayeDoc", "fcheTree", "frenchDoc", "fliciDatabase", "ficiJournal", "bicheDocument", "fachedocument", "facheTransaction", "fifaDatabase", "bicheDoc", "fruitDocument", "facheTree", "frenchDescription", "bacheDoc", "fliciMatrix", "foyerDocument", " frenchDescription", "frenchTransaction", "fcheDoc", "hacheDocument", "fifaDocument", "flicheTransaction", "foyerDatabase", "hicheJournal", "ficidocument", "fayeDoc", "FicheDoc", "flicheDocument", "fliciDocument", "fitimeTransaction", "fiqueDatabase", "frenchDocument", "flicheDatabase", "fruitTransaction", "hichedocument", " frenchDocument", "fayeDatabase", "ficheMatrix", "fichedocument", "frenchMatrix", "hicheDocument", " frenchDatabase", "fruitdocument", "ficheJournal", "fliciTransaction", "foyerTree", "flicheMatrix", "bicheDatabase", "hachedocument", "fifaDoc", "facheDocument", "FayeDocument", "ficheDocuments", "fiqueDocument", "facheDatabase", "ficheDatabase", "ficheDoc", "ficheTransaction", "bacheTree", "hicheTransaction", "ficheDescription", "ficiDatabase", "bicheTree", "fruitJournal", "FicheDocuments", "fitimeMatrix", " ficheDescription", "fitimeDescription", "ficheTree", "hacheTransaction", "facheDoc", "frenchDocuments", "fcheDatabase", "fifaDocuments", "FayeDocuments", "FayeDatabase", "fayeDocument"], "nomFichier": ["nomFichomer", "nomFericier", "nomFcher", "nomFicier", "nomFicher", "nomPFoililler", "nomFchier", "nomFichIER", "nomFichoancer", "nomFachier", "nomFicomer", "nomFichie", "nomPFichiller", "nomUFichire", "nomFericIER", "nomFacherer", "nomNolfiere", "nomPichier", "nomFericanger", "nomFichiere", "nomFicire", "nomUFichIER", "nomFacher", "nomPFoilier", "nomNichie", "nomFoiljer", "nomFachery", "nomPachier", "nomFilicjer", "nomFicheire", "nomFiverire", "nomFiverIER", "nomFoilier", "nomFiverier", "nomFiverery", "nomFoilER", "nomFicER", "nomFchiner", "nomPFoiljer", "nomFachIER", "nomFichoIER", "nomNolfie", "nomFolfier", "nomFicheier", "nomFchomer", "nomFichire", "nomFachomer", "nomUFachier", "nomFihIER", "nomFericancer", "nomPachomer", "nomFiliciller", "nomUFachIER", "nomFolfiere", "nomPicherer", "nomNichire", "nomUFichier", "nomFachiere", "nomFicheer", "nomFichancer", "nomFilicER", "nomFchire", "nomFilicier", "nomFolfie", "nomFihery", "nomUFachery", "nomPichomer", "nomFachire", "nomFicerer", "nomNichiere", "nomFichoanger", "nomFicheiner", "nomFicjer", "nomPichire", "nomFachanger", "nomFichery", "nomFicheiere", "nomPFichER", "nomFchiere", "nomFcherer", "nomPFoilER", "nomFichanger", "nomFiciller", "nomFachie", "nomFolfire", "nomFichjer", "nomUFachire", "nomFichiller", "nomNolfier", "nomFachancer", "nomNolfire", "nomFoililler", "nomPacherer", "nomPFichier", "nomFicheie", "nomPFichjer", "nomFihire", "nomFichER", "nomFichiner", "nomPachire", "nomUFichery", "nomFicherer", "nomFichoier", "nomNichier", "nomFihier", "nomFachiner"], "extension": ["protension", "Extension", "expractor", "strension", "protention", "Extending", "xtensions", "Extensions", "contension", "expension", "protitude", "contention", "xtension", "extending", "expitude", "strensions", "extractor", "strending", "extitude", "protractor", "expention", "extention", "xtending", "extensions", "contitude", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueLocalistent", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusistant", "fichierElectronicityInert", "fichierElectroniqueEXistance", "fichierElectroniquePersistant", "fichierElectronogramLocalistent", "fichierElectroniqueAssclusive", "fichierElectroniquePresentiker", "fichierElectroniquePlusiker", "fichierElectroniqueLocalistant", "fichierElectronogramExistance", "fichierElectronogramLocalistant", "fichierElectroniqueAssistent", "fichierElectroniqueEXert", "fichierElectronicityExert", "fichierElectronogramExistent", "fichierElectroniqueExvant", "fichierElectroniqueExistent", "fichierElectronogramLocalclusive", "fichierElectroniqueInistent", "fichierElectronicityInistant", "fichierElectroniqueEXvant", "fichierElectroniqueInclusive", "fichierElectroniqueInistance", "fichierElectronogueExistant", "fichierElectroniqueLocalistance", "fichierElectronoguePersistent", "fichierElectronogramExclusive", "fichierElectronogramLocalistance", "fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityExistant", "fichierElectroniqueEXistant", "fichierElectroniqueExplvant", "fichierElectroniqueAssistance", "fichierElectroniqueExister", "fichierElectronicityInvant", "fichierElectroniqueExplistant", "fichierElectroniqueInistant", "fichierElectronogueExiker", "fichierElectroniqueExert", "fichierElectronogueExister", "fichierElectronogueExistent", "fichierElectronoguePersiker", "fichierElectroniqueInvant", "fichierElectroniquePersiker", "fichierElectroniqueExistance", "fichierElectronoguePersister", "fichierElectroniqueExplert", "fichierElectroniqueExclusive", "fichierElectroniquePresentistant", "fichierElectronicityExvant", "fichierElectroniqueInert", "fichierElectroniqueLocalclusive", "fichierElectroniqueAssistant", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectroniquePlusistent", "fichierElectroniquePresentister", "fichierElectroniqueExplistance", "fichierElectronicityInistance", "fichierElectroniquePresentistent"], "idIgid": ["idIgcid", "idImgids", "idIgaddress", "idIgcido", "idIIgid", "idIgcoid", "idIigmaddress", "idIIgoid", "idIgzida", "idIegids", "idIgida", "idIgzido", "idAmgaddress", "idAgid", "idAmgis", "idIgoid", "idIgdido", "idIgcida", "idIgido", "idIIgzid", "idImgaddress", "idIgdata", "idIegdata", "idIkglimit", "idIIgzoid", "idIIgzido", "idIkgis", "idAglimit", "idIegid", "idIigmlimit", "idAmglimit", "idIgids", "idIgzid", "idIigmid", "idIgis", "idIIgido", "idIgdid", "idIkgaddress", "idIgdoid", "idAmgid", "idAgaddress", "idIigmis", "idIgzoid", "idIgkey", "idIkgid", "idImglimit", "idIvgkey", "idImgkey", "idImgid", "idIegkey", "idIIgzida", "idIgdida", "idIvgid", "idIvgdata", "idAgis", "idIglimit", "idIvgids", "idImgdata", "idImgis", "idIIgida"], "inputStream": ["InputStream", "outputSteam", "inputTime", " inputThread", "inputstream", "InputSteam", "outputStreamer", "imageLoop", " inputStreamer", "Inputstream", " inputLoop", "imageTime", "helloSteam", " inputSteam", "InputLoop", "helloStreamer", "InputTime", "outputstream", " inputTime", "helloChannel", " inputChannel", "inputSteam", "inputThread", "outputThread", "InputThread", "inputLoop", "imageSteam", " inputstream", "outputChannel", "inputStreamer", "helloStream", "imageStream", "inputChannel"], "outputStream": ["sequenceStream", " outputStreamer", "outputSteam", "webView", "sequenceSteam", "outputStreamer", "inputView", "writeSteam", " outputStyle", "outputForm", "writeView", "OutputView", "webStream", "OutputSteam", "inputSteam", "outputView", "OutputStyle", "sequenceStreamer", "inputForm", "OutputStreamer", "webSteam", "webStreamer", "writeStream", "writeForm", "OutputStream", " outputSteam", "sequenceStyle", "OutputForm", " outputView", "outputStyle"], "typeMime": ["typeRime", "typeSmime", "TypemIME", "TypeMim", "typeSmme", "typeRme", "typeRIME", "typemIME", "TypeMime", "TypeMme", "typeRim", "typeSmim", "Typemime", "typeMim", "TypeMIME", "typeMIME", "typeSmIME", "typemime", "typemim", "Typemim", "Typemme", "typeMme", "typemme"], "tailleFichier": [" tailleFuzzie", " tailleficheiers", " tailleFixiers", " tailleFixie", " tailleFuzzies", " tailleficheies", " taillefichie", " tailleFuzziers", " tailleFixies", " tailleFuzzier", " tailleFicheier", " tailleFichiers", " tailleficheier", " taillefichier", " tailleFichies", " tailleficheie", " tailleFicheies", " taillefichies", " tailleFichie", " tailleFixier", " taillefichiers", " tailleFicheie", " tailleFicheiers"]}}
{"id1": "3252116", "id2": "19739421", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["Getmd10", "getMD1", "Getmd4", "getMD4", "getmd10", "Getmd5", "getmd4", "getHash5", "GetMD5", "getMD10", "GetMD10", "getmd1", "getHash10", "GetMD1", "getmd5", "GetMD4", "Getmd1", "getMC4", "getMC1", "getMC5", "getMC10", "getHash4", "getHash1"], "source": ["output", "buffer", "ser", "style", "message", "text", "site", "template", "SOURCE", "b", "seed", "f", "secret", "ource", "sample", "from", "subject", "Source", "content", "e", "code", "this", "src", "null", "name", "dest", "sequence", "base", "string", "input", "copy", "object", "file", "target", "data", "origin", "start", "image", "c"], "s": ["ls", "es", "abs", "a", "gets", " sets", "b", "gs", " ss", "bs", " gets", "ss", "ds", "p", " rs", "ws", "its", "ses", "hs", "os", "xs", "cs", "ins", "t", "ps", "rs", " fs", "js", "ads", "ns", " outputs", "sts", "ats", "bes", "fs", "parts", "ings", " ls", " ans", "ends", "sb", "uns", " ts", " samples", "eps", "ts", " returns", " streams", "S", "ies", " es"], "hexDigits": ["hexPosits", "hexFunbits", "exdigitions", "exDigits", " hexDigit", "hexPosities", "hexdigitions", "exDigitions", "hexPosals", "hexFunits", "exDigities", "hexDigists", "hexDities", "hexPositions", "hexDits", "hexDigals", "hexDigbits", "hexdigbits", "exDigals", "exdigals", "exdigits", "hexDists", " hexDigitions", "hexdigits", "hexFunals", " hexDigists", "hexdigals", " hexDigbits", "hexDigities", "hexDigitions", "exdigities", "hexDigit", "hexdigists", " hexDigities", "hexdigit", " hexDigals", "hexFunit", "hexDitions", "hexdigities"], "md": ["dr", "ms", "nd", "add", "cond", "pdf", "sd", "mc", "bd", "od", "ad", "MD", "grad", "der", "cd", "desc", "mm", "dm", "rm", "mt", "ind", "red", "sm", "dh", "nt", "det", "ld", "mb", "d", "dd", " Md", "td", "mk", "amd", "dig", "mod", "pd", "m", "df", "di", "mn", "cmd", "hd", "de"], "tmp": ["fake", "proc", "db", "html", "emp", "nb", "qq", "img", "pkg", "tt", "zip", "bis", "params", "xy", "bag", "local", "np", "test", "xs", "sym", "up", "buff", "etc", "cmp", "js", "comp", "mb", "cb", "sup", "bytes", "yy", "perm", "mp", "obj", "txt", "Temp", "dirty", "ctx", "table", "sp", "temp", "cur"], "str": ["ch", "gr", "out", "dr", "text", "st", "vol", "sl", "n", "buf", "it", "stri", "b", "sc", "p", "cat", "sw", "cs", "t", "fr", "ar", "arr", "v", "cr", "e", "cast", "hex", "STR", "name", "ctr", "w", "char", "tr", "obj", "txt", "print", "string", "set", "m", "iter", "arc", "br", "sp", "data", "div", "r", "Str", "c", "list"], "k": ["x", "j", "kk", "n", "km", "b", "ck", "f", "q", "tk", "id", "p", "ikk", "kt", "kj", "h", "ke", "ok", "t", "kid", "ak", "ku", "v", "kw", "g", "key", "kh", "ks", "ka", "ik", "d", "w", "l", "mk", "kl", "kar", "kn", "set", "m", "z", "ko", "unk", "sk", "K", "c", "kan"], "i": ["multi", "im", "zi", "x", "j", "n", "phi", "it", "ai", "ini", "is", "ic", "ri", "ui", "me", "iu", "p", "o", "io", "mi", "ci", "conv", "ii", "qi", "v", "gi", "e", " j", "hi", "ti", "ji", "bi", "index", "si", "inter", "I", "u", "print", "m", "status", "xi", "cli", "di", "sim", "pi", "info", "chain", "ij", "in", "ip", "li", "\u0438", "ix"], "byte0": ["node8", "hex6", "Byte140", " byte140", "pixelElement", " byte8", "byte1", "Byte8", "Byte1", "pixel1", "byte6", "Byte3", "node1", " byte6", "channel140", " byte3", "byteElement", " byte2", "byte8", "hex1", "pixel6", "pixel0", "byte140", "Byte0", "node0", "byte3", "hex0", "channel0", "channel3", "Byte2", " byteElement", "channel1", " byte1", "node2", "byte2", "hexElement"]}}
{"id1": "1698200", "id2": "19810820", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": [" loginbitshare", "loginByteshare", " loginBitshare", " loginbitShare", "loginbitshare", "loginBitStock", "loginByteShare", " loginbitStock", "loginByteStock", "loginBitshare", " loginBitStock", "loginbitStock", "loginbitShare"], "params": ["http", "json", "properties", "config", "pps", "headers", "posts", "types", "ports", "metadata", "gs", "ams", "comments", "stats", "p", "parser", "pretty", "mm", "cms", "auth", "pas", "pins", "tags", "param", "rs", "ps", "photos", "changes", "settings", "Par", "terms", "cp", "chains", "points", "keys", "Parameters", "parts", "details", "acl", "hash", "pres", "requires", "pi", "names", "options", "caps", "members", "services"], "httpclient": [" httpconnection", "ttpcontroller", "httpconnection", "httpcontroller", "Httpclient", "ttpco", "httpsClient", "httprequest", "httpsrequest", "httcontroller", "hyperconnection", "httpco", "httco", "HttpClient", "hyper2", "hyperclient", " httprequest", "https2", "httpcli", "http2", "httpscontroller", "httpsconnection", "hypercli", "httClient", " http2", "ttpclient", "httpsco", "httpClient", " httpClient", "httclient", " httpcli", "Httpconnection", "Httprequest", "httpscli", "ttpClient", "httpsclient"], "httppost": ["httpploster", "httpplpost", "httpplop", "httmppost", "httpost", "httploster", "httpperop", "httphoint", "httpop", "httppom", "httppposter", "httppop", "httplost", "httplop", "httmpop", "httphoster", "httplom", "httppppost", "httpart", " httpom", "httpplart", " httppop", "httpperost", "httppart", "httpploint", " httppom", "httmpost", "httpplost", "httphost", "httpposter", "httpoint", "httploint", " httpppost", "httpppost", "httposter", "httpperpost", "httphpost", " httpop", "httplart", "httplpost", "httppoint", "httpom", "httpppop", "httmpart", "httpperom", " httpost", "httpppoint", "httpppart"], "formparams": ["feeddetails", "formchanges", "formedparams", "formsettings", "functionchanges", "formedtags", "inputerrors", "formargs", "formerrors", "formParameters", "formmembers", "feedParameters", "foreproperties", "feedparams", " formmembers", "batchnames", "formtags", "formauthors", "forechanges", "formnames", " formproperties", "inputparam", "formederrors", "inputparams", " formchanges", "functionargs", "inputnames", "inputdetails", "formparam", "feedparam", " formnames", "batcherrors", "foreparams", "batchtags", "inputtags", "functionproperties", "foredetails", "functionmembers", "condsettings", " formargs", "condparams", "functiondetails", "formednames", "forenames", "condnames", "foreauthors", " formParameters", " formdetails", "foresettings", "batchparams", "condproperties", "functionparams", " formparam", "formdetails", "functionauthors", " formsettings", "foremembers", "foreargs", " formauthors", "inputParameters", "formproperties"], "entity": ["orm", "buffer", "json", "html", "fee", "ew", "ity", "template", "ent", "user", "metadata", "em", "person", "body", "eme", "inv", "enc", "ce", "create", "note", "security", "el", "ee", "ITY", "content", "component", "xml", "Entity", "quote", "event", "form", "line", "activity", "entry", "object", "ENT", "ell", "profile", "comment", "document", "data", "empty", "out"], "httpresponse": [" httpconnection", "procreply", "httpresp", "httpResponse", "httpconnection", "HTTPreply", "HTTPconnection", " httpreply", "HTTPresponse", "ttpResponse", "ttpresponse", " httpresult", "procresponse", "httpreply", "HTTPResponse", " httpResponse", " httpresp", "httpresult", "HTTPresult", "ttpconnection", "procresult", "HTTPresp", "ttpresp", "procResponse"], "it": ["ist", "lit", "mit", "ite", "im", "est", "st", "init", "ent", "is", "ic", "itted", "IT", "ip", "rit", "ul", "et", "its", "ind", "ed", "iz", "al", "t", "ex", "It", "el", "v", "at", "ate", "ert", "he", "l", "you", "sit", "MIT", "ect", "itter", "iter", "i", "ot", "act", "ut", "li", "il"], "escookie": ["escue", "eccake", "ecoder", "occookie", "ecotton", "isecookie", "descookie", "iseccake", "descue", "escace", "escancel", "ecace", "eyookie", "espcookie", "occcake", "eyace", "escotton", "escoder", "eyancel", "espace", "desccookie", "httpsotton", "eccookie", "ecookie", "ecue", "Esctrl", "occog", "esccookie", "espookie", "Escookie", "httpsookie", "ecog", "isecoder", "httpscookie", "desctrl", "occcookie", "Escue", "esccake", "escog", "esctrl", "occotton", "occoder", "Esccookie", "iseccookie", "httpsog", "espancel", "eycookie", "ectrl", "ecancel"]}}
{"id1": "14038176", "id2": "7927042", "code1": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["fectString", "FetchPage", "fetchPage", "fetchURL", "FetchString", "fectUrl", "fgetURL", "fgetUrl", "fectPage", "fectURL", "FetchURL", "FetchUrl", "fetchString", "fgetPage", "fgetString"], "urlString": ["UrlString", "urlRest", "domainStr", "pathStr", "uriRest", "lStr", "httpStr", "uriString", "pathString", "lSeries", "UrlRest", "domainSeries", "urlStr", "urlstring", "lString", "lSingle", "domainString", "pathSingle", "urlSeries", "pathSeries", "httpString", "uriStr", "httpstring", "Urlstring", "urlSingle", "UrlStr", "domainSingle", "httpRest", "uristring"], "url": ["http", "mail", "sl", "open", "build", "bel", "link", "ur", "lb", "ul", "Url", "address", "loader", "URL", "rel", "github", "ssl", "uri", "dl", "nl", "loc", "client", "email", "google", "name", "mount", "impl", "ll", "str", "l", "char", "base", "lr", "acl", "rl", "file", "web", "cert", "r", "hl"], "reader": ["runner", "buffer", "http", "owner", "ator", "rar", "address", "loader", "parser", "read", "row", "iterator", "test", "older", "er", "uri", "length", "operator", "inner", "writer", "impl", "readable", "reading", "handler", "stream", "rot", "upper", "Reader", "ner", "entry", "input", "iter", "rl", "layer", "file", "driver", "ro", "range", "data", "r"], "line": ["message", "text", "mail", "cell", "model", "lin", "block", "phrase", "ln", "user", "header", "eline", "detail", "link", "lane", "body", "entity", "row", "sample", "frame", "nl", "lines", "channel", "liner", "email", "le", "e", "inline", "ine", "rule", "LINE", "number", "char", "online", "page", "quote", "sequence", "l", "entry", "string", "source", "point", "print", "iter", "file", "stroke", "log", "comment", "range", "column", "word", "Line", "len"], "builder": ["buffer", "runner", "message", "db", "adder", "black", "block", "bean", "worker", "build", "bar", "b", "built", "loader", "der", "parser", "row", "Builder", "BU", "creator", "older", "control", "browser", "length", "operator", "builders", "inner", "writer", "oster", "building", "board", "atter", "upper", "base", "layer", "language", "sb", "web", "aker", "php", "outer", "ener", "uild", "order"]}}
{"id1": "9647576", "id2": "23677147", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 1, "substitutes": {"Reserve": ["reserve", "Conserved", "Servation", "resolve", "Served", "Resolve", "Solve", "Conservation", "Conserve", "Reserved", "reserved", "Reservation", "reservation", "Serve", "Consolve"], "stbookings": ["Stbooksers", "stbookers", "Stbookings", "stbooksies", "stbinding", "Stbooksing", "Stbooksings", "stbooksing", "stBooking", "Stbookies", "stBookings", "Stbooking", "stbinders", "stbooksings", "Stbooksies", "stbindings", "stBookers", "stbooksers", "stbooking", "stbindies", "stBookies", "stbookies", "Stbookers"], "stchartwl": ["stplotbook", "STChartbook", "stChartwl", "stplotwl", "STchartbook", "stchartbook", "STChartwl", "STchartwl", "stchartwal", "STchartml", "stChartwal", "stChartml", "stpagewal", "STChartml", "STChartwal", "STchartwal", "stplotml", "stpageml", "stpagewl", "stpagebook", "stChartbook", "stplotwal", "stchartml"], "sp": ["spr", "sy", "st", "vol", " SP", "space", "se", "so", "tp", "lp", "sc", "p", "bsp", "ss", "sw", "SP", "pt", "sm", "esp", "scope", "ps", " esp", "ap", "pb", "sh", "cp", "si", "service", "policy", "asp", "pe", "isp", "osp", "yp", "Sp", "sb", "spe", "sv", "jp", "sk", "sil", "sf", "pp", "pol"], "userbooksql": ["clientreadsqs", "userbindsql", "userbindql", "userBookssql", "userbooksSQL", "userooksql", "userscriptsql", "userbooksquer", "userscriptselly", " userbindsql", "usertypesQL", " userbindquer", "userbooksels", "userreadsels", "usertypesqs", "userbysquer", "userpagessql", "clientbooksqs", "userooksqs", "userpagesQL", "userpagesql", "userreadsql", "agentpagesQL", "userbookselly", " userbookssql", "userbookssql", "userreadselly", "clientbooksels", "usertypesql", "userookselly", "userbindSQL", "userbysql", "clientbooksql", "agentpagesql", "agentbookssql", " userbooksSQL", "agentbooksqs", "userscriptsels", " userbooksquer", " userbindql", "userbooksQL", "userBooksql", "clientreadsql", "userBooksSQL", "userbookqs", "userBooksquer", "userbookql", "clientbookselly", "agentbooksQL", "userreadsqs", "clientreadsels", "userooksels", "userpagesqs", "userbyssql", "clientreadselly", "userbooksqs", "agentpagessql", "userbysSQL", "userbookQL", "userbindquer", "userscriptsqs", " userbindSQL", "usertypessql", "agentpagesqs"], "agentbooksql": ["agentiquesQL", "agentbeansili", "agentBookssql", " agentbooksQL", "ownerbeansQL", "ownerbeansql", "agentbooksqu", "agentBooksquer", "ownerbooksql", "agentbeansql", "agentbooksquer", "agentletsqu", " agentBookssql", "agentiquessql", " agentBooksqu", "agentletsql", " agentBooksquer", "ownerbooksili", "agentBooksQL", "agentbooksili", "agentpagesQL", "agentiquesquer", "ownerbooksquer", " agentbookQL", "agentiquesqu", " agentbooksquer", "agentpagesili", "agentbeansQL", "agentpagesql", "agentbookssql", "ownerbeansquer", "agentbookQL", " agentbooksqu", " agentbookili", "agentiquesql", "agentbooksQL", "agentletsquer", " agentBooksql", "agentletssql", "agentbookili", "agentpagessql", " agentbookql", "ownerbeansili", "agentBooksili", " agentbooksili", " agentbookssql", "agentbookql", "agentbeansquer", "agentiquesili", "ownerbooksQL", "agentbookquer", "agentBooksql", "agentBooksqu"], "bookingid": ["bookingingID", "bookillingids", "bookingID", "BookingsID", "bookingsID", "Bookingid", "BookingID", "bookingingid", "bookillingid", "Bookingids", "bookingingids", "bookillingID", "bookingsids", "Bookingsids", "bookingids", "bookingsid", "Bookingsid"], "currentcoach": ["currentlyCoach", "currentCoach", " currentfoch", "currentlyCoachable", "currentfoACH", "currentcalch", "currentcalachable", "currentfoech", "currentconasp", "currentcoachable", "currentlycoat", "currentconac", "currentlycoech", "currentlyCoch", "currentcoeACH", "currentCoACH", "currentcac", "currentlycoac", "currentcach", "currentCOach", "currentcalach", "currentlycoachable", "currentCoarch", "currentcalech", " currentcoACH", "currentlycoasp", "currentconach", "currentlycac", "currentcoech", "currentcoasp", "currentCoch", "currentCOac", "currentfoach", "currentlycach", "currentconat", "currentlycoch", "currentlycat", "currentlycasp", "currentcat", " currentfoach", "currentcoarch", "currentcoch", " currentcoarch", "currentfoarch", "currentcasp", "currentcoac", "currentlyCoech", "currentCOat", " currentfoACH", "currentcoeach", "currentCOasp", "currentCoech", "currentcoACH", "currentCoachable", "currentcoat", " currentcoch", "currentlycoach", "currentcoearch", "currentfoachable", " currentfoarch", "currentfoch"], "currentseat": [" currentslot", "reportedsel", " currentport", "currentslot", "Currentseat", "currentlysen", "currentsel", "curseat", " currentsel", "currentroute", "reportedport", "curroute", "reportedroute", "currentlyslot", "currentport", "currentlysel", " currentsen", "currentsen", "reportedseat", "currentlyseat", "cursel", "Currentsen", "Currentsel", "Currentslot", " currentroute", "curport"], "tickpos": [" tickno", "poppo", "checkPos", "testpo", "stickno", "snappos", "quotePos", "poppos", "rickpo", "stickpo", "quoteno", "testpos", "tickpo", "quotepos", "tickprop", "popposition", "stickpos", "ickpos", "stickPos", "checkpo", "ickpo", "snapPos", "rickprop", " tickpo", " tickPos", "rickpos", "rickPos", "stickposition", "testPos", " tickposition", "snapposition", "checkposition", "tickPos", "checkpos", "tickposition", "stickprop", "snappo", "testposition", "popPos", "ickPos", "tickno", "ickposition", "quoteposition", " tickprop"], "chartavailupdsql": ["chartavailupsdsq", "chartavailupdQL", "chartavailupysQL", "chartavailupdsq", "chartavailupsdssql", "chartavailupsdsQL", "chartavailupdatesQL", "chartavailupysq", "chartavailupdssql", "chartavailupsdatesql", "chartavailupysql", "chartavailupdsQL", "chartavailupsdsql", "chartavailupdql", "chartavailupsdatesq", "chartavailupdatesq", "chartavailupdq", "chartavailupsdatessql", "chartavailupdatesql", "chartavailupdatessql", "chartavailupyssql", "chartavailupsdatesQL"]}}
{"id1": "13362846", "id2": "11645260", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setContenu": ["setCont\u00ednU", "setcontensenux", "setContensenu", "setCont\u00ednue", "setContenux", "setContensenux", "setCont\u00ednux", "setContennU", "setContensenue", "setcontenu", "setContenue", "setContenU", "setcontenU", "setcontensenU", "setContennu", "setContensenU", "setcontenue", "setcontensenu", "setcontenux", "setCont\u00ednu", "setContennux", "setContennue", "setcontensenue"], "contenuFichier": ["contenuVechier", "contenuFicheaire", "contenuFiveraire", "contenuFamilyachier", "contenuVichyr", "contenuVchIER", "contenuFichie", "contenuVchie", "contenuMicheiere", "contenuFsrenchaire", "contenuFicheiere", "contenuFihiere", "contenuFrenchier", "contenuFsrenchieri", "contenuFechier", "contenuFileochiere", "contenuFsrenchire", "contenuVchier", "contenuFuffer", "contenuFchiere", "contenuFamilyichie", "contenuFignaire", "contenuFecher", "contenuFihier", "contenuFsechier", "contenuFichtIER", "contenuFileochiers", "contenuFsicher", "contenuFithyr", "contenuFolfire", "contenuFsrenchier", "contenuFChier", "contenuFamilyachie", "contenuVichIER", "contenuFsichieri", "contenuMicheaire", "contenuFechiest", "contenuFileichiere", "contenuFihiest", "contenuFechieri", "contenuFrenchieri", "contenuVichier", "contenuFithier", "contenuFolfier", "contenuMichiere", "contenuFithiest", "contenuFamilyachiere", "contenuVechiere", "contenuMicheier", "contenuFChaire", "contenuFachiers", "contenuFochier", "contenuFsichaire", "contenuFachorie", "contenuFachier", "contenuFiverieri", "contenuFileochie", "contenuFolfer", "contenuVechyr", "contenuFichIER", "contenuFsecher", "contenuVchiere", "contenuFicher", "contenuFigniere", "contenuFichieri", "contenuFechiere", "contenuFechire", "contenuFolfieri", "contenuMichaire", "contenuMicheer", "contenuFochie", "contenuFichire", "contenuFamilyichorie", "contenuFichiest", "contenuFachie", "contenuFicheorie", "contenuFsechire", "contenuFchier", "contenuFochiere", "contenuFamilyichiere", "contenuFileochier", "contenuFachiere", "contenuFiverire", "contenuFchIER", "contenuFamilyachorie", "contenuFignier", "contenuFochiers", "contenuFichaire", "contenuFsichire", "contenuFichtie", "contenuFsechieri", "contenuFichiers", "contenuFicheieri", "contenuFechyr", "contenuFiverier", "contenuFCher", "contenuFichorie", "contenuFChiere", "contenuFichtiere", "contenuFithie", "contenuFileichiers", "contenuFamilyichier", "contenuFicheiers", "contenuFrenchaire", "contenuFicheer", "contenuFithorie", "contenuVichie", "contenuFchie", "contenuFrenchire", "contenuFithiere", "contenuFuffieri", "contenuFihyr", "contenuFileichier", "contenuFuffire", "contenuMichier", "contenuFichtier", "contenuFicheier", "contenuFichyr", "contenuFichiere", "contenuVechiest", "contenuFuffier", "contenuMicher", "contenuFigner", "contenuVichiest", "contenuVichiere", "contenuFicheie", "contenuFochIER", "contenuFileichie", "contenuFicheire", "contenuFsichier"], "fichierElectronique": ["fichierelectronier", "fichierCentronique", "fichierElectRONique", "fichierAdministroniques", "fichierElectroneic", "fichierelectroniques", "fichierElectrenicy", "fichierelectrenique", "fichierCentRONius", "fichierSelectroneiques", "fichierElectrontique", "fichierelectronic", "fichierElectonique", "fichierElectRONaire", "fichierCentronicy", "fichierElectoniques", "fichierElectromius", "fichierElectonier", "fichierAdministroneiq", "fichierElectromie", "fichierElectchronicy", "fichierCentRONique", "fichierElectrontipolar", "fichierTransferronic", "fichierAdministronique", "fichierElectronsie", "fichierElectrenique", "fichierTransferradorie", "fichierElectromicity", "fichierElectronicity", "fichierAdministroniq", "fichierElectronie", "fichierElectrontaire", "fichierSelectroniques", "fichierElectroneiq", "fichierTransferronius", "fichierAdministroneique", "fichierTransferradorique", "fichierCentronius", "fichierCentRONaire", "fichierElectronsiques", "fichierElectreniques", "fichierElectroneius", "fichierElectronsiq", "fichierElectrenaire", "fichierElectradorius", "fichierElectronsicity", "fichierElectronius", "fichierElectromaire", "fichierElectromipolar", "fichierElectRONius", "fichierSelectronicity", "fichierSelectronique", "fichierSelectroneique", "fichierElectronoch", "fichierElectroneie", "fichierTransferradorius", "fichierElectchronaire", "fichierElectricie", "fichierElectRONicy", "fichierElectchronique", "fichierElectronipolar", "fichierElectroneoch", "fichierelectreniques", "fichierElectronier", "fichierAdministroneie", "fichierelectrenier", "fichierelectronique", "fichierTransferronique", "fichierElectrenius", "fichierAdministroneiques", "fichierElectronic", "fichierElectroniq", "fichierElectronsoch", "fichierElectchroniques", "fichierElectroneaire", "fichierElectricique", "fichierElectromic", "fichierElectchronicity", "fichierTransferronie", "fichierElectradorie", "fichierElectradorique", "fichierElectrenic", "fichierelectrenic", "fichierTransferradoric", "fichierElectrenier", "fichierElectroneicity", "fichierCentronaire", "fichierElectroneipolar", "fichierCentRONicy", "fichierSelectroneicity", "fichierElectriciq", "fichierElectromique", "fichierElectronaire", "fichierElectronsier", "fichierElectroniques", "fichierElectroneique", "fichierElectradoric", "fichierElectronsic", "fichierElectronicy", "fichierElectriciques", "fichierElectronticity", "fichierElectroneiques", "fichierElectchronoch", "fichierElectronsique", "fichierElectchronius", "fichierAdministronie", "fichierSelectronoch", "fichierElectonic", "fichierSelectroneoch"], "utilisateurCourant": ["utilisateurParticipant", "utilisateurGovernants", "utilisateurRepresentant", "utilisateursCourant", "utilisateursCouriant", "utilisateursGovernante", "utilisateurRepresentiant", "utilisateurGoverniant", "utilisateurGovernant", "utilisateurParticipants", "utilisateurGovernante", "utilisateursGoverniant", "utilisateurRepresentante", "utilisateurCourants", "utilisateursGovernant", "utilisateurParticipiant", "utilisateursGovernants", "utilisateursCourante", "utilisateursCourants", "utilisateurRepresentants", "utilisateurCourante", "utilisateurParticipante", "utilisateurCouriant"], "support": ["collection", "history", "replace", "access", "cover", "force", "supported", "see", " Support", "accept", "install", "help", "control", "use", "feature", "allow", "pport", "library", "trust", "null", "share", "know", "service", "SUP", "please", "language", "cap", "port", "profile", "system", "document", "evidence", "media", "format", "success", "context", "proof", "storage", "prototype", "supp", "Support"], "ficheDocument": [" ficheDatabase", "bacheDocument", "ficiDocument", "fitimeDocument", "fitimeDatabase", "bacheDatabase", "ficiMatrix", "fiqueDescription", "FicheDatabase", "facheJournal", "ficiTransaction", "frenchDatabase", "foyerDoc", "FicheDocument", "fayeDocuments", "fcheDocument", "hacheJournal", "FayeDoc", "fcheTree", "frenchDoc", "fliciDatabase", "ficiJournal", "bicheDocument", "fachedocument", "facheTransaction", "fifaDatabase", "bicheDoc", "fruitDocument", "facheTree", "frenchDescription", "bacheDoc", "fliciMatrix", "foyerDocument", " frenchDescription", "frenchTransaction", "fcheDoc", "hacheDocument", "fifaDocument", "flicheTransaction", "foyerDatabase", "hicheJournal", "ficidocument", "fayeDoc", "FicheDoc", "flicheDocument", "fliciDocument", "fitimeTransaction", "fiqueDatabase", "frenchDocument", "flicheDatabase", "fruitTransaction", "hichedocument", " frenchDocument", "fayeDatabase", "ficheMatrix", "fichedocument", "frenchMatrix", "hicheDocument", " frenchDatabase", "fruitdocument", "ficheJournal", "fliciTransaction", "foyerTree", "flicheMatrix", "bicheDatabase", "hachedocument", "fifaDoc", "facheDocument", "FayeDocument", "ficheDocuments", "fiqueDocument", "facheDatabase", "ficheDatabase", "ficheDoc", "ficheTransaction", "bacheTree", "hicheTransaction", "ficheDescription", "ficiDatabase", "bicheTree", "fruitJournal", "FicheDocuments", "fitimeMatrix", " ficheDescription", "fitimeDescription", "ficheTree", "hacheTransaction", "facheDoc", "frenchDocuments", "fcheDatabase", "fifaDocuments", "FayeDocuments", "FayeDatabase", "fayeDocument"], "nomFichier": ["nomFichomer", "nomFericier", "nomFcher", "nomFicier", "nomFicher", "nomPFoililler", "nomFchier", "nomFichIER", "nomFichoancer", "nomFachier", "nomFicomer", "nomFichie", "nomPFichiller", "nomUFichire", "nomFericIER", "nomFacherer", "nomNolfiere", "nomPichier", "nomFericanger", "nomFichiere", "nomFicire", "nomUFichIER", "nomFacher", "nomPFoilier", "nomNichie", "nomFoiljer", "nomFachery", "nomPachier", "nomFilicjer", "nomFicheire", "nomFiverire", "nomFiverIER", "nomFoilier", "nomFiverier", "nomFiverery", "nomFoilER", "nomFicER", "nomFchiner", "nomPFoiljer", "nomFachIER", "nomFichoIER", "nomNolfie", "nomFolfier", "nomFicheier", "nomFchomer", "nomFichire", "nomFachomer", "nomUFachier", "nomFihIER", "nomFericancer", "nomPachomer", "nomFiliciller", "nomUFachIER", "nomFolfiere", "nomPicherer", "nomNichire", "nomUFichier", "nomFachiere", "nomFicheer", "nomFichancer", "nomFilicER", "nomFchire", "nomFilicier", "nomFolfie", "nomFihery", "nomUFachery", "nomPichomer", "nomFachire", "nomFicerer", "nomNichiere", "nomFichoanger", "nomFicheiner", "nomFicjer", "nomPichire", "nomFachanger", "nomFichery", "nomFicheiere", "nomPFichER", "nomFchiere", "nomFcherer", "nomPFoilER", "nomFichanger", "nomFiciller", "nomFachie", "nomFolfire", "nomFichjer", "nomUFachire", "nomFichiller", "nomNolfier", "nomFachancer", "nomNolfire", "nomFoililler", "nomPacherer", "nomPFichier", "nomFicheie", "nomPFichjer", "nomFihire", "nomFichER", "nomFichiner", "nomPachire", "nomUFichery", "nomFicherer", "nomFichoier", "nomNichier", "nomFihier", "nomFachiner"], "extension": ["protension", "Extension", "expractor", "strension", "protention", "Extending", "xtensions", "Extensions", "contension", "expension", "protitude", "contention", "xtension", "extending", "expitude", "strensions", "extractor", "strending", "extitude", "protractor", "expention", "extention", "xtending", "extensions", "contitude", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueLocalistent", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusistant", "fichierElectronicityInert", "fichierElectroniqueEXistance", "fichierElectroniquePersistant", "fichierElectronogramLocalistent", "fichierElectroniqueAssclusive", "fichierElectroniquePresentiker", "fichierElectroniquePlusiker", "fichierElectroniqueLocalistant", "fichierElectronogramExistance", "fichierElectronogramLocalistant", "fichierElectroniqueAssistent", "fichierElectroniqueEXert", "fichierElectronicityExert", "fichierElectronogramExistent", "fichierElectroniqueExvant", "fichierElectroniqueExistent", "fichierElectronogramLocalclusive", "fichierElectroniqueInistent", "fichierElectronicityInistant", "fichierElectroniqueEXvant", "fichierElectroniqueInclusive", "fichierElectroniqueInistance", "fichierElectronogueExistant", "fichierElectroniqueLocalistance", "fichierElectronoguePersistent", "fichierElectronogramExclusive", "fichierElectronogramLocalistance", "fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityExistant", "fichierElectroniqueEXistant", "fichierElectroniqueExplvant", "fichierElectroniqueAssistance", "fichierElectroniqueExister", "fichierElectronicityInvant", "fichierElectroniqueExplistant", "fichierElectroniqueInistant", "fichierElectronogueExiker", "fichierElectroniqueExert", "fichierElectronogueExister", "fichierElectronogueExistent", "fichierElectronoguePersiker", "fichierElectroniqueInvant", "fichierElectroniquePersiker", "fichierElectroniqueExistance", "fichierElectronoguePersister", "fichierElectroniqueExplert", "fichierElectroniqueExclusive", "fichierElectroniquePresentistant", "fichierElectronicityExvant", "fichierElectroniqueInert", "fichierElectroniqueLocalclusive", "fichierElectroniqueAssistant", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectroniquePlusistent", "fichierElectroniquePresentister", "fichierElectroniqueExplistance", "fichierElectronicityInistance", "fichierElectroniquePresentistent"], "idIgid": ["idIgcid", "idImgids", "idIgaddress", "idIgcido", "idIIgid", "idIgcoid", "idIigmaddress", "idIIgoid", "idIgzida", "idIegids", "idIgida", "idIgzido", "idAmgaddress", "idAgid", "idAmgis", "idIgoid", "idIgdido", "idIgcida", "idIgido", "idIIgzid", "idImgaddress", "idIgdata", "idIegdata", "idIkglimit", "idIIgzoid", "idIIgzido", "idIkgis", "idAglimit", "idIegid", "idIigmlimit", "idAmglimit", "idIgids", "idIgzid", "idIigmid", "idIgis", "idIIgido", "idIgdid", "idIkgaddress", "idIgdoid", "idAmgid", "idAgaddress", "idIigmis", "idIgzoid", "idIgkey", "idIkgid", "idImglimit", "idIvgkey", "idImgkey", "idImgid", "idIegkey", "idIIgzida", "idIgdida", "idIvgid", "idIvgdata", "idAgis", "idIglimit", "idIvgids", "idImgdata", "idImgis", "idIIgida"], "inputStream": ["InputStream", "outputSteam", "inputTime", " inputThread", "inputstream", "InputSteam", "outputStreamer", "imageLoop", " inputStreamer", "Inputstream", " inputLoop", "imageTime", "helloSteam", " inputSteam", "InputLoop", "helloStreamer", "InputTime", "outputstream", " inputTime", "helloChannel", " inputChannel", "inputSteam", "inputThread", "outputThread", "InputThread", "inputLoop", "imageSteam", " inputstream", "outputChannel", "inputStreamer", "helloStream", "imageStream", "inputChannel"], "outputStream": ["sequenceStream", " outputStreamer", "outputSteam", "webView", "sequenceSteam", "outputStreamer", "inputView", "writeSteam", " outputStyle", "outputForm", "writeView", "OutputView", "webStream", "OutputSteam", "inputSteam", "outputView", "OutputStyle", "sequenceStreamer", "inputForm", "OutputStreamer", "webSteam", "webStreamer", "writeStream", "writeForm", "OutputStream", " outputSteam", "sequenceStyle", "OutputForm", " outputView", "outputStyle"], "typeMime": ["typeRime", "typeSmime", "TypemIME", "TypeMim", "typeSmme", "typeRme", "typeRIME", "typemIME", "TypeMime", "TypeMme", "typeRim", "typeSmim", "Typemime", "typeMim", "TypeMIME", "typeMIME", "typeSmIME", "typemime", "typemim", "Typemim", "Typemme", "typeMme", "typemme"], "tailleFichier": [" tailleFuzzie", " tailleficheiers", " tailleFixiers", " tailleFixie", " tailleFuzzies", " tailleficheies", " taillefichie", " tailleFuzziers", " tailleFixies", " tailleFuzzier", " tailleFicheier", " tailleFichiers", " tailleficheier", " taillefichier", " tailleFichies", " tailleficheie", " tailleFicheies", " taillefichies", " tailleFichie", " tailleFixier", " taillefichiers", " tailleFicheie", " tailleFicheiers"]}}
{"id1": "7891509", "id2": "19109981", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"pageAddress": ["pageaddress", "Pageaddress", "resourceName", " pageUrl", "pageName", " pageAdd", "resourceAdd", "pageAdd", "resourceaddress", " pageaddress", "PageAdd", " pageName", "serveraddress", "serverUrl", "serverAddress", "PageAddress", "PageUrl", "pageUrl", "serverName", "resourceAddress", "PageName"], "url": ["http", "mail", "ls", "window", "sl", "ret", "build", "bel", "link", "ur", "ul", "Url", "address", "URL", "p", "rel", "api", "pl", "ssl", "dl", "uri", "nl", "client", "resource", "browser", "gl", "key", "google", "str", "mount", "ll", "l", "char", "www", "base", "acl", "file", "sb", "web", "https", "cert", "r", "github"], "in": ["out", "IN", "on", "din", "gin", "by", "init", "n", "it", "oin", "rin", "is", "ic", "vin", "mc", "b", "and", "ill", "read", "en", "inc", "io", "from", "nin", "re", "ind", "al", "ins", "ma", "bin", "all", "inner", "reader", "one", "isin", "sum", "l", "In", "conf", "check", "input", "copy", "again", "i", "mn", " din", "inn", "r", "inside", "inf", "cin"], "inputLine": ["inputBlock", "focusRow", " inputBlock", "inputRow", "focusLine", "InputBlock", "submitLINE", "outputBlock", " inputLINE", " inputEntry", "outputLINE", "enumNet", "outputline", "focusL", "responseBlock", " inputNet", "responseline", " inputline", "enumL", "focusNet", "submitEntry", "inputline", "responseLine", "enumLine", " inputRow", "enumRow", "InputLine", "InputEntry", "InputLINE", "inputL", "responseLINE", " inputL", "submitBlock", "inputNet", "inputEntry", "outputLine", "inputLINE", "submitLine"]}}
{"id1": "12128591", "id2": "21308543", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 0, "substitutes": {"hash": [" mac", " check", "update", " sum", "Hash", " version", " text", " address", " equals", " signature", " key", "id", "h", " hashing", " fingerprint", "code", " code", "hex", " salt", "dump", " body", " message", "print", " h", " id", " Hash"], "data": ["output", "buffer", "message", "text", "json", "html", "password", "window", "block", "hello", "a", "ata", "secret", "raw", "dat", "rel", "accept", "DATA", "content", "this", "any", "bytes", "sequence", "result", "command", "batch", "string", "input", "action", "padding", "table", "value", "mu", "info", "what", "out", "image"], "digest": [" digist", "deest", "digly", "dese", "digist", "deist", "Digse", " digse", "Digester", "initEST", "mdests", " digave", " digested", "Digest", "digested", "displayest", " digit", "mdester", "displayested", "equse", "initested", "redly", " digEST", "digave", "mailly", "equest", "redgest", "redest", "displayse", "equave", "Digests", "DigEST", "digit", "displayests", "mdested", "redester", "digse", "diggest", "Digested", "mdly", "digEST", "digests", "Digist", "mailester", "mailest", "initester", "equit", "digester", "mdgest", "mdest", "mailgest", " digester", "initest", "mdit", "mdave", "mdse", "deested"]}}
{"id1": "10131427", "id2": "5049453", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", "Copyfile", " CopyImage", "CopyImage", "CopyStream", " cpfile", " cpStream", " copyStream", " copyImage", " CopyStream", " Copyfile", " cpImage", " CopyFile", " copyfile", " cpFile"], "in": ["IN", "on", "din", "gin", "st", "n", "it", "rin", "is", "ic", "vin", "b", "old", "o", "en", "inc", "from", "mm", "ind", "ins", "ar", "el", "up", "edIn", "isin", "l", "r", "In", "input", "source", "i", "s", "inn", "inf", "cin"], "out": ["output", "ch", "n", "Out", "it", "b", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "serv", "nt", "str", "w", "l", "net", "err", "OUT", "check", "gt", "ne", "file", "log", "po", "i", "oss", "ot", "s"], "sourceChannel": ["singleApplication", "seedChannel", "srcChannel", "sourceButton", "singleChuck", "inputConnection", "resourceConnection", "sourceApplication", "singleButton", "ourceChannel", "sourceChain", " sourcechannel", "srcStream", "matchChuck", "srcButton", "SourceStream", "ourceButton", "sourceChan", "srcchannel", "resourceChannel", "sourceChuck", "Sourcechannel", "ourceConnection", "inputChan", "seedButton", "SourceChannel", "inputChain", "sourceStream", "sourcechannel", "ourcechannel", "matchApplication", "resourcechannel", "ourceStream", "seedApplication", "matchChannel", "seedChuck", " sourceConnection", "ourceChan", " sourceStream", "ourceChain", "singleChannel", "SourceConnection", "resourceStream", " sourceChan", " sourceChain", "matchButton", " sourceButton", "sourceConnection", "inputChannel"], "destinationChannel": ["desticationCow", "destinatoryCow", "destinatedChannel", "destinationClient", "desticationChannel", "DestationChannel", "destinatoryBlock", "destensionClient", "destensionChan", "DestinationConnection", "destationConnection", "destinatedConnection", "DestationConnection", "destinationsChan", "DestationCow", "destinationsContext", "DestinationChannel", "DestinationBlock", "DestationChan", "destinatoryChan", "DestensionConnection", "destinationsChannel", "destinatedContext", "DestinationContext", "DestensionChan", "destensionConnection", "DestationContext", "DestinationChan", "destinationContext", "destroyChannel", "DestationBlock", "destinationCow", "destensionChannel", "destinationBlock", "DestinationCow", "destationChan", "destationBlock", "destroyClient", "destationChannel", "DestensionClient", "destinatoryChannel", "destationContext", "destinationChan", "destroyConnection", "destationCow", "desticationChan", "destinationsConnection", "DestensionChannel", "destinatedChan", "DestinationClient", "destinationConnection", "desticationBlock", "destroyChan", "destationClient"]}}
{"id1": "9096314", "id2": "4830847", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeLostService": ["handleServiceMissingServices", "handleServiceLostEvent", "handleNodeLostEvent", "handleNodeChangedServices", "handleNodeMissingEvent", "handleServiceMissingEvent", "handleServiceLostService", "handleServiceLostServices", "handleNodeMissingService", "handleNodelostEvent", "handleNodeLostServices", "handleNodelostService", "handleNodeChangedService", "handleNodeMissingServices", "handleNodeChangedEvent", "handleServiceMissingService", "handleNodelostServices"], "eventID": ["serviceDate", "eventDate", "ventData", "eventName", " eventJS", "nodeType", " eventName", "EventDate", "eventType", "serviceType", "nodeData", "EventName", "eventUID", "EventID", "eventId", " eventUID", "EventUID", "nodeUID", "ventJS", "ventType", "ventName", "eventJS", " eventId", "ventID", "serviceTime", " eventType", "EventId", "EventTime", "EventJS", " eventData", "EventType", "nodeId", "ventId", " eventDate", "eventData"], "nodeID": [" nodeIDs", "odeID", "odeId", "nodeType", "eventType", "componentid", " nodeName", " nodeId", " nodeType", "stationIP", "nodeName", "eventId", "stationID", "nodeIDs", "serviceIDs", "nodeIP", "stationType", "NodeIDs", "NodeID", "stationId", "processId", "NodeId", " nodeIP", "NodeName", "nodeId", "odeIP", "connectionId", "processID", "componentId", "serviceid", "connectionid", "processName", "componentID", "stationName", "connectionID", "nodeid", "serviceId"], "ipAddr": ["ipADn", "ipAddrs", "ipAddp", "ipAddri", " ipAttr", "ipAddressn", " ipAttrs", "ipaddrs", " ipAtter", " ipAttn", "ipaddri", "ipADrs", "ipADri", " ipAddressrs", "ipaddAddress", "ipAddresser", "ipStartp", "ipAtter", "ipAddn", "ipAttachr", " ipAddAddress", " ipAdder", "ipAddressru", " ipAddrs", "ipStartru", " ipAddn", "ipConnectp", " ipaddAddress", "ipaddp", "ipaddn", "ipAdder", "ipAttacher", " ipAddri", " ipaddrs", " ipAddressr", "ipAddressrs", "ipConnectrs", "ipADr", " ipAddp", "ipaddr", "ipaddru", " ipAddressru", " ipaddp", "ipAddressr", "ipStartr", " ipAddressp", "ipAttr", "ipAddAddress", " ipaddr", "ipAttachru", "ipAddressp", " ipAddru", "ipConnectAddress", "ipAttrs", "ipStartrs", "ipAttachrs", "ipConnectr", "ipadder", "ipAttn", "ipAddru"], "serviceID": [" serviceURL", "eventName", " serviceId", "ServiceId", "serviceName", "eventType", "serviceType", "ServiceType", "resourceURL", "interfaceID", "moduleID", "eventId", "ServiceNAME", " serviceNAME", "serviceURL", " serviceName", "resourceLAN", "ServiceID", "interfaceNAME", "servNAME", "moduleNAME", "interfaceLAN", "moduleName", "interfaceURL", "serviceLAN", " serviceLAN", "servId", "ServiceName", "resourceID", "resourceId", "servLAN", "servURL", "moduleType", "serviceNAME", "servID", "serviceId", " serviceType"], "eventTime": ["EventTS", "EventType", "ventID", " eventType", "EventTime", "EventID", "ventTime", "ventTS", "eventTS", " eventTS", "ventType", "eventType"], "log": ["db", "mail", "json", "ger", "or", "config", "it", "cal", "org", "pel", "msg", "lo", "link", "ext", "and", "prot", "ct", "iam", "blog", "tab", "sql", "Log", "util", "cat", "row", "en", "report", "pl", "low", "note", "use", "ex", "t", "crit", "LOG", "default", "al", "ar", "category", "email", "alert", "tag", "lock", "le", "at", "be", " logger", "error", "debug", "xml", "w", "scale", "l", "event", "net", "cont", "enter", "print", "base", "entry", "set", "og", "gob", "ge", "cf", "url", "out", "conf", "bug", "c", "cache", "zip"], "dbConn": ["DBObj", "bbCon", "DBTx", "bbConnection", "dbObj", "bConn", " dbTx", "gbconn", "sbCon", "dbConnect", "cbConnection", " dbSys", "dbTx", "sbConnection", "sbConnect", " dbCon", "bConnect", "cbCon", "dbCon", "webConnection", "bbConn", "webCon", "DbObj", "dbSys", "gbConnection", "DbCon", " dbConnection", "webConn", "DbConnection", "bConnection", "dbconn", "cbConnect", "gbCon", "gbConn", "bbConnect", "DbSys", " dbConnect", "sbconn", "webObj", "DBSys", "DbConn", " dbObj", "bCon", " dbconn", "sbConn", "cbConn", "dbConnection", "DBCon", "DbTx", "DBConn"], "getNextOutageIdStmt": ["getNextOutageIDStmb", "getNextOutageIdStMT", "getNextOutageIdstmt", "getNextOutageIdstmb", "getNextOutageIDstmm", "getNextOutageIdSTmt", "getNextOutageIDStmt", "getNextOutageIdStmm", "getNextOutageIDStm", "getNextOutageIdstm", "getNextOutageIdSTmm", "getNextOutageIdStm", "getNextOutageIdSTMT", "getNextOutageIDstm", "getNextOutageIdSTmb", "getNextOutageIdStmb", "getNextOutageIdstmm", "getNextOutageIDstmt", "getNextOutageIDStMT", "getNextOutageIdstMT", "getNextOutageIdSTm", "getNextOutageIDstMT", "getNextOutageIDStmm", "getNextOutageIDstmb"], "outageID": ["OutagementID", "outAGEid", "outagateID", "outageIT", "OutageUID", "outageIndex", "OutagementUID", "OutagementIndex", "outageId", "OutagementWriter", "OutagementIT", "Outagementid", "outagementid", "outAGEUID", "OutageIndex", "outagId", "outancyIndex", "outagateWriter", "OutageWriter", "outagerID", "outagementIndex", "outancyID", "outagementET", "outagerWriter", "outagementUID", "OutageIT", "outagateId", "outAGEID", "outancyET", "Outageid", "OutagementId", "outageUID", "outageid", "OutageET", "outagementIT", "outagID", "outancyId", "outAGEId", "outrageid", "outagerId", "outagementWriter", "outrageID", "outageWriter", "outagerIT", "outrageUID", "OutageId", "OutageID", "outageET", "outagET", "outrageId", "outagIndex", "outagementId", "outagateIT", "OutagementET", "outagementID"], "seqRS": ["sequenceSR", "sequencePS", " seqDS", "sequenceRS", " seqPS", " seqrs", "nextPS", "descRs", "sequSR", " seqRES", "reqrs", "descRS", "seqSR", "seqPS", "nextRs", " seqRs", "sequRs", "seqRs", "eqrs", "seqrs", "descRES", "reqSR", "eqRs", "sequRS", "nextDS", "sqSR", "eqRS", "sqWS", "descrs", "sequenceRs", "sequenceDS", "sequencers", "sqRs", "seqRES", "nextRS", "reqRS", "sequenceRES", " seqSR", "sequWS", "seqDS", "seqWS", "reqRES", " seqWS", "eqRES", "sqRS"], "newOutageWriter": ["newIntagementEntry", "newOutagaWriter", "newOutagementWriter", "newOutagaWrite", "newoutagementWrite", "newOutagementwriter", "newOutagesEntry", "newOutagesEditor", "newoutagEntry", "newOutageWriting", "newOutagwriter", "newOutancyWriting", "newIntagementWriting", "newOutagewriter", "newOutagementWriting", "newoutagWriter", "newOutagementWrite", "newIntageWR", "newoutagwriter", "newOutageEditor", "newOutagWriter", "newOutageWrite", "newOutagerWrite", "newIntagementWrite", "newOutancyEntry", "newOutagementWR", "newOutrueWriter", "newOutaceWriter", "newoutagementEntry", "newoutageWriter", "newOutagEntry", "newIntageWrite", "newOutageReader", "newoutancewriter", "newOutancyWrite", "newIntageEntry", "newoutagementwriter", "newOutagaReader", "newIntagementWriter", "newOutagaWR", "newOutancyWriter", "newOutrueWrite", "newoutagWrite", "newOutagementReader", "newIntageWriting", "newIntagementWR", "newoutanceWrite", "newOutancewriter", "newoutageWrite", "newOutagerWriter", "newoutageEntry", "newOutanceWriter", "newOutrueEditor", "newOutacewriter", "newOutaceWriting", "newOutageWR", "newOutagWrite", "newOutaceWrite", "newoutanceWriter", "newOutageEntry", "newIntageWriter", "newOutanceWrite", "newOutageswriter", "newOutanceEditor", "newOutagerWR", "newOutaceEntry", "newoutageEditor", "newOutruewriter", "newOutagesWriter", "newOutagerReader", "newoutagementWriter", "newoutanceEditor", "newoutagewriter", "newIntagementReader", "newOutagesWrite", "newOutagementEntry", "newIntageReader"]}}
{"id1": "7396682", "id2": "12055086", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["load", "core", "replace", "split", "sync", "cross", "link", "move", "repeat", "proxy", "crop", "transfer", "clip", "read", "download", "create", "cat", "slice", "map", "fit", "Cop", "delete", "write", "cop", "cp", "share", "upload", "gc", "Copy", "archive", "clone", "py", "php", "pixel", "opy", "zip"], "srcFS": ["sourceFS", "srcOS", " srcVS", "srfs", "srcFs", "srcCS", "sourceCS", "rcCS", "rcSF", " srcCS", " srcSF", "sysFS", "srcSF", "sourceVS", "srcVS", "sysFs", "srFs", "sourcefs", "srcfs", " srcfs", "rcfs", "rcFS", "sourceFs", "srMS", "srFS", "rcMS", "sysOS", "srcMS", "rcFs", " srcMS", " srcOS", "sourceSF", " srcFs", "sourceOS", "rcOS", "sysVS", "rcVS"], "src": ["path", "nil", "ser", "http", "proc", "node", "st", "addr", "RC", "boot", "sync", "SOURCE", "img", "init", "pkg", "sys", "tmp", "rx", "lb", "sin", "via", "sc", "rel", "rc", "dir", "desc", "from", "subject", "sub", "uri", "loc", "th", "resource", "obs", "filename", "Source", "rs", "spec", "pri", "iv", "syn", "comp", "req", "str", "ctr", "dest", "txt", "sec", "obj", "sit", "cont", "sn", "sr", "check", "source", "input", "selected", "secure", "sb", "https", "target", "inst", "url", "start", "sci", "usr", "sq", "supp", "cur"], "dst": ["deest", " ddest", "ddlt", "desdest", "dhdest", "dhst", "dST", " dST", "ddst", "dddest", "Dlt", "DDest", "dedest", "ddest", "DST", "dlt", "dsnd", "dgt", "deslt", "dsdest", "dsest", "Ddest", "ddnd", " dlt", "dslt", "dsST", "Dst", "lst", " dest", "desst", " dDest", "dsgt", "dest", "dDest", "ldest", "desnd", "lgt", "Dest", "dnd", "lest", "dsst", "degt", "dhDest", "dhlt"], "deleteSource": ["closeSOURCE", "deleteSources", "removeSource", "removeParent", "delSOURCE", "leteResult", "closeSite", "leteParent", "destroySources", "deleteParent", " deleteTarget", "destroyResult", "delDest", "leteSOURCE", "leteDest", "updateSource", "removeDest", "leteTarget", "DeleteSite", "updateSite", "deleteResult", "leteSource", "deleteTarget", "deleteDest", "destroyTarget", "deleteSOURCE", "updateSOURCE", "closeSourceFile", "leteSources", "updateSourceFile", "delParent", "DeleteSOURCE", " deleteResult", "destroySource", "closeSource", "deleteSourceFile", "deleteSite", " deleteSources", "delSource", "removeSOURCE", "DeleteSourceFile", "DeleteSource"], "conf": ["ch", "plan", "con", "ln", "config", "ban", "f", "params", "q", "prop", "pool", "scan", "css", "irm", "mm", "cms", "conv", "map", "cfg", "param", "acc", "cm", "ref", "Conf", "req", "cb", "comm", "fs", "lib", "conn", "check", "def", "hash", "m", "cn", "ctx", "cc", "log", "job", "comment", "co", "info", "cf", "com", "ca", "report", "cache"], "contents": ["constaves", "Content", "Contodes", " contresses", "Contents", "CONTodes", "contends", " Contresses", " contENTS", "contodes", "contresses", "CONTends", "CONTants", "constents", "CONTents", "constENTS", "Contterms", "CONTaves", "contENTS", " Contents", "content", "ContENT", "CONTterms", "CONTENTS", " Content", "CONTent", "CONTresses", " contENT", "Contants", " contodes", " ContENTS", " content", "contterms", "constends", "CONTENT", " contants", " contaves", " contterms", "contENT", "contants", "contaves", " contends"], "i": ["ims", "multi", "json", "im", "ms", "x", "j", "init", "n", "phi", "my", "it", "ai", "ini", "is", "ic", "ski", "ui", "ie", "me", "q", "id", "y", "o", "ci", "mi", "ind", "ki", "qi", "ii", "client", "gi", "hi", "key", "ti", "ji", "inner", "bi", "index", "si", "I", "span", "u", "ori", "ei", "m", "iter", "xi", "us", "iq", "cli", "ami", "docker", "di", "sim", "pi", "ij", "chain", "ip", "li", "oi", "\u0438", "ix"], "in": ["IN", "din", "con", "add", "by", "ini", "is", "ze", "mc", "and", "body", "raw", "sql", "read", "sample", "en", "inc", "from", "re", "ind", "ins", "bin", "inner", "doc", "reader", "xml", "isin", "r", "char", "In", "check", "input", "source", " din", "inn", "out", "inf", "cin"]}}
{"id1": "659316", "id2": "3053403", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 1, "substitutes": {"argv": ["suppp", "argsv", "Argv", "argV", "suppV", " argm", "argsV", "Argm", "argss", "argsc", "suppvs", "callV", " argvs", "suppv", " argc", "argm", "callvs", "ArgV", "argsm", "argvs", "argc", " argV", " argp", "argp", "callp", "Argc", "Args", "callv"], "sources": ["inources", "seets", " sures", "inodes", "tources", "sliders", "servets", "inets", " sors", " sets", " siders", "sodes", "seodes", "servources", "seults", "sors", " soots", " sults", "sures", "stors", "tiders", " socks", "sloots", " sodes", "stources", "slources", "stets", "toots", "stures", "socks", "slocks", "seources", "soots", "siders", "inults", "sults", "tocks", "servors", "servures", "sets"], "targets": ["topes", " tangets", "targetsets", "topens", "tangches", "targends", "toksets", "Targes", "targetgers", "tankets", "toolsargens", "tangets", "Topets", "targetens", "Targches", "Topends", "targes", "Topches", " tanges", "topches", "tokets", "tokes", "tokens", "tanges", "tassches", "tokgers", "toolsargets", "tokends", "tasses", "toolsankets", " targens", " tangens", "tankens", "tanksets", "toolsarggers", " tangends", "Targets", "Topes", "toolsanksets", "toolsankgers", "tangens", "topends", "toolsargsets", "targetets", "targens", "toolsankens", " targes", " targends", "topets", "targsets", "targches", "tankgers", "targgers", "tassets", "tassends", "Targends", "tangends"], "srclen": ["srclogn", "srseln", "srklog", " srplen", "srklen", "srplade", "srklue", "rsccue", "srccen", "srplen", "srccog", "srselogn", "rsclue", "rsclogn", " srcln", "srselog", " srplength", " srpln", "srclog", "rsccen", "srCLade", "srccue", "srCLength", " srclength", "srCLen", " srclade", " srplade", "srclength", "srselue", "srclade", "rsclog", "srplength", "srccogn", "rsclen", "srselade", "srCLn", "srselength", "srcln", "srklogn", "srselen", "rsccog", "srclue", "rsccogn", "srpln"], "source": ["buffer", "style", "ser", "site", "internal", "template", "SOURCE", "force", "sys", "link", "me", "ource", "root", "console", "local", "scan", "create", "from", "resource", "scope", "Source", "wrapper", "parent", "this", "src", "store", "null", "inner", "reader", "get", "service", "scale", "sequence", "standard", "input", "copy", "iter", "select", "status", "secure", "match", "set", "file", "system", "sp", "query", "search", "info", "escape", "s", "trace", "start", "context", "score", "cache"], "tgt": ["teht", "npt", "itarg", "itgt", "ittarget", "tearget", "nht", " tpt", "Target", "Targ", " tgn", "ttarget", "starget", "warget", " targ", "tearg", "targ", "ngn", "itht", "Tht", "wtarget", "tgn", "warg", "Tgt", "sttarget", "tht", "tegn", " ttarget", "wgt", "tpt", "tegt", "itarget", " tht", "stgt", "tetarget", "ngt", "tept", "starg"], "target": ["output", "path", "buffer", "pointer", "top", "trap", "mask", "owner", "internal", "bolt", "template", "touch", "member", "peer", "sys", "tmp", "link", "manager", "proxy", "arget", "socket", "Target", "rel", "local", "to", "channel", "resource", "wrapper", "parent", "stable", "null", "writer", "next", "goal", "dest", "handler", "inter", "localhost", "base", "gt", "child", "copy", "table", "match", "secondary", "trace", "ARGET", "out"], "deletes": ["seleted", "dges", "deges", "desets", "Deels", "desleted", "delves", "leets", "dletes", "desletes", "desges", "Deles", "Deletes", "seletes", "dlets", "delets", "duleted", "lelets", "duges", "deslets", "dellets", "dleted", "desves", "deves", "duletes", "seles", "dules", "seels", "deets", "deleted", "delletes", "deles", "dulets", "deels", "leletes", "leves", "Deleted", "duels"], "del": ["Del", " dele", "dr", "ls", "se", "dis", "pel", "des", "tl", "rol", "rem", "vet", "rel", "inv", "ele", "col", "bl", "re", "dem", "sel", "pl", "dl", "nl", "el", "nt", "syn", "le", "delete", "ll", "dec", "l", "tr", "compl", "md", "err", "kl", "let", "cl", "def", "ne", "rl", "els", "cel", "elt", "de", "len"]}}
{"id1": "16215393", "id2": "5299276", "code1": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"importSequences": ["loadsequelines", "loadSequences", " importsequelines", " importSeence", "loadsequences", " importSlence", " importSeelines", " importSlines", "loadSequence", " importSequelines", "loadsequines", " importsequence", " importSeences", " importSlences", " importSequines", " importSeines", " importSequence", " importSlelines", "loadSequines", " importsequines", "loadsequence", " importsequences", "loadSequelines"], "names": ["uploads", "sheets", "nos", "strings", "artifacts", "eas", "users", "types", "orders", "times", "roots", "mas", "people", "years", "files", "packages", "photos", "these", "ids", "ns", "said", "letters", "codes", "AMES", "keys", "Names", "named", "makers", "reports", "resources", "onyms", "idents", "groups", "finals", "papers", "aps", "ren", "ames"], "sequences": ["enencies", "Sequencing", "seqames", "requence", "seqes", "sequencing", "requelines", "seqencies", "seqences", "enences", "sequencies", "sequames", "equelines", "Sequencies", "Sequences", "equencing", "equence", "enames", "requencing", "sequelines", "sequence", "Seques", "equences", "Sequelines", "Sequence", "enes", "Sequames", "requences", "seques"], "is": ["ists", "ais", "ms", "es", "isc", "tis", "ls", "iso", "ris", "se", "dis", "ai", "ois", "ri", "sys", "ui", "isl", "has", "bis", "isa", "its", "iss", "os", "does", "re", "rs", "serv", "isf", "\u00eds", "Is", "isin", "fs", "iris", "isi", "i", "sb", "ios", "s", "sis", "in", "res", "ip", "lis", "IS"], "helper": ["hypert", "utilpert", "hepher", "hapert", "horper", "helpility", "helber", "hper", " Helpers", " Helber", "calhel", " Helper", "perpert", "kelhel", " helpers", "hypher", "perporter", " helser", " helpi", "perpi", "kelper", "hiper", "perper", "hwpi", " helpen", "heliper", "perility", "utilility", "peripper", "horipper", "hwper", "helpert", "hapher", "helpen", "kelpert", "hehelp", "helpber", " helber", "hpert", "helipper", "caliper", "helpper", "helhelp", "calper", "helpi", "calpert", "perpers", "utilper", "utilipper", "heper", "horpper", "hhel", "helpser", "helpers", "perpper", "horpert", "utilpper", " Helser", "helppers", "hahelp", "hyhelp", "haper", "helser", "hwporter", "helhel", "helppper", "hyper", "helporter", " helporter", "helility", "keliper", "utilpers", "hepert", "hwpen", "perpen", "helpher"], "ch": ["history", "yet", "cell", " Ch", "j", "chan", "cho", "msg", "change", "och", "q", "ver", "ched", "wh", "count", "cd", "col", "cs", "ach", "ich", "pr", "th", "conv", "qu", "cr", "comp", "str", "ech", "zh", "cp", "comm", "cb", "sh", "char", "Ch", "cha", "cont", "tch", "cl", "cht", "ph", "job", "z", "range", "br", "i", "CH", "che", "cmd", "vc", "conf", "cor", "c", "cur"], "line": ["message", "list", "text", "cell", "block", "lin", "phrase", "ln", "user", "header", "eline", "link", "normal", "shell", "body", "row", "frame", "nl", "lines", "content", "le", "code", "inline", "ine", "str", "LINE", "l", "online", "page", "level", "sequence", "string", "source", "iter", "log", "range", "chain", "comment", "info", "data", "url", "word", "Line"], "tokenizer": ["tokenator", "Tokener", " tokeniser", "tokeniser", " tokenister", "wordator", "worder", "okeniser", "tokenize", "Tokenize", "Tokeniser", "okenizer", "okenister", "Tokenister", "worditer", "Tokenator", " tokenator", "tokenister", " tokeniter", "okenize", "Tokenizer", "Tokeniter", "wordizer", " tokener", " tokenize", "tokeniter", "tokener"], "name": ["path", "ident", "text", "part", "prefix", "n", "type", "var", "item", "normal", "title", "id", "nm", "no", "common", "local", "filename", "NAME", "ame", "key", "label", "str", "w", "family", "sequence", "named", "nam", "base", "string", "cap", "Name", "value", "chain", "info", "format", "alias", "word"], "seq": ["quit", "buffer", "buf", "se", "j", "sl", "msg", "pkg", "ext", "tmp", "nm", "tab", "rez", "sample", "queue", "sel", "sub", "obs", "resp", "pipe", "pos", "pse", "buff", "nt", "cmp", "null", "req", "str", "next", "vec", "obj", "txt", "sequence", "result", "sec", "mem", "struct", "batch", "sequ", "ctx", "iter", "iq", "exp", "sim", "data", "temp", "sq", "list", "gen", "zip"]}}
{"id1": "12055086", "id2": "411595", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeleging", " copyDelingting", " copydeleving", " copyDeletving", " copydeletting", " copydeleging", " copydeleting", " copydeleing", " copydeletving", " copyDeeleving", " copyDeleing", " copyDelingving", " copyDeletging", " copyDeeleging", " copyDelingging", " copyDeeleing", " copyDelinging", " copydeletging", " copyDeleving", " copyDeeleting", " copyDeletting"], "source": ["style", "site", "init", "template", "se", "SOURCE", "seed", "body", "ource", "sql", "local", "sample", "ce", "from", "resource", "spec", "scope", "Source", "back", "parent", "src", "store", "original", "service", "ace", "form", "base", "input", "oss", "sp", "target", "query", "search", "origin", "start", "image"], "dest": ["lit", "est", "st", "orig", "it", "img", "pub", "del", "master", "end", "cat", "dir", "mm", "pas", "loc", "th", "bin", "tom", "dist", "src", "null", "d", "w", "cas", "Dest", "them", "trans", "nom", "port", "decl", "https", "target", "sp", "exp", "comb", "origin", "temp", "rest", "way"], "buf": ["buffer", "pause", "Buffer", "db", "block", "img", "pkg", "fg", "b", "aka", "bs", "bag", "Buff", "tab", "prop", "alph", "cat", "bl", "cv", "meg", "seq", "conv", "fb", "arr", "buff", "ref", "uf", "eb", "cast", "box", "str", "bus", "vec", "cb", "cp", "bytes", "bc", "batch", "tx", "cap", "capt", "br", "bh", "comb", "data", "cf", "cmd", "rb", "cur"], "in": ["IN", "on", "per", "din", "con", "gin", "or", "by", "init", "it", "user", "rin", "ai", "ini", "ze", "ic", "is", "ri", "read", "en", "inc", "mm", "from", "ind", "al", "ins", "el", "bin", "inner", "isin", "In", "un", "input", "iter", "i", "info", "inn", "inside", "inf", "cin"], "out": ["output", "on", "ion", "con", "by", "n", "auto", "Out", "dis", "sys", "flush", "can", "o", "aos", "to", "os", "en", "end", "io", "conv", "outs", "t", "client", "up", "v", "ou", "nt", "at", "write", "inner", "writer", "sum", "obj", "page", "net", "conn", "OUT", "ne", "cn", "log", "oss", "i", "co", "res", "outer"], "count": ["ch", "counter", "add", "core", "cond", "n", "nb", "now", "ct", "q", "common", "read", "size", "num", "ind", "t", "current", "total", "deep", "length", "nt", "acc", "Count", "code", "cloud", "ctr", "index", "number", "span", "sum", "ount", "char", "cont", "batch", "check", "amount", "cap", "cc", "max", "z", "comment", "found", "start", "conf", "coll", "c", "len"]}}
{"id1": "19849797", "id2": "23510383", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferStream", " copyFiles", " cpfile", " cpStream", "transferFile", " copyStream", "transferFiles", "copyStream", " cpFiles", "copyFiles", " copyfile", "copyfile", " cpFile", "transferfile"], "sourceFile": ["ourceFile", "sourceLine", "ourcefile", "srcTable", "ourcePage", "ourceTable", "ourceLine", "srcLine", "srcFile", " sourcefile", "srcPath", " sourceField", "sourcePath", " sourcePage", "srcField", "srcfile", " sourceLine", "ourcePath", "sourceTable", "sourcePage", "srcPage", "sourcefile", " sourceTable", "ourceField", " sourcePath", "sourceField"], "destFile": ["optFolder", "DestPath", "optDir", " destFilename", " destFiles", " destDir", "datFilename", "srcFolder", "DestFilename", "optFilename", "destEntity", "declDir", "DestDir", "destDir", "DestFiles", "restFilename", "destFilename", "srcFile", "datFiles", "destFiles", "srcPath", "optPath", "declFolder", "restFile", " destPlace", "optEntity", "srcEntity", "declEntity", "destPath", "declFile", "optFile", " destPath", "destPlace", "srcDir", "srcFiles", "destFolder", "restPlace", "datPlace", "DestFile", "datFile", "restFiles"], "source": ["series", "style", "load", "owner", "update", "missing", "se", "init", "SOURCE", "force", "ie", "attribute", "shell", "proxy", "body", "send", "ource", "console", "local", "sample", "create", "ce", "iterator", "from", "subject", "note", "use", "pose", "resource", "channel", "spec", "scope", "Source", "back", "parent", "component", "slave", "src", "inner", "store", "cause", "reader", "index", "stream", "service", "none", "char", "scale", "sequence", "result", "before", "standard", "check", "input", "OURCE", "iter", "copy", "table", "match", "parse", "comment", "show", "target", "query", "search", "origin", "in", "start", "image", "score"], "destination": ["verination", "Destination", "destinator", "Destation", "decined", "Destinator", " destment", "verificate", "separination", "destation", "terminined", " destinated", "restination", "destificate", "descinator", "decinated", "noninated", " destificate", "noninate", "separment", "descinate", "destment", "Destinate", "noninator", "destined", " destined", "separation", "termininate", "Destinated", "Destificate", " destation", "decinate", "verinated", "nonination", "descination", "restinator", "terminination", "descation", "decination", "restinate", "destinate", "destinated", "Destment", "veration", "separinated", "restinated", "termininated", " destinate", " destinator"]}}
{"id1": "414258", "id2": "8024375", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["path", "http", "html", "ls", "location", "term", "sl", "config", "bel", "link", "b", "ur", "Url", "address", "q", "URL", "sql", "util", "pl", "default", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "browser", "gl", "ref", "key", "ld", "name", "str", "xml", "mount", "ll", "impl", "external", "get", "l", "char", "page", "un", "base", "string", "cl", "rl", "file", "log", "job", "domain", "web", "r", "pattern"], "in": ["IN", "on", "update", "din", "gin", "con", "init", "n", "ln", "oin", "rin", "ai", "is", "vin", "mc", "f", "body", "o", "read", "en", "nin", "mi", "from", "al", "ins", "login", "ma", "bin", "serv", "inner", "null", "name", "reader", "isin", "l", "online", "In", "min", "include", "line", "check", "input", "source", "m", "again", "i", " din", "s", "inn", "out", "c", "cin"]}}
{"id1": "19739421", "id2": "11933797", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownCommandClass", "UnknownOptionError", " UnknownCommandException", "UnknownFormatError", "UnknownCommandError", "UnknownOptionClass", "UnknownParameterHandler", "UnknownParameterClass", "UnknownCommandHandler", " UnknownOptionHandler", " UnknownOptionError", " UnknownCommandHandler", "UnknownFormatException", " UnknownCommandError", "UnknownParameterException", "UnknownFormatHandler", "UnknownFormatClass", "UnknownCommandException", " UnknownCommandClass", "UnknownOptionHandler", "UnknownParameterError", " UnknownOptionClass"], "cmdLineParser": ["cmdListParser", "commandLineParser", "cmdBlockOptions", "mdlineparser", "cmdlineBuilder", "cmdFramePers", "mdlinearser", "cmdLOptions", " cmdLineReader", "cmdlineRunner", "cmdBlockParser", "mdLineLoader", "commandLineRunner", "commandLineReader", "cmdLineparser", "cmdNetParser", "mdLineparser", "cmdNetStreamer", "cmdLineBuilder", "cmdChainReader", "cmdChainLoader", "CmdlineBuilder", "cmdLinePers", "commandlineBuilder", "cmdFrameParser", "cmdNetHandler", "mdLineStreamer", " cmdPageParser", "cmdlineparser", "cmdlineProvider", "cmdBlockProvider", "cmdBlockReader", "mdlineParser", "cmdListBuilder", "cmdFrameReader", "mdLineParser", "cmdChainarser", "cmdPageReader", "cmdLinearser", "cmdSetparser", "cmdLineOptions", "commandlineReader", "cmdlineStreamer", "cmdLineReader", "commandlineParser", "commandLineBuilder", "cmdlinePers", "cmdBlockHandler", "cmdlineReader", "commandlinePers", "mdlineReader", "mdLineOptions", "CmdlineProvider", "cmdSetReader", "CmdlineReader", "cmdBlockBuilder", "commandLineProvider", "mdlineLoader", "CmdLineBuilder", " cmdPageReader", "cmdlineHandler", "mdLineBuilder", "CmdlineParser", "cmdListReader", "mdLineReader", "CmdLineProvider", "cmdlinearser", "mdlineBuilder", "CmdLineReader", "cmdlineOptions", "cmdFrameRunner", "commandLinePers", "cmdLParser", "mdlineOptions", "cmdSetParser", "cmdLineRunner", "cmdLineHandler", "cmdPageParser", "cmdNetReader", "cmdListparser", "cmdLineStreamer", "cmdLineProvider", "commandlineRunner", "cmdlineParser", " cmdPageBuilder", "cmdSetBuilder", "cmdPageProvider", "commandlineProvider", "mdlineStreamer", "mdLinearser", "cmdChainParser", "cmdlineLoader", "mdlineHandler", "cmdPageBuilder", "cmdLHandler", "cmdLBuilder", "CmdLineParser", "mdLineHandler", " cmdLineBuilder", "cmdLineLoader"], "formatOption": [" formatEntry", "filterEntry", "transformEntry", " formatOptions", "FormatOption", "formatEntry", "formatOptions", "filterOption", "formatOperation", "FormatOptions", " formatOperation", "transformOption", "transformOperation", "FormatOperation", "transformOptions"], "outputEncodingOption": ["outputencodingOptions", "outputEncachingOptional", "outputencodingOptional", "outputEncappingoption", "outputEncachingOptions", "outputencodingOption", "outputEncgingOption", "outputEncodingOptions", "outputencachingOptions", "outputencodingoption", "outputEncappingOption", "outputEncamingOption", "outputEncgingOptional", "outputencachingOption", "outputencappingOption", "outputEncachingOption", "outputEncamingoption", "outputencappingOptional", "outputEncamingOptional", "outputEncamingOptions", "outputEncappingOptions", "outputEncodingOptional", "outputencappingoption", "outputEncappingOptional", "outputencachingOptional", "outputEncgingoption", "outputEncodingoption"], "inputEncodingOption": ["inputEnclingOptions", "inputenclingOption", "inputEncordingOptions", "inputEncappingOptions", "inputEncachingOptions", "inputencodingAttribute", "inputEncappingOption", "inputEncappingoption", "inputCachingOption", "inputCachingOptional", "inputCachingOptions", "inputCodingOption", "inputCodingOptional", "inputEncendingOptions", "inputencodingOptions", "inputEncodingAttribute", "inputCodingOptions", "inputenclingAttribute", "inputEncordingoption", "inputEncodingoption", "inputEncordingOption", "inputEnclingoption", "inputenclingOptions", "inputEnclingOption", "inputEncodingOptional", "inputEnclingAttribute", "inputEncendingOption", "inputEncachingOptional", "inputencodingOption", "inputEncappingOptional", "inputEncappingAttribute", "inputencodingoption", "inputEncendingOptional", "inputEncachingOption", "inputEncodingOptions", "inputEncordingAttribute", "inputenclingoption"], "format": ["output", "printf", "style", "term", "prefix", "template", "method", "config", "it", "force", "type", "sort", "title", "filter", "f", "api", "pretty", "export", "accept", "note", "use", "with", "Format", "filename", "transform", "at", "module", "error", "version", "name", "fix", "unit", "get", "scale", "policy", "license", "form", "tif", "print", "command", "string", "source", "set", "status", "language", "table", "file", "parse", "option", "join", "pi", "what", "display", "layout", "pattern"], "outputEncoding": ["outputEngoding", " outputEncaling", "outputDecoding", "outputencoding", "outputEncaming", "outputDecalling", " outputEncaming", "outputEncaching", "outputMessaming", " outputDecaming", "responseEncalling", "currentEncaching", "outputEncling", "outputEnording", "outputEngacing", "responseEncoding", "outputencaging", " outputEncryption", "outputencording", "outputMessryption", "outputencaching", "outputEngoder", " outputEngacing", "outputEnacing", "outputCompining", "outputEnaging", "outputencging", "outputEncryption", "outputEncoder", " outputEngaling", "outputEncining", "outputEncording", "currentEncling", " outputEncoder", "currentEnoding", "outputCompryption", "currentEnging", "outputEngling", "outputEngging", "outputCompaming", " outputEngoding", "responseEncryption", "outputMessining", "outputEnaling", " outputEncining", "outputencling", " outputDecoding", "outputEnryption", "publicEncaging", "outputEnoding", "outputEncging", "outputEncaling", "outputCompoding", "currentEnling", "outputDecining", "outputEncaging", "outputDecling", "outputEncalling", "publicEncling", "outputEngaching", "outputEncacing", "publicEncording", " outputEncacing", "outputDecaming", "outputEnalling", "currentEncging", "outputEnling", "outputMessoding", "outputEnging", "publicEncoding", "outputEnoder", "responseEncling", " outputEngoder", " outputDecryption", "outputDecryption", "outputEngaling", "outputEnaching", "currentEnaching", " outputDecining", "currentEncoding"], "inputEncoding": ["inputChoding", "inputCodling", "inputPackoder", "contextEncale", "inputEnling", "inputEncoder", "inputChacing", "contextEnoding", "inputEnacing", "inputChale", "inputEnging", "outputEnging", "sourceEnling", "inputEncacing", "outputEncoder", "outputEnoding", "sourceEncoding", "inputEning", "inputEncling", "inputEncging", "inputCodacing", "outputEncging", "inputEnale", "contextEncacing", "inputEngoder", "inputencale", "outputEncale", "inputChoder", "contextEnale", "inputCododing", "inputEngging", "inputCoding", "outputEnoder", "contextEncoder", "inputEngale", "contextEnacing", "sourceEncacing", "inputencoder", "inputencoding", "inputEncale", "outputEnale", "inputencing", "sourceEncing", "inputEnoding", "inputPackging", "inputencling", "sourceEncling", "sourceEnacing", "inputPackale", "contextEncoding", "inputEncing", "inputencacing", "inputEngoding", "sourceEning", "contextEnoder", "sourceEnoding", "inputEnoder", "inputPackoding"], "remainingArgs": ["remainingFrames", "resainingargs", "remainingBlocks", "remainedParts", "resainedParameters", "remendingGS", "trainingGS", "mainingParts", "removalArgs", "remendingFrames", "remainsArgs", "remistingGS", "resainingGS", "remainedBlocks", "resainedArgs", "removalGS", "remainFrames", "trainingArgs", "remgoingArgs", "remainedGS", "resainedGS", "resainingArgs", "remainedJs", "remainedArgs", "resainingBlocks", "remainingParts", "resainingLinks", "remgoingGS", "remendingItems", "remainBlocks", "remainJs", "remainsParameters", "remainArgs", "remainedargs", "remgoingParts", "remgoingargs", "resainingParameters", "remistingArgs", "mainedArgs", "trainFrames", "remainingParameters", "remainsBlocks", "removalBlocks", "resainedargs", "resainedLinks", "remainGS", "remainingItems", "remistingLinks", "mainingJs", "remainedItems", "resainingItems", "remainingGS", "trainGS", "removalParameters", "resainedBlocks", "mainingArgs", "remainsGS", "trainingFrames", "remgoingItems", "mainedParts", "trainArgs", "mainedJs", "remendingArgs", "trainItems", "remistingBlocks", "remainingLinks", "remainedFrames", "resainedItems", "remainItems", "remainParts", "remainLinks", "remainedParameters", "remainargs", "remgoingJs", "mainedGS", "remainingJs", "mainingGS", "trainingItems", "remainedLinks", "remainingargs"], "inputFile": ["inputPlace", "hiddenfile", "inputPath", " inputLike", "inputFILE", "acceptPlace", "acceptFile", "hiddenFile", " inputfile", "requestFile", "hiddenPath", "inputLike", " inputPlace", "hiddenLike", "outputPath", "outputfile", "Inputfile", "acceptLine", " inputFILE", "requestPath", " inputLine", "requestfile", "outputLike", "requestFILE", "InputLine", " inputPath", "InputFile", "InputPlace", "InputPath", "acceptfile", "InputFILE", "inputLine", "inputfile"], "outputFile": ["OutputDo", "outputFolder", "outputFilename", " outputFiles", "clientDir", " outputDo", "clientFiles", "cacheDir", "writefile", "coinfile", "outputfile", "Outputfile", "writeFile", "clientFile", "inputFilename", "writeFolder", "outputDir", "coinFile", "inputDir", "clientDo", " outputfile", "OutputFilename", "outputDo", " outputDir", "cacheFilename", "OutputFile", "coinDo", "OutputFiles", "outputFiles", "OutputDir", "cachefile", "cacheFile", " outputFolder", "writeDo", "coinFolder", "inputfile"], "out": ["output", "gr", "ser", "list", "on", "session", "con", "init", "n", "ln", "Out", "user", "msg", "sys", "manager", "pretty", "inv", "aos", "dir", "io", "ex", "outs", "ins", "up", "cfg", "ou", "all", "inner", "null", "writer", "error", "inter", "screen", "obj", "net", "err", "conn", "print", "OUT", "log", "in", "res", "outer", "temp", "report", "gen", "inf"]}}
{"id1": "16232202", "id2": "932225", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"doPost": ["handleAdd", " doPOST", "handlePOST", "DoAdd", " doAdd", "doAdd", "DoPOST", "doPOST", "DoPost", "handlepost", "handlePost", "dopost", " dopost", "Dopost"], "request": ["collection", "http", "controller", "attribute", "requ", "connection", "runtime", "complete", "re", "require", "version", "Request", "web", "query", "work", "url", "begin", "report", "list", "have", "QUEST", "template", "condition", "claim", "environment", "create", "forward", "quest", "pe", "print", "remote", "document", "remove", "handle", "application", "session", "worker", "address", "reset", "local", "frame", "subject", "register", "client", "current", "server", "browser", "xml", "view", "get", "directory", "result", "input", "select", "the", "first", "order", "message", "open", "user", "reference", "raw", "ire", "initial", "setup", "call", "req", "process", "post", "position", "law", "record", "command", "media", "context"], "response": ["output", "ve", "message", "http", "application", "session", "site", "social", "description", "location", "header", "detail", "onse", "connection", "shell", "send", "environment", "console", "re", "respond", "answer", "esi", "security", "resp", "video", "server", "continue", "summary", "e", "exit", "settings", "version", "next", "view", "position", "service", "page", "event", "Response", "sequence", "print", "entry", "object", "status", "reply", "render", "profile", "document", "res", "out", "image", "report", "network"], "cu": ["U", "bo", "ub", "eu", "cus", "cy", "cci", "pu", "uc", "ui", "zu", "lu", "ur", "chu", "ucc", "tu", "ck", "su", "umi", "um", "ut", "util", "uci", "au", "ci", "gu", "cum", "angu", "lc", "unc", "ua", "uo", "ou", "cro", "gru", "cm", "uu", "cpu", "cgi", "nu", "hua", "du", "aus", "tc", "ju", "cp", "yu", "hu", "aco", "ue", "u", "Cu", "ctx", "cul", "cn", "us", "mu", "CU", "co", "ocr", "UD", "ru", "c"], "ud": ["ub", "und", "udd", "udo", "eu", "vd", "cus", "aud", "unt", "uc", "ui", "od", "bd", "ur", "rod", "zu", "tu", "udi", "su", "ut", "mud", "ck", "um", "util", "uds", "htt", "ost", "ci", "gu", "uda", "dl", "edu", "uh", "urd", "ku", "unc", "uu", "ow", "eus", " du", "du", "gd", "ld", "dd", "d", "aus", "gb", "uid", "ord", "u", "td", "pd", "us", "di", "dk", "oud", "UD", "hd", "ad"], "returnTo": ["urnTarget", "ReturnTo", "urnTO", "urn2", "returnto", "endTo", "endto", "Return2", "addTo", "returnTO", "return2", "renderTO", "addTO", "ReturnTO", "renderto", "addto", "render2", "endTarget", "renderTo", "urnTo", "urnto", "Returnto", "addTarget", "returnTarget", "endTO"], "password": ["message", "description", "prefix", "phrase", "remember", "hello", "user", "database", "attribute", "secret", "definition", "token", "pool", "ssh", "reset", "wd", "default", "auth", "security", "login", "Password", "email", "pty", "PASS", "trust", "sword", "shadow", "username", "crypt", "command", "padding", "profile", "paste", "push", "word", "pattern"], "md": ["ms", "nd", "pdf", "sd", "msg", "mc", "bd", "and", "od", "MD", "grad", "der", "cd", "mg", "mm", "dm", "mt", "sm", "dh", "det", "ld", "magic", "dd", "d", "mb", " Md", "mac", "td", "mk", "amd", "mod", "Cmd", " MD", "pd", "m", "df", "mn", "cmd", "hd"], "hash": ["rh", "html", "Hash", "init", "hed", "shift", "has", "sha", "raw", "ashes", "h", "test", "oh", "rand", "len", "ho", "hex", "where", "key", "str", "flash", "sh", "mac", "shadow", "bytes", "char", "sum", "tr", "result", "dig", "check", "data", "height", "handle", "her", "hd", "ash"], "pass": ["priv", "session", "task", "mask", "step", "add", "pkg", "pg", "secret", "wd", "prop", "pool", "cat", "read", "test", "default", "auth", "pas", "pos", "ps", "tag", "fail", "PASS", "pack", "Pass", "ask", " def", "ack", "conn", "def", "push", "ph", "ass", "alias", "handle", "conf", "act", "pp", "zip"], "vis": ["priv", "san", "mit", "miss", "vol", "cond", "access", "val", "visible", "nav", "is", "type", "var", "tri", "see", "rav", "ver", "wa", "state", "inv", "ha", "att", "gu", "feat", "circ", "iz", "cfg", "v", "serv", "Vis", "vert", "key", "virt", "str", "view", "label", "comm", "hidden", "mod", "def", "status", "stat", "study", "VIS", "vid", "cap", "pres", "info", "display", "act"]}}
{"id1": "9272325", "id2": "4417943", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["sendGet", "doPost", "executeGet", "sendPOST", "executePost", "httpGet", "executeRequest", "doPOST", "httpRequest", "sendRequest", "httpPost", "doRequest", "doGet", "executePOST", "httpPOST"], "reqUrl": ["requestURL", " reqURL", "reqURL", "seqURL", "seqUrl", "reqName", "resUrl", "requestStr", " reqName", "reqPath", "requestPath", "resStr", "seqLink", "reqStr", " reqPath", "reqLink", " reqLink", "requName", " reqStr", "requURL", "resURL", "requUrl", "requLink", "seqName", "resPath", "requestUrl"], "parameters": ["paramuments", "promams", "parameter", "promuments", "publiceters", "equams", "paramations", "parmes", "equeters", "publications", "arameters", "promations", "parammes", "paruments", "prometers", "pareters", "publiceter", "prommes", "publicams", "equeter", "arammes", "arameter", "prometer", "pareter", "equations", "paramams", "aramuments"], "urlConn": ["httpConn", "relConnection", "implCond", "resourceconn", "urlCtrl", "utilConn", "implConn", " urlCo", "urlDesc", "belDesc", "objCo", " urlConnection", "nlConnection", "objconn", " urlCon", "relconn", "leftconn", "belConn", "URLCon", "sslConn", "URLconn", "httpConnector", "resourceLink", "httpConnection", "sslConnector", "leftConnect", "mountconn", "urlConnection", "resourceConn", "sslDesc", "urlConnector", "URLConnect", "webConnect", "rowConnection", "urlCond", "implDesc", "implConnection", "relConnector", "retConn", " urlConnector", "mountConn", "utilConnect", "webconn", "rowConn", " urlWr", "leftConn", "fileconn", " urlLink", "URLConn", "utilConnection", "mountCo", "belConnection", "urlWr", "nlConn", "rowCo", "leftCon", "relCo", "retConnect", "utilConnector", "nlConnector", "objCtrl", "mountLink", "urlCon", "fileConnection", "rowconn", "urlconn", "relConn", "urlConnect", "sslConnection", "sslConnect", " urlconn", "httpConnect", "mountWr", "sslCond", "fileCon", "fileConn", "objConn", "sslCo", "urlLink", "mountCtrl", "webConn", "mountConnector", " urlConnect", "belCond", "retconn", "urlCo", " urlCtrl", "sslconn", "resourceWr", "nlConnect", "sslCon"], "params": ["units", "json", "password", "prefix", "properties", "config", "pps", "posts", "types", "ams", "p", "AMS", "pins", "files", "ps", "param", "tags", "rs", "v", "changes", "terms", "bytes", "keys", "points", "values", "Parameters", "base", "string", "m", "padding", "results", "names", "data", "s", "options", "phys", "conf", "services"], "url": ["out", "http", "self", "ls", "location", "abs", "sl", "build", "pkg", "bel", "ur", "lb", "Url", "f", "ul", "URL", "loader", "au", "ssl", "dl", "uri", "nl", "loc", "t", "el", "uu", "name", "str", "mount", "ll", "get", "l", "base", "rl", "log", "sb", "web", "https", "r", "hl", "il"], "b": ["buffer", "B", "bf", "db", "binary", "block", "buf", "nb", "n", "it", "a", "bp", "f", "bis", "ob", "bs", "p", "bb", "fb", "bits", "v", "buff", "bin", "eb", "orb", "be", "bit", "mb", "d", "cb", "gb", "w", "bytes", "l", "u", "obj", "bc", "base", "batch", "m", "z", "i", "sb", "br", "s", "r", "rb"]}}
{"id1": "8430178", "id2": "12172485", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "cpFile", "CopyLine", " copyFiles", "CopyPath", "CopyFiles", " copyLine", "copyLine", " copyPath", "cpLine", "copyPath", "cpFiles", "copyFiles", "cpPath"], "source_name": ["sourceEname", "source_NAME", "source_local", "Source_NAME", "source09link", "src_file", "src_format", "sourcePname", "src_Name", "source09names", "Source_local", "sourceptcheck", "source_format", " source_names", "src_check", "src_case", "src_link", "source_names", "source09file", "source_word", "sourcePNAME", "sourcePlocal", "sourceEnames", "source09name", "source_case", "sourceEcase", "sourceptname", "sourceEName", "source_Name", "src_name", "sourceptnames", "source_link", "source_check", "src_names", "sourceptName", " source_word", "Source_name"], "dest_name": ["dest_id", " dest_Name", "destaxyname", "source_NAME", " dest_names", "dest_NAME", "dest9admin", "destipid", "start_Name", "startityName", "destationadmin", "start_common", "dest_key", "dest9Name", "src_file", "dest_create", "Dest_name", "destaxynam", "destitycommon", " dest_key", "Dest_Name", "destationName", "dest_nam", "startityadmin", "destityname", " dest_min", "destipfile", "destationname", "dest_size", "dest9group", "startitycommon", "dest_common", "dest_time", "destaxynames", "destityName", "destityadmin", "dest_admin", "destationcommon", "startityname", "dest__size", "Dest_group", "dest9name", "source_names", "start_name", "destipname", "destaxyName", " dest_no", "dest__names", "destipcreate", "src_create", "Dest_admin", "src_id", "dest__key", "dest_no", " dest_time", "source_nam", " dest_file", "source_Name", "dest_file", "src_name", "dest_Name", "dest_min", "dest_group", "dest_names", "dest__name", "start_admin", " dest_size"], "source_file": ["source___File", "ource_class", "source___service", "source1path", "sourcepyservice", "source2entry", "src_file", "sourcepyfile", "site_file", "sourcepystream", "sourcephpfile", "source_entry", "ource_file", "source1file", "source_info", "source2info", "src_path", " source_entry", "source___time", "site___le", "site___stream", "source___le", "sourcephpservice", "source_class", "sourceistfile", "ource_time", "source___class", "sourcephple", "ource_File", "source1name", "source___file", " source_link", "source_time", "source_path", "sourcephpstream", "site___service", "source_stream", "site_stream", " source_id", "source_File", "sourceistlink", "site_le", "source_service", " source_info", "src_stream", "source2file", "source_le", "src_name", "sourcepyle", "source_link", "source1stream", "site_service", "source___stream", "sourceistname", "source_id", "sourceistid", "site___file"], "destination_file": ["destrant_fp", "destinationJimage", "destinationJpath", "destination____File", "destinationJfile", "destination_link", "destination_db", "destinationJfp", "destination_fp", "destrantJimage", "destinate_do", "destination__db", "destinant_File", "destination_domain", "destinant_link", "destrantJfp", "destinant____file", "destinant_domain", "destinate_file", "destination_path", "destrant_file", "destification_ile", "destination____domain", "destification_path", "destination_File", "destination_do", "destinate_dir", "destrantJfile", "destination____db", "destinant_file", "destification_port", "destination_port", "destinant____db", "destination_dir", "destification_file", "destination_ile", "destrant_image", "destination__File", "destination____file", "destination_image", "destrant_path", "destination__file", "destinant____File", "destinant_fp", "destinant____domain", "destinant_port", "destinant_db", "destinate_ile", "destination__domain", "destrantJpath"], "source": ["ser", "session", "site", "or", "template", "config", "volume", "SOURCE", "ie", "sin", "connection", "title", "major", "product", "secret", "proxy", "class", "master", "ource", "local", "sample", "ce", "from", "note", "use", "feature", "client", "resource", "argument", "server", "Source", "scope", "parent", "content", "existing", "ources", "src", "script", "store", "cause", "reader", "unit", "dest", "service", "shadow", "tool", "sequence", "directory", "base", "input", "copy", "set", "object", "file", "status", "iter", "system", "join", "target", "query", "search", "origin", "start", "out", "image"], "destination": [" destication", "Destination", "destinator", "Destation", "targetociation", "targetinations", "destication", "Destinator", "Destion", "destion", "destation", "estication", "estinate", "termininator", "gestociation", "targetion", " destinated", "restination", "restinations", "targetinator", "restion", "coordication", "targetinated", "methodinator", "targetification", "coordinated", "estination", "alterninate", "Destinated", "methodinate", " destation", "gestinator", "destociation", "originification", "gestination", "restinator", "restation", "destification", "originination", " destification", "coordination", "alterninated", "methodination", "terminination", "estinated", "coordinate", "restinate", "Destinations", "destinated", "destinate", "alterninator", "restinated", "origininator", "terminociation", "destinations", "targetination", "alternination", "termininated", "gestinated", "origininated", " destinate", " destinator", "methodinated"], "buffer": ["message", "Buffer", "binary", "text", "window", "block", "buf", "b", "transfer", "read", "bb", "frame", "buff", "length", "stream", "sequence", "base", "batch", "command", "iter", "table", "comment", "document", "append", "context", "paste", "cache"], "bytes_read": ["bytes2left", "bytes2Read", "bytesunleft", "bytes_Read", " bytes_written", "bytesunread", "bytes2written", " bytes_Read", "bytesunwritten", "bytes2read", "bytesunRead", "bytes_written", "bytes_left", " bytes_left"], "in": ["IN", "din", "gin", "con", " IN", "add", "n", "it", "user", "ini", "rin", "is", "ic", "body", "id", "p", "read", "en", "io", "from", "nin", "mm", "ind", "ins", "std", "t", "ar", "client", "bin", "all", "inner", "doc", "reader", "stream", "get", "isin", "r", "sum", "l", "In", "err", "input", "file", "log", "mn", "inn", "out", "conf", "diff", "inf", "cin"], "response": ["output", "message", "application", "bye", "json", "description", "window", "notice", "ping", "block", "hello", "onse", "example", "echo", "connection", "reset", "sample", "relation", "respond", "answer", "resp", "offer", "continue", "exit", "choice", "request", "version", "one", "page", "respons", "Response", "result", "vector", "sequence", "line", "command", "entry", "print", "hash", "status", "python", "value", "reply", "zero", "network", "query", "data", "success", "format", "res", "remember", "question"], "parentdir": ["parentd", "parentfolder", "parentdirect", "rootfolder", "fatdirect", "masterDir", "Parentdir", "Parentfile", "masterfile", "parentdirectory", " parentfile", "masterdirectory", "fatd", "parentfile", "Parentfolder", " parentfolder", "rootdirectory", "parentDir", " parentDir", "fatdirectory", " parentd", "Parentdirectory", "rootdirect", "masterdir", "fatdir", " parentdirectory", "rootd", "ParentDir", "rootdir", "rootDir", " parentdirect"]}}
{"id1": "9081749", "id2": "1097147", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["cryption", "Encress", "Encrypted", "comprypt", "encress", "Encryption", "crypted", "cress", "encryption", "Encrypt", "compress", "encrypted", "comprypted", "crypt", "compryption"], "password": ["path", "message", "expression", "text", "description", "prefix", "phrase", "hello", "user", "database", "attribute", "account", "secret", "address", "picture", "p", "token", "wd", "reset", "default", "Password", "past", "total", "email", "confirmed", "pass", "request", "PASS", "key", "name", "sword", "shadow", "username", "command", "string", "source", "input", "padding", "value", "secure", "comment", "chain", "wordpress", "push", "word", "pattern"], "encryptType": ["encrypttype", "encjectTYPE", "encryptionType", "escryptionTy", "encryptionTy", "encryptionClass", "encjectClass", "escryptTy", "ethjectTYPE", "ethrypttype", "ethryptClass", "encreatype", "encryptClass", "escryptionype", "encreatTy", "encreatStyle", "encribeStyle", "escryptType", "escryptionStyle", "escryptionType", "escryptype", "encryptionype", "encryptiontype", "ethryptType", "ethjectType", "encryptionStyle", "encryptTYPE", "encribeType", "encveyTYPE", "encryptype", "encreatType", "encjectType", "encjecttype", "encribeTy", "encribeype", "ethjectClass", "encveyType", "ethjecttype", "encveyClass", "encveytype", "encryptStyle", "encryptionTYPE", "escryptStyle", "encryptTy", "ethryptTYPE"], "md": ["dr", "ms", "add", "nd", "pdf", "sd", "mc", "bd", "od", "me", "metadata", "ct", "ad", "del", "MD", "grad", "der", "cd", "ds", "dir", "mm", "dm", "mt", "ind", "down", "red", "rd", "sm", "dh", "nt", "det", "ld", "dd", "d", "mb", " Md", "obj", "mk", "mod", " MD", "pd", "m", "df", "di", "mn", "mand", "cmd", "man", "hd", "de"], "hash": ["style", "rh", "mask", "html", "window", "block", "replace", "Hash", "hz", "hello", "host", "score", "shift", "how", "sort", "has", "filter", "address", "sha", "ashes", "h", "sample", "test", "oh", "map", "total", "length", "square", "all", "hex", "where", "esh", "box", "sh", "number", "mac", "stock", "char", "sum", "dig", "print", "check", "here", "match", "show", "stack", "query", "search", "height", "array", "handle", "her", "color", "cache", "ash"], "hexString": ["pexService", "hexStatement", "exString", "hashStr", "pexList", "hashArray", " hexstring", "exList", " Hexstring", "xfStatement", "exArray", "hexstring", " HexResult", "octStatement", "octArray", "xfArray", "pexArray", "exService", " hexStr", " hexList", "exBuffer", " HexStr", "jsonBuffer", "hexList", "hashString", " hexArray", "pexString", "exstring", "hexBuffer", "exStatement", "hexService", "hexStr", " hexResult", "exResult", "jsonStr", "xfstring", " hexService", "hexArray", "hashBuffer", "exStr", "octstring", "octString", "xfString", "hexResult", "jsonString", " HexString", "jsonArray"], "i": ["multi", "list", "json", "im", "x", "j", "n", "phi", "it", "init", "my", "ai", "a", "is", "ic", "ski", "ui", "ie", "me", "major", "iu", "id", "y", "io", "ci", "mi", "gu", "ki", "ex", "uri", "qi", "ii", "v", "gi", "e", "this", "ti", "ji", "bi", "index", "si", "I", "u", "ei", "gravity", "set", "m", "point", "xi", "cli", "iq", "ami", "di", "sim", "pi", "info", "exp", "in", "ip", "li", "oi", "c", "\u0438", "ix"]}}
{"id1": "22410173", "id2": "10795866", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferStream", "cpFile", " cpfile", " cpStream", "cpfile", " cpFiles", "transferFile", "transferFiles", "copyStream", "cpStream", "cpFiles", "copyFiles", "copyfile", " cpFile", "transferfile"], "source": ["style", "site", "init", "template", "space", "se", "SOURCE", "so", "me", "seed", "ource", "local", "sample", "ce", "scene", "from", "subject", "resource", "spec", "Source", "scope", "parent", "src", "original", "service", "base", "input", "copy", "iter", "file", "sp", "target", "query", "search", "s", "origin", "start"], "dest": ["lit", "deg", "est", "st", "orig", "it", "pub", "img", "des", "tmp", "del", "master", "dir", "test", "desc", "crit", "loc", "tom", "dist", "src", "null", "home", "d", "nw", "pot", "good", "cont", "Dest", "them", "trans", "that", "nom", "exp", "target", "sp", "search", "origin", "usr", "temp", "rest", "way", "de"], "in": ["ch", "IN", "on", "din", "gin", "con", " IN", "or", "internal", "init", "ln", "it", "n", "rin", "ai", "is", "ini", "vin", "and", "sin", "ca", "ain", "can", "pin", "read", "local", "en", "inc", "from", "mi", "re", "ind", "ci", "al", "ins", "client", "win", "ma", "up", "ar", "bin", "all", "inner", "doc", "isin", "l", "In", "net", "an", "conn", "input", "m", "iter", "i", "co", "inn", "r", "inside", " input", "inf", "cin"], "out": ["output", "ch", "cos", "on", "ion", "con", "n", "it", "ent", "Out", "dis", "user", "not", "rem", "can", "o", "aos", "to", "os", "en", "io", "OU", "note", "conv", "ex", "outs", "t", "channel", "client", "nl", "up", "ac", "v", "ou", "nt", "at", "write", "na", "null", "inner", "ns", "w", "sum", "obj", "net", "un", "conn", "OUT", "gt", "ne", "again", "cn", "log", "oss", "chain", "ot", "co", "off", "cmd", "outer"]}}
{"id1": "8490710", "id2": "3767903", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"actualizar": [" actualiser", " actualizeAR", " actualizAR", " actualizaAR", " actualizaar", " actualiziar", "ualizAR", " actualizer", " actualizeer", " actualizeiar", " actualisAR", " actualisiar", "ualizaiar", " actualizaiar", "ualizer", "ualizaer", "ualizaAR", " actualizear", " actualizaer", "ualizar", "ualiziar", " actualisar", "ualizaar"], "ClassNotFoundException": ["ClassNotfoundException", "ClassNotfoundError", "ClassNotPresentError", "ClassNotFoundError", "ClassNotPresentException"], "Exception": ["Instance", "T", "Connection", "Event", "None", "Example", "Message", "Handler", "File", "Time", "Exc", "Transaction", "Application", "Configuration", "E", " exception", "Un", "Class", "Status", "Index", "Warning", "Exit", "Throw", "I", "EX", "Response", "Type", "Null", "Ex", "End", "ION", "Operation", "ception", "Context", "Option", "Interface", "Error", "Result"], "conn": ["ch", "nc", "session", "connect", "Con", "db", "Connection", "con", "close", "init", "n", "config", "ln", "org", "open", "mc", "sys", "gate", "connection", "ont", "ct", "pg", "socket", "sc", "sql", "pool", "pen", "enc", "Connect", "ens", "en", "ws", "rc", "mt", "pas", "client", "yes", "rs", "js", "nt", "ns", "ks", "ec", "cp", "comm", "cb", " con", "exec", "obj", "yn", "ctx", "cn", "cc", "ann", "ctrl", "oss", "die", "cert", "jp", "cmd", "act", "conf", "Conn", "c"], "ms": ["Ms", "ims", "mos", "pm", "vs", "cus", "mes", "posts", "is", "mc", "sys", "uts", "ml", "bs", "inv", "ws", "qs", "ants", "os", "mm", "mi", "mt", "cms", "cs", "mx", "ys", "ces", "ma", "sm", "ins", "ps", "rs", "mys", "xs", "js", "eds", "ns", "mic", "ks", "terms", "ats", "mill", "mp", "fs", "md", "mod", "MS", "ems", "m", "uns", "mn", "arms", "s", "ents", "eps", "ocks", "pers", "res", "ts", "windows", "ies"], "fechaSystem": ["fechaeSys", "fochtaSTEM", "fochaSystem", "fechaeSTEM", "fetaSys", "fechiSystem", "fechoSTEM", "fechaeSystem", "fetisystem", "fechoaSystem", "fetaeSystem", "feshoSystem", "fechasystem", "fechlaSystem", "feshaServer", "fechiSys", "fetaSystem", "fechaSys", "fechtaServer", "fechtaSystem", "fechaServer", "fechaSTEM", "fochtaSystem", "fochaServer", "fechoasystem", "feshosystem", "fechisystem", "fetiSystem", "fechlasystem", "fechaesystem", "feshoServer", "fetasystem", "fechaeServer", "fetiSys", "fetaesystem", "fechoaSys", "fechlaSys", "fochtaServer", "fechoServer", "fechoSystem", "feshasystem", "fochaSTEM", "fetaeSys", "fechoSys", "fechoaServer", "fechtaSTEM", "feshaSystem", "fechosystem"], "aaaammdd": ["aaaammm", "aaaamldd", "aammdd", "aammd", "aaaaumdd", "aaammd", "aaammmd", "aaaamdd", "aaammds", "aaaammmm", "aaaammd", "aammmd", "aaaaammd", "aaaaammdd", "aaammdd", "aaaammmd", "aaaamlmm", "aaammmm", "aaaamd", "aammds", "aaaaumd", "aaaaamdd", "aaaamds", "aaaaummd", "aaaammds", "aaaaamd", "aaaaammm", "aaaaammmm", "aaaamld", "aaaaumds"], "fzafsis": ["fzeajsis", "fzeafses", "fzafesi", "fzamsis", "fzajses", "fzamsi", "fzajesi", "fzeajsi", "fzeafsi", "fzahses", "fzamesi", "fzahesi", "fzeafsis", "fzeafesi", "fzamses", "fzahsi", "fzajsi", "fzeajses", "fzafses", "fzeajesi", "fzafsi", "fzajsis"], "hhmmss": ["hhmmms", "hhmmmss", "hhmmess", "hhMMms", "hhMMse", "hhmmse", "hmmmse", "hhmbs", "HHmmss", "hhmmps", "hmmms", "hhmbess", "hhmmmess", "HHMMs", "hmmbs", "HHMMps", "hmmbess", "HHmms", "hhmmmse", "hhmmmps", "hhmbss", "hhMMss", "hhmbse", "hhmmmms", "hhMMps", "HHMMss", "hhms", "hhmms", "HHmmms", "hmmbss", "hhmss", "hhmps", "HHmmps", "HHMMms", "hmmbse", "hhMMs", "hhMMess", "hmmmess", "hmmmss"], "sss": ["essjs", "issl", "isses", "esss", "ssn", "ossjs", "ssjs", "isss", " ssjs", "ssss", " ssss", "essss", "rssss", "rssl", "ssl", "rsss", "osss", "essn", "essl", "ossn", "sses", "ossss", " ssn", "esses", "rsses", "issss"], "ss": ["SS", "ius", "rss", "sl", "se", "pps", "sd", "tt", "sys", "su", "bs", "sql", "ds", "hess", "stats", "ws", "iss", "ses", "hs", "css", "ys", "cs", "ssl", "lower", "pse", "ps", "rs", "styles", "js", "pass", "ns", "less", "\u00df", "str", "sh", "xx", "si", "ress", "ess", "txt", "good", "string", "tx", "pres", "ass", "sb", "oss", "https", "sv", "s", "tz", "ts", "sf", "sq"], "fzahsis": ["fizahorus", "fzaqsis", "fzaqsi", "fzaqorus", "fzabsis", "fzahses", "fzaforus", "fizahsis", "fizafses", "fizafsis", "fizafsi", "fzaqses", "fizaforus", "fzahsi", "fizahsi", "fizahses", "fzafses", "fzaborus", "fzahorus", "fzabses", "fzafsi", "fzabsi"], "afectados": ["afelectados", "affettados", "afectionarians", "afectionados", "affecturated", "afECTado", "affectado", "afECTurated", "affECTarians", "afettados", "affECTado", "afitectarians", "afettadas", "affectators", "afittulas", "afitecturated", "afitectado", "affECTados", "affectados", "afectadas", "afettators", "afelectulas", "afECTados", "afecturated", "afelectators", "afectulas", "affectarians", "afECTarians", "affECTurated", "affectulas", "afectionado", "afittados", "afectado", "afectators", "afitectados", "affettators", "afectarians", "afectionurated", "affettulas", "afittators", "afittadas", "afettulas", "affettadas", "affectadas", "afelectadas"]}}
{"id1": "5977352", "id2": "17874479", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "label": 0, "substitutes": {"copyFile": ["cpFile", " copyFiles", " cpfile", " copyFolder", "cpfile", "cpFolder", " cpFiles", " cpFolder", "cpFiles", "copyFiles", "copyFolder", " copyfile", "copyfile", " cpFile"], "src": ["ser", "st", "orig", "init", "SOURCE", "img", "pkg", "sys", "via", "sc", "rel", "rc", "from", "ins", "loc", "Source", "rs", "rest", "req", "ctr", "sec", "sit", "cont", "sr", "source", "input", "rl", "ipl", "sb", "inst", "start", "usr", "sf", "sq", "cur"], "dest": ["lit", "self", "est", "st", "orig", "tmp", "del", "master", "dat", "opt", "cat", "end", "coord", "test", "desc", "dir", "loc", "th", "spec", "etc", "foreign", "parent", "nt", "comp", "tom", "dist", "null", "name", "cp", "nw", "none", "good", "txt", "mk", "Dest", "result", "sit", "cont", "tif", "them", "source", "trans", "gt", "nom", "port", "copy", "decl", "sp", "target", "comb", "origin", " dst", "usr", "temp", "rest", "de"], "bufSize": ["ufNum", "bcSIZE", "bcSize", "fontSIZE", "bcLen", "bufNum", "bcNum", " bufferSize", "ufLen", " bufferSIZE", "ufSIZE", "bufLen", "ufSize", "fontSize", " bufNum", " bufferNum", "fontNum", " bufLen", "bufSIZE", " bufSIZE"], "force": ["close", "replace", "auto", "forces", "kill", "apply", "draw", "f", "send", "reset", "ce", "frame", "default", "use", "allow", "enable", "require", "always", "flag", "write", "rule", "error", "stall", "quote", "only", "forcing", "fast", " Force", "print", "command", "fill", "check", "Force", "base", "form", "remote", "forced", "co", "safe", "cmd", "forge", "raise"], "buffer": ["message", "Buffer", "binary", "text", "history", "shape", "window", "block", "phrase", "buf", "template", "attribute", "variable", "sample", "row", "queue", "frame", "total", "buff", "length", "library", "tree", "view", "number", "quote", "sequence", "print", "command", "batch", "base", "limit", "mem", "device", "table", "comment", "stack", "document", "display", "memory", "paste", "word", "temp", "cache"], "read": ["load", "text", "connect", "im", "shape", "add", "bind", "hello", "valid", "open", "Read", "hold", "feed", "count", "send", "q", "raw", "size", "scan", "row", "end", "ind", "give", "t", "allow", "READ", "length", "run", "request", "write", "pass", " Read", "req", "str", "next", "readable", "reader", "reading", "index", "need", "get", "w", "stream", "before", "pe", "print", "fill", "check", "input", "set", "record", "wait", "iter", "parse", "range", "i", "through", "find", "query", "height", "start", "r", "push", "word", "reads", "len"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "internal", "or", "init", "ln", "n", "it", "rin", "ini", "is", "ie", "ic", "sin", "ain", "o", "local", "en", "inc", "mm", "mi", "irm", "ind", "from", "al", "ins", "t", "ma", "ar", "up", "bin", "all", "inner", "doc", "get", "isin", "l", "In", "include", "check", "input", "source", "m", "iter", "cn", "i", "co", "info", "inn", "inside", "inf", "cin"], "out": ["output", "ch", "cos", "list", "on", "mit", "con", "or", "n", "ln", "Out", "it", "ent", "not", "sys", "b", "flush", "can", "o", "aos", "to", "os", "end", "io", "ex", "conv", "t", "op", "client", "outs", "up", "v", "ou", "nt", "oe", "at", "write", "g", "all", "ns", "writer", "inner", "one", "l", "sum", "obj", "net", "om", "conn", "OUT", "gt", "ne", "cn", "again", "file", "oss", "br", "ot", "co", "cmd", "outer", "cache"]}}
{"id1": "22431487", "id2": "12242903", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 0, "substitutes": {"doPost": [" doPOST", "internalPOST", " doQuery", "DoPOST", "doPOST", "DoPost", " doGet", "DoGet", "DoQuery", "internalQuery", "internalGet", "doGet", "internalPost", "doQuery"], "URL": ["API", "IN", "Path", "PATH", "Location", "REF", "SOURCE", "RL", "SSL", "EL", "Url", "Address", "PORT", "CL", "UL", "LL", "NAME", "DL", "STR", "RAW", "URI", "AT", "OUT", "FILE", "PUT", "GET", "HTML", "Name", "TL", "SR", "UR", "HTTP", "METHOD", "url", "L", "IL", "ID"], "params": ["months", "json", "words", "properties", "config", "pps", "posts", "ops", "news", "ports", "times", "ams", "sql", "p", "stats", "lines", "forms", "pages", "mm", "amps", "AMS", "pins", "packages", "items", "ps", "param", "par", "styles", "rs", "changes", "actions", "photos", "settings", "tags", "marks", "Par", "terms", "points", "keys", "values", "Parameters", "parts", "details", "batch", "fields", "vals", "requires", "names", "idents", "options", "phys", "members"], "util": ["http", "eu", "cu", "Ut", "wal", "ui", "lu", "um", "ul", "tu", "iu", "usage", "api", "install", "ool", "help", "conv", "security", "uh", "ils", "etc", "ility", "tree", "nu", "hu", "fun", "utils", "rot", "u", "lib", "form", "utf", "hog", "mu", "fu", "info", "format", "url", "modern", "ut", "til", "hum", "il"], "uri": ["path", "http", "sky", "location", "term", "prefix", "phi", "uni", "ri", "msg", "link", "ui", "ur", "address", "api", "wiki", "subject", "client", "resource", " URI", "ref", "uu", "this", "course", "nu", "du", "unit", "service", "uid", "URI", "u", "quote", "directory", "base", "source", "domain", "based", "range", "pi", "url", "host"], "httpclient": [" httpconnection", "httpce", "httpconnection", "hclient", "Httpclient", "httpsClient", "hce", "httpnet", "Httpce", "Httpnet", "HttpClient", "hClient", " httpserver", "Httpserver", " httpnet", "httpserver", "hserver", " httpce", "httpsconnection", "httpClient", " httpClient", "httpsnet", "Httpconnection", "httpsclient"], "postMethod": ["handleMethod", "postRequest", "handleRequest", "Postmethod", "postField", "PostOperation", "preOperation", "PostRequest", " postClient", "pubRequest", "pubMETHOD", "putMethod", "putClient", "httpOperation", "preMETHOD", "httpField", " postMETHOD", "handleMETHOD", "PostMETHOD", "httpMethod", "putRequest", "preRequest", "pubOperation", "putField", "pubMethod", "PostMethod", "putMETHOD", "PostField", "postmethod", "handleClient", "httpmethod", "putOperation", " postRequest", "putmethod", "postOperation", "postClient", "postMETHOD", "preMethod"], "paramString": ["paramBuffer", "paramArray", "paramFile", "paramUnit", "argString", "postStr", " paramList", "ParamStr", "ParamArray", "permByte", " paramChain", "permBuffer", "processString", "attributeByte", " paramSet", "paramsstring", "paramstring", " paramStr", "termFile", "paramSet", "pstring", "paramNumber", "ParamBuffer", "aramBuffer", "paramByte", " paramFile", "postShort", "permString", "permNumber", "permFile", "termNumber", "aramShort", "ParamList", "paramsList", " paramNumber", "ParamShort", "paramList", " paramUnit", "attributeString", "attributeBuffer", "aramString", "postBuffer", "termString", "pStr", "processstring", "pSet", "paramsString", "argstring", "postString", "ParamUnit", "paramsStr", "termChain", "attributeArray", " paramstring", "permChain", "ParamByte", "pString", "paramsUnit", "paramChain", "ParamString", "paramShort", "aramStr", "paramsSet", "permArray", "paramStr"], "i": ["ims", "it", "ic", "iu", "ql", "ind", "qi", "t", "gi", "ori", "ij", "li", "oi", "or", "j", "my", "init", "a", "ini", "is", "ui", "f", "ia", "q", "o", "fi", "slice", "iv", "e", "il", "hi", "ti", "ji", "bi", "us", "ami", "chain", "sim", "ip", "multi", "im", "ie", "me", "id", "ci", "er", "ii", "uu", "index", "d", "u", "ei", "m", "xi", "pi", "eu", "ms", "x", "phi", "ai", "ski", "b", "p", "y", "io", "mi", "gu", "v", "key", "si", "I", "di", "info", "in", "c", "ix"], "xx": ["x", " XX", "hz", "kk", "fy", "ang", "ck", "XX", "xy", "y", "enc", "zz", "XXXX", "aaa", "xs", "bu", "pp", "xxxxxxxx", "kw", "xxxx", "hex", "xxx", "ous", "yy", "fx", "ess", "txt", "von", "REDACTED", "smith", "mk", "XXX", "yk", "xi", "ux", "foo", "fw", "zzy", "ng", "wx"], "httpResponse": ["HttpRes", " httpRes", "HttpResponse", "consoleResponse", "consoleAnswer", "httpResp", "ttpResponse", "ttpresponse", " httpEntity", "httpsClient", "httpsResponse", "ttpResp", "ttpEntity", "httpAnswer", "consoleEntity", "httpsRes", "Httpresponse", "consoleresponse", "httpsresponse", "httpresponse", "httpClient", " httpResp", " httpClient", "httpEntity", "httpRes", "ttpAnswer", " httpresponse", "HttpResp", "ttpClient", " httpAnswer", "ttpRes"], "strResult": ["STRResult", "STRRest", "strRest", " strRest", "stringresult", "STRNow", "STRResults", "txtresult", "StrNow", " strResults", "Strresult", "stringRes", "StrRes", "strresult", "STRresult", "StrResult", "stringResult", " strresult", " strRes", "txtNow", "strNow", "txtResult", "stringResults", "txtResults", "txtRes", "STRRes", "txtRest", "StrResults", "strRes", "strResults"]}}
{"id1": "9550506", "id2": "10391753", "code1": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"cookieString": [" challengeBytes", "cookieHash", " cryptStr", " cookieStr", " cryptBytes", " cookieByte", " cookieBytes", "cookieBytes", " cookieHash", " cryptByte", " challengeHash", "cookieByte", " challengeStr", "cookieStr", " cryptHash", " challengeByte"], "url": ["path", "http", "mail", "ls", "addr", "sl", "ur", "Url", "ul", "address", "URL", "api", "util", "ssl", "uri", "dl", "loc", "el", "browser", "gl", "home", "mount", "ll", "get", "l", "www", "remote", "lr", "file", "domain", "log", "web", "https", "host", "hl"], "ip": ["path", "http", "password", "addr", "chip", "prefix", "arp", "pkg", "ep", "address", "et", "id", "p", "api", "uri", "loc", "client", "email", "IP", "iv", "name", "ips", "cp", "mac", "net", "tip", "port", "domain", "secure", "skip", "i", "app", "sp", "origin", "host", "zip"], "md": [" dd", "dr", " cmd", "pm", "ms", "nd", "sd", "mc", "bd", "od", "metadata", "del", "MD", "sha", "hm", "grad", "der", "cd", "mg", "met", "mm", "dm", "mt", "ind", "ke", "red", " ms", "ma", "sm", "dh", "nt", "det", "ld", "td", " mt", "dd", "d", " Md", " mc", " mm", " mo", " del", "mk", " m", "managed", " sm", "mp", "mem", " MD", "pd", "def", "m", "df", "mn", "cmd", " ma", "hd", "ng", " sd"], "hash": ["message", "rh", "mask", "html", "password", "Hash", "hed", "has", "sq", "sha", "h", "sample", "checked", "uh", "total", "tag", "ref", "ho", "this", "key", "magic", "sh", "index", "mac", "shadow", "sum", "amd", "check", "sam", "bh", "her", "hd", "kernel", "cache", "ash"]}}
{"id1": "5632808", "id2": "8490297", "code1": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"respondGet": [" respondDelete", "respondGET", " onget", " onDelete", " onGet", " respondget", " respondGET", "partialGet", "respondget", "respondDelete", "partialget", "partialGET", " onGET", "partialDelete"], "resp": ["vp", "wr", " res", "http", "gr", "proc", "html", "Resp", "vol", "cond", "wy", "rep", "dis", "exc", "ret", "msg", "pkg", "news", "sys", "org", "response", "rec", "bp", "rem", "p", "rel", "inv", "report", "re", "respond", "conv", "pos", "fr", "RES", "esp", "serv", "summary", "sol", "req", "cb", "comm", "obj", "Res", "err", "Response", "respons", "conn", "fs", "def", "ctx", "status", "sp", "exp", "https", "res", "cmd", "soc", "exec", "wx"], "os": ["out", "cos", "nos", "mos", "ms", "es", "OS", "asis", "rss", "oos", "oin", "is", "des", "sys", "ows", "bos", "bis", "osi", "bs", "ss", "ds", "dos", "o", "aos", "uds", "io", "css", "ys", "cs", "pos", "op", "obs", "ps", "ox", "oS", "js", "oa", "ns", "aus", "ks", "Os", "fs", "ols", "los", "us", "ose", "oss", "oes", "ios", "ot", "ros", "oses", "res", "ts"]}}
{"id1": "23008590", "id2": "11546108", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["runner", "block", "UN", "loop", "Run", "sample", " Run", "execute", "test", "call", "running", "background", "process", "unit", "thread", "go", "un", "submit", "status", "render", "launch", "func", "web", "work", "start", "dial", "exec"], "url": ["path", "http", "mail", "ls", "location", "sl", "hub", "ret", "bel", "link", "ur", "b", "Url", "ul", "address", "URL", "p", "rel", "pl", "ssl", "uri", "dl", "loc", "resource", "email", "browser", "gl", "ref", "name", "mount", "xml", "hl", "ll", "external", "str", "l", "page", "print", "base", "remote", "lr", "file", "web", "https", "r", "host", "github", "il"], "is": ["ists", "ais", "ms", "es", "isc", "ls", "im", "iso", "ris", "ri", "ic", "sys", "ui", "isl", "bis", "bs", "isa", "as", "its", "iss", "os", "ins", "ar", "rs", "serv", "il", "ib", "Is", "isin", "fs", "ir", "iris", "iter", "us", "isi", "i", "sb", "oss", "ios", "info", "sis", "s", "in", "ip", "lis", "IS"], "writer": ["fn", "runner", "message", "output", "builder", "word", "node", "window", "counter", "caster", "worker", "processor", "white", "wrote", "loader", "riter", "writers", "variable", "console", "writing", "row", "maker", "er", "client", "liner", "server", "wright", "write", "key", "null", "wire", "written", "handler", "service", "player", "page", "oder", "line", "ner", "entry", "string", "print", "Writer", "Reader", "layer", "table", "file", "driver", "document", "data", "format", "out", "outer", "storage", "editor", "order", "network"], "buffer": ["message", "Buffer", "binary", "function", "window", "password", "block", "phrase", "buf", "template", "available", "bar", "seed", "variable", "character", "reset", "sample", "row", "frame", "note", "total", "buff", "length", "library", "number", "char", "sequence", "print", "command", "batch", "string", "line", "source", "padding", "base", "table", "value", "comment", "document", "display", "memory", "append", "paste", "column", "word", "cache"], "reader": ["runner", "ser", "dr", "builder", "per", "rar", "iper", "handle", "rx", "loader", "parser", "read", "row", "iterator", "io", "er", "resource", "inner", "handler", "stream", "rot", "mr", "oder", "Reader", "ner", "iter", "rl", "file", "driver", "ro", "r", "her", "ener"], "n": ["fn", "nc", "nan", "on", "j", "ln", "nb", "p", "no", "y", "o", "en", "num", "note", "nr", "nl", "gn", "v", "nt", "syn", "e", "na", "ns", "nor", "nu", "d", "number", "w", "l", "r", "k", "N", "an", "nn", "sn", "yn", "m", "cn", "ne", "max", "i", "out", "ren", "c", "len"], "updatePage": ["showClass", "currentPage", "uploadPages", "indexTime", "updateNow", "downloadPath", "updatedPage", "UpdatePages", "addPage", "uploadLine", " updateClass", "updatepage", "UPDATEPage", "updatedFile", "createPage", "downloadFile", "updateClass", " updatePages", "indexPoint", "UpdatePage", "updatedLink", "UPDATEPoint", "updatePath", "updatedPath", "uploadPage", "updateFile", "uploadLink", "showPage", "indexLog", "makePage", "uploadFile", "uploadPath", "indexPage", "updatePages", " updateSection", "showLine", "showSection", "downloadLink", "makeClass", "updateSection", "updateTime", "currentURL", "makeLine", "downloadPage", "makeSection", " updateURL", "updateLog", " updateNow", "updatedLine", " updatepage", "addPoint", "updatedURL", "updateLine", "updateURL", "UpdateLink", "updatedTime", "currentpage", "downloadNow", "updatedNow", "UPDATELog", " updateLine", "downloadLine", "updatedpage", "createTime", "updateLink", " updateLink", "addLog", "updatePoint"], "pos1": ["Pos4", "po4", "position3", "pos0", "position4", "po2", "position81", "poseOne", " posOne", "Pos1", "posOne", "Pos2", "position2", "po1", " pos81", "po3", "position0", "pose1", "pose0", "Pos3", "pos81", "pose81", "position1", " pos0", "positionOne"], "pos2": ["Pos4", "po4", "pos02", "pro2", "prop3", "po2", "prop4", " pos6", "pro02", "Pos2", "pos6", "po3", "pro3", "pro4", "prop6", "prop2", "Pos3", "Pos02", " pos02", "po6"], "pos3": ["Pos4", "point03", "po4", "position3", "point3", "posIII", "pointIII", "position4", "PosIII", "po2", "indexthirds", "Pos1", "posthirds", "Pos2", "Pos03", "index03", "position2", "po1", "po3", "pointthirds", "Pos3", "indexIII", "index3", "Posthirds", "position1", "pos03"], "pos4": ["Pos4", " posr", "po4", "pos24", "position24", "position4", "po2", "positionFour", "opr", "Pos1", "opFour", "posr", "Pos2", "po1", "op4", "po3", "positionr", "Pos3", "posFour", " posFour", "op24", " pos24"], "currentVersion": ["currentVer", " currentPage", "CurrentVer", "newPage", "currentlyVer", "newVers", "recentVersion", " currentFilter", "CurrentVersion", "updateVers", "currentFilter", "currentPage", "updateVersion", "updateFilter", "newVersion", "currentUpdate", "CurrentKey", "recentPage", "recentUpdate", "updateKey", "currentlyVersion", "CurrentFilter", "currentlyPage", "recentVer", "currentVers", " currentUpdate", "currentlyVers", "newUpdate", "updateVer", " currentVer", "newVer", "currentKey", " currentKey"], "downloadURL": ["downloadLink", " downloadLink", " downloadUrl", " downloadPDF", "updatePDF", "updateLink", "updateURL", "updateUrl", "downloadPDF", "DownloadLink", "downloadUrl", "DownloadUrl", "DownloadURL", "DownloadPDF"]}}
{"id1": "14450108", "id2": "13368520", "code1": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"connect": ["con", "close", "ping", "bind", "init", "config", "sync", "open", "build", "connection", "ssh", "pen", "Connect", "read", "create", "download", "reset", "client", "initial", "login", "setup", "write", "process", "connected", "conn", "remote", "set", "select", "log", "secure", "construct", "join", "establish", "attach", "dial", "network"], "ftpe": ["oftse", "attpa", "attp", "iftcle", "iftple", "iftpe", "etpe", "etse", "aftpa", "iftpa", "aptpe", "iftse", " ftpy", "ftcle", "etp", "aftpy", "aftcle", "ftpy", "oftme", " ftme", "aftse", "ftme", "ftse", "oftple", "ftple", "etpy", "attpe", "oftpe", "aptp", "aptse", "aftme", "aftp", " ftple", "aftple", "aftpe", " ftse", "aptcle", "iftp", "attple", "ftpa"], "ftp": ["threadtp", "ftping", "http", " ftcp", "aftpp", "ottt", "ftpp", "ttr", " ftc", " ftd", "aftpi", " fttp", "cttp", "aftt", " ftP", "ftk", "oftp", "aftr", " ftt", "rotr", "ottp", " ftpn", "aftpn", "fftp", "ftP", " ftport", "iftpe", "ttpn", "ttport", "ftpat", "afttp", "httpe", "ttpe", " ftpi", "ftcp", "ftpn", "topr", "oftt", "raftphp", "iftcp", "rotk", "ftpi", " fty", "fabr", "rotpe", "toppe", "ffcp", "ttc", "ftr", "ctcp", "ottphp", "ffp", "ottpat", "ttp", "aftk", "ffr", " ftr", "ftt", " ftpp", "httr", "fty", "aftping", "aftP", "threadpe", "iftr", "aftcp", "ftd", "ifttp", "ffping", "fabp", "oftping", "fttp", "oftr", "threadp", "ifty", "fabc", "afty", "ctp", "iftk", "topp", "iftd", "ftport", "ftc", "raftp", "fft", "fabpi", "htttp", "iftt", "aftport", "aftd", "aftpat", "aftc", "ctr", "toptp", "iftpp", "rotp", "ttP", "threadc", "ftphp", "raftt", "aftphp", "aftp", "aftpe", "raftpat", "iftp", "ffc"], "path": ["Path", "prefix", "PATH", "ath", "pkg", "root", "p", "wd", "prop", "dir", "filename", "ref", "name", "str", "cp", "dest", "directory", "copy", "port", "chain", "cert", "full", "context", "url", "cmd", "host", "c", "pattern"], "currentDir": ["activeDir", "reportedPos", "tempDir", "activePath", "reportedDir", "CurrentPos", " currentPath", "currentPos", " currentDirectory", " currentFile", "reportedDIR", "reportedDirectory", "tempDirectory", "currentDIR", "activeFile", "tempPath", " currentPos", "CurrentDir", "CurrentDirectory", "tempDIR", "activePos", "reportedFile", "currentPath", "activeDIR", "currentFile", "currentDirectory", "activeDirectory", " currentDIR"], "reply": ["ch", "message", "reason", "timeout", "notice", "close", "replace", "time", "sync", "nb", "ret", "response", "onse", "echo", "shell", "proxy", "send", "vote", "state", "transfer", "reset", " Reply", "re", "mi", "answer", "respond", "nr", "back", "continue", "call", "flag", "code", "pty", "write", "trust", "error", "next", "post", "Reply", "err", "result", "record", "print", "consider", "status", "pop", "zero", "match", "info", "query", "repl", "report", "ply"]}}
{"id1": "822452", "id2": "20924119", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "23452437", "id2": "19134229", "code1": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"internalCopy": ["internalSave", " doSave", " internalTransfer", " doCopy", " deepCop", " deepCopy", " deepTransfer", "internalTransfer", " internalSave", " doTransfer", " deepSave", " internalCop", "internalCop", " doCop"], "fSource": ["fmsource", "dataSourceFile", "rfSOURCE", "rfStar", "vTarget", " fSOURCE", "fileSourceFile", "pSource", "fStar", "fmCopy", "vSource", "fSourceFile", "gTarget", "vSOURCE", "vsource", "tTarget", "tSOURCE", "fmSource", "oSourceFile", "dataStar", "rfSourceFile", "rfSource", "pSourceFile", "fTarget", " fSourceFile", "oSource", "fileStar", "oSOURCE", "oTarget", "pCopy", "fmSourceFile", "tSourceFile", "fsource", "gsource", " fCopy", " fTarget", "dataSOURCE", "fileSOURCE", "fileSource", "gSource", "gSOURCE", "fCopy", "fSOURCE", " fsource", "tSource", "dataSource", "psource"], "file": ["path", "output", "message", "db", "or", "ol", "template", "type", "fil", "f", "p", "h", "local", "fp", "io", "use", "File", "t", "files", "th", "resource", "filename", "spec", "le", "e", "null", "name", "w", "l", "txt", "page", "ile", "print", "FILE", "base", "source", "port", "table", "log", "chain", "info", "data", "format", "out", "image"], "o": ["onet", "bo", "output", "on", "ol", "auto", "iso", "lo", "yo", "O", "fo", "so", "et", "ob", "y", "no", "to", "os", "ome", "io", "ok", "\u00f3", "op", "oo", "v", "ox", "ho", "oe", "e", "oa", "ow", "ao", "l", "u", "obj", "go", "po", "ko", "ot", "mo", "ro", "og", "co", "ooo", "out"], "i": ["out", "im", "phi", "it", "ini", "ri", "is", "ic", "ai", "ui", "f", "bis", "iu", "io", "ci", "mi", "ki", "ii", "qi", "gi", "hi", "bi", "ib", "si", "I", "l", "u", "iter", "xi", "di", "pi", "info", "ij", "in", "ip", "li", "oi", "il"], "b": ["buffer", "B", "binary", "bf", "j", "buf", "nb", "a", "bd", "bar", "f", "bis", "body", "ob", "bs", "p", "bl", "bb", "erb", "fb", "bits", "bt", "bin", "v", "buff", "ab", "eb", "bg", "bit", "be", "bi", "pb", "bus", "mb", "gb", "blue", "l", "lib", "base", "z", "br", "bh", "sb", "rb"], "n": ["nc", "nan", "on", "missing", "j", "nb", "ln", "a", "after", "count", "no", "y", "en", "num", "t", "nl", "gn", "v", "nt", "syn", "na", "ns", "nor", "nu", "ni", "d", "ll", "number", "span", "r", "k", "l", "an", "N", "nn", "sn", "yn", "un", "ne", "m", "cn", "mn", "out", "ren", "c", "len"]}}
{"id1": "19147279", "id2": "13414771", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"actualizarDatosFinal": [" actualizarDatasBasic", " actualizarDatasFinancial", " actualizarDatosfinal", " actualizarDatosFinancial", " actualizarDatrosfinal", " actualizarDataasfinal", " actualizarDatofinal", " actualizarDatrosFinancial", " actualizarDatasFinal", " actualizarDataasFinal", " actualizarDatoBasic", " actualizarDataasBasic", " actualizarDatosBasic", " actualizarDataosfinal", " actualizarDatrosBasic", " actualizarDataosFinancial", " actualizarDatrosFinal", " actualizarDatoFinal", " actualizarDataosFinal", " actualizarDataasFinancial", " actualizarDataosBasic", " actualizarDatoFinancial", " actualizarDatasfinal"], "idJugadorDiv": ["idJuggadorDef", "idJugadorDef", "idJugadeDec", "idJugordDev", "idJugadorDev", "idJogadorDiv", "idJugadoDev", "idJogadorDev", "idJogadeDef", "idJugadorApp", "idJugadoDiv", "idJugadierDev", "idJuggadorDiv", "idJuggadoDiv", "idJogadorDef", "idJogadeDiv", "idJugadeDev", "idJugadierApp", "idJuggadoApp", "idJugadorDec", "idJuggadorDev", "idJogadorDec", "idJugordDef", "idJugordApp", "idJugadoDec", "idJuggadorApp", "idJugadeDef", "idJogadeDec", "idJugordDec", "idJugadoDef", "idJugadoApp", "idJugordDiv", "idJuggadoDef", "idJuggadoDev", "idJugadeDiv", "idJugadierDiv", "idJugadierDef", "idJogadeDev"], "idRonda": ["IdRata", "idCorondo", "idRunnerondo", "IdRonda", "idTona", "idToda", "idCoda", "idTosa", "IDDoda", "idCosa", "idConda", "idCorora", "IDDona", "idCoronda", "IDRona", "IdRora", "idDona", "idRunneronda", "IdRondo", "IDRoda", "idRora", "idRata", "idRosa", "idRondo", "idCorata", "idRunnerata", "IDRonda", "idDoda", "idDosa", "IDRosa", "idDonda", "idTonda", "idRoda", "idRunnerora", "IDDonda", "IDDosa", "idRona", "idCona"], "unjxdxr": ["unjdxxhr", "unjxddxhr", "unjxdxe", "unjxdxtr", "unjdxtxer", "unjdxtxr", "unjxdtxhr", "unjxddxer", "unjxdtxR", "unjdxxer", "unjdxtxhr", "unjdxxR", "unjxdexR", "unjxdxtR", "unjxdxdr", "unjxdXR", "unjdxxtrs", "unjxdxdR", "unjdxtxR", "unjxdxhr", "unjdxxr", "unjxddxR", "unjxdxdrs", "unjdxxtR", "unjxdXhr", "unjxdxer", "unjxdxte", "unjxdtxr", "unjdxxrs", "unjxdexe", "unjdxxte", "unjxddxr", "unjxdxde", "unjdxxe", "unjxdexr", "unjxdxrs", "unjxdXr", "unjdxxtr", "unjxdxtrs", "unjxdxR", "unjxdXer", "unjxdtxer", "unjxdexrs"], "intResult": ["INTresult", "INTRes", "intReturn", "interReturn", "intSuccess", " intReturn", "IntResults", "interResult", "IntRes", "strReturn", "INTResult", "INTReturn", "IntReturn", "strresult", "INTResults", "interRes", "IntSuccess", "intRes", "IntResult", "intResults", "strResult", " intResults", " intRes", " intresult", " intSuccess", "INTSuccess", "interResults", "intresult", "strResults"], "sql": ["fn", "expression", "spr", "db", "ls", "description", "template", "pel", "statement", "condition", "seed", "params", "ql", "q", "qs", "SQL", "pr", "dl", "serv", "setup", "settings", "sol", "script", "xml", "cp", "command", "string", "status", "select", "scl", "csv", "log", "sb", "sp", "query", "sv", "s", "what", "url", "cmd", "sq"], "connection": ["collection", "bo", "nc", "session", "connect", "ion", "db", "con", "Connection", "application", "pointer", "close", "function", "description", "open", "database", "link", "response", "statement", "condition", "reference", "socket", "pool", "platform", "character", "relation", "creator", "associated", "subject", "client", "channel", "created", "server", "current", "resource", "library", " Connection", "writer", "communication", "engine", "external", "number", "position", "connected", "directory", "conn", "command", "port", "table", "document", "context", "city", "c", "computer", "network"], "ps": ["proc", "pm", "Ps", "ping", "pps", "posts", "PS", "ports", "prep", "statement", "processor", "pg", "tp", "proxy", "socket", "p", "ds", "pa", "fp", "pr", "cs", "fps", "pos", "pt", "pse", "rs", "script", "gres", "process", "cp", "ptr", "mp", "conn", "pd", "po", "sp", "pers", "jp", "eps", "s", "res", "aps", "pp"]}}
{"id1": "11153282", "id2": "19747399", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": ["existUrl", "existingHTTP", "existsUR", "existUR", " existHTTP", "existingUR", "exitsHTTP", " existsUrl", " existUR", "exitsURL", " existsUR", "exitsUrl", "exitsUR", "existsUrl", "existHTTP", "existingUrl", " existUrl", "existURL", "existsHTTP", " existsHTTP", " existURL", "existingURL"], "urlStr": ["uriSt", "uriSpec", " urlWr", "URLStr", " urlString", "uriString", " urlSpec", "urlWr", "uriWr", "urlSpec", "UrlSt", " urlSt", "uriStr", "URLSpec", "urlString", "UrlObj", "UrlStr", "URLString", "UrlSpec", "URLWr", " urlObj", "urlSt", "urlObj", "uriObj"], "url": ["http", "ls", "abs", "sl", "arl", "org", "build", "bel", "link", "ur", "lb", "ul", "Url", "b", "arch", "URL", "p", "sur", "pl", "ssl", "uri", "dl", "loc", "nl", "this", "null", "name", "mount", "str", "ll", "l", "char", "conn", "gc", "base", "acl", "rl", "file", "log", "job", "https", "r", "il"], "con": ["fn", "ch", "nc", "proc", "cos", "connect", "Con", "on", "close", "cond", "n", "ln", "open", "user", "dial", "rec", "connection", "ain", "can", "pen", "col", "en", "num", "re", "sub", "cs", "conv", "client", "fin", "fc", "cm", "syn", "inner", "canon", "cp", "cons", "comm", "coll", "compl", "bc", "un", "conn", "cont", "cn", "CON", "ran", "ctrl", "co", "cf", "res", "com", "conf", "soc", "Conn", "c", "cur"], "responseCode": ["answerCode", " responseType", "ResponseCode", "replyMessage", " responseZone", "responseZone", "replyCode", "responseMessage", "Responsecode", "conditionType", " responseCount", "responseCount", "conditionZone", "conditionMap", "replycode", "ResponseCount", "answerMap", "replyCount", "responseMap", "answerType", " responsecode", "answerZone", "ResponseMessage", " responseMessage", "responsecode", "conditionCode", "responseType", " responseMap"]}}
{"id1": "23666973", "id2": "5299276", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openResourceInternal", "openSteamRAW", "openFileInternal", "openStreamInternal", "openFileRAW", "loadStreamRaw", "openStreamSimple", "openResourceRaw", "loadSteamSimple", "loadSteamRAW", "loadSteamInternal", "openSteamSimple", "openSteamInternal", "openResourceSimple", "loadStreamInternal", "openResourceRAW", "openStreamRAW", "openFileSimple", "loadStreamSimple", "openSteamRaw", "loadSteamRaw", "loadStreamRAW", "openFileRaw"], "filename": ["fn", "path", "nil", "message", "bf", "missing", "description", "location", "prefix", "jpg", "lua", "fil", "title", "f", "metadata", "wikipedia", "reference", "nm", "sql", "mson", "Filename", "download", "fp", "stem", "subject", "uri", "bol", "initial", "png", "length", "ename", "ame", "journal", "river", "src", "name", "original", "mpeg", "LCS", "println", "upload", "username", "txt", "sequence", "directory", "kl", "FILE", "string", "source", "java", "file", "whatever", "document", "ren", "word", "til"], "stream": ["collection", "proc", "http", "window", "sync", "instance", "peer", "present", "export", "sw", "channel", "pipe", "transform", "parent", "content", "where", "mount", "upload", "form", "set", "iter", "port", "clean", "file", "status", "trace", "list", "zip", "buffer", "sl", "then", "link", "response", "old", "row", "download", "control", "conv", "ssl", "impl", "reader", "dd", "engine", "still", "ream", "chain", "stack", "temp", "rest", "output", "valid", " Stream", "draw", "loop", "feed", "body", "pool", "local", "iterator", "resource", "Stream", "pod", "view", "get", "result", "check", "input", "table", "find", "message", "load", "history", "shape", "head", "open", "filter", "socket", "console", "read", "sample", "test", "back", "wrapper", "length", "store", "poll", "next", "event", "cont", "source", "log", "context"], "url": ["path", "http", "mail", "ls", "sl", "cal", "build", "pkg", "bel", "link", "b", "ur", "Url", "ul", "URL", "rel", "pl", "ssl", "uri", "dl", "nl", "loc", "resource", "browser", "gl", "call", "impl", "mount", "str", "mb", "ll", "fl", "external", "l", "char", "kl", "lr", "rl", "file", "job", "web", "r", "hl"], "cl": ["load", "cle", "lf", "class", "ct", "ck", "CL", "lp", "sc", "loader", "pl", "ssl", "dl", "lc", "el", "gl", "cm", "cr", "fc", "Cl", "impl", "tc", "sh", "ll", "fl", "dll", "comm", "kl", "ocl", "acl", "rl", "scl", "cc", "log", "ctrl", "decl", "ctx", "cf", "com", "hl", "c"], "cn": ["fn", "nan", "san", "nc", "ocon", "aren", "atten", "CNN", "CN", "bean", "pan", "tan", "non", "ct", "can", "dn", "bn", "ern", "crow", "css", "cv", "nic", "uan", "enn", "unc", "arn", "cm", "avan", "sen", "ns", "jc", "tun", "unn", "nn", "conn", "gc", "hn", "yn", "cdn", "wn", "tn", "osen", "rn", "cap", "csv", "mn", "oul", "cf", "gn", "pn", "cin"]}}
{"id1": "12744653", "id2": "21608109", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomGuid", "getRandomGID", "getRandGid", "getRandUid", "getRandomGid", "getRandomSecurityid", "getRandomUid", "getRandomUID", "getRandUuid", "getRandomSecurityUID", "getRandomSecurityID", "getRandomSUID", "getRandGUID", "getRandomUuid", "getRandUUID", "getRandomUUID", "getRandomSecurityuid", "getRandomSID", "getRandUID", "getRandomSuid", "getRandGID", "getRandGuid", "getRandomSid"], "secure": [" Secure", "http", "prime", "sync", "force", "strong", "ie", "sys", "nice", "secret", "weak", "pretty", "ssl", "encrypted", "security", "client", "Secure", "server", "quiet", "confirmed", "stable", "clear", "trust", "google", "protect", "service", "sec", "remote", "sr", "dirty", "status", "active", " securely", "https", "safe", "sensitive", " insecure"], "md5": [" md6", "mdle", "mn2", "MD3", " md2", "MD512", "sha3", "MDle", "mdinder", "dig4", " md512", "dig3", "md512", "sha2", "mn5", "sha5", "MD2", "mn3", "MD4", "md4", "md6", " md3", " MD3", "digle", "MD6", "mn512", "MDinder", "sha6", "md2", " mdinder", " MD2", " MD5", "MD5", "dig5", " MDinder", " md4", " mdle", "md3"], "sbValueBeforeMD5": ["sbValueBeforeMDOK", "sbValueAfterMD1", "sbValueBeforemd65", "sbValueBeforeSM5", "sbValueBeforeMS5", "sbValueBeforeND4", "sbValueAfterND2", "sbValueBeforeMP1", "sbValueBeforeSM1", "sbValueBeforeMD15", "sbValueBeforeDDFive", "sbValueBeforeSM4", "sbValueBeforeND2", "sbValueBeforeMEDOK", "sbValueBeforeMD65", "sbValueBeforeMDFound", "sbValueAfterMD65", "sbValueBeforeMS2", "sbValueBeforeAMDFound", "sbValueBeforeMP15", "sbValueAtMED5", "sbValueAtMED2", "sbValueBeforeMED2", "sbValueBeforeMS3", "sbValueBeforemd2", "sbValueBeforemd15", "sbValueBeforeMD2", "sbValueBeforeMAN2", "sbValueBeforeSM2", "sbValueBeforeMD1", "sbValueBeforeAMD5", "sbValueAfterMDFive", "sbValueAtMD5", "sbValueBeforeMD4", "sbValueAfterMD4", "sbValueBeforeNDFound", "sbValueBeforeMP2", "sbValueAtMD65", "sbValueBeforeDD5", "sbValueAfterMD2", "sbValueAfterND4", "sbValueBeforeAMD2", "sbValueBeforeMDFive", "sbValueBeforeMP5", "sbValueBeforemd5", "sbValueAtMDOK", "sbValueAfterMD5", "sbValueAfterMDFound", "sbValueBeforeMED5", "sbValueAfterND5", "sbValueBeforeMED65", "sbValueBeforeMAN3", "sbValueBeforeDD65", "sbValueBeforeMAN5", "sbValueAtMED65", "sbValueBeforeMP4", "sbValueBeforeMACFive", "sbValueBeforeMAC65", "sbValueBeforeMD3", "sbValueBeforeDD2", "sbValueAfterMD15", "sbValueBeforeND5", "sbValueAfterND1", "sbValueBeforeND1", "sbValueAtMEDOK", "sbValueBeforemdOK", "sbValueAfterMD3", "sbValueBeforeMAC5", "sbValueBeforeMAC2", "sbValueAtMD2", "sbValueBeforeAMD1"], "time": ["history", "TIME", "top", "est", "timeout", "counter", "now", "user", "hour", "times", "id", "runtime", "duration", "size", "frame", "Time", "t", "client", "etime", "current", "total", "lock", "timer", "length", "clock", "name", "tc", "estamp", "today", "ime", "rate", "tim", "date", "value", "race", "system", "work", "year", "age", "start", "ts", "ty"], "rand": ["dr", "rh", "reg", "nd", "rss", "init", "and", "rid", "seed", "roll", "rev", "id", "grad", "pick", "rc", "inv", "rad", "sample", "pid", "rd", "red", "mid", "std", "rank", "nt", "frac", "rest", "cr", "gz", "dist", "serial", "rot", "uid", "round", "rate", "sid", "quant", "hash", "gt", "did", "max", "z", "range", "random", "res", "r", "ng", "gen", "Rand"], "valueBeforeMD5": ["valueAfterND5", "valueBeforeMT5", "valueFrontMD45", "valueFrontSD45", "valueBeforeHTML45", "valueBeforeSDFive", "valueBeforeSD3", "valueAfterMD7", "valueBeforeMD3", "valueBeforeHTMLFive", "valueAfterMD2", "valueBeforeMD2", "valueBeforeMC7", "valueBeforeMDFive", "valueBeforeMTLE", "valueBeforeMCLE", "valueBeforeND7", "valueBeforeMCFive", "valueFrontMDFive", "valueAfterMDLE", "valueBeforeMC45", "valueBeforeSD45", "valueBeforeMC2", "valueBeforeND2", "valueBeforeSD5", "valueBeforeMD7", "valueBeforeND5", "valueFrontSD5", "valueBeforeMT2", "valueBeforeNDLE", "valueBeforeMT7", "valueAfterNDLE", "valueBeforeMDLE", "valueFrontMD5", "valueAfterND2", "valueBeforeMC5", "valueBeforeHTML5", "valueBeforeHTML3", "valueBeforeMD45", "valueBeforeMC3", "valueFrontSD3", "valueFrontSDFive", "valueAfterND7", "valueFrontMD3"], "array": ["collection", "buffer", "rays", "our", "expression", "binary", "instance", "a", "var", "attribute", "address", "ary", "arrow", "raw", "av", "row", "sample", "area", "feature", "map", "arr", "length", "RAY", "pair", " Array", "atomic", "angle", "ray", "sh", "share", "external", "number", "vector", "record", "Array", "batch", "angular", "hash", "archive", "range", "app", "data", "random", "audio", "trace", "storage", "image", "list", "ash"], "sb": ["ub", "bf", "db", "ls", "sl", "nb", "SB", "lb", "bp", "gs", "bis", "shell", "bps", "bs", "lp", "kb", "ob", "bsp", "ssh", "sw", "bb", "sa", "erb", "ssl", "obs", "bt", "eb", "bg", "orb", "pb", "ib", "zb", "cb", "si", "gb", "wb", "sh", "sg", "gc", "rob", "abb", "bh", "stab", "sv", "s", "sp", "umb", "soc", "sf", "sq", "rb"], "j": ["bot", "json", "jl", "it", "msg", "jack", "aj", "ct", "jj", "q", "je", "y", "kj", "h", "att", "jit", "ind", "ja", "dj", "uj", "t", "v", "js", "g", "ji", "key", "str", "jc", "index", "_", "yy", "jump", "obj", "k", "bj", "m", "J", "__", "us", "job", "z", "i", "br", "ij", "off", "jp", "oj", "jo", "ix"], "b": ["B", "bf", "db", "by", "nb", "a", "bd", "bar", "bp", "bis", "body", "bs", "y", "bound", "bb", "beta", "bu", "fb", "bt", "v", "emb", "eb", "bg", "ab", "be", "bi", "ib", "mb", "cb", "d", "gb", "u", "k", "bc", "ba", "i", "br", "rb"], "valueAfterMD5": ["valueAfterMD3", "valueBeforeMD3", "valueAfterMD2", "valueAftermd5", "valueBeforeMD2", "valueAfterMOD3", "valueAfterMOD2", "valueBeforeMD6", "valueAftermd6", "valueAfterMOD5", "valueAftermd2", "valueAftermd3", "valueAfterMOD6", "valueAfterMD6"]}}
{"id1": "19520541", "id2": "755203", "code1": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"getDirectoryListing": ["getDirectoryLning", "getDirectorylistING", "getFilelistging", "getDirectoryListList", "getDirectorylistging", "getFileListList", "getDirectoryProcessList", "getFilelisting", "getDirectorylistning", "getFilelistning", "getDirectorylistList", "getDirectorylisting", "getDirectorylistings", "getFileListings", "getDirectoryLings", "getDirectoryLging", "getDirectoryLing", "getFilelistings", "getDirectoryProcessning", "getFileListING", "getDirectoryListning", "getDirectoryListings", "getFileListing", "getFileListning", "getDirectoryListING", "getDirectoryListging", "getFilelistING", "getDirectoryProcessING", "getFilelistList", "getDirectoryProcessing", "getFileListging"], "url": ["path", "http", "mail", "html", "ls", "location", "addr", "sl", "it", "ret", "build", "bel", "link", "b", "ur", "Url", "f", "address", "q", "ml", "ob", "URL", "id", "ul", "rel", "sql", "util", "github", "pl", "ssl", "uri", "dl", "loc", "nl", "el", "server", "back", "gl", "ref", "call", "all", "this", "key", "null", "request", "str", "mount", "xml", "name", "ll", "fl", "get", "l", "u", "err", "kl", "un", "print", "base", "string", "cl", "rl", "log", "job", "domain", "web", "https", "cert", "r", "host", "hl", "il"], "CancelledOperationException": ["CancelledActionError", "CanceuledOperationException", "CancelledActionException", "CancelledRuntimeWarning", "CancelledRuntimeError", "CanceuledOperation ", "CanceuledOperationError", "CancelledOperationWarning", "CanceuledOperationWarning", "CanceuledRequest ", "CancelledRuntimeException", "CancelledRequestError", "CancelledOperationError", "CancelledActionWarning", "CancelledRequest ", "CancelledRuntime ", "CanceuledRequestWarning", "CancelledRequestException", "CancelledRequestWarning", "CanceuledRequestError", "CancelledOperation ", "CancelledAction ", "CanceuledRequestException"], "file": ["path", "buffer", "message", "db", "part", "task", "template", "class", "title", "f", "address", "body", "id", "folder", "local", "size", "dir", "fp", "use", "File", "uri", "resource", "filename", "length", "key", "null", "module", "name", "family", "page", "ile", "print", "base", "project", "string", "source", "FILE", "table", "comment", "web", "info", "data", "format", "full", "handle", "image"], "userInfo": ["userData", "usersData", "USERINFO", " userData", "usernameINFO", "verINFO", "verInfo", "UserInf", "authorInf", "authorInfo", "usernameStatus", " userStatus", "UserData", "Userinfo", "userInf", "userINFO", " userInf", "authorData", " userINFO", "USERInfo", "verInf", "usersINFO", "usersInfo", " userinfo", "verData", "usernameInfo", "UserInfo", "authorinfo", "USERStatus", "usersInf", "userStatus", "UserINFO", "userinfo"], "urlConnection": ["cmdConnector", "xmlconnection", "httpConn", "jsonconnection", "httpAction", "fileCurrent", "httpConnector", "httpConnection", " urlconnection", "userConfiguration", "httpconnection", "dbconnection", "urlLine", "urlConnect", "implConnector", "userCurrent", "httpConfiguration", " urlLine", "xmlConnection", "cmdConnect", "httpConnect", "xmlCurrent", " urlConnector", "implconnection", "xmlConnect", "fileConn", " urlAction", "jsonAction", " urlCurrent", "implLine", "cmdConnection", "dbConnector", "urlConn", "fileConnect", "urlConnector", "jsonConnection", "userConnector", "userConnection", "fileConfiguration", " urlConnect", "httpCurrent", "cmdConn", "fileConnector", "implConnection", "urlCurrent", "dbLine", "urlAction", "jsonConnect", "dbConnection", "urlconnection", "fileConnection", "urlConfiguration"], "encode": ["enableode", "Encode", "enablecode", "enpack", "enize", "enCode", "encify", "EnCode", "enode", "encpack", "enableize", "Enode", " enpack", "encCode", "enccode", " enode", "encize", "Enpack", "enableify", "enify", " enCode", " enize", " enify"], "urlStream": ["xmlstream", "inputstream", "httpstream", "xmlStreamer", " urlstream", "rowSteam", "xmlStream", "logStreamer", " urlWindow", " urlStreamer", "fileStream", "urlStreamer", "fileWindow", "inputStream", "Urlstream", "httpStream", "UrlSteam", "rowStream", "urlstream", "inputSteam", "httpSteam", "urlSteam", "urlWindow", "logSteam", "rowConnection", "logstream", "httpStreamer", "logStream", "fileSteam", "rowWindow", "UrlStream", " urlSteam", "UrlStreamer", "inputStreamer", "xmlSteam", "fileConnection"]}}
{"id1": "22708533", "id2": "15018553", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentAsFile", " copyDocumenttoFile", " copyDocumentAsURI", " copydocumenttoURI", " copyDocumenttoURI", " copyDocumentFromUrl", " copydocumenttoURL", " copyDocumentFromFile", " copydocumentToFile", " copyDocumentToUrl", " copyDocumentToURL", " copydocumenttoFile", " copydocumenttoUrl", " copyDocumenttoURL", " copyDocumentFromURL", " copydocumentToUrl", " copydocumentToURI", " copyDocumentAsUrl", " copyDocumentAsURL", " copydocumentToURL", " copyDocumentFromURI", " copyDocumenttoUrl", " copyDocumentToFile", " copyDocumentToURI"], "file": ["path", "place", "message", "valid", "attribute", "fil", "title", "f", "local", "sample", "from", "default", "File", "resource", "filename", "le", "where", "rule", "name", "doc", "ile", "FILE", "command", "string", "source", "input", "base", "check", "table", "log", "document", "work", "full", "data", "origin", "image"], "target": ["arg", "top", "update", "window", "location", "replace", "template", "valid", "link", "arget", "Target", "root", "rel", "to", "local", "scope", "back", "component", "this", "home", "view", "dest", "result", "remote", "print", "project", "base", "source", "table", "select", "join", "origin", "layout", "alias", "ARGET", "host", "pattern"], "is": ["ims", "mos", "ists", "ains", "mis", "ais", "im", "isc", "abs", "es", "est", "iso", "ris", "it", "tis", "dis", "ri", "ois", "isl", "has", "nis", "bis", "bs", "isa", "its", "iss", "ms", "ys", "xs", "mi", "ci", "cs", "ins", "bits", "obs", "ics", "rs", "ns", "isf", "\u00eds", "vs", "si", "Is", "isin", "ir", "fs", "isal", "iris", "vis", "ism", "us", "isi", "i", "oss", "ios", "sis", "ip", "lis", "IS"], "os": ["mos", "cos", "nos", "out", "ms", "es", "OS", "asis", "oos", "mes", "ops", "oin", "des", "sys", "ows", "uts", "bos", "bis", "osi", "et", "bs", "ss", "dos", "o", "aos", "ost", "css", "io", "ins", "pos", "obs", "ps", "osa", "ox", "oS", "ones", "oa", "ns", "mot", "acs", "ks", "Os", "none", "ols", "los", "us", "ori", "ose", "oss", "oes", "ios", "ot", "ros", "tes", "oses", "eps", "ts"], "url": ["http", "con", "ls", "location", "n", "open", "user", "link", "ur", "Url", "f", "address", "ul", "URL", "rel", "re", "ssl", "uri", "nl", "t", "channel", "client", "name", "str", "mount", "ll", "cp", "service", "l", "char", "net", "conn", "domain", "job", "web", "https", "cert", "r", "host"], "connection": ["application", "connect", "pointer", "ion", "Connection", "con", "cone", "description", "session", "using", "close", "n", "open", "link", "generation", "response", "database", "condition", "reference", "character", "relation", "uri", "closure", "t", "client", "resource", "channel", " Connection", "creation", "communication", "still", "opening", "number", "service", "established", "l", "position", "net", "result", "conn", "command", "entry", "document", "city", "c", "network"]}}
{"id1": "18489832", "id2": "3330944", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadXZipfile", " tryLoadZppedfile", " tryLoadXippedFile", " tryLoadZippedDir", " tryLoadXippedDir", " tryLoadZZipDir", " tryLoadZippedImage", " tryLoadXippedfile", " tryLoadZressedfile", " tryLoadZppedFile", " tryLoadXZipDir", " tryLoadZippedFile", " tryLoadZippedfile", " tryLoadZZipfile", " tryLoadZppedImage", " tryLoadZressedImage", " tryLoadZZipImage", " tryLoadZppedDir", " tryLoadZZipFile", " tryLoadZressedFile", " tryLoadXippedImage", " tryLoadZressedDir", " tryLoadXZipFile", " tryLoadXZipImage"], "url": ["http", "location", "sl", "open", "ret", "build", "link", "ur", "b", "ul", "Url", "address", "URL", "loader", "raw", "row", "ssl", "uri", "dl", "nl", "browser", "ref", "call", "request", "key", "str", "name", "mount", "xml", "ll", "external", "get", "l", "char", "err", "un", "base", "file", "log", "parse", "web", "https", "r"], "destDir": ["srcDIR", "originDir", " destDirectory", " destDIR", "destDIR", "targetFolder", "sourceDir", "srcFolder", "distDirectory", "sourceFolder", "srcFile", " destFolder", "originDirectory", "targetDIR", "targetDirectory", "destDirectory", "distFolder", "sourceDirectory", " destFile", "originDIR", "srcDir", "originFolder", "destFolder", "targetDir", "sourceFile", "srcDirectory", "distDir", "distDIR", "destFile"], "urlConnection": ["streamCompany", "urlDialog", "UrlDialog", "streamClient", "urlCompany", "URLCompany", "httpConnection", " urlDialog", "urlConnect", " urlLink", "streamConnector", "URLClient", "httpDialog", "httpConnect", "httpLink", "urlLink", "UrlLink", "UrlConnect", "urlConnector", "UrlConnection", "streamConnection", "URLConnection", " urlConnect", " urlClient", "urlClient", "URLConnector", " urlConnector", " urlCompany"], "tmpFile": ["tmpBe", "empView", " tmpPage", "tempDir", "tmpView", "tempChain", "empFilename", "tempTile", "mpFile", " tmpView", "cmpfile", "tmpPage", "mpfile", "destPage", " tmpfile", "tempView", "empTile", "thisFile", "tempPage", " tmpBe", "thisFilename", "tempBe", "thisChain", " tmpFilename", "tmpChain", "empFile", " tmpTile", "empDir", "tempFile", "destfile", "destBe", "tmpDir", "tempFilename", "tmpTile", "empfile", "thisfile", "empChain", "tmpFilename", "cmpFilename", "cmpFile", "cmpPage", " tmpDir", "tmpfile", "tempfile", "destFile"], "in": ["IN", "on", "din", "gin", "im", "con", "ains", "or", "st", "ln", "n", "it", "by", "oin", "ini", "rin", "is", "ze", "ie", "ai", "sin", "old", "ain", "as", "en", "inc", "from", "mi", "re", "ind", "al", "ins", "ma", "win", "up", "el", "bin", "pass", "all", "inner", "index", "none", "one", "isin", "l", "In", "input", "source", "iter", "i", "co", "info", "init", "query", "inn", "inside", "inf", "cin"], "out": ["output", "ch", "cos", "on", "con", "or", "n", "Out", "ent", "it", "sys", "tmp", "flush", "can", "no", "o", "aos", "to", "col", "os", "io", "OU", "note", "ex", "outs", "t", "client", "conv", "up", "v", "ou", "nt", "exit", "oe", "at", "write", "na", "null", "all", "writer", "external", "one", "obj", "net", "print", "OUT", "ne", "cn", "po", "oss", "co", "outer"], "localURL": ["publicURL", "LocalUrl", "LocalID", "LocalUR", "LocalURI", "localURI", "localhostID", " localID", "localLL", " localLL", "LocalLL", " localURI", " localUR", " localUL", "localhostUL", "publicURI", "publicUR", "localUL", "localID", "LocalUL", " localUrl", "localUR", "LocalURL", "publicUrl", "localUrl", "localhostLL", "localhostURL"]}}
{"id1": "6301863", "id2": "11933797", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doHttpQuery", "doDirectCall", "doRawAction", "doDirectQuery", "doNativeCall", "doNativeQuery", "sendHttpAction", "doNativeAction", "doHttpRequest", "doDirectRequest", "sendRawQuery", "sendHttpQuery", "doNativeRequest", "doHttpCall", "sendRawCall", "sendHttpCall", "sendRawRequest", "doRawQuery", "doDirectAction", "sendRawAction", "doHttpAction", "doRawCall", "sendHttpRequest"], "postData": ["requestDATA", "preBody", "requestData", "posteddata", "POSTDATA", "postBody", "POSTMessage", "requestMessage", "preMessage", "preData", "requestBody", "POSTData", "postDATA", "PostString", "postdata", "postedMessage", " postMessage", "postString", "postedData", "PostMessage", " postString", "postMessage", " postdata", "PostData", "Postdata", "preDATA", "POSTBody", "postedString"], "url": ["http", "mail", "con", "ls", "abs", "addr", "sl", "org", "ret", "build", "pkg", "bel", "link", "ur", "lb", "ul", "Url", "URL", "rel", "pl", "re", "ssl", "uri", "dl", "loc", "nl", "client", "gl", "ld", "google", "str", "mount", "ll", "l", "www", "https", "web", "cert", "cmd", "hl"], "conn": ["ch", "nec", "nc", "connect", "con", "addr", "close", "j", "org", "open", "com", "sys", "connection", "pg", "ct", "iw", "rel", "inv", "enc", "col", "ssl", "conv", "pas", "loc", "resp", "pt", "client", "fin", "nt", "syn", "ns", "canon", "cp", "cb", "comm", "l", "exec", "net", "cont", "cn", "cert", "jp", "res", "gn", "cmd", "act", "Conn", "c", "cur"], "wr": ["dr", "spr", "RW", "wm", "rew", "WR", "wer", "dx", "vet", "rou", "iw", "Wr", "wd", "wp", "sw", "writ", "hr", "pr", "fr", "rw", "wt", "write", "writer", "nw", "wb", "w", "vr", "mr", "wid", "kl", "wk", "tn", "wn", "mk", "lr", "Writer", "fw", "kr", "r", "wy", "wx"], "rd": ["dr", "rh", "nd", "rar", "ri", "erd", "nder", "rid", "rx", "rod", "rog", "rer", "rend", "ry", "rc", "hr", "pr", "red", "fr", "rand", "rw", "rs", "cr", "rt", "rpm", "ld", "reader", "dd", "ptr", "mr", "rr", "rect", "sr", "ra", "rob", "rl", "rn", "adr", "ro", "RD", "r", "ru", "rb"], "sb": ["bf", "abs", "nb", "SB", "sd", "bd", "b", "bp", "lb", "bis", "bps", "bs", "lp", "kb", "bag", "bsp", "ob", "bn", "bb", "sa", "erb", "obs", "bt", "sm", "eb", "bg", "xb", "RB", "pb", "ib", "zb", "mb", "si", "gb", "cb", "sh", "obb", "sth", "sg", "gc", "bj", "rob", "lbs", "sp", "bh", "sv", "gob", "sf", "sq", "rb"], "line": ["buffer", "message", "style", "list", "text", "cell", "lin", "block", "phrase", "ln", "valid", "header", "eline", "link", "zone", "entity", "row", "sample", "frame", "stay", "nl", "liner", "le", "e", "code", "inline", "ine", "rule", "name", "label", "LINE", "number", "ice", "l", "page", "sequence", "pe", "entry", "string", "print", "point", "check", "file", "log", "stroke", "comment", "chain", "display", "word", "Line"]}}
{"id1": "14053882", "id2": "10728243", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"encrypt": [" encrypted", " encryption", "Encrypted", " encode", "Encode", "encode", "Encryption", "decrypted", "decode", "encryption", "Encrypt", "encrypted", "decryption", "decrypt"], "plaintext": ["plainth", "plainpassword", "publictext", "broadText", "broadth", "publicText", "longtext", "broadmessage", "maintext", "plainText", " plainText", "longmessage", " plainmessage", "mainText", "broadtext", "mainTEXT", "publicpassword", "plainmessage", " plainTEXT", "publicTEXT", "longth", "plainTEXT", "mainpassword", " plainth", "longText", " plainpassword"], "md": [" dd", "dr", "ms", "mark", "nd", "sd", "mc", "od", "metadata", "del", "MD", "sha", "grad", "der", "cd", "ds", "mg", "met", "mm", "dm", "mt", "ind", "rm", "ma", "sm", "dh", "nt", "det", "ld", "mb", "d", "dd", " mc", "esm", "mp", " mo", "mk", "mod", "managed", "dig", "pd", "m", "df", "sam", "mo", "mn", "mand", "cmd", "med", " ma", "hd", "ng"], "raw": ["strip", "message", "out", "orig", "unsigned", "n", "buf", "unknown", "valid", "available", "known", "bare", "row", "bound", "hook", "rendered", "encrypted", "right", "clear", "all", "hex", " Raw", "box", "original", "sh", "RAW", "bytes", "good", "custom", "base", "extra", " RAW", "input", "clean", "value", "data", "full", "array", "random", "aw", "r", "Raw", "pack"], "hash": ["message", "json", "html", "mask", "password", "Hash", "unknown", "hat", "hed", "sign", "has", "sha", "id", "ssh", "ashes", "h", "ashed", "total", "alert", "tag", "hex", "key", "flash", "sh", "mac", "shadow", "hidden", "sum", "tr", "href", "print", "cert", "search", "height", "url", "proof", "handle", "cache", "ash"]}}
{"id1": "5759961", "id2": "22338097", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"saveUser": [" manipulateGroup", " enrichGroup", " saveGroup", " saveuser", "saveuser", "saveGroup", " manipulateAccount", " manipulateUser", " enrichAccount", " enrichUser", " manipulateuser", "saveAccount", " enrichuser", " saveAccount"], "user": ["message", "load", "owner", "per", "update", "password", "or", "add", "by", "replace", "force", "author", "human", "used", "item", "response", "account", "me", "person", "ver", "usage", "row", "create", "test", "User", "use", "auth", "client", "login", "server", "v", "email", "content", "e", "this", "write", "store", "rule", "name", "responsible", "version", "post", "USER", "get", "username", "char", "u", "uid", "result", "record", "print", "base", "project", "entry", "object", "table", "file", "actor", "job", "us", "profile", "ro", "info", "data", "cert", "url", "usr", "word", "report"], "digest": ["compest", "Digse", " digse", " digests", "readse", "Digester", " digested", "Digest", "digested", "hashests", "mdester", " digEST", "digress", "compested", "compests", "DigEST", "hashest", "hashester", "mdested", "digse", "digEST", "Digested", "digests", "readester", "hashress", "digester", "hashEST", "readest", "mdest", " digress", "hashested", " digester", "compress", "mdse", "readested"], "hash": ["rh", "html", "mask", "password", "add", "block", "Hash", "init", "hed", "type", "has", "count", "sha", "id", "ashes", "h", "size", "test", "num", "uh", "tag", "hex", "key", "version", "sh", "index", "number", "mac", "char", "sum", "result", "dig", "check", "max", "search", "full", "height", "handle", "her", "cache", "ash"], "bigInt": ["bigLong", "bigINT", "longINT", "pgINT", "littleint", "BigInt", "bigInteger", "longInt", "pgInt", "littleInt", "pgint", "bigint", " bigint", "hugeLong", "BigLong", "hugeInteger", "longint", "hugeint", "BigInteger", "Bigint", " bigLong", "hugeInt", " bigInteger", "littleINT"], "hashtext": ["ashstr", "ashtext", " hashvalue", "ashText", "hashpath", "hashtxt", "HashText", "ashread", "shavalue", "sumpath", "hashvalue", "hashinfo", "sumtext", " hashread", "shaText", " hashtxt", "ashinfo", "shatxt", "hextext", " hashstr", "sumstr", "hashfunction", "sumfunction", "Hashfunction", "hexText", "hashText", "hextxt", "hashread", "hexread", "hashstr", "Hashinfo", "hexpath", "Hashpath", " hashfunction", "Hashstr", "sumText", " hashinfo", "Hashtext", "ashtxt", " hashText", "shatext", "hexvalue"]}}
{"id1": "659316", "id2": "13516684", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"argv": ["suppp", "argsv", "Argv", "argV", "suppV", " argm", "argsV", "Argm", "argss", "argsc", "suppvs", "callV", " argvs", "suppv", " argc", "argm", "callvs", "ArgV", "argsm", "argvs", "argc", " argV", " argp", "argp", "callp", "Argc", "Args", "callv"], "sources": ["inources", "seets", " sures", "inodes", "tources", "sliders", "servets", "inets", " sors", " sets", " siders", "sodes", "seodes", "servources", "seults", "sors", " soots", " sults", "sures", "stors", "tiders", " socks", "sloots", " sodes", "stources", "slources", "stets", "toots", "stures", "socks", "slocks", "seources", "soots", "siders", "inults", "sults", "tocks", "servors", "servures", "sets"], "targets": ["topes", " tangets", "targetsets", "topens", "tangches", "targends", "toksets", "Targes", "targetgers", "tankets", "toolsargens", "tangets", "Topets", "targetens", "Targches", "Topends", "targes", "Topches", " tanges", "topches", "tokets", "tokes", "tokens", "tanges", "tassches", "tokgers", "toolsargets", "tokends", "tasses", "toolsankets", " targens", " tangens", "tankens", "tanksets", "toolsarggers", " tangends", "Targets", "Topes", "toolsanksets", "toolsankgers", "tangens", "topends", "toolsargsets", "targetets", "targens", "toolsankens", " targes", " targends", "topets", "targsets", "targches", "tankgers", "targgers", "tassets", "tassends", "Targends", "tangends"], "srclen": ["srclogn", "srseln", "srklog", " srplen", "srklen", "srplade", "srklue", "rsccue", "srccen", "srplen", "srccog", "srselogn", "rsclue", "rsclogn", " srcln", "srselog", " srplength", " srpln", "srclog", "rsccen", "srCLade", "srccue", "srCLength", " srclength", "srCLen", " srclade", " srplade", "srclength", "srselue", "srclade", "rsclog", "srplength", "srccogn", "rsclen", "srselade", "srCLn", "srselength", "srcln", "srklogn", "srselen", "rsccog", "srclue", "rsccogn", "srpln"], "source": ["buffer", "style", "ser", "site", "internal", "template", "SOURCE", "force", "sys", "link", "me", "ource", "root", "console", "local", "scan", "create", "from", "resource", "scope", "Source", "wrapper", "parent", "this", "src", "store", "null", "inner", "reader", "get", "service", "scale", "sequence", "standard", "input", "copy", "iter", "select", "status", "secure", "match", "set", "file", "system", "sp", "query", "search", "info", "escape", "s", "trace", "start", "context", "score", "cache"], "tgt": ["teht", "npt", "itarg", "itgt", "ittarget", "tearget", "nht", " tpt", "Target", "Targ", " tgn", "ttarget", "starget", "warget", " targ", "tearg", "targ", "ngn", "itht", "Tht", "wtarget", "tgn", "warg", "Tgt", "sttarget", "tht", "tegn", " ttarget", "wgt", "tpt", "tegt", "itarget", " tht", "stgt", "tetarget", "ngt", "tept", "starg"], "target": ["output", "path", "buffer", "pointer", "top", "trap", "mask", "owner", "internal", "bolt", "template", "touch", "member", "peer", "sys", "tmp", "link", "manager", "proxy", "arget", "socket", "Target", "rel", "local", "to", "channel", "resource", "wrapper", "parent", "stable", "null", "writer", "next", "goal", "dest", "handler", "inter", "localhost", "base", "gt", "child", "copy", "table", "match", "secondary", "trace", "ARGET", "out"], "deletes": ["seleted", "dges", "deges", "desets", "Deels", "desleted", "delves", "leets", "dletes", "desletes", "desges", "Deles", "Deletes", "seletes", "dlets", "delets", "duleted", "lelets", "duges", "deslets", "dellets", "dleted", "desves", "deves", "duletes", "seles", "dules", "seels", "deets", "deleted", "delletes", "deles", "dulets", "deels", "leletes", "leves", "Deleted", "duels"], "del": ["Del", " dele", "dr", "ls", "se", "dis", "pel", "des", "tl", "rol", "rem", "vet", "rel", "inv", "ele", "col", "bl", "re", "dem", "sel", "pl", "dl", "nl", "el", "nt", "syn", "le", "delete", "ll", "dec", "l", "tr", "compl", "md", "err", "kl", "let", "cl", "def", "ne", "rl", "els", "cel", "elt", "de", "len"]}}
{"id1": "20306677", "id2": "6987642", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"update": ["edit", "UPDATE", "Update", "load", "patch", "json", "offset", "add", "save", "init", "replace", "touch", "now", "user", "draw", "build", "change", "database", " Update", "put", "updated", "flush", "send", "latest", "id", "state", "local", "size", "create", "execute", "test", "num", " UPDATE", "use", "login", "op", "current", "up", "oo", "run", "call", "delete", "write", "where", "all", "version", "ask", "index", "get", "upload", "u", "print", "batch", "check", "fill", "set", "push", "status", "date", "value", "match", "find", "query", "out", "insert", "commit", "report"], "o": ["onet", "bo", "n", "iso", "oin", "a", "O", "fo", "b", "ob", "p", "y", "to", "os", "t", "oo", "v", "e", "oa", "ao", "oice", "u", "obj", " mo", "k", "om", "object", "m", "po", "i", " os", "mo", "vo", "oid", "ooo", "out"], "bill": ["bo", "iban", "lex", "kick", "gross", "nb", "book", "money", "bean", "build", "bar", " Bill", "b", "handle", "inv", "bb", "BILL", "pay", "phy", "Bill", "fax", "ship", "ll", " billing", "service", "bank", "quote", "net", "nn", "conn", "trade", "stuff", "batch", "project", "biz", "company", "ann", "work", "vo", "unk", "sk", " billed", "fund", "report"], "pst": [" pct", "apct", " psp", "tpse", "tpST", "tpsp", "cstra", "pstro", "opst", "apsp", "opse", "picstro", "pstra", "pST", "cstro", "picst", "pse", "tpstra", "opct", "pth", " pST", "pkgth", "cth", "tpct", "pkgstro", "opstra", "tpst", "apst", " pse", "picth", "pkgstra", "pkgst", "cst", " pstra", "psp", "apST", "picstra", "pct"]}}
{"id1": "14047629", "id2": "22135199", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"source": ["output", "buffer", "proc", "message", "expression", "se", "SOURCE", "seed", "shell", "address", "q", "ource", "sql", "console", "sample", "iterator", "from", "channel", "resource", "Source", "content", "request", "src", "reader", "stream", "service", "position", "sequence", "event", "result", "input", "copy", "file", "system", "query", "data", "format", "in", "image"], "process": ["place", "proc", "session", "connect", "function", "task", "node", "pm", "term", "program", "method", "se", "init", "build", "link", "sys", "and", "class", "condition", "processor", "p", "state", "console", "make", "flow", "create", "execute", "frame", "pid", "use", "pp", "pipe", "component", "run", "Process", "code", "processing", "call", "script", "store", "post", "cp", "service", "thread", "complex", "command", "project", "check", "mem", "object", "status", "file", "job", "parse", "chain", "work", "memory", "context", "cmd", "handle", "exec", "network"], "processStdOut": ["processStrdIn", "processStrrEr", "processStstdOut", "processStstEx", "processStrdEx", "processStrIn", "processStrOut", "processStstdIn", "processStstdEx", "processStrrOut", "processStdEr", "processStstIn", "processStrdEr", "processStrrIn", "processStstOut", "processStdEx", "processStstEr", "processStrdOut", "processStstdEr", "processStrEr", "processStrrEx", "processStrEx"], "processStdIn": ["processStackdin", "processStackdIN", "processSttIns", "processStackdsIn", "processStsin", "processStsOut", "processStdsIn", "processStrIn", "processStsIn", "processStrIN", "processStrOut", "processStdIN", "processStackdsIN", "processStackdsOut", "processStrin", "processSTtIn", "processSTtOut", "processStackdOut", "processSTdIns", "processStdin", "processStsIN", "processStdIns", "processSTdIn", "processSttIn", "processSttIN", "processStrIns", "processStackdsin", "processSTdIN", "processSTdOut", "processStdsIN", "processStdsIns", "processStackdIn", "processSTtIns", "processStdsOut", "processStdsin", "processSTtIN", "processSttOut"]}}
{"id1": "12242903", "id2": "20100809", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hashKey": [" hashkey", "hashValue", "processkey", "hashkey", "updateValue", "updateLink", "processLink", "processKey", " hashValue", "updatekey", "updateKey", "processValue", "hashLink", " hashLink"], "key": ["path", "message", "text", "json", "Key", "password", "description", "prefix", "phrase", "template", "hello", "type", "link", "item", "piece", "seed", "title", "attribute", "secret", "et", "id", "y", "token", "state", "encrypted", "client", "KEY", "lock", "code", "this", "null", "hex", "name", "ace", "username", "char", "service", "k", "obj", "base", "entry", "string", "source", "port", "value", "chain", "foo", "data", "cert", "sk", "conf", "cache"], "hashed": ["enhhed", "rhamped", "hrypted", "khhed", "enhrypted", "hashing", "shoted", "enhash", "ahashed", " hushed", "hored", "enhashed", "ahored", " hored", " hoted", " hrypted", "khrypted", "shhed", " hamped", "hoted", "hhed", "hohed", " hashing", "thashed", " hhed", "thushed", "rhhed", "shamped", "khashed", "hoashing", "ahushed", "hoashed", "khashing", "hamped", "hoash", "thored", "hushed", "rhoted", "khash", "shashed", "thash", "ahash", "rhashed"], "md5": ["det3", " md55", " md0", "MD3", " md2", " md45", "sha3", "md45", "sha0", "dig3", "det55", "sha2", "sha5", "MD2", " MD3", " md3", " MD45", "md2", "det5", "MD45", "MD0", "md55", "dig55", " MD2", " MD5", "MD5", "md0", "dig5", "md3"], "hash": ["message", "html", "block", "Hash", "hz", "score", "shift", "hed", "build", "has", "sq", "count", "sha", "ssh", "h", "sample", "checked", "ashed", "uh", "total", "length", "square", "tag", "always", "radius", "ah", "hex", "trust", "sh", "index", "number", "shadow", "sum", "check", "search", "height", "array", "handle", "carry", "kernel", "ash"]}}
{"id1": "9210168", "id2": "21425787", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"run": ["function", "close", "block", "apply", "runs", "normal", "class", "Run", "invoke", "execute", "test", "true", "default", "call", "all", "running", "exit", "pass", "process", "name", "get", "thread", "result", "def", "render", "show", "func", "launch", "work", "display", "start", "begin", "play", "exec"], "url": ["path", "http", "ls", "abs", "sl", "ret", "bel", "ur", "b", "Url", "f", "gif", "URL", "rel", "io", "pl", "ssl", "uri", "nl", "resource", "browser", "gl", "ref", "str", "mount", "impl", "fl", "l", "char", "rect", "lr", "rl", "file", "https", "web", "res", "hl"], "fis": [" fi", " fiss", " fIs", "fbiss", "fiis", "ifIs", "fiIS", "sfIS", "lfis", "fiss", "fi", "sfIs", "dfis", "fIS", "fbis", " fim", "ifis", "dfiss", "fbibus", "fiien", "fibus", "fbi", "fien", "dfi", "sfien", " fibus", "fIs", "dfibus", "fiIs", "ifIS", "fiim", "ifien", "fim", "lfim", "lfIs", "sfis"], "r": ["gr", "dr", "R", "rar", "ri", "rec", "ur", "rx", "b", "f", "p", "rel", "rc", "hr", "re", "pr", "rd", "nr", "er", "fr", "ar", "rs", "cr", "rt", "reader", "vr", "rf", "mr", "tr", "l", "rr", "rect", "sr", "ra", "rl", "rn", "ran", "ro", "kr", "res", "rb"], "br": ["dr", "buf", "nb", "n", "bd", "b", "bp", "rx", "bm", "bs", "BR", "p", "rel", "bl", "hr", "bb", "pr", "nr", "fr", "bt", "browser", "Br", "cr", "ab", "bro", "be", "str", "cb", "vr", "mr", "tr", "bridge", "err", "sr", "lr", "adr", "bh", "kr", "ber", "rb"], "line": [" row", "bo", "cell", "model", "lin", "block", "n", "ln", "valid", "user", " chunk", "eline", "link", "zone", "lane", "entity", "no", " status", "row", "sample", "frame", "nl", " inline", "lines", "record", "liner", "email", " block", "le", "e", "code", "inline", "ine", "name", "str", "LINE", " frame", "number", "l", "char", "page", "sequence", " entry", "base", "print", "entry", "point", "string", "check", "file", "log", "stroke", "comment", "li", "word", "Line", " error"], "sb": ["ub", "bf", "db", "sbm", "nb", "sync", "SB", "bd", "b", "lb", "gs", "bis", "shell", "bs", "lp", "kb", "bsp", "bn", "bb", "sa", "erb", "ssl", "nl", "bt", "eb", "bg", "orb", "xb", "pb", "ib", "zb", "cb", "si", "gb", "mb", "sth", "sg", "sn", "bj", "rob", "sam", "sp", "bh", "sv", "stab", "soc", "sf", "sq", "rb"], "text": ["path", "output", "buffer", "message", "html", "st", "term", "x", "TEXT", "pdf", "n", "config", "msg", "ext", "b", "title", "lt", "body", "Text", "read", "end", "note", "t", "content", "translation", "code", "str", "name", "txt", "cont", "print", "source", "value", "comment", "data", "format", "displayText", "layout", "out", "word"]}}
{"id1": "4895903", "id2": "8166767", "code1": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["loads", "save", "init", "sync", "open", "build", "link", "oad", "LOAD", "loader", "read", "download", "sample", "execute", "install", "use", "map", "lock", "transform", "call", "Load", "store", "dump", "loading", "launch", "show", "insert"], "sourceType": ["componentTYPE", "unittype", " sourceClass", "templateSpec", "typeType", "sourceCopy", " sourceStyle", "secretTyp", "noTyp", "serviceTyp", "typeEmail", "componentClass", "speType", "statusTyp", "scantype", "scopeTyp", "messageTyp", "licenseTyp", "templateType", "sourceTYPE", "styleTyp", "noStyle", "versionDefault", "statusType", " sourceTYPE", "scopeStyle", "sequenceTYPE", "notetype", "scopeType", "styleTYPE", "messageDefault", "ourceTy", "licenseTYPE", "sourceEmail", "speCopy", "serviceType", "statusVersion", "SOURCEType", "templateTyp", "templateStyle", "sourceStyle", "ourceTyp", "SOURCEtype", " sourceField", "templateCopy", "licenseType", "licensetype", "licenseUnit", "styleClass", " sourceTyp", "scanType", "serviceApp", "scanTyp", "sourcetype", "licenseEmail", "scopetype", "causetype", "SOURCEVersion", "messageTy", "componentTyp", "templatetype", "typeUnit", "scoreTyp", "versionTyp", "componentType", "statusTy", "notype", "ourceDefault", "sourceSpec", "scoreType", "componentField", "sourceTyp", "sourceTy", "sourceVersion", "versionTy", "statustype", "SOURCEApp", "styleType", "licenseVersion", "unitType", "noteTy", "causeType", "scopeSpec", "sourceDefault", "versionType", "unitTyp", "sourceApp", "sourceField", " sourceSpec", "secretApp", "servicetype", "scoretype", "scopeCopy", "secrettype", "versionStyle", "sequenceType", "sourceUnit", "scanField", "sourceClass", "noteType", "SOURCETyp", "causeTy", "sequenceEmail", "spetype", "messageType", " sourcetype", "versiontype", "componenttype", "speTyp", "sequenceUnit", "typeTYPE", "secretType", "ourceType", "causeTyp", "noteTyp", "noType"], "source": ["style", "function", "core", "se", "instance", "config", "force", "see", "size", "scan", "Source", "parent", "content", "component", "src", "any", "service", "license", "sequence", "status", "iter", "file", "query", "origin", "storage", "report", "list", "series", "text", "json", "description", "init", "template", "SOURCE", "seed", "sql", "create", "from", "slot", "slice", "feature", "scope", "remote", "details", "string", "object", "parse", "comment", "sp", "search", "start", "handle", "expression", "site", "missing", "draw", "ie", "me", "address", "via", "body", "ource", "subject", "use", "resource", "settings", "view", "unit", "get", "input", "copy", "table", "join", "target", "find", "alias", "message", "update", "reason", "node", "send", "raw", "state", "sample", "ce", "note", "spec", "filename", "key", "module", "store", "stream", "none", "show", "format", "context", "image", "supp", "cache"], "param": ["path", "arg", "prom", "pm", "attr", "model", "prefix", "monitor", "init", "member", "config", "method", "arm", "cal", "term", "msg", "item", "rem", "attribute", "property", "params", "asm", "reference", "p", "prop", "mm", "rm", "argument", "Param", "typ", "par", "tag", "ref", "pai", "pre", "rpm", "req", "name", "Parameter", "index", "cp", "aram", "perm", "problem", "m", "meter", "comment", "query", "admin", "format", "start", "conf", "rest"], "location": ["path", "history", "message", "expression", "owner", "ion", "shape", "description", "Location", "peer", "condition", "property", "address", "reference", "root", "usage", "region", "local", "center", "area", "sample", "folder", "bound", "feature", "loc", "resource", "initial", "filename", "scope", "translation", "library", "direction", "where", "key", "module", "LOC", "name", "operation", "mount", "position", "family", "event", "directory", "sequence", "remote", "activity", "ocation", "entry", "point", "padding", "device", "language", "value", "availability", "comment", "document", "target", "search", "info", "media", "origin", "context", "layout", "trace", "color"], "type": ["style", "function", "part", "shape", "description", "ping", "term", "time", "method", "types", "link", "sort", "class", "title", "tp", "ver", "address", "id", "root", "state", "pretty", "test", "kind", "t", "op", "typ", "scope", "length", " Type", "operator", "tag", "all", "where", "key", "TYPE", "error", "name", "unit", "ype", "position", "ime", "family", "Type", "event", "form", "pe", "command", "action", "status", "language", "port", "comment", "option", "info", "what", "format", "options", "trace", "color", "role", "ty"], "inputsource": ["acceptsource", "InputSource", "Inputsrc", " inputresource", "inputsrc", "submitsample", "inputsum", "inputscope", "inputsample", "helpsource", "uploadservice", " inputobject", "inputource", "outputobject", "helpiterator", " inputservice", " inputSOURCE", "operatorseed", "Inputresource", "inputSource", "insertsource", "insertiterator", "insertsite", "inputsequence", "Inputsource", " inputstore", "pullsource", "submitsrc", "inputSOURCE", " inputsrc", " inputSource", "inource", "inSource", "inputseed", "Inputobject", "operatorsource", "uploadstore", "acceptresource", "outputstore", "outputresource", "submitsource", "outputscope", "Inputource", "inputservice", "operatorstream", "uploadsum", " inputseed", "othersource", "submitsequence", "helpstore", "insertsum", "inputstream", "insertservice", "inputobject", "acceptscope", "inputstore", "pullseed", " inputsite", "inputiterator", "othersrc", "helpsite", "Inputstore", "outputsource", " inputource", "pullstream", "acceptsrc", "othersequence", " inputscope", "insertstore", "outputsrc", " inputiterator", "pullSOURCE", "uploadsource", "othersample", "operatorSOURCE", "inputresource", " inputsum", " inputstream", "inputsite", " inputsequence", "insource", "insrc", " inputsample"], "url": ["path", "buffer", "http", "text", "mail", "html", "abs", "term", "sl", "user", "open", "bel", "link", "ur", "Url", "f", "ml", "address", "URL", "p", "sql", "rel", "api", "download", "ssl", "dl", "uri", "nl", "client", "resource", "browser", "gl", "ref", "str", "impl", "xml", "mount", "ll", "external", "l", "u", "char", "net", "base", "string", "rl", "file", "git", "web", "cert", "r", "host"], "ds": ["dr", "db", "ms", "ls", "sd", "des", "sys", "gs", "bs", "ss", "dos", "ws", "uds", "qs", "hs", "Ds", "xs", "eds", "dt", "cs", "DS", "dl", "ys", "ps", "rs", "dh", "js", "ads", "ns", "sts", "gd", "ks", "dd", "dc", "md", "fs", "dds", "pd", "df", "di", "ees", "ysis", "eps", "ts", "sq"], "mbeans": ["cmbs", "cmovies", "mxbean", " mbs", "Mubes", " mbean", "Mbs", "umovies", "mxbeans", "movies", "umbean", "mxubes", "mbs", "lbean", "cmbeans", "Mbean", "mubes", "mxbs", "cmbean", "Mbeans", " movies", "umbs", "umbeans", "lbs", "lbeans", "mbean", "lubes"]}}
{"id1": "9275622", "id2": "8182932", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" duplicateStream", " copyFiles", " cpfile", " duplicateFiles", " cpStream", " duplicatefile", " duplicateFile", " copyStream", "copyStream", " cpFiles", "copyFiles", " copyfile", "copyfile", " cpFile"], "_file1": ["_linkInit", "_ileOne", "_fileFirst", "_ileFirst", "_ile2", "_FileInit", "_ile1", "_FileFirst", "_filesOne", "_FileOne", "_fileInit", "_link1", "_filesFirst", "_linkOne", "_files1", "_fileOne", "_link2", "_File1", "_File2", "_ileInit", "_files2"], "_file2": [" _Filetwo", "_filetwo", " _File2", "_Fileb", " _fileb", " _FILE1", "_FILE1", " _FILE02", "_image2", "_linktwo", "_FileTwo", " _fileTwo", "_link1", "_FILE2", " _FileTwo", " _filetwo", "_FILE02", "_link2", " _FILE2", "_File1", "_fileTwo", " _FILEb", " _File1", "_linkTwo", "_File02", "_imageb", "_File2", " _file02", "_image1", "_image02", "_file02", "_FILEb", "_Filetwo", "_fileb"], "fis": [" fi", "cais", " fiss", "cios", "cos", "kis", "cfis", "cfois", "qis", "cis", "qiss", "fiss", "kais", "fi", "Fis", " fris", " fais", "Fiss", "qios", "cfris", "fli", "Fios", "flis", "qos", "kos", "fais", "Fos", "flios", " fios", "cfiss", "fliss", "kios", " fois", "fois", "ufi", "fios", "ufiss", "Fois", "ufis", "Fris", "fris", "ufios"], "fos": ["mos", "faos", "ffoes", "hos", "moes", "sfoes", "ffis", "sfoss", "mows", " foes", "hose", "maos", "flos", "flis", "floes", "wows", " fose", "foes", "ffoss", "sfose", "wis", "floss", "hoss", "sfos", " foss", "hoes", "woes", "fows", " fows", "waos", " faos", "foss", "fose", "woss", "ffos", "wos"], "canalFuente": ["canallFueree", "canallfueree", "canallfuje", "canalFuenza", "canalKuente", "canalfuperor", "canallFuent", "canalUtente", "canallFuje", "canalFuje", "canalFuestro", "canalfuent", "canalFueree", "canalTenenza", "canalTenente", "canalfueree", "canalfuje", "canalTenent", "canallfuperor", "canalFaleree", "canalFuent", "canallFuente", "canalFuperor", "canalFalente", "canallfuestro", "canalfuenza", "canalKuje", "canalFalent", "canalFalestro", "canallFuestro", "canallfuent", "canalFienza", "canalTenperor", "canallFuperor", "canallfuente", "canallfuenza", "canalFiperor", "canalFalperor", "canalUtestro", "canalUtent", "canalFient", "canalKuperor", "canalKuent", "canalFiente", "canalfuente", "canalFalje", "canalUteree", "canallFuenza", "canalfuestro"]}}
{"id1": "17716716", "id2": "11005804", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"plainToMD": [" convertToMC", " convertAsMC", " stringFromDM", " convertAsMD", " stringToDM", " convertToDM", " stringFromMC", " convertToMD", " convertTomd", " stringAsDM", " stringAsmd", " stringFromMD", " stringToMD", " stringTomd", " convertAsmd", " stringAsMC", " convertAsDM", " stringAsMD", " stringToMC", " stringFrommd"], "loggerCol": ["logggerColl", "loggerCOL", "logGERCOL", "logggerCOL", "loggeCol", "loginatorCl", "loggeCl", " loggerCOL", " loggerColumn", "logggerColumn", "badinatorCl", "logGERCol", "logggerCl", "loggeColl", " logggerCol", "badgerCol", "logggerCol", "logiderCol", "logiderColumn", "badinatorCol", "loggerCl", "loggerColl", " logggerCOL", "loggeCOL", "loginatorCOL", "loginatorColl", "badinatorCOL", "badgerCOL", "badgerColl", "badgerCl", "logiderCOL", "logGERColumn", "badinatorColl", "loginatorCol", " logggerColumn", "loggerColumn"], "input": ["output", "buffer", "text", "prefix", "hello", "it", "config", "example", "q", "raw", "from", "subject", "Input", "initial", "up", "request", "this", "str", "background", "char", "result", "form", "base", "command", "string", "source", "hash", " Input", "value", "file", "active", "document", "data", " inputs", "url", "in", "out", "context", "image", "pattern"], "byteHash": ["binaryHas", "byteLength", "ByteTr", "binaryHash", "bytehash", "uehash", "byteMap", " byteLength", "bytesHas", " byteTr", " byteHas", "ueTr", " bytehash", "Bytehash", "byteHas", "bytesHash", "byteshash", "ByteHas", "ueLength", "ByteMap", "byteTr", "binaryhash", " byteMap", "ByteLength", "ueHash", "ByteHash", "bytesMap"], "md": ["gr", "dr", "pm", "ded", "ms", "nd", "add", "cond", "msg", "sd", "mc", "bd", "od", "ct", "MD", "grad", "der", "cd", "ds", "mg", "met", "mm", "dm", "mt", "rm", "ind", "red", "sm", "det", "comp", "ld", "doc", "dd", "d", " Md", " mc", "mb", "mac", "mp", "mk", "mod", "dig", " MD", "gm", "pd", "def", "m", "hash", "df", "material", "sam", "di", "mo", "mn", "cmd", "med", "hd", "ng", "de"], "md5result": ["md64result", " md5Result", "MD5Result", "md3Result", "md5string", "md2Result", "md45results", "md65Result", "md3proc", "md2string", "md45result", "md45comment", "md64response", "MD2comment", "md5comment", "md3result", "md7result", "md5message", "md8proc", "MD5results", " md8proc", "md64results", "md7Result", "MD2Result", "MD5response", " md5proc", "MD5comment", "MD5result", " md8result", "md3results", "md5response", "md2results", "md7string", "MD2result", "MD5string", "MD2string", "md8message", "md64comment", "md3message", " md8message", "md65result", "md5results", "md65proc", "md45response", "md2comment", "md2result", "md5Result", "md65message", "MD2results", "md5proc", "md2response", "md8result", "MD2response", "md7results", "md8Result", " md5message", "md3string", " md8Result"], "i": ["multi", "ims", "im", "x", "j", "n", "phi", "it", "init", "my", "ai", "a", "is", "ic", "ie", "ui", "b", "me", "q", "id", "y", "fi", "o", "io", "ci", "mi", "ind", "gu", "uri", "qi", "ii", "v", "gi", "key", "ti", "ji", "bi", "index", "si", "I", "span", "u", "l", "ei", "m", "iter", "xi", "us", "cli", "z", "di", "sim", "pi", "in", "ip", "li", "c", "\u0438", "ix"]}}
{"id1": "18891988", "id2": "10715601", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getFile": ["selectfile", "getFilename", "createFilename", "GetFile", "selectFilename", "createString", "GetString", "createFile", "getfile", "createfile", "GetFilename", "getString", "selectFile", "Getfile", "selectString"], "serviceName": [" serviceCode", "libraryName", "ServiceFamily", "libraryType", "serverCode", "ServiceType", "serviceType", "serverType", "libraryFamily", "serviceCode", "serviceNames", "ServiceName", " serviceFamily", "ServiceNames", "ServiceCode", "libraryNames", "serviceFamily", "serverName", " serviceType", " serviceNames"], "wsdlLocation": ["wslLocation", "wlLoc", "awsdlURL", "wslLoc", "wssdFolder", "wslFolder", "wssdlocation", "awsdlocation", "wsdLoc", "wsDLlocation", "wsdllocation", "wsDLPath", "wsdlURL", "wsdLocation", "wsDLLoc", "wsDLFolder", "wsollocation", "wlFolder", "awsdllocation", "wsdURL", "wdlLocation", "wlPath", "wsolLoc", "awsdlLocation", "awsdlLoc", "wsolLocation", "wsDLURL", "wssdPath", "wssdLocation", "awsolLocation", "wsdlPath", "wsdlocation", "wsDLLocation", "wsdlFolder", "awsdURL", "wdlLoc", "awsolURL", "awsdLocation", "awsollocation", "wdlFolder", "wdlPath", "wlLocation", "wslPath", "wsdlLoc", "awsdLoc", "wssdLoc", "wsolURL", "wssdURL", "awsolLoc"], "endpoint": ["endword", "bindport", "startPoint", "idpoints", "bindpoints", "bindpoint", "endPoint", "Endpoint", "startpoints", "beginPoint", " endpoints", "beginword", "bindPoint", " endline", "idPoint", " endport", "Endpoints", "EndPoint", "beginpoint", "startword", "Endport", "startpoint", "idpoint", "Endword", "startline", "endport", "endline", " endPoint", "endpoints", "beginpoints", "idline"], "fileLocation": ["FileLoc", "Filelocation", "FileLocation", "fileLoc", "filePosition", " fileLoc", " filelocation", "documentLoc", " filePosition", "documentPosition", "filelocation", "FilePosition", "documentLocation", "documentlocation"], "tempDir": ["tmpUrl", "TempUrl", "TempPath", "TempDir", "tempDirectory", "tmpDirectory", "tmpdir", "tmpPath", " tempFolder", "tmpFolder", "tempPath", " tempdir", " tempUrl", "tempFolder", "TempDirectory", "TempFolder", " tempDirectory", "tmpDir", "tempUrl", "Tempdir", " tempPath", "tempdir"], "url": ["http", "mail", "ls", "window", "location", "sl", "open", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "socket", "URL", "rel", "sur", "pl", "re", "ssl", "uri", "dl", "loc", "nl", "up", "browser", "gl", "cr", "str", "mount", "ll", "cp", "service", "l", "char", "un", "conn", "base", "m", "job", "ctrl", "web", "https", "cert", "r", "li", "github", "il"], "WSDLFile": ["WSDLLFilename", "WSDLString", "WSDQLFile", "WIDDLString", "WHDLfile", "WIDDLType", "WSDDLString", "WIDLFile", "WHDDLFile", "WSDDLFILE", "WNDLFILE", "WSDDLType", "WHDDLfile", "WSDLLString", "WSDLLFILE", "WIDDLFile", "WNDLFile", "WSDDLFile", "WNDDLfile", "WSDLLType", "WHDDLFILE", "WSDELfile", "WSDLSFile", "WNDLFilename", "WIDLType", "WIDLString", "WSDQLfile", "WIDLfile", "WNDDLFILE", "WSDLLfile", "WSDMLfile", "WSDQLFILE", "WSDMLFILE", "WSDLLFile", "WSDMLFile", "WSDELFILE", "WNDLfile", "WSDLSType", "WSDLSString", "WSDLFILE", "WSDLType", "WSDLSfile", "WSDDLfile", "WHDLFILE", "WSDLFilename", "WSDLfile", "WSDELFile", "WNDDLFilename", "WSDDLFilename", "WHDLFile", "WIDDLfile", "WNDDLFile", "WSDELFilename"], "tmpWSDLFile": ["tmpWSDDLFiles", "tmpWSDlFile", "tmpWSDLDFilename", "tmpWIDDLFILE", "tmpWNDDLFilename", "tmpWSDLDFILE", "tmpWIDDLfile", "tmpWSDLLFilename", "tmpWSDLLFiles", "tmpWNDDLfile", "tmpWNDDLFiles", "tmpWSDlFiles", "tmpWSDlfile", "tmpWSDLFiles", "tmpWNDDLFile", "tmpWNDLFile", "tmpWSDlFilename", "tmpWIDDLFilename", "tmpWSDLLFILE", "tmpWNDLFiles", "tmpWSDLDFile", "tmpWSDDLFILE", "tmpWSDLDfile", "tmpWIDLfile", "tmpWSDLLfile", "tmpWIDDLFile", "tmpWSDLFilename", "tmpWSDDLFilename", "tmpWIDLFILE", "tmpWSDDLFile", "tmpWNDLFilename", "tmpWIDLFilename", "tmpWNDLfile", "tmpWSDLLFile", "tmpWIDLFile", "tmpWSDLFILE", "tmpWSDLfile", "tmpWSDDLfile"], "inputFile": ["inputPlace", "InputStream", "inputPath", "indexFILE", "indexStream", "intFiles", "inputSourceFile", "tmpFILE", "inputFILE", "outputFILE", "clientPath", "outputFile", "clientFiles", " inputfile", "indexfile", "errorFile", "tmpSourceFile", " inputPlace", "interfacePlace", "errorfile", "outputfile", "Inputfile", " inputFILE", "inputStream", "interfaceSourceFile", "InputFiles", "tmpStream", "clientFile", "intFILE", "inputFiles", "infile", "inputDo", "clientFILE", " inputFiles", "intfile", "errorFILE", " inputDo", "intFile", "tmpPlace", "inDo", "indexFile", "inFile", "interfaceFile", "inPath", " inputPath", "InputFile", "interfacefile", "tmpfile", " inputSourceFile", "InputPath", "InputDo", "errorStream", "InputFILE", "outputStream", "inputfile"], "tmpFile": ["tmpFILE", "inputFILE", "empFilename", "tmpFiles", "mpFile", " tmpPath", "empFILE", "mpfile", " tmpfile", "tmpPath", "tempFiles", "tempFILE", "tempPath", "mpFiles", "inputFilename", "empFile", "mpPath", "tempFile", "tempFilename", " tmpFiles", "empfile", "tmpFilename", "tmpfile", "tempfile", "inputfile"], "in": ["ch", "IN", "din", "init", "ln", "n", "it", "rin", "ri", "ai", "is", "ic", "ini", "sin", "ain", "id", "o", "inv", "en", "inc", "io", "from", "mi", "ind", "ins", "t", "client", "ar", "bin", "inner", "stream", "isin", "r", "In", "cont", "conn", "input", "source", "file", "inn", "inf", "c", "cin"], "out": ["output", "ch", "buffer", "on", "by", "n", "auto", "Out", "sys", "tmp", "connection", "can", "pool", "o", "inv", "to", "os", "en", "aos", "io", "OU", "ex", "outs", "t", "client", "conv", "ou", "lock", "cm", "all", "write", "at", "null", "group", "writer", "this", "ao", "w", "obj", "net", "conn", "OUT", "conf", "ne", "file", "log", "oss", "co", "we", "outer", "c", "cache"], "con": ["ch", "fn", "nc", "cos", "connect", "Con", "cone", "const", "cur", "ln", "cal", "exc", "mc", "connection", "acon", "ain", "can", "ws", "num", "re", "conv", "login", "win", "fc", "cm", "tc", "cp", "cons", "sec", "un", "conn", "cn", "CON", "ran", "func", "co", "cf", "com", "conf", "soc", "Conn", "c", "cin"], "fileLength": ["objectSize", "objectFontSize", "channelSize", "objectDuration", "FILESize", "channelLength", "ileLen", "FILELength", "fileDuration", "ileLength", " fileDuration", "fileSize", "FILEDuration", " fileLen", " fileSize", "FILELen", " fileFontSize", "fileLen", "ileDuration", "channelDuration", "fileFontSize", "channelFontSize", "ileSize", "objectLength"], "channelIn": ["channelIN", "chanIn", "consoleIn", "ChannelIn", "clientSet", "channelSet", "Channelin", "consoleedIn", "clientIn", "clientOut", "ChannelIN", "ChannelSet", " channeledIn", "ChanneledIn", "channeledIn", "ChannelOut", "channelin", "consoleOut", "consoleIN", "chanSet", "clientin", "chanIN", "chanOut", "clientIN", " channelIN", " channelin"], "channelOut": ["chanIn", "consoleIn", "ChannelIn", "channelOUT", " channelConn", "ChannelConn", "courseout", "courseOut", "courseOUT", "courseIn", "chanout", "chanConn", "ChannelOut", "consoleOUT", "channelout", "Channelout", "consoleout", "consoleOut", "chanOut", " channelout", "channelConn", " channelOUT", "ChannelOUT"], "tmpDocument": ["tmpDoc", "tpFile", "npDocument", "mkdocument", "npFile", " tmpDocuments", "mpDoc", "npMedia", "tpDocument", "tempDoc", "cpDocument", "tmDoc", "tpMedia", " tmpDoc", "tmDocument", " tmpMedia", "tmpDocuments", "cpDoc", "cpdocument", "tempdocument", " tmpdocument", "mpDocument", "mkDocument", "npDocuments", "mkDoc", "tmpdocument", "tpDocuments", "tmpMedia", "tmdocument", "mpdocument", "tempDocument"], "nl1": ["ln01", "rn6", "NL0", "pelOne", "sol0", "sol1", "nl01", "sol2", "nrOne", "nelOne", "rn3", "nl2", "ln2", "nl3", "pel1", "nel1", "lnOne", "ln6", "nel3", "nl6", "nlOne", "nr1", "sol9", "nr01", "ln3", "nel6", "nl0", "rn1", "pel01", "NL2", "nl9", "ln0", "ln9", "NL1", "ln1", "NL9", "rnOne"], "i": ["multi", "ims", "ms", "x", "j", "n", "init", "it", "ai", "a", "is", "ic", "ini", "ui", "ie", "me", "ri", "id", "y", "o", "io", "mi", "ci", "qi", "ii", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "span", "u", "k", "m", "xi", "cli", "us", "mu", "ami", "ori", "di", "sim", "pi", "info", "ij", "ip", "li", "\u0438", "ix"], "node1": ["Node2", "ode001", "nOne", "node91", "ode2", "component0", "node001", "NodeOne", "component2", "Node1", "layer91", "layer0", " node2", "layerOne", "ode1", "ode0", " node91", "node0", "Node001", " node0", " node001", "componentOne", " nodeOne", "layer1", "n1", "n0", "nodeOne", "node2", "n91", "Node0", "component1"], "tmpOut": ["tmpObj", " tmpIs", "tmpIs", "mpOut", "empIs", "mpout", "TempOUT", "npIn", "mpObj", "cmpIn", "cmpout", "TempIn", "tmpOUT", " tmpObj", "tempout", " tmpIn", "empout", "npout", "mpIn", " tmpOUT", "cmpOut", "TempObj", "tmpout", "tempObj", "tmpIn", "npObj", "tempIn", "tempOUT", "tempIs", "TempOut", "tempOut", "empOut", " tmpout", "npOut"], "retVal": ["retValue", "returnVal", "returnValue", "returnTrue", "returnval", "retval", "RetTrue", "RetValue", "Retval", "retTrue", " retValue", " retval", " retTrue", "RetVal"]}}
{"id1": "13595251", "id2": "755203", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargarArchico", " descargarActico", " descargarActive", " descargarRico", " descargarRiv", " descargarMotive", " descargarRivo", " descargarActiv", " descargoArchico", " descargoMotico", " descargoMotivo", " descargoMotiv", " descargarActivo", " descargarArchiv", " descargoMotive", " descargoArchive", " descargarMotiv", " descargarRive", " descargoArchivo", " descargarMotivo", " descargarMotico", " descargoArchiv", " descargarArchive"], "fis": ["ufos", " fiss", "fiis", "dfris", "fiiss", "ffis", " fris", "fiss", "Fis", "ffix", "dfis", "Fiss", "ffiss", "dfiss", "fiix", "Fos", "ffris", "fix", " fios", "ufris", "ufiss", "fios", "ufis", "Fris", "ffios", "dfos", " fix", "ffos", "fris", "fiios"], "fos": [" fOS", "faos", "infbos", " fOs", "woses", "lfoses", "fedOs", "fOS", "fbos", "flaos", "voss", " foes", "fedbos", "infOS", "wbos", "vows", "infos", "flos", "lfos", "fedos", "vos", "infOs", "fOs", "wows", "floses", "foes", " fbos", " foss", "woes", "fows", "lfbos", "fedOS", "flbos", " fows", "lfaos", "foses", "foss", "woss", "waos", "wos", "voes"], "inChannel": ["innChan", "inputConnection", " inButton", "inConnection", "inchannel", "InChannel", "InConnection", "aiRow", "aichannel", "inGray", " inchannel", "inChan", "inputChan", "InButton", "innerchannel", "Inchannel", "innerChan", " inChan", "outchannel", "inRow", "aiChan", "innerButton", "innRow", "initConnection", "innChannel", "InGray", "initGray", "outChan", "initChan", "initChannel", "innchannel", "InChan", "inputGray", "aiChannel", "inButton", "outRow", "inputChannel", "innerChannel"], "outChannel": ["OUTConsole", "OUTButton", " outStream", "inchannel", " outchannel", "inChan", "OUTStream", " outConsole", "outchannel", "OUTChannel", "inStream", " outButton", "outButton", " outChan", "outChan", "OUTchannel", "OUTChan", "outStream", "inButton", "outConsole", "inConsole"]}}
{"id1": "7396682", "id2": "20519261", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"copy": ["load", "core", "replace", "split", "sync", "cross", "link", "move", "repeat", "proxy", "crop", "transfer", "clip", "read", "download", "create", "cat", "slice", "map", "fit", "Cop", "delete", "write", "cop", "cp", "share", "upload", "gc", "Copy", "archive", "clone", "py", "php", "pixel", "opy", "zip"], "srcFS": ["sourceFS", "srcOS", " srcVS", "srfs", "srcFs", "srcCS", "sourceCS", "rcCS", "rcSF", " srcCS", " srcSF", "sysFS", "srcSF", "sourceVS", "srcVS", "sysFs", "srFs", "sourcefs", "srcfs", " srcfs", "rcfs", "rcFS", "sourceFs", "srMS", "srFS", "rcMS", "sysOS", "srcMS", "rcFs", " srcMS", " srcOS", "sourceSF", " srcFs", "sourceOS", "rcOS", "sysVS", "rcVS"], "src": ["path", "nil", "ser", "http", "proc", "node", "st", "addr", "RC", "boot", "sync", "SOURCE", "img", "init", "pkg", "sys", "tmp", "rx", "lb", "sin", "via", "sc", "rel", "rc", "dir", "desc", "from", "subject", "sub", "uri", "loc", "th", "resource", "obs", "filename", "Source", "rs", "spec", "pri", "iv", "syn", "comp", "req", "str", "ctr", "dest", "txt", "sec", "obj", "sit", "cont", "sn", "sr", "check", "source", "input", "selected", "secure", "sb", "https", "target", "inst", "url", "start", "sci", "usr", "sq", "supp", "cur"], "dst": ["deest", " ddest", "ddlt", "desdest", "dhdest", "dhst", "dST", " dST", "ddst", "dddest", "Dlt", "DDest", "dedest", "ddest", "DST", "dlt", "dsnd", "dgt", "deslt", "dsdest", "dsest", "Ddest", "ddnd", " dlt", "dslt", "dsST", "Dst", "lst", " dest", "desst", " dDest", "dsgt", "dest", "dDest", "ldest", "desnd", "lgt", "Dest", "dnd", "lest", "dsst", "degt", "dhDest", "dhlt"], "deleteSource": ["closeSOURCE", "deleteSources", "removeSource", "removeParent", "delSOURCE", "leteResult", "closeSite", "leteParent", "destroySources", "deleteParent", " deleteTarget", "destroyResult", "delDest", "leteSOURCE", "leteDest", "updateSource", "removeDest", "leteTarget", "DeleteSite", "updateSite", "deleteResult", "leteSource", "deleteTarget", "deleteDest", "destroyTarget", "deleteSOURCE", "updateSOURCE", "closeSourceFile", "leteSources", "updateSourceFile", "delParent", "DeleteSOURCE", " deleteResult", "destroySource", "closeSource", "deleteSourceFile", "deleteSite", " deleteSources", "delSource", "removeSOURCE", "DeleteSourceFile", "DeleteSource"], "conf": ["ch", "plan", "con", "ln", "config", "ban", "f", "params", "q", "prop", "pool", "scan", "css", "irm", "mm", "cms", "conv", "map", "cfg", "param", "acc", "cm", "ref", "Conf", "req", "cb", "comm", "fs", "lib", "conn", "check", "def", "hash", "m", "cn", "ctx", "cc", "log", "job", "comment", "co", "info", "cf", "com", "ca", "report", "cache"], "contents": ["constaves", "Content", "Contodes", " contresses", "Contents", "CONTodes", "contends", " Contresses", " contENTS", "contodes", "contresses", "CONTends", "CONTants", "constents", "CONTents", "constENTS", "Contterms", "CONTaves", "contENTS", " Contents", "content", "ContENT", "CONTterms", "CONTENTS", " Content", "CONTent", "CONTresses", " contENT", "Contants", " contodes", " ContENTS", " content", "contterms", "constends", "CONTENT", " contants", " contaves", " contterms", "contENT", "contants", "contaves", " contends"], "i": ["ims", "multi", "json", "im", "ms", "x", "j", "init", "n", "phi", "my", "it", "ai", "ini", "is", "ic", "ski", "ui", "ie", "me", "q", "id", "y", "o", "ci", "mi", "ind", "ki", "qi", "ii", "client", "gi", "hi", "key", "ti", "ji", "inner", "bi", "index", "si", "I", "span", "u", "ori", "ei", "m", "iter", "xi", "us", "iq", "cli", "ami", "docker", "di", "sim", "pi", "ij", "chain", "ip", "li", "oi", "\u0438", "ix"], "in": ["IN", "din", "con", "add", "by", "ini", "is", "ze", "mc", "and", "body", "raw", "sql", "read", "sample", "en", "inc", "from", "re", "ind", "ins", "bin", "inner", "doc", "reader", "xml", "isin", "r", "char", "In", "check", "input", "source", " din", "inn", "out", "inf", "cin"]}}
{"id1": "1862616", "id2": "19549577", "code1": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"fetch": [" fully", "tDownload", "fully", "confault", " fault", "fDownload", "tully", "confetch", "confully", "confDownload", "tault", "tetch", " fDownload", "fault"], "reference": ["path", "message", "pointer", "description", "location", "prefix", "template", "resolution", "attribute", "title", "condition", "address", "definition", "absolute", "sample", "create", "re", "reverse", "register", "note", "resource", "filename", "server", "relative", "ref", "library", "request", "index", "external", "number", "position", "directory", "href", "remote", "print", "string", "source", "value", "document", "Reference", "seek"], "url": ["http", "mail", "ls", "abs", "sl", "arl", "open", "build", "ur", "ul", "Url", "f", "q", "ml", "ob", "URL", "h", "au", "pl", "ssl", "dl", "loc", "nl", "atl", "ref", "g", "null", "str", "ll", "service", "l", "char", "gc", "base", "acl", "log", "job", "https", "web", "r", "hl"], "c": ["ch", "nc", "C", "con", "cu", "cur", "n", "com", "mc", "b", "f", "ct", "sc", "rc", "h", "enc", "ce", "ci", "cs", "conv", "t", "lc", "client", "ac", "v", "etc", "fc", "cm", "cr", "cin", "g", "tc", "ec", "cp", "cb", "dc", "l", "k", "pc", "bc", "cont", "cl", "ctrl", "z", "co", "cf", "r", "ca", "coll", "cache"]}}
{"id1": "13362846", "id2": "6379126", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setCont\u00ednU", "setcontensenux", "setContensenu", "setCont\u00ednue", "setContenux", "setContensenux", "setCont\u00ednux", "setContennU", "setContensenue", "setcontenu", "setContenue", "setContenU", "setcontenU", "setcontensenU", "setContennu", "setContensenU", "setcontenue", "setcontensenu", "setcontenux", "setCont\u00ednu", "setContennux", "setContennue", "setcontensenue"], "contenuFichier": ["contenuVechier", "contenuFicheaire", "contenuFiveraire", "contenuFamilyachier", "contenuVichyr", "contenuVchIER", "contenuFichie", "contenuVchie", "contenuMicheiere", "contenuFsrenchaire", "contenuFicheiere", "contenuFihiere", "contenuFrenchier", "contenuFsrenchieri", "contenuFechier", "contenuFileochiere", "contenuFsrenchire", "contenuVchier", "contenuFuffer", "contenuFchiere", "contenuFamilyichie", "contenuFignaire", "contenuFecher", "contenuFihier", "contenuFsechier", "contenuFichtIER", "contenuFileochiers", "contenuFsicher", "contenuFithyr", "contenuFolfire", "contenuFsrenchier", "contenuFChier", "contenuFamilyachie", "contenuVichIER", "contenuFsichieri", "contenuMicheaire", "contenuFechiest", "contenuFileichiere", "contenuFihiest", "contenuFechieri", "contenuFrenchieri", "contenuVichier", "contenuFithier", "contenuFolfier", "contenuMichiere", "contenuFithiest", "contenuFamilyachiere", "contenuVechiere", "contenuMicheier", "contenuFChaire", "contenuFachiers", "contenuFochier", "contenuFsichaire", "contenuFachorie", "contenuFachier", "contenuFiverieri", "contenuFileochie", "contenuFolfer", "contenuVechyr", "contenuFichIER", "contenuFsecher", "contenuVchiere", "contenuFicher", "contenuFigniere", "contenuFichieri", "contenuFechiere", "contenuFechire", "contenuFolfieri", "contenuMichaire", "contenuMicheer", "contenuFochie", "contenuFichire", "contenuFamilyichorie", "contenuFichiest", "contenuFachie", "contenuFicheorie", "contenuFsechire", "contenuFchier", "contenuFochiere", "contenuFamilyichiere", "contenuFileochier", "contenuFachiere", "contenuFiverire", "contenuFchIER", "contenuFamilyachorie", "contenuFignier", "contenuFochiers", "contenuFichaire", "contenuFsichire", "contenuFichtie", "contenuFsechieri", "contenuFichiers", "contenuFicheieri", "contenuFechyr", "contenuFiverier", "contenuFCher", "contenuFichorie", "contenuFChiere", "contenuFichtiere", "contenuFithie", "contenuFileichiers", "contenuFamilyichier", "contenuFicheiers", "contenuFrenchaire", "contenuFicheer", "contenuFithorie", "contenuVichie", "contenuFchie", "contenuFrenchire", "contenuFithiere", "contenuFuffieri", "contenuFihyr", "contenuFileichier", "contenuFuffire", "contenuMichier", "contenuFichtier", "contenuFicheier", "contenuFichyr", "contenuFichiere", "contenuVechiest", "contenuFuffier", "contenuMicher", "contenuFigner", "contenuVichiest", "contenuVichiere", "contenuFicheie", "contenuFochIER", "contenuFileichie", "contenuFicheire", "contenuFsichier"], "fichierElectronique": ["fichierelectronier", "fichierCentronique", "fichierElectRONique", "fichierAdministroniques", "fichierElectroneic", "fichierelectroniques", "fichierElectrenicy", "fichierelectrenique", "fichierCentRONius", "fichierSelectroneiques", "fichierElectrontique", "fichierelectronic", "fichierElectonique", "fichierElectRONaire", "fichierCentronicy", "fichierElectoniques", "fichierElectromius", "fichierElectonier", "fichierAdministroneiq", "fichierElectromie", "fichierElectchronicy", "fichierCentRONique", "fichierElectrontipolar", "fichierTransferronic", "fichierAdministronique", "fichierElectronsie", "fichierElectrenique", "fichierTransferradorie", "fichierElectromicity", "fichierElectronicity", "fichierAdministroniq", "fichierElectronie", "fichierElectrontaire", "fichierSelectroniques", "fichierElectroneiq", "fichierTransferronius", "fichierAdministroneique", "fichierTransferradorique", "fichierCentronius", "fichierCentRONaire", "fichierElectronsiques", "fichierElectreniques", "fichierElectroneius", "fichierElectronsiq", "fichierElectrenaire", "fichierElectradorius", "fichierElectronsicity", "fichierElectronius", "fichierElectromaire", "fichierElectromipolar", "fichierElectRONius", "fichierSelectronicity", "fichierSelectronique", "fichierSelectroneique", "fichierElectronoch", "fichierElectroneie", "fichierTransferradorius", "fichierElectchronaire", "fichierElectricie", "fichierElectRONicy", "fichierElectchronique", "fichierElectronipolar", "fichierElectroneoch", "fichierelectreniques", "fichierElectronier", "fichierAdministroneie", "fichierelectrenier", "fichierelectronique", "fichierTransferronique", "fichierElectrenius", "fichierAdministroneiques", "fichierElectronic", "fichierElectroniq", "fichierElectronsoch", "fichierElectchroniques", "fichierElectroneaire", "fichierElectricique", "fichierElectromic", "fichierElectchronicity", "fichierTransferronie", "fichierElectradorie", "fichierElectradorique", "fichierElectrenic", "fichierelectrenic", "fichierTransferradoric", "fichierElectrenier", "fichierElectroneicity", "fichierCentronaire", "fichierElectroneipolar", "fichierCentRONicy", "fichierSelectroneicity", "fichierElectriciq", "fichierElectromique", "fichierElectronaire", "fichierElectronsier", "fichierElectroniques", "fichierElectroneique", "fichierElectradoric", "fichierElectronsic", "fichierElectronicy", "fichierElectriciques", "fichierElectronticity", "fichierElectroneiques", "fichierElectchronoch", "fichierElectronsique", "fichierElectchronius", "fichierAdministronie", "fichierSelectronoch", "fichierElectonic", "fichierSelectroneoch"], "utilisateurCourant": ["utilisateurParticipant", "utilisateurGovernants", "utilisateurRepresentant", "utilisateursCourant", "utilisateursCouriant", "utilisateursGovernante", "utilisateurRepresentiant", "utilisateurGoverniant", "utilisateurGovernant", "utilisateurParticipants", "utilisateurGovernante", "utilisateursGoverniant", "utilisateurRepresentante", "utilisateurCourants", "utilisateursGovernant", "utilisateurParticipiant", "utilisateursGovernants", "utilisateursCourante", "utilisateursCourants", "utilisateurRepresentants", "utilisateurCourante", "utilisateurParticipante", "utilisateurCouriant"], "support": ["collection", "history", "replace", "access", "cover", "force", "supported", "see", " Support", "accept", "install", "help", "control", "use", "feature", "allow", "pport", "library", "trust", "null", "share", "know", "service", "SUP", "please", "language", "cap", "port", "profile", "system", "document", "evidence", "media", "format", "success", "context", "proof", "storage", "prototype", "supp", "Support"], "ficheDocument": [" ficheDatabase", "bacheDocument", "ficiDocument", "fitimeDocument", "fitimeDatabase", "bacheDatabase", "ficiMatrix", "fiqueDescription", "FicheDatabase", "facheJournal", "ficiTransaction", "frenchDatabase", "foyerDoc", "FicheDocument", "fayeDocuments", "fcheDocument", "hacheJournal", "FayeDoc", "fcheTree", "frenchDoc", "fliciDatabase", "ficiJournal", "bicheDocument", "fachedocument", "facheTransaction", "fifaDatabase", "bicheDoc", "fruitDocument", "facheTree", "frenchDescription", "bacheDoc", "fliciMatrix", "foyerDocument", " frenchDescription", "frenchTransaction", "fcheDoc", "hacheDocument", "fifaDocument", "flicheTransaction", "foyerDatabase", "hicheJournal", "ficidocument", "fayeDoc", "FicheDoc", "flicheDocument", "fliciDocument", "fitimeTransaction", "fiqueDatabase", "frenchDocument", "flicheDatabase", "fruitTransaction", "hichedocument", " frenchDocument", "fayeDatabase", "ficheMatrix", "fichedocument", "frenchMatrix", "hicheDocument", " frenchDatabase", "fruitdocument", "ficheJournal", "fliciTransaction", "foyerTree", "flicheMatrix", "bicheDatabase", "hachedocument", "fifaDoc", "facheDocument", "FayeDocument", "ficheDocuments", "fiqueDocument", "facheDatabase", "ficheDatabase", "ficheDoc", "ficheTransaction", "bacheTree", "hicheTransaction", "ficheDescription", "ficiDatabase", "bicheTree", "fruitJournal", "FicheDocuments", "fitimeMatrix", " ficheDescription", "fitimeDescription", "ficheTree", "hacheTransaction", "facheDoc", "frenchDocuments", "fcheDatabase", "fifaDocuments", "FayeDocuments", "FayeDatabase", "fayeDocument"], "nomFichier": ["nomFichomer", "nomFericier", "nomFcher", "nomFicier", "nomFicher", "nomPFoililler", "nomFchier", "nomFichIER", "nomFichoancer", "nomFachier", "nomFicomer", "nomFichie", "nomPFichiller", "nomUFichire", "nomFericIER", "nomFacherer", "nomNolfiere", "nomPichier", "nomFericanger", "nomFichiere", "nomFicire", "nomUFichIER", "nomFacher", "nomPFoilier", "nomNichie", "nomFoiljer", "nomFachery", "nomPachier", "nomFilicjer", "nomFicheire", "nomFiverire", "nomFiverIER", "nomFoilier", "nomFiverier", "nomFiverery", "nomFoilER", "nomFicER", "nomFchiner", "nomPFoiljer", "nomFachIER", "nomFichoIER", "nomNolfie", "nomFolfier", "nomFicheier", "nomFchomer", "nomFichire", "nomFachomer", "nomUFachier", "nomFihIER", "nomFericancer", "nomPachomer", "nomFiliciller", "nomUFachIER", "nomFolfiere", "nomPicherer", "nomNichire", "nomUFichier", "nomFachiere", "nomFicheer", "nomFichancer", "nomFilicER", "nomFchire", "nomFilicier", "nomFolfie", "nomFihery", "nomUFachery", "nomPichomer", "nomFachire", "nomFicerer", "nomNichiere", "nomFichoanger", "nomFicheiner", "nomFicjer", "nomPichire", "nomFachanger", "nomFichery", "nomFicheiere", "nomPFichER", "nomFchiere", "nomFcherer", "nomPFoilER", "nomFichanger", "nomFiciller", "nomFachie", "nomFolfire", "nomFichjer", "nomUFachire", "nomFichiller", "nomNolfier", "nomFachancer", "nomNolfire", "nomFoililler", "nomPacherer", "nomPFichier", "nomFicheie", "nomPFichjer", "nomFihire", "nomFichER", "nomFichiner", "nomPachire", "nomUFichery", "nomFicherer", "nomFichoier", "nomNichier", "nomFihier", "nomFachiner"], "extension": ["protension", "Extension", "expractor", "strension", "protention", "Extending", "xtensions", "Extensions", "contension", "expension", "protitude", "contention", "xtension", "extending", "expitude", "strensions", "extractor", "strending", "extitude", "protractor", "expention", "extention", "xtending", "extensions", "contitude", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueLocalistent", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusistant", "fichierElectronicityInert", "fichierElectroniqueEXistance", "fichierElectroniquePersistant", "fichierElectronogramLocalistent", "fichierElectroniqueAssclusive", "fichierElectroniquePresentiker", "fichierElectroniquePlusiker", "fichierElectroniqueLocalistant", "fichierElectronogramExistance", "fichierElectronogramLocalistant", "fichierElectroniqueAssistent", "fichierElectroniqueEXert", "fichierElectronicityExert", "fichierElectronogramExistent", "fichierElectroniqueExvant", "fichierElectroniqueExistent", "fichierElectronogramLocalclusive", "fichierElectroniqueInistent", "fichierElectronicityInistant", "fichierElectroniqueEXvant", "fichierElectroniqueInclusive", "fichierElectroniqueInistance", "fichierElectronogueExistant", "fichierElectroniqueLocalistance", "fichierElectronoguePersistent", "fichierElectronogramExclusive", "fichierElectronogramLocalistance", "fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityExistant", "fichierElectroniqueEXistant", "fichierElectroniqueExplvant", "fichierElectroniqueAssistance", "fichierElectroniqueExister", "fichierElectronicityInvant", "fichierElectroniqueExplistant", "fichierElectroniqueInistant", "fichierElectronogueExiker", "fichierElectroniqueExert", "fichierElectronogueExister", "fichierElectronogueExistent", "fichierElectronoguePersiker", "fichierElectroniqueInvant", "fichierElectroniquePersiker", "fichierElectroniqueExistance", "fichierElectronoguePersister", "fichierElectroniqueExplert", "fichierElectroniqueExclusive", "fichierElectroniquePresentistant", "fichierElectronicityExvant", "fichierElectroniqueInert", "fichierElectroniqueLocalclusive", "fichierElectroniqueAssistant", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectroniquePlusistent", "fichierElectroniquePresentister", "fichierElectroniqueExplistance", "fichierElectronicityInistance", "fichierElectroniquePresentistent"], "idIgid": ["idIgcid", "idImgids", "idIgaddress", "idIgcido", "idIIgid", "idIgcoid", "idIigmaddress", "idIIgoid", "idIgzida", "idIegids", "idIgida", "idIgzido", "idAmgaddress", "idAgid", "idAmgis", "idIgoid", "idIgdido", "idIgcida", "idIgido", "idIIgzid", "idImgaddress", "idIgdata", "idIegdata", "idIkglimit", "idIIgzoid", "idIIgzido", "idIkgis", "idAglimit", "idIegid", "idIigmlimit", "idAmglimit", "idIgids", "idIgzid", "idIigmid", "idIgis", "idIIgido", "idIgdid", "idIkgaddress", "idIgdoid", "idAmgid", "idAgaddress", "idIigmis", "idIgzoid", "idIgkey", "idIkgid", "idImglimit", "idIvgkey", "idImgkey", "idImgid", "idIegkey", "idIIgzida", "idIgdida", "idIvgid", "idIvgdata", "idAgis", "idIglimit", "idIvgids", "idImgdata", "idImgis", "idIIgida"], "inputStream": ["InputStream", "outputSteam", "inputTime", " inputThread", "inputstream", "InputSteam", "outputStreamer", "imageLoop", " inputStreamer", "Inputstream", " inputLoop", "imageTime", "helloSteam", " inputSteam", "InputLoop", "helloStreamer", "InputTime", "outputstream", " inputTime", "helloChannel", " inputChannel", "inputSteam", "inputThread", "outputThread", "InputThread", "inputLoop", "imageSteam", " inputstream", "outputChannel", "inputStreamer", "helloStream", "imageStream", "inputChannel"], "outputStream": ["sequenceStream", " outputStreamer", "outputSteam", "webView", "sequenceSteam", "outputStreamer", "inputView", "writeSteam", " outputStyle", "outputForm", "writeView", "OutputView", "webStream", "OutputSteam", "inputSteam", "outputView", "OutputStyle", "sequenceStreamer", "inputForm", "OutputStreamer", "webSteam", "webStreamer", "writeStream", "writeForm", "OutputStream", " outputSteam", "sequenceStyle", "OutputForm", " outputView", "outputStyle"], "typeMime": ["typeRime", "typeSmime", "TypemIME", "TypeMim", "typeSmme", "typeRme", "typeRIME", "typemIME", "TypeMime", "TypeMme", "typeRim", "typeSmim", "Typemime", "typeMim", "TypeMIME", "typeMIME", "typeSmIME", "typemime", "typemim", "Typemim", "Typemme", "typeMme", "typemme"], "tailleFichier": [" tailleFuzzie", " tailleficheiers", " tailleFixiers", " tailleFixie", " tailleFuzzies", " tailleficheies", " taillefichie", " tailleFuzziers", " tailleFixies", " tailleFuzzier", " tailleFicheier", " tailleFichiers", " tailleficheier", " taillefichier", " tailleFichies", " tailleficheie", " tailleFicheies", " taillefichies", " tailleFichie", " tailleFixier", " taillefichiers", " tailleFicheie", " tailleFicheiers"]}}
{"id1": "6517139", "id2": "8490297", "code1": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"getPrefsKey": ["getPrefoKey", "getPrefoValue", "getPrefixValue", "getPrefoData", "getPrefsValue", "getPrefskey", "getPrefmsData", "getPrefokey", "getPrefsData", "getPrefmsKey", "getPrefixkey", "getPrefixData", "getPrefmskey", "getPrefmsValue", "getPrefixKey"], "key": ["path", "message", "text", "json", "Key", "password", "description", "prefix", "phrase", "my", "unknown", "type", "ek", "item", "link", "secret", "address", "id", "y", "token", "default", "client", "KEY", "lock", "code", "null", "error", "name", "label", "str", "index", "service", "keys", "char", "ace", "k", "obj", "result", "base", "entry", "string", "hash", "value", "info", "data", "sk", "network"], "MD5": ["MDdown", "MDole", " MD4", "MD1", "HTML5", "MT2", "MD3", "MTole", "MD10", "MT3", " MDole", "HTML3", "md5", "md45", "MTdown", "md10", " MD10", "MP4", "HTMLdown", " MD6", "MD8", "MD2", "MD7", "HTMLole", " MD8", "DE3", "md8", " MD1", "MD4", "md4", " MD3", "md6", "MT7", " MD7", "MD6", "MT5", " MD45", "md7", " MDdown", "DE1", "DE5", "MP2", "md2", "md1", "MT6", "MD45", "DE45", "MT10", "MP3", " MD2", "MP5", "MT8", "md3"], "resultBytes": ["ResultByte", "resultsBytes", "Resultbytes", "resultBs", "resultsByte", "successBs", "successResults", "answerBs", "resultByte", "resultResults", " resultResults", " resultByte", "answerString", "successBytes", "resultString", "answerBytes", " resultBs", "answerResults", " resultbytes", "resultsbytes", "resultbytes", "ResultBytes", " resultString", "successString"]}}
{"id1": "8024375", "id2": "5049453", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomGuid", "getRandomGID", "getRandGid", "getRandomCid", "getRandUid", "getRandomGid", "getRandomUid", "getRandomUID", "getRandUuid", "getRandomSUID", "getRandomCUID", "getRandGUID", "getRandomUuid", "getRandUUID", "getRandomUUID", "getRandomCID", "getRandomSID", "getRandUID", "getRandomSuid", "getRandomCuid", "getRandGID", "getRandGuid", "getRandomSid"], "secure": [" Secure", "http", "prime", "sync", "force", "strong", "ie", "sys", "nice", "secret", "weak", "pretty", "ssl", "encrypted", "security", "client", "Secure", "server", "quiet", "confirmed", "stable", "clear", "trust", "google", "protect", "service", "sec", "sr", "dirty", "status", "active", " securely", "https", "safe", "sensitive", " insecure"], "md5": [" md6", "sha512", "mdle", "MD3", " md2", "metadata45", "MD512", " md45", "sha3", "md45", "MDle", "dig4", " md512", "dig3", "md512", "metadata2", "sha2", "sha5", "MD2", "MD4", "md4", "md6", " md3", "digle", "MD6", "sha6", "md2", "MD45", "metadata3", "MD5", "dig5", "metadata5", " md4", " mdle", "md3"], "sbValueBeforeMD5": ["sbValueBeforeIM2", "sbValueAfterMD1", "sbValueBeforeSM5", "sbValueBeforeMS5", "sbValueBeforeMT4", "sbValueBeforeND4", "sbValueAfterND2", "sbValueBeforeMP1", "sbValueBeforemdFound", "sbValueBeforeMD512", "sbValueBeforeDDFive", "sbValueBeforemdson", "sbValueBeforeSM4", "sbValueWithoutMD512", "sbValueBeforeND2", "sbValueBeforeMD65", "sbValueBeforeMDLeft", "sbValueBeforeDS512", "sbValueBeforeOLD512", "sbValueBeforeMDFound", "sbValueAfterMD65", "sbValueWithoutDD5", "sbValueBeforeMS2", "sbValueBeforeAMDFound", "sbValueBeforeIMLeft", "sbValueBeforeIM5", "sbValueBeforeMS3", "sbValueBeforeIM1", "sbValueBeforeOLD5", "sbValueBeforeMPLeft", "sbValueBeforemd2", "sbValueBeforeMOD5", "sbValueBeforeMT5", "sbValueBeforeSMson", "sbValueBeforeMD2", "sbValueBeforeMOD3", "sbValueBeforeSM2", "sbValueWithoutMD5", "sbValueWithoutMD2", "sbValueBeforeMD1", "sbValueAfterMDLeft", "sbValueBeforeAMD5", "sbValueAfterMDFive", "sbValueBeforeLM512", "sbValueBeforeMD4", "sbValueBeforeLM2", "sbValueAfterMD4", "sbValueBeforeMP2", "sbValueBeforeDD5", "sbValueAfterMD2", "sbValueAfterND4", "sbValueBeforeDS5", "sbValueBeforeDD512", "sbValueBeforeAMD2", "sbValueBeforeMOD2", "sbValueBeforeMT2", "sbValueBeforeMDFive", "sbValueBeforeMP5", "sbValueAfterNDson", "sbValueWithoutDD2", "sbValueBeforemd5", "sbValueBeforeMDson", "sbValueBeforeMOD1", "sbValueAfterMD5", "sbValueAfterMDFound", "sbValueAfterND5", "sbValueBeforeDS2", "sbValueBeforeDD65", "sbValueBeforeAMDson", "sbValueBeforeNDson", "sbValueBeforeOLD2", "sbValueBeforeMACFive", "sbValueBeforeMAC65", "sbValueBeforeMD3", "sbValueBeforeDD2", "sbValueBeforeND5", "sbValueAfterMD3", "sbValueBeforeMS1", "sbValueBeforeMAC5", "sbValueBeforeMAC2", "sbValueAfterMDson", "sbValueWithoutDD512", "sbValueBeforeMTson", "sbValueBeforeLM5"], "time": ["history", "TIME", "top", "est", "timeout", "counter", "now", "user", "hour", "times", "id", "runtime", "duration", "size", "frame", "Time", "t", "client", "etime", "current", "total", "timer", "length", "clock", "name", "estamp", "today", "ime", "rate", "tim", "set", "date", "value", "race", "system", "work", "year", "age", "start", "ts", "ty", "when"], "rand": ["dr", "rh", "reg", "nd", "rss", "init", "and", "rid", "seed", "roll", "rev", "id", "grad", "pick", "rc", "inv", "rad", "sample", "pid", "rd", "red", "mid", "std", "rank", "nt", "frac", "cr", "rt", "gz", "dist", "serial", "rot", "uid", "round", "rate", "sid", "quant", "hash", "gt", "did", "z", "sam", "range", "random", "res", "r", "ng", "gen", "Rand"], "valueBeforeMD5": ["valueBeforeND3", "valueAfterND5", "valueBeforeMT5", "valueAfterMD3", "valueBeforeMOD2", "valueAfterMD7", "valueBeforeMD3", "valueBeforeMOD5", "valueBeforeMC25", "valueAfterMD2", "valueBeforeMD2", "valueBeforeMC7", "valueBeforeND7", "valueBeforeMC2", "valueBeforeND2", "valueBeforeMD7", "valueBeforeND5", "valueAfterND3", "valueBeforeMT2", "valueBeforeMD25", "valueAfterND2", "valueBeforeMC5", "valueBeforeMT3", "valueBeforeMOD3", "valueBeforeMC3", "valueAfterND7", "valueBeforeMOD7", "valueBeforeMT25"], "array": ["collection", "buffer", "rays", "our", "expression", "binary", "instance", "a", "var", "response", "attribute", "address", "ary", "arrow", "raw", "av", "row", "sample", "area", "feature", "map", "arr", "length", "RAY", "pair", " Array", "atomic", "angle", "ray", "sh", "share", "external", "number", "vector", "record", "Array", "batch", "angular", "object", "hash", "archive", "range", "app", "data", "random", "audio", "storage", "image", "list", "ash"], "sb": ["ub", "bf", "db", "nb", "SB", "lb", "bp", "bis", "bps", "bs", "lp", "kb", "ob", "bsp", "sw", "hs", "bb", "sa", "erb", "ssl", "obs", "bt", "eb", "bg", "xb", "pb", "ib", "zb", "cb", "sh", "gb", "wb", "si", "sth", "sg", "gc", "sr", "rob", "abb", "ctrl", "bh", "sv", "soc", "sf", "sq", "rb"], "j": ["bot", "json", "jl", "it", "msg", "jack", "aj", "ct", "jj", "q", "je", "kj", "att", "jit", "ind", "ja", "dj", "uj", "t", "v", "js", "g", "ji", "key", "str", "jc", "ju", "index", "_", "yy", "jump", "obj", "k", "bj", "m", "J", "__", "us", "job", "z", "i", "br", "ij", "off", "jp", "oj", "jo", "ix"], "b": ["B", "bf", "db", "nb", "a", "bd", "bar", "bp", "bis", "bs", "y", "bound", "bb", "beta", "bu", "fb", "bt", "v", "ab", "eb", "bg", "be", "bi", "xb", "ib", "mb", "cb", "d", "gb", "u", "k", "bc", "ba", "br", "rb"], "valueAfterMD5": ["valueAfterID5", "valueAfterMD3", "valueAfterMD7", "valueBeforeMD3", "valueAfterMD2", "valueAftermd7", "valueAftermd5", "valueBeforeMD2", "valueBeforeMD7", "valueAfterID3", "valueAfterID7", "valueAfterID2", "valueAftermd2", "valueAftermd3"]}}
{"id1": "13644374", "id2": "5676111", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesForURL", "getBytesFromPage", "getByteFormURL", "getBytesfromPath", "getByteFromPath", "getBytesFormUrl", "getBytesfromURL", "getBytesForPage", "getBytesfromUrl", "getByteFormPath", "getBytesFromPath", "getByteFormPage", "getByteFromPage", "getBytesFormPage", "getBytesForPath", "getByteFromUrl", "getBytesForUrl", "getBytesFormURL", "getByteFromURL", "getByteFormUrl", "getBytesFromURL", "getBytesfromPage", "getBytesFormPath"], "url": ["path", "http", "html", "ls", "location", "sl", "build", "link", "ur", "Url", "ul", "address", "URL", "id", "pl", "default", "uri", "dl", "nl", "loc", "el", "ref", "name", "str", "xml", "ll", "l", "page", "base", "rect", "string", "domain", "parse", "web", "https", "full", "res", "host", "pattern"], "get": ["http", "load", "gets", "build", "put", "send", "body", "read", "download", "create", "like", "give", "call", "request", "pre", "g", "this", "pull", "post", "service", "Get", "let", "got", "check", "GET", "set", "select", "show", "parse", "find", "query", "search", "full", "ge", "we", "play", "exec"], "response": ["output", "message", "http", "application", "json", "block", "open", "onse", "connection", "body", "respond", "answer", "pos", "resp", "resource", "client", "yes", "content", "request", "tree", "version", "next", "still", "post", "service", "respons", "page", "Response", "result", "entry", "that", "object", "status", "reply", "document", "given", "success", "res", "successful", "soc", "image"], "entity": ["load", "json", "ity", "model", "se", "instance", "member", "ent", "user", "peer", "iso", "type", "me", "and", "put", "person", "em", "body", "eme", "ce", "icon", "note", "encrypted", "security", "resource", "el", "total", "ee", "client", "email", "content", "component", "le", "group", "any", "unit", "Entity", "one", "obj", "event", "result", "form", "pe", "record", "unique", "entry", "activity", "base", "object", "line", "comment", "document", "info", "data", "image"]}}
{"id1": "6418781", "id2": "6682825", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"client": ["http", "window", "cell", "block", "force", "controller", "and", "connection", "to", "channel", "component", "tree", "service", "ace", "cl", "secure", "web", "query", "url", "cli", "list", "con", "close", "template", "response", "util", "row", "control", "Client", "cm", "google", "obj", "conn", "remote", "entry", "batch", "chain", "co", "sim", "cmd", "builder", "bolt", "prefix", "manager", "local", "resource", "server", "nt", "contact", "get", "check", "cache", "system", "man", "self", "patch", "type", "plugin", "console", "ce", "wrapper", "call", "key", "store", "tc", "policy", "command", "base", "c", "pattern"], "names": ["states", "nos", "strings", "some", "ls", "ms", "n", "olds", "users", "types", "orders", "prints", "aos", "roots", "mas", "lines", "files", "rs", "books", "these", "said", "ns", "ids", "members", "terms", "sts", "AMES", "ans", "chains", "keys", "named", "nam", "ons", "models", "pres", "nets", "spe", "s", "idents", "papers", "aps", "ren", "ames", "objects"], "name": ["path", "nan", "node", "core", "n", "member", "user", "a", "me", "nm", "p", "id", "common", "create", "t", "filename", "NAME", "ame", "ename", "e", "key", " named", "str", " NAME", "l", "named", "nam", "entry", "string", "cn", "brain", "Name", "value", "comment", " Name", "data", "in", "out", "word", "c"], "ftpFiles": ["ftpsFiles", "afpOps", "aftpFiles", "ftfFile", "fttpFile", "ftnFiles", "ftniles", "fttpfiles", "etpfiles", "ftpsFile", "etpsiles", "fttpiles", "afpFiles", "fttpOps", "ftfTypes", "ftpsfiles", "afpTypes", "ftnFile", "etpFile", "ftpsiles", "fttpTypes", "etpsFiles", "etpsfiles", "ftfOps", "ftfFiles", "ftpTypes", "ftnfiles", "ftnOps", "aftpTypes", "ftpOps", "etpFiles", "aftpFile", "ftpiles", "afpFile", "etpiles", "fttpFiles", "ftpfiles", "etpsFile", "ftnTypes", "aftpOps"], "ftpFile": ["aftnFile", "ftpnfile", " ftpItem", "ftpDocument", "fttpItem", "fttpfile", " ftnFiles", "fltpFile", " ftnFile", "fltpfile", "ftnStyle", " ftpfile", " ftnfile", "flpFiles", "ftPStyle", "ftpfile", "ftpStyle", "ftnfile", "fttpFile", "ftnFiles", "ftnEntity", "aftpStyle", "ffpfile", "fftpDocument", "ftpnFiles", "ftrItem", " ftnItem", "ftpItem", "fftpFiles", "fttpStyle", "fttpDocument", "aftnStyle", "flpfile", "ftrEntity", "fttpEntity", "ftnFile", "ftpnDocument", "flpEntity", "aftnFiles", "ffpFiles", "flpFile", "ftrFiles", "ffpDocument", "ftnItem", "ftnDocument", "ftpEntity", "ffpFile", "aftpFiles", "aftpFile", "ftpnFile", "fltpEntity", "fftpFile", "fltpFiles", "ftPFiles", "ftrfile", "fttpFiles", "ftPFile", "fftpfile", "ftrFile"]}}
{"id1": "20091126", "id2": "7499186", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["load", "save", "sync", "open", "move", "y", "transfer", "cat", "download", "create", "to", "io", "map", "Cop", "call", "delete", "write", "store", "cp", "get", "upload", "Copy", "file", " Copy", "system", "Transfer", "clone", "paste"], "in": ["IN", "din", "gin", "init", "n", "ini", "rin", "b", "ck", "old", "ain", "id", "en", "inc", "io", "from", "mm", "ind", "ins", "el", "up", "inner", "isin", "r", "l", "In", "input", "source", "file", "i", "info", " din", "inn", " input", "inf", "cin"], "out": ["output", "ch", "self", "or", "x", "n", "Out", "it", "msg", "tmp", "b", " output", "as", "y", "p", "o", "to", "os", "end", "io", "ex", "outs", "t", "channel", "v", "ou", "nt", "e", "at", "write", "null", "w", "bytes", "one", "l", "_", "err", "result", "net", "OUT", "gt", "file", "log", " it", "co", "ot", " os", "s", "res", "c"], "inChannel": ["binRow", " inRow", " inCommand", "innChan", " inSection", "incChannel", "inChuck", "binSection", "inConnection", " inConnection", "conListener", "innConnection", "ginChain", "cinChannel", "insideChannel", "cinchannel", "inchannel", "InChannel", "InConnection", "conChannel", "INChannel", " inchannel", "ginChannel", "inChan", " inListener", "binCommand", "Inchannel", "binChuck", "INListener", "INConnection", "outBlock", " inChan", "outchannel", "inBlock", "inChain", "insideCommand", "inRow", "inSection", "inCommand", "incChuck", "INChan", "inListener", "ginChuck", "binPanel", "inPanel", "binChannel", "incPanel", " inBlock", "innChannel", "cinBlock", "cinCommand", "insideRow", "insideSection", "innchannel", "InChan", "conConnection", "conChan", "outCommand", "binChain", "ginPanel", "incChain"], "outChannel": ["inCh", "outCh", "OutChan", " outCh", "cosSlot", "moduleChannel", "skyChannel", "outputPassword", "OutChannel", "outputManager", "outUser", "outManager", "cmdChannel", "skyMany", "inchannel", "cmdMany", " outchannel", " outGate", "inChan", "OutCh", "cmdGate", "outGate", "outchannel", "OUTChannel", "OUTSlot", "OUTUser", "skyGate", "moduleChan", "cmdChan", "cosUser", "outSlot", "moduleManager", "outMany", "cosChannel", "inSlot", "outputChan", " outPassword", " outChan", "outChan", "skyChan", "inUser", "outputChannel", " outMany", "Outchannel", "OUTChan", " outManager", "cosChan", "modulePassword", "outPassword"]}}
{"id1": "6403868", "id2": "5035872", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUnpackItems", "extractUnInstallFiles", "extractunInstallFiles", "extractuninstallItems", "extractuninstallFiles", "extractunInstallItems", "extractUnpackFile", "extractUnpackFiles", "extractuninstallFile", "extractUninstallItems", "extractUnInstallItems", "extractUninstallFile", "extractUnInstallFile", "extractunInstallFile"], "_destPath": ["_DestPath", "_combPath", "_privDir", "_combDir", "_tempDir", "_destDir", "_srcPath", "_restPoint", "_DestKey", "_srcDir", "_DestPoint", "_restPath", "_combFormat", "_sourcePath", "_srcPoint", "_privPath", "_destFormat", "_destKey", "_restDir", "_sourceDir", "_DestDir", "_DestTh", "_privPoint", "_privTh", "_tempPath", "_tempFormat", "_tempTh", "_restKey", "_destPoint", "_destTh", "_srcKey", "_sourceFormat", "_tempPoint"], "upgrade": ["upcp", "exchange", "unate", " upchange", "upcheck", "equgrade", "excheck", "equcp", "equgrad", "downgrades", "downchange", "uncp", "equate", " upcp", "upchange", "ungrade", "exgrades", "upgrad", "upgrades", " upate", "exgrade", "downgrade", " upcheck", " upgrades", "ungrad", "upate", " upgrad", "downcheck"], "lastVer": [" lastVers", " lastServ", "lastServ", "lastVers", "nextVer", "latestServ", "LastVersion", " lastver", "nextServ", "latestRes", "lastRes", "oldVersion", "latestVers", "nextRes", " lastVersion", "nextVers", "oldver", "lastVersion", "LastVer", "oldVer", " lastRes", "lastver", "latestVer", "LastVers", "oldVers", "Lastver"], "oldlog": ["Oldlog", "OLDLog", "oldpath", "OLDlog", "Oldog", "OldLog", "olderog", "OLDpath", "OLDog", "olderpath", "oldog", " oldLog", " oldog", "olderLog", " olderr", "Oldpath", "olderlog", "oldLog", "olderr", "OLDerr", " oldpath", "oldererr"], "destPath": ["altParent", " destDirectory", "altNode", "destNet", "estPos", "originPath", "restDir", "gestNode", "declPath", "destFont", "descName", "locTime", "potPath", "identPort", "sortFont", "foreignPod", "altDir", "originPort", "sortDir", "foreignPath", "estDir", "DestPoint", "estRef", "DestPath", " destDir", " destPort", "destName", "estName", "destDir", "destLog", "DestParent", " destPos", "srcPath", "destRoot", "DestName", "privPath", "descPos", " destParent", "descDisk", "identPath", "altHost", "estPath", "privRoot", "destPos", "DestFont", "declFont", "DestStream", "DestFile", "destFile", "descPath", "destParent", "altPoint", "descTime", "potPod", "srcPort", "destTh", "DestDir", "destNode", "descNet", "descKey", "foreignStream", "DestPos", " destPoint", " destName", "restFile", "srcLog", "destHost", "locNet", "potStream", " destTh", "srcDir", "declFull", " destFile", "destRef", "restPath", "estKey", "destStream", " destHost", "sortFull", " destRef", " destNode", "destPoint", "destDisk", "gestDisk", "destTime", " destLog", "restPoint", "declDir", "DestFull", "privDir", "srcFile", "gestName", "altPath", "identPoint", "foreignDir", " destKey", "locDisk", "destPod", "DestPort", "DestRoot", "destDirectory", "destPort", "originPoint", "locPath", "sortPath", "destKey", " destRoot", "gestHost", "destFull", "DestRef", "DestPod", "DestLog", "potDir", "gestTime", "originTh", "altName", "srcDirectory", "privPos", "DestDirectory", "gestNet", "gestPath", "identTh"], "lastVerPath": ["lastVerForm", "highestVerFile", "lastverFile", "lastVersVal", " lastverDir", "lastVerFile", " lastVersPath", "lastVerVal", "lastverVal", "highestVERFile", "lastVerCh", "lastverForm", "highestVerpath", "lastVERDir", "lastVerpath", "lastVersLog", "lastverCh", "lastverName", "lastVersionCh", "lastVERFile", "lastVerDir", "lastVersFile", "lastVerLog", "lastVerName", "lastResPath", "highestVERVal", "lastverDir", " lastVersCh", "lastVERForm", "highestVerVal", " lastVersLog", "lastVersionpath", "lastVERpath", "lastVersPath", "lastVersionFile", "highestVERPath", " lastVerpath", "highestVerPath", "highestVERpath", " lastVerFile", "lastverPath", "lastResForm", "lastverLog", " lastverForm", "lastVERPath", "lastVersCh", "lastVERVal", " lastverpath", "lastverpath", " lastverPath", "lastRespath", " lastVerForm", "lastVersName", "lastVerspath", " lastVerName", " lastVerDir", " lastVersFile", "lastResDir", " lastVerCh", " lastVerLog", "lastVersionPath"], "bkdir": ["bakDir", "bqfd", "BkDIR", "blkgroup", " bkDir", "Bckdir", "bakdi", " bkkdir", "bckpath", "bkgrel", "bckfolder", "bkkDir", "bkkpath", " bakfolder", " bkkrel", "bckDir", "bkgDir", "blkdir", " bakdir", "bkgdir", "bukdir", "bkkdi", "bkjgroup", "bkpath", " bkdi", "bakrel", "bkgfolder", "bckdir", "bkfolder", "blkjdi", "bukpath", "BkDir", "bkDir", "bkjdi", "blkfd", "Bkpath", "bkgroup", "bqdir", "bkkDIR", "bqdi", "blkjdir", " bkfolder", "bakfolder", "bkfd", "Bkdir", "Bckpath", " bkkfolder", "bkdi", " bkkDir", "bckdi", " bakDir", "BckDIR", "bkrel", "blkjgroup", "bkkfolder", "bkkdir", "bkDIR", "BckDir", "bkkrel", "bakdir", " bakdi", "bkjdir", "bkjfd", "bukgroup", "bukDIR", "bqgroup", "bukdi", "bukfd", "blkjfd", "blkdi", " bkrel", "bukDir", "bckDIR"], "oldClassCopied": ["oldClassReplified", "oldClassReplied", "oldClassCopyified", "oldclasscopified", "oldClassCopie", "oldDirCopiated", "oldClassColied", "oldclassCopie", "oldClasscopried", "oldClassChied", "oldClasscopie", "oldclassCopies", "oldClassColaced", "oldClassReplried", "oldDirCopied", "oldClassCopyies", "oldDirRepliated", "oldClasscopies", "oldClassColified", "oldClasscopified", "oldClassCopies", "oldClassCopried", "oldclassCopied", "oldClassChiated", "oldClassCopiated", "oldclassCopified", "oldClassCopified", "oldclasscopie", "oldClassCopaced", "oldDirReplied", "oldClasscopiated", "oldclassCopaced", "oldDirReplried", "oldClassCopyie", "oldclasscopies", "oldClassChried", "oldClassCopyied", "oldClassColies", "oldDirCopies", "oldClassReplaced", "oldDirReplies", "oldClassChies", "oldClasscopied", "oldclasscopied", "oldClassReplies", "oldClassRepliated", "oldDirCopried"], "ls": ["las", "ists", "vs", "ms", "abs", "lf", "es", "ln", "sels", "la", "tl", "gs", "lt", "bs", "ds", "ws", "its", "qs", "ars", "xs", "les", "cs", "dl", "lines", "lc", "lists", "ics", "ps", "rs", "ils", "LS", "less", "ns", "ks", "ats", "l", "fs", "ols", "acts", "los", "lbs", "rl", "els", "ts", "lv", "irs", "lis"], "i": ["multi", "ims", "eu", "im", "zi", "x", "j", "init", "phi", "it", "a", "ini", "is", "ic", "ski", "ui", "ri", "b", "me", "fire", "id", "y", "io", "ci", "mi", "gu", "ki", "qi", "ii", "gi", "hi", "ti", "key", "bi", "ji", "index", "si", "I", "l", "u", "ei", "batch", "m", "xi", "us", "iq", "ami", "cli", "di", "sim", "pi", "chain", "ij", "ip", "li", "oi", "ix"]}}
{"id1": "19307120", "id2": "9647576", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": [" sendPOST", "doPost", "sendpost", "postPost", "sendPOST", " sendpost", "postText", "postpost", "doPOST", "postPOST", "doText", "dopost", " sendText", "sendText"], "url": ["path", "http", "mail", "ls", "location", "addr", "term", "sl", "ret", "build", "link", "ur", "Url", "ul", "address", "q", "URL", "pl", "ssl", "uri", "dl", "nl", "loc", "ref", "call", "str", "mount", "ll", "l", "u", "base", "string", "file", "log", "web", "https", "host", "pp"], "param": ["proc", "prom", "password", "ram", "prefix", "model", "term", "block", "config", "amp", "cal", "rem", "property", "params", "p", "prop", "row", "mm", "dem", "Param", "argument", "par", "tag", "pass", "key", "name", "post", "aram", "command", "mem", "project", "input", "string", "m", "meter", "padding", "option", "comment", "sp", "start", "conf", "commit"], "result": ["output", "buffer", "message", "reason", "description", "term", "cur", "valid", "ret", "response", "manager", "product", "p", "complete", "test", "true", "default", "answer", "feature", "current", "wrapper", "continue", "confirmed", "code", "request", "r", "sum", "command", "string", "status", "date", "value", "match", "comment", "results", "chain", "query", "data", "success", "memory", "found", "res", "diff", "temp", "report", "Result"], "httpurl": ["webconn", "httpsurl", "hconn", "webUrl", "webURL", "hUrl", "httpURL", "weburl", "workURL", "httpsURL", "workurl", " httpURL", "hURL", " httpUrl", "httpconn", "httpUrl", "workUrl", "httpsconn", "workconn", "httpsUrl", " httpconn", "hurl"], "httpConn": ["Httpconn", "hconn", "procConn", "HttpConn", "procObj", "httpCon", "httpCod", "httpConnection", "ttpObj", "procCod", "copCod", "hConnect", " httpCon", "httpsConnection", "copConn", "procCon", "httpsCon", "httpConnect", "copconn", "httpsConn", " httpConnection", "procConnection", "hoverConnection", "hoverconn", " httpCod", "hoverConn", "httpsConnect", "ttpCon", "HttpConnect", "ttpConn", "httpconn", "HttpCon", "httpsconn", "ttpConnection", "hoverConnect", " httpObj", "copCon", "hConn", "procconn", "ttpconn", "httpObj", " httpconn", "hConnection", " httpConnect"], "out": ["output", "ch", "cos", "timeout", "by", "n", "auto", "Out", "it", "init", "sys", "put", "flush", "p", "pretty", "o", "aos", "to", "os", "io", "OU", "ex", "outs", "conv", "up", "v", "ou", "nt", "all", "write", "inner", "writer", "w", "screen", "obj", "net", "print", "OUT", "check", "set", "oss", "co", "cmd", "outer"], "in": ["IN", "on", "per", "din", "gin", "by", "init", "se", "it", "oin", "rin", "ri", "is", "ic", "read", "en", "inc", "from", "mi", "re", "ind", "al", "ins", "er", "ma", "el", "bin", "inner", "reader", "isin", "In", "input", "iter", "i", "mn", " din", "inn", "inf", "cin"], "line": ["field", "message", "text", "cell", "lin", "block", "phrase", "ln", "se", "header", "eline", "link", "piece", "lane", "body", "row", "frame", "liner", "email", "continue", "le", "e", "code", "inline", "ine", "rule", "LINE", "ice", "l", "online", "page", "sequence", "record", "pe", "entry", "string", "print", "point", "iter", "port", "file", "stroke", "log", "comment", "chain", "lined", "ip", "Line"]}}
{"id1": "17202158", "id2": "15971794", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["findZoneIDs", "readLineID", "findLocalID", "readZoneNames", "readLineIDs", "findLocalIDS", "findZoneIDS", "readLocalNames", "readObjectIDS", "readLineNames", "readZoneID", "findLocalIDs", "readZoneIDS", "findZoneID", "readLocalIDs", "findZoneNames", "readLocalID", "findLocalNames", "readObjectNames", "readLocalIDS", "readObjectIDs", "readLineIDS", "readObjectID"], "zoneFileName": [" zoneFileChain", "ZonefileSpec", "zoneFileSource", "ZonefileSource", "zonefileFilename", "ZonefileType", "zonefileNames", "zonefilePath", "zoneDirSource", "ZonefileFilename", "zoneFolderFilename", "zonefileName", "ZoneFileName", "zoneFilePath", "zoneFILEType", "zoneFolderName", "zonefileSource", "zoneFILEPath", "ZonefileName", " zonefileName", "zoneFilesNames", "ZoneFileSource", "zoneFILENames", "ZoneFileFilename", "zoneFILEFilename", " zonefileChain", " zoneFileNames", "ZoneFileType", "ZoneFilePath", "zoneFileSpec", "zoneFilesPath", "zoneDirPath", "zonefileType", "zoneFilenameSource", "zoneFilenamePath", "zoneFilenameName", " zonefileNames", "zoneFILEName", "zoneFileType", "zoneDirSpec", "zoneFileFilename", "ZoneFileSpec", "zoneFolderPath", "zonefileChain", "ZonefilePath", "zoneFILEChain", " zonefilePath", "zoneFileChain", "zonefileSpec", "zoneDirName", "zoneFolderType", "zoneFileNames", "zoneFilenameSpec", "zoneFilesChain", "zoneFilesName", " zoneFilePath"], "zoneids": [" zoneuploads", "elementuploads", "zipids", "zonenames", "zonecodes", "znames", "zlines", "zuploads", " zoneoids", "tzids", "zcodes", " zonelines", "zaIDs", "tzIDs", " zoneIDs", "elementcodes", "tznaires", "zonelines", "elementids", "tzoids", "zipIDs", "zoneoids", " zonecodes", "zIDs", "zaoids", " zonenaires", "zonenaires", " zonenames", "elementlines", "ziplines", "zaids", "zoneuploads", "zids", "zipnames", "zanaires", "zoneIDs"], "url": ["http", "ls", "sl", "open", "ret", "build", "user", "bel", "ur", "lb", "Url", "ul", "f", "q", "URL", "loader", "rel", "ssl", "uri", "dl", "loc", "nl", "resource", "browser", "ref", "this", "name", "mount", "str", "ll", "l", "char", "result", "base", "cl", "lr", "rl", "file", "log", "web", "r"], "lnr": ["nlp", "linr", "cnrar", "lnn", "lnp", "cnp", "lenr", "lnrar", "nlr", "nldr", "nln", "lendr", "nlrar", "lnR", "linrar", "olndr", "lenR", "lenn", "nlR", "lncr", "olnR", "nlcr", "olnr", "linp", "lndr", "cnr", "cncr", "olnn", "lincr"], "line": ["message", "style", "text", "part", "cell", "block", "lin", "phrase", "ln", "section", "header", "eline", "link", "normal", "lane", "row", "sample", "frame", "nl", "liner", "continue", "le", "e", "code", "inline", "ine", "next", "LINE", "number", "stream", "day", "l", "char", "page", "online", "sequence", "net", "entry", "string", "print", "point", "stroke", "log", "file", "comment", "range", "chain", "display", "ge", "word", "Line"]}}
{"id1": "14865947", "id2": "7044685", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 1, "substitutes": {"execute": ["Command", "Action", " operate", " executes", " proceed", " evaluate", " Exec", "invoke", " parse", " Run", " query", " execution", " command", "Exec", "run", " manage", "process", " interpret", " eval", "exec", "command", " executing", " executed", " executable", " Execution", " resume", " executions", " dispatch"], "event": ["ev", "Ev", "se", "exc", "te", " environment", "xe", "ce", "frame", "ed", "ex", "t", " command", "ee", "E", "EE", " EVENT", " frame", "w", "ae", " Event", "pe", "command", " events", " invocation", "context", "de", "Event"], "shell": ["quit", "buffer", "bot", "message", "history", "session", "grid", "style", "html", "window", "Shell", "cell", "template", "sys", "detail", "microsoft", "b", "handle", "body", "tab", "root", "sql", "console", "pool", "h", "ssh", "help", "ja", "nl", "fr", "scope", "lock", "js", "tree", "pty", "sol", "sh", "screen", "tool", "l", "round", "line", "base", "tools", "theme", "hell", "sb", "system", "range", "query", "scroll", "search", "stack", "layout", "cli", "windows", "widget", "hl", "kernel"], "view": ["buffer", "ve", "vp", "html", "window", "block", "template", "iew", "vm", "ui", "see", "review", "row", "cv", "views", "VIEW", "v", "ou", "browser", "tree", "version", "w", "screen", "eye", "View", "tv", "show", "web", "document", "query", "display", "layout", "widget", "image", "report", "list"], "rootFolder": [" rootEntry", "RootDir", "RootDirectory", " rootDirectory", "coverDirectory", " rootCategory", "RootArea", "rootArea", "RootCategory", "coverLibrary", "rootCategory", "parentArea", " rootArea", "RootFolder", " rootDisk", "coverFolder", "parentFolder", "parentDir", "bottomDisk", "bottomLibrary", "parentCategory", "rootLibrary", " rootLibrary", "rootDisk", "RootEntry", "rootDir", "parentEntry", "bottomFolder", "rootDirectory", "coverDisk", "rootEntry", "bottomDirectory", " rootDir", "parentDirectory"], "dialog": ["dliz", " Dialog", "selectog", "Dialj", "dlj", "DialOG", "dloc", "choog", "choDialog", "dialDialog", "Dialog", "selectig", "selectDialog", "logig", "clig", " Dialoc", "callOG", "callogs", "callDialog", "closer", "Dialoc", "Dialogs", "logDialog", "dlog", "choOG", " Dializ", "dialoc", "choogs", "logoser", "clDialog", "dialig", "dialj", "selectoser", "logog", "dialoser", "dializ", "dialOG", "Dializ", "dialogs", " Dialj", "DialDialog", "callog", "clog"], "password": ["path", "buffer", "message", "expression", "description", "prefix", "words", "phrase", "hello", "user", "database", "response", "attribute", "secret", "address", "definition", "picture", "raw", "p", "wd", "reset", "encrypted", "Password", "login", "pass", "clear", "request", "PASS", "key", "sword", "shadow", "username", "directory", "command", "entry", "string", "source", "padding", "language", "hash", "table", "device", "comment", "query", "data", "paste", "word", "pattern"], "md5": [" md6", "ma64", "m2", " md2", " md64", "MD3", "MD512", "ma2", "md64", " md7", " md512", "m5", "md512", "mt5", "MD2", "mb512", "MD7", "MD4", "md4", "mt4", "m3", "md6", "mm7", "mb4", "md7", "MD6", "mb5", "MD64", "ma7", "md2", "ma5", "mt2", "mt3", "mm2", "mm6", "m4", "MD5", " md4", "mb2", "md3", "mm5"], "md": [" dd", "dr", "pm", "ms", "nd", "pdf", "sd", "msg", "mc", "bd", "od", "metadata", "ct", "MD", "cd", "mg", "mm", "dm", "mt", "ind", "rm", "red", "pt", "sm", "dh", "nt", "det", "ld", "magic", "dd", "d", " Md", "mb", "mac", "mk", "mod", "dig", "pd", "m", "hash", "df", "mn", "cmd", "hd", "de"]}}
{"id1": "9956095", "id2": "8932510", "code1": "    public void exportNotesToServer() {\n        boolean uploaded = true;\n        try {\n            File f = new File(UserSettings.getInstance().getNotesFile());\n            FileInputStream fis = new FileInputStream(f);\n            String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName();\n            setDefaultAuthenticator();\n            URL url = new URL(urlString);\n            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n            urlc.setDoOutput(true);\n            urlc.setRequestMethod(\"PUT\");\n            OutputStream os = urlc.getOutputStream();\n            int nextByte = fis.read();\n            while (nextByte != -1) {\n                os.write(nextByte);\n                nextByte = fis.read();\n            }\n            fis.close();\n            os.close();\n            if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP_NO_CONTENT) {\n                uploaded = false;\n            }\n        } catch (SSLHandshakeException e) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.sslcertificateerror\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n            uploaded = false;\n        } catch (Exception e) {\n            uploaded = false;\n        }\n        if (uploaded) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"info.notesfileuploaded\"), I18N.getInstance().getString(\"info.title\"), JOptionPane.INFORMATION_MESSAGE);\n        } else {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.notesfilenotuploaded\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"exportNotesToServer": [" uploadNotesFromserver", " uploadNotestoRemote", " uploadNotesToserver", " uploadNotestoserver", " uploadNotestoServer", " uploadNotesToServer", " uploadNotesToRemote", " uploadNotesFromServer", " uploadNotesFromRemote"], "f": ["fn", "bf", "lf", "fo", "ef", "fe", "b", "p", "fi", "o", "h", "fp", "File", "ft", "t", "fb", "files", "v", "fc", "fm", "uf", "e", "g", "fl", "fac", "rf", "l", "fs", "tf", "file", "i", "F", "cf", "fd", "r", "sf", "c", "fa"], "fis": [" fi", "fbIs", " fIs", "fiis", "tis", "FIs", "Fisin", "fileis", "fii", "bois", "fiois", "sfIS", "fisin", "bis", "xfis", " fris", "Fis", "fi", "tris", "sfIs", "sfis", "fIS", "bir", "fli", "fbis", "xfi", "filebis", "flis", "fbisin", "sfris", "bi", "fileisin", "fIs", "tIs", " fois", "Fi", "xfir", "fois", "flois", "Fois", "tIS", "fiir", "fileIs", "fir", "fbbis", " fIS", "xfois", "fris", "Fbis"], "urlString": ["UrlString", "nlSimple", "nlString", " urlSimple", "nlstring", " urlstring", "urlSimple", "urlstring", "urlStr", "lString", "lstring", "UrlSimple", "Urlstring", "UrlStr", "nlStr", " urlStr", "lStr"], "url": ["http", "ls", "location", "abs", "sl", "open", "ret", "build", "bel", "ur", "Url", "ul", "ml", "URL", "api", "console", "ssl", "dl", "uri", "nl", "atl", "t", "el", "browser", "gl", "ref", "str", "impl", "ll", "l", "ocl", "base", "cl", "rl", "log", "ctrl", "https", "r", "hl", "c", "il"], "urlc": ["toolco", " urlp", "urlcr", "methodcd", "URLc", " urlci", " urlconst", "urlC", "urlcm", "llp", "tool2", "makem", "makec", "buildco", "build2", "urlconst", " urlcon", " urlchain", "makeconst", "Urlci", " urlcr", "urlcd", " urlC", "llco", "dlci", "llc", "dlc", "urlp", "URLC", " url2", "urlcon", " urllc", "url2", "pullc", "pullm", "urlci", "implci", "urcd", "urcr", "methodcr", " urlcp", "implc", "pullco", " urlm", "slc", "Urlc", "Urlcm", "llC", "slci", "implcon", "makeco", "Urlcon", " urlcd", "urc", "buildc", "urlcp", "methodlc", " urlco", "slm", "toolcp", "implcm", "methodc", "urllc", "URLp", "slchain", "toolc", "urlco", "pullconst", "urlm", "dlm", " urlcm", "dlchain", "urlchain", "buildcp", "URLco"], "os": ["mos", "cos", "out", "ms", "es", "OS", "oos", "dis", "ops", "is", "sys", "ows", "uts", "bos", "osi", "bs", "ob", "dos", "o", "aos", "io", "css", "ost", "obs", "pos", "ps", "ones", "ox", "oS", "js", "oa", "Os", "fs", "ols", "los", "us", "ose", "oss", "ros", "ios", "ot", "i", "oes", "oses", "ts"], "nextByte": ["continueByte", " nextbyte", "NextBytes", "continueBit", "NextLine", "continuebyte", "firstbyte", "currentbyte", "currentByte", "firstBytes", "NextByte", " nextLine", "NextChar", "nextChar", "firstChar", "Nextbyte", " nextChar", "nextbyte", "nextBit", " nextBytes", "NextBit", "nextBytes", "currentLine", "nextLine", " nextBit", "currentBytes", "continueChar", "firstByte"], "uploaded": ["streamored", "acceptisted", "Uploadened", "requestred", "accessated", "ploaded", "streamated", "uploadd", "ploadated", " uploadeded", "Uploaded", " uploadededed", " uploadated", " uploadedisted", "accesseded", "accepted", "hosted", " uploadedored", "uploadended", "uploadeded", "uploadized", "hostred", "Uploadended", "hostated", "acceptated", " uploadened", "uploadsied", "otted", "Uploadred", " uploadedED", " uploadisted", "ploadended", "streamed", "requestated", "acceptied", "streameded", "requestd", "uploadisted", "ottied", "ottized", "Uploadd", "uploadened", "uploadied", " uploadED", "accessed", "ottated", "uploadsized", "uploadated", "uploadsed", "hostd", " uploadended", "uploadred", "requested", "ploadened", "uploadED", "accessored", "uploadored", "Uploadated", "acceptED", " uploadedated", "uploadsated", "acceptized"]}}
{"id1": "19584877", "id2": "13595251", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "5607440", "id2": "21368981", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBin", "updateShowshipSpans", "updateShowshipBeans", "updateShowshipSpan", "updateShoppingMein", "updateShoppingSpin", "updateShowshipSpaning", "updateShoppingMeaning", "updateShowshipBein", "updateShowshipSpin", "updateShoppingSpans", "updateShowshipBean", "updateShoppingBein", "updateShoppingSpaning", "updateShoppingBan", "updateShowshipBeaning", "updateShoppingSpan", "updateShoppingBaning", "updateShoppingMeans", "updateShoppingMean", "updateShoppingBeaning", "updateShoppingBeans", "updateShoppingBans"], "userId": ["clientId", "clientid", "clientPath", "USERId", "UserName", "UserReference", "userReference", "userPath", " userName", "clientName", "USERLog", " userLog", "userName", " userReference", "UserLog", "USERName", "userid", " userPath", "USERReference", "UserPath", " userid", "UserId", "Userid", "userLog"], "connection": ["collection", "bo", "output", "management", "application", "connect", "pointer", "session", "Connection", "con", "ion", "close", "function", "config", "open", "database", "generation", "response", "statement", "manager", "condition", "link", "reference", "socket", "sql", "usage", "character", "relation", "creator", "subject", "client", "resource", "server", "library", "settings", "office", " Connection", "writer", "communication", "operation", "engine", "container", "license", "directory", "conn", "command", "entry", "information", "table", "driver", "document", "query", "context", "city", "c", "computer", "network"], "preparedStatement1": ["preparedRequestOne", "preparedStatement9", "preparedQuery7", "preparedTransaction1", "preparedComment2", "preparedPolicyn", "preparedComment5", "prearedStatement10", "prequalifiedStatement6", "prequalifiedStatOne", "preparedStatOne", "preprotectedStatement1", "preparedPolicy1", "preparedStatus12", "prearedStatementOne", "preculatedComment7", "preparedstatement4", "preparedComment8", "prearedQueryn", "preprotectedTemplate1", "preparedTransaction2", "preparedStatement6", "preparedTransaction9", "preparedComment4", "preparedPolicy10", "preparedStatement8", "preparedTransactionOne", "preparedComment1", "preparedMessage8", "preparedStatus1", "preparedRequest1", "preparedstatement5", "preparedMessage1", "preparedRequest4", "preparedStatementn", "preprotectedTemplate12", "preparedstatement1", "preparedstatement2", "prequalifiedStatement1", "preparedStatus11", "preculatedComment1", "preparedTransaction12", "preparedQuery2", "preparedTemplate11", "preparedStatement4", "preparedStatn", "preparedStat10", "prequalifiedStat1", "preparedQuery4", "preparedQueryn", "preparedQuery1", "prearedQuery5", "preparedMessage7", "preparedStatementOne", "preparedMessageOne", "prearedStatement2", "preparedCommentOne", "prequalifiedStatement2", "preparedTemplate1", "preparedstatementOne", "preprotectedTemplate11", "preparedStatement5", "prearedQuery10", "preparedStatementONE", "prearedQueryOne", "preparedStat6", "prequalifiedStat2", "preparedTransaction10", "preparedQuery10", "preparedQuery8", "preprotectedStatement11", "prearedQuery4", "preparedStatement11", "preprotectedStatement9", "preparedQuery5", "preparedComment7", "preculatedCommentOne", "preparedTransaction11", "preparedStat1", "preprotectedStatement12", "prearedStatement5", "preparedTemplate12", "preculatedStatementOne", "preparedQueryOne", "preculatedComment8", "preculatedStatement7", "preparedStat2", "preparedStatement10", "preparedTemplate9", "preparedStatus9", "preparedQueryONE", "prearedStatementn", "prequalifiedStatementOne", "preparedStatONE", "preculatedStatement1", "preculatedStatement8", "preprotectedTemplate9", "preparedPolicyOne", "preparedRequest2", "prearedQuery2", "preparedStatement12", "prequalifiedStat6", "prearedStatement1", "prearedStatement4", "prearedQuery1", "preparedStatement7"], "preparedStatement2": ["preparedListTwo", "preededStatementSecond", "preparedstatementSecond", "preparedTransaction1", "prearedStatementTwo", "prearedStatementSecond", "preparedTransaction4", "preededStatement2", "prearedStatement2", "preededTransactionTwo", "preededTransactionSecond", "preparedstatement2", "preparedSessionTwo", "preededStatement4", "preparedListSecond", "preparedstatementTwo", "preparedTransactionSecond", "preparedList1", "preparedTransactionTwo", "preededTransaction2", "preparedSessionSecond", "preparedStatement4", "preparedstatement4", "preededTransaction4", "preparedStatementTwo", "preparedSession4", "preparedStatementSecond", "preparedTransaction2", "preparedSession2", "preededStatementTwo", "prearedStatement1", "preparedList2"], "preparedQuery": ["PrearedString", "preferredQu", "precedQuery", "postaredQuery", "preparedString", "PreparedStatement", "prelatedQ", "prelatedQu", "prearedQuery", "PreparedQuery", "preutedQuery", "preferredString", "prearedStatement", "prelatedQuery", "prefixedQu", "premittedQL", "prefixedStatement", "preutedString", "prearedQL", "preparedSpec", "prearedString", "preparedQ", "postaredQL", "PreparedQ", "premediatedQu", "preutedQu", "premediatedQ", "prearedSpec", "PreparedQu", "postparedQL", "preferredQuery", "postparedStatement", "premittedStatement", "preferredQL", "prelatedStatement", "preparedStatement", "postaredStatement", "prearedQu", "preparedQu", "PreparedString", "PrearedQu", "postparedQuery", "precedSpec", "PrearedQ", "premittedQuery", "premediatedQuery", "PreparedSpec", "preparedQL", "preferredStatement", "preutedStatement", "PrearedQuery", "precedStatement", "premediatedStatement", "prearedQ", "precedQu", "PrearedStatement", "prefixedQuery", "prefixedSpec", "PrearedSpec"], "date": ["message", "now", "time", "user", "draw", "zone", "grade", "address", "dat", "state", "duration", "late", "dt", "note", "month", "Date", "tag", " day", "office", "dated", "number", "day", "get", "today", "event", "result", "status", "value", "render", "document", "query", "data", "year", "age", "order", "start", "diff", "ate", "when"], "format": ["output", "fn", "printf", "style", "function", "html", "add", "prefix", "template", "it", "type", "apply", "sort", "after", "filter", "f", "api", "pretty", " Format", "export", "cat", "sche", "late", "mt", "dt", "use", "Format", "spec", "transform", "tag", "call", "at", "write", "pre", "writer", "process", "fix", "unit", "handler", "get", "service", "scale", "license", "atter", "form", "print", "string", "set", "file", "value", "render", "parse", "join", "data", "append", "layout", "act", "pattern"], "orderDate": ["gradeDay", " orderDeliveryDate", "orderedNow", "gradeDeliveryDate", "OrderDay", "gradedate", "orderYear", "orderNow", "OrderDeliveryDate", " orderdate", " orderDay", "orderedYear", " orderYear", "gradeDate", "orderDay", "OrderDate", "orderedDay", "orderDeliveryDate", "orderdate", "Orderdate", "OrderYear", "orderedDate", "OrderNow", " orderNow"], "iterator": ["collection", "runner", "udder", "history", "list", "pointer", "rounder", "ator", "counter", "instance", "database", "loop", "versions", "processor", "internet", "pee", "loader", "integer", "starter", "size", "sample", "creator", "pie", "older", "later", "video", "liner", "filename", "wrapper", "ater", "operator", "river", "inner", "chest", "writer", "next", "reader", "dump", "stream", "ippy", "ter", "vector", "sequence", "directory", "upper", "values", "former", "consider", "set", "sequ", "iter", "cache", "race", "network", "chain", "era", "walker", "info", "data", "finder", "trace", "outer", "storage", "Iterator", "information"], "shoppingInfo": ["shippingInf", "sharingInformation", "choppingData", "shillingInf", "shoutingData", "ShippingData", "ShippingInformation", "shoutingInfo", "choppingInfo", "shillingDetails", "shoutingDetails", "ShoppingData", "ShoppingInf", "shoutingInf", "shppingInformation", "ShoppingInfo", "shoppingInformation", "shoppingInf", "choppingINFO", "shippingData", "ShoppingInformation", "choppingInf", "shitchingData", "sharingInf", "shitchingInf", "shootingData", "shippingInfo", "shoppingINFO", "ShippingInfo", "shppingINFO", "shoppingData", "shoppingDetails", "ShippingDetails", "sharingInfo", "chootingINFO", "chootingInf", "sharingData", "chootingData", "shitchingInfo", "shppingData", "shippingDetails", "shillingInfo", "shillingData", "shppingInf", "shppingInfo", "chootingInfo", "shootingINFO", "ShippingInf", "shippingINFO", "shippingInformation", "shootingInf", "ShoppingDetails", "shootingInfo"], "product": ["collection", "application", "per", "top", "node", "products", "program", "template", "attribute", "processor", "property", "id", "image", "common", "relation", "client", "resource", "production", "category", "qualified", "operator", "translation", "Product", "module", "process", "name", "division", "contact", "position", "service", "brand", "result", "print", "command", "project", "base", "source", "object", "device", "material", "shop", "system", "document", "cart", "pi", "media", "pixel", "prototype", "order", "article"], "quantity": ["qualitude", "quantularity", "severicity", "qualularity", "percenticity", "materialularity", "materialency", "Quantularity", "Quantication", "percentitude", "severularity", "materialication", "quantitude", " quanti", " quantify", "percentify", "quality", "quantency", "quanti", "quantication", "Quantity", "percenti", "quanticity", "parify", "materiality", "severency", "quantify", "pari", "percentularity", "severication", "parity", "severity", "Quantency", "parularity", "qualicity", "severitude", " quantularity", "percentity"], "cartInfo": ["CartData", "cartInf", " cartINFO", "artInf", "cotCheck", "chipCheck", "artInfo", " cartData", "cartNote", "cartINFO", " cartNote", "chantInfo", "chantData", " cartCheck", "cartData", " cartInformation", " cartInf", "cartNotice", "chipNote", "CartINFO", "CartInf", "cotInfo", "CartInformation", "cartCheck", "artData", "cotData", "commerceNotice", "chantINFO", "cartInformation", "commerceINFO", "armInfo", "chipData", "chipInfo", "CartInfo", "armData", "artInformation", "commerceInfo", "chantNotice", "commerceData", "armInf", " cartNotice", "armINFO", "cotNote"], "i": ["multi", "ims", "ite", "im", "init", "phi", "it", "ini", "ai", "is", "ic", "ui", "ip", "me", "iu", "p", "y", "fi", "h", "o", "io", "mi", "ci", "ii", "t", "v", "gi", "hi", "ti", "bi", "si", "ice", "I", "l", "u", "m", "xi", "ori", "ami", "di", "pi", "info", "ij", "s", "cli", "li", "ix"], "productList": [" productlist", "productOrder", " productOrder", "currentList", "processList", "cartOrder", "currentlist", " productLibrary", "currentLibrary", " productLIST", "processlist", "cartList", "productlist", "processOrder", "currentLIST", "productLIST", "cartlist", "cartLibrary", "cartLIST", "productLibrary"], "components": ["ompresses", "condositories", "Compcomponent", "comports", "supputes", "compducers", " compresses", "Compositories", "condresses", "compcomponent", "proonents", "ompositories", " compositories", "coponents", "ompducers", " Compositories", "commonents", "Compresses", "omponents", " Components", "commonent", "supponent", "commorts", "Components", "supponents", "producers", "coports", "commutes", " Compresses", "coponent", "condonents", " Compcomponent", "computes", "condducers", " compcomponent", "compositories", "compresses", "coputes", "supports", "proresses", "proositories"], "j": ["connect", "json", "jl", "n", "item", "aj", "Database", "jj", "q", "p", "sql", "kj", "Connect", "ja", "insert", "v", "js", "this", "g", "ji", "jc", "l", "k", "obj", "m", "J", "select", "z", "SELECT", "ij", " ii", "jp", "query", "Insert", "oj", "jo"]}}
{"id1": "1954410", "id2": "536614", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doExecute": ["doEditute", "doCommutes", "doCommExec", "DoExecute", "DoExecit", "doCommit", "DoExecutes", "doExecutes", "doExecit", "doEditit", "DoExecExec", "doExecExec", "doEditutes", "doCommute", "doEditExec"], "mapping": ["smappings", " mappings", "mapper", "Mappings", "mapped", " mapped", "Mapper", "Mapped", " mapper", "smapped", "mappings", "Mapping", "smapper", "smapping"], "form": ["path", " forms", "orm", "session", "owner", "self", "template", "config", "type", "f", "raw", "forms", " Form", " FORM", "subject", "map", "Form", "parent", "fc", "view", "formed", "command", "FORM", "m", "sam", "app", "format"], "request": ["http", "window", "se", "instance", "sw", "parent", "version", "upload", "Request", "query", "url", "report", "QUEST", "template", "create", "allow", "this", "impl", "quest", "container", "_", "w", "remote", "project", "def", "document", "application", "session", "Upload", "model", "address", "Exception", "reset", "frame", "client", "resource", "current", "server", "xml", "view", "input", "first", "order", "question", "message", "open", "user", "reference", "true", "initial", "req", "store", "post", "cont", "command", "context", "host"], "response": ["output", "message", "application", "session", "connection", "send", "ce", "re", "respond", "frame", "resp", "server", "content", "write", "view", "xml", "Response", "result", "print", "status", "reply", "sp", "document", "success", "res", "report"], "errors": [" mess", " steps", " messages", " success", " managers", " logs", " messenger", " sessions", " manager", " storage", " changes", " fails", " requests", " flashes", " status", " statements", " error", " states", " problems", " state", " warnings", " flash", " updates", " moves", " elements", "Mess", "ages", " Messages"], "isMultipart": ["isMultipod", "isMultipain", "isMultIPare", "isMultiade", "isMultiplod", "isMultiIPod", "isMultifarts", "isMultiparts", "isMultosparts", "isMultiipart", "isMultiIPade", "isMultipare", "isMultIPain", "isMultiarts", "isMultifare", "isMultiIPain", "isMultiplarts", "isMultiIPare", "isMultiIPart", "isMultIPade", "isMultiiparts", "isMultifart", "isMultiipare", "isMultospart", "isMultIParts", "isMultospain", "isMultiart", "isMultiipain", "isMultiod", "isMultospare", "isMultiplade", "isMultIPod", "isMultipade", "isMultiplart", "isMultiipade", "isMultifain", "isMultiipod", "isMultiIParts", "isMultIPart"], "mailInstance": ["flexance", " mailance", " mailInst", "mailinstance", " mailBuilder", " MailInstance", " Mailinstance", "emailance", "emailBuilder", "mailance", " MailBuilder", "flexInstance", "mailInst", "flexinstance", "flexInst", "emailinstance", " MailInst", "mailBuilder", "emailInstance", "emailInst", " mailinstance"], "fields": ["field", "states", "faces", "strings", "links", "balls", "properties", "headers", "workers", "types", "orders", "posts", "users", "ports", "locks", "checks", "prints", "plugins", "drivers", "comments", "images", "frames", "sections", "qs", "forms", "rows", "boxes", "rules", "views", "flags", "pages", "packs", "files", "dates", "lists", "bits", "lines", "tags", "classes", "levels", "packages", "tests", "holders", "features", "members", "terms", "days", "keys", "parts", "details", "models", "reports", "phones", "relations", "lights", "modules", "names", "groups", "atts", "objects", "services"], "attachments": ["achensions", "attensions", " attachions", "payances", " attachresses", "attitions", "attachMENTS", "payements", "attachitions", "acheements", "attachensions", "Attachments", " attachements", "attachions", "achMENTS", "acheances", "Attachresses", "achements", "attMENTS", " attachitions", "AttachMENTS", " attachances", "payitions", "achitions", "Attachions", "achments", "attachresses", "attachements", "payments", "achresses", "attments", "achions", "Attachensions", "attachances", "Attachitions", "acheitions"], "items": ["cases", "links", "orders", " Items", "images", "Items", " images", "its", "rows", "pages", "qs", "files", "lines", "tests", "packages", "photos", " files", "actions", "ids", " results", "members", "ips", "archives", "keys", "parts", "reports", "phones", "apps", "resources", "results", "names", " samples", " inputs", "issues", "groups", "events", "objects", "services"], "iter": ["each", "ser", "ite", "ator", "iner", "init", "it", "Iter", "loop", "orient", "li", "its", "read", "iterator", "test", "maker", "altern", "re", "older", "ind", "dir", "er", "oper", "loc", "el", "cmp", "inner", "store", "writer", "ait", "reader", "inter", "coll", "ipper", "tr", "ter", "Iterator", "result", "tif", "upper", "ner", "former", "set", "gener", "i", "walker", "outer", "list", "order"], "item": ["cell", "member", "instance", "it", "change", "attribute", "att", "element", "atom", "inner", "other", "status", "file", "job", "url", "word", "zip", "on", "json", "internal", "or", "template", "link", "entity", "claim", "row", "ex", "group", "name", "obj", "anything", "details", "entry", "object", "data", "ip", "attr", "add", "local", "area", "mm", "er", "resource", "up", "rule", "xml", "unit", "one", "page", "stat", "app", "order", "step", "addr", "type", "detail", "raw", "Item", "initial", "el", "spec", "key", "related", "store", "module", "event", "record", "layer", "match", "info", "image", "ix", "single"], "aux": ["af", "eu", "abs", "cu", "auto", "used", "uds", "aim", "aos", "area", "av", "airs", "au", "ex", "AU", "etc", "ox", "lim", "aff", "buff", "fax", "uf", "du", "aus", "ax", "fx", "net", "fuck", "imp", "pet", "extra", "tx", "us", "vers", "mu", "max", "fu", "uff", "ux", "off", "foo", "fam", "pad", "aw", "ras", "ups", "ix", "fat"], "part": ["top", "block", "member", "peer", "tmp", "and", "zone", "bound", "card", "parent", "component", "pre", "inner", "version", "job", " parts", "work", "art", "word", "list", "split", "pos", "pair", "photo", "group", "mod", "print", "partial", "object", "sp", "Part", "start", "temp", "html", "add", "prefix", "section", "worker", "person", "local", "relation", "PART", "pod", " Part", "pet", "tx", "join", "admin", "message", "party", "patch", "step", "pkg", "detail", "piece", "tab", "p", "api", "sample", "pt", "par", "wrapper", "comp", "parts", "half", "base", "point", "primary", "layer", "pad", "format"], "baos": ["booses", "baops", "waols", "boOS", "cao", "kaops", "pois", "bais", "waoss", "caOs", "bios", "taos", "taoss", "baols", "pooss", "kaoss", "bio", "bao", "booss", "baOs", "kais", "vaOs", "caoss", "caOS", "vaols", "boOs", "tao", "biOS", "boos", "kaos", "baOS", "poops", "vaoss", "caos", "poo", "baoses", "caols", "bioses", "vaos", "tais", "poOS", "taOs", "waOs", "baoss", "waos", "poos", "taops", "pooses", "boo"], "body": ["output", "buffer", "message", "binary", "text", "json", "html", "description", "mail", "plain", "template", "head", "header", "detail", "loop", "title", "shell", "send", "bill", "rel", "Body", "size", "subject", "note", "default", "ody", "t", "content", "summary", "pass", "tree", "null", "name", "post", "foot", "business", "base", "port", "file", "log", "ODY", "comment", "data", "format", "tail", "display", "scroll", "layout", "report"], "preferencesInstance": ["prefiesinstance", "preffiesinstance", "prefferencesinstance", "prefutesObj", "preferencesObj", "preffiesObj", "preffiesImpl", "prefancesInstance", "prefutesImpl", "prefancesObj", "preferencesinstance", "prefancesImpl", "prefutesInstance", "prefferencesImpl", "prefancesinstance", "prefiesInstance", "preferencesImpl", "prefferencesInstance", "prefiesImpl", "prefferencesObj", "prefutesinstance", "prefiesObj", "preffiesInstance"]}}
{"id1": "324679", "id2": "481364", "code1": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"import_hints": [" import_harks", " import_Hinters", " import_prarks", " import_Hints", " import_cints", " import_hinters", " import_printers", " import_prints", " import_cinters", " import_carks", " import_hins", " import_cins", " import_Hins", " import_prins", " import_Harks"], "filename": ["fn", "path", "output", "doi", "nil", "bf", "json", "location", "pdf", "jpg", "ln", "without", "title", "fil", "wikipedia", "latest", "nm", "kj", "Filename", "fp", "stem", "subject", "File", "files", "png", "ename", "ame", "journal", "name", "original", "LCS", "println", "username", "figure", "family", "txt", "directory", "kl", "FILE", "string", "source", "file", "finals", "there", "image", "til", "SourceFile"], "pieceId": [" pieceName", "blockid", "pieceInt", "caseLike", "pieceID", "ieceID", " pieceLog", "piecePath", "pixelId", " piecePath", "ieceById", "ieceIdent", "componentid", "pixelName", "ieceLog", " pieceNumber", "leagueNumber", "ieceId", "peInt", "leagueName", "blockId", "pixelid", " pieceid", "peId", "peLog", "pieceNumber", "pairInt", "pieceid", "blockID", "pieceIdent", "componentById", "pairId", "ieceNumber", "pixelPath", "peID", "ieceid", "pieceLike", "pairLike", "pieceName", "ieceName", " pieceIdent", "leagueIdent", "componentId", "blockById", " pieceInt", "componentID", "pieceById", " pieceID", "ieceInt", "ieceLike", "pieceLog", "caseInt", "pairById", "caseById", "leagueId", "caseId", "iecePath"], "i": ["multi", "im", "or", "x", "j", "n", "init", "it", "ai", "ini", "ic", "ie", "ui", "ip", "b", "me", "p", "y", "sql", "o", "io", "ci", "mi", "ind", "ki", "t", "pos", "ii", "qi", "v", "gi", "uli", "uu", "ti", "g", "bi", "ni", "index", "si", "I", "l", "u", "k", "go", "m", "iter", "xi", "ori", "us", "cli", "di", "sim", "pi", "info", "r", "li", "oi", "c", "ix"], "col": ["ch", "path", "fn", "Col", "con", "cell", "cond", "cal", "rem", "ct", "prop", "cat", "num", "dir", "coord", "loc", "lc", "pos", "COL", "pt", "win", "fc", "box", "mon", "cp", "dc", "coll", "rot", "char", "pc", "c", "ctx", "cul", "chron", "file", "ctrl", "co", "div", "column", "city", "act", "cmd", "cel", "cor", "color", "cur"], "row": ["our", "rew", "cell", "Row", "ror", "user", "ri", "ows", "hour", "rid", "roll", "rog", "ry", "root", "rc", "rows", "num", "frame", "re", "nr", "month", "pos", "loc", "rs", "ox", "rank", "length", "square", "box", "ow", "dd", "index", "post", "week", "ue", "rot", "family", "round", "tr", "form", "line", "rown", "floor", "ro", "range", "co", "race", "res", "r", "cor"], "rotation": ["polato", "rotator", "validate", "rotato", "validator", "lating", "rotate", "portato", "rotutation", "lation", "polation", "poluation", "polration", "polating", "polator", "lenate", "orientration", "polational", " rotate", "lenator", "rotration", "portating", " rotration", "portational", "validation", "lational", "lenation", "lenutation", " rotuation", "rotational", "orientuation", "rotating", "lato", "orientation", "validutation", "polutation", "portation", "polate", "rotuation", "orientate"], "number": ["collection", "message", "counter", "block", "n", "nb", "volume", "news", "type", "database", "BER", "count", "no", "integer", "duration", "size", "Number", "num", "note", "nr", "NUM", "initial", "total", "production", "length", "na", "nu", "nine", "version", "name", "division", "span", "directory", "result", "string", "umber", "amount", "padding", "significant", "language", "file", "comment", "document", "numbered", "random", "maximum", "population", "portion", "network"], "temppiece": ["stemppane", " temppawn", "temappyle", " temptayer", "temptiece", "temptyle", "stemmpixel", "stemmpane", "temptipe", "templawn", "temptayer", " templawn", "tmptrice", "temptoly", " temptoly", "temapprice", "temppixel", "temppsane", "tempperiece", "temploly", "stemppiece", " temptane", "temppsiece", " temppayer", " temptpiece", "temmpawn", "temppsoly", "tempperpiece", "temptrice", "temptpiece", "tmppane", "stemmpiece", "temmppiece", "stemppixel", "temptixel", "tmppyle", "templyle", "tmptyle", "temappiece", " temppoly", "temmpixel", "temppsayer", "tmptane", "tempprice", "temappane", "temppawn", " temptipe", "tmppiece", " templpiece", " temppane", " temptyle", "temmpyle", " temptiece", "temppsixel", " temppyle", "temppane", "templiece", "temmpiece", "templpiece", "temppyle", "temppsyle", "templipe", " templiece", "tempperipe", "tempppiece", "temppsawn", "temmpayer", "tempperyle", "tmpprice", "stemmpyle", "temppspiece", "tmptiece", "temppayer", "temmprice", "temmpoly", "temppipe", "temmpane", "stemppyle", "temptane", " temppipe", "temppoly", " temploly", " tempppiece"], "lineread": ["linetext", "cellreader", " linewrite", "ineread", "linkread", "celltext", "linebuild", "linreq", "lineready", "lexbuild", "lanereadable", "LINEread", " linRead", "linewrite", "dayfind", "linestr", "cellload", "linkreadable", "linereq", "lindata", " linwrite", "linkreader", "inetext", " linetext", "linfind", "bytereadable", "byteready", "lineRead", "lanereq", " linereader", "linreader", " linedata", "LINEdata", "rangeplay", " linestr", "byteread", "LINEinput", " linebuild", "lexplay", "lexread", "laneread", "ineload", "cellread", "LINEpass", " linepass", "bytefind", " lineinput", "rangeread", "linereader", "lexstr", "lanereader", "linkreq", "LINEwrite", "dayread", " lineRead", "linedata", "linepass", "linereadable", "linready", "rangestr", " lineload", "linRead", "dayready", "rangebuild", "lineload", " linread", "LINERead", "linefind", "linread", "dayreadable", "linpass", " lineplay", "linreadable", "inereader", " lininput", "lineinput", "lineplay"], "tok": ["wtoc", "top", " tik", "rtarr", "wtol", "ttol", " tople", "ttyk", "attot", "vtok", "tunc", " targ", "qtoc", "pyk", "entok", "tople", " tack", "etik", "took", " took", "detok", "vtack", "entk", "vtawk", "etunc", "detot", "tarr", "tproc", "rtk", "toc", "vtop", "tol", "untok", "pk", "wtk", "ttawk", "tik", " tawk", " toke", "tyk", " tk", "wtawk", "vtproc", "tot", "detook", "pok", "entop", "ttarg", "toke", "tk", "tawk", " tunc", "pawk", "entawk", "wtproc", "targ", "etarg", "qtok", "ttunc", "etok", "wtyk", "tTok", "attook", " tak", "entarr", " tTok", "vtak", "ttok", "qtoke", "untTok", "untoc", "wtarg", "wtok", "qtTok", " tol", "attok", "entak", " top", "tak", " tarr", "vtook", "ttik", "detople", "ttk", "attople", "tack", "rtak", "wtack", "untoke", "wtook", " tproc", " toc", "ttoc", "rtok", " tot"], "entree": ["sentrain", "sentree", "ntree", "montrees", "entour", "windree", "Entrees", "montee", "intree", "ntrie", "nthe", "windool", "entrape", "ptrie", " entabe", "centropy", "centour", " enthe", " entrape", "antree", "antry", "sentour", "entabe", "intropy", "Entrain", "ntrape", "ptrain", "Entrie", "ntool", "Entee", "montree", "montabe", "intour", "centree", "windee", "entrie", " entee", "antrie", "anthe", "ptrees", " entool", "montrain", "Entabe", "ntee", " entry", "montrie", "entry", "sentropy", "entee", "entrees", "enthe", " entrie", "entool", "entrain", "Entree", "intrain", "ntry", "windrape", "centrain", "entropy", "ptree"], "byurl": ["BYsl", " BYUrl", " BYsl", "BYdefault", "BYUrl", " byURL", "useurl", "bydefault", " bysl", " byUrl", " BYURL", "BYURL", "byUrl", " bydefault", " BYurl", "byURL", "useURL", "useUrl", "BYurl", "usedefault", "bysl"], "url": ["http", "mail", "ls", "sl", "open", "bel", "link", "ur", "ul", "Url", "gif", "URL", "rel", "deb", "download", "io", "re", "ssl", "dl", "uri", "nl", "resource", "el", "browser", "gl", "ref", "mount", "ll", "l", "char", "net", "rl", "file", "log", "job", "web", "cert", "cf", "r", "hl"], "in": ["IN", "din", "gin", "n", "it", "rin", "ini", "is", "mc", "sin", "f", "body", "en", "inc", "io", "from", "ins", "t", "win", "ma", "bin", "v", "serv", "inner", "reader", "stream", "get", "l", "In", "input", "source", " din", "inn", "out", "inf", "cin"]}}
{"id1": "6517139", "id2": "19784131", "code1": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"getPrefsKey": ["getPrefoKey", "getPrefoValue", "getPrefixValue", "getPrefoData", "getPrefsValue", "getPrefskey", "getPrefmsData", "getPrefokey", "getPrefsData", "getPrefmsKey", "getPrefixkey", "getPrefixData", "getPrefmskey", "getPrefmsValue", "getPrefixKey"], "key": ["path", "message", "text", "json", "Key", "password", "description", "prefix", "phrase", "my", "unknown", "type", "ek", "item", "link", "secret", "address", "id", "y", "token", "default", "client", "KEY", "lock", "code", "null", "error", "name", "label", "str", "index", "service", "keys", "char", "ace", "k", "obj", "result", "base", "entry", "string", "hash", "value", "info", "data", "sk", "network"], "MD5": ["MDdown", "MDole", " MD4", "MD1", "HTML5", "MT2", "MD3", "MTole", "MD10", "MT3", " MDole", "HTML3", "md5", "md45", "MTdown", "md10", " MD10", "MP4", "HTMLdown", " MD6", "MD8", "MD2", "MD7", "HTMLole", " MD8", "DE3", "md8", " MD1", "MD4", "md4", " MD3", "md6", "MT7", " MD7", "MD6", "MT5", " MD45", "md7", " MDdown", "DE1", "DE5", "MP2", "md2", "md1", "MT6", "MD45", "DE45", "MT10", "MP3", " MD2", "MP5", "MT8", "md3"], "resultBytes": ["ResultByte", "resultsBytes", "Resultbytes", "resultBs", "resultsByte", "successBs", "successResults", "answerBs", "resultByte", "resultResults", " resultResults", " resultByte", "answerString", "successBytes", "resultString", "answerBytes", " resultBs", "answerResults", " resultbytes", "resultsbytes", "resultbytes", "ResultBytes", " resultString", "successString"]}}
{"id1": "18005010", "id2": "742465", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"setProfile": [" setProperty", "SETProf", "setDefault", "setProf", " setProf", "SETProfile", " setDefault", "storeProf", "SETProperty", "storeProfile", "storeDefault", "SETDefault", "storeProperty", "setProperty"], "loginName": [" loginNames", "displayName", " loginname", "loginNames", "displayKey", "displayname", "fileKey", "displayNames", " loginKey", "loginKey", "fileNames", "loginname", "fileName", "filename"], "profile": ["output", "buffer", "panel", "history", "style", "update", "json", "face", "password", "properties", "config", "template", "user", "header", "account", "title", "property", "picture", "p", "usage", "pool", "sample", "relation", "Profile", "plot", "frame", "note", "feature", "client", "pse", "summary", "settings", "pty", "photo", "position", "username", "policy", "prof", "result", "line", "details", "project", "FILE", "mem", "base", "hash", "port", "table", "log", "option", "document", "data", "memory", "context", "report", "role", "phone"], "outStream": [" outSteam", "outputSteam", "offSteam", "aosPoint", "outputFile", "exStream", " outFile", "outPoint", "exWriter", "aosStream", "outSteam", "offStream", "outView", " outWriter", " outstream", " outPoint", "OutFile", "exSteam", "OutStream", "aosWriter", "servStream", "OutWriter", "outputstream", "servView", "servSteam", "aosSteam", "outputView", "outstream", "offstream", "offWriter", "OutView", "Outstream", "servstream", "outWriter", " outView", "OutSteam", "outputStream", "exPoint", "outFile"], "url": ["path", "http", "mail", "html", "ls", "location", "abs", "host", "org", "open", "build", "bel", "link", "ur", "Url", "f", "address", "q", "URL", "rel", "re", "pl", "ssl", "uri", "dl", "nl", "loc", "resource", "client", "email", "browser", "impl", "mount", "str", "xml", "ll", "get", "service", "l", "char", "base", "string", "parse", "web", "https", "cert", "r", "li"], "file": ["path", "output", "binary", "db", "lf", "template", "link", "f", "body", "pool", "local", "download", "fp", " File", "File", "resource", "filename", "email", "le", "library", "tree", "null", "name", "page", "ile", "result", "print", "FILE", "base", "entry", "port", "table", "web", "document", "info", "format", "out", "image", "report"], "connection": ["bo", "nc", "session", "connect", "pointer", "application", "Connection", "con", "ion", "cone", "close", "open", "database", "link", "response", "generation", "condition", "statement", "socket", "sql", "no", "console", "character", "to", "relation", "closure", "client", "resource", "channel", "created", "communication", "still", "number", "position", "established", "online", "connected", "net", "directory", "conn", "command", "system", "web", "city", "dial", "c", "computer", "network"], "writer": ["fn", "buffer", "runner", "usher", "builder", "word", "node", "function", "window", "WR", "owner", "counter", "caster", "worker", "draw", "processor", "flush", "wrote", "wa", "loader", "riter", "writers", "variable", "writing", "ws", "iterator", "writ", "maker", "creator", "er", "client", "liner", "rw", "wright", "wrapper", "widget", "operator", "wt", "write", "journal", "inner", "reader", "written", "handler", "println", "w", "external", "event", "ner", "entry", "Writer", "driver", "comment", "walker", "document", "format", "outer", "commit", "storage", "editor", "network"], "myEnum": [" myAnom", "myAcom", " myENum", "myAnum", "myAnet", "myAcums", "myEncumb", "myENom", "myenumb", " myENumb", "someEnums", "someENumb", " myAnet", " myAnums", "someEnum", "myEncom", "myAnums", " myAnum", "myENum", "myenum", " myEnums", "myEncUM", "myENums", "myEnom", "myenom", "someEnUM", "someENum", "myEnUM", "myAnUM", "myEncum", "myAcum", " myEnom", "myAnom", "myEncums", "myEnums", " myENom", "myENumb", "myEnet", " myEnumb", "myAcet", "myENet", "myEnumb", "myAnumb", "someENums", " myEnet", "myENUM", "someEnumb", "someENUM"], "key": ["field", "bo", "owner", "text", "part", "node", "Key", "cell", "step", "prefix", "cond", "member", "n", "val", "it", "a", "type", "var", "item", "ek", "title", "attribute", "id", "no", "variable", "token", "row", "col", "test", "note", "ex", "element", "KEY", "v", "parent", "pair", "name", "label", "str", "index", "ice", "mac", "ace", "keys", "char", "one", "k", "pe", "base", "entry", "string", "child", "hash", "air", "primary", "m", "value", "i", "chain", "info", "column", "host", "word"]}}
{"id1": "19810820", "id2": "18693224", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": [" copyStreamchannel", "copyFilechannel", " copyByteChannel", " copyStreamFile", " copyFilesStream", " copyFileschannel", "copyFileStream", "copyBytechannel", " copyBytechannel", " copyFileStream", "copyByteStream", "copyByteChannel", " copyStreamStream", " copyFilechannel", " copyFilesChannel", " copyByteStream", " copyByteFile", "copyByteFile", " copyFileFile", " copyFilesFile", "copyFileFile", " copyStreamChannel"], "src": ["ser", "st", "ls", "sl", "init", "RC", "sync", "SOURCE", "img", "sys", "tmp", "rx", "bs", "sc", "rel", "rc", "from", "ins", "obs", "loc", "filename", "Source", "rs", "js", "syn", "rt", "req", "ctr", "dest", "txt", "sec", "cont", "sr", "source", "input", "rl", "sb", "inst", "s", "usc", "in", "start", "usr", "sf", "sq", "SourceFile", "cur"], "dst": [" ddest", " dist", "Dnd", "sest", "bist", "dth", " dnd", "jst", "sut", "ddest", "best", "bdest", "jdest", "Ddest", "Dst", " dest", "dist", "Dist", "bst", "dest", "sth", "snd", "dut", "dnd", "sdest", "jest", "Dest", "Dut", " dth", "sst", "jut", "Dth"], "preserveModificationTime": ["preserveModificationTimes", "preserveModificationTim", "preserveSpecificationTime", "preserveModifierTimes", "preserveSpecificationsTime", "preserveModifyingTime", "preserveQualificationsTimes", "preserveModifiedTimes", "preserveModifierTim", "preserveModifiedTime", "preserveModifyTime", "preserveModificationsLength", "preserveQualificationsLength", "preserveModifyLength", "preserveModifiedTim", "preserveModifyingPoint", "preserveModifyingTimes", "preserveModificationsPoint", "preserveModificationsTim", "preserveModificationPoint", "preserveQualificationsPoint", "preserveModifyTimes", "preserveSpecificationsTim", "preserveSpecificationTimes", "preserveQualificationTime", "preserveQualificationTimes", "preserveModifierTime", "preserveModifyPoint", "preserveSpecificationTim", "preserveModificationsTime", "preserveSpecificationsTimes", "preserveQualificationPoint", "preserveModifyingLength", "preserveModificationLength", "preserveQualificationsTime", "preserveModificationsTimes", "preserveQualificationLength"], "inputChannel": ["interfaceChannel", "InputStream", "entityChannel", "inputConnection", "hiddenListener", "inputChuck", "outputBuffer", "hiddenCategory", "interfaceCategory", "inputCategory", " inputGray", "infoChuck", " inputConnection", "openChannel", "infochannel", "outputChuck", "inputBuffer", "openGray", "inputListener", "InputChannel", " inputchannel", "evalChannel", "infoChan", "inputChan", " inputChuck", "innerchannel", "innerChan", "inputStream", "evalChan", "InputChan", "hiddenChannel", "clientConnection", "infoChannel", "outputchannel", " inputChan", "InputBuffer", "inputchannel", "innerStream", "openConnection", " inputBuffer", "clientChannel", "Inputchannel", "outputChan", " inputListener", "openChan", "clientChan", "entityChan", "clientGray", "inputGray", " inputStream", "outputStream", " inputCategory", "interfaceListener", "innerChannel"], "outputChannel": ["putChannel", " outputChan", "displayChannel", "writeChannel", "coinChan", "inputConnection", "doubleInstance", "webManager", "doubleChannel", "writeManager", "outputInstance", "outputManager", "outputConnection", " outputchannel", " outputButton", "webchannel", "putchannel", " outputConnection", "coinChannel", "inputChan", "inputField", "putButton", "OutputChan", "displayButton", "writeChan", "outputchannel", " outputStream", "coinInstance", "outputButton", "displayChan", "inputManager", "OutputConnection", "outputField", "OutputManager", "webChannel", "inputInstance", "outputChan", "Outputchannel", "putChan", "displaychannel", "writeStream", "coinField", "writechannel", " outputManager", "OutputStream", "outputStream", "doubleField", "OutputChannel", "doubleChan"], "length": ["buffer", "history", "load", "list", "text", "json", "offset", "shape", "term", "volume", "time", "then", "present", "type", "available", "loop", "ength", "count", "expected", "duration", "size", "to", "end", "Length", "needed", "component", "library", "all", "required", "number", "bytes", "position", "l", "ENGTH", "family", "sequence", "base", "details", "limit", "amount", "HH", "padding", "capacity", "partial", "value", "max", "join", "full", "data", "height", "width", "start", "left", "len"], "total": ["equal", "offset", "description", "unknown", "valid", "last", "human", "used", "bar", "available", "title", "eta", "count", "otal", "raw", "Total", " Total", "ta", "no", "free", "local", "to", "checked", "num", "complete", "size", "note", "t", "created", "current", "translation", "summary", "stable", "this", "all", "less", "done", "required", "index", "number", "scale", "sum", "good", "sequence", "unique", "base", "meta", "amount", "quant", "zero", "active", "max", "info", "full", "successful"]}}
{"id1": "18891988", "id2": "13563706", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["selectfile", "getFilename", "createFilename", "GetFile", "selectFilename", "createString", "GetString", "createFile", "getfile", "createfile", "GetFilename", "getString", "selectFile", "Getfile", "selectString"], "serviceName": [" serviceCode", "libraryName", "ServiceFamily", "libraryType", "serverCode", "ServiceType", "serviceType", "serverType", "libraryFamily", "serviceCode", "serviceNames", "ServiceName", " serviceFamily", "ServiceNames", "ServiceCode", "libraryNames", "serviceFamily", "serverName", " serviceType", " serviceNames"], "wsdlLocation": ["wslLocation", "wlLoc", "awsdlURL", "wslLoc", "wssdFolder", "wslFolder", "wssdlocation", "awsdlocation", "wsdLoc", "wsDLlocation", "wsdllocation", "wsDLPath", "wsdlURL", "wsdLocation", "wsDLLoc", "wsDLFolder", "wsollocation", "wlFolder", "awsdllocation", "wsdURL", "wdlLocation", "wlPath", "wsolLoc", "awsdlLocation", "awsdlLoc", "wsolLocation", "wsDLURL", "wssdPath", "wssdLocation", "awsolLocation", "wsdlPath", "wsdlocation", "wsDLLocation", "wsdlFolder", "awsdURL", "wdlLoc", "awsolURL", "awsdLocation", "awsollocation", "wdlFolder", "wdlPath", "wlLocation", "wslPath", "wsdlLoc", "awsdLoc", "wssdLoc", "wsolURL", "wssdURL", "awsolLoc"], "endpoint": ["endword", "bindport", "startPoint", "idpoints", "bindpoints", "bindpoint", "endPoint", "Endpoint", "startpoints", "beginPoint", " endpoints", "beginword", "bindPoint", " endline", "idPoint", " endport", "Endpoints", "EndPoint", "beginpoint", "startword", "Endport", "startpoint", "idpoint", "Endword", "startline", "endport", "endline", " endPoint", "endpoints", "beginpoints", "idline"], "fileLocation": ["FileLoc", "Filelocation", "FileLocation", "fileLoc", "filePosition", " fileLoc", " filelocation", "documentLoc", " filePosition", "documentPosition", "filelocation", "FilePosition", "documentLocation", "documentlocation"], "tempDir": ["tmpUrl", "TempUrl", "TempPath", "TempDir", "tempDirectory", "tmpDirectory", "tmpdir", "tmpPath", " tempFolder", "tmpFolder", "tempPath", " tempdir", " tempUrl", "tempFolder", "TempDirectory", "TempFolder", " tempDirectory", "tmpDir", "tempUrl", "Tempdir", " tempPath", "tempdir"], "url": ["http", "mail", "ls", "window", "location", "sl", "open", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "socket", "URL", "rel", "sur", "pl", "re", "ssl", "uri", "dl", "loc", "nl", "up", "browser", "gl", "cr", "str", "mount", "ll", "cp", "service", "l", "char", "un", "conn", "base", "m", "job", "ctrl", "web", "https", "cert", "r", "li", "github", "il"], "WSDLFile": ["WSDLLFilename", "WSDLString", "WSDQLFile", "WIDDLString", "WHDLfile", "WIDDLType", "WSDDLString", "WIDLFile", "WHDDLFile", "WSDDLFILE", "WNDLFILE", "WSDDLType", "WHDDLfile", "WSDLLString", "WSDLLFILE", "WIDDLFile", "WNDLFile", "WSDDLFile", "WNDDLfile", "WSDLLType", "WHDDLFILE", "WSDELfile", "WSDLSFile", "WNDLFilename", "WIDLType", "WIDLString", "WSDQLfile", "WIDLfile", "WNDDLFILE", "WSDLLfile", "WSDMLfile", "WSDQLFILE", "WSDMLFILE", "WSDLLFile", "WSDMLFile", "WSDELFILE", "WNDLfile", "WSDLSType", "WSDLSString", "WSDLFILE", "WSDLType", "WSDLSfile", "WSDDLfile", "WHDLFILE", "WSDLFilename", "WSDLfile", "WSDELFile", "WNDDLFilename", "WSDDLFilename", "WHDLFile", "WIDDLfile", "WNDDLFile", "WSDELFilename"], "tmpWSDLFile": ["tmpWSDDLFiles", "tmpWSDlFile", "tmpWSDLDFilename", "tmpWIDDLFILE", "tmpWNDDLFilename", "tmpWSDLDFILE", "tmpWIDDLfile", "tmpWSDLLFilename", "tmpWSDLLFiles", "tmpWNDDLfile", "tmpWNDDLFiles", "tmpWSDlFiles", "tmpWSDlfile", "tmpWSDLFiles", "tmpWNDDLFile", "tmpWNDLFile", "tmpWSDlFilename", "tmpWIDDLFilename", "tmpWSDLLFILE", "tmpWNDLFiles", "tmpWSDLDFile", "tmpWSDDLFILE", "tmpWSDLDfile", "tmpWIDLfile", "tmpWSDLLfile", "tmpWIDDLFile", "tmpWSDLFilename", "tmpWSDDLFilename", "tmpWIDLFILE", "tmpWSDDLFile", "tmpWNDLFilename", "tmpWIDLFilename", "tmpWNDLfile", "tmpWSDLLFile", "tmpWIDLFile", "tmpWSDLFILE", "tmpWSDLfile", "tmpWSDDLfile"], "inputFile": ["inputPlace", "InputStream", "inputPath", "indexFILE", "indexStream", "intFiles", "inputSourceFile", "tmpFILE", "inputFILE", "outputFILE", "clientPath", "outputFile", "clientFiles", " inputfile", "indexfile", "errorFile", "tmpSourceFile", " inputPlace", "interfacePlace", "errorfile", "outputfile", "Inputfile", " inputFILE", "inputStream", "interfaceSourceFile", "InputFiles", "tmpStream", "clientFile", "intFILE", "inputFiles", "infile", "inputDo", "clientFILE", " inputFiles", "intfile", "errorFILE", " inputDo", "intFile", "tmpPlace", "inDo", "indexFile", "inFile", "interfaceFile", "inPath", " inputPath", "InputFile", "interfacefile", "tmpfile", " inputSourceFile", "InputPath", "InputDo", "errorStream", "InputFILE", "outputStream", "inputfile"], "tmpFile": ["tmpFILE", "inputFILE", "empFilename", "tmpFiles", "mpFile", " tmpPath", "empFILE", "mpfile", " tmpfile", "tmpPath", "tempFiles", "tempFILE", "tempPath", "mpFiles", "inputFilename", "empFile", "mpPath", "tempFile", "tempFilename", " tmpFiles", "empfile", "tmpFilename", "tmpfile", "tempfile", "inputfile"], "in": ["ch", "IN", "din", "init", "ln", "n", "it", "rin", "ri", "ai", "is", "ic", "ini", "sin", "ain", "id", "o", "inv", "en", "inc", "io", "from", "mi", "ind", "ins", "t", "client", "ar", "bin", "inner", "stream", "isin", "r", "In", "cont", "conn", "input", "source", "file", "inn", "inf", "c", "cin"], "out": ["output", "ch", "buffer", "on", "by", "n", "auto", "Out", "sys", "tmp", "connection", "can", "pool", "o", "inv", "to", "os", "en", "aos", "io", "OU", "ex", "outs", "t", "client", "conv", "ou", "lock", "cm", "all", "write", "at", "null", "group", "writer", "this", "ao", "w", "obj", "net", "conn", "OUT", "conf", "ne", "file", "log", "oss", "co", "we", "outer", "c", "cache"], "con": ["ch", "fn", "nc", "cos", "connect", "Con", "cone", "const", "cur", "ln", "cal", "exc", "mc", "connection", "acon", "ain", "can", "ws", "num", "re", "conv", "login", "win", "fc", "cm", "tc", "cp", "cons", "sec", "un", "conn", "cn", "CON", "ran", "func", "co", "cf", "com", "conf", "soc", "Conn", "c", "cin"], "fileLength": ["objectSize", "objectFontSize", "channelSize", "objectDuration", "FILESize", "channelLength", "ileLen", "FILELength", "fileDuration", "ileLength", " fileDuration", "fileSize", "FILEDuration", " fileLen", " fileSize", "FILELen", " fileFontSize", "fileLen", "ileDuration", "channelDuration", "fileFontSize", "channelFontSize", "ileSize", "objectLength"], "channelIn": ["channelIN", "chanIn", "consoleIn", "ChannelIn", "clientSet", "channelSet", "Channelin", "consoleedIn", "clientIn", "clientOut", "ChannelIN", "ChannelSet", " channeledIn", "ChanneledIn", "channeledIn", "ChannelOut", "channelin", "consoleOut", "consoleIN", "chanSet", "clientin", "chanIN", "chanOut", "clientIN", " channelIN", " channelin"], "channelOut": ["chanIn", "consoleIn", "ChannelIn", "channelOUT", " channelConn", "ChannelConn", "courseout", "courseOut", "courseOUT", "courseIn", "chanout", "chanConn", "ChannelOut", "consoleOUT", "channelout", "Channelout", "consoleout", "consoleOut", "chanOut", " channelout", "channelConn", " channelOUT", "ChannelOUT"], "tmpDocument": ["tmpDoc", "tpFile", "npDocument", "mkdocument", "npFile", " tmpDocuments", "mpDoc", "npMedia", "tpDocument", "tempDoc", "cpDocument", "tmDoc", "tpMedia", " tmpDoc", "tmDocument", " tmpMedia", "tmpDocuments", "cpDoc", "cpdocument", "tempdocument", " tmpdocument", "mpDocument", "mkDocument", "npDocuments", "mkDoc", "tmpdocument", "tpDocuments", "tmpMedia", "tmdocument", "mpdocument", "tempDocument"], "nl1": ["ln01", "rn6", "NL0", "pelOne", "sol0", "sol1", "nl01", "sol2", "nrOne", "nelOne", "rn3", "nl2", "ln2", "nl3", "pel1", "nel1", "lnOne", "ln6", "nel3", "nl6", "nlOne", "nr1", "sol9", "nr01", "ln3", "nel6", "nl0", "rn1", "pel01", "NL2", "nl9", "ln0", "ln9", "NL1", "ln1", "NL9", "rnOne"], "i": ["multi", "ims", "ms", "x", "j", "n", "init", "it", "ai", "a", "is", "ic", "ini", "ui", "ie", "me", "ri", "id", "y", "o", "io", "mi", "ci", "qi", "ii", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "span", "u", "k", "m", "xi", "cli", "us", "mu", "ami", "ori", "di", "sim", "pi", "info", "ij", "ip", "li", "\u0438", "ix"], "node1": ["Node2", "ode001", "nOne", "node91", "ode2", "component0", "node001", "NodeOne", "component2", "Node1", "layer91", "layer0", " node2", "layerOne", "ode1", "ode0", " node91", "node0", "Node001", " node0", " node001", "componentOne", " nodeOne", "layer1", "n1", "n0", "nodeOne", "node2", "n91", "Node0", "component1"], "tmpOut": ["tmpObj", " tmpIs", "tmpIs", "mpOut", "empIs", "mpout", "TempOUT", "npIn", "mpObj", "cmpIn", "cmpout", "TempIn", "tmpOUT", " tmpObj", "tempout", " tmpIn", "empout", "npout", "mpIn", " tmpOUT", "cmpOut", "TempObj", "tmpout", "tempObj", "tmpIn", "npObj", "tempIn", "tempOUT", "tempIs", "TempOut", "tempOut", "empOut", " tmpout", "npOut"], "retVal": ["retValue", "returnVal", "returnValue", "returnTrue", "returnval", "retval", "RetTrue", "RetValue", "Retval", "retTrue", " retValue", " retval", " retTrue", "RetVal"]}}
{"id1": "5148212", "id2": "15905041", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"copyFile": ["copImage", "cloneFile", "copyImage", "cloneImage", " copyImage", "copFile", "clonefile", " copyfile", "copyfile", "copfile"], "src": ["path", "lit", "ser", "ident", "attr", "st", "ls", "init", "img", "pkg", "ie", "sys", "ur", "ource", "sc", "rel", "rc", "inc", "ost", "from", "sur", "ins", "loc", "filename", "Source", "rs", "iv", "syn", "rest", "req", "str", "obj", "sec", "txt", "sit", "sr", "source", "input", "iter", "file", "ipl", "inst", "url", "start", "usc", "urg", "usr", "sf", "sq", "cur"], "dest": ["lit", "gov", "st", "img", "to", "coord", "parent", "dist", "tom", "doc", "ord", "tif", "trans", "iter", "port", "file", "origin", "path", "deg", "orig", "des", "desc", "fr", "this", "delete", "sup", "obj", "Dest", "sit", "min", "decl", "sp", "data", "temp", "rest", "output", "est", "nd", "fe", "dat", "crit", "loc", "etc", "null", "d", "tr", "good", "result", "target", "way", "ident", "vol", "master", "opt", "prop", "end", "cat", "dir", "test", "spec", "v", "foreign", "comp", "req", "nw", "mk", "cont", "them", "source", "gt", "nom", "comb", "usr", "de"], "bufSize": ["bufCount", "bufsize", "fontSIZE", "queueLen", "bufLength", "boxSize", "buffersize", "bufferSIZE", "bufferSize", "BufferCount", "BufferLength", "fontInfo", "ufSIZE", "ufsize", "boxsize", "bufLen", "queueCount", "bufferLen", "ufInfo", "ufSize", " bufsize", "BufferLen", "fontSize", "BufferSize", "bufInfo", "bufferLength", "bufferCount", "queueLength", "boxSIZE", " bufInfo", "bufSIZE", "fontsize", " bufSIZE", "queueSize"], "force": [" confirm", "update", "reason", "replace", "pdf", "auto", "sync", " override", "open", "apply", "handle", "seed", "flush", "send", "forge", "ce", "frame", "default", "use", "like", " enforce", "allow", "enable", "yes", "require", "always", "ghost", "fail", "flag", "e", "write", "vert", "rule", "error", "cp", "external", "ignore", "ace", "fx", "quote", "only", "forcing", "fast", "form", "print", "remote", "Force", "dirty", "secure", "forced", "func", "append", "start", "cmd", "raise"], "f": ["bf", "part", "lf", "fo", "ef", "xf", "b", "ct", "p", "fi", "h", "fp", "dir", "t", "fr", "v", "fc", "fm", "uf", "e", "g", "d", "fac", "w", "rf", "l", "r", "fs", "elf", "m", "df", "file", "of", "exp", "s", "F", "cf", "conf", "sf", "c", "inf"], "buffer": ["message", "Buffer", "binary", "text", "history", "shape", "window", "password", "block", "buf", "template", "phrase", "database", "bar", "attribute", "filter", "variable", "row", "sample", "queue", "frame", "buff", "length", "library", "write", "index", "number", "char", "sequence", "result", "print", "command", "batch", "line", "base", "iter", "table", "stroke", "parse", "stack", "document", "memory", "paste", "append", "word", "temp", "cache"], "read": ["load", "seek", "im", "shape", "add", "bind", "time", "hello", "it", "take", "open", "valid", "gets", "Read", "feed", "count", "q", "send", "raw", "size", "en", "end", "ke", "ind", "like", "give", "READ", "t", "allow", "length", "run", "write", "key", " Read", "need", "str", "readable", "reader", "index", "reading", "get", "w", "stream", "char", "record", "pe", "print", "before", "mem", "check", "input", "fill", "iter", "select", "skip", "log", "parse", "range", "i", "find", "info", "query", "height", "start", "ip", "word", "reads", "len"], "in": ["IN", "on", "per", "din", "gin", "im", "con", "internal", "or", "by", "init", "ln", "it", "oin", "rin", "ini", "is", "ie", "ic", "ain", "image", "to", "en", "inc", "io", "mm", "mi", "irm", "ind", "from", "al", "ins", "ex", "client", "ma", "ar", "up", "bin", "inner", "get", "isin", "local", "l", "ir", "In", "net", "input", "source", "m", "iter", "i", "inn", "inside", "inf", "cin"], "out": ["output", "cos", "list", "on", "ion", "con", "or", "n", "ln", "Out", "it", "user", "not", "sys", "b", "flush", "can", "o", "aos", "to", "os", "end", "io", "OU", "note", "ex", "conv", "t", "client", "outs", "up", "bin", "ou", "v", "parent", "nt", "oe", "at", "write", "inner", "writer", "one", "obj", "net", "conn", "print", "OUT", "ne", "cn", "file", "oss", "ot", "co", "full", "outer", "cache"]}}
{"id1": "2324868", "id2": "3731077", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"actionPerformed": ["actionExecformed", " actionTransceived", " actionExecceived", " actionExecform", " actionOccuted", "actionExecform", " actionPeruted", "actionExecceived", " actionExecuted", " actionPerform", "actionPeruted", "actionExecuted", "actionPerform", " actionOccformed", " actionExecformed", "actionPerceived", " actionPerceived", " actionTransform", " actionTransuted", " actionTransformed", " actionOccceived", " actionOccform"], "e": ["ev", "es", "or", "n", "se", "a", "ef", "te", "ie", "b", "o", "ce", "re", "ed", "er", "t", " event", "ee", "v", "ea", "E", "ec", "cb", "w", "event", "m", "events", "Event"], "delim": ["dliter", "Delimm", "Delim", "delib", "separiter", "delimeter", "Delib", "dlimeter", "delam", " delib", "separimeter", "drib", "delimm", " delam", "dlif", " delimm", " delimeter", "drim", "delif", "deliter", "drimm", "separif", " delif", "dram", "Delam", "dlim", "separim", " deliter"], "r": ["dr", "R", "rar", "n", "it", "rx", "ur", "p", "rc", "hr", "re", "pr", "rd", "nr", "er", "fr", "rg", "rw", "rs", "cr", "rt", "reader", "d", "w", "vr", "mr", "l", "tr", "rr", "rate", "sr", "lr", "m", "rl", "rn", "br", "kr", "res", "usr", "c", "rb"], "line": ["out", "text", "mail", "node", "cell", "block", "lin", "ln", "user", "lo", "eline", "detail", "link", "normal", "handle", "raw", "row", "sample", "frame", "ole", "lines", "nl", "liner", "le", "run", "pass", "inline", "ine", "ode", "LINE", "ice", "stream", "l", "online", "page", "sequence", "record", "entry", "string", "ste", "base", "point", "check", "stroke", "file", "log", "range", "chain", "comment", "word", "Line"], "url": ["http", "ls", "abs", "addr", "sl", "org", "open", "hub", "ret", "build", "bel", "link", "ur", "lb", "Url", "ul", "f", "blog", "URL", "rel", "api", "ssl", "dl", "uri", "loc", "nl", "client", "browser", "gl", "ref", "str", "ll", "gb", "l", "net", "base", "rl", "log", "web", "https", "cert", "hl"], "conn": ["ch", "nec", "nc", "connect", "db", "con", "Connection", "close", "addr", "ln", "n", "sync", "org", "open", "connection", "ct", "socket", "rel", "inv", "enc", "ws", "ssl", "dl", "pas", "nl", "resp", "client", "loc", "conv", "nt", "syn", "ns", "write", "canon", "ait", "cp", "cb", "nw", "comm", "obj", "net", "yn", "cl", "ctx", "cn", "rn", "secure", "ann", "ctrl", "https", "cert", "jp", "cmd", "res", "fin", "dial", "Conn", "c", "cur"], "wr": ["fn", "dr", "spr", "RW", "wm", "rew", "ev", "rex", "WR", "ln", "wer", "vet", "wrote", "wa", "iw", "writers", "Wr", "mg", "wp", "ws", "sw", "writ", "mt", "pr", "fr", "resp", "pipe", "rw", "wt", "write", "wi", "writer", "nw", "wb", "w", "vr", "mr", "wk", "kl", "tn", "wn", "Writer", "ell", "rn", "tw", "wl", "fw", "kr", "we", "wire", "wy", "wx"], "tokens": ["tikens", " tOKens", "tokents", "tikents", "tokENS", "tokonds", "tokskens", "Tokets", "Tokers", "toksets", "todkens", "todENS", "tOKens", "Toksets", "tocers", "todents", "Tokens", "stodens", "stokets", "tokwords", "Toksers", "tokkens", "tokeds", "Toksens", "todeds", "stokonds", "toksonds", "stokkens", "tokets", "tocwords", "tookkens", "tokswords", "toksers", "tocets", "stodkens", "tookens", "stokens", "todens", "takawords", "Tokwords", "tookets", " tokENS", "todonds", "takaets", "takaers", "toksens", "tookonds", "stodets", "takaens", "tokers", " tOKents", "tikENS", "tikeds", " tokeds", "tocens", "stodonds", " tOKENS", "todets", "tOKeds", "tOKENS", " tokents", "tOKents", " tOKeds", "Tokswords"], "in": ["IN", "on", "din", "con", "gin", "it", "ini", "rin", "is", "mc", "ic", "ill", "body", "read", "en", "inc", "io", "from", "irm", "mm", "ind", "ins", "ma", "win", "ar", "bin", "all", "inner", "null", "reader", "l", "In", "err", "input", "iter", "i", "mn", " din", "inn", "out", "inf", "cin"]}}
{"id1": "17475530", "id2": "18693224", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkForImages", "testAddLinkstoimage", "testAddLinkstoImage", "testAddLinkToimage", "testAddLinktoImages", "testAddLinkFromImage", "testAddLinkForImage", "testAddLinkstoPicture", "testAddLinkFromImages", "testAddLinktoImage", "testAddLinkForimage", "testAddLinksToimage", "testAddLinkToPicture", "testAddLinkFromPicture", "testAddLinkToImages", "testAddLinkstoImages", "testAddLinksToImages", "testAddLinktoimage", "testAddLinksToImage", "testAddLinktoPicture", "testAddLinkForPicture", "testAddLinksToPicture", "testAddLinkFromimage"], "in": ["IN", "on", "din", "gin", "password", "add", "or", "by", "init", "it", "rin", "ini", "is", "vin", "mc", "and", "o", "en", "inc", "from", "nin", "re", "ind", "ed", "al", "ins", "ex", "er", "ma", "sein", "up", "bin", "v", "all", "at", "inner", "doc", "get", "one", "isin", "r", "k", "sum", "In", "include", "check", "input", "source", "set", "m", "file", "show", "i", "info", " din", "pi", "inn", "out", "inside", "cin"]}}
{"id1": "2461169", "id2": "10795866", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeString2String", "decodeFileToString", "decodeString2file", "decodeStringToFiles", "decodeFileFileFiles", "decodeString2File", "decodeFileFilefile", "decodeFileAsfile", "decodeFile2File", "decodeFile2file", "decodeFileTofile", "decodeFileAsFiles", "decodeFileAsString", "decodeFileToFiles", "decodeString2Files", "decodeFileAsFile", "decodeStringToString", "decodeStringTofile", "decodeFileFileString", "decodeStringToFile", "decodeFile2Files", "decodeFileFileFile"], "infile": ["outname", "outfolder", "fromfile", "infolder", "isinname", "frombase", "infilename", "fromfilename", "InFile", "inputfolder", "Infile", "isinfile", "fromFile", "isinfolder", "Inbase", "outfilename", "outbase", "inputname", "inputFile", "inname", "inFile", "isinFile", "inbase", "outFile", "Infilename", "inputfile"], "outfile": ["Outfile", "tofilename", "outname", " outname", " outFile", "outdir", "todir", "infilename", "OutFile", "Outdir", "tofile", "otname", "otFile", "otfile", "outfilename", "toFile", "inname", "otFILE", "inFILE", "indir", "inFile", "Outfilename", "outFile", "outFILE", " outFILE"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "auto", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "shape", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "frame", "note", "bone", "initial", "total", "buff", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "display", "paste", "append", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "shift", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "index", "reading", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " okay", "valid", "ceed", " succeed", "support", "response", "town", "condition", "exist", " succeeds", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "scope", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "done", "photo", "sufficient", "error", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first"]}}
{"id1": "19113613", "id2": "23611770", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"copy": ["cos", "core", "save", "init", "split", "sync", "replace", "cross", "link", "move", "ip", "proxy", "crop", "transfer", "clip", "to", "download", "create", "cat", "slice", "map", "Cop", "delete", "write", "cop", "cp", "share", "gc", "Copy", "same", "co", "clone", "py", "paste", "php", "pixel", "opy", "zip"], "in": ["IN", "on", "din", "con", "gin", "by", "init", "it", "rin", "ai", "is", "ic", "ie", "ini", "sin", "old", "id", "y", "o", "inv", "local", "en", "inc", "from", "re", "mi", "ind", "ins", "ar", "el", "up", "bin", "all", "inner", "isin", "l", "ir", "In", "net", "check", "input", "iter", "i", "info", "inn", "act", "inside", "inf", "cin"], "out": ["output", "ch", "on", "ion", "con", "n", "over", "Out", "it", "not", "ent", "sys", "tmp", "b", "ver", "p", "y", "o", "aos", "to", "end", "local", "os", "io", "can", "OU", "en", "ex", "outs", "t", "op", "client", "v", "ou", "nt", "at", "all", "write", "null", "store", "inner", "this", "w", "one", "l", "obj", "err", "net", "result", "conn", "OUT", "base", "gt", "set", "port", "log", "oss", "ot", "co", "res", "outer", "cache"], "source": ["style", "site", "prefix", "space", "template", "se", "SOURCE", "ie", "attribute", "title", "sin", "shell", "ource", "sql", "local", "scan", "ce", "relation", "from", "subject", "use", "lower", "resource", "Source", "scope", "parent", "this", "key", "src", "inner", "store", "cause", "index", "unit", "si", "service", "position", "sequence", "base", "string", "input", "status", "language", "select", "range", "system", "sp", "query", "search", "s", "format", "origin", "start", "finder"], "target": ["output", "style", "arg", "top", "step", "bolt", "term", "location", "template", "link", "arget", "Target", "root", "rel", "token", "to", "local", "test", "t", "resource", "scope", "parent", "translation", "tree", "key", "null", "module", "goal", "dest", "other", "tif", "print", "base", "gt", "point", "that", "table", "match", "join", "query", "url", "origin", "alias", "ARGET", "pattern"], "files": ["uploads", "states", "faces", "assets", "ls", "balls", "plates", "banks", "headers", "workers", "users", "ports", "facts", "iles", "lets", "images", "pages", "jobs", "les", "lines", "packages", "styles", "books", "actions", "features", "members", "values", "fs", "parts", "models", "details", "reports", "tools", "resources", "modules", "pieces", "issues", "events", "thumbnails", "items", "objects", "services"], "file": ["path", "field", "ve", "word", "node", "model", "block", "tile", "user", "fe", "item", "f", "folder", "local", "row", "fp", "dir", "relation", "File", "feature", "resource", "el", "filename", "current", "parent", "le", "library", "e", "tree", "key", "be", "rule", "name", "label", "play", "page", "ile", "event", "pe", "line", "FILE", "entry", "print", "child", "base", "port", "table", "job", "document", "work", "data", "full", "foo", "image"], "inCh": [" inCod", "inCod", "rinChan", "cinCod", "cinCor", "outCod", "cinCr", "rinCod", "incCor", "cinSam", " inCl", " inch", "incCr", "inch", "cinCh", "cinch", "inChan", "cinChan", " inChan", "InCh", "rinCl", "incSam", "rinCh", "dinSam", "InCod", "incCh", "inCl", "outChan", "dinCh", "inCor", "InCl", "outch", "InChan", "dinCr", "inCr", "inSam", "dinCor"], "outCh": ["outCol", "inCol", "outputCod", "outCod", " outCod", " outCol", "inch", "inChan", "newCol", "newCod", " outch", "outputChan", " outGr", "outGr", " outChan", "outChan", "outputGr", "newCh", "outch", "newChan", "outputCh", "newch", "newGr"]}}
{"id1": "10266116", "id2": "22708533", "code1": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "code2": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"retrieveStream": [" RetrieveSteam", "retetchForm", " RetrievedForm", "retrievedFile", "retetchFile", "retireForm", "retrievedForm", "retrieveFile", "retireFile", " RetrieveStream", "retireStream", " RetrievedFile", " RetrieveForm", "retrieveForm", "retetchStream", " RetrievedSteam", "retireSteam", " RetrieveFile", "retrievedStream", "retrievedSteam", "retrieveSteam", " RetrievedStream", "retetchSteam"], "url": ["path", "http", "load", "html", "ls", "location", "addr", "term", "ur", "Url", "ul", "address", "q", "URL", "id", "rel", "util", "pl", "ssl", "uri", "dl", "channel", "resource", "server", "ref", "request", "str", "name", "mount", "impl", "ll", "xml", "l", "page", "err", "href", "remote", "base", "string", "domain", "file", "job", "log", "web", "https", "full", "cmd", "host", "hl", "pattern"], "getRequest": ["getCommand", "createMethod", "getrequest", "getCustomer", "httpResponse", "findResponse", "findCustomer", "makeAttempt", "giveMessage", "findAttempt", "createRequest", " getMessage", "makeResponse", "createrequest", "getMessage", "giveCommand", "httprequest", " getAttempt", "GetQuery", "giveQuery", "makeCustomer", "GetCommand", "getMethod", "httpMethod", " getCommand", " getCustomer", "GetMessage", " getQuery", "findRequest", " getrequest", " getMethod", "createResponse", "giveRequest", "httpRequest", "getQuery", "GetRequest", "makeRequest", "getAttempt"], "getResponse": ["checkBody", "getSolution", "checkRes", "getresponse", "GetApplication", "httpResponse", "checkResponse", " getSolution", "GetResponse", "httpSolution", "getResp", " getRes", "deleteResponse", "getApplication", "giveResponse", "deleteSolution", "GetRes", "deleteRequest", " getResp", "getRes", " getBody", " getresponse", "deleteResp", "GetBody", " getApplication", "checkRequest", "giveApplication", "giveRequest", "httpRequest", "getBody", "Getresponse", "GetRequest", "giveresponse", "httpResp"], "statusCode": ["sequenceStatus", " statusType", "sequenceCount", "statusNumber", "useCode", "statusCo", "successCode", "impactLength", "StatusStatus", " statusNumber", "statusLength", "versioncode", "versionCode", "impactCo", "statuscode", "statusStatus", " statuscode", " statusLength", "usecode", "StatusNumber", "impactCode", "successcode", "impactcode", " statusStatus", "statusCount", " statusCo", "sequenceCode", "StatusCount", "statusType", "versionCo", "useType", "successType", "versionLength", " statusCount", "StatusCode", "sequenceNumber"], "getResponseEntity": ["getResultObject", " getReturnEntity", "getReturnEntity", "getBlockEntity", "getresponseElement", "getRespEntry", "getResultEntry", " getReturnElement", "getResultEntity", "getresponseEntity", "GetresponseEntry", "getresponseUnit", "GetResponseEntry", "getResponseElement", "getResponseObject", " getReturnObject", "getRespEntity", "getRespUnit", " getResponseObject", "getResponseEnt", "getReturnEnt", "GetresponseUnit", "getBlockObject", "getBlockEnt", "getresponseEnt", "getReturnElement", " getResponseEnt", "GetResponseObject", "GetResponseUnit", "getResponseEntry", "getRespObject", "getBlockElement", "getresponseObject", "getReturnObject", "GetresponseEntity", " getResponseElement", "getResponseUnit", "GetResponseEntity", "getresponseEntry", "getResultUnit", " getReturnEnt", "GetresponseObject"]}}
{"id1": "19494842", "id2": "12678045", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"callService": ["useService", "runservice", "callservice", "runServices", " callservice", "useServices", " callQuery", "runService", "useservice", "callQuery", "runQuery", "useQuery", "callServices", " callServices"], "url": ["http", "ls", "sl", "bel", "link", "ur", "b", "Url", "ul", "address", "URL", "pl", "ssl", "uri", "dl", "nl", "client", "resource", "channel", "browser", "gl", "google", "str", "ll", "get", "service", "l", "char", "conn", "base", "acl", "file", "sb", "web", "oul", "r", "hl"], "in": ["out", "IN", "on", "din", "gin", "con", "it", "oin", "rin", "ri", "is", "ic", "mc", "and", "b", "ill", "read", "en", "inc", "io", "from", "er", "ins", "el", "bin", "all", "inner", "reader", "l", "sum", "isin", "In", "check", "input", "iter", "again", "i", "mn", " din", "inn", "r", "conf", "inf", "cin"], "inputLine": ["parseRow", "contextL", "inputRow", "parseLine", "helloLINE", "Inputline", "outputRow", " inputLINE", "contextLine", "helloFile", "outputline", "contextRow", "parseFile", "outputL", "helloLine", "InputRow", "responseline", " inputline", "responseRow", "inputline", "responseLine", "helloRow", " inputRow", "inputFile", "InputLine", "InputLINE", "inputL", "responseLINE", " inputL", "contextline", "parseLINE", " inputFile", "outputLine", "inputLINE"], "buf": ["buffer", "Buffer", "db", "block", "bed", "img", "msg", "pkg", "bar", "vet", "raf", "hung", "ob", "bag", "nm", "tab", "Buff", "inv", "alph", "area", "queue", "cv", "bu", "conv", "buff", "uf", "bg", "aux", "pb", "vec", "cb", "comm", "cam", "mk", "mem", "nom", "cap", "mu", "gor", "br", "bh", "fam", "cf", "cmd", "rb", "cur"], "answer": ["place", "ve", "message", "replace", "response", "onse", "review", "ver", "send", "address", "accept", "equ", "install", "about", "channel", "argument", "offer", "continue", "exit", "answered", "version", "poll", "ask", "Answer", "say", "username", "sequence", "result", "form", "print", "sn", "entry", "command", "again", "archive", "value", "reply", "option", "search", "array", "interpret", "remember", "image", "report", "cache", "question"]}}
{"id1": "160739", "id2": "3375724", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createFileStream", "createInputstream", " createOutputFile", " createFilestream", " createInputSteam", " createFileSteam", " createOutFile", "createOutputstream", "createInputFile", " createOutStream", "createInputStream", " createOutputSteam", "createOutputSteam", " createFileFile", " createInputStream", " createOutSteam", "createInputSteam", " createInputFile", " createOutstream", " createInputstream", "createOutputFile", " createOutputstream"], "inFile": ["inputPath", "inDir", "dinPort", "ninPath", "dinPath", "dinDir", " infile", "outFilename", " inPort", "infile", "ninFilename", "inputDir", " inPath", "ninFile", "outPath", "inFilename", "inPort", "outfile", "inputFile", "inputPort", "dinFile", " inDir", "inPath", " inFilename", "ninfile"], "outFile": ["Outfile", "exfile", "outPlace", "outPort", "outputFilename", "OutFilename", "outputFile", "outputPlace", "exFile", "newfile", "OutPort", "outputfile", "exPlace", "OutFile", "toPort", "outFilename", "newFilename", "tofile", "infile", "newFile", "toFile", "inFilename", "inPort", "outfile", "toFilename", "exFilename", "newPlace"], "k_blockSize": ["k_BlockTime", "k4BlockName", "k_BlockStyle", "k2byteLength", "k_byteSize", "k2blockLength", "k_blockName", "k4blockSize", "k2byteTime", "k4blockCount", "k2blockTime", "k_blockTime", "k_byteName", "k_batchLength", "k4BlockStyle", "k_BlockLength", "k_BlockSize", "k_BlockCount", "k2blockSize", "k4BlockSize", "k_byteTime", "k_batchTime", "k_blockCount", "k4BlockCount", "k2byteCount", "k_blockLength", "k_byteLength", "k4blockStyle", "k2byteSize", "k_blockStyle", "k_BlockName", "k_batchSize", "k4blockName", "k_byteCount", "k2blockCount", "k_batchCount", "k_byteStyle"], "byteCount": ["byteLength", "wordN", "bitN", "byteSize", "byteCode", "charPtr", "bitSize", "bitCounter", "linePtr", "bytecount", "wordCode", " byteLength", "bitCount", "bytePtr", "charCount", "lineLength", "byteCounter", " bytecount", "bbCode", "wordSize", "bitLength", " bytePtr", "bbN", "blockCounter", "blockLength", "charLength", "bitCode", "byteCheck", "blockCount", "bbSize", " byteCheck", "byteN", "wordCount", "charcount", "bbCount", " byteCounter", "linecount", "lineCount", "bitCheck", "blockCheck"], "buf": ["buffer", "proc", "Buffer", "db", "block", "img", "msg", "pkg", "fg", "b", "bag", "raw", "Buff", "bn", "alph", "cat", "bl", "queue", "cv", "seq", "conv", "arr", "buff", "uf", "bg", "cast", "pb", "ctr", "str", "vec", "cb", "doc", "bytes", "txt", "bc", "batch", "mem", "ctx", "tx", "cap", "exp", "cmd", "rb", "cur"], "ofp": ["owlpa", " ofpa", "ofd", "OFP", "owlp", "ofl", " ofP", "ofP", "owlP", "Ofpa", "Ofl", " ofl", "ofpa", "OFd", "Ofp", "OfP", "Ofd", "OFp", " ofd", "OFl", "owld"], "zos": ["ossus", "cos", "sbm", "esa", "zen", "zi", "es", "rss", "tis", "init", "hz", "amia", "zik", "jas", "ze", "zy", "zu", "psy", "gs", "osi", "zin", "bs", "za", "socket", "ez", "hess", "rez", "ws", "os", "zers", "zon", "css", "zag", "zes", "std", "zzle", "LOS", "ps", "webkit", "js", "enos", "rose", "settings", "zh", "zb", "bes", "eros", "zl", "cz", "south", "zer", "los", "python", "sch", "z", "zo", "oss", "sis", "jp", "zona", "nz", "zip"], "osw": ["iswx", "aosW", "osiw", "cosw", "ospace", "osd", "aosw", "sysw", "sysW", "aosd", "cosew", "oW", "syswd", "isw", "owa", "cosd", "issw", "osew", "ossw", "cosws", "osrw", "sysrw", "aoswd", "osws", " ossw", "osswx", "osiW", "opace", "ow", " oswx", "aoswa", "aospace", "aosrw", "osswd", "osiwa", "osipace", " osew", "ossrw", " osW", "osW", "isW", "aosew", " osd", "ossW", "oswa", "oswx", "osssw", "aosws", "oswd", " osws"], "bw": ["nbwe", "abwe", "besw", "bbx", "pbwb", "sbwb", "bex", "pbz", "sbw", "pbwe", "bwk", " bem", " bx", "bbz", " bwl", "obwb", "bwp", "bsw", "bbend", "nbew", "bwl", "bewk", "bbwp", " bex", "pbwt", "rbw", " bz", "bwb", "abew", "bwy", "nbw", "obwl", "bewl", "pbw", "wbw", "sbz", "pbwy", " bsw", "bew", "bem", "bbws", " bwp", "rbex", "wbz", "wbwp", " bwk", "wbem", " bwt", "bwt", "bwe", "obsw", "abwy", "bbex", "wbwt", "nbwy", " bend", "rbws", "wbend", "pbew", "bbw", "bz", "bws", "bx", "wbx", "abw", "sbwt", "obwt", " bws", "rbz", "obw", "obwk", "bbwt", "obz", "bend", "bbem"], "zot": ["ziot", "zerot", "zeronet", "zeror", "zonet", "zipot", "Zot", " ziat", "zoor", "Zit", " zott", "zott", " zo", "zerote", "zoot", "ziphot", "zoonet", "zoo", "zipiat", "zerit", "zeriat", " ziot", " zor", "zor", "zerhot", "zerott", "zipiot", " zonet", "Zote", "zhot", "zero", "Zott", "zote", "ziat", "zeriot", "zo", " zote", " zhot"], "ifp": [" ifd", " ifr", "iwd", " ifth", "iwp", " ifP", " iftp", "ifP", "isP", "Ifth", " ifjp", "iwr", "ifjp", "isjp", "ihp", "Ifjp", "isp", "ifr", "ihr", "ihtp", "iwtp", "IfP", "ifth", "ihd", "Ifp", "iftp", "ifd", "isth"], "zis": [" ziss", "izis", "zeris", " zi", "ezis", "zi", "izisa", "izi", "zoisa", " zIS", "zipic", "zoinit", "eziss", "zois", "zisa", "zerIS", "zIS", "zipis", " zic", "zisc", "zoiss", "zinit", "izinit", "ziinit", "izisc", "zic", "zeric", "ziisa", "ziis", "zipIS", "iziss", "ziss", "ziiss", " zisc", "ezi", "ezisc"], "isr": ["sisrs", "ispr", "iosstr", "itssr", "iospr", "isalr", "issrc", "iossr", "isscr", "issrs", "iosr", "itsstr", "isstr", "iscr", "issr", "isalpr", " isrs", "sisr", "siscr", "itspr", " isrc", "isalstr", "isrs", "sisrc", "isalsr", " iscr", "itsr", "isrc"], "br": ["wr", "gr", "dr", "shr", "bf", "bd", "b", "bp", "bm", "BR", "rel", "bn", "bl", "hr", "pr", "fr", "bt", "js", "Br", "cr", "bro", "bi", "obl", "str", "ctr", "Fr", "vr", "mr", "tr", "ptr", "bj", "sr", "lr", "ba", "bh", " Br", "kr", "ber", "r", "yr", "rb"], "zit": ["zeop", "zipIT", "iziti", "ziti", "zipit", "izip", "zist", "ozit", "czip", "czit", "ezlit", "zite", "ozunit", "ezIT", "lexIt", "ziit", "lexIT", "czop", "czunit", " zlit", "ziplit", "zIT", "zipist", "ziIt", "zlit", "ezite", " zip", " zIT", "cziti", "lexist", "zipite", "zunit", "lexit", "oziti", "ziIT", "zeit", "zipIt", "ezit", "zeip", "czot", "izit", "ozip", " zite", "zIt", "ziist", "zeot", "zop", " zop", "izunit", "zip"]}}
{"id1": "411595", "id2": "13063241", "code1": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"displayDiffResults": ["displaydiffStats", " displaydiffResult", " displayChangeresults", " displayChangeResults", " displayDiffResult", " displayChangeResult", "displaydiffResult", "displaydiffresults", " displayDiffStats", "displaydiffResults", "displayDiffresults", " displaydiffStats", " displayDiffresults", " displaydiffResults", "displayDiffStats", " displaydiffresults", "displayDiffResult", " displayChangeStats"], "outFile": ["nfile", " outDisk", "outputFILE", "targetStream", "OUTSet", "OUTFile", "outputFile", " outDir", "targetFile", "outputPath", "outputfile", " outfile", "targetPath", "outDisk", " outPath", "outputDir", "OUTfile", "outputSet", " outSet", "outPath", "outputDisk", "outfile", "outSet", "targetFILE", "OUTPath", "outputStream", "nFile", "outDir", "nDir", "outFILE", " outFILE", "nDisk"], "outStream": [" outSteam", "outputSteam", "writeStreamer", "outputStreamer", "reportStream", "outputFile", " outStreamer", "writeSteam", "outSteam", "outView", " outstream", "writeView", "outputstream", "outputView", "reportSteam", "outstream", "reportstream", "reportFile", "writeStream", " outView", "outputStream", "outStreamer"], "out": ["timeout", "by", "it", "aos", "to", "t", "at", "inner", "error", "external", "sum", "hit", "err", "OUT", "file", "list", "ch", "on", "con", "init", "auto", "ent", "o", "ex", "outs", "conv", "op", "ou", "write", "g", "writer", "w", "l", "obj", "go", "net", "conn", "print", "batch", "entry", "again", "oss", "co", "cmd", "conf", "output", "n", "put", "can", "os", "client", "up", "nt", "one", "page", "check", "copy", "table", "update", "over", "Out", "user", "sys", "b", "flush", "raw", "console", "pretty", "io", "v", "all", "screen", "log", "format", "empty", "in", "cache"], "bgcolor": ["backgroundcolor", "bgname", " backgroundcolor", "fontname", "bgcol", "backgroundcol", " backgroundColor", "fontcol", " backgroundname", "fontColor", "fontcolor", "bgColor", "backgroundname", " backgroundcol", "backgroundColor"], "onMouseOver": ["onmouseOver", "onMouseOut", " onmouseover", "onmouseover", "onmouseOut", "onMouseover", " onMouseover", "onmouseDown", " onmouseOver", "onMouseDown", " onMouseDown", " onmouseDown", " onmouseOut", " onMouseOut"]}}
{"id1": "19910627", "id2": "5142039", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "label": 0, "substitutes": {"getData": ["getResponse", " getResponse", "getDATA", "updatedata", "exportData", " getdata", "exportdata", " getDATA", "exportResponse", "updateData", "updateDATA", "exportDATA", "updateResponse", "getdata"], "httpclient": ["Httpparent", "httpscell", " httpcell", "httpconfig", "httpconnection", "httpcell", "Httpclient", "httpsClient", "httpsconfig", "socketclient", "HttpClient", "socketconfig", "socketcell", "socketClient", "httpparent", "httpsparent", "httpsconnection", "httpClient", " httpClient", "ttpclient", "ttpparent", "ttpconnection", " httpconfig", "Httpconnection", "ttpClient", "httpsclient"], "get": ["http", "patch", "add", "init", "open", "force", "gets", "build", "put", "see", "send", "body", "make", "read", "create", "execute", "use", "like", "give", "op", "current", "require", "call", "request", "delete", "g", "pre", "need", "name", "pull", "post", "service", "Get", "got", "check", "GET", "set", "select", "show", "parse", "find", "query", "ge", "start", "handle", "play", "exec", "cache"], "response": ["output", "ve", "message", "application", "function", "json", "description", "block", "open", "example", "connection", "onse", "see", "body", "console", "re", "respond", "answer", "pos", "resp", "resource", "yes", "still", "page", "sequence", "result", "Response", "remote", "entry", "that", "object", "status", "reply", "document", "given", "success", "trace", "res", "successful", "report"], "entity": ["orm", "message", "json", "ity", "model", "voice", "instance", "ent", "type", "detail", "em", "person", "ce", "icon", "resource", "el", "email", "ITY", "component", "le", "e", "eric", "name", "unit", "Entity", "quote", "obj", "event", "result", "pe", "line", "activity", "entry", "details", "object", "comment", "document", "query", "info", "image"], "instream": [" inpod", "Instream", "excase", "outpod", " incase", "inputstream", "inconsole", "inspod", "instack", "instore", "fromcase", " inconsole", "inputconsole", "outconsole", " inStream", "fromstream", "inputproc", "inputStream", " incomplete", "infield", "inStream", "inproc", "incomplete", "outstream", "fromstack", "inpod", "insfield", " inproc", " instack", "outproc", "fromconsole", " infield", "outcomplete", "insStream", "Incomplete", "insstream", "exstack", "outfield", "InStream", "exstream", "outStream", "outstore", " instore", "Instore", "exconsole", "incase"], "responseMessage": ["ResponseValue", " responseValue", " responseText", "responseValue", " responsemessage", "answerMsg", "answerMessage", "ResponseMsg", " responseString", "answerString", "Responsemessage", "ResponseText", "resMsg", " responseMsg", "responseMsg", "responseString", "responsemessage", "ResponseMessage", "resmessage", "responseText", "answerValue", "ResponseString", "resMessage", "resText"]}}
{"id1": "7169984", "id2": "2324868", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 0, "substitutes": {"connRemote": [" connLocal", " validateRemote", " authLocal", " communicateAsync", " communicateLocal", " connBase", " authAsync", " connAsync", " validateLocal", " communicateBase", " authBase", " validateBase", " communicateRemote", " validateAsync", " authRemote"], "jsonObject": ["JSONElement", " jsonElement", "jsArray", "JSONArray", "jsonObj", "xmlAst", "xmlObject", "JSONAst", " jsonArray", "jsonElement", "xmlElement", " jsonObj", "jsObject", "jsonArray", "jsObj", "jsobject", "xmlObj", "JSONObj", "jsonobject", " jsonAst", "JSONObject", "JSONobject", " jsonobject", "jsonAst"], "OPCode": [" OPType", "OpType", " OpName", "OPData", "OPName", " OPCause", " OpType", "OPCause", " OpCode", "OpCode", " OPcode", "OpName", "OPType", " OpCause", "opType", " OPName", "OpData", "opCode", "OpCause", "Opcode", "opcode", "OPcode", "opData", " OPData"], "retSrc": ["retStrource", " retSRC", "retAsRC", "RetStrrc", "retSource", "retSetRC", " retInsource", "retSetcr", "retAsrc", "retSetrc", "RetSsrc", "retStrRC", "retSsrc", "retNRC", "RetSRC", " retInsrc", "retInscr", "retNcr", "returnSRC", " retInsRC", "retInssrc", "retNrc", "RetStrrs", "retRsource", "retAssrc", " retSource", "retInsRC", "retStrrs", "retSetsrc", "retInsrs", "RetSrc", "retRsrc", "returnSetRC", "retRssrc", "retInsrc", "RetStrsrc", "returnSrc", "retStrrc", "returnSetsrc", "RetStrRC", "retSrs", "retStrsrc", "retInsource", "returnSetrc", "retRsRC", " retInssrc", "returnSsrc", "retAsrs", "retSRC", "retNsrc", " retSsrc", "retScr", "returnScr", "RetSrs", "returnSetcr"], "httpClient": [" httpSystem", "healthCo", " httpGe", "httpGe", "healthNet", "ttpStore", " httpStore", "upperClient", "httpCo", "upperCo", "httpConnect", "HttpStore", "HttpClient", "healthClient", "upperGe", "ttpSystem", "upperNet", "HttpConnect", "httpNet", "httpSystem", " httpNet", " httpCo", "ttpClient", "httpStore", "HttpSystem", "ttpConnect", "healthGe", " httpConnect"], "httpPost": ["HTTPPut", "httpsPost", "httpPress", "httppost", " httppost", "HTTPpost", "hoverpost", "httpsPress", "ttppost", "healthPress", "httpPre", "httpsPOST", "healthPOST", "ttpPost", " httpPOST", "hpost", "ttpPre", "httpPut", "hPOST", "hoverPost", "HTTPPost", "HTTPPOST", "healthPost", "ttpPut", " httpPut", " httpPre", "ttpPOST", " httpPress", "hoverPre", "hoverPOST", "hPost", "httpPOST"], "httpParams": ["httpPrams", "ttpPrars", "httpPrants", "httpparams", "httpPms", "ttpParps", "httpPgs", "httpParms", "ttpPrps", " httpPgs", "httpParps", "httpPants", "httpparms", " httpPams", " httpParms", "httpParants", "httpPargs", "ttpParars", "ttpPrms", "ttpParams", "ttpPrams", "httpSharants", "httpPrars", "httpPars", " httpPants", "httpSharams", "httpShargs", "httpparps", "httpPrps", "httpparars", " httpPargs", " httpPms", "httpPams", "httpSharms", "httpPrgs", "ttpParms", " httpParants", "httpPps", "httpPrms", "httpParars"], "nameValuePair": ["nameValuePariece", "nameValuePartpair", "nameValuePerseter", "nameValuePersair", "nameValueParair", "nameValuePointpair", "nameValuePeter", "nameValuepiece", "nameNameParatch", "nameValueParpair", "nameNamePair", "nameValuePatch", "nameKeyPair", "nameValuePointairs", "nameValueChair", "nameKeyParair", "nameValuepeter", "nameValuePartair", "nameValuePareter", "nameNameParpair", "nameValuePairs", "nameValuePiece", "nameKeyPairs", "nameValuesPpair", "nameValuepair", "nameValuePartatch", "nameValueppair", "nameValuePpair", "nameValuePointair", "nameValuePointiece", "nameValuePersairs", "nameValueChpair", "nameValuesPairs", "nameKeyParpair", "nameValueParairs", "nameValuespiece", "nameKeyParairs", "nameValuespairs", "nameValueParatch", "nameKeyPeter", "nameNameParair", "nameValuespair", "nameValuesppair", "nameValuepairs", "nameValuesPair", "nameValuesPiece", "nameValuepatch", "nameKeyPpair", "nameValuePerspair", "nameNamePpair", "nameNamePatch", "nameKeyPareter", "nameValueChairs"], "response": ["output", "message", "application", "social", "json", "description", "block", "onse", "connection", "body", "entity", "relation", "frame", "respond", "answer", "resp", " responding", "e", "request", "tree", "next", "xml", "view", "still", "service", "Response", "result", "sequence", "command", "entry", "object", "reply", "document", "given", "data", "trace", "res", "image", "report", "cache", "network"]}}
{"id1": "12128591", "id2": "9796161", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"hash": [" mac", " check", "update", " sum", "Hash", " version", " text", " address", " equals", " signature", " key", "id", "h", " hashing", " fingerprint", "code", " code", "hex", " salt", "dump", " body", " message", "print", " h", " id", " Hash"], "data": ["output", "buffer", "message", "text", "json", "html", "password", "window", "block", "hello", "a", "ata", "secret", "raw", "dat", "rel", "accept", "DATA", "content", "this", "any", "bytes", "sequence", "result", "command", "batch", "string", "input", "action", "padding", "table", "value", "mu", "info", "what", "out", "image"], "digest": [" digist", "deest", "digly", "dese", "digist", "deist", "Digse", " digse", "Digester", "initEST", "mdests", " digave", " digested", "Digest", "digested", "displayest", " digit", "mdester", "displayested", "equse", "initested", "redly", " digEST", "digave", "mailly", "equest", "redgest", "redest", "displayse", "equave", "Digests", "DigEST", "digit", "displayests", "mdested", "redester", "digse", "diggest", "Digested", "mdly", "digEST", "digests", "Digist", "mailester", "mailest", "initester", "equit", "digester", "mdgest", "mdest", "mailgest", " digester", "initest", "mdit", "mdave", "mdse", "deested"]}}
{"id1": "949327", "id2": "1141361", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"f": ["fn", "path", "bf", "lf", "n", "j", "it", "fo", "ret", "b", "q", "p", "y", "o", "fi", "h", "fp", "test", "dir", "ft", "t", "fb", "fr", "filename", "v", "fc", "fm", "fab", "fax", "e", "fed", "g", "name", "d", "fac", "w", "rf", "l", "fx", "fs", "r", "form", "elf", "base", "def", "m", "df", "tf", "file", "exp", "info", "fw", "F", "cf", "fd", "sf", "c", "fa"], "in": ["IN", "on", "din", "gin", " IN", "con", "add", "im", "by", "n", "init", "it", "oin", "rin", "ai", "is", "ic", "lo", "nin", "o", "h", "local", "en", "inc", "io", "from", "mm", "re", "ind", "make", "al", "ins", "t", "er", "ex", "ma", "up", "ac", "bin", "at", "all", "inner", "reader", "get", "isin", "r", "l", "In", "input", "m", "iter", "again", "log", "pi", " din", "info", "inn", "thin", "inf", "cin"], "cbuf": ["cfuff", "rbdf", "cdbuf", "sbbuf", "rboff", "cbuffy", "cduffy", "cbf", "bcoff", "cbfg", "cbdf", "gbf", "CBbf", "cduff", "bcdf", "abbbuf", "bcuff", "cdoff", "cduf", "nbuff", "gbuff", "CBf", "nbbuf", "cboff", "abbfg", "CBuff", "abbuf", "CBuffy", "cff", "gbuf", "cbather", "cfbf", "CBuf", "sbuff", "rbuf", "cbbf", "gbbf", "CBbuf", "bcather", "sbuf", "rbather", "cbbuf", "bcfg", "bcuf", "bcbuf", "rbuff", "rbfg", "nbfg", "abbdf", "rbuffy", "cbuff", "nbuf", "cfuf", "rbbuf", "sbather"], "read": ["depth", "core", "se", "hello", "it", "sync", "ext", "count", "scan", "re", "ind", "ed", "fail", "pre", "trust", "error", "fill", "set", "iter", "burst", "query", "slow", "r", "ly", "report", "buffer", "text", "close", "orig", "is", "Read", "link", "q", "old", "row", "ke", "give", "READ", "allow", "rank", "ready", "run", "clear", "write", "reader", "readable", "reading", "k", "rate", "pe", "print", "wait", "skip", "parse", "chain", "data", "start", "handle", "ip", "saw", "miss", "est", "add", "dev", "n", "ret", "shift", "feed", "current", " Read", "need", "view", "index", "get", "ignore", "Reader", "mem", "check", "input", "select", "find", "mix", "play", "pack", "seek", "ank", "load", "connect", "think", "x", "bind", "open", "ai", "hold", "roll", "send", "raw", "end", "ink", "test", "io", "default", "ok", "length", "reach", "key", "poll", "stream", "record", "ead", "value", "log", "range", "height", "reads"], "totRead": ["totaLength", "tcotConnect", "totaRead", "totalLength", "taotRead", "tootCheck", "ptOTLoad", "tiotFill", "notReader", "ptOTWrite", "tacotDisplay", "totaWrite", "tottAdd", "ttotRead", "tottedPrint", "tottFind", "totalFind", "toteRun", "notWrite", "totaReader", "totRun", "totConnect", "totaNeed", "notalNeed", "retotWrit", " totalRead", "totSend", "tiotVal", "notRead", "totalPrint", "letrotSee", "tiotReader", "totReader", "totalSee", "tottReader", "totedRead", "letotRead", "tokLoad", "toticFind", "tottedReader", "atotFill", "tcotCheck", " totFind", "tottPrint", "retottReader", "tiotHave", "tfatRead", "toticRun", "toticWrite", "notNeed", " totalWrite", "taotDisplay", "trotWrite", "totBreak", "tfatWrite", "tOTWrite", "tokFind", "tobyLoad", "trotRead", "ptotWrite", "tcotBreak", "totaFill", "ttottNeed", "totaPrint", "tfatLoad", " totBuild", "notalWrite", "toteFind", "tottRun", "totFill", "tootRead", "tiotPrint", "toiotRead", "tOTFind", "tiotBreak", "notalPrint", "atotaFill", "totLoad", "ttotWrite", "letotSee", "tobyRead", "tcotRead", "ttotAdd", "totDisplay", "tacotRead", " totalBuild", "trotFind", "totalCheck", "tiatFill", "totedFill", "retotPrint", "tiatLoad", "tacotCheck", "notaLoad", "ltotLoad", "totaAdd", "tobyWrite", "toteNeed", "toiotVal", "totLength", "toteReader", "atotaRead", "tcotDisplay", "totalLoad", "toiotBreak", "notaWrite", "tiotSend", "totaSee", "toteLoad", "ttottWrite", "totWrit", "toteWrite", "ltotaFill", "atotRead", "tiotWrit", "tiatSend", "tiatBuild", "toiotSend", "totBuild", "totedHave", "toticRead", "taotConnect", "tootVal", "tokWrite", "atotHave", "totedPrint", "ltotRead", "ptotFind", "toteBuild", "tootSend", "letrotWrite", "notaReader", " toteWrite", "letrotFind", "retottWrit", "tcotVal", "notalRead", "tiatVal", " totWrite", "retotRead", "atotaHave", "ltotaLoad", "totalBuild", "tootBreak", "totNeed", "retotReader", "totVal", "ptOTFind", "tOTNeed", "tootConnect", " toteRead", "totHave", "totaFind", "tcotSend", "ttottRead", "notLoad", "notCheck", " toteFind", "tootDisplay", "totalRead", "ttottAdd", "toteLength", "ptOTRead", " totalLength", "totSee", "ltotaBuild", "tottWrit", "totWrite", "retottPrint", "tottWrite", "totalWrite", "notalCheck", "tiatRead", "totaHave", "totalNeed", "notalLoad", "totaCheck", "ltotFill", "tfatReader", "letotFind", "tokRead", "totaBuild", " totLength", "notPrint", "ltotBuild", "totAdd", "toteAdd", "tacotConnect", "tiotRead", "tiatBreak", "tOTLoad", "ptotRead", "trotSee", "tobyCheck", "toteFill", "letrotRead", "ptotLoad", "ttotNeed", "totaLoad", "tottRead", "toteRead", "tottedRead", "retottRead", "totCheck", "tottedWrit", "tOTRead", "atotPrint", "notaRead", "totaDisplay", " toteRun", "tobyNeed", " totRun", "totaConnect", "letotWrite", "tobyPrint", "ltotaRead", "totFind", "taotCheck", "atotaPrint", "tottNeed", "totPrint"], "out": ["output", "ch", "con", "or", "n", "auto", "Out", "sys", "b", "o", "aos", "to", "os", "end", "io", "OU", "ex", "outs", "t", "conv", "up", "v", "ou", "at", "write", "g", "writer", "w", "r", "obj", "net", "OUT", "log", "oss", "co", "s", "we", "res", "c"], "i": ["ims", "ion", "it", "ri", "ic", "iu", "to", "iii", "ind", "t", "qi", "gi", "any", "set", "status", "iy", "ij", "r", "cli", "li", "oi", "zi", "j", "my", "init", "ini", "is", "ui", "ia", "q", "o", "ico", " I", "uri", "e", "this", "hi", "g", "ti", "bi", "ji", "ice", "l", "you", "print", "us", "ami", "chain", "sim", "ip", "\u0438", "multi", "im", "ity", "ie", "me", "um", "id", "mm", "ci", "ii", "client", "index", "ei", "m", "xi", "iq", "pi", "php", "dr", "x", "phi", "ai", "ski", "b", "p", "y", "integer", "io", "mi", "ki", "v", "PI", "si", "I", "point", "di", "info", "s", "c", "ix"]}}
{"id1": "3375722", "id2": "7372311", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importatSelectr", " importarDator", " importarDatr", " importarStors", " importarStor", " importatSelectors", " importarSetors", " importarStero", " importarSelectr", " importatSetero", " importarSelectors", " importatSetors", " importarDatero", " importarSelectero", " importarSetr", " importarSetero", " importarDators", " importarSelector", " importatSetor", " importatSelector", " importatSelectero", " importatSetr", " importarStr"], "pArquivoXLS": ["pArquiveXLS", "pArquivoEXLS", "pArquivoXML", "pArquivoXXCS", "pArquivoOXCS", "pArquivoEXCS", "pArquiveXls", "pArquiveEXCS", "pArquivoEXls", "pArquivoEXML", "pArquivoTXCS", "pArquivoTXML", "pArquivoDXLS", "pArquarioEXCS", "pArquarioXCS", "pArquivoXXLS", "pArquarioEXML", "pArquiveEXLS", "pArquivoDXML", "pArquivoXXls", "pArquarioEXls", "pArquarioXLS", "pArquivoTXLS", "pArquiveXML", "pArquarioXls", "pArquivoXXML", "pArquivoOXls", "pArquivoDXCS", "pArquivoOXLS", "pArquivoTXls", "pArquivoDXls", "pArquiveEXls", "pArquarioEXLS", "pArquivoOXML", "pArquarioXML", "pArquivoXls", "pArquiveEXML", "pArquiveXCS", "pArquivoXCS"], "pCabecalhoSetor": ["pCabecalhaSetr", "pCabecalhoStar", "pCabecalhaSetor", "pCabecalhoStr", "pCabecalhoStor", "pCabecalhaSetar", "pCabecalhaSetter", "pCabecalhoSetr", "pCabecalhoSetar", "pCabecalhoStter", "pCabecalhoSetter"], "pAndamento": ["pAndmentO", "pAndamente", "pandmento", "pAndmentos", "pAndimento", "pAndimentos", "pandamente", "pAndemento", "pAndementO", "pAndementos", "pandamentos", "pandmentos", "pAndamentos", "pandamentO", "pandmentO", "pAndmente", "pandamento", "pAndamentO", "pAndimentO", "pandmente", "pAndimente", "pAndemente", "pAndmento"], "iLinha": ["iLuha", "aiPlanva", "iLinva", "iEnva", "iPlanha", "iLuzo", "iEn\u00e7a", "aiPlan\u00e7a", "aiLin\u00e7a", "aiPlanha", "iPlan\u00e7a", "aiLinha", "aiPlanzo", "iPlanva", "iEnzo", "iPlanzo", "iLin\u00e7a", "aiLinzo", "iLu\u00e7a", "iEnha", "iLuva", "aiLinva", "iLinzo"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestinos", "stmtLimpezaInicialDecione", "stmtLimpezaInicioDestinos", "stmtLimpezaInicialEstination", "stmtLimpezaInitalDestINO", "stmtLimpezaInicialDecINO", "stmtLimpezaInitalEstino", "stmtLimpezaInicialEstINO", "stmtLimpezaInicialEstino", "stmtLimpezaInicioDestin", "stmtLimpezaInicioEstin", "stmtLimpezaInicioDestination", "stmtLimpezaIniciodestino", "stmtLimpezaInitalEstINO", "stmtLimpezaInicialDestione", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialDestin", "stmtLimpezaIniciodestinos", "stmtLimpezaInitalEstinos", "stmtLimpezaInitalDestione", "stmtLimpezaInicialdestination", "stmtLimpezaInitalDestino", "stmtLimpezaInicialDecino", "stmtLimpezaInicioEstino", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDecinos", "stmtLimpezaInicioEstINO", "stmtLimpezaInitalDestinos", "stmtLimpezaInicialEstione", "stmtLimpezaInitalEstione", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDestINO", "stmtLimpezaInicioDestINO", "stmtLimpezaInicioEstination", "stmtLimpezaInicialdestino", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialEstin", "stmtLimpezaInicioDestino", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialdestin", "stmtLimpezaIniciodestination"], "stmtDestino": ["stmDestin", "stmpDestoin", "stmDestination", "stmtOrigino", "stmpDestinos", "stmtOrigination", "stmtOrigoin", "stmtDecino", "stmtDesination", "stmtDestination", "stmdestano", "stmtdestano", "stmtdestoin", "stmtdestinos", "stmpOriginos", "stmOrigino", "stmpDestination", "stmtdestination", "stmtOrigined", "stmtDestined", "stmpOrigoin", "stmtDesin", "stmtDesino", "stmtdestin", "stmtDestin", "stmtStino", "stmtDescino", "stmOrigination", "stmtStinos", "stmtDecin", "stmDestined", "stmtStoin", "stmtOriginos", "stmpDestino", "stmdestin", "stmtDestoin", "stmtOrigin", "stmtDescination", "stmtdestino", "stmdestino", "stmtDestano", "stmpOrigino", "stmDestano", "stmtDecination", "stmtStination", "stmtDesano", "stmtDecano", "stmtDescined", "stmDestino", "stmtDescin", "stmOrigin", "stmdestination", "stmpOrigination", "stmtDestinos", "stmOrigined"], "arquivo": ["raquiva", " araquive", " araquiva", "araquario", "arqarius", "arquerarius", "rquivo", "raquivo", "arquive", "arquerario", "rquiva", "rquario", "raquarius", "arquarius", " arqiva", " arQuive", " arqivo", "raquario", " arquario", " arqive", "araquivo", "rquarius", " arQuario", "arqario", " arQuivo", "arquerivo", "arqiva", " araquivo", "arqueriva", "araquiva", "arqive", " arquiva", "arquiva", "arquario", " araquario", " arquive", "arqivo", " arqario", " arQuiva", "araquarius"], "plan1": ["panel0", "plan2", "Plan1", " plan2", "panel2", " plan0", "panel01", "plan01", "PlanOne", " planner1", " plan01", "Plan01", " planner2", " plannerOne", "Plan2", "plan0", "Plan0", " planOne", "planOne", " planner0", "panel1"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTRAS__", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTRos__", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTERos__", "QUANTIDADE_DE_REGISTROs__", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROs2", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRANS_", "QUANTIDADE_DE_REGISTROS2"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTERosON", "QUANTIDADE_DE_REGISTEROSON", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTRIES2", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTRATESON", "QUANTIDADE_DE_REGISTROSON", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRosON", "QUANTIDADE_DE_REGISTRATIONSON", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROS2"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROS_"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstIMada", "quantidadeDeRegistrosEstifated", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimated", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstipated", "quantidadeDeRegistrosEstifados", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstIMados", "quantidadeDeRegistrosEstIMated", "quantidadeDeRegistrosEstIMadas", "quantidadeDeRegistrosEstimadas"], "vSetor": ["valuesSetora", "valuesSetor", "valuesSetero", "vSelectora", "vSETero", "valuesSetar", "valuesSETor", "vSelectero", "vEndero", "vSetero", "vSetora", "vSETora", "vSETar", "vSelector", "vSetar", "vEndor", "vSETor", "vEndora", "valuesSETar", "vSelectar", "valuesSETero", "valuesSETora", "vEndar"], "vSubsetor": ["vSubmento", "vSubetOR", "vSubmentOR", "vSubeto", "vsubscriptor", "vSubscripto", "vsubseto", "vsubscriptOR", "vSubscriptation", "vSubmentation", "vsubsetor", "vsubscripto", "vSubscriptor", "vsubsetOR", "vSubscriptOR", "vSubetation", "vSubsetation", "vSubsetOR", "vSubmentor", "vsubsetation", "vSubetor", "vsubscriptation", "vSubseto"], "vSegmento": ["vSeggmentao", "vSegMENTao", "vIncrementano", "vSeggmentano", "vSegementao", "vIncreementano", "vSegementano", "vSegMENTO", "vSegMENTo", "vIncreementO", "vIncrementO", "vIncreemento", "vIncreementao", "vIncrementao", "vSegementO", "vSegmentao", "vSegemento", "vSeggmento", "vSegmentO", "vSegmentano", "vSegMENTano", "vIncremento", "vSeggmentO"], "registroAtual": ["Registroatual", "Registroatomic", "RegistrosAtual", "RegistroActUAL", "RegistrosAtuel", "RegistrosActuel", "RegistroATuel", "RegistroATUAL", "RegistrosAtomic", "RegistrosActual", "RegistroActual", "RegistroAtUAL", "RegistroATual", "RegistrosActomic", "RegistrosActUAL", "RegistroAtuel", "RegistroActomic", "Registroatuel", "RegistroATomic", "RegistrosAtUAL", "RegistroAtual", "RegistroatUAL", "RegistroAtomic", "RegistroActuel"], "vPapeisPorSegmento": ["vPapeisPorSegmentO", "vPapeisPorSegmentedo", "vPapeisPorSegmentede", "vPapeisPorGmentao", "vPapeisPorSegamentO", "vPapeisPorGamentao", "vPapeisPorSegamentao", "vPapeisPorSegmentedO", "vPapeisPorSegmentedao", "vPapeisPorSegmente", "vPapeisPorSegementao", "vPapeisPorSegamento", "vPapeisPorGamentO", "vPapeisPorSegementO", "vPapeisPorGmento", "vPapeisPorGmentO", "vPapeisPorGmente", "vPapeisPorSegamente", "vPapeisPorGamento", "vPapeisPorSegemente", "vPapeisPorGamente", "vPapeisPorSegemento", "vPapeisPorSegmentao"], "sql": ["fn", "orm", "series", "expression", "session", "spr", "mail", "json", "html", "description", "db", "ls", "prefix", "template", "pel", "sd", "wal", "sys", "statement", "condition", "seed", "pg", "params", "ql", "socket", "rel", "inv", "SQL", "install", "pr", "dl", "security", "nl", "spec", "cfg", "email", "js", "sol", "str", "xml", "details", "string", "expr", "table", "scl", "csv", "log", "select", "software", "comment", "sp", "query", "s", "sv", "eps", "url", "cmd", "sq"]}}
{"id1": "19006212", "id2": "18613870", "code1": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"Load": [" Create", "load", "loads", "Play", "Open", "Read", "Init", "Import", " Init", "Create", "loader", "Save", " Add", " Get", "read", "Add", "New", "File", " Import", " Read", "Loading", "Find", "Loader", " Open", "Get", "Download"], "fname": ["pname", "Fname", "fclynn", "frfile", "fullfilename", "fctype", "filefile", "lpath", "filepath", " fnam", " fName", "fnm", "frName", "fullName", "fullnm", "fpname", "lfile", "fcfilename", "filetype", "fullname", " flynn", "pName", "fnam", "fcnames", "fcname", " fpath", "fpnam", "lname", "fpfile", " ftype", "fcnm", "frname", "fileName", "filename", "fpath", "fpName", " fnames", "fName", "ftype", "fnames", "fcpath", "frnam", "fullnames", " ffile", "ffilename", " ffilename", "Ffile", "fulllynn", "pfile", "flynn", "ppath", "filenam", "FName", "ffile", "fcName", " fnm", "lName", "Fpath"], "f": [" fa", "bf", " F", "face", "fo", "a", "b", "p", "fp", "t", "fr", "fc", "fm", "e", "g", "d", "w", "fs", "form", " e", "m", "file", "fw", "F", "cf", "sf", "c", "fa"], "aType": ["aField", "aTypes", " aField", "oField", "bField", "aFile", " aTypes", "oTypes", " aFile", "oFile", "bType", "oType", "bFile", "bTypes"], "aElement": ["oaCell", "oaElement", "AElement", "aCell", "oaHeader", " aHeader", "ACell", "oaEntity", "aHeader", " aCell", "AEntity", "aEntity", "AHeader", " aEntity"], "content": ["message", "Content", "load", "text", "description", "template", "section", "title", "body", "size", "default", "code", "script", "version", "label", "xml", "view", "txt", "sequence", "source", "object", "action", "value", "comment", "document", "data", "format", "layout", "cache"], "Ax": ["Col", "Ha", "Tx", "Az", "Area", "X", "He", "Num", "Ap", "ox", "Pos", "Y", "Dim", "AX", "At", "Wa", "Ty", "ax", "ay", "Ar", "Al", "Ex", "xi", "Typ", "AI", "Am"], "Ay": ["Ali", " Ny", "Opp", "Bet", "Ba", "Sy", "Az", "Gy", "Imm", "Ry", "Sky", "Serv", "Li", "Ac", "Ty", "Yu", "Py", "Tok", "Rot", "Mut", "Pan", "Mal", "Lin", "Typ", "Ak", "Bi", "Xi", "Bat"], "aTemplate": ["oController", "aTarget", "anTarget", "aLayout", "aController", "oTarget", " aLayout", "anController", "anLayout", " aController", " aTarget", "oLayout", "oTemplate", "anTemplate"], "factory": ["fcreate", "hacter", "formixture", "tacter", "tixture", "Factory", "hiber", "fiber", "formactory", " fFactory", "hixture", "FFactory", " fcreate", "cfcreate", " fictionary", "fixture", "formacter", "cfFactory", "tiber", "fictionary", "Fcreate", "Fictionary", "formiber", "facter", "fFactory", "cfactory", "cfictionary", "tactory", "hactory"], "data_read": ["Data_length", "data_loaded", "Data_read", "data_length", "Data_used", "Data_loaded", "data_used"], "url": ["http", "builder", "mail", "ls", "location", "abs", "ol", "sl", "org", "user", "bel", "link", "ur", "Url", "ul", "address", "ml", "ob", "URL", "loader", "sql", "norm", "rel", "util", "bb", "dl", "uri", "loc", "nl", "resource", "channel", "browser", "gl", "ref", "name", "str", "xml", "mb", "ll", "l", "u", "char", "kl", "result", "lr", "rl", "file", "domain", "web", "data"], "parser": ["builder", "per", "json", "function", "arser", "password", "penter", "instance", "peer", "worker", "jack", "tar", "processor", "rer", "lp", "p", "loader", "iterator", "basic", "er", "asser", "Parser", "browser", "inner", "writer", "doctor", "reader", "xml", "policy", "bank", "Reader", "layer", "language", "file", "parse", "system", "document", "walker", "cer", "format", "asper", "ler"], "i": ["multi", "zi", "x", "j", "my", "phi", "it", "ini", "ai", "is", "ie", "ic", "ui", "me", "id", "y", "mi", "ci", "gu", "ki", "er", "ind", "t", "qi", "ii", "v", "gi", "e", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "u", "ei", "yi", "m", "xi", "us", "iq", "ami", "di", "chain", "pi", "ij", "info", "sim", "in", "cli", "li", "oi", "ix"], "start_x": ["startingix", " start_ex", "startingx", "start_xs", "start_ex", " start_X", "start_ix", "startingxs", "start_X", "startingex", " start_ix", " start_xs"], "start_y": ["end_py", " start_cy", "start_py", "start09y", "end_y", "start09cy", " start_yy", "end_b", "start_yy", "start09yy", "start_b", "end_x", "start09x", "start_cy"]}}
{"id1": "5543349", "id2": "22442270", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"loadMFileViaWeb": ["loadMFileByWeb", "loadMFileUsingWeb", "loadMFilesviaWe", "loadMFilesviaweb", "loadMFileviaWe", "loadMFilesViaweb", "loadMFileViaWe", "loadMFileviaweb", "loadMFilesViaWeb", "loadMFileviaWeb", "loadMFileByWe", "loadMFileByweb", "loadMFilesViaWe", "loadMFileUsingweb", "loadMFileViaweb", "loadMFileUsingWe", "loadMFilesviaWeb"], "codeBase": ["uribase", "codeMark", " codeRoot", "fileBase", "CodeRoot", "fileBased", "filebase", "codebase", "CodeBased", "uriMark", "codeBased", "uriBase", "CodeBase", " codebase", " codeBased", " codeMark", "CodeMark", "uriBased", "Codebase", "fileRoot", "codeRoot"], "directoryAndFile": ["DirectoryandModel", " directoryAndDirectory", "directoryOrType", " directoryOrFile", "directoryandFile", "directoryAndType", "DirectoryandPath", "DirectoryAndFile", "directoryAndPath", "directoryButFile", " directoryAndfile", "directoryOrPath", "directoryOrDirectory", "directoryAndDirectory", " directoryOrDirectory", "DirectoryAndPath", "Directoryandfile", "directoryandPath", "directoryandfile", " directoryAndType", " directoryOrType", " directoryOrfile", "DirectoryandFile", "DirectoryAndModel", "directoryOrfile", "directoryOrFile", "directoryOrModel", "directoryandDirectory", "directoryButfile", "DirectoryAndfile", "directoryAndfile", "directoryButDirectory", "directoryandType", "directoryAndModel", "directoryandModel", "directoryButType"], "mFileName": ["mFilePath", "mSourceFileNames", "MFilenameNames", "mSourceFileName", "mFilenamePath", "mFolderName", "mTablePath", "mFolderPath", "mfileSource", "mFileType", "MFilename", "mfileName", "MFileName", "mFilename", "MFilePath", "mFilePart", "mFilenameSize", " mFileFile", " mfileName", "mFoldername", "mfilePath", "mSourceFileFile", "mfileFile", "mFilenameNames", "mFolderPart", "mSourceFilePath", "mFilenameFile", "MFileNames", "MFilePart", " mFileType", "MFileBody", "MFilenameName", "MFilenamePath", " mfileType", "mFilenameSource", "mFilenameType", "mfileSize", "mTablename", "MFileSource", "MFilenameSource", "mFilenamename", "mFileBody", "mFileFile", "mFileNames", "mFilenameName", "mfileType", "MFilenameSize", "mTablePart", "MFilenameBody", " mfileFile", " mfilePath", "MFilenamename", "mFileSize", "MFileSize", "mFileSource", "mSourceFileBody", "mTableName", "mFilenamePart", "mSourceFileSize", "mfileNames", "mfileBody", "mSourceFileSource", "mSourceFileType", " mFilePath", "mFilenameBody", "MFilenamePart"], "code": ["core", "cell", "program", "hello", " coding", "to", "scene", "t", "content", "component", "sequence", "form", "stroke", "coded", "query", "zip", "buffer", "text", "json", "template", "create", " to", "e", "done", "script", "l", "string", "comment", " content", "data", "Code", " data", "output", "expression", "html", "n", "body", "frame", "result", "input", "copy", "action", "func", "message", "reason", "node", "x", "time", "ce", "test", "length", "hex", "module", "cod", "codes", "ode", "coe", "event", "command", "source", "value", " Code", "c", "cache"], "function": ["fn", "expression", "foundation", "Function", "program", "method", "instance", "false", "callback", " func", "user", "normal", "and", "connection", "class", "f", "relation", "from", "feature", "closure", " command", "resource", "production", "foreign", "component", "library", "functional", "module", "process", "fun", "handler", "service", "family", "event", "result", " functions", " program", "form", "command", " functionality", "partial", "object", "action", "python", "file", "value", "job", "func", " computation", "document", "full", " Function", "FUN", "lambda", "role"], "url": ["out", "http", "mail", "location", "sl", "open", "build", "bel", "link", "ur", "b", "Url", "address", "URL", "p", "rel", "io", "re", "ssl", "dl", "nl", "loc", "resource", "el", "browser", "gl", "str", "mount", "ll", "get", "l", "char", "base", "rl", "file", "log", "job", "web", "r", "li", "hl", "il"], "in": ["out", "IN", "din", "gin", "n", "it", "rin", "is", "ic", "sin", "f", "body", "p", "inc", "from", "ind", "ins", "bin", "inner", "null", "reader", "stream", "isin", "l", "In", "input", "source", "file", "i", "info", " din", "inn", "r", "inf", "cin"], "inReader": ["innerReader", "fromRunner", "cinRunner", "cinWriter", "innerRunner", " inLine", "innLine", "innReader", "fromWriter", "inRead", "InReader", " inStream", "fromReader", "fromLoader", "inBuilder", " inLoader", "cinLoader", "inStream", "inRunner", "innerR", " inR", "fromR", "innerBuilder", " inWriter", "inLoader", " inBuilder", " inRead", "inWriter", "innStream", " inRunner", "InStream", "InRead", "innRead", "InLine", "cinReader", "inLine", "inR", "fromBuilder"], "line": ["message", "text", "cell", "lin", "block", "ln", "section", "header", "eline", "change", "link", "zone", "lane", "entity", "row", "sample", "frame", "stay", "element", "liner", "email", "le", "e", "inline", "ine", "key", "error", "rule", "ode", "LINE", "number", "l", "char", "page", "online", "sequence", "record", "entry", "string", "print", "point", "port", "stroke", "file", "comment", "lined", "column", "Line"], "end": ["load", "close", "block", "open", "class", "id", "END", "export", "reset", "ed", "length", "run", "e", "stop", "next", "ended", "End", "log", "info", "data", "start", "begin", "list"]}}
{"id1": "23672408", "id2": "10176678", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"copyIconFiles": ["copyIconDocuments", "copyIconfiles", "copyiconFiles", "copyIndexfiles", " copyiconImages", " copyiconFiles", "copyiconfiles", "copyIndexDocuments", " copyIconImages", " copyIconfiles", "copyIndexImages", " copyiconfiles", " copyIconDocuments", "copyIndexFiles", "copyiconDocuments", "copyiconImages", " copyiconDocuments", "copyIconImages"], "clazz": ["callaz", "chace", "relab", "callazz", "relaz", "Clazz", " closer", "CLoser", "clus", "escotted", "classotted", " cluster", "descazz", "crub", "clbo", "Claz", "callace", "craz", "descab", "plasse", "CLace", " clashed", "sclbean", "sclace", "classe", "close", "scloser", "classazz", " plazz", "clace", "CLbean", "sclazz", "plaz", "cluddy", "Clbo", " clojure", "plazz", " classe", "plashed", "chojure", "escojure", "descaz", "Close", "descose", "Clace", " clbean", " clus", "Clab", "claz", "crus", " plub", "clojure", "clashed", " clotted", " clace", " club", "chotted", "relose", "pkgazz", "colluddy", " plus", "clbean", "cluster", "collotted", "CLazz", "colluster", "pkgashed", "callbo", " cluddy", "classuddy", "escazz", " plaz", "closer", "relazz", "clotted", "clab", "club", "classuster", "crazz", "pkgasse", "pkgaz", "chazz", " claz", " clbo", "collazz", "escace"], "i16": ["ami2016", " i160", "pi150", "ii16", "ji16", "pi16", "li2016", "pi6", "i6", "li16", "ini2016", "iri2016", "ii160", "amiShort", "ami16", "liShort", "ri157", "i24", "i216", "i2016", "i19", "iShort", "ji6", "i157", "ami19", "ri6", "ji63", "ini24", "iri16", " i157", "ini216", "iri6", "pi63", "iri157", "ami63", "ri16", " i6", "ii216", "ji150", "ini16", "ami6", "i160", "i150", "ini19", "iniShort", "ii24", "i63", " i2016", "ini160", "ami150", "ri2016", "li19", " i216", " i24"], "fileType": ["treeTYPE", "ilePattern", "fileFamily", "iletype", " fileTyp", "viewTYPE", "eventType", "Filetype", "resourceTYPE", " fileValue", "relationFamily", "viewType", "webTyp", "treeTime", "fileTime", "issueTyp", "eventList", "FILEName", "issuetype", "coreHandler", " fileUnit", "formattype", "formType", "policyFamily", "eventFormat", "fileFormat", "fileDef", "ileTyp", "coreDef", "fileValue", "eventUnit", "webTYPE", "formtype", "policyHandler", "formatValue", "treetype", "webList", "relationTyp", "policyTyp", "formName", "issuePattern", "ileType", "FileName", " fileFormat", "formatType", "formatTYPE", "policyType", "fileTyp", " fileTime", "relationHandler", "FILEType", " filePattern", "coreTYPE", "fileTYPE", "webType", "fileHandler", "coreFamily", "fieldType", " filetype", "fileUnit", "fieldTyp", "viewtype", "issueType", "resourceFormat", "coreType", "resourceUnit", "formatTime", "coreTyp", "viewValue", "filetype", "fieldDef", "relationType", "FileType", "fileName", "resourceType", "fieldTYPE", " fileList", " fileTYPE", "FILEtype", "fileList", "treeType", "filePattern", "eventTYPE", "webDef"], "desti16": ["desti18", "destgi16", "desti216", "destsi18", "resulti24", "destxi18", "destui160", "destsi160", "desti2016", "destgi24", "destsi32", " destsi18", "destui32", " desti160", "desti160", "resultii216", "destii216", "destii24", " destsi32", "destgi2016", "destui24", "resulti16", "resultii16", "resulti2016", "resulti216", " desti18", " destsi16", "destii16", "destii2016", "destxi16", "destsi16", "destui18", "destui216", " destsi160", "resultii2016", "destui2016", "resultii24", "destui16", "destgi216", "desti24", "destxi160", "destxi32"], "src": ["ser", "proc", "ls", "st", "addr", "sl", "ln", "sync", "img", "pkg", "sys", "isl", "tmp", "sq", "rx", "gs", "via", "sc", "rel", "rc", "scan", "desc", "sel", "sub", "ssl", "ibl", "ins", "nl", "loc", "obs", "std", "rg", "rs", "etc", "bin", "fc", "iv", "syn", "cmp", "comp", "sol", "inner", "bg", "req", "ctr", "cb", "dest", "vr", "ptr", "txt", "sec", "bc", "sit", "cont", "sn", "sr", "source", "input", "ctx", "rob", "rl", "iter", "sb", "sp", "bh", "inst", "urg", "cli", "usr", "hl", "rest", "rb", "cur"], "dst": ["dmn", "tst", " ddest", "dernd", "Dnd", " dot", "dsnet", "rdmt", "rbl", "ddst", "dddest", "fdr", "dLest", "dbl", "dput", "rst", " dnd", "dLnet", "ddmn", " dcut", "Ddr", "fdest", "fnd", "ddest", "fst", "dLst", "derdest", " dmt", "rdst", "dgt", "ndmt", "rdest", " dbl", "dLcut", "tgt", "Ddest", "dsest", "nst", "ddnd", " dsts", "rdsts", " ddr", "nnd", "dsts", "nput", "dsot", "Dst", " dgt", "dot", " dest", "derst", "dLdest", "dest", "dermn", "dLbl", "dcut", "dnd", "ndest", "dmt", "dLot", " dput", " dnet", "ndsts", "tput", "dsst", "tnd", "rcut", "ddr", " dmn", "ndst", "ngt", "dnet"], "i32": ["i31", "i86", "i64", "ii34", "i48", " i64", "xi48", "ii342", "pi34", "xi31", "i34", "ii32", "pi31", "ic64", "ini31", "ini32", " i40", "ini22", "ini48", "isi64", "xi22", " i34", "i40", "ii28", "isi86", "ip32", "ic40", "ic342", "ic28", "ip31", "ic48", "i28", "ic32", "i22", "pi32", " i342", "ic86", " i86", "ic31", "isi40", "ip34", "ic22", " i31", "xi32", "i342", " i28", "pi64", "ic34", "isi32", "ip64"], "desti32": ["destpi32", "targetpi30", "destdi30", "destI32", "desti34", "targeti31", "destic32", "destu256", "targetpi32", "destdi32", "destI256", "Desti32", "DestI90", "Desti256", "destu31", "destpi31", "targeti34", "targetpi31", "destic30", "destpi34", "targeti32", "destI31", "desti30", "desti90", "DestI31", "destic31", "destu32", "destdi31", "desti31", "destu90", "targeti30", "Desti90", "destic34", "targetpi34", "destI90", "destdi34", "DestI32", "destpi30", "desti256", "Desti31", "DestI256"]}}
{"id1": "10176678", "id2": "20939940", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpgZIP", "testLoadHttpgZipped", "testLoadHttpGzipipping", "testLoadHttpgzipping", "testLoadHttpGzipIP", "testLoadHttpgzIP", "testLoadHttpGgzIP", "testLoadHttpGgzipped", "testLoadHttpgzipped", "testLoadHttpGgzips", "testLoadHttpgzips", "testLoadHttpgZips", "testLoadHttpgZipping", "testLoadHttpGzips", "testLoadHttpGgzipping", "testLoadHttpGZIP", "testLoadHttpGzIP", "testLoadHttpGzipips", "testLoadHttpGzipipped", "testLoadHttpGzipping", "testLoadHttpGZips", "testLoadHttpGZipped", "testLoadHttpGZipping"], "url": ["path", "http", "mail", "reason", "ls", "location", "html", "config", "ret", "msg", "type", "build", "link", "ur", "b", "Url", "q", "URL", "id", "state", "sql", "rel", "p", "test", "pl", "ssl", "uri", "dl", "loc", "browser", "ref", "fail", "key", "name", "str", "mount", "ll", "l", "policy", "err", "result", "rect", "base", "string", "lr", "acl", "status", "web", "full", "format", "options", "host", "pattern"], "loadingInfo": ["LoadingInf", "readingInf", "contentData", "contentNow", "loadingStatus", "LoadingStatus", "readingStatus", " loadingData", "readingInfo", " loadingInf", "LoadingNow", "loadingNow", " loadingStatus", "contentInf", "LoadingData", "loadingData", "LoadingInfo", " loadingNow", "contentInfo", "readingNow", "loadingInf"], "contentInputStream": ["fileInputstream", "fileInputThread", "contentIntStream", " contentInputForm", "contentOutputPoint", " contentOutputForm", "contentOutputForm", "contentIntSteam", "contentInputForm", "contentOutputStream", "fileStreamstream", "contentStreamSteam", "fileStreamSteam", "fileInputStream", "contentInfoThread", "contentByteStream", " contentOutputPoint", " contentOutputStream", "contentOutputSteam", "contentInputPoint", "contentByteThread", "contentInputSteam", "contentByteSteam", "contentInfoSteam", "contentInputThread", "contentInputstream", "contentReadForm", " contentOutputSteam", "contentReadStream", "contentIntPoint", "contentInfostream", "contentStreamStream", "fileStreamStream", "contentStreamstream", "contentIntForm", "fileStreamThread", " contentInputPoint", "contentInfoStream", "contentStreamThread", "contentReadPoint", "contentBytestream", " contentInputSteam", "contentReadSteam", "fileInputSteam"], "actual": ["approximately", "fake", "real", "actually", "now", "valid", "false", "present", "old", "latest", "raw", "test", "produced", "true", "older", "rendered", "initial", "current", "total", "Act", "affected", "tested", "all", "original", "required", "view", "currently", "virtual", " Actual", "other", "truth", "result", "partial", "ual", "received", "full", "array", "reported", "act", "verified"], "expected": ["fake", " expect", "or", "pects", "valid", "ired", " expecting", "supported", "example", "want", "old", "anticipated", "checked", "test", "produced", "ed", "ex", "pected", "planned", "current", "erved", "always", "tested", "confirmed", "anted", "umed", "required", "ert", "EXP", "awaited", " unexpected", "announced", "received", "nexpected", "pect", "important", "reported", "allowed"]}}
{"id1": "160739", "id2": "23199071", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "label": 0, "substitutes": {"createOutputStream": [" createFileStream", "createInputstream", " createOutputFile", " createFilestream", " createInputSteam", " createFileSteam", " createOutFile", "createOutputstream", "createInputFile", " createOutStream", "createInputStream", " createOutputSteam", "createOutputSteam", " createFileFile", " createInputStream", " createOutSteam", "createInputSteam", " createInputFile", " createOutstream", " createInputstream", "createOutputFile", " createOutputstream"], "inFile": ["inputPath", "inDir", "dinPort", "ninPath", "dinPath", "dinDir", " infile", "outFilename", " inPort", "infile", "ninFilename", "inputDir", " inPath", "ninFile", "outPath", "inFilename", "inPort", "outfile", "inputFile", "inputPort", "dinFile", " inDir", "inPath", " inFilename", "ninfile"], "outFile": ["Outfile", "exfile", "outPlace", "outPort", "outputFilename", "OutFilename", "outputFile", "outputPlace", "exFile", "newfile", "OutPort", "outputfile", "exPlace", "OutFile", "toPort", "outFilename", "newFilename", "tofile", "infile", "newFile", "toFile", "inFilename", "inPort", "outfile", "toFilename", "exFilename", "newPlace"], "k_blockSize": ["k_BlockTime", "k4BlockName", "k_BlockStyle", "k2byteLength", "k_byteSize", "k2blockLength", "k_blockName", "k4blockSize", "k2byteTime", "k4blockCount", "k2blockTime", "k_blockTime", "k_byteName", "k_batchLength", "k4BlockStyle", "k_BlockLength", "k_BlockSize", "k_BlockCount", "k2blockSize", "k4BlockSize", "k_byteTime", "k_batchTime", "k_blockCount", "k4BlockCount", "k2byteCount", "k_blockLength", "k_byteLength", "k4blockStyle", "k2byteSize", "k_blockStyle", "k_BlockName", "k_batchSize", "k4blockName", "k_byteCount", "k2blockCount", "k_batchCount", "k_byteStyle"], "byteCount": ["byteLength", "wordN", "bitN", "byteSize", "byteCode", "charPtr", "bitSize", "bitCounter", "linePtr", "bytecount", "wordCode", " byteLength", "bitCount", "bytePtr", "charCount", "lineLength", "byteCounter", " bytecount", "bbCode", "wordSize", "bitLength", " bytePtr", "bbN", "blockCounter", "blockLength", "charLength", "bitCode", "byteCheck", "blockCount", "bbSize", " byteCheck", "byteN", "wordCount", "charcount", "bbCount", " byteCounter", "linecount", "lineCount", "bitCheck", "blockCheck"], "buf": ["buffer", "proc", "Buffer", "db", "block", "img", "msg", "pkg", "fg", "b", "bag", "raw", "Buff", "bn", "alph", "cat", "bl", "queue", "cv", "seq", "conv", "arr", "buff", "uf", "bg", "cast", "pb", "ctr", "str", "vec", "cb", "doc", "bytes", "txt", "bc", "batch", "mem", "ctx", "tx", "cap", "exp", "cmd", "rb", "cur"], "ofp": ["owlpa", " ofpa", "ofd", "OFP", "owlp", "ofl", " ofP", "ofP", "owlP", "Ofpa", "Ofl", " ofl", "ofpa", "OFd", "Ofp", "OfP", "Ofd", "OFp", " ofd", "OFl", "owld"], "zos": ["ossus", "cos", "sbm", "esa", "zen", "zi", "es", "rss", "tis", "init", "hz", "amia", "zik", "jas", "ze", "zy", "zu", "psy", "gs", "osi", "zin", "bs", "za", "socket", "ez", "hess", "rez", "ws", "os", "zers", "zon", "css", "zag", "zes", "std", "zzle", "LOS", "ps", "webkit", "js", "enos", "rose", "settings", "zh", "zb", "bes", "eros", "zl", "cz", "south", "zer", "los", "python", "sch", "z", "zo", "oss", "sis", "jp", "zona", "nz", "zip"], "osw": ["iswx", "aosW", "osiw", "cosw", "ospace", "osd", "aosw", "sysw", "sysW", "aosd", "cosew", "oW", "syswd", "isw", "owa", "cosd", "issw", "osew", "ossw", "cosws", "osrw", "sysrw", "aoswd", "osws", " ossw", "osswx", "osiW", "opace", "ow", " oswx", "aoswa", "aospace", "aosrw", "osswd", "osiwa", "osipace", " osew", "ossrw", " osW", "osW", "isW", "aosew", " osd", "ossW", "oswa", "oswx", "osssw", "aosws", "oswd", " osws"], "bw": ["nbwe", "abwe", "besw", "bbx", "pbwb", "sbwb", "bex", "pbz", "sbw", "pbwe", "bwk", " bem", " bx", "bbz", " bwl", "obwb", "bwp", "bsw", "bbend", "nbew", "bwl", "bewk", "bbwp", " bex", "pbwt", "rbw", " bz", "bwb", "abew", "bwy", "nbw", "obwl", "bewl", "pbw", "wbw", "sbz", "pbwy", " bsw", "bew", "bem", "bbws", " bwp", "rbex", "wbz", "wbwp", " bwk", "wbem", " bwt", "bwt", "bwe", "obsw", "abwy", "bbex", "wbwt", "nbwy", " bend", "rbws", "wbend", "pbew", "bbw", "bz", "bws", "bx", "wbx", "abw", "sbwt", "obwt", " bws", "rbz", "obw", "obwk", "bbwt", "obz", "bend", "bbem"], "zot": ["ziot", "zerot", "zeronet", "zeror", "zonet", "zipot", "Zot", " ziat", "zoor", "Zit", " zott", "zott", " zo", "zerote", "zoot", "ziphot", "zoonet", "zoo", "zipiat", "zerit", "zeriat", " ziot", " zor", "zor", "zerhot", "zerott", "zipiot", " zonet", "Zote", "zhot", "zero", "Zott", "zote", "ziat", "zeriot", "zo", " zote", " zhot"], "ifp": [" ifd", " ifr", "iwd", " ifth", "iwp", " ifP", " iftp", "ifP", "isP", "Ifth", " ifjp", "iwr", "ifjp", "isjp", "ihp", "Ifjp", "isp", "ifr", "ihr", "ihtp", "iwtp", "IfP", "ifth", "ihd", "Ifp", "iftp", "ifd", "isth"], "zis": [" ziss", "izis", "zeris", " zi", "ezis", "zi", "izisa", "izi", "zoisa", " zIS", "zipic", "zoinit", "eziss", "zois", "zisa", "zerIS", "zIS", "zipis", " zic", "zisc", "zoiss", "zinit", "izinit", "ziinit", "izisc", "zic", "zeric", "ziisa", "ziis", "zipIS", "iziss", "ziss", "ziiss", " zisc", "ezi", "ezisc"], "isr": ["sisrs", "ispr", "iosstr", "itssr", "iospr", "isalr", "issrc", "iossr", "isscr", "issrs", "iosr", "itsstr", "isstr", "iscr", "issr", "isalpr", " isrs", "sisr", "siscr", "itspr", " isrc", "isalstr", "isrs", "sisrc", "isalsr", " iscr", "itsr", "isrc"], "br": ["wr", "gr", "dr", "shr", "bf", "bd", "b", "bp", "bm", "BR", "rel", "bn", "bl", "hr", "pr", "fr", "bt", "js", "Br", "cr", "bro", "bi", "obl", "str", "ctr", "Fr", "vr", "mr", "tr", "ptr", "bj", "sr", "lr", "ba", "bh", " Br", "kr", "ber", "r", "yr", "rb"], "zit": ["zeop", "zipIT", "iziti", "ziti", "zipit", "izip", "zist", "ozit", "czip", "czit", "ezlit", "zite", "ozunit", "ezIT", "lexIt", "ziit", "lexIT", "czop", "czunit", " zlit", "ziplit", "zIT", "zipist", "ziIt", "zlit", "ezite", " zip", " zIT", "cziti", "lexist", "zipite", "zunit", "lexit", "oziti", "ziIT", "zeit", "zipIt", "ezit", "zeip", "czot", "izit", "ozip", " zite", "zIt", "ziist", "zeot", "zop", " zop", "izunit", "zip"]}}
{"id1": "22235113", "id2": "10212189", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallEml", "unmarshalXml", "unmarshallXsl", "unmarshallYml", "unmarshallEplex", "unmarshallAsml", "unmarshalYml", "unmarshallAsplex", "unmarshallEsl", "unmarshalXplex", "unmarshallAssl", "unmarshallXplex", "unmarshalYplex", "unmarshallYxml", "unmarshallExml", "unmarshallXxml", "unmarshallYsl", "unmarshalXxml", "unmarshalYxml", "unmarshalXsl", "unmarshallAsxml", "unmarshallYplex", "unmarshalYsl"], "unmarshaller": ["unmachailing", "unmachailer", "unmarshillier", "unmarshcalloser", "unmarshailable", "unmarshCalling", "unmachailable", "unmarshcallier", "unmMarshcallers", "unmarshellers", "unmachallable", "unmarshiller", "unmachallers", "unmarshalling", "unmachalling", "unmarshelloser", "unmMarshcallier", "unmarshallable", "unmarshcalling", "unmarshallier", "unmMarshalloser", "unmarshailer", "unmMarshcalloser", "unmarshcallable", "unmMarshallers", "unmachailers", "unmarshilloser", "unmarshalloser", "unmarshailing", "unmMarshaller", "unmarshailers", "unmMarshallier", "unmarshcaller", "unmarshillers", "unmarshellier", "unmarshCallable", "unmarshCallers", "unmachaller", "unmarshcallers", "unmarsheller", "unmarshallers", "unmMarshcaller", "unmarshCaller"], "accessUrl": ["execUrl", "uploadurl", "accessPage", "accessurl", "uploadURL", "accessibleUr", "AccessDb", " accessurl", " accessURL", "accessibleUrl", "AccessPath", "accessURL", "accessUr", "uploadUr", "ccessUrl", "ccessurl", " accessUr", "accessPath", "axURL", "aceUrl", "ccessURL", "execPath", "accessibleURL", "execUr", "accessDb", "ccessPage", "Accessurl", "execURL", "AccessURL", "acePage", "aceurl", "axUrl", "AccessUrl", "axUr", "accessibleDb", "AccessPage", "axDb", "aceURL", "AccessUr", " accessPath", "uploadUrl", "ccessUr"], "nameSpace": ["NameSpace", "whiteSpace", "nameBox", " nameSp", "resourceSpace", "whitespace", "NameType", "linkSpace", " nameBox", "Namespace", "nameSp", "resourceBox", "nameAccount", "wordSpace", "wordBox", "whiteSp", " nameAccount", "linkspace", "resourcespace", " namespace", "wordspace", "nameType", "whiteAccount", "linkSp", " nameType", "namespace", "NameAccount", "linkType", "NameSp"], "replace": ["strip", "place", "each", "update", "add", "prefix", "close", "template", "save", "over", "cover", "force", "apply", "align", "change", "after", "filter", "repeat", "places", "old", "alter", "gre", "re", "register", "use", "sub", "map", "insert", "transform", "wrapper", "pair", "delete", "write", "group", "store", "fix", "share", "tool", "record", "fill", "string", "look", "hash", "same", "match", "escape", "join", "find", "search", "format", "remove", "include", "repl"], "with": ["path", "spr", "self", " without", "add", "using", "now", "x", "by", "then", "apply", " WITH", "without", "after", "repeat", "title", "via", "id", "sql", "default", "spec", "require", "where", "xml", "With", "form", "set", "here", "tx", "cap", "value", "join", "work", "format", "php", "context", "handle", "which", "color", "ith"], "url": ["http", "mail", "ls", "sl", "open", "user", "bel", "link", "ur", "Url", "ul", "address", "URL", "ssl", "uri", "dl", "nl", "channel", "resource", "browser", "ref", "this", "str", "mount", "xml", "impl", "ll", "external", "service", "l", "u", "char", "base", "rl", "sb", "https", "web", "cert", "r"], "inputStream": [" InputSteam", "outputSteam", " inputThread", "inputstream", "imagestream", " Inputstream", " inputSteam", "imageThread", "outputstream", " InputStream", "inputThread", "inputSteam", "inStream", " InputThread", "inSteam", "activestream", "imageSteam", "activeStream", " inputstream", "activeSteam", "outputStream", "imageStream", "instream"], "xmlContent": [" xmlcontent", "xaValue", " xmlAccept", "phpContents", " xmlRaw", "xmlRaw", "xmlAccept", " xmlText", "xaAccept", "phpcontent", "xmlContents", "mlContents", "xmlcontent", " xmlName", "xfName", "textName", "mlcontent", "formContent", "xmlName", "textContent", "xfContents", "mlText", "xfContent", "mlRaw", "jsonContent", "textContents", "jsonText", "formContents", "phpText", "mlContent", "textcontent", " xmlValue", "xaText", "xmlText", "textText", "formText", "jsoncontent", " xmlContents", "jsonContents", "xaContent", "xfcontent", "mlValue", "phpContent", "xmlValue", "formRaw", "mlAccept"], "out": ["output", "cos", "con", "n", "auto", "Out", "ent", "user", "init", "sys", "flush", "o", "aos", "to", "os", "io", "ex", "outs", "conv", "client", "t", "up", "ou", "nt", "at", "write", "inner", "null", "writer", "external", "net", "conn", "OUT", "extra", "check", "conf", "copy", "cn", "file", "log", "comment", "co", "in", "cmd", "outer", "list"], "xmlRequestNumber": ["xmlEventNumber", " xmlResponseNo", "xmlEventNo", "xmlCounterCount", "xmlEventCounter", "xmlRequestNo", " xmlResponseNumber", " xmlResponseCount", "xmlRequestCounter", "xmlResponseNo", "xmlCounterCounter", "xmlResponseCounter", "xmlResponseNumber", "xmlCounterNumber", "xmlResponseCount", "xmlEventCount", " xmlRequestCount", " xmlRequestNo", "xmlCounterNo", " xmlResponseCounter", " xmlRequestCounter", "xmlRequestCount"], "byteArrayInputStream": ["byteArrayOutputStream", "byteOrderInputSteam", "byteArrayHttpForm", "byteArrayHttpStream", "byteArrayOutputSet", "byteArrayOutputSteam", "byteOrderInputSource", "byteStringOutputSocket", "byteArrayReadSource", "byteStringOutputStream", "byteStreamInputStream", "byteArrayInputSocket", "byteStringInputForm", "byteArrayinputStream", "byteArrayReadStream", "byteStringOutputSteam", "byteArrayinputSteam", "byteArrayinputSocket", "byteStreamOutputSet", "byteOrderReadStream", "byteStringInputStream", "byteArrayIntSet", "byteArrayStorageForm", "byteArrayinputForm", "byteArrayStorageSteam", "byteStreamOutputStream", "byteOrderInputForm", "byteArrayStorageSet", "byteArrayReadSteam", "byteArrayOutputForm", "byteArrayReadForm", "byteStringInputSocket", "byteArrayHttpSource", "byteArrayRawSocket", "byteArrayOutputSource", "byteArrayInputForm", "byteArrayRawSteam", "byteStreamOutputSteam", "byteArrayHttpSteam", "byteOrderReadForm", "byteArrayIntSteam", "byteArrayRawForm", "byteStreamOutputForm", "byteArrayOutputSocket", "byteArrayInputSource", "byteStreamInputForm", "byteArrayIntForm", "byteStringInputSteam", "byteOrderInputStream", "byteArrayInputSteam", "byteStreamInputSet", "byteArrayStorageStream", "byteStreamInputSteam", "byteOrderReadSteam", "byteArrayInputSet", "byteOrderReadSource", "byteArrayRawStream", "byteStringOutputForm", "byteArrayIntStream"], "source": ["ser", "expression", "style", "site", "ident", "json", "reason", "template", "config", "se", "SOURCE", "instance", "handle", "proxy", "params", "body", "ource", "state", "console", "relation", "from", "subject", "resource", "scope", "Source", "parent", "content", "component", "where", "src", "inner", "store", "cause", "xml", "unit", "stream", "service", "position", "sequence", "details", "object", "copy", "status", "input", "table", "file", "select", "parse", "comment", "join", "target", "context", "trace", "layout", "in", "report"]}}
{"id1": "21531069", "id2": "18962382", "code1": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"updateuser": ["setaccount", "updateaccount", "setuser", "UPDATEusers", "UPDATEusername", "UPDATEaccount", " updateusername", "setusername", "setusers", " updateusers", "updateusers", "updateusername", "UPDATEuser", " updateaccount"], "u": ["U", "bo", "out", "eu", "cu", "uni", "user", "pu", "ui", "ur", "b", "ul", "tu", "iu", "su", "o", "util", "au", "gu", "bu", "uj", "up", "ou", "uf", "uu", "nu", "du", "hu", "uv", "ju", "uid", "ue", "you", "c", "un", "us", "mu", "fu", "ud", "ux", "ut", "ru", "lu"], "i": [" im", "im", " n", "j", "n", "phi", "x", "it", "ai", "ini", "is", "ri", "ic", "f", "iu", "p", "y", "iri", "fi", "o", "ci", "iat", " I", "mi", "ki", "ii", "t", "qi", " Ai", "v", "gi", "e", " j", "hi", "ti", "bi", "index", "si", "I", "l", "r", "iti", "ei", " iT", "m", "xi", " bi", "di", "pi", "in", "cli", "li", "oi", "c"], "conn": ["bo", "nec", "cell", "ln", "connection", "pg", "wp", "att", " ce", "cp", " con", " cont", "cl", "port", "dial", " cc", "cur", "ch", " c", "nc", "db", "con", "close", "j", " comm", "org", "ont", "tp", "enc", "conv", "win", "cm", "cb", " mc", " net", "obj", "net", "yn", "ann", "po", "co", "sp", " ac", "cmd", "gn", "conf", "Connection", "n", "ct", "dat", "iw", "pool", " ex", "en", "loc", "client", "resp", "nt", " ch", "comm", "ht", "tn", "cert", " core", "Conn", " cx", "connect", "Con", " cs", "addr", "open", "pkg", "gate", "socket", "p", "pas", "pt", " pc", "js", "ns", " cur", "req", " connection", "cont", "ctx", "cn", "cc", "jp", "ca", "c"], "pm": ["vp", "mmm", "ms", "px", "term", "pn", "arm", "vm", "pkg", "rem", "em", "tm", "asm", "bm", "hm", "lp", "p", "nm", "ams", "pool", "wp", "pa", "ym", "mm", "pl", "dem", "rm", "mi", "mx", "mt", "pr", "pt", " mp", "pse", "ps", "cm", "js", "lem", "fm", "rpm", "pb", "cp", "esm", "mr", "mp", "perm", "pc", "md", "mk", "om", "gm", "pd", "PM", "m", "am", "ph", "po", "pi", "py", "jp", "pp", "pol"]}}
{"id1": "21125261", "id2": "8069594", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"test": ["load", "T", "hello", "testing", " evaluate", "example", "read", "sample", "evaluate", "execute", "feature", "t", "tests", "fit", "server", "train", "run", "volt", "debug", "unit", " tests", " testing", "Test", " sample", "show", "launch"], "is": ["mis", "ais", "es", "isc", "tis", "ms", "ls", "iso", "ris", "ai", "ri", "sys", "has", "lis", "bs", "isa", "as", "its", "ws", "os", "does", "xs", "are", "ps", "rs", "serv", "xml", "stream", "Is", "fs", "sit", "input", "us", "i", "ios", "s", "sis", "in", "out", "isi", "IS"], "byteArrayOutputStream": ["byteArrayApplicationForm", "byteArrayInputStyle", "byteArrayOutputView", "byteArrayByteForm", "byteArrayApplicationStream", "byteStringInputView", "byteArrayOutputSteam", "byteStringoutputString", "byteStringoutputSteam", "byteStringOutputStream", "byteStreamInputStream", "byteArrayoutputStream", "byteArrayInputString", "byteStringOutputSteam", "byteArrayApplicationSteam", "byteArrayoutputForm", "byteArray4View", "byteArray4Steam", "byteStringInputStream", "byteStringOutputString", "byteArrayoutputString", "byteArray4Stream", "byteStreamOutputStream", "byteArrayOutputForm", "byteArrayByteView", "byteArrayApplicationStyle", "byteArrayByteSteam", "byteArrayInputView", "byteArrayInputStream", "byteArrayOutputStyle", "byteStreamOutputStyle", "byteArrayInputForm", "byteStreamInputStyle", "byteStreamOutputSteam", "byteArray4String", "byteArrayOutputString", "byteStreamOutputForm", "byteStringoutputStream", "byteStringInputSteam", "byteStreamInputForm", "byteStringOutputView", "byteArrayoutputSteam", "byteArrayInputSteam", "byteArrayByteStyle", "byteStreamInputSteam", "byteStringoutputForm", "byteStringInputString", "byteStringOutputForm", "byteArrayByteStream", "byteArrayByteString"], "def": ["db", "json", "ded", "Def", "dev", "ef", "sd", "des", "del", "definition", "cd", "ds", "sche", "desc", "dem", "default", "crit", "pro", "dl", "det", "Definition", "DEF", "da", "define", "d", "dal", "dec", "DE", "md", "dict", "df", "defined", "decl", "conf", "hd", "de"], "se": ["ve", "ser", "ide", "est", "Se", "es", "ase", "sl", "te", "sd", "ie", "ze", "so", "me", "see", "ene", "she", "su", "ense", "sche", "ses", "sa", "ce", "ke", "sel", "ane", "sem", "pse", "ee", "ade", "le", "e", "be", "ine", "ode", "engine", "he", "ae", "sec", "SE", "pe", "ste", "ne", "set", "ese", "sed", "parse", "sp", "spe", "ge", "we", "sea", "de"], "linkId": ["LinkName", "lineid", "chainId", "linkID", "lineId", " linkName", "LinkID", "lineID", "Linkid", "linkedId", "connectionIdent", " linkID", "linkid", "chainID", "LinkId", "linkedID", "connectionId", "linkedIdent", "chainIdent", " linkid", "connectionID", "lineName", "linkIdent", "linkName"], "segmentId": ["segementName", "begmentId", "segroupName", "sementRef", "segmentID", "segroupById", "semissionName", "sementId", "sementid", "segementID", "semissionId", "begroupId", "segroupId", "idegmentRef", "segementId", "segementRef", "begmentID", "sementID", "idegementName", "semissionid", "segmentName", "idegementid", "begroupById", "segmentById", "segementid", "segmentid", "idegmentName", "idegmentid", "begroupID", "segementById", "sementName", "begmentById", "idegementRef", "segmentRef", "segroupID", "semissionRef", "idegementId", "begmentName", "idegmentId", "sementById", "begroupName"], "linkSegments": ["linkFragments", "linkFraggments", "linkParlements", " linkSegment", "linkConnectets", "linkSeggments", " linkThreadlements", "linkBuildment", " linkBuildments", " linkGments", "linkGment", "linkConnectables", "linkFragment", " linkGment", " linkSeggments", "linkSeglements", "linkBuildets", "linkConnectroups", " linkSeglements", "linkGgments", "linkConnectgments", " linkSegables", " linkThreadroups", "linkSegment", " linkThreadments", " linkGroups", " linkSegroups", "linkSements", "linkConnectlements", "linkThreadgments", "linkSegables", "linkThreadlements", " linkThreadgments", "linkConnectments", " linkBuildgments", "linkGments", " linkBuildets", "linkBuildables", " linkSegets", "linkBuildgments", "linkSeets", "linkSeables", "linkSegets", " linkBuildables", "linkParroups", "linkThreadroups", "linkBuildroups", "linkGroups", "linkFragroups", "linkThreadments", "linkParments", "linkSegroups", " linkGgments", "linkBuildments", "linkPargments"], "segments": [" Seges", "usegins", "vegments", " sements", "sements", "segins", "parsectors", " segins", "megments", "velements", "parsegments", "megins", "bements", " segs", "segs", "bevals", "vectors", " Sements", "sectors", "usements", "selements", "mements", "begments", " Segments", " seges", "seges", " sevals", "vements", " Sevals", "parsements", " sectors", "parselements", " selements", "beges", "megs", "usegs", "sevals", "usegments"], "frameProperties": ["framePropptions", " frameByperties", "framePrps", "frameComptions", "frameByperties", "framePropperties", "frameParptions", " framePrptions", " frameProrics", "framePrperties", " frameProptions", "frameProfps", "frameParps", "frameProfperties", "frameByptions", " frameByptions", " framePrps", "framePropps", "framePrrics", "frameProfilities", "frameParperties", " framePrperties", " frameProps", "frameProilities", " frameByilities", " frameByps", "frameProps", "framePropilities", " frameProilities", "frameByps", "frameProfptions", "frameProptions", "frameProrics", " framePrrics", "frameComrics", "frameByilities", "frameComperties", "frameParrics", "framePrptions", "frameComps"], "time": ["each", "second", "message", "TIME", "task", "depth", "step", "timeout", "window", "x", "think", "now", "counter", "money", "tt", "times", "count", "runtime", "duration", "size", "frequency", "Time", "t", "etime", "total", "timer", "length", "transform", "trust", "clock", "version", "estamp", "ime", "sequence", "event", "delay", "rate", "tim", "before", "check", "set", "speed", "point", "tx", "date", "value", "system", "distance", "slow", "year", "context", "start", "ts", "trace"], "vehicle": ["Vehic", "heroicles", "verticles", "vehendor", "heroocity", "verendor", "heroICLE", "vericle", "verogram", "survogram", "ventic", " vehocity", "survicle", "yardogram", "vertocity", "Vehicles", "yardicle", "Vehicle", "vehICLE", "venticle", "VehICLE", "survendor", "yardocity", "vehocity", "yardendor", "vehogram", "venticles", "vertic", "verocity", "heroicle", "survocity", "vehic", " vehICLE", " vehicles", "ventocity", "verticle", "vehicles", "Vehocity"]}}
{"id1": "15018553", "id2": "7633336", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"encrypt": [" encrypted", "enccrypt", "Encrypted", " encode", "Encode", "encode", "unccrypt", "uncode", "Encrypt", "Enccrypt", "encrypted", "uncrypted", "uncrypt", " enccrypt"], "text": ["path", "output", "buffer", "message", "password", "x", "TEXT", "phrase", "now", "msg", "ext", "title", "ct", "q", "body", "p", "Text", "read", "test", "t", "th", "pt", "v", "nt", "content", "translation", "code", "str", "name", "w", "txt", "cont", "form", "print", "string", "input", "source", "tx", "select", "value", "comment", "document", "data", "url", "act", "ut", "word", "pattern"], "md": [" dd", " cmd", "pm", "ms", "nd", "img", "msg", "pkg", "mc", "bd", "od", "and", "metadata", "ct", "ad", "del", "MD", "sha", "grad", "der", "cd", "mg", "h", "mm", "dm", "mt", "ind", "rm", "t", "mode", "dh", "cmp", "det", "ld", "doc", "mb", "d", "dd", "mac", "mp", "err", "mk", "mond", "mod", "dig", "mem", "pd", "m", "hash", "df", "di", "mo", "mn", "mand", " cd", "cmd", "hd", "c", "de"], "md5hash": ["md512sha", " md3hash", " md2hash", "md5hex", "md2hash", "md5sha", " md2cloth", "md5h", "md2sum", "md2hex", "md2sha", "md3h", "md3sum", "md5sum", "md3hex", "md5cloth", " md5cloth", "md512h", "md512sum", " md3Hash", "md3Hash", " md5hex", "md3hash", "md2cloth", " md5h", " md2sum", "md3sha", " md5Hash", "md5Hash", " md3sha", "md2h", "md512hash", "md3cloth", " md3h", "md512Hash", "md2Hash", " md3sum", " md5sha", " md5sum", " md2hex"]}}
{"id1": "3584508", "id2": "22411381", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"copyResource": [" copiedFile", "copyAddress", " copiedAddress", " copiedResource", " copyUrl", " copiedUrl", " copyFile", "copyUrl", "downloadUrl", "downloadFile", "downloadResource", " copyAddress", "copyFile", "downloadAddress"], "url": ["path", "http", "mail", "html", "ls", "sl", "ret", "link", "ur", "Url", "f", "address", "ml", "ul", "gif", "URL", "rel", "util", "github", "re", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "browser", "gl", "ref", "null", "str", "mount", "mb", "ll", "fl", "service", "l", "char", "base", "string", "source", "cl", "rl", "file", "https", "web", "cert", "r", "host", "hl"], "input": ["http", "eval", "text", "missing", "focus", "add", "access", "unknown", "config", "it", "init", "qa", "open", "user", "ip", "feed", "ain", "raw", "can", "state", "local", "accept", "read", "Input", "ssl", "op", "initial", "up", "request", "null", "inner", "pull", "reader", "index", "stream", "get", "upload", "sum", "form", "cont", "base", "before", "PUT", "source", "acl", "iter", "select", "file", "active", "enter", "parse", "info", "inside", "empty", "start", "context", "in", "act", "image", "exec", "audio"], "output": ["text", "update", "unsigned", "auto", "Output", "four", "response", "put", "connection", "entity", "console", "o", "icon", "ilo", "bool", "beta", "client", "current", "ou", "continue", "component", "exit", "write", "null", "group", "next", "position", "hidden", "online", "other", "net", "you", "print", "remote", "object", "ne", "table", "file", "secure", "secondary", "web", "display", "success", "format", "out", "outer", "image", "network"], "b": ["B", "bf", "db", "binary", "block", "by", "j", "nb", "bp", "f", "body", "ob", "bs", "p", "y", "bb", "t", "bits", "fb", "v", "buff", "ab", "eb", "be", "bi", "bit", "g", "ib", "mb", "d", "cb", "gb", "wb", "l", "char", "k", "obj", "bc", "u", "base", "m", "ba", "z", "i", "br", "ble", "sb", "r", "c", "rb"]}}
{"id1": "9796161", "id2": "416857", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getSHA2", "toSHA4", "toMD7", "getMD4", "getmd2", "getmd4", "getSHA5", "getmd7", "toSHA2", "toMD5", "getSHA7", "toSHA7", "toMD4", "getMD2", "getmd5", "toSHA5", "toMD2", "getMD7", "getSHA4"], "s": ["ies", "text", "strings", "ls", "ms", "es", "abs", "space", "n", "gets", "is", "b", "gs", "f", "bs", "p", "ss", "y", "sql", " gets", "h", "its", "ws", "ses", "os", "aws", "xs", "ins", "t", "ps", "v", "rs", "js", "ns", "g", "src", "str", "ats", "sts", "bytes", "l", "fs", "c", "string", "source", "i", "sb", "ends", "sv", "data", "ts", "S", "sq"], "m": ["pm", "mask", "ms", "vm", "mc", "rem", "me", "manager", "em", "tm", "bm", "hm", "nm", "y", "h", "mm", "dm", "mt", "M", "rm", "mi", "made", "sm", "v", "cm", "fm", "e", "g", "mut", "mac", "mr", "perm", "md", "l", "mk", "om", "managed", "mod", "gm", "am", "mu", "mo", "man"]}}
{"id1": "5744493", "id2": "6457199", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doPageMove", " synchronizedFullDownload", " synchronizedFileMove", " doFileMove", " synchronizedFullMove", " doFullMove", " doPageCopy", " doFullDownload", " doFileDownload", " doFileCopy", " synchronizedFileCopy", " doStreamCopy", " doStreamMove", " synchronizedFullCopy", " doPageDownload", " synchronizedFileDownload", " doFullCopy", " doStreamDownload"], "in": ["IN", "din", "gin", "or", "init", "n", "it", "rin", "ic", "b", "ck", "old", "ain", "as", "o", "en", "inc", "from", "mm", "ind", "ex", "ins", "el", "up", "ac", "isin", "l", "In", "input", "source", "file", "i", "inn", "r", " input", "inf", "cin"], "out": ["output", "ch", "n", "Out", "it", "p", "as", "o", "to", "os", "io", "help", "ex", "outs", "t", "op", "up", "v", "serv", "ou", "nt", "at", "write", "null", "w", "l", "net", "OUT", "check", "gt", "ne", "file", "log", "po", "ot", "s", "res", "c"], "inChannel": ["inCh", " inCommand", "vinConnection", "outCh", " inButton", "dinButton", "inConnection", " inConnection", "dinCommand", "vinChannel", "cinChannel", "INStream", "isinChan", "innCategory", "inchannel", "InChannel", "inCategory", "innCommand", "INChannel", " inchannel", "vinCommand", "inChan", "innerchannel", "innerChan", "Inchannel", "cinCategory", " inChan", "InCh", "outchannel", "dinChan", "innButton", "inStream", "inCommand", "INChan", " inCh", "isinConnection", "dinCase", "innerStream", "cinButton", "isinChannel", "isinButton", "vinCase", "innChannel", "outChan", "inCase", "cinCommand", "dinConnection", "dinChannel", " inCategory", "outStream", "InChan", " inCase", "inButton", "INchannel", "innerChannel"], "outChannel": ["upMachine", "outCh", " outRoom", "OutChan", " outCh", "outMachine", "OutChannel", "newChannel", " outStream", " outchannel", "inChan", "aosSection", "OutCh", "aosDisk", "aosChannel", "OutStream", "newConnection", "outchannel", "upSection", "cosMachine", "outDisk", " outConnection", "outerRoom", "inStream", "upChannel", "upDisk", "newchannel", "cosChannel", "onChannel", "outRoom", "outputChan", "outerChannel", " outChan", "outChan", "onConnection", "cosDisk", "aosMachine", "outputChannel", "onChan", "outConnection", "outerStream", "outSection", "newChan", "outStream", "outputStream", "outputCh", "cosSection", "inRoom", "onchannel", "outerChan"], "maxCount": ["maxFlag", "maxSize", " maxSize", "MAXLength", " maxLength", "maxLength", "minLength", "maxCast", "MaxLength", "MaxCount", "minCount", " maxCast", "minSize", "MaxSize", "minFlag", "MAXCount", "MAXFlag", " maxFlag", "minCast", "MaxCast"], "size": ["equal", "message", "Size", "fee", "shape", "ms", "notice", "close", "space", "resolution", "sd", "gets", "is", "ze", "shift", "small", "count", "send", "body", "export", "duration", "area", "ize", "sample", "read", "sent", "total", "length", "len", "write", "any", "name", "readable", "si", "bytes", "scale", "position", "sum", "keys", "SIZE", "south", "speed", "m", "capacity", "set", "ose", "range", "show", "scroll", "empty", "height", "start", "score", "seek"], "pos": ["cos", "pointer", "part", "offset", "slot", "x", "n", "it", "pg", "p", "no", "Position", "rel", "o", "to", "os", "coord", "row", "pl", "pid", "pr", "pro", "seq", "loc", "pose", "pt", "spec", "ps", "resp", "length", "Pos", "pass", "POS", "doc", "index", "position", "l", "page", "pc", "limit", "point", "def", "port", "zero", "po", "i", "sp", "pi", "off", "exp", "start", "left", "len"]}}
{"id1": "8132219", "id2": "6890417", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", "Copyfile", " copyFiles", "CopyStream", "CopyFiles", " copyStream", "copyStream", " CopyStream", " Copyfile", " CopyFiles", "copyFiles", " CopyFile", " copyfile", "copyfile"], "inFile": ["inName", " inRow", "inputName", "innPath", "dinRow", "innFile", "inTemplate", "ninTemplate", " inEmail", "dinPath", "inputTemplate", "outFilename", "inputFilename", "inRow", "ninFilename", "ninName", " inPath", "ninFile", "inFilename", "innRow", "inputFile", "dinEmail", "dinFile", "outTemplate", "innEmail", "outName", "inPath", "inEmail"], "outFile": ["ouFILE", "ouFile", "outputFilename", "outputFILE", "outputFile", "outputFormat", "outputfile", "outputTable", "outTable", " outfile", "outFilename", "destfile", "inFilename", "destFormat", "outfile", "outFormat", " outFormat", "ouFilename", "inTable", "inFILE", "destFILE", "outFILE", "destFile", "ouTable", " outFILE"], "in": ["IN", "on", "din", "gin", "init", "it", "ini", "rin", "ai", "ic", "is", "ze", "sin", "old", "ain", "id", "o", "en", "inc", "from", "irm", "ind", "ins", "el", "up", "bin", "inner", "isin", "ir", "In", "input", "source", "i", "info", " din", "s", "inn", " input", "inf", "cin"], "out": ["output", "by", "n", "Out", "it", "b", "p", "can", "o", "aos", "to", "os", "en", "io", "ex", "outs", "t", "client", "v", "ou", "e", "all", "at", "g", "name", "w", "one", "net", "OUT", "gt", "ne", "file", "ot", "co", "res", "c"], "inChannel": ["vinCategory", " inButton", "sinCategory", "cinHandler", "inConnection", " inConnection", "vinChannel", "inColumn", "cinChannel", "newChannel", "insideChannel", "innCategory", "sinChannel", "cinStream", "inchannel", "inHandler", "insideHandler", "sinBlock", "inCategory", "innerConnection", "newCase", "ginPanel", "isinCase", " inchannel", "ginChannel", "inChan", "innerchannel", "ginCategory", "innerChan", "cinComponent", " inComponent", "outBlock", "sinColumn", "sinStream", "cinColumn", "outchannel", "newPanel", " inChan", "inBlock", "sinSlot", "inStream", "vinPanel", "cinButton", "outColumn", "isinChannel", "innCase", "inPanel", "inSlot", "isinSlot", "vinCase", "innChannel", "inComponent", "insideComponent", "innSlot", "outChan", "inCase", "outConnection", "insideButton", "outStream", " inHandler", "newCategory", "sinCase", "inButton", "isinCategory", "ginCase", "cinBlock", "innerChannel"], "outChannel": ["nChan", "exBlock", "outCh", " outBlock", "exChan", "OutChan", " outCh", "nchannel", "oPassword", "exChain", "OutChannel", "outputConnection", "OutConnection", " outStream", "inchannel", " outchannel", "oChan", "inChan", "OutCh", "outPassword", "outClient", "outBlock", "outchannel", " outConnection", "inStream", "exChannel", "nChannel", "nStream", "outputChan", " outPassword", " outChain", "outChain", " outChan", "outChan", "oClient", "oChannel", "outputChannel", "inPassword", "outConnection", " outClient", "outStream", "outputCh", "inClient"]}}
{"id1": "6470716", "id2": "539195", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"st": ["ist", "ust", "step", "est", "nd", "se", "stri", "tt", "ST", "stra", "St", "sw", "ost", "std", "ft", "t", "th", "sm", "ast", "stable", "rt", "store", "ld", "sts", "str", "sh", "d", "stream", "service", "sth", "www", "sta", "sn", "ste", "sty", "set", "sp", "inst", "start", "rest"], "url": ["ch", "http", "mail", "html", "ls", "addr", "host", "location", "sl", "abs", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "address", "shell", "URL", "rel", "github", "pl", "ssl", "dl", "uri", "loc", "nl", "client", "el", "browser", "gl", "ref", "null", "impl", "mount", "str", "ll", "fl", "l", "char", "www", "rect", "base", "string", "cl", "file", "domain", "web", "cert", "r", "li", "hl", "rest", "il"], "fis": [" fi", " fiss", "tiss", "tis", "efi", "xfier", "Fais", "fiss", "xfis", "fi", "f\u00eds", "Fis", "flisl", "fier", " fais", "Fiss", "fei", "efis", "fli", "xfi", "flis", "fisl", "feois", "feis", "fais", "Fos", "feier", "fliss", "uf\u00eds", "Fier", "Fi", "fois", "ufisl", "ufi", "ufiss", "tos", " fisl", "ufis", "Fois", " f\u00eds", "tais", "efiss", "ef\u00eds", "xfois"], "zis": [" ziss", " zris", "zhisin", "ozisin", "fisi", "zhis", "zris", "czits", "czis", "zIs", "ozes", "zits", "zipIs", "zipisin", "fiss", " zits", "zisa", " zisi", "zisin", "zipis", "ozisa", "zes", "zenisi", "ozis", "zos", "zipos", "zhes", "ozIs", "czisa", "zeniss", " zos", "fits", "zhIs", "zisi", " zIs", "zenris", "zenis", " zisa", "zipes", "ziss", "zipits", "ozits", "czIs", "fris"], "entry": ["field", "de", "cell", "or", "existent", "member", "se", "ent", "valid", "ie", "link", "tmp", "item", "attribute", "way", "ry", "entity", "row", "ce", "jar", "card", "element", "fr", "nt", "e", "key", "null", "be", "office", "name", "index", "inter", "char", "obj", "event", "result", "record", "form", "line", "source", "def", "log", "match", "zo", "comment", "chain", "info", "system", "sp", "Entry", "out", "enter", "word", "jo", "list", "pattern", "zip"], "count": ["ch", "buffer", "depth", "counter", "add", "cell", "core", "n", "nb", "force", "last", "ct", "read", "size", "end", "num", "ind", "t", "current", "total", "length", "nt", "acc", "call", "Count", "code", "name", "ctr", "index", "number", "char", "ount", "page", "sum", "err", "cont", "base", "batch", "check", "amount", "child", "iter", "cc", "match", "max", "comment", "found", "start", "c", "len"], "data": ["output", "buffer", "message", "text", "json", "reason", "part", "step", "block", "n", "buf", " DATA", "ata", "raw", "dat", "sample", "size", "area", "DATA", "bin", "length", "all", "done", "name", "next", "d", "number", "bytes", "good", "result", "string", "batch", "def", "mem", "source", "table", "value", "mu", "zero", "chain", "format", "out", "image", "cache"], "fos": [" fOS", "fool", "hos", "fol", "Foss", "fooss", "fOS", "fiops", "fops", "foops", "Fos", "wis", "hoss", "Fops", " foss", "hOS", "fios", "his", "foos", "foss", "Fol", "fiol", "woss", "wOS", "wos", "fioss"], "dest": ["output", "est", "nd", "member", "des", "gate", "send", "master", "dat", "transfer", "gest", "cat", "coord", "test", "desc", "pas", "std", "loc", "crit", "pipe", "bin", "foreign", "parent", "nt", "det", "comp", "done", "src", "dist", "writer", "dc", "ptr", "sum", "result", "cont", "Dest", "them", "mem", "source", "trans", "nom", "decl", "exp", "target", "comb", "origin", "out", "usr", "temp", "rest", "way"]}}
{"id1": "1141361", "id2": "11952735", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"makeRead": ["doRead", "doPost", " doPost", " doRead", " processCreate", " initialRead", " initialFind", " doCreate", "doFind", " initialCreate", " initialPost", " doFind", " processFind", " processRead", "doCreate", " processPost"], "user": ["field", "message", "owner", "password", "by", "author", "users", "human", "database", "plugin", "account", "connection", "person", "usage", "nick", "creator", "User", "use", "auth", "client", "server", "rule", "name", "post", "USER", "uid", "username", "project", "string", "date", "table", "file", "student", "url", "host", "word"], "databaseID": ["databaseTime", "directoryid", "databaseIDs", "connectionTime", "directoryId", "directoryID", " databaseTime", " databaseAND", " databaseIDs", "directoryTime", "directoryAND", "databaseId", "connectionIDs", " databaseId", "databaseid", "connectionId", "directoryIDs", " databaseid", "connectionID", "connectionid", "connectionAND", "databaseAND"], "time": ["second", "message", "TIME", "timeout", "now", "money", "type", "tt", "hour", "times", "zone", "tm", "id", "runtime", "duration", "end", "frequency", "Time", "t", "created", "etime", "mode", "timer", "length", "clock", "version", "tc", "ime", "sequence", "delay", "rate", "tim", "date", "port", "value", "info", "year", "age", "start"], "query": ["message", "task", "description", "term", "menu", "then", "qa", "gate", "condition", "title", "q", "ql", "body", "sql", "execute", "note", "eries", "transform", "qu", "content", "run", "call", "request", "code", "script", "view", "quest", "quote", "command", "entry", "string", "clean", "select", "Query", "comment", "find", "work", "search", "cmd", "sq", "question"], "statement": ["buffer", "message", "expression", "session", "binary", "function", "word", "description", "phrase", "template", "se", "volume", "bind", "database", "connection", "condition", "ct", "shell", "definition", "sql", "usage", "console", "state", "Statement", "execute", "mt", "slot", "frequency", "subject", "fr", "yahoo", "confirmed", "call", "library", "journal", "le", "rule", "communication", "number", "position", "quote", "page", "sequence", "result", "print", "command", "batch", "entry", "that", "ements", "stat", "status", "table", "language", "comment", "sp", "document", "media", "finder", "memory", "cmd", "ts", "commit", "storage", "report", "list", "article"], "count": ["message", "counter", "now", "nb", "state", "complete", "size", "num", "ind", "loc", "current", "total", "length", "nt", "call", "flag", "Count", "code", "OUNT", "all", "any", "index", "number", "contact", "sum", "ount", "c", "batch", "check", "amount", "set", "status", "table", "find", "found", "handle", "coll", "report", "list"]}}
{"id1": "14047629", "id2": "20939940", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"source": ["output", "buffer", "proc", "message", "expression", "se", "SOURCE", "seed", "shell", "address", "q", "ource", "sql", "console", "sample", "iterator", "from", "channel", "resource", "Source", "content", "request", "src", "reader", "stream", "service", "position", "sequence", "event", "result", "input", "copy", "file", "system", "query", "data", "format", "in", "image"], "process": ["place", "proc", "session", "connect", "function", "task", "node", "pm", "term", "program", "method", "se", "init", "build", "link", "sys", "and", "class", "condition", "processor", "p", "state", "console", "make", "flow", "create", "execute", "frame", "pid", "use", "pp", "pipe", "component", "run", "Process", "code", "processing", "call", "script", "store", "post", "cp", "service", "thread", "complex", "command", "project", "check", "mem", "object", "status", "file", "job", "parse", "chain", "work", "memory", "context", "cmd", "handle", "exec", "network"], "processStdOut": ["processStrdIn", "processStrrEr", "processStstdOut", "processStstEx", "processStrdEx", "processStrIn", "processStrOut", "processStstdIn", "processStstdEx", "processStrrOut", "processStdEr", "processStstIn", "processStrdEr", "processStrrIn", "processStstOut", "processStdEx", "processStstEr", "processStrdOut", "processStstdEr", "processStrEr", "processStrrEx", "processStrEx"], "processStdIn": ["processStackdin", "processStackdIN", "processSttIns", "processStackdsIn", "processStsin", "processStsOut", "processStdsIn", "processStrIn", "processStsIn", "processStrIN", "processStrOut", "processStdIN", "processStackdsIN", "processStackdsOut", "processStrin", "processSTtIn", "processSTtOut", "processStackdOut", "processSTdIns", "processStdin", "processStsIN", "processStdIns", "processSTdIn", "processSttIn", "processSttIN", "processStrIns", "processStackdsin", "processSTdIN", "processSTdOut", "processStdsIN", "processStdsIns", "processStackdIn", "processSTtIns", "processStdsOut", "processStdsin", "processSTtIN", "processSttOut"]}}
{"id1": "9996334", "id2": "6756635", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"generateToken": ["generatesKey", "generatesString", " GeneratesKey", "generateCode", "generatorCode", " GenerateCode", "generatorKey", " GeneratesToken", "generatorToken", "generatesToken", "generateString", "generateKey", " GeneratesString", "generatorString", " GenerateKey", " GenerateToken", " GenerateString", " GeneratesCode", "generatesCode"], "code": ["buffer", "message", "text", "function", "html", "reason", "password", "close", "x", "template", "hello", "response", "address", "state", "token", "ce", "test", "rice", "content", "component", "e", "codes", "name", "error", "ode", "str", "char", "sequence", "command", "string", "source", "hash", "value", "data", "Code", "c"], "md": ["dr", "pm", "ms", "add", "nd", "pdf", "sd", "msg", "mc", "bd", "od", "MD", "der", "cd", "ds", "mg", "desc", "mm", "dm", "mt", "ind", "mat", "red", "rm", "sm", "dh", "det", "ld", "mb", "d", "dd", "mp", "mk", "amd", "mod", "pd", "m", "df", "di", "mo", "mn", "mand", "cmd", "med", "hd", "de"], "bytes": ["binary", "strings", "ms", "es", "words", "pdf", "gets", "users", "b", "versions", "gs", "bps", "bs", "raw", "latest", "ds", "its", "pages", "outs", "lines", "bits", "files", "unks", "classes", "steps", "hex", "terms", "gb", "keys", "values", "parts", "vals", "tes", "Bytes", "results", "pieces", "s", "blocks", "groups", "ents", "seconds", "objects"]}}
{"id1": "19113613", "id2": "88047", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": ["cos", "core", "save", "init", "split", "sync", "replace", "cross", "link", "move", "ip", "proxy", "crop", "transfer", "clip", "to", "download", "create", "cat", "slice", "map", "Cop", "delete", "write", "cop", "cp", "share", "gc", "Copy", "same", "co", "clone", "py", "paste", "php", "pixel", "opy", "zip"], "in": ["IN", "on", "din", "con", "gin", "by", "init", "it", "rin", "ai", "is", "ic", "ie", "ini", "sin", "old", "id", "y", "o", "inv", "local", "en", "inc", "from", "re", "mi", "ind", "ins", "ar", "el", "up", "bin", "all", "inner", "isin", "l", "ir", "In", "net", "check", "input", "iter", "i", "info", "inn", "act", "inside", "inf", "cin"], "out": ["output", "ch", "on", "ion", "con", "n", "over", "Out", "it", "not", "ent", "sys", "tmp", "b", "ver", "p", "y", "o", "aos", "to", "end", "local", "os", "io", "can", "OU", "en", "ex", "outs", "t", "op", "client", "v", "ou", "nt", "at", "all", "write", "null", "store", "inner", "this", "w", "one", "l", "obj", "err", "net", "result", "conn", "OUT", "base", "gt", "set", "port", "log", "oss", "ot", "co", "res", "outer", "cache"], "source": ["style", "site", "prefix", "space", "template", "se", "SOURCE", "ie", "attribute", "title", "sin", "shell", "ource", "sql", "local", "scan", "ce", "relation", "from", "subject", "use", "lower", "resource", "Source", "scope", "parent", "this", "key", "src", "inner", "store", "cause", "index", "unit", "si", "service", "position", "sequence", "base", "string", "input", "status", "language", "select", "range", "system", "sp", "query", "search", "s", "format", "origin", "start", "finder"], "target": ["output", "style", "arg", "top", "step", "bolt", "term", "location", "template", "link", "arget", "Target", "root", "rel", "token", "to", "local", "test", "t", "resource", "scope", "parent", "translation", "tree", "key", "null", "module", "goal", "dest", "other", "tif", "print", "base", "gt", "point", "that", "table", "match", "join", "query", "url", "origin", "alias", "ARGET", "pattern"], "files": ["uploads", "states", "faces", "assets", "ls", "balls", "plates", "banks", "headers", "workers", "users", "ports", "facts", "iles", "lets", "images", "pages", "jobs", "les", "lines", "packages", "styles", "books", "actions", "features", "members", "values", "fs", "parts", "models", "details", "reports", "tools", "resources", "modules", "pieces", "issues", "events", "thumbnails", "items", "objects", "services"], "file": ["path", "field", "ve", "word", "node", "model", "block", "tile", "user", "fe", "item", "f", "folder", "local", "row", "fp", "dir", "relation", "File", "feature", "resource", "el", "filename", "current", "parent", "le", "library", "e", "tree", "key", "be", "rule", "name", "label", "play", "page", "ile", "event", "pe", "line", "FILE", "entry", "print", "child", "base", "port", "table", "job", "document", "work", "data", "full", "foo", "image"], "inCh": [" inCod", "inCod", "rinChan", "cinCod", "cinCor", "outCod", "cinCr", "rinCod", "incCor", "cinSam", " inCl", " inch", "incCr", "inch", "cinCh", "cinch", "inChan", "cinChan", " inChan", "InCh", "rinCl", "incSam", "rinCh", "dinSam", "InCod", "incCh", "inCl", "outChan", "dinCh", "inCor", "InCl", "outch", "InChan", "dinCr", "inCr", "inSam", "dinCor"], "outCh": ["outCol", "inCol", "outputCod", "outCod", " outCod", " outCol", "inch", "inChan", "newCol", "newCod", " outch", "outputChan", " outGr", "outGr", " outChan", "outChan", "outputGr", "newCh", "outch", "newChan", "outputCh", "newch", "newGr"]}}
{"id1": "21326424", "id2": "2807585", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"delete": ["update", "close", "save", "put", "del", "send", "download", "create", "execute", "Delete", " purge", "clear", "request", "write", "release", "null", "post", "dump", "get", "service", "destroy", "check", "query", "data", "remove", "insert", "commit", "de"], "id": ["path", "ment", "message", "ident", "db", "part", "description", "template", "n", "Id", "type", "item", "and", "rid", "token", "variable", "pid", "kid", "iden", "ref", "ids", "code", "key", "name", "aid", "uid", "k", "md", "event", "string", "hash", "value", "vid", "show", "data", "oid", "url", "ID"], "response": ["output", "collection", "message", "application", "self", "site", "json", "function", "description", "model", "detail", "onse", "me", "attribute", "see", "controller", "example", "api", "reset", "relation", "frame", "respond", "answer", "default", "resp", "server", "content", "summary", "exit", "request", "tree", "error", "version", "next", "view", "service", "position", "respons", "page", "Response", "result", "sequence", "command", "entry", "object", "hash", "action", "information", "value", "reply", "render", "document", "data", "format", "display", "res", "image", "report", "network"], "connection": ["bo", "application", "connect", "ion", "session", "Connection", "con", "cone", "pointer", "function", "close", "location", "description", "open", "link", "generation", "statement", "condition", "database", "controller", "reference", "console", "character", "to", "reset", "relation", "subject", "client", "channel", "wrapper", "library", "request", "office", "creation", "government", "communication", "writer", "operation", "engine", "number", "position", "established", "builder", "connected", "license", "directory", "conn", "remote", "command", "entry", "set", "language", "information", "document", "city", "c", "network"]}}
{"id1": "22552318", "id2": "17792212", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadCDDL", "loadCDML", "loadPDl", "LoadCDML", "loadDSL", "LoadDDL", "loadDSML", "loadPDML", "loadDDDL", "loadCDl", "LoadCDL", "loadDDML", "loadPDL", "loadDDl", "LoadDDML", "loadCDDL", "loadCDL", "loadDSl", "LoadDDl", "loadDSDL", "loadPDDL", "LoadDDDL", "LoadCDl"], "stmt": ["frpt", "STm", "Stmm", "stpt", "stMT", "strmt", "utm", "utMT", "astMT", "strmp", "Stm", " superstmt", "stm", " stct", "asttm", "utmt", "StMT", "stmm", " superstpt", "Stst", "STmm", "strmm", " superstm", "Sttm", "astmt", "sttm", "Stmt", " stmp", " stst", "STmp", "stct", "frct", "stmp", "frm", "utst", "STMT", " stm", " superstct", " stMT", " stpt", "stst", " stmm", "strm", " sttm", "astm", "frmt", "STmt"], "qry": ["qurys", " qri", "quri", "sqri", "Qrys", "sqRY", "Qri", "QRY", " qary", " qRY", "qury", "qri", "Qry", "sqary", " qrys", "sqry", "qrys", "qRY", "sqrys", "quary", "qary"], "q": ["qt", "j", "n", "qq", "qa", "pkg", "sq", "f", "ql", "p", "ry", "o", "h", "qs", "t", "qi", "v", "qu", "e", "g", "qv", "d", "w", "u", "k", "m", "iq", "z", "i", "comment", "query", "s", "r", "c", "Q", "dq"]}}
{"id1": "11475527", "id2": "17286898", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDatafromUrl", "addTextFromURL", "addDataFormLocation", "addDataToURL", "addDataFormUrl", "addDatafromURL", "addTextFromurl", "addDatafromLocation", "addDataFromLocation", "addTextFormLocation", "addTextFromLocation", "addTextFormUrl", "addTextFormurl", "addDatafromurl", "addTextFormURL", "addDataFromurl", "addDataFormURL", "addDataToLocation", "addDataToUrl", "addTextFromUrl", "addDataTourl", "addDataFormurl", "addDataFromUrl"], "theurl": ["teuri", "thUrl", " thefile", "teurl", " theURL", " theloader", "heUrl", "thloader", "heloader", "theloader", "heuri", "thfile", "heURL", "teUrl", "TheUrl", " theuri", "theuri", "TheURL", "heurl", "hefile", "Theurl", "Theuri", " theUrl", "teURL", "thefile", "thurl", "theUrl", "theURL"], "line": ["message", "text", "node", "cell", "lin", "block", "ln", "valid", "header", "eline", "link", "zone", "lane", "sample", "row", "frame", " inline", "liner", "email", "le", "code", "inline", "ine", "rule", "name", "LINE", "ice", "day", "l", "char", "page", "online", "sequence", "record", "entry", "string", "source", "point", "print", "status", "ner", "stroke", "comment", "chain", "lined", "Line"], "in": ["proc", "IN", "din", "gin", "con", "st", "or", "init", "n", "it", "open", "rin", "ai", "is", "mc", "lo", "oin", "ic", "f", "old", "ain", "id", "pin", "o", "read", "en", "inc", "from", "mi", "al", "ins", "t", "win", "ma", "ac", "bin", "serv", "inner", "reader", "isin", "l", "r", "In", "conn", "include", "input", "source", "again", "i", "inn", "phys", "out", "inf", "cin"], "data": ["buffer", "text", "window", "user", "a", "ata", "ad", "feed", "body", "raw", "dat", "read", "size", "iterator", "io", "DATA", "client", "pipe", "content", "this", "writer", "da", "reader", "bus", "d", "next", "stream", "dec", "result", "input", "def", "file", "join", "info", "query", "out", "cache"], "e": ["ve", "eu", "es", "or", "x", "se", "n", "a", "te", "ie", "ze", "me", "b", "f", "p", "y", "o", "eeee", "h", "ele", "ce", "re", "ed", "er", "element", "t", "ex", "ee", "v", "E", "le", "oe", "g", "ine", "be", "error", "ec", "d", "ue", "ae", "event", "err", "pe", "entry", "m", "ne", "i", "ge", "r", "c", "de"]}}
{"id1": "23161545", "id2": "12242903", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomGuid", "getRandomGID", "getRandGid", "getRandomCid", "getRandUid", "getRandomGid", "getRandomUid", "getRandomUID", "getRandUuid", "getRandomSUID", "getRandomCUID", "getRandGUID", "getRandomUuid", "getRandUUID", "getRandomUUID", "getRandomCID", "getRandomSID", "getRandUID", "getRandomSuid", "getRandomCuid", "getRandGID", "getRandGuid", "getRandomSid"], "secure": [" Secure", "http", "prime", "sync", "force", "strong", "ie", "sys", "nice", "secret", "weak", "pretty", "ssl", "encrypted", "security", "client", "Secure", "server", "quiet", "confirmed", "stable", "clear", "trust", "google", "protect", "service", "sec", "sr", "dirty", "status", "active", " securely", "https", "safe", "sensitive", " insecure"], "md5": [" md6", "sha512", "mdle", "MD3", " md2", "metadata45", "MD512", " md45", "sha3", "md45", "MDle", "dig4", " md512", "dig3", "md512", "metadata2", "sha2", "sha5", "MD2", "MD4", "md4", "md6", " md3", "digle", "MD6", "sha6", "md2", "MD45", "metadata3", "MD5", "dig5", "metadata5", " md4", " mdle", "md3"], "sbValueBeforeMD5": ["sbValueBeforeIM2", "sbValueAfterMD1", "sbValueBeforeSM5", "sbValueBeforeMS5", "sbValueBeforeMT4", "sbValueBeforeND4", "sbValueAfterND2", "sbValueBeforeMP1", "sbValueBeforemdFound", "sbValueBeforeMD512", "sbValueBeforeDDFive", "sbValueBeforemdson", "sbValueBeforeSM4", "sbValueWithoutMD512", "sbValueBeforeND2", "sbValueBeforeMD65", "sbValueBeforeMDLeft", "sbValueBeforeDS512", "sbValueBeforeOLD512", "sbValueBeforeMDFound", "sbValueAfterMD65", "sbValueWithoutDD5", "sbValueBeforeMS2", "sbValueBeforeAMDFound", "sbValueBeforeIMLeft", "sbValueBeforeIM5", "sbValueBeforeMS3", "sbValueBeforeIM1", "sbValueBeforeOLD5", "sbValueBeforeMPLeft", "sbValueBeforemd2", "sbValueBeforeMOD5", "sbValueBeforeMT5", "sbValueBeforeSMson", "sbValueBeforeMD2", "sbValueBeforeMOD3", "sbValueBeforeSM2", "sbValueWithoutMD5", "sbValueWithoutMD2", "sbValueBeforeMD1", "sbValueAfterMDLeft", "sbValueBeforeAMD5", "sbValueAfterMDFive", "sbValueBeforeLM512", "sbValueBeforeMD4", "sbValueBeforeLM2", "sbValueAfterMD4", "sbValueBeforeMP2", "sbValueBeforeDD5", "sbValueAfterMD2", "sbValueAfterND4", "sbValueBeforeDS5", "sbValueBeforeDD512", "sbValueBeforeAMD2", "sbValueBeforeMOD2", "sbValueBeforeMT2", "sbValueBeforeMDFive", "sbValueBeforeMP5", "sbValueAfterNDson", "sbValueWithoutDD2", "sbValueBeforemd5", "sbValueBeforeMDson", "sbValueBeforeMOD1", "sbValueAfterMD5", "sbValueAfterMDFound", "sbValueAfterND5", "sbValueBeforeDS2", "sbValueBeforeDD65", "sbValueBeforeAMDson", "sbValueBeforeNDson", "sbValueBeforeOLD2", "sbValueBeforeMACFive", "sbValueBeforeMAC65", "sbValueBeforeMD3", "sbValueBeforeDD2", "sbValueBeforeND5", "sbValueAfterMD3", "sbValueBeforeMS1", "sbValueBeforeMAC5", "sbValueBeforeMAC2", "sbValueAfterMDson", "sbValueWithoutDD512", "sbValueBeforeMTson", "sbValueBeforeLM5"], "time": ["history", "TIME", "top", "est", "timeout", "counter", "now", "user", "hour", "times", "id", "runtime", "duration", "size", "frame", "Time", "t", "client", "etime", "current", "total", "timer", "length", "clock", "name", "estamp", "today", "ime", "rate", "tim", "set", "date", "value", "race", "system", "work", "year", "age", "start", "ts", "ty", "when"], "rand": ["dr", "rh", "reg", "nd", "rss", "init", "and", "rid", "seed", "roll", "rev", "id", "grad", "pick", "rc", "inv", "rad", "sample", "pid", "rd", "red", "mid", "std", "rank", "nt", "frac", "cr", "rt", "gz", "dist", "serial", "rot", "uid", "round", "rate", "sid", "quant", "hash", "gt", "did", "z", "sam", "range", "random", "res", "r", "ng", "gen", "Rand"], "valueBeforeMD5": ["valueBeforeND3", "valueAfterND5", "valueBeforeMT5", "valueAfterMD3", "valueBeforeMOD2", "valueAfterMD7", "valueBeforeMD3", "valueBeforeMOD5", "valueBeforeMC25", "valueAfterMD2", "valueBeforeMD2", "valueBeforeMC7", "valueBeforeND7", "valueBeforeMC2", "valueBeforeND2", "valueBeforeMD7", "valueBeforeND5", "valueAfterND3", "valueBeforeMT2", "valueBeforeMD25", "valueAfterND2", "valueBeforeMC5", "valueBeforeMT3", "valueBeforeMOD3", "valueBeforeMC3", "valueAfterND7", "valueBeforeMOD7", "valueBeforeMT25"], "array": ["collection", "buffer", "rays", "our", "expression", "binary", "instance", "a", "var", "response", "attribute", "address", "ary", "arrow", "raw", "av", "row", "sample", "area", "feature", "map", "arr", "length", "RAY", "pair", " Array", "atomic", "angle", "ray", "sh", "share", "external", "number", "vector", "record", "Array", "batch", "angular", "object", "hash", "archive", "range", "app", "data", "random", "audio", "storage", "image", "list", "ash"], "sb": ["ub", "bf", "db", "nb", "SB", "lb", "bp", "bis", "bps", "bs", "lp", "kb", "ob", "bsp", "sw", "hs", "bb", "sa", "erb", "ssl", "obs", "bt", "eb", "bg", "xb", "pb", "ib", "zb", "cb", "sh", "gb", "wb", "si", "sth", "sg", "gc", "sr", "rob", "abb", "ctrl", "bh", "sv", "soc", "sf", "sq", "rb"], "j": ["bot", "json", "jl", "it", "msg", "jack", "aj", "ct", "jj", "q", "je", "kj", "att", "jit", "ind", "ja", "dj", "uj", "t", "v", "js", "g", "ji", "key", "str", "jc", "ju", "index", "_", "yy", "jump", "obj", "k", "bj", "m", "J", "__", "us", "job", "z", "i", "br", "ij", "off", "jp", "oj", "jo", "ix"], "b": ["B", "bf", "db", "nb", "a", "bd", "bar", "bp", "bis", "bs", "y", "bound", "bb", "beta", "bu", "fb", "bt", "v", "ab", "eb", "bg", "be", "bi", "xb", "ib", "mb", "cb", "d", "gb", "u", "k", "bc", "ba", "br", "rb"], "valueAfterMD5": ["valueAfterID5", "valueAfterMD3", "valueAfterMD7", "valueBeforeMD3", "valueAfterMD2", "valueAftermd7", "valueAftermd5", "valueBeforeMD2", "valueBeforeMD7", "valueAfterID3", "valueAfterID7", "valueAfterID2", "valueAftermd2", "valueAftermd3"]}}
{"id1": "2199604", "id2": "23335922", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"unzipEntry": ["unlinkFile", "unwrapEnt", "UnzipEnt", "unzipInternal", "UnpackInternal", "unlinkInternal", "unpackInternal", "UnpackFile", "unpackFile", "UnpackEnt", "UnzipFile", "unpackEnt", "UnzipEntry", "unlinkEnt", "UnzipInternal", "unwrapEntry", "unlinkEntry", "unwrapFile", "unwrapInternal", "unzipFile", "UnpackEntry", "unpackEntry", "unzipEnt"], "zipfile": ["Zipimage", "zonetree", " zipFile", "archivetree", "ziptree", "ztree", "zip2", "zipFile", " zip2", "zipimage", "zonefile", "zFile", "zoneimage", "archivefile", "zone2", "Zip2", "ZipFile", " zipimage", "zfile", "zoneFile", "Zipfile", "archiveFile"], "entry": ["ment", "part", "cell", "add", "or", "existent", "member", "it", "ent", "se", "ie", "link", "item", "attribute", "via", "id", "ry", "entity", "row", "ce", "illegal", "associated", "element", "resource", "needed", "nt", "e", "key", "office", "error", "name", "index", "ace", "char", "obj", "event", "directory", "enter", "record", "check", "archive", "match", "job", "comment", "escape", "info", "data", "Entry", "word", "image", "list", "pattern", "zip"], "outputDir": ["outputRel", "outRel", "outputFolder", "resultFile", " outputDirectory", "outputDis", " outputRel", "updateDis", "responseNet", "OutputFolder", "resultRel", "outputDirectory", "outputNet", "resultDir", "OutputDirectory", "inputDis", "inputDir", "responseDir", "outFolder", "responseDis", "updateDir", "updateNet", "OutputFile", "OutputDir", "inputNet", " outputFolder", "outDir", "outFile", "outDirectory"], "outputFile": ["displayFile", "responsefile", "responsePort", "tempDir", "OutputFILE", "currentfile", "currentStream", "componentPort", "outputFILE", "putFile", "OutputImage", "outputPlace", "componentPlace", "putSet", "currentDir", "componentFile", "OutputPort", "outputPort", "outputfile", "keyF", " outputImage", "outputImage", "Outputfile", "displayFILE", "keyFile", "componentfile", "tempStream", "outputF", "outputSet", "responsePlace", "keyDir", "tempFile", "OutputF", "putDir", "responseFile", "OutputFile", " outputSet", "displayDir", "OutputSet", "keyFILE", "OutputDir", "OutputStream", "currentFile", "putImage", "tempfile", "OutputPlace", "displayF"], "inputStream": ["InputStream", "openThread", "outputSteam", "openSteam", " inputThread", "requestStream", "InputSteam", "outputStreamer", " inputSource", "inputSocket", " inputStreamer", "requestSource", "outputSource", "actSteam", "openSocket", " inputSocket", " inputSteam", "actStreamer", "thisStreamer", "openStream", "inputThread", "inputSteam", "thisSteam", "actStream", "thisSource", "requestStreamer", "InputThread", "thisStream", "InputSocket", "inputSource", "inputStreamer", "actSource", "requestSteam"], "outputStream": [" outputStreamer", "outputSteam", "publicView", "successSteam", "publicStreamer", " outputThread", "Outputstream", "outputStreamer", "successForm", "successStream", "publicStream", "OutputThread", "outputForm", "successstream", "OutputView", "outputstream", "OutputSteam", "publicForm", "inputThread", "inputSteam", "publicstream", "outputView", "outputThread", "OutputStreamer", "publicSteam", "OutputStream", " outputSteam", "inputStreamer", "OutputForm", " outputView"]}}
{"id1": "21425787", "id2": "18782385", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyByte", "CopyFile", "Copyfile", " copyFiles", "CopyFiles", "transferFile", "transferFiles", "copyFiles", "transferByte", "CopyByte", "copyByte", " copyfile", "copyfile", "transferfile"], "in": ["IN", "on", "din", "gin", "n", "it", "rin", "is", "ic", "ie", "vin", "b", "old", "o", "en", "inc", "from", "ind", "ins", "ar", "el", "up", "isin", "l", "In", "input", "source", "i", "inn", "inf", "cin"], "out": ["output", "n", "Out", "ent", "it", "b", "p", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "nt", "at", "g", "null", "str", "w", "l", "net", "err", "OUT", "source", "gt", "ne", "po", "i", "oss", "ot", "s", "c"], "sourceChannel": ["seedChannel", "srcChannel", "sourcePanel", "inputConnection", "srcChan", "systemPanel", "ourceChannel", " sourceClass", "sourceChan", "ourceCommand", "sourceClass", "ourceClass", "sourceCategory", "startChannel", " sourceManager", "seedPanel", "ourceConnection", "inputChan", "startCategory", "seedMachine", "sourceManager", "srcManager", "seedCategory", "inputCh", "sourceCh", "srcCommand", "startPanel", " sourceCommand", "ourceManager", "systemCategory", " sourceConnection", "sourceMachine", "ourceChan", "startMachine", "srcConnection", "srcCh", "srcClass", "systemChannel", " sourceChan", " sourceCh", "systemMachine", "sourceConnection", "inputChannel", "sourceCommand"], "destinationChannel": ["restinationChan", "destinatorChan", "destinationHandler", "destinatedChannel", "DestationChannel", "destensionChan", "DestinationHandler", "DestinationConnection", "destinoChannel", "destationConnection", "destinationsChan", "destationHandler", "Destationchannel", "destinatorHandler", "Destinationchannel", "DestinationChannel", "DestationChan", "DestensionConnection", "destinatedContext", "DestensionChan", "destinationsChannel", "destensionchannel", "destensionConnection", "restinochannel", "destinationchannel", "destinatedchannel", "Destensionchannel", "restinationchannel", "DestinationChan", "destinationContext", "destensionChannel", "destinochannel", "destinatorChannel", "destationChan", "destinoContext", "restinoChan", "restinoContext", "destationChannel", "destationContext", "destinationChan", "destinoChan", "DestationHandler", "destinationsConnection", "destinationschannel", "destationchannel", "DestensionChannel", "restinationChannel", "restinoChannel", "destinatedChan", "destinationConnection", "restinationContext", "destinatorchannel"]}}
{"id1": "841724", "id2": "5138455", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "1421557", "id2": "3958807", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "15745420", "id2": "23677147", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"download": [" Download", "update", "save", "split", "link", "move", " downloads", "del", "transfer", "install", "dl", "login", "request", "pull", "view", "dump", "upload", "Download", "remote", "submit", "copy", "GET", "archive", "file", "data", "dial", "zip"], "address": ["path", "place", "message", "express", "site", "shape", "description", "password", "addr", "add", "location", "prefix", "type", "link", "attribute", "connection", "Address", "reference", "absolute", "uri", "resource", "server", "email", "relative", "street", "key", "name", "index", "contact", "service", "ace", "page", "directory", "remote", "command", "base", "adr", "domain", "comment", "search", "order", "context", "alias", "ip", "host", "report", "route", "network"], "localFileName": ["remoteFileName", "localfilePath", "localFullFilename", " localFilenameName", "localFilename", "localFileNum", "localFileType", "remoteFileType", " localFileFilename", "localFilenameSize", "localCodePath", " localFilename", "remoteFilenameSize", "localFullName", "localModelNames", "localFileSize", "LocalFilePath", "remoteFilenameType", " localFilenamename", "localFilenameNames", "localFilenamePath", "localPagePath", "LocalFilenameNum", "localFilenameNum", "localFullname", "localDirFilename", "LocalFileNames", "localFilenameFilename", "LocalFileName", "localDirPath", " localFilenamePath", "LocalFilenamePath", "localFileNames", "localFilenameType", "LocalFilenameName", "LocalFileNum", "localModelPath", "localModelName", "remoteFilenamePath", "localTablePath", "localDirname", "localFilenameName", "localPagename", "localfileSize", "localPageNames", "localCodeName", "remoteFileSize", " localFilePath", "localPageSize", "localFileFilename", "remoteFilePath", "remoteFilename", "localModelNum", "LocalFilenameNames", "localFilenamename", "localfileName", "localfilename", " localFilenameFilename", "localPageName", "remoteFilenameName", "localPageNum", "localCodeType", "localTableType", "localDirName", "remoteFilenamename", "localTableName", "localFilePath", "localFullPath"], "ext": ["path", "alg", "text", "addr", "x", "config", "eng", "not", "ret", "type", "xt", "except", "end", "dir", "desc", "Ext", "t", "EXT", "typ", "fab", "sect", "content", "code", "dist", "name", "str", "pat", "dim", "txt", "obj", "cont", "tim", "def", "file", "exp", "off", "sp", "format", "cmd", "word", "prot", "pattern", "zip"], "temp": ["output", "fake", "path", "part", "emp", "prefix", "orig", "pdf", "template", "EMP", "tmp", "tar", "tm", "tab", "p", "dat", "local", "por", "dir", "test", "mt", "t", "created", "pt", "current", "relative", "pre", "box", "null", "tc", "cp", "dest", "none", "w", "perm", "mp", "txt", "tr", "mk", "mod", "porary", "Temp", "tif", "mem", "partial", "base", "copy", "table", "file", "tem", "empty", "memory", "cache", "zip"], "out": ["output", "bo", "cos", "on", "con", "or", "n", "boot", "Out", "it", "ln", "sys", "tmp", "b", "body", "p", "can", "no", "o", "inv", "to", "os", "aos", "end", "io", "OU", "conv", "outs", "t", "op", "client", "pos", "yes", "ou", "e", "at", "write", "oe", "null", "inner", "writer", "ns", "ao", "w", "one", "obj", "go", "net", "print", "OUT", "ne", "cn", "file", "i", "oss", "ot", "co", "outer"], "conn": ["ch", "nc", "connect", "con", "Connection", "addr", "n", "open", "gate", "connection", "ct", "socket", "rel", "enc", "cs", "conv", "ssl", "client", "resp", "serv", "cm", "nt", "syn", "canon", "cp", "comm", "cb", " con", "obj", "yn", "ctx", "cn", "cc", "ctrl", "co", "cert", "jp", "cmd", "com", "conf", "ca", "res", "Conn", "c"], "in": ["IN", "on", "din", "gin", "con", "asin", "or", "internal", "init", "n", "ln", "it", "oin", "rin", "ini", "is", "ic", "user", "ain", "raw", "can", "image", "no", "inv", "en", "inc", "from", "irm", "nin", "ind", "er", "ins", "t", "client", "up", "bin", "all", "inner", "str", "stream", "isin", "l", "In", "net", "conf", "input", "source", "iter", "file", "i", "inn", "inside", "inf", "cin"], "url": ["http", "mail", "con", "ls", "sl", "open", "build", "bel", "link", "ur", "connection", "Url", "ul", "f", "URL", "rel", "pl", "ssl", "dl", "nl", "client", "browser", "gl", "google", "str", "mb", "ll", "cp", "l", "www", "net", "lr", "web", "cert", "cmd", "r", "hl", "il"], "buffer": ["message", "Buffer", "binary", "history", "shape", "window", "cell", "block", "password", "phrase", "template", "buf", "button", "database", "bar", "filter", "raw", "variable", "read", "sample", "row", "queue", "frame", "initial", "buff", "length", "view", "number", "sequence", "command", "batch", "base", "source", "mem", "padding", "table", "stroke", "value", "comment", "stack", "document", "memory", "paste", "append", "column", "word", "cache"], "numRead": ["numberWrite", " numSend", "numberLoad", "umerRead", " numPush", "newPush", " numREAD", " numWrite", "numberReader", " numLength", "umPrint", " numLoad", "numWrite", "numberREAD", "sumWrite", "sumRead", "umRead", "numREAD", "sumReader", "newSend", "numLength", "NUMREAD", "NUMRead", "numReader", "numberPrint", " numPrint", "umerReader", "numPush", "numLoad", "newRead", "numPrint", "numberRead", "umerPush", "umLoad", "NUMLoad", "numberLength", "NUMLength", "numSend", "newReader", "umerSend", " numReader"], "numWritten": ["numberWrite", " numWrit", " numWrite", "monWrit", "numWrite", "NumWrite", "NumWritten", " numWriter", "monWritten", "numberWritten", "umWriter", "monWriter", "umWritten", "NumWriter", "NumWrit", "numWriter", "numWrit", "monWrite", "umWrite", "numberWriter"], "oldArq": ["oldDarch", "oldarQ", "oldDarck", "lastArch", "oldUrck", "oldAq", " oldAq", "oldArqs", "oldArch", "oldAqs", " oldTarQ", "lastARq", " oldTariq", "oldTarqs", "oldTarQ", "oldariq", " oldArch", "oldARch", "oldArQ", " oldTarqs", "oldLaiq", "oldDarqu", "oldArqu", "lastARch", "lastArck", "oldARq", "oldUrq", " oldAQ", "oldTarch", "oldarqs", "oldTariq", " oldArqs", "oldAQ", "oldARqu", " oldAqs", " oldArQ", "oldLaQ", "lastARqu", "lastArq", "oldAch", "lastArqu", " oldAriq", "oldDarq", "oldarq", "oldARck", " oldAch", " oldTarch", "oldUrch", "oldLaq", "oldArck", "lastARck", "oldUrqu", "oldLaqs", "oldTarq", " oldTarq", "oldAriq"], "nomeFinal": ["NomeGlobal", " nomFinal", "NomeFinal", "nomfinal", "namefinal", " nomfinal", "nadeGlobal", "noursefinal", "NadeGlobal", "NadeWall", "nadeWall", "nameGlobal", " nomFin", "nomFinal", "NomeWall", "nourseFinal", "nomesFin", " nomeFin", "nadeFin", "nomeWall", "nadeFinal", "nomFin", "nourseGlobal", "nameFinal", "Nadefinal", "nomesfinal", "nomeGlobal", "nomesFinal", "nomefinal", "nameWall", "NadeFinal", "nourseWall", " nomefinal", "Nomefinal", "nomeFin", "nadefinal"]}}
{"id1": "16820041", "id2": "9550506", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encodePassword": ["enotepassword", "enotePass", "enccodePassword", "enodePass", "enccodePass", "encodedpassword", "encodePass", "enodepassword", "enccodepassword", "encodepassword", "enodePassword", "encodedPass", "enotePassword"], "_originalPassword": ["_OriginalString", " _modifiedPassword", "_modifiedText", "_originalUser", " _originalString", "_encryptedString", "_modifiedUser", " _modifiedText", "_encryptedText", " _originalWord", "_OriginalUser", "_encryptedWord", "_modifiedToken", "_OriginalText", "_encryptedUser", " _modifiedWord", "_encryptedPassword", "_modifiedString", " _originalUser", "_encryptedToken", "_modifiedPassword", "_modifiedWord", " _modifiedString", "_originalWord", " _OriginalPassword", "_OriginalPassword", "_originalString", " _OriginalUser", " _OriginalToken", "_originalToken", " _OriginalString", "_originalText", " _originalText", "_OriginalToken", " _originalToken", "_OriginalWord"], "md": ["dr", "pm", "ms", "nd", "add", "sd", "mc", "bd", "od", "metadata", "MD", "sha", "grad", "der", "cd", "ds", "mg", "mm", "dm", "mt", "ind", "red", "ma", "sm", "dh", "nt", "det", "ld", "magic", "mb", "d", "dd", " mc", " Md", " m", " mo", "mp", "mk", "mod", "managed", "dig", "pd", "def", "m", "df", "material", "di", "mo", "mn", "mand", "cmd", "hd", "ng", "de"], "encodedPassword": ["enccodedSecret", "encressedPassword", "enccodedPassword", "ecryptedpassword", "encodingText", "encachedPassword", "encatedPassword", "EncodingUser", "encachedpassword", "encatedpassword", "acodedConnection", "ecodedSecret", "ecryptedSecret", "EncodingPassword", "encryptedUser", "encodingUser", "acratedPassword", "encoderUser", "acodedpassword", "ecryptedString", "encodedString", "encoderPassword", "encratedPassword", "encryptedSecret", "encressedConnection", "encryptedpassword", "ecodedPassword", "encodedUser", "encressedpassword", "encoderEmail", "encatedConnection", "EncodedUser", "encryptedString", "acratedConnection", "encodedText", "EncodedText", "EncodedEmail", "encachedString", "encodingEmail", "EncodingText", "encodedEmail", "encodingPassword", "enccodedpassword", "encratedConnection", "ecodedpassword", "EncodedPassword", "encryptedEmail", "encodedSecret", "encodedConnection", "encryptedPassword", "encratedpassword", "enccodedString", "ecryptedPassword", "EncodingEmail", "acratedpassword", "ecodedString", "encoderText", "encodedpassword", "acodedPassword", "encachedSecret", "encryptedText"]}}
{"id1": "5676111", "id2": "14598566", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"get": [" download", "init", " fetch", "sync", " finish", "export", "download", "execute", " construct", "call", "run", "delete", " recover", "dump", "upload", "Get", " delete", "Download", "gc", "print", "GET", " copy", "info", " reload", "exec", " put", "zip"], "cnt": ["ncht", "ccount", "cNT", "clen", " cct", "Cht", "Cnt", "unclen", "uncnt", "ncnt", "nNT", "nnt", "acNT", "uncNT", "Ccount", "nccount", "acnc", " cnc", "aclen", "CNT", "cnc", "Cnc", " cht", "Cct", "uncnc", " cNT", "nct", " ccount", "nnc", "cct", "cht", "ncct", "acnt", " clen"], "url": ["path", "http", "mail", "con", "ls", "addr", "sl", "open", "ret", "build", "bel", "link", "handle", "ur", "Url", "ul", "f", "socket", "URL", "rel", "pl", "ssl", "dl", "uri", "loc", "nl", "client", "el", "browser", "gl", "ref", "null", "google", "str", "mount", "xml", "ll", "fl", "cp", "l", "char", "www", "fs", "base", "https", "web", "cert", "r", "host", "hl"], "conn": ["ch", "nec", "nc", "connect", "con", "addr", "access", "init", "org", "open", "com", "connection", "ct", "rel", "enc", "ens", "col", "en", "os", "conv", "pas", "nl", "client", "loc", "resp", "serv", "nt", "cm", "syn", "ns", "cp", "comm", "cons", "coll", "cb", "l", "obj", "exec", "net", "cont", "yn", "ctx", "cn", "co", "cert", "jp", "cmd", "gn", "act", "ca", "dial", "Conn", "c", "cur"], "is": ["ist", "ists", "ais", "im", "abs", "isc", "mis", "ms", "init", "iso", "ris", "it", "es", "dis", "ri", "ic", "sys", "isl", "has", "nis", "lis", "bis", "bs", "isa", "its", "iss", "os", "ys", "ins", "ps", "rs", "isf", "ib", "si", "Is", "isin", "fs", "sit", "iris", "vis", "imp", "iter", "us", "icks", "i", "ends", "sim", "ios", "in", "ip", "isi", "IS"], "filename": ["fn", "path", "sbm", "prefix", "lua", "title", "fil", "f", "continental", "latest", "nm", "sql", "mson", "Filename", "fp", "stem", "subject", "ename", "ame", "FIL", "journal", "river", "nu", "name", "str", "LCS", "println", "username", "family", "txt", "kl", "FILE", "string", "source", "knife", "file", "ren", "til"], "fos": ["faos", "loes", "boss", " foses", "Foss", "bos", "flaos", " foes", "Faos", "fres", "flos", "vos", "floes", "Foses", "Fos", "foes", "laos", "Fres", "floss", "voses", " foss", "boes", "los", "loss", "fows", "Fows", "vaos", " fows", "foses", " faos", "foss", "vres", "Foes", " fres", "bows"], "buffer": ["output", "message", "Buffer", "binary", "history", "text", "window", "block", "phrase", "buf", "template", "button", "database", "bar", "available", "attribute", "variable", "sample", "queue", "frame", "note", "bone", "total", "buff", "length", "library", "view", "bytes", "char", "page", "sequence", "event", "result", "print", "command", "batch", "base", "source", "mem", "iter", "table", "comment", "stack", "document", "data", "display", "memory", "paste", "scroll", "append", "temp", "cache"]}}
{"id1": "9550506", "id2": "16063533", "code1": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"cookieString": [" challengeBytes", "cookieHash", " cryptStr", " cookieStr", " cryptBytes", " cookieByte", " cookieBytes", "cookieBytes", " cookieHash", " cryptByte", " challengeHash", "cookieByte", " challengeStr", "cookieStr", " cryptHash", " challengeByte"], "url": ["path", "http", "mail", "ls", "addr", "sl", "ur", "Url", "ul", "address", "URL", "api", "util", "ssl", "uri", "dl", "loc", "el", "browser", "gl", "home", "mount", "ll", "get", "l", "www", "remote", "lr", "file", "domain", "log", "web", "https", "host", "hl"], "ip": ["path", "http", "password", "addr", "chip", "prefix", "arp", "pkg", "ep", "address", "et", "id", "p", "api", "uri", "loc", "client", "email", "IP", "iv", "name", "ips", "cp", "mac", "net", "tip", "port", "domain", "secure", "skip", "i", "app", "sp", "origin", "host", "zip"], "md": [" dd", "dr", " cmd", "pm", "ms", "nd", "sd", "mc", "bd", "od", "metadata", "del", "MD", "sha", "hm", "grad", "der", "cd", "mg", "met", "mm", "dm", "mt", "ind", "ke", "red", " ms", "ma", "sm", "dh", "nt", "det", "ld", "td", " mt", "dd", "d", " Md", " mc", " mm", " mo", " del", "mk", " m", "managed", " sm", "mp", "mem", " MD", "pd", "def", "m", "df", "mn", "cmd", " ma", "hd", "ng", " sd"], "hash": ["message", "rh", "mask", "html", "password", "Hash", "hed", "has", "sq", "sha", "h", "sample", "checked", "uh", "total", "tag", "ref", "ho", "this", "key", "magic", "sh", "index", "mac", "shadow", "sum", "amd", "check", "sam", "bh", "her", "hd", "kernel", "cache", "ash"]}}
{"id1": "19738435", "id2": "19235551", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"parse": ["arse", "proc", "load", "json", "shape", "replace", "se", "build", "link", "parser", "read", "create", "slice", "resource", "transform", "pair", "request", "process", "xml", "service", "layer", "file", "match", "construct", "document", "format", "handle"], "url": ["path", "http", "ls", "location", "abs", "term", "sl", "open", "build", "link", "ur", "Url", "address", "q", "URL", "id", "sql", "parser", "util", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "client", "browser", "gl", "ref", "name", "mount", "xml", "str", "ll", "impl", "l", "u", "page", "char", "conn", "localhost", "base", "string", "input", "file", "web", "document", "https", "host", "github"], "target": ["output", "path", "collection", "owner", "top", "node", "model", "term", "template", "instance", "graph", "type", "metadata", "arget", "Target", "root", "local", "to", "t", "resource", "scope", "parent", "nt", "component", "tree", "group", "name", "container", "other", "result", "record", "project", "source", "object", "table", "context", "layout", "report", "pattern"], "parseURL": [" parseUrl", "buildUrl", " parseSR", "buildURL", "parseSR", "arsePage", "buildPage", "arseURL", "buildSR", "arseUrl", "arseSR", "parseUrl", " parsePage", "parsePage"], "connection": ["nc", "session", "connect", "application", "cone", "Connection", "con", "ion", "description", "open", "database", "link", "response", "generation", "condition", "socket", "character", "relation", "creator", "uri", "client", "resource", "channel", "created", "writer", "communication", "still", "established", "position", "connected", "directory", "result", "conn", "command", "entry", "document", "context", "c", "network"], "charset": ["charsat", "cheresect", "charsset", "chagnet", "charsET", "charsheet", "cheresset", "CHARSat", "cheresets", "chearsset", "chearsect", "chasset", "charsets", "chagnset", "chearsets", "CHarsat", "chereset", "charasset", "chresets", "chARSetter", "chactersect", "chararset", "chatsset", "chARSat", "chacterset", "chactersheet", "charasET", "chagnET", "chreset", "CHARSet", "chaset", "chARSet", "charsetter", "CHARSetter", "chearset", "chactersset", "CHarsetter", "CHARSets", "chasET", "chresect", "chararsset", "chactersetter", "chactersET", "chararsET", "chatset", "chagnheet", "chararsheet", "CHarsets", "chatsect", "charsect", "charasheet", "charaset", "chresset", "chactersat", "CHarset", "chatsets", "chasheet", "chactersets", "chARSets"], "reader": ["buffer", "runner", "message", "builder", "rar", "processor", "loader", "parser", "read", "row", "iterator", "io", "red", "uri", "client", "resource", "inner", "writer", "readable", "reading", "handler", "stream", "event", "upper", "Reader", "ner", "entry", "input", "source", "iter", "layer", "file", "driver", "document", "data", "context", "r"]}}
{"id1": "7633336", "id2": "20685385", "code1": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 0, "substitutes": {"executeHttpGet": [" executeHTTPPost", "executeUrlPut", "executeRemotePut", "executeUrlPost", "executeHttpGET", " executeHTTPPut", " executeHttpPost", "executeHTTPGet", "executeRemoteGET", "executeUrlGET", " executeHTTPGET", "executeHTTPPost", "executeUrlGet", "executeHttpPost", "executeRemoteGet", " executeHTTPGet", "executeRemotePost", "executeHTTPPut", "executeHTTPGET", " executeHttpPut", "executeHttpPut", " executeHttpGET"], "uri": ["path", "message", "http", "html", "description", "password", "location", "prefix", "force", "ri", "msg", "link", "ui", "ur", "address", "reset", "wiki", "basic", "queue", "subject", "qi", "resource", "ku", "filename", "server", "uu", "request", "du", "name", "original", "unit", "URI", "u", "href", "directory", "command", "string", "status", "parse", "i", "range", "https", "pi", "query", "url", "origin", "res"], "req": ["gr", "proc", "http", "task", "qt", "j", "qq", "msg", "pkg", "requ", "q", "sql", "inv", "create", "desc", "ind", "crit", "pp", "resp", "resource", "require", "ref", "request", "comp", "quest", "comm", "get", "quick", "md", "mk", "conn", "Request", "job", "ctrl", "find", "query", "work", "url", "cmd", "res", "sq", "dq"], "client": ["ch", "grid", "http", "con", "cell", "close", "force", "response", "connection", "ip", "ct", "api", "console", "ci", "pro", "Client", "server", "cm", "call", "key", "google", "pb", "tc", "cp", "service", "net", "conn", "remote", "cl", "cap", "secure", "chain", "co", "web", "https", "url", "city", "cli", "c", "cache"], "resLogin": ["statsConnect", "reslogin", " reslogin", "statsLogin", "statsClient", "Reslogin", "invlogin", "invLogin", "ResClient", "invConnect", "resConnect", "ResLogin", "statslogin", "ResConnect", "resClient", " resConnect", " resClient"], "r": ["dr", "R", "rar", "b", "rx", "ur", "f", "p", "rc", "hr", "re", "rd", "nr", "er", "fr", "rg", "rs", "rw", "cr", "rt", "river", "reader", "vr", "mr", "rr", "err", "rect", "sr", "lr", "rl", "rn", "ro", "br", "kr", "res", "rb"], "sb": ["ub", "bf", "sbm", "sl", "nb", "SB", "sd", "bd", "b", "lb", "bis", "bps", "bs", "lp", "kb", "bn", "bb", "sa", "erb", "ssl", "bt", "eb", "bg", "xb", "pb", "ib", "zb", "cb", "mb", "gb", "wb", "obb", "sg", "bj", "sam", "bh", "sp", "BB", "stab", "sf", "sq", "rb"], "s": ["ser", "ches", "ls", "ms", "st", "sl", "n", "se", "gets", "is", "b", "gs", "bs", "sql", "ss", "ds", "state", "y", "its", "ws", "qs", "h", "sample", "hs", "ys", "os", "ins", "t", "ps", "rs", "js", "ns", "g", "less", "where", "sol", "sts", "str", "comm", "fs", "sn", "string", "source", "z", "i", "sp", "tes", "sv", "full", "ts", "S", "sq"]}}
{"id1": "8087001", "id2": "23246123", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 0, "substitutes": {"generateStackHashKey": ["generateStackNodePage", "generateStackStateIndex", "generateTrackHashPage", "generateStackNodeKey", "generateStackHashKeys", "generateStackHashIndex", "generateStackStateKeys", "generateStackHashPage", "generateTrackhashPage", "generateStackStateKey", "generateTrackHashKeys", "generateTrackhashKeys", "generateTrackHashKey", "generateStackhashKey", "generateTrackhashKey", "generateStackNodeKeys", "generateTrackHashIndex", "generateStackNodeIndex", "generateStackhashIndex", "generateStackhashKeys", "generateTrackhashIndex", "generateStackhashPage", "generateStackStatePage"], "e": [" err", "eu", " me", "es", "x", "se", "n", "exc", "te", "ef", "a", "ie", "ep", "me", "f", "p", "eg", "eeee", "o", "xe", "h", "en", "ed", "ex", "er", "t", "element", "el", "ee", "email", "E", "oe", "eb", " ce", "error", " pe", "ec", "d", "eer", "ue", "ae", "u", "err", "event", "pe", "ne", "m", " exc", "i", "exp", "ge", "r", " te", " error"], "digest": ["compest", "Digse", " digse", " digests", "diger", "Digester", "compEST", " digested", "descgest", "Digest", "digested", "mdester", "Diger", "descse", " digEST", "decest", "decse", "compested", "decested", "compests", "Digests", "DigEST", " diggest", "descest", "mdested", "mdEST", "digse", "diggest", "descer", "Digested", "digEST", "digests", "decester", " diger", "digester", "mdest", " digester", "mdse", "Diggest"], "hash": ["message", "style", "rh", "html", "block", "Hash", "valid", "build", "has", "filter", "sha", "h", "sample", "ashed", "test", "report", "map", "total", "tag", "all", "hex", "key", "sh", "mac", "shadow", "sum", "dig", "check", "log", "chain", "bh", "search", "her", "score", "cache", "ash"], "rtn": ["RTnm", "ntN", "rtnm", "artns", "artnor", "RTnu", "aptnu", "RTN", "ytns", "rotns", "rtr", "rtyn", "rotnm", "rxne", "vrn", "latnm", "ttr", "erton", "aptr", "latn", "ttnu", "ytnor", "ttn", "artn", "mtnm", "rotnor", "tton", "ertn", "RTcn", "vrb", "mtcn", "rtN", "vrnm", "rotyn", "apton", "rxmn", "ntnm", "ytyn", "otmn", "rotn", "vrN", "rtmn", "rotcn", "rxnm", "aptn", "rtnor", "rxn", "otne", "ertr", "rton", "ntn", "otnm", "RTb", "rtb", "rtnu", "otn", "mtn", "ertnu", "artyn", "mtnu", "rotnu", "ntb", "rtns", "latmn", "latne", "rtne", "RTn", "ytn", "rtcn"]}}
{"id1": "5998352", "id2": "2910383", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"testStandardTee": [" testStandardTette", " testStandardEe", " testStandardMees", " teststandardMe", " testStandardMee", " testStandardNe", " teststandardMees", " testStandardEee", " testStandardNees", " testStandardEees", " teststandardTees", " testStandardMe", " testStandardNee", " testStandardTe", " teststandardTe", " testStandardTees", " testStandardMette", " teststandardMette", " testStandardEette", " teststandardTette", " teststandardMee", " teststandardTee", " testStandardNette"], "reference": ["approximately", "collection", "message", "expression", "pointer", "function", "description", "internal", "prefix", "using", "template", "hello", "section", "resolution", "type", "link", "attribute", "condition", "example", "see", "title", "address", "definition", "sample", "relation", "test", "re", "reverse", "register", "note", "associated", "use", "argument", "filename", "back", "relative", "ref", "library", "request", "key", "specified", "name", "operation", "external", "service", "position", "sequence", "directory", "print", "remote", "string", "value", "document", "Reference", "search", "memory", "alias", "word", "report", "pattern", "information"], "source": ["buffer", "ser", "style", "core", "template", "instance", "SOURCE", "force", "seed", "shell", "loader", "ource", "sql", "console", "sample", "iterator", "from", "resource", "spec", "Source", "operator", "src", "inner", "store", "reader", "unit", "get", "service", "username", "stream", "sequence", "base", "input", "copy", "select", "file", "target", "format", "context"], "destination1": ["destificationOne", "stensionOne", "Destinationone", "destinatorOne", "destensionFirst", "DestinatorOne", "destregationName", "destinator1", "destination01", "destinationName", "desturationFirst", "destificateOne", "Destinatorone", "Destinator1", "stensionFirst", "Destinator01", "destinatorName", "destregationone", "stension1", "destation1", "destinatorone", "destification1", "destregation1", "destinations2", "destificationone", "desturation2", "stination2", "destensionOne", "destinator01", "destificationName", "destinationone", "stinationFirst", "destension1", "destationOne", "destregationOne", "destension2", "Destination01", "desturationOne", "stinationOne", "destinationFirst", "destinationsOne", "destificate1", "destation01", "desturation1", "destificate01", "destinationsFirst", "stension2", "DestinatorName", "Destination1", "DestinationOne", "stination1", "DestinationName", "destinations1", "destinationOne"], "destination2": ["Destination2", "desturation4", "destinated3", "destinationtwo", "destensionTwo", "destinate1", "desturationB", "estinition52", "destendanttwo", " destinationB", "destendant2", "destendant4", "destinition3", " desturation2", "destinated2", "destinateTwo", "DestensionTwo", " desturationB", "Destension1", "destination52", "desturation2", "estinition3", "Destension2", "estination3", "destinated52", "destension1", "destinate2", "destensiontwo", "destendantB", "destinition52", "estination52", "destension2", "destination4", "estinition2", " destination4", "destociationTwo", "destinationTwo", "destinator3", "destinator2", "desturationtwo", "destociation2", "destociation1", " desturationtwo", "destination3", "Destination1", "destension4", "destinator52", "destinition2", "destinationB", "destensionB", "DestinationTwo", "estination2", " destinationtwo", " desturation4"], "tee": [" teE", "chete", " teoe", " teea", "chee", "peer", "cheee", "see", "seoe", "tees", "pee", "ceoe", "ieea", "pees", "peoe", "ceer", "cee", "ieee", "tete", "teea", " tete", "iee", "peee", "iete", "seee", "teee", "cheea", " teee", "teE", "ceee", "teoe", "teer", "peE", "seE", "ceE", " teer", " tees", "cees"]}}
{"id1": "3266833", "id2": "3330944", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "label": 1, "substitutes": {"is": ["ists", "ais", "isc", "init", "iso", "ris", "ois", "sys", "isl", "has", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "bits", "serv", "isf", "any", "get", "Is", "isin", "fs", "iris", "parts", "us", "i", "ios", "info", "sis", "s", "in", "was", "isi", "IS"], "name": ["path", "self", "part", "description", "location", "prefix", "term", "n", "template", "type", "normal", "class", "title", "body", "id", "local", "size", "create", "default", "current", "filename", "NAME", "parent", "length", "ame", "code", "this", "key", "null", "version", "number", "get", "position", "info", "family", "named", "sequence", "base", "string", "source", "Name", "file", "value", "i", "names", "admin", "search", "data", "format", "alias", "handle", "url", "in", "word", "image", "order"], "contentType": ["fileQuery", "messageTypes", "ContentLength", " contentLength", "contentQuery", "contentUnit", "contentControl", "messagetype", "mediaTypes", "mediaQuery", "Contenttype", "mediatype", "messageControl", "mediaType", "contentTypes", "ContentType", "messageType", "fileTypes", "contentLength", "messageLength", "fileType", "messageQuery", " contentTypes", "mediaUnit", "contenttype", " contentControl", "messageUnit", "ContentTypes", " contentUnit", "mediaLength", "mediaControl", " contenttype", "fileLength"], "index": ["path", "update", "fee", "offset", "depth", "timeout", "prefix", "x", "access", "n", "instance", "open", "dx", "type", "sort", "address", "count", "id", "exclusive", "size", "row", "num", "test", "create", "ind", "slice", "pos", "lock", "length", "content", "code", "key", "error", "Index", "si", "number", "position", "level", "sequence", "batch", "axis", "action", "value", "max", "i", "find", "info", "success", "height", "start", "image", "list"], "extension": ["protension", "contention", "xtention", "xtitude", "protend", "extend", "xtension", "extitude", "extention", "protention", "xtend", "protitude", "contend", "contension", "contitude"], "isImage": ["ISPhoto", "isaimage", "isoMedia", "isItemImage", "wasImage", "needsPhoto", "needsFile", "isimage", "hasMedia", "isaImage", "isoItemImage", "areMedia", "ISimage", " isItemImage", "needsimage", "hasFile", "isoImage", "needsImage", "areImage", "areFile", "needsPicture", "wasimage", "wasFile", "isFile", "isaPicture", "needsMedia", "hasimage", "isPicture", "areItemImage", "ISPicture", "isoFile", "isMedia", "isaPhoto", " isFile", "isPhoto", " isMedia", "ISImage", "wasMedia", "hasImage"], "isAux": [" isCAux", "isiAuxe", "isNAmp", "isOAux", "isSAUX", "isPaux", "isinPamp", "isCAux", "isiOAiox", "wasAux", "isiAiox", "wasAAxx", "isaaux", "isAUX", "isAiox", "isNAaux", "isAAux", "isinPaaux", " isCAaux", "isOAult", "isAAUX", "isNAux", "isOAuxe", " isCAx", "isAcx", "isAndux", "isaux", "isAAxx", "isinPaux", "isAcaux", "isOAxx", "wasAUX", "isAx", "isinAUX", "isiOAux", "wasAult", "wasAAult", "wasAAux", "isCAUX", "isiAux", "isAult", "isauxe", "isOAiox", "isaiox", "isCAx", "isCAiox", "isinAaux", "isAcux", "isAaux", "isSAaux", "isOAaux", "isinAux", "isNAUX", "isinPaUX", " isCAUX", " isAaux", "wasAxx", "wasAAUX", "isOAUX", "isinAmp", "isSAmp", "isAuxe", "isiOAuxe", "isPaUX", "isiOAaux", "isPaaux", "isAndaux", "isAndUX", "isAcUX", "isCAuxe", "isPamp", "isAAult", "isiAaux", "isSAux", " isAx", "isAmp", " isAUX", "isAxx", "isAndx", "isCAaux"], "out": ["output", "cos", "list", "ion", "con", "timeout", " Out", "by", "n", "auto", "Out", "ent", "vol", "boot", "user", "it", "sys", " OUT", "tmp", "b", " output", "p", "pool", "o", "aos", "to", "os", "io", "OU", "conv", "outs", "t", "pos", "ex", "up", "v", "lock", "nt", "at", "all", "this", "null", "w", "sum", "go", "net", "result", "conn", "gc", "OUT", "batch", "cn", "port", "cache", "log", "oss", "chain", "co", "in", "we", "outer", "res", "order"], "bufferedImage": ["renderedImages", "renderedVideo", "buffererImages", "bufferingImage", "bufferredimage", "bufferedVideo", "bufferredImage", "renderingImages", "renderedImage", "bufferredVideo", "bufferredImages", "bufferingVideo", "bufferingImages", "renderingimage", "buffererimage", "buffererImage", "bufferedimage", "renderedimage", "renderingImage", "bufferedImages", "buffererVideo", "renderingVideo", "bufferingimage"], "inputStream": ["InputStream", "inputSteam", "outputSteam", "outputView", "inputstream", "InputView", "outputStream", "InputSteam", "currentView", "inputView", "currentSteam", "currentstream", "outputstream", "currentStream", "Inputstream"]}}
{"id1": "2199604", "id2": "536614", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"unzipEntry": ["unlinkFile", "unwrapEnt", "UnzipEnt", "unzipInternal", "UnpackInternal", "unlinkInternal", "unpackInternal", "UnpackFile", "unpackFile", "UnpackEnt", "UnzipFile", "unpackEnt", "UnzipEntry", "unlinkEnt", "UnzipInternal", "unwrapEntry", "unlinkEntry", "unwrapFile", "unwrapInternal", "unzipFile", "UnpackEntry", "unpackEntry", "unzipEnt"], "zipfile": ["Zipimage", "zonetree", " zipFile", "archivetree", "ziptree", "ztree", "zip2", "zipFile", " zip2", "zipimage", "zonefile", "zFile", "zoneimage", "archivefile", "zone2", "Zip2", "ZipFile", " zipimage", "zfile", "zoneFile", "Zipfile", "archiveFile"], "entry": ["ment", "part", "cell", "add", "or", "existent", "member", "it", "ent", "se", "ie", "link", "item", "attribute", "via", "id", "ry", "entity", "row", "ce", "illegal", "associated", "element", "resource", "needed", "nt", "e", "key", "office", "error", "name", "index", "ace", "char", "obj", "event", "directory", "enter", "record", "check", "archive", "match", "job", "comment", "escape", "info", "data", "Entry", "word", "image", "list", "pattern", "zip"], "outputDir": ["outputRel", "outRel", "outputFolder", "resultFile", " outputDirectory", "outputDis", " outputRel", "updateDis", "responseNet", "OutputFolder", "resultRel", "outputDirectory", "outputNet", "resultDir", "OutputDirectory", "inputDis", "inputDir", "responseDir", "outFolder", "responseDis", "updateDir", "updateNet", "OutputFile", "OutputDir", "inputNet", " outputFolder", "outDir", "outFile", "outDirectory"], "outputFile": ["displayFile", "responsefile", "responsePort", "tempDir", "OutputFILE", "currentfile", "currentStream", "componentPort", "outputFILE", "putFile", "OutputImage", "outputPlace", "componentPlace", "putSet", "currentDir", "componentFile", "OutputPort", "outputPort", "outputfile", "keyF", " outputImage", "outputImage", "Outputfile", "displayFILE", "keyFile", "componentfile", "tempStream", "outputF", "outputSet", "responsePlace", "keyDir", "tempFile", "OutputF", "putDir", "responseFile", "OutputFile", " outputSet", "displayDir", "OutputSet", "keyFILE", "OutputDir", "OutputStream", "currentFile", "putImage", "tempfile", "OutputPlace", "displayF"], "inputStream": ["InputStream", "openThread", "outputSteam", "openSteam", " inputThread", "requestStream", "InputSteam", "outputStreamer", " inputSource", "inputSocket", " inputStreamer", "requestSource", "outputSource", "actSteam", "openSocket", " inputSocket", " inputSteam", "actStreamer", "thisStreamer", "openStream", "inputThread", "inputSteam", "thisSteam", "actStream", "thisSource", "requestStreamer", "InputThread", "thisStream", "InputSocket", "inputSource", "inputStreamer", "actSource", "requestSteam"], "outputStream": [" outputStreamer", "outputSteam", "publicView", "successSteam", "publicStreamer", " outputThread", "Outputstream", "outputStreamer", "successForm", "successStream", "publicStream", "OutputThread", "outputForm", "successstream", "OutputView", "outputstream", "OutputSteam", "publicForm", "inputThread", "inputSteam", "publicstream", "outputView", "outputThread", "OutputStreamer", "publicSteam", "OutputStream", " outputSteam", "inputStreamer", "OutputForm", " outputView"]}}
{"id1": "5744493", "id2": "8069594", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doPageMove", " synchronizedFullDownload", " synchronizedFileMove", " doFileMove", " synchronizedFullMove", " doFullMove", " doPageCopy", " doFullDownload", " doFileDownload", " doFileCopy", " synchronizedFileCopy", " doStreamCopy", " doStreamMove", " synchronizedFullCopy", " doPageDownload", " synchronizedFileDownload", " doFullCopy", " doStreamDownload"], "in": ["IN", "din", "gin", "or", "init", "n", "it", "rin", "ic", "b", "ck", "old", "ain", "as", "o", "en", "inc", "from", "mm", "ind", "ex", "ins", "el", "up", "ac", "isin", "l", "In", "input", "source", "file", "i", "inn", "r", " input", "inf", "cin"], "out": ["output", "ch", "n", "Out", "it", "p", "as", "o", "to", "os", "io", "help", "ex", "outs", "t", "op", "up", "v", "serv", "ou", "nt", "at", "write", "null", "w", "l", "net", "OUT", "check", "gt", "ne", "file", "log", "po", "ot", "s", "res", "c"], "inChannel": ["inCh", " inCommand", "vinConnection", "outCh", " inButton", "dinButton", "inConnection", " inConnection", "dinCommand", "vinChannel", "cinChannel", "INStream", "isinChan", "innCategory", "inchannel", "InChannel", "inCategory", "innCommand", "INChannel", " inchannel", "vinCommand", "inChan", "innerchannel", "innerChan", "Inchannel", "cinCategory", " inChan", "InCh", "outchannel", "dinChan", "innButton", "inStream", "inCommand", "INChan", " inCh", "isinConnection", "dinCase", "innerStream", "cinButton", "isinChannel", "isinButton", "vinCase", "innChannel", "outChan", "inCase", "cinCommand", "dinConnection", "dinChannel", " inCategory", "outStream", "InChan", " inCase", "inButton", "INchannel", "innerChannel"], "outChannel": ["upMachine", "outCh", " outRoom", "OutChan", " outCh", "outMachine", "OutChannel", "newChannel", " outStream", " outchannel", "inChan", "aosSection", "OutCh", "aosDisk", "aosChannel", "OutStream", "newConnection", "outchannel", "upSection", "cosMachine", "outDisk", " outConnection", "outerRoom", "inStream", "upChannel", "upDisk", "newchannel", "cosChannel", "onChannel", "outRoom", "outputChan", "outerChannel", " outChan", "outChan", "onConnection", "cosDisk", "aosMachine", "outputChannel", "onChan", "outConnection", "outerStream", "outSection", "newChan", "outStream", "outputStream", "outputCh", "cosSection", "inRoom", "onchannel", "outerChan"], "maxCount": ["maxFlag", "maxSize", " maxSize", "MAXLength", " maxLength", "maxLength", "minLength", "maxCast", "MaxLength", "MaxCount", "minCount", " maxCast", "minSize", "MaxSize", "minFlag", "MAXCount", "MAXFlag", " maxFlag", "minCast", "MaxCast"], "size": ["equal", "message", "Size", "fee", "shape", "ms", "notice", "close", "space", "resolution", "sd", "gets", "is", "ze", "shift", "small", "count", "send", "body", "export", "duration", "area", "ize", "sample", "read", "sent", "total", "length", "len", "write", "any", "name", "readable", "si", "bytes", "scale", "position", "sum", "keys", "SIZE", "south", "speed", "m", "capacity", "set", "ose", "range", "show", "scroll", "empty", "height", "start", "score", "seek"], "pos": ["cos", "pointer", "part", "offset", "slot", "x", "n", "it", "pg", "p", "no", "Position", "rel", "o", "to", "os", "coord", "row", "pl", "pid", "pr", "pro", "seq", "loc", "pose", "pt", "spec", "ps", "resp", "length", "Pos", "pass", "POS", "doc", "index", "position", "l", "page", "pc", "limit", "point", "def", "port", "zero", "po", "i", "sp", "pi", "off", "exp", "start", "left", "len"]}}
{"id1": "14773782", "id2": "14764852", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" decodeJPEGGrater", " decodeJPEGPater", " decodeJPEGPotation", " decodeJPEGRasters", " decodeJPEGGrasters", " decodeJPPGrater", " decodeJPEGrotation", " decodeJPEGRotation", " decodeJPEGPasters", " decodeJPEGrasters", " decodeJPPGRasters", " decodeJPEGGrotation", " decodeJPEGrater", " decodeJPPGRater", " decodeJPPGraster", " decodeJPPGrasters", " decodeJPPGRaster", " decodeJPEGRater", " decodeJPEGraster", " decodeJPEGRaster", " decodeJPPGrotation", " decodeJPPGRotation", " decodeJPEGGraster", " decodeJPEGPaster"], "IOException": ["URIProblem", "IOProblem", "ConnectionProblem", " IOFailure", "URIException", "ConnectionException", "IOFailure", "ConnectionFailure", "URIFailure", " IOProblem"], "start": ["Start", "top", "wind", "st", "step", "offset", "init", "time", "birth", "it", "open", "seed", "send", " started", "end", "read", "reset", "create", "from", "started", "t", "initial", "get", "before", "delay", "base", "print", "starting", "trans", "set", "wait", "art", "insert", "rest", "first", "begin"], "i": ["multi", "im", "counter", "x", "j", "init", "phi", "my", "it", "ini", "ai", "is", "ie", "ski", "ui", "ic", "b", "me", "f", "major", "q", "id", "p", "ci", "gu", "ind", "mi", "ex", "ki", "qi", "ii", "client", "conv", "gi", "uu", "request", "g", "key", "bi", "ti", "name", "index", "si", "I", "u", "go", "sequence", "batch", "m", "xi", "us", "iq", "di", "sim", "pi", "info", "s", "ij", "exp", "in", "out", "li", "c", "ix"], "url": ["path", "http", "mail", "ls", "location", "hub", "link", "ur", "gif", "Url", "ul", "q", "URL", "id", "rel", "row", "uri", "dl", "nl", "resource", "el", "browser", "gl", "ref", "key", "mount", "xml", "ll", "external", "l", "char", "string", "lr", "domain", "log", "job", "web", "res", "r", "host", "pattern"], "istream": ["ISTub", "ststream", "istram", "astroll", "istsabel", "iststream", "istsream", "istub", "istStream", "iftub", "iftriver", "istriver", "istank", "stStream", "astStream", "astream", "isub", "isriver", "istroll", "itstream", "itroll", "ISTank", "ISTream", "astabel", "stream", "isream", "ISTriver", "istsStream", "iftank", "istabel", "aststream", "iftream", "astram", "ISTroll", "isank", "itream", "ISTstream", "stabel", "istsstream", "ISTram", "itram"], "dec": ["deg", "De", "DEC", "dev", "valid", "dis", "draw", "des", "bd", "rec", "del", "bec", "der", "enc", " Dec", " DEC", "desc", "dem", "dep", "det", "disc", "da", "ec", "Dec", "dc", "coll", "cam", "exec", "dig", "def", "ra", "decl", " enc", "ko", "oct", "div", "agg", "dra", "cor", "c", "de"], "raster": [" rreement", " ratter", "Raster", " rraphic", "Rasters", "remraphic", "replreement", "Rraphic", "brast", "master", "replaster", "matter", "remmap", "mastered", "Rreement", "ratter", "rastered", "remaster", " rast", " rasters", "rreement", "bratter", "Rmap", "rraphic", "brastered", "replasters", "Ratter", "remasters", "mast", " rmap", " rastered", "replatter", "braster", "rmap", "rasters", "rast"], "width": ["path", "const", "text", "shape", "window", "step", "term", "resolution", "orth", "change", "ength", "body", "wa", "cut", "weight", "size", "tall", "sw", "frame", "issa", "length", "write", "Width", "dim", "w", "position", "wid", "strength", "axy", "cale", "padding", "ose", "fw", "success", "displayText", "layout", "widget", "idth", "left", "len"], "height": ["buffer", "alpha", "history", "style", "inches", "shape", "depth", "window", "volume", "resolution", "count", "acity", "h", "size", "dimension", "frame", "power", "th", "kw", "length", "confidence", "hang", "rank", "density", "radius", "angle", "cision", "gravity", "padding", "capacity", "grow", "stroke", "holes", "Height", "ty"], "stop": ["quit", "pause", "update", "est", "step", "close", "st", "term", "timeout", "counter", "it", "ops", "root", "cut", "no", "end", "Stop", " Stop", "period", "op", "enable", "ab", "disable", "delete", "null", "next", "post", "jump", "obj", "result", "gc", "set", "pop", "status", "wait", "skip", "max", "trip", "termination", "success", "wake", "fin", "commit", "rest"]}}
{"id1": "12085127", "id2": "17580775", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 0, "substitutes": {"navigate": ["Naviate", "configure", "generiate", "configigation", "Navate", "navure", "naviate", "avure", "avigate", "Navigate", "generigate", "avigation", "configigate", "navinate", "generigation", "Navinate", "aviate", "avinate", "navigation", "avate", "Navure", "Navigation", "configate", "generinate", "navate"], "url": ["path", "http", "html", "ls", "location", "term", "sl", "org", "ret", "build", "link", "ur", "b", "Url", "f", "address", "ul", "URL", "util", "pl", "ssl", "uri", "dl", "nl", "loc", "email", "gl", "ref", "this", "key", "null", "req", "str", "mount", "xml", "name", "ll", "external", "l", "char", "page", "www", "conn", "rect", "base", "string", "file", "domain", "log", "job", "web", "document", "cert", "host", "il"], "connection": ["nc", "message", "application", "connect", "pointer", "cone", "Connection", "con", "ion", "description", "session", "open", "database", "generation", "response", "controller", "condition", "statement", "socket", "sql", "console", "character", "relation", "channel", "client", "resource", "created", "communication", "still", "opening", "position", "established", "connected", "net", "directory", "conn", "command", "entry", "set", "city", "network"], "is": ["ims", "mis", "ais", "im", "isc", "ms", "tis", "iso", "ris", "dis", "ois", "ic", "ri", "isl", "nis", "bis", "bs", "isa", "as", "its", "iss", "os", "are", "ins", "rs", "si", "stream", "Is", "fs", "iris", "ism", "us", "isi", "i", "oss", "ios", "s", "sis", "in", "ip", "lis", "IS"]}}
{"id1": "20568568", "id2": "742465", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"createHTML": ["CreateSQL", "CreateHT", " createSQL", "seeHT", "seeSQL", "seeHTML", "seeURL", "createHT", " createHT", "createURL", "CreateURL", "createSQL", "CreateHTML", " createURL"], "requestPage": [" requestFrame", "responseFrame", "referenceApp", "questionApp", "RequestLine", "requestFrame", "questionpage", "referenceType", "RequestFrame", "RequestPage", "referencepage", "requestType", "RequestType", " requestLine", "Requestpage", "referencePage", "responseLine", "questionPage", "requestLine", "questionType", " requestType", "RequestApp", "requestApp", "requestpage", "responseType", "responsePage"], "result": ["output", "buffer", "message", "out", "function", "html", "json", "description", "reason", "prefix", "term", "section", "detail", "response", "product", "params", "root", "complete", "relation", "true", "answer", "cup", "feature", "summary", "all", "this", "request", "error", "figure", "page", "sequence", "line", "command", "source", "date", "value", "match", "render", "comment", "results", "join", "document", "work", "search", "success", "format", "memory", "trace", "res", "r", "word", "report", "cache", "Result"], "url": ["http", "html", "ls", "abs", "ol", "sl", "open", "link", "ur", "Url", "f", "URL", "loader", "rel", "ws", "re", "ssl", "uri", "dl", "nl", "resource", "browser", "gl", "ref", "str", "xml", "ll", "get", "l", "char", "fs", "base", "lr", "rl", "sb", "web", "in", "res", "r", "il"], "ins": ["als", "vs", "con", "ains", "gin", "asin", "din", "ls", "lins", "ln", "ris", "includes", "is", " in", "gs", "Ins", "bs", "ds", "its", "qs", "ws", "uds", "ars", "eds", "cs", "pins", "rus", "ics", "ints", "ils", "rys", "inner", "sts", "ks", "ats", "reader", "ips", "rates", "kins", "mr", "isin", "fs", "input", "INS", " din", "pers", "in", "res", "ts", "cin"], "bufferedReader": [" buffererReader", "buffedLoader", "buffaredReader", "buffiledreader", " buffedContainer", " buffedReader", " bufferedreader", "buffiledWriter", "buffaredBuilder", "bufferingReader", "bufferedreader", " bufferedLoader", "buffedReader", "bufferedBuilder", "buffedBuilder", "buffaredLoader", "buffererLoader", "bufferedContainer", "bufferingreader", " buffererBuilder", " buffedWriter", "buffiledContainer", " bufferedWriter", "buffedContainer", "buffedWriter", "buffiledReader", " buffererWriter", "bufferedWriter", " buffererLoader", "bufferingContainer", " bufferedBuilder", "bufferingWriter", "buffererReader", " buffedreader", "buffaredWriter", "bufferedLoader", "buffererWriter", " bufferedContainer", "buffererBuilder", "buffedreader"], "cssLine": ["ssLin", "cssData", "cosBody", "styleData", "rssBody", "ssLine", "ssRow", "cosLine", "ssBlock", "rssLine", "rssRow", "javascriptBlock", "javascriptRow", "cssline", "cosBlock", "styleLine", "CSSRow", "cssBlock", "styleRow", "cssBody", "cosRow", "ssBody", "csRow", "cssRow", "ssData", "csData", "csLine", "javascriptLin", "ssline", "csline", "rssBlock", "javascriptLine", "cssLin", "CSSLin", "CSSBlock", "styleline", "CSSLine"], "e1": ["e01", "e2", "E0", "ee5", "o5", "E1", " e3", "ee0", " e5", "e3", "ee1", " e2", "ee3", "o1", "o01", "e5", " e0", "ee2", "o0", "E3", "E2", "o2", " e01", "e0", "ee01"], "queryZoom": ["queryZoneolution", "viewZoo", " queryZooming", "queryXome", "queryzom", "queryzoo", "queryDom", "queryZoo", " queryZolution", "queryZoneom", "queryZome", " queryzolution", "queryzome", "viewZom", "viewZome", "queryZXolution", "queryZolution", "queryXoo", "viewzom", " queryzom", " queryzooming", "queryZXooming", "queryzooming", "viewzoom", "queryDoom", "queryZooming", "queryZoneoom", "queryZXom", "queryDoo", "viewzome", "queryZoneooming", "queryXoom", "queryDome", "queryzoom", "queryXom", "queryzolution", "queryZXoom", "viewzoo", " queryzoom", "viewZoom", " queryZom", "queryZom"], "appendToHome": ["appendTOHome", "appendToUrl", "appendtoMenu", "addtoMenu", "appendTOUrl", "addtoHome", "addtoUrl", "appendtoUrl", "appendtoQuery", "appendetoHome", "appendtoHome", "addtoQuery", "appendetoUrl", "addToQuery", "addToMenu", "addToHome", "addToUrl", "appendTOQuery", "appendetoMenu", "appendetoQuery", "appendTOMenu", "appendToQuery", "appendToMenu"], "sql": ["fn", "series", "expression", "spr", "db", "json", "ls", "ms", "sd", "sys", "statement", "condition", "params", "ql", "q", "rel", "inv", "SQL", "sel", "mt", "dl", "nl", "ma", "spec", "qu", "setup", "QL", "sol", "where", "xml", "quote", "imp", "sn", "string", "expr", "select", "scl", "csv", "table", "sp", "query", "sv", "cmd", "sq"], "pstmt": [" pstpr", "pSTMT", "pstmr", " pstrmr", "pstsql", "pStMT", "psem", "pmtpr", "prsthmt", " pstm", "pSTpr", "pstrmr", "pstpr", "prsthpr", "psthpr", "pstrsql", "pmtStatement", " pstms", "pstrbl", "pstm", "pstartMT", "pstatbl", "prsthStatement", " pStms", "pstrm", "pstatm", "psthmt", "psthst", "pstStatement", "postpr", " pstrm", "pstatmr", "pSTms", "pfrmt", "prsthst", "pstartmt", "pstrpr", "pstatmt", "psemt", " pstrmt", "pstMT", "pStms", "pStmt", "pstbl", "prstmt", " pStmt", "pstms", "pSTStatement", " pStMT", "pfrpr", "psebl", " pstrbl", " pstsql", "pstst", "postm", "psemr", "postsql", " pstMT", " pfrm", "pmtmt", "pSTmt", " pfrpr", "pstartms", "pStst", "prstpr", "prstStatement", " pfrmt", "pstrmt", " pStst", " pstmr", "postmt", "pfrsql", "prstst", "psthStatement", " pstbl", "pstartst", " pfrsql", "pfrm", "pmtst", "pSTst", " pstst"], "rs": ["ims", "ms", "ls", "ris", "ows", "gs", "bs", "ss", "ds", "rc", "ues", "rows", "ws", "its", "os", "ars", "ys", "xs", "cs", "rd", "ps", "rys", "rt", "sts", "ks", "ats", "rates", "mr", "fs", "Rs", "ras", "res", "ts", "RS"]}}
{"id1": "5399593", "id2": "13563706", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["ecode", "deccode", "enccode", "enrypted", "ecrypt", "encode", "eccode", "decrypted", "enrypt", "decode", "encrypted", "ecrypted", "decrypt", "enode"], "plaintext": ["plainth", " Plaininput", "plainpassword", "preText", " Plaintext", " plaininput", "aintext", "plaincontext", "plaininput", "maintext", "plainText", " plainText", "mainText", "preword", " Plainth", "pretext", "mainword", " plainword", " Plainpassword", " plaincontext", "ainth", "precontext", "maincontext", " plainth", "aininput", "ainpassword", " plainpassword", "plainword"], "UnsupportedEncodingException": ["UnsupportedEncryptionError", "UnsupportedCompoderError", "UnsupportedCompodingException", "UnsupportedEncodedError", "UnsupportedEncoderError", "UnsupportedEncoderEx", "UnsupportedCompodingError", "UnsupportedEncodingError", "UnsupportedCompoderEx", "UnsupportedEncryptionEx", "UnsupportedEncodedException", "UnsupportedEncoderException", "UnsupportedCompoderException", "UnsupportedCompodingEx", "UnsupportedEncryptionException", "UnsupportedEncodingEx", "UnsupportedEncodedEx"], "md": [" dd", "dr", " cmd", "pm", "ms", "nd", "add", "sd", "mc", "bd", "od", "del", "MD", "sha", "grad", "der", "cd", "mg", "mm", "dm", "mt", "ind", "red", "sm", "nt", "det", "ld", "dd", "d", " Md", " mc", "mb", " mm", " m", " mo", "mk", "mp", "mod", " MD", "gm", "pd", "def", "m", "df", "mo", "mn", "mand", "cmd", "med", " ma", "hd", "exec", "ad"], "raw": ["strip", "message", "load", "json", "core", "orig", "unsigned", "n", "buf", "valid", "draw", "des", "available", "known", "bare", "read", "row", "hook", "rendered", "clear", "all", "hex", " Raw", "sh", "serial", "bytes", "RAW", "cooked", "custom", "mem", " RAW", "input", "clean", "data", "full", "empty", "aw", "out", "Raw", "pack", "was"], "hash": ["message", "html", "mask", "password", "Hash", "unknown", "hat", "hed", "has", "sha", "id", "ssh", "ashes", "h", "ASH", "ashed", "total", "tag", "cloth", "component", "code", "hex", "key", "name", "zh", "sh", "dump", "mac", "shadow", "hidden", "sum", "tr", "result", "check", "bh", "search", "height", "proof", "ash"]}}
{"id1": "4686922", "id2": "8430178", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceAsFiles", "extractResource2File", "extractResourcesToFile", "extractResourceAsfile", "extractResourceAsStream", "extractResourceFromStream", "extractResources2File", "extractResourceTofile", "extractResourcesToFiles", "extractResourcesToStream", "extractResourcesTofile", "extractResource2Files", "extractResources2Files", "extractResourceFromFile", "extractResource2file", "extractResources2file", "extractResources2Stream", "extractResourceToFiles", "extractResourceAsFile", "extractResourceFromfile", "extractResourceFromFiles", "extractResource2Stream", "extractResourceToStream"], "resourcePath": ["Resourcepath", "templatepath", "resourceName", "ResourceIn", "templateIn", "uriUrl", " resourceIn", "resourceIn", "uriPath", "templatePath", "resourcepath", "ResourceLocation", "uriName", "ResourcePath", "resourceLocation", "attributeLocation", "resourceUrl", "attributeName", "ResourceName", "uriLocation", "attributeUrl", "ResourceUrl", " resourcepath", "attributePath", " resourceName", "templateName"], "dest": ["output", "lit", "gov", "self", "orig", "img", "des", "tmp", "opt", "dat", "prop", "to", "end", "dir", "coord", "desc", "cat", "loc", "etc", "parent", "this", "src", "dist", "null", "home", "w", "good", "result", "cont", "Dest", "mem", "source", "trans", "nom", "decl", "sp", "target", "comb", "origin", "temp", "rest"], "in": ["IN", "on", "din", "gin", "con", "or", "init", "ln", "it", "rin", "ini", "is", "mc", "sin", "f", "raw", "id", "no", "local", "inc", "from", "re", "mi", "ind", "al", "ins", "resource", "up", "bin", "all", "inner", "none", "isin", "r", "l", "In", "input", "source", "ne", "iter", "m", "file", "i", " din", "inside", "inn", "conf", "inf", "cin"], "out": ["output", "ch", "cos", "on", "con", " Out", "n", "Out", "it", "sys", "tmp", "b", "f", "can", "no", "o", "aos", "to", "col", "en", "os", "io", "pool", "note", "conv", "outs", "t", "client", "v", "ou", "nt", "exit", "at", "na", "stable", "null", "write", "writer", "inner", "w", "obj", "net", "print", "OUT", "ne", "cn", "again", "i", "oss", "co", "ot", "res", "outer", "cache"]}}
{"id1": "19335986", "id2": "20619879", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncappedFailure", "uncurredException", " uncuredFailure", "uncaughtception", " uncaughtception", "uncuredError", "uncuredFailure", "uncurredception", " uncuredException", " uncuredError", "uncaughtFailure", " uncaughtFailure", "uncurredError", " uncuredception", " uncaughtError", "uncaughtError", "uncappedException", "uncuredException", "uncappedError", "uncuredception", "uncappedception", "uncurredFailure"], "t": [" T", "T", "task", " title", "window", "n", "b", "title", "f", "p", "y", " th", "o", "h", "to", " tid", " st", "g", "d", "w", "thread", "l", " ti", "m", "Thread", "out", "tf", "c"], "e": ["ev", "eu", "es", "x", "se", "it", "exc", "te", "ef", "fe", "ie", "a", "b", "f", "et", "p", "eg", "o", "ele", "xe", "eeee", "ce", "en", "ed", "ex", "er", "el", "ee", "Error", "ea", "E", "oe", "error", "ec", "d", "u", "ae", "event", "err", "pe", "m", "i", "r", "c", "de"], "display": ["output", "style", "session", "window", "dis", "draw", "present", "link", "b", "lay", "body", "console", "server", "DIS", "browser", "Display", "this", "name", "label", "view", "d", "screen", "position", "l", "print", "details", "table", "log", "show", "render", "s", "scroll", "layout", "play", "report", "list"], "shell": ["output", "buffer", "quit", "expression", "session", "window", "Shell", "or", "program", "dis", "ui", "handle", "b", "echo", "body", "sound", "environment", "console", "ssh", "help", "control", "nl", "server", "scope", "browser", "library", "tree", "sh", "view", "screen", "tool", "board", "l", "form", "print", "command", "log", "hell", "system", "sb", "ro", "scroll", "layout", "cli", "storage", "report"], "message": ["field", "buffer", "management", "application", "session", "mail", "description", "window", "template", "hello", "menu", "member", "button", "open", "msg", "detail", "response", "echo", "metadata", "manager", "payment", "title", "body", "console", "subject", "Message", "email", "content", "summary", "translation", "request", "module", "error", "label", "view", "say", "position", "one", "result", "command", "object", "m", "essage", "meter", "language", "log", "show", "comment", "system", "document", "memory", "trace", "layout", "image", "report", "question"], "e1": [" e3", "E2", " e0", "ee0", "E0", "e2", "ee2", "e3", "ee1", "e0", " e2", "E3", "ee3", "E1"]}}
{"id1": "15896098", "id2": "3024992", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checkam", "getSHA256Checkchecksums", "getSHA256Checsums", "getSHA256Checsum", "getSHA256Chechecksam", "getSHA256Chechecksume", "getSHA256Chechecksum", "getSHA256Checkume", "getSHA256Checksam", "getSHA256Checksums", "getSHA256Checkchecksam", "getSHA256Checkum", "getSHA256Checkcksums", "getSHA256Checkchecksume", "getSHA256Checkcksum", "getSHA256Checkchecksum", "getSHA256Checkums", "getSHA256Chechecksums", "getSHA256Checsam", "getSHA256Checkcksam", "getSHA256Checksume", "getSHA256Checsume", "getSHA256Checkcksume"], "source": ["path", "buffer", "output", "message", "style", "text", "reason", "template", "SOURCE", "seed", "secret", "body", "raw", "ource", "sample", "from", "subject", "filename", "Source", "content", "this", "src", "name", "sequence", "base", "string", "input", "status", "file", "value", "target", "data", "s", "format", "url", "in", "context", "out", "image"], "checksum": ["checksim", "checkssum", "cksumb", " checksums", " checksume", "cksum", " checkssum", "ckssum", "csume", "checkums", "checkume", "checkumb", "cksume", "checkim", "csim", "cksums", " checksim", "cssum", " checksumb", "csum", "checksums", "checkum", "checksume", "checksumb", "cksim"], "md": ["dr", "pm", "ms", "pdf", "sd", "mc", "bd", "od", "MD", "grad", "der", "cd", "wd", "mg", "mm", "dm", "mt", "ind", "down", "red", "sm", "dh", "nt", "det", "ld", "dd", "d", " Md", "mb", "mp", "mk", "mod", " MD", "Cmd", "pd", "def", "m", "df", "di", "mo", "mn", "mand", "cmd", "hd", "ad"], "byteData": ["bytedata", "ByteDATA", "routeDat", " bytedata", "bytesDATA", "sliceList", " byteList", "bytesArray", "sliceDat", "bleRel", "ioList", "phraseParts", "bytesBytes", " byteDat", "byteList", "channelRel", "phraseDATA", "reverseCount", "phraseBytes", " byteCount", "byteRel", "byteDATA", "wordBytes", "byteCount", "ByteBytes", "routeDATA", "bledata", " byteParts", "ioDATA", "ioData", " byteDATA", "byteBytes", "channelParts", "wordData", "ByteParts", "wordDATA", "wordArray", "byteParts", "reverseData", "byteArray", "reverseDat", " byteArray", "bytesData", "channelData", " byteBytes", "ByteData", "channeldata", "byteDat", "reverseDATA", "sliceDATA", "bleData", "routeData", " byteRel", "routeCount", "ioDat", "phraseData", "sliceData", "bleParts"], "sb": ["ub", "bf", "db", "sbm", "nb", "SB", "b", "lb", "bis", "shell", "SF", "bs", "lp", "kb", "ob", "bsp", "bps", "sw", "bb", "sa", "erb", "ssl", "bt", "sm", "eb", "bg", "xb", "pb", "ib", "zb", "mb", "si", "gb", "wb", "cb", "sh", "obb", "sg", "bj", "bash", "sam", "bh", "sp", "sv", "sf", "sq", "rb"], "i": ["ims", "ion", "it", "ri", "ic", "iu", "to", "ind", "qi", "gi", "any", "err", "set", "iy", "ij", "cli", "li", "oi", "list", "series", "json", "j", "init", "my", "ini", "ui", "q", "o", "uri", "this", "hi", "g", "ti", "ji", "bi", "l", "print", "remote", "chain", "sim", "ip", "\u0438", "multi", "im", "ity", "ie", "loop", "me", "major", "id", "ci", "er", "ii", "client", "life", "u", "ei", "m", "xi", "iq", "pi", "history", "ms", "phi", "ai", "ski", "y", "io", "mi", "gu", "ki", "si", "I", "ime", "point", "di", "info", "ix"], "hexString": [" HexResource", "exString", "hashArray", " hexstring", "fullString", "shortArray", "shortString", " Hexstring", "fullStore", "exArray", "hexstring", "htmlstring", "shortResource", "exBuffer", "htmlString", "hashString", " HexBuffer", " hexArray", " hexBuffer", "exstring", "hexBuffer", "shortstring", "shortBuffer", "htmlArray", "htmlBuffer", "hexStore", "fullstring", "exStore", "hexArray", "fullBuffer", "hashBuffer", " hexStore", "hashstring", " hexResource", "hexResource", " HexString"], "hex": ["lit", " sex", "json", "html", "rex", "tex", "rh", "term", "x", "hello", "des", "pex", "ext", "raw", "prop", "h", " ex", "alph", "cat", "rendered", "ex", " Hex", "sex", "solid", "comp", "flash", "sh", "zh", "he", "dump", "none", "cont", "form", "temp", "def", "tx", "ph", "oct", "exp", "full", "php", "alias", "com", "mix", "hl"]}}
{"id1": "17193692", "id2": "4458076", "code1": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"execUpdate": [" ExecSet", " executeUpdate", " ExecUpdate", "ExecUpdate", "executeSelect", "ExecSet", "executeAction", " executeSet", " ExecSelect", " ExecAction", "ExecAction", "ExecSelect", "executeSet", " executeAction", " executeSelect", "executeUpdate"], "sqlStmts": ["sqlStrmnt", "sqlStrmms", "sqlSylts", "sqlStrrths", "sqlSylms", "sqlStmls", "sqlStrmths", "sqlStmths", "sqlStlsts", "sqlStrrments", "sqlStarmts", "sqlSttmnt", "sqlStmtters", "sqlStrmns", "sqlStrmps", "sqlStamuts", "sqlStrrls", "sqlSylsts", "sqlStrmuts", "sqlStmns", "sqlStamters", "sqlStlps", "sqlStamts", "sqlStrrms", "sqlSymsts", "sqlStrruts", "sqlStrths", "sqlStmrks", "sqlStmtsts", "sqlStmms", "sqlStarmms", "sqlStrps", "sqlStrks", "sqlStrrmters", "sqlStmtms", "sqlStrrns", "sqlStrts", "sqlStlms", "sqlStmrts", "sqlStsps", "sqlSymms", "sqlStlments", "sqlSttmps", "sqlStmtps", "sqlStrrnt", "sqlStrmsts", "sqlStmters", "sqlStmks", "sqlStmtns", "sqlStmuts", "sqlStsnt", "sqlStrters", "sqlStarmters", "sqlStmnt", "sqlStlters", "sqlStrmks", "sqlStarmments", "sqlStrrks", "sqlStmsts", "sqlStrmments", "sqlSttmts", "sqlStmtts", "sqlStamths", "sqlStrmls", "sqlStrments", "sqlStrrters", "sqlStrms", "sqlSymts", "sqlStmrters", "sqlStlts", "sqlSttmls", "sqlStrns", "sqlStmtks", "sqlStmps", "sqlStrrmnt", "sqlStrrts", "sqlStruts", "sqlStmments", "sqlStrrmts", "sqlStsls", "sqlSylps", "sqlSymps", "sqlStrmters", "sqlStrrmps", "sqlSttmters", "sqlStrmts", "sqlStrls", "sqlStmrns", "sqlStrnt", "sqlStsts", "sqlStrrps"], "i": ["multi", "ims", "im", "zi", "x", "j", "n", "phi", "it", "my", "ini", "ai", "is", "ic", "a", "ui", "ie", "me", "ri", "iu", "id", "y", "o", "ci", "mi", "ind", "uri", "slice", "ii", "qi", "ma", "v", "asi", "gi", "hi", "key", "g", "bi", "ti", "ji", "index", "si", "I", "u", "ei", "yi", "point", "m", "xi", "us", "cli", "ori", "z", "di", "sim", "pi", "ij", "info", "in", "ip", "li", "c", "\u0438", "ix"], "stmt": ["ostMT", "st", "stMT", "ostmt", "smp", "Stt", "Stm", "stm", "styMT", "StMT", "Stg", "stt", "stymsg", "Stmsg", "Stmp", "sm", "stym", "Stmt", " stmp", " stmsg", "stymt", "stmp", "ostm", "stg", "ostg", " stm", "stmsg", " stMT", " stg", "smt", " stt"]}}
{"id1": "3024987", "id2": "14191679", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStreamWithEncending"], "in": ["IN", "din", "gin", " IN", "con", "init", "n", "it", "rin", "ini", "is", "mc", "sin", "p", "as", "read", "local", "inc", "from", "mm", "mi", "ind", "Input", "ins", "up", "ac", "bin", "inner", "isin", "r", "l", "In", "cont", "input", "source", "copy", "iter", "m", "i", "info", "data", "inn", "act", "inside", "inf", "cin"], "reader": ["rise", "buffer", "dr", "per", "rar", "phrase", "rx", "loader", "parser", "read", "row", "iterator", "io", "red", "er", "oe", "inner", "req", "writer", "reading", "handler", "rot", "mr", "rr", "ocker", "Larry", "Reader", "ner", "input", "iter", "rl", "file", "driver", "ro", "query", "data", "r"], "baout": ["caout", "baOut", "baos", "beanout", "haouts", "beanouts", "cain", "beanin", "haout", "oaos", "BAout", "bares", "haOut", "yaout", "BAin", "caOut", "boOut", " baot", "yain", "baouts", "beanOut", "bain", "oaout", "oain", "hain", "boos", "boout", "BAot", "caos", "BAres", "oaOut", "yares", "caouts", " bain", " bares", "baot", "boin", "yaot"], "out": ["output", "bo", "cos", "update", "con", " Out", "n", "auto", "Out", "sys", " OUT", "b", " output", "o", "to", "os", "io", "OU", "conv", "outs", "t", "client", "ex", "ou", "all", "stable", "null", " bout", "ao", " outs", "net", "OUT", "batch", "gt", "ne", "copy", "cn", "oss", " os", "cmd", "outer", "res"], "bytes": ["faces", "binary", "units", "strings", "es", "words", "pdf", "gets", "des", "users", "versions", "gs", "bps", "bs", "latest", "comments", "raw", "frames", "its", "pages", "les", "cells", "outs", "bits", "files", "classes", "lines", "unks", "ones", "services", "letters", "terms", "ips", "ites", "values", "parts", "ings", "reports", "vals", "videos", "resources", "tes", "results", "Bytes", "names", "pieces", "data", "blocks", "groups", "issues", "seconds", "objects", "ies", "reads"]}}
{"id1": "8468859", "id2": "21979462", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"connect": ["con", "timeout", "close", "ping", "bind", "init", "config", "sync", "open", "link", "connection", "pen", "Connect", "create", "register", "client", "login", " disconnect", "ready", "setup", "exit", "request", "error", "process", "connected", "conn", "check", "set", "select", "log", "match", "construct", "join", "attach", "establish", "start", "dial", "network"], "status": ["output", "uses", "style", "update", "json", "description", "ping", "prefix", "access", "sync", "severe", "sign", "sort", "title", "params", "comments", "stats", "usage", "console", "sc", "flags", "use", "ssl", "login", "spec", "content", "summary", "settings", "code", "str", "version", "xml", "service", "scale", "policy", "sequence", "result", "gc", "details", "print", "check", "source", "stat", "impact", "comment", "join", "search", "format", "display", "url", "score", "list"], "reply": ["message", "part", "close", "prefix", "notice", "time", "nb", "user", "ret", "link", "response", "address", "vote", "state", " Reply", "frame", "answer", "feature", "back", "continue", "flag", "code", "write", "error", "next", "number", "Reply", "result", "record", "command", "consider", "job", "match", "comment", "py", "query", "success", "repl", "ply"], "isConnected": ["isConns", "isAdapts", "isCorrecting", "isPresented", "isProcessable", "isConnectioned", "isLoads", "isCorrecteds", "isStarting", "isAdapted", "issConnecting", " isConnects", " isLoadeds", "isConnections", "isConnectable", "isLoaded", "IsConnected", "isConnecting", "isConnured", "IsNECTedIn", "IsConnectED", "isConnectedIn", "isProcessed", "IsConnectured", "issConnecteded", "issConnectedIn", "isConnectionedIn", "isNECTed", "isPresentedIn", "isPresenting", " isConnecting", " isLoading", "isStartedIn", "IsConnecting", "isStarteded", "isAdapteds", "IsConnects", "issConnectioning", "isConnectionured", "isNECTing", "isLoadeds", "isLinkED", "isConnectured", "IsConnectionED", "isConnects", "IsConnectioned", "issConnectioned", "isLinks", "isConnectioneded", "isNECTable", "IsNECTed", "isCorrected", "IsNECTable", "isStartable", "IsNECTing", "isConnecteded", "isConnectED", "issConnectioneded", "isLinked", "isProcessing", "isConnecteds", "isConned", "isStarted", " isConnecteds", "isNECTedIn", "isConnectionED", "isConnectioning", "isPresenteded", "issConnected", "isLoading", "IsConnectedIn", "isConnED", "IsConnectionured", " isLoads", "IsConnections", " isLoaded", "isProcessedIn", "IsConnectable", "issConnectionedIn", "isLinkured", "isAdapting", "isCorrects"]}}
{"id1": "22046596", "id2": "755203", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": [" replace", " rename", " cp", " duplicate", " insert", " restore", "transfer", " mirror", " replicate", " cop", " parallel", "write", " move", " populate", " paste", "cp", "upload", " swap", " extend", "Copy", " overwrite", " seek", " Transfer", " copying", "paste", " dup", " share"], "s": ["ls", "es", "st", "ms", "sl", "n", "gets", "is", "sq", "b", "gs", "f", "p", "ss", "ds", "its", "qs", "os", "ses", "ws", "ys", "xs", "cs", "ins", "ps", "rs", "v", "js", "ns", "g", "less", "src", "sts", "ats", "str", "l", "fs", "south", "string", "source", "input", "z", "sb", "sv", "ts", "S", "ies", "sf"], "t": ["T", "st", "j", "template", "n", "it", "ent", "te", "ret", "unt", "tt", "title", "ct", "f", "p", "kt", "o", "h", "test", "mt", "pt", "v", "nt", "wt", "at", "rt", "g", "tc", "ts", "w", "l", "tr", "txt", "k", "ht", "gt", "i", "ot"], "in": ["IN", "din", "gin", "im", "con", "init", "it", "oin", "rin", "ai", "is", "ic", "ie", "and", "sin", "user", "en", "inc", "io", "from", "mi", "ind", "ins", "ar", "up", "bin", "inner", "isin", "ir", "In", "input", "source", "iter", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "ch", "con", "or", "by", "j", "n", "Out", "it", "msg", "sys", "b", "can", "o", "aos", "to", "en", "io", "ex", "outs", "channel", "client", "up", "ac", "v", "ou", "nt", "this", "g", "w", "l", "k", "net", "result", "conn", "OUT", "check", "gt", "cn", "i", "co", "ot", "res", "outer", "c"]}}
{"id1": "20190303", "id2": "3375724", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_no___lim", "test01_ok_failed_500_no___Log", "test01_ok_failed_500_noTlog", "test01_ok_failed_500_no_lim", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_No_og", "test01_ok_failed_500_No_lim", "test01_ok_failed_500_no_og", "test01_ok_failed_500_no_log", "test01_ok_failed_500_No_Log", "test01_ok_failed_500_No_log", "test01_ok_failed_500_noTlim", "test01_ok_failed_500_noTLog", "test01_ok_failed_500_noTog", "test01_ok_failed_500_no___og", "test01_ok_failed_500_no___log"], "client": ["collection", "http", "session", "connect", "con", "window", "close", "prefix", "cell", "template", "config", "force", "connection", "manager", "loader", "api", "console", "pool", "local", "control", "ssl", "Client", "channel", "resource", "server", "wrapper", "cm", "call", "google", "tc", "handler", "contact", "service", "conn", "remote", "cl", "secure", "system", "co", "https", "cert", "url", "city", "cli", "cmd", "context", "c", "cache"], "post": ["http", "json", "add", "save", "POST", "valid", "posts", "Post", "and", "put", "feed", "send", "body", "p", "wp", "read", "row", "create", "test", "ost", " Post", "op", "ps", "pod", "request", "pre", "write", "dd", "get", "upload", "form", "mod", "submit", "set", "copy", "parse", "url"], "response": ["output", "message", "http", "application", "json", "description", "block", "user", "onse", "connection", "example", "feed", "body", "sample", "re", "respond", "answer", "pos", "resp", "server", "tree", "version", "next", "xml", "view", "get", "service", "respons", "Response", "result", "remote", "entry", "status", "value", "reply", "info", "document", "data", "given", "res", "soc", "network"]}}
{"id1": "6742637", "id2": "17996547", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 0, "substitutes": {"findExtensions": [" findExtions", " findEXTensions", "findextions", " findExtras", "findEXTensions", "findEXTions", "findextensions", "findAppensions", "findExtions", "findEXTension", "findextras", "findAppension", "findEXTras", "findAppions", " findEXTras", " findEXTions", "findAppras", "findextension", " findExtension", "findExtras", " findEXTension", "findExtension"], "url": ["path", "ch", "http", "mail", "ls", "location", "addr", "abs", "sl", "config", "val", "link", "ur", "Url", "ul", "address", "URL", "loader", "rel", "norm", "util", "row", "pl", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "filename", "server", "lim", "email", "browser", "gl", "ref", "key", "req", "str", "mount", "xml", "name", "ll", "l", "char", "string", "lr", "cl", "rl", "file", "domain", "parse", "sb", "web", "https", "cert", "host", "hl"], "extensions": ["Extension", "Extends", "xtensions", "dimends", "extences", "appendperties", "Extensions", "Extences", "expension", " extension", "exended", "appendended", "expperties", "extperties", "xtperties", "expensions", "xtended", "appendensions", "exensions", "expends", "expences", "extances", "dimensions", "dimances", "xtances", "exances", " extences", "extended", "extension", "appendends", "dimended", "xtends", "exends", "expended"], "res": ["ch", "gr", "ser", "proc", "rex", "reg", "ms", "es", "abs", "vol", "resolution", "sys", "rem", "ver", "ry", "rel", "rez", "reset", "re", "er", "ins", "RES", "ps", "ers", "rs", "rys", "ref", "rt", "req", "cons", "ress", "mr", "Res", "mer", "us", "vers", "pres", "ro", "range", "pers", "ber", "r", "rest"], "prop": ["priv", "proc", "attr", "add", "term", "properties", "buf", "val", "pkg", "ext", "tmp", "property", "tab", "p", "rel", "col", "np", "plot", "desc", "att", "pr", "feat", "pro", "rop", "pos", "op", "pt", "pid", "ps", "cfg", "etc", "kw", "comp", "pred", "key", "pb", "cp", "Prop", "mp", "def", "cap", "pic", "po", "exp", "jp", "cmd", "conf", "bug", "prot"], "msg": ["message", "gov", "text", "reason", "ms", "notice", "kg", "pkg", "gs", "body", "desc", "mt", "Message", "sm", "cfg", "cmp", "bg", "g", "str", "ug", "Msg", "char", "mun", "txt", "md", "err", "sg", "good", "print", "string", "gm", "m", "uint", "nom", "hog", "log", "og", "mn", "mess", "urg", "cmd", "med", "utt"]}}
{"id1": "9449064", "id2": "3184073", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"readExp": [" readExpl", "passexp", " readExpress", "readerLoc", " readEx", "readerexp", "passExpl", "readProp", " readProp", "checkExp", "readerProp", " readLoc", "readExpl", "checkexp", "readLoc", "ReadProp", "readexp", "ReadEXP", " readEXP", "readerExp", "readerEx", "ReadExp", "ReadEx", "passExpress", "passExp", "checkExpl", "ReadLoc", "readEx", "readerEXP", "readExpress", " readexp", "checkExpress", "readEXP", "Readexp"], "writeExp": ["riteexp", "writeEx", "writeXP", "writeReg", "writeExt", "writEx", " writeExt", " writeReg", "writEXP", "riteEXP", "writexp", "riteConf", "writeexp", "updateExt", "writExp", "riteEv", "riteExt", "updateReg", "riteExp", " writeEXP", " writeXP", "updateExp", "updateEv", "writConf", " writeConf", "writeEXP", "applyEXP", " writeexp", "writeEv", "applyExp", "riteReg", "applyEx", " writeEx", " writeEv", "applyXP", "writeConf", "writXP"], "expFile": ["mxFilename", "exfile", "xpFiles", "expDir", "exprFile", "expPlace", "docField", "repFILE", "ExpFile", "expFilename", " expFilename", "docPlace", "ExpDir", "expField", "expFiles", "docFILE", "exFile", "xpFile", " expDir", "repPath", "xpPath", "exPlace", "exFILE", "repFile", " expfile", "mxFILE", "xpName", "expPath", "exprDir", "mxFile", "exprfile", "xpField", "expFILE", " expPlace", "xpFILE", "mxName", "xpFilename", "xpfile", " expFiles", " expFILE", "repField", "exprFilename", "Expfile", "expfile", "exprFILE", "exFiles", "expName", "exFilename", "exprName", "docFile", "docFilename", "docPath"], "exp": ["ev", "expression", " dj", " sc", "inf", "rep", "ent", " est", " doc", "ef", " extr", "plus", "ext", "bed", "f", "raw", " disp", "sc", "ez", "opt", " xp", "pl", "dem", " resp", "Exp", "pr", "pp", "resp", "esp", "ps", "lim", "ox", " expand", "acc", "xp", " expr", " ev", " inst", "comp", " vec", "prov", " ep", "comm", "EXP", " lim", "obj", " exponent", "imp", " np", "expl", "isp", "def", "expr", " expanded", "zero", " exc", "eq", "inst", " ne", "jp", " op", "eps", " imp", "push", " expansion", " rap", "nz", "wx"], "fi": ["ffe", "zi", "obi", "lf", "ista", "phi", "cci", "ri", "fe", "ini", "xf", "uti", "osi", "abi", "FI", "fty", "iri", "uci", "fif", "ico", "ci", "mi", "ki", "qi", "ii", "flo", "gi", "eric", "wi", "ti", "ni", "si", "ati", "ei", "Fi", "i", "zo", "pi", "aci", "li", "isi", "fa"], "oi": ["obo", "multi", "obi", "igi", "iso", "oin", "ini", "ri", "uti", "bis", "osi", "iri", "ta", "uci", "ink", "ico", "io", "mi", "ci", "uta", "ki", "ii", "flo", "uo", "asi", "eric", "ovi", "oa", "vi", "ti", "bi", "odi", "ni", "rio", "ati", "oni", "eni", "ei", "avi", "ivo", "ori", "ami", "i", "ita", "isi"], "jf": ["jackxf", "djbf", "jjF", "jv", "gfm", "jjc", "jfx", " jif", " jbf", "jjif", "jcfx", "bjfm", " jfp", "jjfc", "jbf", "Jf", " jc", "jackfd", "djf", " jsf", "jsbf", " jfx", " jfc", "jfc", "Jif", " jb", "jjf", "jcf", "Jbf", "jxf", "jcfm", " jv", "bjf", "JF", " jfm", "djxf", "jF", " jF", "Jfd", "jc", "jfd", "jcsf", " jxf", "bjv", "jjv", "jsxf", "bjfp", "jcxf", "jfm", "Jxf", "jackbf", "jb", "gc", "jif", "gf", "jackf", "jsf", "Jfm", "Jfx", "Jsf", "djfd", "jcb", "jfp", "jssf", "gfc", "jjfm", "Jb", "jjfp"], "sp": ["vp", "spr", "st", "space", "se", "rep", "so", "ep", "bp", "tp", "lp", "p", "sc", "bsp", "sw", "SP", "pl", "op", "pt", "sm", "esp", "ps", "par", " esp", "ap", "pb", "sh", "cp", "si", "spl", "span", "asp", "sg", "isp", "osp", "Sp", "sam", "sb", "spe", "sv", "jp", "sk", "sf", "pp"], "e": ["ev", "x", "n", "it", "a", "fe", "ie", "f", "p", "re", "ed", "er", "t", "el", "ee", "v", "E", " ev", "name", "d", "w", "event", "pe", "m", "i", "s"], "fo": ["obo", "bo", "eno", "FO", "oos", "lo", "ato", "so", "folio", "xf", "tto", "o", "fif", "io", "ico", "ki", "flo", "uo", "uf", "oe", "wt", "wi", "ti", "opa", "aco", "olf", "tif", "hea", "wo", "po", "zo", "ro", "mo", "co", "ooo", "cf", "tf", "fa"], "oo": ["obo", "bo", "oooooooo", "ollo", "ano", "oos", "lo", "yo", "elo", "ato", "so", "folio", "aha", "ta", "o", "ico", "ilo", "flo", "uo", "ox", "cro", "ero", "OO", "oco", "oe", "oa", "opa", "oto", "olo", "ora", "ao", "aco", "ola", "goo", "oooo", "wo", "po", "zo", "ro", "mo", "co", "ko", "oes", "foo", "oid", "ooo"], "ex": ["de", "rex", "lex", "tex", "or", "es", "x", "px", "wx", "exc", "cre", "te", "des", "pex", "ext", "ic", "example", "nex", "su", "ry", "except", "xe", "re", "Exc", "el", "ac", "ox", "sex", "hex", "iox", "aux", "six", "external", "none", "ax", "EX", "err", "event", "Ex", "def", "ctx", "status", "tx", "log", " exc", "ception", "spe", "pers", "act", "com", "exe", "ix"]}}
{"id1": "21363911", "id2": "17627195", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "label": 0, "substitutes": {"testTransactions": [" testtransacts", " testtransitions", " testtransactions", " testTransitions", " testTransaction", "testTaction", " testtransaction", "testTransaction", "testTactions", "testTacts", "testTransitions", "testtransitions", "testtransacts", "testtransaction", "testtransactions", "testTransacts", "testTitions", " testTransacts"], "con": ["fn", "bo", "ln", "config", "ic", "connection", "ain", "rc", "re", "xc", "ac", "cp", "cons", "gc", "ctrl", "cf", "com", "dial", "cur", "ch", "nc", "on", "db", "sc", "bn", "util", "enc", "cv", "sur", "pl", "conv", "win", "cm", "don", "go", "bc", "un", "conn", "ran", "po", "co", "res", "conf", "ren", "mc", "rec", "ct", "can", "dn", "pen", "ens", "en", "client", "fc", "pc", "cache", "coll", "connect", "Con", "cal", "open", "gate", "console", "anc", "pt", "tc", "fl", "cont", "ctx", "CON", "cn", "cc", "act", "c", "gen"], "st": ["ist", "bo", "ust", "const", "est", "nd", "step", "sl", "ln", "it", "tt", "ST", "so", "irst", "statement", "put", "ct", "stra", "et", "ut", "St", "sc", "stan", "h", "sw", "ost", "mt", "std", "t", "fr", "pt", "bt", " superst", "th", "ft", "stre", "nt", "cr", "ast", "wt", "sol", "must", "ld", "rt", "sts", "str", "stop", "l", "sth", "obj", "sta", "sn", "stage", "ste", "cl", "sty", "stat", "sb", "sp", "co", "inst", "s", "art", "start", "ts", "rest"], "rs": ["ims", "rets", "ri", "ows", "bs", "ss", "ds", "rc", "ires", "its", "re", "rys", "ats", "dds", "Rs", "rl", "arms", "r", "vs", "ws", "rows", "qs", "hs", "cs", "ks", "rates", "mr", "pres", "res", "aps", "rings", "cases", "ls", "abs", "rss", "rx", "gs", "ars", "rd", "ins", "rus", "ags", "ress", "pc", "rr", "ges", "els", "ts", "ras", "RS", "dr", "ms", "ris", "sys", "times", "arts", "stats", "ues", "rel", "hr", "ys", "xs", "rm", "ics", "ps", "rots", "js", "ns", "rt", "ubs", "sts", "vr", "acks", "sr", "ems", "vers", "icks", "ros", "s", "irms", "usr"]}}
{"id1": "11477906", "id2": "9805906", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadFAULTSetting", "loaddefaultsettings", "readdefaultSetting", "loaddefaultSettings", "readdefaultSettings", "loaddefaultSetting", "loadFAULTSettings", "readDefaultValues", "readDefaultSettings", "loadDefaultSetting", "readdefaultsettings", "loadFAULTsettings", "readDefaultSetting", "loadDefaultsettings", "readDefaultsettings", "loadDefaultValues", "readdefaultValues", "loaddefaultValues", "loadFAULTValues"], "configFileName": ["configfilePath", "configPagePath", "configFilenamename", "confFileLocation", "configFilenameLocation", "configFILEName", "configFILELocation", "conffileName", "configFILEname", "confFilePath", "configFilenameName", "configFileNames", "configStreamName", "conffilePath", "configFilename", "confFilenameLocation", "configStreamname", "configfileName", "configfilename", "conffileNames", "configFilenameNames", "configfileNames", "confFilenameName", "confFileNames", "configFILEPath", "configFilenamePath", "configFileLocation", "confFilename", "configStreamLocation", "configPagename", "conffilename", "configPageNames", "confFilenamename", "confFilenamePath", "configFilePath", "configPageName", "confFileName", "configStreamPath"], "in": ["IN", "on", "din", "con", "gin", "ls", "or", "im", "init", "n", "it", "user", "ini", "rin", "is", "mc", "ai", "ze", "ain", "id", "o", "en", "from", "mi", "re", "ind", "al", "ins", "t", "ar", "ma", "up", "bin", "run", "e", "inner", "doc", "isin", "l", "In", "check", "input", "source", "m", "i", "ro", "info", " din", "inn", "inf", "ad", "cin"], "out": ["ion", "it", "not", "aos", "to", "ind", "t", "at", "gc", "OUT", "port", "file", "con", "or", "init", "auto", "une", "ent", "des", "o", "ex", "outs", "conv", "ou", "writer", "w", "obj", "net", "po", "oss", "co", "off", "res", "handle", "are", "output", "n", "can", "os", "en", "OU", "ins", "client", "up", "server", "nt", "null", "check", "copy", "m", "cache", "ge", "update", "over", "Out", "user", "sys", "raw", "read", "io", "v", "ing", "all", "store", "gt", "ne", "cn", "log", "ot", "de"]}}
{"id1": "12085127", "id2": "5723876", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"navigate": ["Naviate", "configure", "generiate", "configigation", "Navate", "navure", "naviate", "avure", "avigate", "Navigate", "generigate", "avigation", "configigate", "navinate", "generigation", "Navinate", "aviate", "avinate", "navigation", "avate", "Navure", "Navigation", "configate", "generinate", "navate"], "url": ["path", "http", "html", "ls", "location", "term", "sl", "org", "ret", "build", "link", "ur", "b", "Url", "f", "address", "ul", "URL", "util", "pl", "ssl", "uri", "dl", "nl", "loc", "email", "gl", "ref", "this", "key", "null", "req", "str", "mount", "xml", "name", "ll", "external", "l", "char", "page", "www", "conn", "rect", "base", "string", "file", "domain", "log", "job", "web", "document", "cert", "host", "il"], "connection": ["nc", "message", "application", "connect", "pointer", "cone", "Connection", "con", "ion", "description", "session", "open", "database", "generation", "response", "controller", "condition", "statement", "socket", "sql", "console", "character", "relation", "channel", "client", "resource", "created", "communication", "still", "opening", "position", "established", "connected", "net", "directory", "conn", "command", "entry", "set", "city", "network"], "is": ["ims", "mis", "ais", "im", "isc", "ms", "tis", "iso", "ris", "dis", "ois", "ic", "ri", "isl", "nis", "bis", "bs", "isa", "as", "its", "iss", "os", "are", "ins", "rs", "si", "stream", "Is", "fs", "iris", "ism", "us", "isi", "i", "oss", "ios", "s", "sis", "in", "ip", "lis", "IS"]}}
{"id1": "442381", "id2": "17580775", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionsCheck", " doVersionsCheck", " doVersionscheck", " doApplicationInfo", "doFeatureUpdate", "doVersionscheck", "doImageCheck", "doApplicationInfo", "doVersionsUpdate", "doBuildUpdate", "doBuildcheck", " doApplicationQuery", "doVersionUpdate", "doImageTest", "doFeaturecheck", " doVersionUpdate", "doFeatureCheck", "doImageInfo", "doVersionTest", "doApplicationQuery", "doImageQuery", " doVersionTest", " doVersionsTest", "doFeatureInfo", "doVersionQuery", " doVersionQuery", " doVersioncheck", " doApplicationCheck", "doFeatureQuery", "doBuildCheck", " doVersionsUpdate", "doVersioncheck", "doBuildTest", "doFeatureTest", "doApplicationTest", "doVersionsTest", "doVersionInfo", " doApplicationTest", "doApplicationCheck", " doVersionInfo"], "view": ["buffer", "http", "self", "update", "html", "window", "model", "block", "cell", "iew", "vm", "controller", "manager", "see", "review", "ml", "q", "pool", "h", "row", "cv", "views", "subject", "VIEW", "client", "server", "v", "lock", "browser", "component", "call", "this", "tree", "box", "version", "index", "engine", "virtual", "page", "form", "eye", "print", "project", "check", "input", "View", "tv", "file", "port", "show", "document", "query", "display", "context", "layout", "widget", "image", "report"], "url": ["http", "mail", "html", "sl", "build", "bel", "link", "ur", "lb", "Url", "f", "address", "ul", "b", "URL", "rel", "pl", "ssl", "uri", "dl", "loc", "nl", "client", "v", "browser", "gl", "ref", "str", "mount", "ll", "get", "l", "char", "rl", "file", "log", "domain", "job", "oul", "r", "host", "hl"], "in": ["IN", "on", "din", "gin", " IN", "asin", "init", "ln", "n", "rin", "is", "vin", "sin", "f", "body", "ain", "can", "inc", "from", "ins", "inner", "reader", "stream", "isin", "l", "In", "input", "source", "i", "mn", " din", "info", "inn", "out", "mat", "inf", "cin"], "bin": ["buffer", "cos", "binary", "db", "session", "din", "gin", "con", "by", "init", "ln", "nb", "abin", "spin", "bed", "rin", "sin", "b", " Bin", "body", "bn", "local", "bl", "re", "ebin", "conv", "ins", "win", "bur", "buff", "len", "bg", "all", "inner", "bi", "mon", "jin", "reader", "cb", "stock", "lib", " bins", "obin", "brain", "file", "ran", "sam", " din", "inn", "out", "thin", "rb", "cache", "cin"], "line": ["field", "message", "style", "part", "cell", "lin", "block", "ln", "section", "tile", "lo", "eline", "link", "detail", "zone", "lane", "cat", "row", "sample", "frame", "stay", "lines", "channel", "liner", " block", "le", "code", "inline", "key", "ine", "rule", "next", "LINE", "ice", "stream", "l", "char", "page", "sequence", "err", "record", "entry", "string", "base", "point", "print", "status", "iter", "port", "file", "log", "job", "parse", "comment", "range", "chain", "trace", "cmd", "column", "word", "Line"], "develBuild": ["devBuilder", "devBuild", "duvelBuilt", "deployBuilder", "deVELBoot", "depoBuild", "deVELBuilder", "deeltaLoad", "DeVELBuilt", "deployLoad", "deploybuild", "develLoad", "develbuild", "deeltabuild", "develBuilt", "deVELBuild", "DeVELBuild", "DevelBuild", "DeVELbuild", "depoBuilt", "duVELbuild", "desvelbuild", "duVELBoot", "desVELLoad", "develLog", "deVELRelease", "duvelBoot", "desVELBuild", "deeltaBuild", "deployBoot", "deVELLog", "deeltaRelease", "DevelBuilt", "devBuilt", "DevelLog", "duvelBuild", "DeVELLog", "desvelLoad", "deffbuild", "deffBuild", "devBoot", "deployRelease", "desvelBuild", "deployBuilt", "develRelease", "duffBuilder", "deVELBuilt", "duvelBuilder", "deVELbuild", "depobuild", "develBuilder", "duvelbuild", "duVELBuilder", "duVELBuild", "desvelRelease", "desVELbuild", "deVELLoad", "develBoot", "deployBuild", "duffBuilt", "depoLog", "devbuild", "deffBuilder", "Develbuild", "duffbuild", "deffBuilt", "desVELRelease", "duffBuild", "devLog"], "stableBuild": ["devBuilder", "devBuild", " unstablebuild", "confirmedBuild", "confirmedBoot", " stablebuild", "confirmedbuild", "activeBuilder", "activeBuild", "stableMake", "stableLong", " unstableBuild", "stableBoot", "stablebuild", "secureBuild", " unstableBuilder", " stableBoot", " unstableLong", " unstableBind", "stableBuilder", " stableLong", "stableBind", " stableBind", " unstableBoot", "secureCraft", " stableCraft", "activebuild", " stableBuilder", "devBind", " stableMake", " unstableCraft", "devMake", "devbuild", "confirmedLong", "stableCraft", "activeMake", "securebuild", "secureBuilder"]}}
{"id1": "14567939", "id2": "3046085", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "label": 1, "substitutes": {"baseHash": [" basehash", " baseKey", "basicSign", "basichash", "basicKey", " baseSign", "BaseKey", "baseKey", "basehash", "Basehash", "basicHash", "BaseHash", "baseSign", "BaseSign"], "name": ["ident", "prefix", "term", "n", "user", "author", "account", "title", "person", "address", "id", "common", "local", "create", "default", "login", "initial", "current", "NAME", "john", "parent", "ame", "run", "key", "username", "family", "named", "hash", "table", "Name", "domain", "names", "admin", "search", "info", "alias", "word", "order"], "password": ["message", "session", "description", "prefix", "restricted", "phrase", "hello", "user", "database", "attribute", "secret", "picture", "token", "wd", "reset", "auth", "Password", "login", "pass", "key", "sword", "shadow", "username", "crypt", "command", "entry", "hash", "padding", "value", "remember", "word"], "digest": [" digend", "displayester", "Digse", "diger", "Digester", "displayEST", "displayest", "Digest", "digested", "descgest", " digested", "Digend", "mdester", "displayested", "Diger", " Digest", "descse", "decest", "digum", "Digum", "decgest", "decested", "displayum", " Digester", "descested", "descester", "DigEST", "descest", "mdested", "mdEST", "digend", " Diger", "digse", "Digested", "digEST", "diggest", "dest", "decester", " diger", " digum", "digester", "dgest", "mdgest", "dested", "mdest", " digester", "dEST", "mdse", "Diggest", " Digend"]}}
{"id1": "189963", "id2": "21316706", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "7468819", "id2": "1005107", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["runner", "task", "block", "hello", "runs", "loop", "Run", "invoke", " Run", "execute", "test", "call", "running", "process", "poll", "unit", "thread", "go", "submit", "wait", "launch", "profile", "func", "work", "start", "begin", "exec"], "con": ["ch", "nc", "mos", "cos", "const", "Con", "cone", "connect", "ln", "cal", "open", "sin", "connection", "ct", "acon", "ain", "can", "rc", "pen", "en", "create", "re", "conv", "client", "win", "fin", "xc", "bur", "fc", "cm", "syn", "canon", "cp", "cons", "comm", "don", "pc", "un", "conn", "cont", "gc", "conf", "cl", "cn", "CON", "clean", "cc", "ran", "ctrl", "construct", "co", "url", "cf", "act", "com", "cmd", "res", "dial", "Conn", "c", "cur"], "encodedPassword": ["encodingData", "decodedpassword", "encressedPassword", "encachedUser", "decachedPassword", "decodedResponse", "enccodedPassword", "encachedPassword", "encachedpassword", "encressedUser", "decodingpassword", "encressedResponse", "decodingPassword", "encuredpassword", "encodedResponse", "decachedResponse", "encryptedPass", "decachedUser", "encryptedData", "encodedUser", "encryptedpassword", "encressedpassword", "decodedUser", "encuredUser", "decodedPassword", "encodedData", "encodingPass", "encuredResponse", "decodedData", "encodingPassword", "encuredPassword", "enccodedpassword", "decodingData", "decachedpassword", "encachedResponse", "decodedPass", "encodedPass", "encryptedPassword", "decodingPass", "enccodedPass", "encodingpassword", "encodedpassword", "enccodedData"], "encoder": ["ecoder", " encoding", "decoding", "decoser", " encoser", "encoding", "encater", "enoding", "decoded", "encoded", "Encoser", "encODE", "enoder", "ecoding", "decoder", "ecODE", "decODE", "enoded", "Encoder", "Encater", " encater", "encoser", "ecoded", "enODE", "decater", "Encoding"], "is": ["ist", "ists", "im", "ais", "ms", "isc", "es", "asin", "se", "ris", "it", "iso", "ai", "ri", "ic", "sys", "isl", "nis", "bs", "isa", "as", "its", "iss", "os", "ys", "are", "ins", "rs", "il", "isf", "ib", "si", "Is", "isin", "ir", "fs", "sit", "iris", "isi", "i", "ios", "s", "sis", "in", "was", "lis", "IS"], "rd": ["dr", "rh", "din", "nd", "rar", "ri", "erd", "nder", "bd", "rod", "rx", "rid", "cd", "rc", "hr", "ind", "red", "fr", "rg", "rand", "rs", "rw", "cr", "rt", "ld", "reader", "dd", "d", "mr", "rr", "rect", "sr", "ra", "rob", "rl", "rn", "RD", "xd", "r", "ren", "ru", "rb"], "line": ["message", "cell", "lin", "block", "phrase", "se", "ln", "lo", "header", "eline", "link", "detail", "lane", "row", " LINE", "sample", "frame", "re", "nl", "liner", "le", "code", "inline", "ine", "name", "label", "LINE", "ice", "l", "page", "sequence", "record", "base", "entry", "command", "point", "string", "print", "stroke", "log", "file", "comment", "chain", "column", "word", "Line"], "response": ["output", "collection", "buffer", "message", "application", "json", "description", "model", "template", "database", "detail", "onse", "connection", "sheet", "console", "reset", "relation", "frame", "answer", "pos", "resp", "server", "continue", "relative", "summary", "library", "request", "tree", "this", "next", "xml", "view", "service", "position", "respons", "vector", "Response", "sequence", "page", "command", "print", "table", "value", "reply", "csv", "results", "document", "data", "display", "memory", "format", "trace", "res", "array", "image", "report", "list", "network"], "lastIteraction": ["lastIterate", "lastInterations", " lastIterate", " lastRelations", " lastIterated", " lastInterate", " lastiterations", "lastIteration", "lastInterate", " lastiterate", " lastIterations", " lastInterations", " lastRelate", "lastIterations", " lastRelated", " lastiteration", " lastRelation", " lastInteration", "lastInteration", " lastInterated", "lastIterated", " lastIteration", " lastiterated", "lastInterated"], "result": ["buffer", "message", "out", "reason", "json", "ret", "answer", "current", "content", "request", "str", "page", "err", "string", "status", "value", "results", "query", "data", "success", "url", "res", "r", "report", "cache", "Result"], "e": ["ev", "eu", "es", "or", "x", "se", "n", "exc", "ent", "te", "a", "ie", "ze", "ep", "b", "me", "f", "p", "eg", "o", "h", "xe", "eeee", "en", "re", "note", "ex", "er", "t", "ee", "v", "E", "le", "oe", "g", "ine", "be", "error", "ec", "d", "ue", "l", "ae", "u", "err", "pe", "ei", "ne", "m", "i", "s", "r", "c", "ate"]}}
{"id1": "11968328", "id2": "15500892", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": [" getMDState", " calculateMD2", " getMT2", " calculateMD5", " getMD1", " getMD2", " calculatemd1", " getmdState", " getmd1", " getmd2", " getHash5", " getHashState", " getMT1", " calculatemd2", " calculateMDState", " getMT5", " getmd5", " getMTState", " calculateMD1", " calculatemdState", " calculatemd5", " getHash2", " getHash1"], "_pwd": ["_wppriv", "_passwd", "_passfx", " _pw", "_vpwd", "_spfx", " _sppriv", " _passwd", "_cw", "_pwords", " _passwords", "_vppriv", "_spwd", "_cfx", " _ppriv", "_spwords", "_pword", "_wpwd", "_passw", " _spword", "_pw", " _passfx", " _spw", "_passwords", " _pwords", "_spw", " _pword", "_pfx", "_spword", "_ppriv", "_wpword", " _spwd", "_sppriv", "_vpword", "_cwords", " _pfx", "_vpw", "_cwd", " _passw", "_wpw"], "md": ["bf", "db", "pm", "mail", "ms", "add", "nd", "sd", "msg", "mc", "tmp", "od", "bd", "and", "del", "MD", "der", "cd", "mg", "h", "dir", "mm", "dm", "mt", "ind", "down", "red", "rm", "sm", "dh", "det", "ld", "mb", "d", "dd", " Md", "mp", "mk", "mod", "dig", "pd", "m", "df", "mn", "mand", "cmd", "man", "hd", "ng", "de"]}}
{"id1": "8064604", "id2": "14758866", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"init": ["load", "connect", "update", "bind", "it", "config", "open", "Init", "prep", " Init", "reset", "create", "register", "auth", "use", "hook", "login", "initial", "setup", "dump", "get", "set", "construct", "start", "dial"], "mgr": ["lnd", " mmg", "mdr", "rmGr", "rmnd", "lgr", "cdr", " mnd", "Mgr", "MGr", "mGr", "lGr", "lmg", "cgr", "Mmg", " mdr", "mnd", " mGr", "mmg", "rmgr", "cmg", "Mdr", "rmmg", "cGr"], "cfg": [" msg", "db", " cs", "config", " cp", "ct", " sane", " cf", " md", " df", "Config", "map", " sched", " sp", " conf", " cz", "Conf", "g", " config", "ctr", "cb", " mc", "keys", " sch", " caps", " setup", "cf", "conf", " cc"], "sock": ["spock", "jsock", "slip", "sink", "snip", "spocks", "spox", " sox", "sip", "svc", " svc", "sox", "snock", " socks", "jsocks", "spink", "snvc", " sip", "jsox", "snow", " sink", "sow", " sow", "slvc", "jsink", "slock", "socks", "slow"], "_cman": ["_dgr", "_mman", " _cgr", "_dml", " _cml", " _dml", "_cml", "_cctr", "_dctr", "_rctr", "_rman", "_mctr", " _dctr", " _dgr", "_mml", "_rgr", " _cctr", "_dman", "_cgr", "_mgr", "_rml", " _dman"], "_sock": ["_Socked", "_tock", "_csocked", "_nsq", "_tocks", " _ssocked", "_rsock", "_sice", "_Sck", "_rsocket", "_svq", "_sck", " _sek", " _rsock", "_sourceockey", "_csocket", "_sourceock", "_Src", "_dsrc", "_sq", "_socket", "_csck", " _rsck", "_Socks", " _sck", " _ssek", "_ssocked", "_socks", " _rsocket", "_Sock", " _socked", "_lsq", "_trc", "_soc", "_sockey", "_dsock", "_spockey", "_tck", "_svoc", "_rsocked", "_dsck", "_lsock", "_sourceocked", "_sek", "_rsck", " _rsocked", " _socket", " _ssockey", "_ssockey", "_nsock", " _sockey", "_socked", "_csock", "_spocked", "_lsoc", "_spek", "_nsoc", "_lsice", "_ssek", "_spock", " _ssock", "_nsice", "_sourceek", "_dsocks", "_svock", "_ssock", "_svice", "_Socket", "_src"], "i": ["it", "ic", "iu", "qi", "t", "gi", "err", "set", "iy", "cli", "li", "j", "my", "ini", "is", "ui", "f", "q", "sql", "o", " I", "ex", "e", "this", "hi", "g", "ti", "bi", "name", "l", "k", "print", "batch", "us", "ami", "chain", "sim", "ip", "\u0438", "multi", "im", "counter", "ity", "n", "ie", "loop", "me", "id", "ci", "ii", "client", "index", "mac", "u", "m", "xi", "pi", "x", "phi", "ai", "p", "y", "integer", "io", "mi", "gu", "ki", "v", "si", "I", "di", "info", "in", "c", "ix"], "key": ["ch", "path", "json", "Key", "prefix", "by", "x", "phrase", "cy", "n", "my", "ie", "item", "title", "et", "q", "p", "y", "row", "col", "test", "ke", "ex", "client", "KEY", "lock", "parent", "pair", "code", "this", "str", "name", "index", "cp", "mac", "char", "sum", "k", "mk", "print", "command", "entry", "string", "tip", "def", "air", "primary", "check", "value", "chain", "cert", "foo", "important", "ip", "conf", "cmd", "word", "list"], "_sout": [" _svamp", "_ssamp", "_wsout", "_svout", "_svco", "_svamp", "_sres", " _svout", "_wsamp", "_wsco", "_ssres", "_svres", "_wsres", " _svco", "_samp", " _svres", " _sco", " _samp", "_ssout", "_ssco", "_sco", " _sres"], "_sinp": ["_senP", "_cinm", " _sinh", " _cinP", "_binm", "_senp", "_senh", "_sinP", "_cinh", "_sinh", "_cinP", "_cinp", "_senm", " _cinm", "_binP", " _sinm", "_binp", "_binh", "_sinm", " _cinh", " _sinP", " _cinp"], "seed": ["ser", "db", "offset", "node", "password", "prime", "prefix", "sl", "se", "dev", "then", "now", "shift", "draw", "tmp", "feed", "secret", "socket", "id", "token", "sample", "row", "test", "sel", "slot", "sudo", "server", "pse", "eed", "Salt", "stable", "store", "index", "dd", "serial", "shadow", "uid", "sum", "sequence", "delay", "sn", "entry", "source", "finger", "iter", "set", "sid", "sp", "random", "insert", "mix", " seeded", "temp", "sett", "zip"], "rand": ["bot", "dr", "spr", "reg", "nd", "kick", "by", "add", "ng", "dev", "user", "draw", "sys", "normal", "and", "rx", "rev", "rc", "inv", "rad", "rd", "red", "pos", "radius", "rt", "rot", "mr", "round", "mk", "max", "z", "ro", "range", "random", "res", "r", "rest", "gen", "Rand"], "hex": ["ch", "alpha", "lit", "json", "html", "rex", "tex", "password", "term", "x", "prefix", "rh", "hello", "des", "pex", "raw", "wh", "prop", "h", "hook", "ex", " Hex", "buff", "kw", "hp", "length", "sex", "str", "sh", "hl", "index", "he", "serial", "mac", "bytes", "none", "char", "tr", "cas", "form", "print", "mem", "string", "def", "iter", "tx", "ph", "oct", "exp", "cert", "full", "random", "cf", "com", "mix", "hw", "temp", "color", "zip"], "pass": ["path", "strip", "out", "task", "password", "step", "add", "prefix", "phrase", "access", "rep", "val", "ret", "press", "gate", "secret", "send", "p", "wd", "read", "reset", "test", "pas", "allow", "pos", "ps", "pair", "fail", "PASS", "Pass", "pack", "name", "process", "ask", "str", "alt", "ress", "ack", "sum", "print", "conf", "def", "parse", "ass", "pillar", "res", "handle", "push", "act", "word", "pp", "gen"], "md5": ["dig45", " Md2", "hash3", " md2", " md64", "MD3", "hash5", " md45", " md_", "md45", "md64", "MD_", "dig4", "dig_", "dig3", " Md5", "hash23", "MD2", "hash2", "md23", "md4", "MD4", " MD3", " md3", " md4", " md23", "MD64", "md2", "MD45", "MD23", " MD64", " MD2", " MD5", "md_", "MD5", "dig5", " Md4", "md3"], "hash": ["style", "rh", "html", "password", "bolt", "host", "addr", "Hash", "hz", "hat", "header", "type", "title", "sha", "id", "token", "ssh", "h", "alph", "test", "buster", "total", "browser", "name", "flash", "version", "mac", "sum", "crypt", "print", "cert", "search", "data", "height", "random", "handle", "her", "temp", "ash"], "banner": ["scaninner", " baninner", " baner", "banker", "buginner", "broadnel", "bugker", "baninner", "bannel", "binker", "raininner", "broadline", "banter", "broadinner", "scanter", "binter", "binner", "baner", "bugner", "rainner", " bannel", "rainer", "Banler", " banler", "banline", "bininner", " banline", "scannel", "Banner", "banler", "scanline", "broadner", "rainler", "Baner", "Baninner", "scanner", "bugter", "scanker"], "txt": ["fn", "priv", "btn", "text", "qt", "json", "html", "plain", "words", "TEXT", "ret", "msg", "ext", "tmp", "notes", "ct", "tp", "mint", "tm", "xt", "lt", "nm", "tk", "dat", "htm", "kt", "writers", "ws", "Text", "tin", "t", "XT", "typ", "buff", "js", "nt", "wt", "ns", "rt", "str", "xml", "obj", "tif", "tn", "cont", "print", "tch", "sit", "details", "def", "tx", "tg", "data", "res", "out", "utt"], "sname": [" sName", "ssname", "spadmin", "lsnam", "ssnam", "lsadmin", "ssName", "ssame", "spnam", " same", "sName", "spname", "snam", "lsname", "ssadmin", "sadmin", "lsame", "spame", "same", " snam"], "spass": [" spwd", "psass", " spASS", "sposs", "osposs", " spred", "spred", " sposs", "spack", "ospss", "pswd", " spack", "psss", "ospack", "SPoss", "SPack", "SPass", "ospASS", "ospass", "spss", " spss", "psred", "SPASS", "spwd", "ospwd", "spASS", "ospred"], "sseed": ["tsiter", "wsentry", " sser", "tsser", "pspass", "Seed", "tsseed", "sentry", "ssel", "psentry", " siter", "Srandom", "Ssecret", "Sseed", "ssiter", "ssser", "ssecret", "wsseed", "siter", "ssseed", "tseed", "pssel", "wspass", "psecret", "prandom", "psseed", "sser", "wssel", "peed", "srandom", "pseed"], "items": ["ims", "faces", "cases", "links", "ms", "abs", "mods", "ops", "types", "orders", "item", "times", "lets", "arts", "images", "stats", "ues", "its", "rows", "qs", "ars", "pages", "airs", "Items", "boxes", "xs", "amps", "ins", "lines", "files", "ics", "rs", "cats", "styles", "actions", "ids", "aux", "terms", "ips", "ites", "keys", "values", "stuff", "EMS", "details", "phones", "flows", "results", "arms", "els", "groups", "blocks", "objects"]}}
{"id1": "8328527", "id2": "4830847", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 1, "substitutes": {"insertJobLog": ["insertJlog", " insertJobHistory", "insertChecklog", " insertJHistory", "insertLogHistory", "insertJHistory", "insertJobConfig", "insertLoglog", " insertJConfig", "insertLogConfig", "insertJoblog", "insertJConfig", "insertCheckLog", "insertJLog", "insertJobHistory", " insertJobConfig", " insertJoblog", " insertJlog", "insertCheckConfig", "insertCheckHistory", " insertJLog", "insertLogLog"], "userId": ["authorPart", "usernameDir", "UserID", "userIn", "UserPart", "usersIn", "UserById", "usaDir", "usaId", "usernameDef", "usernameById", "UserName", "userID", "usaDef", " userName", "usernameId", "userDir", "usersName", "checkID", "userName", " userIn", "usaById", " userDef", "checkName", "authorID", "userDef", "userPart", " userById", "checkPart", "userById", "UserIn", "UserId", " userDir", "authorId", "usersById", "authorName", "usersId"], "checkId": ["workInt", "testId", "workID", "workById", "cleanid", "workInfo", "objById", "testById", "CheckID", "CheckInfo", "checkInfo", "cleanInt", "testInfo", "cleanId", "objID", "ckInfo", "checkid", " checkIdent", " checkById", "ckId", "CheckId", "testID", " checkInt", " checkid", "cleanIdent", " checkInfo", "checkById", "checkIdent", "checkID", "CheckById", "ckID", "checkInt", "Checkid", "objInfo", "objId", "workId", "workid", "workIdent", "ckById", " checkID"], "checkType": ["defTYPE", "defType", "okType", "CheckKey", "CheckID", "testType", "checkInfo", "checkTYPE", "defInfo", "checkKind", "ckInfo", "checkedTYPE", "okKey", "testTYPE", "ckTYPE", "checkTypes", " checkTypes", "CheckId", "testID", "okId", "ckType", " checkInfo", "checkedID", "CheckType", "checkedKind", "checkID", "okID", "ckID", " checkKey", "testKind", "checkKey", "checkedType", " checkTYPE", "ckKind", "defTypes", "ckTypes", " checkID"], "objType": ["objTYPE", "bjTheme", "rtType", "rtTypes", "cmdTy", " objName", "objTheme", "bjTy", "objVersion", " objVersion", "checkTYPE", " objTypes", "objTy", "checkTypes", "cmdTYPE", "rtStyle", "ObjVersion", "ObjType", "tmpTYPE", "rtTYPE", "cbVersion", " objStyle", "tmpType", "ObjName", "cbName", "ObjTYPE", "cmdType", "bjType", "tmpTy", "bjTYPE", "objTypes", "objStyle", "checkStyle", "cbType", "cmdTheme", "cbTYPE", "tmpTheme", " objTYPE", "objName"], "dbo": ["doBo", "dbc", "rdBo", "dbf", "rdbc", "DBo", "Dpo", "dobo", "dtBO", "Dbu", "DBO", "dobf", "rdbo", "doBO", "dBo", "pBO", "dtbo", " dBo", " dbu", "rdbu", "pbo", "dBO", "pBo", "ppo", " dbc", "rdBO", "Dbo", " dBO", "dtBo", "dbu", "rdpo", "dpo", "Dbc", " dbf", "dtbf", " dpo"], "connection": ["output", "bo", "collection", "management", "application", "connect", "session", "cone", "Connection", "con", "pointer", "ion", "function", "close", "db", "config", "instance", "open", "database", "generation", "response", "link", "condition", "statement", "manager", "reference", "socket", "usage", "pool", "pen", "relation", "creator", "associated", "subject", "t", "client", "resource", "current", "server", "library", "settings", "government", "communication", "writer", "operation", "engine", "handler", "position", "connected", "net", "directory", "conn", "command", "information", "table", "po", "document", "query", "context", "c", "computer", "network"], "preStm": ["priSTem", "preSTcm", " preStn", " prePutm", "presStpm", "preStrcm", "PreStrn", "preStrdm", "PreStn", "prePostem", "prestr", "Prestmi", "preWdm", "preTrm", "prestmt", "preWr", "prePutl", "preStrm", "preStpm", "presSTpm", "preSTm", "presttm", "Prestmt", "preSTpm", "preFormm", "preTrem", " preStM", "preShm", "priSTm", "prePutm", "preWm", "preStsm", "Prestm", " preTrm", "preEstsm", " preSTl", " prePutl", "preStrn", "preStmn", "preRestr", " prestn", " prePutr", "PreSttm", "preStrM", "preStdm", "preRestl", "prefixSTem", " prePutmn", "preFormmt", "preRestm", "preSTr", "prePutM", "preShmt", "prefixSTmt", "prePutr", "prePostam", " preStam", "preSTn", "prestem", "preSTmt", " prePutam", "prefixSTm", " preStr", "preStl", "preStam", " preSTm", "prestarm", "Presttm", "preTrM", "preStrr", "preFormn", "preWmt", "preTrmt", "priSTr", "presSTm", "prefixStarm", " preTrem", " prestr", "preStrmt", "PreStrdm", " preStl", "prefixSTarm", "prePutmn", "preSTsm", "presStm", "preSTmn", "preRestmt", "prestl", " preSTr", " prePutem", "prestpm", "PreStrmt", "prePostm", "presSTem", "prestsm", "PreStrm", "preSTem", "prePutem", "preStcm", "preShtm", "PreStmt", "preStarm", " preStmt", " prePutmt", "priSTcm", "preSTarm", "prestm", "priStm", "preEstm", "preStn", "preStM", "priStcm", "preEstpm", "prePutam", "PreStm", "prefixStem", "prefixStm", "presStem", " preTrM", " prestm", "preStem", "presStsm", "prePutarm", " prestmt", "preStr", " preStem", "preStmi", "preSTl", "preWn", "preEstem", " preTrmt", "prePostmn", "preStmt", "priStr", "prestmi", "preStrem", " preStmn", "priStem", "PreStdm", "preStrl", "PreStmi", "prePutmi", "presSTsm", "prePutmt", "preSttm", "preShmi", " preSTmt", "prestn", "prePuttm", "prefixStmt", "preFormdm", "preSTam"], "sql": ["fn", "san", "spr", "db", "json", "ls", "description", "template", "sd", "pkg", "sys", "seed", "q", "ql", "su", "SQL", "ssl", "dl", "nl", "spec", "setup", "js", "sol", "script", "xml", "ll", "quote", "conn", "sn", "string", "scl", "csv", "log", "sb", "sp", "query", "sv", "s", "eps", "sk", "cmd", "sq"], "cleanSql": ["cleanPq", "cleanSyq", "cleanStql", "removeSq", "cleanSQL", "cleanDSQL", "removeSql", "emptyStml", "cleanDSuff", "cleanAsql", "cleanSuff", "cleanStq", "cleanDSql", "emptyStql", "cleanStmt", "emptySml", "cleanSymt", "cleanInsql", "cleanSyql", "removePql", "emptyStmt", "cleanPuff", "cleanSml", "cleanAsq", "cleanAsmt", "removePQL", "cleanInsq", "removePuff", "cleanSq", "emptyStq", "cleanAsml", "emptySql", "cleanPQL", "cleanPql", "removeSQL", "cleanInsQL", "removePq", "cleanSyml", "cleanStml", "emptySq", "cleanDSq", "removeSuff", "cleanInsuff", "cleanSmt", "emptySmt"], "dCount": ["outRes", "dLimit", "outLimit", "dlRes", "udCount", "dlCount", "udRes", "udMax", "dlLimit", "udLimit", "outMax", "dMax", "dlMax", "dRes", "outCount"], "sHaveIns": [" sHaveINS", "SHadIns", "SHaveCons", "shaveIns", "sSeeIns", "sHaveCons", "sHavingins", "shaveINS", "sSaveCons", "sHadins", "sHaveINS", "sSaveins", "sSeeINS", "sHadIns", "sHasIns", "shaveins", "sHasINS", "sHadEx", "sHadEls", "SHaveins", "sHaveEls", "SHaveEls", "SHaveIns", "sSaveIns", " shaveIns", "sSaveEls", "sHasCons", " sHaveins", "sSeeins", " shaveins", "sHavingEx", "sHasins", "sHavingIns", " shaveINS", "SHadins", "sHaveins", "SHadCons", "sHasEx", "SHadEls", "sHadCons", "sHasEls", "sHaveEx"], "j": ["bot", "Ja", "json", "jl", "x", "by", "n", "it", "Journal", "msg", "jack", "b", "aj", "f", "jj", "q", "p", "y", "kj", "o", "att", "jit", "ind", "dj", "jen", "ja", "uj", "v", "js", "key", "ji", "g", "jc", "ju", "index", "_", "jump", "k", "batch", "bj", "Job", "m", "J", "job", "z", "i", "br", "exp", "ij", "off", "jp", "out", "oj", "jo", "left", "ix"]}}
{"id1": "15799935", "id2": "23585985", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "label": 0, "substitutes": {"saveAttachmentBody": ["saveAttachablePart", "saveAttentionPart", "saveAttachedFile", "saveAttachedbody", "saveExtachedPart", "saveAttentionBody", "saveAttachablebody", "saveExtachedBody", "saveAttachableFile", "saveAttachmentPart", "saveExtachmentbody", "saveExtachmentFile", "saveExtachmentBody", "saveAttachedBody", "saveExtachmentPart", "saveAttentionbody", "saveAttachableBody", "saveExtachedbody", "saveExtachedFile", "saveAttentionFile", "saveAttachmentFile", "saveAttachmentbody", "saveAttachedPart"], "context": ["message", "history", "application", "foundation", "host", "template", "config", "instance", "present", "support", "response", "connection", "comments", "state", "environment", "center", "ce", "frame", "subject", "client", "current", "parent", "content", "component", "translation", "request", "course", "null", "version", "background", "view", "contact", "container", "service", "command", "java", "ctx", "tx", "cc", "Context", "system", "stack", "document", "chain", "search", "media", "cf", "cache", "network"], "part": ["message", "session", "top", "task", "patch", "add", "block", "se", "instance", "type", "tmp", "piece", "and", "connection", "zone", "body", "p", "sample", "bound", "PART", "pod", "parent", "component", "pair", "name", "version", "post", "thread", "parts", "base", "partial", "trans", "tx", "file", "reply", "job", "join", "sp", "work", "Part", "data", "art", "start", "host", "word", "temp", "report"], "localAttachment": [" localDetignment", "localAppention", " localAssachment", "localDetail", " localAttachachment", " localAttachention", " localAttention", "localAssention", "localDetachment", "localAttment", "localDetached", "localAppached", "localDetignment", "localAttachail", "localAttail", "localAttachignment", " localAttachached", "localAssment", " localAssention", "localAttignment", "localAcachment", "localattention", "localAttachached", "localAssached", " localAssail", " localAttignment", " localDetail", " localAssached", "localAssachment", "localAcail", " localAttached", "localDetention", "localAcached", "localAttention", "localATTachment", "localAssail", "localATTment", "localAppachment", "localAssignment", "localAttached", "localAcignment", "localattachment", "localAppail", " localDetached", " localAttail", " localDetachment", "localAttachachment", "localattached", " localAttment", "localAttachention", " localAttachignment", "localATTention", "localATTignment"], "accountId": [" accountName", "containerID", "accountDb", "AccountById", " accountNum", " accountID", "amountInt", " accountDb", "objectID", "accountAnd", "containerId", "objectId", " accountAnd", "accountById", "accountNum", "accountS", "bankS", "containerNum", "bankID", "amountDb", "AccountID", "accountName", "accId", "objectName", "bankAnd", "accDb", "containerInt", "amountID", "accID", "accAnd", "objectById", "AccountName", "accInt", "accountInt", " accountById", "accNum", "accS", " accountInt", "bankId", " accountS", "amountId", "AccountId", "accountID"], "attachmentId": ["contachedId", "attachmentById", "Attociationid", "assignmentid", "attionId", "attachmentid", "attignmentId", "assignmentId", "attionid", "assignmentById", "contachmentId", "attociationid", "attignmentID", "contachmentid", "attionById", "attacheId", "AttachmentById", "attachmentID", "contachedById", "attacheid", "attmentid", "attmentById", "Attachmentid", "AttociationID", "attmentID", "assachmentid", "attociationId", "AttachmentID", "contachmentSerial", "attachedId", "attociationById", "assachmentID", "contachmentById", "attachmentSerial", "AttociationId", "AttociationById", "attociationID", "assachmentId", "attachedID", "attignmentid", "attachedSerial", "contachedSerial", "attacheID", "attionSerial", "contachedid", "attacheById", "AttachmentId", "attignmentById", "attmentId", "assachmentById", "assignmentID", "attociationSerial", "attachedid", "attachedById"], "in": ["ch", "IN", "on", "din", "per", "con", "gin", "init", "it", "rin", "ai", "is", "vin", "mc", "body", "raw", "as", "p", "id", "read", "en", "inc", "from", "mm", "ind", "ex", "ins", "al", "up", "bin", "all", "inner", "isin", "sum", "r", "l", "In", "conf", "input", "source", "m", "iter", "file", "i", "info", "inn", "act", "inside", "inf", "cin"], "saveIn": ["savePath", "savIn", "secureIns", " saveOut", "storeIn", "savAs", "saveIN", "getIn", " saveIN", " savePath", "getIN", "aveIn", "secureAs", "getOut", "savIns", "sendPath", "aveIns", "sendIn", "savIN", "saveOut", " saveIns", "secureIN", "sendOut", "secureIn", "aveOut", "getIns", "storePath", "aveIN", "saveIns", "sendIN", "storeOut", "storeIN"], "saveAs": ["saveAS", "SaveAs", "SaveIn", "aveAs", "SaveBy", "saveAn", "aveTo", " saveTo", "submitAs", "dumpAs", "saveBy", " saveAn", "aveIn", "submitas", "saveas", "dumpAn", " saveBy", "dumpTo", "submitBy", "submitAS", " saveAS", "saveTo", "SaveAS", "aveas", "Saveas", "submitIn", "aveAn", "aveAS"], "out": ["output", "cos", "con", "n", "auto", "Out", "it", "ent", "sys", "can", "o", "inv", "to", "os", "aos", "io", "OU", "ex", "outs", "t", "conv", "up", "v", "serv", "ou", "all", "null", "inner", "name", "ao", "one", "sum", "obj", "net", "gc", "OUT", "copy", "cn", "log", "oss", "i", "co", "res", "outer"], "copySize": ["CopyCount", "copyLength", "likeLength", "msgSize", "copySIZE", "likeCount", "copyPercent", "pushLength", "pushSize", "opyLength", "likeFontSize", "msgSIZE", "pushCount", "pushFontSize", "CopyLength", "CopyFontSize", "msgLength", "opySize", "opySIZE", "CopySize", " copyLength", "opyPercent", "CopyPercent", " copyCount", "CopySIZE", "copyFontSize", "copyCount", "likeSize", " copyFontSize", "msgPercent"], "contentUriString": ["contentUnistring", "contentUuriString", "contentUuriStr", "contentUnuriString", "contentUicstring", "contentIristring", "contentIiStr", "contentUnristring", "contentUicStatic", "contentUniString", "contentUriStatic", "contentUnriStr", "contentUnriString", "contentUnuriStr", "contentUrisString", "contentUiStatic", "contentUiStr", "contentUuriStatic", "contentUicStr", "contentUristring", "contentUriNumber", "contentUniStr", "contentUriStr", "contentIiString", "contentIriString", "contentIriStatic", "contentIriStr", "contentUistring", "contentUrisstring", "contentUnriNumber", "contentUniNumber", "contentUuriNumber", "contentIistring", "contentUuristring", "contentUicString", "contentUiString", "contentUnuristring", "contentIiStatic", "contentUrisStr", "contentUrisNumber", "contentUnuriNumber"], "mSize": ["moSize", "lLength", "lBytes", "mPos", "nBytes", "mBytes", "nSize", "nLength", "lSize", "lPos", "mLength", "moPos", "nPos", "moLength", "moBytes"], "mContentUri": ["mResourceIuid", "mContent_uid", "mContentIuid", "mResourceUris", "mContent_RI", "mResourceUuid", "mContent_ri", "mResourceIri", "mContentPRI", "mContentIri", "mResourceURI", "mContentIris", "mContentPri", "mContent_ris", "mContentUris", "mContentURI", "mContentUuid", "mResourceUri", "mContentIRI", "mResourceIris", "mResourceIRI", "mContentPris", "mContentPuid"], "cv": ["vp", "nc", "ev", "const", "cu", "vv", "vol", "buf", "vm", "um", "ct", "mult", "rc", "av", "CV", "desc", "conv", "lc", "xc", "v", "fc", "cm", "qu", "cmp", "GV", "box", "qv", "cod", "pb", "uv", "tc", "cb", "cp", "nv", "vr", "dc", "vt", "cont", "ov", "gc", "cn", "cap", "cc", "csv", "ctrl", "sv", "cf", "act", "vc", "lv", "cas", "c"], "uri": ["doi", "prefix", "term", "phi", "uni", "ri", "link", "ui", "handle", "ur", "address", "q", "picture", "id", "iri", "folder", "dir", "subject", "qi", "resource", " URI", "component", " ni", "uu", "du", "unit", "bid", "uid", "ue", "URI", "u", "result", "directory", "i", "range", "query", "url", "origin", "ip", " Uri", "report"]}}
{"id1": "6840241", "id2": "18748516", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["load", "close", "save", "replace", "sync", "cover", "link", "move", "transfer", "clip", "read", "size", "create", "cat", "slice", "map", "call", "delete", "write", "cop", "cp", "share", "gc", "print", "Copy", "system", "clone", "opy"], "source": ["style", "session", "site", "se", "template", "SOURCE", "ie", "shell", "body", "master", "ource", "sql", "state", "local", "sample", "ce", "size", "from", "subject", "ins", "resource", "pse", "Source", "scope", "spec", "wrapper", "parent", "src", "store", "inner", "reader", "si", "stream", "base", "sr", "input", "status", "iter", "select", "table", "sp", "info", "origin", "context", "start", "inside", "image", "cache"], "sink": ["sinker", "Sink", "asender", "asink", "slender", " sue", "Sinker", "slink", "ssink", "ssource", "Sender", " sinker", "Source", "asource", "ssender", " sender", "asinker", "sender", "Sue", "sue", "slue", "ssinker", "slource"]}}
{"id1": "14783950", "id2": "4468255", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compresswithFiles", "composeWithFiles", "compressWithzip", "composeWithoutFiles", "compressByzip", "compresswithZip", "compressByZip", "compressWithFiles", "compressWithoutzip", "compressByFiles", "composeWithZip", "composeWithoutZip", "compressByExt", "composeWithExt", "compressWithExt", "compressWithoutExt", "compresswithzip", "compressWithoutZip", "composeWithoutExt", "composeWithoutzip", "compresswithExt", "composeWithzip", "compressWithoutFiles"], "fileList": ["pagelist", "pageCode", "pageList", "fileIterator", "ilelist", " filelist", "pageLIST", "pageL", "ileL", "wordList", " fileSet", " fileL", "ileLIST", "itemList", "ileList", "fileNames", " fileIterator", " fileNames", "wordLIST", "fileSet", "resourceNames", "pageSet", "wordIterator", "tileList", "resourceList", "itemLock", " FileCode", " FileList", "tileSet", " FileSet", "itemNames", " fileLIST", " FileLIST", "wordSet", "tileLIST", "fileL", " fileCode", " fileLock", "fileCode", "resourceLock", "fileLock", "tileIterator", "fileLIST", "filelist"], "zipFileName": ["zipfilePath", "zipDirFilename", "zipFileNames", "zipFilenamename", " zipfileName", " zipFilePath", " zipfileNames", " zipFileFilename", "zipilename", "zFilePath", "zipilePath", " zipFileNames", " zipfilePath", "zipFilenameNames", "zipFileFilename", "zipileFilename", "zipFilenameFilename", "zipFilenamePath", "zipFilePath", "zipDirNames", "zFilenamename", "zipfileName", "zipDirName", "zFilenameFilename", " zipfileFilename", "zipfileNames", "zipileName", "zipfileFilename", "zipFilename", "zipDirPath", "zFilename", "zipfilename", "zFilenamePath", "zFileFilename", "zFilenameName", "zipFilenameName", "zFileName"], "fos": ["lfoos", " fOS", "lfOS", "Foss", "lfis", "woos", "fOS", " foos", "FOS", "loos", "lfos", "flis", "flos", "Fos", "flOS", "lOS", "los", "loss", "foos", "floos", "Foos", "foss", "woss", "wOS", "wos"], "zos": ["ossus", "sbm", "zen", "zi", "es", "hz", "zik", "jas", "ze", "zu", "iaz", "zin", "zan", "za", "ss", "ez", "hess", "rez", "zers", "os", "ses", "ws", "zon", "css", "zag", "zes", "ippers", "zzle", "ps", "rys", "webkit", "js", "enos", "less", "zh", "zb", "bes", "enz", "eros", "ess", "cz", "zer", "los", "zero", "iners", "z", "zo", "zar", "oss", "sis", "han", "Sax", "nz", "zip"], "iter": ["ser", "izer", "ator", "ger", "iver", "iner", "it", "valid", "user", "is", "Iter", "loop", "orient", "ver", "loader", "its", "iterator", "maker", "re", "er", "oper", "loc", "liter", "el", "ee", "train", "iv", "where", "inner", "ait", "reader", "inter", "coll", "ipper", "ptr", "tr", "ter", "Iterator", "ir", "vis", "ner", "former", "here", "gener", "fer", "i", "exp", "walker", "cer", "kit", "ip", "outer", "li", "list", "order"], "fileName": ["fNumber", "fileBody", " fileBody", "fieldNAME", "fileCurrent", "getname", "shortStore", "fname", "shortSource", "getStore", "fBody", "FileName", " fileSet", "fSource", "ileNumber", "ileSet", " fileStore", "localNAME", "ilename", "localname", "Filename", "ileSource", "fileString", "fNames", "ileList", " fileCurrent", "ileNAME", "FilePath", "fileNames", "tableName", " fileNames", "fileStore", "filename", "ileCurrent", "fileSet", "tablePath", "fName", "ilePath", " filename", "fieldList", "filePath", "shortname", "localName", " filePath", "FileString", "tableSet", "getName", "fieldName", "localList", "fileNumber", "fieldname", "fString", "ileString", " fileSource", "getSource", "ileName", "FileCurrent", "ileBody", "fileSource", " fileString", "FileNames", "fileNAME", " fileNumber"], "ind": ["cand", "mind", "wind", "ded", "nd", "cond", "j", "n", "bind", "ent", "draw", "sign", "seed", "roll", "count", "Ind", "cd", "inc", "num", "kind", "pl", "att", "red", "dj", "pos", "loc", "hend", "typ", "stick", "butt", "pred", "IND", "ld", "inder", "req", "cod", "index", "d", "ptr", "td", "md", "mod", "i", "find", "inn", "div", "med", "dial"], "shortName": [" shortString", "recentname", "shortFilename", " shortType", "fullString", "shortString", "fullType", "fullName", "ShortString", "smallName", "shortType", "fullname", "quickKey", "shortCode", " shortname", "Shortname", "smallname", "shortKey", "ShortFilename", "ShortKey", "smallCode", "quickString", "shortname", "quickName", "smallFilename", "ShortCode", " shortKey", "recentCode", "ShortName", "recentFilename", "ShortType", "recentName", "quickname"], "fis": [" fIs", "cfis", "cfois", "pois", "FIs", "sfi", " fris", "Fis", "fi", "sfIs", "cfi", "cfris", "hois", "ufois", "wi", "ufIs", "hi", "hris", "fIs", "wis", "ufris", "fois", "ufi", "ufis", "his", "Fris", "pi", "wois", "sfois", "wIs", "pris", "fris", "sfis", "pis"], "buf": ["buffer", "Buffer", "db", "orig", "block", "bed", "img", "msg", "pkg", "fg", "var", "bar", "b", "aka", "bag", "Buff", "tab", "cat", "bl", "cv", "seq", "conv", "fb", "arr", "buff", "bin", "ref", "uf", "box", "bus", "vec", "cb", "wb", "bytes", "tr", "bc", "batch", "mem", "cap", "mu", "br", "fam", "cmd", "temp", "rb", "cur"], "bytesRead": [" bytesLoad", "usersFind", " bytesWrite", "secondsWrite", "BytesNeed", "bytesFind", "linesWritten", "linesNeed", "BytesWritten", "bytesLoad", "flowsFind", "usersLoad", "blocksRead", " bytesWritten", "BytesRead", "postsFind", "secondsLoad", "usersRead", "secondsWritten", "bytesReady", "bytesLength", "BytesLength", "secondsRead", "bytesWritten", "blocksWritten", "linesRead", "flowsReady", "bytesWrite", "postsReady", " bytesNeed", "usersReady", " bytesLength", "bytesNeed", "postsRead", "postsLoad", "flowsLoad", "linesLength", "blocksWrite", "flowsRead", "blocksLoad"]}}
{"id1": "4629990", "id2": "17901739", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonForServer", "logonToClient", "logonTOServer", "logonToSite", "logonForserver", "logOnToClient", "logonTOSite", "logOnToSite", "logontoClient", "logOnToserver", "logonTOserver", "logonForSite", "logOnToServer", "logontoSite", "logOntoServer", "logOntoClient", "logontoServer", "logonTOClient", "logonForClient", "logonToserver", "logontoserver", "logOntoSite", "logOntoserver"], "ftpClient": ["ftpBuilder", " ftpBuilder", "ftcResponse", " fttpclient", "afttpClient", "aftcpClient", "fttpClient", "ftcpBuilder", "aftcpResponse", "aftpClient", "ftpConnection", "fftClient", "aftpResponse", "ftcpServer", "ffpclient", "ftcpclient", "ftcClient", "ftpclient", " ftpLib", "fftclient", " fttpBuilder", "fttclient", "ftcConnection", "aftpConnection", "fttConnection", "fttpLib", "aftcpConnection", "fttLib", "fttBuilder", "aftcpclient", "fftConnection", "fttResponse", " ftpclient", "fttpServer", "fttClient", " fttpLib", "ftspClient", "ftcpLib", "ftspServer", "afttpConnection", "fttpBuilder", "fttpConnection", "fttpclient", "ftcclient", "ftpServer", "ftpLib", "ftpResponse", " fttpClient", "aftpServer", "ftcpClient", "aftcpServer", "ftcpConnection", "aftpclient", "ffpClient", "ftcpResponse", "ffpConnection", "afttpclient", "ftspclient"], "ftpAddress": [" ftpaddress", "aftrAdd", "fttInterface", "ftpPath", "ettpOrder", "aftpClient", "fttpOrder", " ftpPath", "ftfPort", "ffcpAddress", "ftrAddress", "aftrClient", "fttStreet", "ettpAdd", "ettpAddress", "afttpHost", "aftrAddress", "ftPStreet", "ftpaddress", "etpAddress", "ftfAdd", "ftcpInterface", "ftPInterface", "fttpPort", "aftpaddress", "ftcpHost", "afttpAdd", "ftrClient", "fttpHost", "ftcpPath", "ftfaddress", "ffpAddress", "ftphAdd", "ffcpInterface", "ftpeaddress", "etpOrder", " ftpPort", "ftfHost", "ftpOrder", " fttpaddress", "ftcpAdd", "ftraddress", "fttpPath", " fttpPort", "ftcpAddress", "etpAdd", "ftfAddress", "ftphaddress", "ftrAdd", "ftphClient", "fttpaddress", "ftcpStreet", "etpaddress", "ftpeOrder", " fttpPath", "fttpAddress", "ettpaddress", "ftpeAdd", "fttAddress", "ftpInterface", "ftcpOrder", "ftcpaddress", "ftPAddress", "aftpHost", "ftcpClient", "ftpHost", " fttpAddress", "ftphAddress", "aftraddress", "ftpPort", "afttpaddress", "ffpStreet", "ftpeAddress", "ftpStreet", "ftfPath", "afttpAddress", "ftcpPort", "fttpAdd", "aftpAdd", "ffpInterface", "ftpAdd", "aftpAddress", "ffcpStreet"], "noRetries": ["noEntries", "noRetry", "noretorts", "noRetorts", "noTrys", " noEntries", "NOReties", "noreties", "NOretry", "NOreties", " noRetorts", "noretry", "noContries", "noretrys", "noRetrys", "NOretries", "noContrys", "noTries", " noEnties", "NORetrys", "noEntorts", " noEntorts", "noContorts", "NOretrys", "noEnties", "noConties", "noTies", "NORetries", "noEntry", "noTry", "NORetry", " noEntrys", " noReties", " noRetrys", "noEntrys", "noReties", "noretries"], "remoteHomeDir": ["remoteRootRoot", "remoteRootdir", "remoteRootDirectory", " remoteHomeDirectory", "remoteWelcomeRoot", "RemoteHomeRoot", "remoteHomeDirectory", " remoteRootDirectory", "remoteBaseDirectory", "RemoteRootDir", "externalHomePath", " remoteRootPath", "externalHomeDir", "remoteRootDir", "remoteHostDir", "remoteWelcomePath", " remoteHomePath", "RemoteRootRoot", "RemoteHomeDir", "remoteHostPath", "remoteHostRoot", "remoteBaseDir", "remoteBasePath", "remoteWelcomeDir", "externalHomedir", "RemoteRootPath", "remotehomeDirectory", "remoteHomedir", "remotehomedir", "RemoteHomePath", "remoteRootPath", "remotehomePath", "remotehomeDir", "externalHomeDirectory", "remoteHomeRoot", "remoteHomePath", " remoteRootDir"], "noRetriesSoFar": ["noRetriesSOOld", "noRetriesSOMuch", "noRetrysSOfar", "noRetrysSOFar", "noRetriessoMuch", "noRetrysSofar", "noRetriesSoobar", "noRetriesOffFar", "noRetrysSONear", "noRetriessoOld", "noRetriesSofar", "noRetriesSOFar", "noRetriesPeFar", "noRetriesPefar", "noRetriesTooobar", "noRetriesOffNear", "noRetriesToofar", "noRetriesTooNear", "noRetrysSOobar", "noRetrysSoNear", "noRetrysSoFar", "noRetrysSoOld", "noRetrysSoMuch", "noRetriesTooFar", "noRetriesSoMuch", "noRetriessoobar", "noRetriesSOfar", "noRetriesSONear", "noRetriesSoNear", "noRetriesSoOld", "noRetriessoFar", "noRetriessoNear", "noRetrysSoobar", "noRetrysSOMuch", "noRetryssofar", "noRetriessofar", "noRetryssoOld", "noRetriesPeOld", "noRetryssoFar", "noRetriesSOobar", "noRetriesOfffar", "noRetryssoNear", "noRetriesPeNear"], "reply": ["message", "part", "close", "notice", "nb", "apply", "link", "response", "echo", "address", "count", "shell", "state", "reset", " Reply", "answer", "power", "continue", "exit", "flag", "code", "write", "error", "next", "number", "ignore", "Reply", "result", "print", "command", "consider", "status", "zero", "job", "match", "comment", "info", "py", "success", "repl", "report", "ply"]}}
{"id1": "18011804", "id2": "2324868", "code1": "    public FileChooserTestFrame() throws HeadlessException, MalformedURLException {\n        super();\n        addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent aEvent) {\n                System.exit(0);\n            }\n        });\n        Dimension dim = getToolkit().getScreenSize();\n        Rectangle abounds = getBounds();\n        setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2);\n        setVisible(true);\n        URL url = new URL(\"ftp://cendantstp/\");\n        char[] password = \"spnr\".toCharArray();\n        PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password);\n        FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication);\n        JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView);\n        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        fileChooser.setMultiSelectionEnabled(true);\n        File[] selectedFiles = null;\n        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n            selectedFiles = fileChooser.getSelectedFiles();\n            for (int i = 0; i < selectedFiles.length; i++) {\n                if (selectedFiles[i] instanceof FTPFileFile) {\n                    FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i];\n                    logger.fine(ftpFile.getName());\n                    logger.fine(ftpFile.getPath());\n                } else {\n                    logger.fine(selectedFiles[i].toString());\n                    logger.fine(selectedFiles[i].getAbsolutePath());\n                }\n            }\n        }\n        remoteFileSystemView.disconnect();\n        try {\n            if (null != selectedFiles) {\n                FTPClient ftpClient = new FTPClient();\n                InetAddress inetAddress = InetAddress.getByName(url.getHost());\n                ftpClient.connect(inetAddress);\n                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                    throw new FTPBrowseException(ftpClient.getReplyString());\n                }\n                if (null != passwordAuthentication) {\n                    ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());\n                }\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    FTPFileFile file = (FTPFileFile) selectedFiles[i];\n                    logger.fine(file.getPath());\n                    FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\"));\n                    logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos));\n                    fos.close();\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 0, "substitutes": {"HeadlessException": ["Headlessception", " Headlessception", "HeadlesslyEvent", "HeadlessEvent", "HeadlevelError", "HeadlevelException", "HeadLessception", " HeadlesslyEvent", "HeadLessEvent", " HeadlesslyError", "Headlesslyception", "Headlevelception", " HeadlessEvent", "HeadlesslyException", " HeadlessError", "HeadLessException", " HeadlesslyException", "HeadlessError", "HeadLessError", " Headlesslyception", "HeadlevelEvent", "HeadlesslyError"], "MalformedURLException": ["MalformedURLExpion", "MalformedURLAexception", "MalformedURLEssption", "MalformedURLExpption", "MalformedURLExpression", "MalformedURLEssception", "MalformedURLExption", "MalformedURLExression", "MalformedURLEexption", "MalformedURLExion", "MalformedURLExpception", "MalformedURLEexception", "MalformedURLEssression", "MalformedURLAxression", "MalformedURLAxion", "MalformedURLAxception", "MalformedURLEexression", "MalformedURLAexion", "MalformedURLAxption", "MalformedURLAexption", "MalformedURLEexion", "MalformedURLEssion", "MalformedURLAexression"], "aEvent": [" anEvents", " anEvent", " aCommand", " oEvents", " aFolder", " oCommand", " anFolder", " oEvent", "iCommand", "iFolder", " aEvents", "iEvents", " anCommand", " oFolder", "iEvent"], "dim": ["ims", "dr", " dimension", "db", "shape", "im", "px", "ram", "sd", "ality", "tm", "iam", "Rect", "region", "size", "dir", "coord", "dimension", " Dim", "dm", "dem", "mm", "mid", "spec", "lim", "Dim", "du", "mb", "d", "cam", "sum", "wid", "mod", "vis", "details", "mem", "gm", "def", "sam", "di", "py", "height", "div", "dom"], "abounds": ["aporders", "abbles", "aborts", "abbounding", "bbles", "absounces", "aports", "abbqs", "bounds", "abbodies", "abbounds", "Abounds", "amborders", " abensions", " ABounding", "Abounding", " abounces", "abounces", "abqs", "rabounds", "raborders", "amborts", "aborders", " aborders", "Abodies", " ABounds", "apounds", "ambbles", "abensions", "borts", "absorders", "abounding", "borders", "ambounds", "absounds", "apbles", "absensions", "Abqs", "abodies", " ABodies", " ABqs", "rabensions", "rabounces"], "url": ["path", "http", "mail", "html", "ls", "location", "window", "abs", "term", "sl", "addr", "hub", "usb", "bel", "link", "ur", "connection", "Url", "f", "address", "socket", "URL", "api", "parser", "absolute", "ssl", "uri", "dl", "loc", "nl", "resource", "client", "server", "browser", "ref", "str", "ll", "l", "u", "www", "localhost", "base", "lr", "domain", "web", "https", "r", "host", "github"], "password": ["session", "description", "prefix", "words", "phrase", "hello", "user", "database", "attribute", "secret", "address", "definition", "token", "reset", "security", "Password", "encrypted", "login", "power", "pass", "key", "sword", "shadow", "username", "crypt", "directory", "command", "padding", "hash", "language", "profile", "wordpress", "random", "word", "pattern"], "passwordAuthentication": [" passwordAuthenticating", "passwordAuthentiction", "passwordauthentiction", "passwordCommunicating", "passwordauthentication", "passwordauthentications", "passwordAuthenticator", "passwordAuthicator", " passwordAuthenticator", "passwordCommunication", " passwordAuthicating", " passwordAuthification", "passwordAuthentications", " passwordAuthentification", " passwordAuthentications", "passwordAuthicating", "passwordAuthenticating", "passwordauthentification", "passwordAuthiction", "passwordAuthications", "passwordAuthification", " passwordAuthiction", "passwordAuthentification", "passwordCommunicator", "passwordCommuniction", "passwordAuthication", " passwordAuthentiction", "passwordCommunications", " passwordAuthicator", "passwordauthenticating", " passwordAuthications", "passwordauthenticator", " passwordAuthication", "passwordCommunification"], "remoteFileSystemView": ["remoteFileListContext", "remoteFilesSystemContext", "remoteFilesystemModel", "remoteFileSystemview", "remoteFilesystemResponse", "remoteFilesSystemview", "remoteFileSystemContext", "remoteFileystemResponse", "remoteFilesystemView", "remoteFilesSystemView", "remoteFileListView", "remoteFileListResponse", "remoteFileSystemDisplay", "remotePlaceSystemModel", "remoteFileListModel", "remoteFileystemView", "remoteFileSystemModel", "remoteFilesystemview", "remoteFileTreeContext", "remoteFileListview", "remoteFileListDisplay", "remoteFilesSystemModel", "remotePlaceSystemDisplay", "remoteFileSystemResponse", "remoteFileTreeModel", "remotePlaceSystemView", "remotePlaceSystemview", "remoteFileTreeView", "remoteFilesystemDisplay", "remoteFileystemDisplay", "remoteFileTreeview"], "fileChooser": [" fileSelecticker", "fileSelectressor", "fileSeoder", "channelChoorer", "fileCompicker", "resourceChoer", "fileComposer", "resourceCompicker", "fileCompressor", "channelChoicker", "fileClerer", "fileSeoser", "fileSelectose", "resourceChoose", "filechoerer", "resourceComper", " fileCompose", " fileSelectressor", " fileChoer", " fileComposer", " fileCompressor", "channelchoerer", " fileSelectoser", " fileChoose", "fileChoer", "fileSeerer", " fileChoressor", "resourceComposer", "fileSelectoser", "fileCloser", "channelchooser", "fileChoressor", "fileSelectoder", "fileClicker", "fileChoorer", "fileSelecter", "fileChooder", "filechoicker", "fileChoser", "resourceChooser", " fileChicker", "channelchoicker", " fileChooder", "fileComper", "fileCompoder", "fileSeose", " fileSelecter", "fileChicker", "channelChooser", "fileChoose", " fileCompoder", " fileChoicker", "fileSeressor", "fileChosen", "resourceCompose", "fileComposen", " fileChoosen", "channelchoorer", " fileChose", "filechooser", "fileSeicker", "fileChoicker", "fileClorer", "resourceChoicker", "fileChoosen", "fileChoerer", "fileSelecticker", "channelChoerer", "fileChose", "fileSeorer", " fileChoser", "filechoorer", " fileChosen", "fileCompose"], "selectedFiles": ["checkedfiles", "selectedResources", "printedOps", "verifiedFeatures", "verifiedBooks", "fetchedFiles", "linkedResources", "lectediles", "pressedBytes", "namedPhones", "namedOps", "selectedBytes", "pressedThings", "selectediles", "pressedBooks", "checkedFiles", "lectedResources", "selectedfiles", "reviewedBooks", "checkedItems", "selectedOps", "pressedFile", "linkedFiles", "pressedPhones", "fetchedItems", "pressediles", "pickedBooks", "lectedfiles", "checkedBooks", "verifiedFiles", "lectedFile", "selectedThings", " selectediles", "coloredFiles", "pickedFeatures", "fetchedThese", "coloredBytes", "printedFile", "identifiedItems", "reviewedFile", " selectedItems", "reviewedFiles", "selectedThese", "selectedFeatures", "selectedFile", "namedFiles", "linkedFile", "coloredThese", "printedPhones", " selectedOps", "identifiedBooks", "fetchedBooks", " selectedfiles", "selectedBooks", " selectedBooks", " selectedResources", "pressedItems", "selectedPhones", "lectedFiles", "identifiedFiles", "printedFiles", "electedBooks", "pressedThese", " selectedFile", "electedItems", "pressedOps", "linkedfiles", "pressedfiles", "coloredThings", "identifiedOps", "pickedItems", "electedFiles", "fetchedfiles", "namedFile", "electedFeatures", "fetchedThings", "lectedItems", "verifiedItems", "pickedFiles", "selectedItems", "fetchedBytes", "lectedBooks", "pressedFiles"], "i": ["multi", "history", "x", "j", "init", "phi", "it", "my", "ai", "ini", "is", "ic", "ri", "ui", "me", "iu", "id", "y", "io", "mi", "ci", "ki", "ex", "uri", "t", "ii", "qi", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "u", "sequence", "err", "ei", "print", "batch", "m", "status", "xi", "us", "iq", "mu", "cli", "ami", "di", "sim", "pi", "chain", "info", "exp", "ij", "s", "in", "ip", "li", "\u0438", "ix"], "ftpFile": [" fttpfile", "ftpifile", " ftpChat", "ftpaFile", " ftpChain", " fttpFile", " fttpResource", "fttpfile", "fttpFILE", "ftpingfile", "ftPAction", "ftapiAction", "fttpChat", "ftPfile", "ftpFolder", " ftpfile", "ftpingResource", "ftPChain", "ftpfile", "fttpChain", "fttpFile", "ftpChain", "iftpComment", "ftpaComment", "ftpingFile", "iftpFile", "ftpiChain", "iftapiComment", "ftapiFolder", " ftPChat", "ftpFILE", "ftpComment", "ftPComment", "ftpingFILE", "ftrResource", "iftapiAction", "iftapiFolder", " ftPChain", "ftpiChat", "ftpiFile", " fttpFILE", "ftPFolder", "ftpAction", "iftapiFile", "iftpFolder", " ftPfile", " ftPFile", "iftpAction", "ftapiFile", "ftPChat", "fttpResource", " ftpFILE", "ftpaFolder", "ftpaAction", "ftpResource", "ftrFILE", "ftrfile", "ftPFile", "ftapiComment", "ftpChat", "ftrFile", " ftpResource"], "ftpClient": ["fttClient", "ftcpClient", "ftcServer", "fttProxy", "aftcpProxy", " ftpServer", "fttServer", "aftcpClient", "fttclient", " ftpConnection", "fttpProxy", "fttpClient", " fttClient", "aftpClient", "aftpProxy", "fttpConnection", "ftcpConnection", " fttConnection", "ftpConnection", "fttConnection", "ftcConnection", "aftpConnection", "aftpclient", "ftcpServer", "ftpProxy", "aftcpConnection", "fttpclient", "ftcclient", " fttclient", "ftpServer", " fttServer", "ftcpclient", "ftcClient", "ftcpProxy", "ftpclient", "aftcpclient", " ftpclient"], "inetAddress": ["physHost", "ptonAddress", "networkAddress", "physAdd", "inetaddress", "ptonaddress", "networkHost", "inetClient", "networkAdd", "netAddress", "netaddress", "inetHost", "physAddress", "netClient", "inetAdd", "netHost", "networkClient", "etAddress", "physClient", "ptonAdd", "netAdd", "etaddress", "etAdd"]}}
{"id1": "13152325", "id2": "8665321", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"loadExistingAntlibs": ["loadExistingAntibs", "loadExistingAntibFiles", "loadExistingAntLibFiles", "loadExistingAntlibz", "loadExistingAntribz", "loadExistingantlibd", "loadExistingAntibz", "loadExistingAntLibs", "loadExistingAntribd", "loadExistingantLibd", "loadExistingAntLibd", "loadExistingAntibd", "loadExistingantlibz", "loadExistingAntLibz", "loadExistingantLibz", "loadExistingAntribs", "loadExistingantLibFiles", "loadExistingantlibs", "loadExistingantLibs", "loadExistingAntlibFiles", "loadExistingantlibFiles", "loadExistingAntlibd", "loadExistingAntribFiles"], "classLoader": ["Classloader", " classPath", "classloader", "ClassLoader", " classReader", " ClassLoad", " ClassReader", " ClassPath", " classLoad", " classloader", " Classloader", "ClassPath", " ClassLoader", "ClassReader", "classLoad", "classReader", "ClassLoad", "classPath"], "antlibUrl": ["antribUr", "antlibraryurl", "antlabUr", "antliburl", "antribURL", "antLibRel", "antsLibStr", "antLibUr", "antslibUr", "antlibraryURL", "antlibraryUrl", "antslibUrl", "antlaburl", "antriburl", "antappUrl", "antribUrl", "antlibraryUr", "antLibURL", "antslibStr", "AntLibURL", "antlibraryStr", "antappUr", "antsLibURL", "antdburl", "antlibUr", "antsLibUrl", "antsLiburl", "antLiburl", "AntLibUr", "antlibraryRel", "antlibURL", "antlabUrl", "antlabStr", "antsLibRel", "antappURL", "AntlibUrl", "antdbUrl", "antdbUr", "AntlibUr", "antLibStr", "antsliburl", "antLibUrl", "antappRel", "antsLibUr", "AntLibUrl", "AntLiburl", "antdbURL", "Antliburl", "antlibStr", "antslibURL", "antlibRel", "AntlibURL", "antslibRel"], "antlibUri": ["antLibIis", "antLibUris", "antlibUris", "antlibEURI", "antlibUtRI", "antlibIris", "antlibEris", "antlibIr", "antlibIis", "antLibUURI", "antlibraryUsr", "antlibraryUne", "antlibUsRI", "antlibUtmi", "antlibUtrid", "antlibURri", "antLibIris", "antlibUis", "antlibOri", "antlibUsmi", "antlibUrid", "antlibUsne", "antLibIURI", "antLibUpi", "antlibraryUmi", "antlibraryUris", "antlibGeris", "antLibUrid", "antlibEUri", "antlibURris", "antlibIpi", "antlibEUpi", "antLibUtpi", "antlibOris", "antlibraryUsri", "antlibraryURI", "antlibEUris", "antlibURRI", "antlibGeRI", "antlibOr", "antLibUtris", "antlibUsr", "antLibUis", "antlibUtris", "antLibIRI", "antLibUri", "antlibIne", "antlibEri", "antlibraryUr", "antlibGeri", "antlibUr", "antlibIURI", "antlibUsri", "antLibUtri", "antlibUtri", "antlibUmi", "antLibIri", "antlibraryUsRI", "antlibUne", "antlibUsis", "antlibraryUri", "antlibIRI", "antlibraryUsne", "antlibUsris", "antlibOne", "antlibURI", "antlibIrid", "antlibUpi", "antLibIrid", "antLibURI", "antlibEis", "antlibIri", "antlibURmi", "antlibUURI", "antlibraryUsris", "antlibUsURI", "antlibGerid", "antlibUtpi", "antlibraryUsmi"], "resources": ["states", "links", "parents", "headers", "workers", "users", "types", "ports", "checks", "Resources", "images", "ries", "ues", "writers", "pages", "roots", "years", "files", "dates", "classes", "packages", "iers", "rs", "ions", "books", "these", "works", "actions", "builders", "maps", "bytes", "keys", "archives", "values", "ples", "models", "reports", "relations", "modules", "stores", "names", "issues", "groups", "events", "res", "seconds", "objects", "services"], "url": ["path", "http", "ls", "abs", "location", "add", "host", "sl", "addr", "bel", "link", "ur", "lb", "Url", "f", "address", "URL", "rel", "util", "ssl", "dl", "loc", "nl", "resource", "el", "server", "browser", "gl", "ref", "request", "key", "str", "mount", "name", "xml", "ll", "get", "service", "l", "char", "remote", "base", "entry", "lr", "string", "source", "rl", "date", "file", "web", "format", "r", "li", "github"], "stream": ["path", "buffer", "message", "history", "window", "progress", "sl", "open", "user", "response", "feed", "body", "socket", "loader", "console", "read", "sample", "iterator", "row", "io", "sw", "client", "resource", "Stream", "channel", "pipe", "content", "inner", "store", "view", "ream", "standard", "source", "input", "file", "stack", "system", "data", "context", "out", "zip"], "reader": ["collection", "buffer", "runner", "per", "rar", "volume", "instance", "ri", "rx", "reviewed", "review", "via", "rer", "loader", "socket", "parser", "console", "read", "row", "iterator", "sample", "older", "er", "READ", "client", "resource", "liner", "server", "length", "inner", "writer", "dd", "reading", "handler", "readable", "rr", "upper", "Reader", "roller", "ner", "input", "entry", "iter", "rl", "layer", "file", "driver", "ro", "range", "query", "r", "reads"], "line": ["buffer", "message", "text", "ls", "cell", "lin", "block", "sl", "ln", "n", "lf", "lo", "msg", "header", "eline", "link", "body", "sql", "row", "sample", "frame", "stay", "lines", "nl", "pos", "liner", "le", "inline", "ine", "str", "next", "label", "LINE", "l", "online", "page", "pe", "entry", "string", "print", "point", "iter", "port", "file", "log", "comment", "range", "profile", "column", "handle", "li", "word", "Line", "len"], "pkg": ["path", "patch", "part", "mask", "password", "kg", "prefix", "init", "msg", "lang", "var", "plugin", "zip", "pg", "p", "root", "wd", "deb", "col", "dir", "pid", "dl", "Package", "pp", "packages", "pt", "kid", "pod", "cmp", "pair", "key", "rpm", "module", "req", "name", "cp", "fx", "family", "quote", "perm", "lib", "mod", "imp", "ppa", "entry", "ctx", "gp", "port", "alias", "ip", "pack", "jar"], "uri": ["http", "location", "term", "ri", "link", "ui", "ur", "connection", "address", "proxy", "reference", "id", "iri", "api", "util", "folder", "local", "io", "mi", "resource", " URI", "library", "uu", "handler", "uid", "URI", "directory", "base", "source", "cli", "domain", "file", "i", "system", "profile", "pi", "ip"], "resource2antlib": ["resource2Antli", "resource1antlib", "resource2antlibrary", "resource1antLib", "resource2ntlibrary", "resource2etli", "resource2ntLib", "resourcetoANTconfig", "resource2ANTlib", "resource2antsconfig", "resource2boltloc", "resource2AntLib", "resource2antib", "resourcetoantloc", "resourcetoANTib", "resource2agentlib", "resource2boltlib", "resource2agentlibrary", "resource2etlib", "resource2ANTloc", "resource2agentib", "resource2ntli", "resource2boltib", "resource2ntib", "resource2antslib", "resource2ANTib", "resource1antlibrary", "resource1agentib", "resource1agentlibrary", "resourcetoantib", "resourcetoANTloc", "resourcetoANTlib", "resource2Antlibrary", "resource2etlibrary", "resource1agentlib", "resource2antconfig", "resource2antLib", "resource2antli", "resource2boltconfig", "resource2agentLib", "resource2Antlib", "resource2ntlib", "resource1agentLib", "resource2etLib", "resource2antloc", "resource2Antib", "resourcetoantconfig", "resource2ANTconfig", "resource2antsloc", "resource1antib", "resourcetoantlib", "resource2antsib"]}}
{"id1": "21425787", "id2": "8490297", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyByte", "CopyFile", "Copyfile", " copyFiles", "CopyFiles", "transferFile", "transferFiles", "copyFiles", "transferByte", "CopyByte", "copyByte", " copyfile", "copyfile", "transferfile"], "in": ["IN", "on", "din", "gin", "n", "it", "rin", "is", "ic", "ie", "vin", "b", "old", "o", "en", "inc", "from", "ind", "ins", "ar", "el", "up", "isin", "l", "In", "input", "source", "i", "inn", "inf", "cin"], "out": ["output", "n", "Out", "ent", "it", "b", "p", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "nt", "at", "g", "null", "str", "w", "l", "net", "err", "OUT", "source", "gt", "ne", "po", "i", "oss", "ot", "s", "c"], "sourceChannel": ["seedChannel", "srcChannel", "sourcePanel", "inputConnection", "srcChan", "systemPanel", "ourceChannel", " sourceClass", "sourceChan", "ourceCommand", "sourceClass", "ourceClass", "sourceCategory", "startChannel", " sourceManager", "seedPanel", "ourceConnection", "inputChan", "startCategory", "seedMachine", "sourceManager", "srcManager", "seedCategory", "inputCh", "sourceCh", "srcCommand", "startPanel", " sourceCommand", "ourceManager", "systemCategory", " sourceConnection", "sourceMachine", "ourceChan", "startMachine", "srcConnection", "srcCh", "srcClass", "systemChannel", " sourceChan", " sourceCh", "systemMachine", "sourceConnection", "inputChannel", "sourceCommand"], "destinationChannel": ["restinationChan", "destinatorChan", "destinationHandler", "destinatedChannel", "DestationChannel", "destensionChan", "DestinationHandler", "DestinationConnection", "destinoChannel", "destationConnection", "destinationsChan", "destationHandler", "Destationchannel", "destinatorHandler", "Destinationchannel", "DestinationChannel", "DestationChan", "DestensionConnection", "destinatedContext", "DestensionChan", "destinationsChannel", "destensionchannel", "destensionConnection", "restinochannel", "destinationchannel", "destinatedchannel", "Destensionchannel", "restinationchannel", "DestinationChan", "destinationContext", "destensionChannel", "destinochannel", "destinatorChannel", "destationChan", "destinoContext", "restinoChan", "restinoContext", "destationChannel", "destationContext", "destinationChan", "destinoChan", "DestationHandler", "destinationsConnection", "destinationschannel", "destationchannel", "DestensionChannel", "restinationChannel", "restinoChannel", "destinatedChan", "destinationConnection", "restinationContext", "destinatorchannel"]}}
{"id1": "6418781", "id2": "4016687", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"client": ["http", "window", "cell", "block", "force", "controller", "and", "connection", "to", "channel", "component", "tree", "service", "ace", "cl", "secure", "web", "query", "url", "cli", "list", "con", "close", "template", "response", "util", "row", "control", "Client", "cm", "google", "obj", "conn", "remote", "entry", "batch", "chain", "co", "sim", "cmd", "builder", "bolt", "prefix", "manager", "local", "resource", "server", "nt", "contact", "get", "check", "cache", "system", "man", "self", "patch", "type", "plugin", "console", "ce", "wrapper", "call", "key", "store", "tc", "policy", "command", "base", "c", "pattern"], "names": ["states", "nos", "strings", "some", "ls", "ms", "n", "olds", "users", "types", "orders", "prints", "aos", "roots", "mas", "lines", "files", "rs", "books", "these", "said", "ns", "ids", "members", "terms", "sts", "AMES", "ans", "chains", "keys", "named", "nam", "ons", "models", "pres", "nets", "spe", "s", "idents", "papers", "aps", "ren", "ames", "objects"], "name": ["path", "nan", "node", "core", "n", "member", "user", "a", "me", "nm", "p", "id", "common", "create", "t", "filename", "NAME", "ame", "ename", "e", "key", " named", "str", " NAME", "l", "named", "nam", "entry", "string", "cn", "brain", "Name", "value", "comment", " Name", "data", "in", "out", "word", "c"], "ftpFiles": ["ftpsFiles", "afpOps", "aftpFiles", "ftfFile", "fttpFile", "ftnFiles", "ftniles", "fttpfiles", "etpfiles", "ftpsFile", "etpsiles", "fttpiles", "afpFiles", "fttpOps", "ftfTypes", "ftpsfiles", "afpTypes", "ftnFile", "etpFile", "ftpsiles", "fttpTypes", "etpsFiles", "etpsfiles", "ftfOps", "ftfFiles", "ftpTypes", "ftnfiles", "ftnOps", "aftpTypes", "ftpOps", "etpFiles", "aftpFile", "ftpiles", "afpFile", "etpiles", "fttpFiles", "ftpfiles", "etpsFile", "ftnTypes", "aftpOps"], "ftpFile": ["aftnFile", "ftpnfile", " ftpItem", "ftpDocument", "fttpItem", "fttpfile", " ftnFiles", "fltpFile", " ftnFile", "fltpfile", "ftnStyle", " ftpfile", " ftnfile", "flpFiles", "ftPStyle", "ftpfile", "ftpStyle", "ftnfile", "fttpFile", "ftnFiles", "ftnEntity", "aftpStyle", "ffpfile", "fftpDocument", "ftpnFiles", "ftrItem", " ftnItem", "ftpItem", "fftpFiles", "fttpStyle", "fttpDocument", "aftnStyle", "flpfile", "ftrEntity", "fttpEntity", "ftnFile", "ftpnDocument", "flpEntity", "aftnFiles", "ffpFiles", "flpFile", "ftrFiles", "ffpDocument", "ftnItem", "ftnDocument", "ftpEntity", "ffpFile", "aftpFiles", "aftpFile", "ftpnFile", "fltpEntity", "fftpFile", "fltpFiles", "ftPFiles", "ftrfile", "fttpFiles", "ftPFile", "fftpfile", "ftrFile"]}}
{"id1": "471804", "id2": "20920051", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoDateFix", "doVersionsCheck", "doLicenseUpdate", "DoVersionUpdate", "doVersionscheck", "doDateFix", "doDateUpdate", "doVersionsUpdate", "doLicenseFix", "DoVersionFix", "DoDateUpdate", "doDatecheck", "doVersionUpdate", "doLicenseCheck", "doVersionFix", "DoVersionCheck", "doDateCheck", "DoDatecheck", "doVersionsFix", "doLicensecheck", "doVersioncheck", "DoDateCheck", "DoVersioncheck"], "view": ["buffer", "http", "self", "update", "html", "window", "model", "block", "cell", "iew", "open", "controller", "manager", "see", "review", "q", "console", "util", "row", "cv", "views", "help", "VIEW", "subject", "client", "server", "v", "browser", "wrapper", "component", "call", "this", "tree", "doc", "index", "hl", "engine", "get", "page", "form", "eye", "print", "blade", "check", "input", "View", "tv", "file", "table", "show", "web", "document", "query", "display", "context", "layout", "out", "host", "widget", "image", "report"], "url": ["path", "http", "json", "html", "ls", "location", "sl", "org", "bel", "link", "b", "lb", "Url", "f", "address", "ur", "ul", "socket", "URL", "id", "rel", "github", "pl", "ssl", "uri", "dl", "nl", "loc", "client", "v", "browser", "gl", "null", "str", "mount", "ll", "l", "char", "string", "lr", "rl", "language", "file", "date", "log", "web", "oul", "r", "host", "hl"], "in": ["IN", " IN", "gin", "din", "asin", "init", "ln", "n", "rin", "is", "vin", "b", "sin", "f", "body", "ain", "inc", "ins", "inner", "reader", "stream", "isin", "l", "kin", "In", "input", "source", "file", "i", "mn", " din", "info", "inn", "out", "mat", "inf", "cin"], "bin": ["buffer", "cos", "binary", "din", "gin", "con", "by", "ln", "nb", "abin", "spin", "bed", "rin", "sin", "b", " Bin", "loader", "bn", "local", "bl", "ebin", "win", "pipe", "buff", "bur", "len", "bg", "inner", "bi", "mon", "reader", "stock", "lib", " bins", "conn", "mem", "obin", "file", "ran", "sam", " din", "inn", "out", "thin", "rb", "cache", "cin"], "line": ["path", "field", "style", "load", "text", "ide", "part", "ls", "cell", "lin", "block", "ln", "se", " Line", "section", "lo", "eline", "link", "lane", "body", "no", "state", "cat", "sample", "row", "col", "frame", "lines", "channel", "el", "liner", "le", "code", "inline", "ine", "store", "LINE", "ice", "one", "l", "level", "page", "char", "err", "record", "entry", "string", "base", "point", "print", "iter", "port", "file", "log", "job", "range", "comment", "chain", "trace", "cmd", "column", "word", "Line"], "version": ["update", "ion", "description", "iso", "volume", "type", "versions", "title", "Version", "major", "ver", "latest", "usage", "test", "feature", "client", "resource", "video", "spec", "v", "browser", "tag", "translation", "VERSION", "release", "river", "key", "vision", "name", "index", "number", "serial", "position", "scale", "virtual", "license", "sequence", "form", "VER", "command", "project", "string", "hash", "status", "date", "python", "value", "match", "vers", "language", "software", "info", "format", "image"], "build": ["style", "load", "binary", "builder", "db", "update", "bor", "add", "dev", "last", "link", "hold", "b", "built", "arch", "ver", "old", "latest", "make", "util", "test", "install", "use", "th", "tag", "fail", "ship", "release", "where", "be", "dist", "unit", "ward", "building", "other", "round", "lib", "print", "project", "struct", "hash", "date", "boost", "match", "log", "Build", "ble", "work", "full", "develop", "bug", "uild"]}}
{"id1": "20660203", "id2": "8430178", "code1": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"temp": ["buffer", "fake", "deg", "T", "cu", "emp", "term", "prime", "template", "unt", "tmp", "count", "mint", "p", "dat", "variable", "perature", "late", "cum", "t", "pt", "current", "total", "v", "length", "pre", "null", "str", "alt", "tc", "cp", "fac", "ptr", "mp", "txt", "tr", "result", "mod", "Temp", "partial", "m", "iter", "Temperature", "tem", "cel", "c"], "a1": ["aache", "ca01", "ao256", " a0", " a10", "aaa9", " a4", "ae1", "wa6", "alpha3", "aa512", "aa2", "A1", "anache", "area1", "a3", "aa4", "alphaOne", "ca1", "a10", "wa0", "xa0", "area5", "aka61", "aa9", "i512", " a61", " aone", "aa5", " a9", "a01", "i2", "an1", "area61", "a6", "aaa2", "ca256", "a5", "sa1", "aaa3", "aa256", "A512", "a256", "xa512", " a8", "a4", "i256", "pa256", "aone", "era256", "anOne", "aaone", "ao0", "aaa1", "aa8", "aa0", "wa5", "aaa8", " aOne", "a2", "ao10", " a591", "aka5", "era1", "ao01", " a6", " a2", "aeOne", "A6", "xa256", "a001", "ao001", "xa2", "pa01", "aa3", "aa10", " a5", "a512", "xa01", "ao1", "a9", "xa1", "aa6", "wa1", "A2", "A0", "alpha1", "pa1", " a01", "aaaOne", "saone", "aa1", "aeache", "xa591", " a256", "era591", "sa4", "sa2", "i1", "akaache", "a61", "A8", "alpha9", "era01", " aache", "a0", "aaOne", "aOne", "a8", "ca001", "a591", "areaache", "aaa6", "aka1", "pa001"], "j": ["Ja", "json", "im", "jl", "x", "n", "ie", "b", "aj", "jj", "q", "y", "rel", "kj", "dj", "ind", "ja", "pr", "uj", "fr", "v", "adj", "js", "at", "ort", "g", "ji", "key", "jc", "jump", "other", "k", "obj", "tr", "bj", "ne", "J", "job", "z", "ij", "jp", "ge", "jo", "ix"], "i": ["ims", "it", "ri", "ic", "iu", "ish", "iii", "ind", "qi", "gi", "inner", "span", "status", "iter", "ori", "port", "iy", "ij", "cli", "li", "oi", "list", "json", "zi", "init", "my", "ini", "a", "is", "ui", "ia", "fi", "uri", "asi", "this", "hi", "g", "ti", "bi", "ji", "wi", "batch", "us", "ami", "chain", "sim", "ip", "\u0438", "multi", "im", "fire", "ie", "me", "id", "iri", "ci", "ii", "index", "ei", "yi", "xi", "iq", "pi", "php", "phi", "ai", "y", "io", "mi", "gu", "ki", "key", "ni", "si", "I", "point", "di", "info", "in", "ix"]}}
{"id1": "701029", "id2": "16557837", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 0, "substitutes": {"loadSourceCode": ["loadsourceData", " loadsourceFile", "loadSourceFileData", "loadBaseFile", " loadsourceCode", "loadSourceFileCode", "loadSourceFileSource", "loadSourceFile", " loadSourceFile", "loadBaseData", "loadSourceSource", "loadSourceFileFile", "loadsourceSource", "loadsourceCode", " loadsourceData", "loadsourceFile", " loadSourceSource", " loadSourceData", " loadsourceSource", "loadSourceData", "loadBaseSource", "loadBaseCode"], "length": ["collection", "buffer", "path", "message", "load", "text", "shape", "description", "volume", "type", "available", "loop", "title", "f", "ength", "count", " Length", "no", "h", "duration", "size", "read", "download", "end", "default", "Length", "t", "filename", "total", "library", "code", "write", "name", "readable", "number", "dump", "position", "ENGTH", "l", " lengths", "sequence", "SIZE", "family", "string", "limit", "amount", "capacity", "max", "join", "width", "format", "height", "maximum", "len"], "file": ["path", "buffer", "output", "db", "face", "fil", "connection", "f", "pool", "local", "size", "fp", "io", "frame", "File", "al", "channel", "resource", "el", "filename", "parent", "le", "ref", "e", "name", "page", "ile", "FILE", "base", "remote", "source", "set", "port", "table", "po", "full", "format", "handle", "image", "list", "il", "sf"], "buff": ["ch", "buffer", "Buffer", "j", "buf", "font", "tmp", "b", "f", "ob", "Buff", "alph", "read", "end", "bb", "fr", "ref", "uf", " buf", "mb", "txt", "mem", "ph", "append", " buffer", "cmd", " buffers"], "is": ["ist", "ims", "ser", "ists", "ais", "ls", "es", "isc", "iso", "ris", "it", "ri", "ois", "sys", "isl", "has", "lis", "bis", "isa", "its", "iss", "os", "mi", "are", "ins", "bits", "rs", "il", "\u00eds", "si", "Is", "ir", "fs", "iris", "vis", "iter", "us", "i", "oss", "sim", "ios", "s", "ip", "isi", "IS"], "isr": ["ispr", "Isr", "issl", "isspr", "essr", "isl", "oissr", "isar", " isl", " isvr", "risl", "issrs", "isvr", " ispr", "issr", "esar", "rispr", "issvr", "esr", "oisr", " isrs", "oisrs", "rissr", "oisar", "Ispr", "isrs", "Isrs", "risr", "esrs", "risar", "risrs", "Isvr"], "cv": ["vp", "nc", "qt", "vs", "buf", "vm", "rev", "bm", "tk", "sc", "cd", "rc", "av", "CV", "conv", "bt", "xc", "v", "fc", "cm", "uf", "rpm", "pb", "uv", "tc", "cb", "cp", "nv", "vr", "cam", "txt", "ctx", "cn", "tv", "cc", "sv", "cf", "vc", "lv", "hw", "c", "cur"], "url": ["http", "mail", "html", "location", "addr", "or", "abs", "sl", "ret", "bel", "link", "ur", "Url", "ul", "address", "URL", "rel", "io", "re", "ssl", "uri", "dl", "loc", "nl", "resource", "atl", "el", "browser", "gl", "ref", "key", "impl", "mount", "name", "str", "dll", "ll", "get", "l", "string", "rl", "web", "https", "res", "r", "github", "il"], "reader": ["buffer", "runner", "ser", "dr", "history", "builder", "rar", "ri", "rx", "body", "rer", "loader", "parser", "rc", "read", "row", "iterator", "older", "er", "fr", "resource", "liner", "rs", "wrapper", "inner", "writer", "reading", "handler", "stream", "ipper", "upper", "Reader", "ner", "roller", "iter", "rl", "driver", "ro", "range", "info", "data", "r", "her", "dra", "editor"], "sourceCode": [" sourceMessage", "SourceForce", "sourceLine", "SourceMessage", "sourceCount", "SourceData", "sourceMessage", "SourceComment", "relationData", "sourceName", " sourceComment", "relationName", " sourceData", "codeData", " sourceCount", "SourceScript", " sourceScript", "sourceTree", "codeTree", " sourceName", "relationCode", "sourceScript", "componentLine", " sourceTree", " sourceForce", "codeCode", "SourceLine", " sourceLine", "relationForce", "sourceComment", "SourceCount", "SourceCode", "sourceForce", "componentScript", "SourceTree", "codeMessage", "SourceName", "sourceData", "relationCount", "componentComment", "relationLine", "componentCode"], "line": ["message", "text", "cell", "block", "lin", "phrase", "ln", "se", "lo", "eline", "link", "body", "row", "sample", "frame", "lines", "nl", "liner", "lock", "le", "e", "code", "inline", "ine", "key", "str", "label", "LINE", "number", "l", "online", "page", "pe", "entry", "string", "source", "point", "print", "ne", "iter", "port", "stroke", "log", "comment", "range", "chain", "lined", "data", "trace", "word", "Line"]}}
{"id1": "21821404", "id2": "2009072", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"getWebPage": ["getDebugPage", "getLivePages", "downloadwebPage", "getwebPage", "getWebPages", "downloadwebUrl", "getwebPages", "getLivePage", "downloadWebUrl", "getDebugUrl", "downloadWebPages", "downloadwebpage", "downloadWebPage", "downloadwebPages", "getWebpage", "downloadWebpage", "getwebpage", "getwebUrl", "getDebugpage", "getLivepage", "getWebUrl", "getDebugPages", "getLiveUrl"], "urlObj": ["UrlCtrl", "Urlobj", "uriCtrl", "urlOnce", "UrlOnce", "urlCtrl", "logObject", "uriobj", "urlObject", " urlInd", "uriOnce", " urlOnce", "logInfo", "httpInfo", "UrlObject", "urlInfo", "logObj", "httpOb", "uriInd", " urlObject", "UrlInd", "UrlObj", " urlInfo", "uriObject", "logOb", "urlobj", "httpObject", " urlCtrl", "httpObj", "urlInd", "uriObj", " urlobj", " urlOb", "urlOb"], "content": ["output", "buffer", "message", "Content", "load", "text", "html", "reason", "core", "template", "section", "header", "ext", "response", "title", "address", "articles", "body", "comments", "raw", "complete", "read", "ce", "equ", "current", "wrapper", "continue", "cm", "code", "write", "str", "view", "page", "txt", "sequence", "result", "cont", "command", "string", "source", "object", "clean", "value", "comment", "document", "data", "format", "display", "context", "empty", "layout", "temp", "ontent", "article"], "is": ["ists", "by", "se", "not", "ri", "and", "isa", "its", "iss", "does", "re", "rys", "where", "isin", "other", "fs", "err", "iris", "job", "web", "ios", "sis", "isi", "IS", "ais", "or", "iso", "being", "a", "has", "as", "e", "be", "name", "\u00eds", "were", "Is", "net", "sit", "string", "ese", "his", "chain", "res", "lis", "are", "when", "mis", "es", "isc", "tis", "sels", "ois", "isl", "internet", "id", "os", "rs", "more", "isf", "ians", "was", "ist", "ms", "ris", "sys", "nis", "bis", "ire", "plays", "ir", "ism", "i", "ot", "s", "in", "out", "c"], "reader": ["buffer", "runner", "ser", "dr", "per", "rar", "ri", "iper", "loader", "parser", "read", "row", "iterator", "io", "er", "liner", "anger", "inner", "writer", "reading", "handler", "stream", "ipper", "rr", "ocker", "Reader", "ner", "roller", "iter", "file", "ro", "ader", "in", "r", "dra", "editor"], "line": ["message", "text", "part", "cell", "lin", "block", "ln", "section", "lo", "eline", "detail", "link", "piece", "zone", "lane", "row", "sample", "frame", "nl", "el", "liner", "email", "le", "e", "inline", "ine", "label", "LINE", "l", "online", "page", "char", "sequence", "record", "entry", "string", "print", "point", "stroke", "file", "comment", "range", "lined", "column", "word", "Line"]}}
{"id1": "335223", "id2": "20306677", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "8625346", "id2": "22625683", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "23510383", "id2": "7425022", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"saveProject": ["createPackage", "saveFile", " savePackage", " saveApp", " SaveFile", "saveApp", "createProject", "createFile", " SaveApp", " SavePackage", " SaveProject", "createApp", "savePackage", " saveFile"], "file": ["path", "real", "db", "open", "link", "id", "complete", "local", "dir", "create", "io", "use", "File", "files", "resource", "filename", "parent", "ame", "e", "get", "ile", "base", "FILE", "project", "port", "table", "log", "info", "foo", "data", "full", "in", "handle", "image", "report"], "types": ["assets", "strings", "posts", "ypes", "sites", "ports", "versions", "times", "plugins", " Types", "pages", "views", "packs", "tests", "files", "classes", "packages", "tags", "styles", "actions", "ids", "features", "codes", "scripts", "pes", "keys", "values", "otypes", "Types", "projects", "parts", "models", "apps", "resources", "ties", "names", "issues", "groups", "events", "thumbnails", "options", "ts", "items", "objects", "sets", "services"], "images": ["uploads", "assets", "faces", "links", "icons", "versions", "picture", "frames", "pages", "boxes", "views", "files", "classes", "tags", "styles", "photos", "scripts", "models", "videos", "media", "blocks", "groups", "thumbnails", "events", "Image", "image", "Images"], "trajectories": ["Trajors", "traceptories", "Trajables", "traceptables", "tractories", "Trajectory", "trajables", "trajectory", "Trajory", "traceptory", "trajectables", "tractables", "traceptors", "trajory", "trajectors", "tractors", "Trajectories", "Trajectables", "Trajectors", "tractory", "Trajories", "trajories", "trajors"], "databasesIncluded": ["databasesInsjected", "databasesINjected", "databasesInscluded", "daturesInclusions", "databasesInclusion", "databasesedInified", "datadesIncluded", "databasesINified", "databasesINclusion", "databasesIngcluded", "datadesInified", "datadesInsified", "databasesInslisted", "databasesInglisted", "databasesInsified", "databasesIngclusions", "datadesInclusion", "daturesInscluded", "datadesInjected", "databasesedIncluded", "datadesInsclusion", "datadesInsjected", "databasesInsclusions", "daturesInslisted", "databasesedInclusions", "databasesInsclusion", "daturesInsclusions", "databasesInlisted", "databasesINcluded", "databasesInified", "databasesedInjected", "databasesedInlisted", "datadesInscluded", "databasesInjected", "databasesedInclusion", "daturesInlisted", "databasesInclusions", "daturesIncluded"], "onlyLinks": ["forceLink", " onlyRelations", "forceLinks", "onlylinks", "forcelinks", "Onlylinks", "onlyRelations", "OnlyLink", "alsoLinks", "OnlyLinks", "OnlyRelations", " onlyLink", "alsoRelations", "onlyLink", "alsoLink", " onlylinks"], "index": ["second", " sidx", "connect", "ion", "update", "offset", " Index", "add", "x", "n", "open", "address", "no", "end", "inc", "num", "ind", "ex", "pos", "loc", "initial", "length", "fail", "all", "Index", "number", "position", "sequence", "nn", "check", "amount", "set", "zero", "match", "max", "i", "find", "info", "first"], "name": ["path", "prefix", "n", "me", "title", "id", "nm", "root", "local", "create", "default", "about", "filename", "NAME", "parent", "ame", "run", "none", "named", "base", "string", "primary", "m", "table", "Name", "system", "names", "full", "data", "man", "word", "image"], "format": ["printf", "style", "term", "prefix", "init", "it", "cal", "percent", "pretty", " Format", "util", "mt", "default", "use", "Format", "v", "fm", "MAT", "unit", "get", "scale", "form", "print", "base", "set", "language", "table", "value", "parse", "data", "layout", "color", "list", "pattern"], "count": ["depth", "counter", "mark", "add", "reset", "size", "num", "total", "length", "flag", "Count", "code", "error", "process", "sum", "ount", "err", "amount", "set", "table", "skip", "z", "found", "start", "c", "order"], "version": ["json", "description", "j", "section", "build", "header", "database", "versions", "connection", "Version", "major", "ver", "mint", "latest", "root", "draft", "about", "current", "server", "video", "v", "parent", "translation", "VERSION", "summary", "release", "journal", "tree", "xml", "number", "virtual", "page", "result", "record", "VER", "alone", "java", "python", "vers", "document", "information"], "writer": ["output", "buffer", "builder", "function", "description", "window", "counter", "access", "caster", "author", "connection", "flush", "wrote", "writers", "variable", "console", "writing", "to", "sw", "iterator", "writ", "maker", "creator", "er", "client", "server", "wright", "wrapper", "browser", "operator", "journal", "write", "inner", "reader", "written", "handler", "external", "w", "stream", "service", "print", "entry", "Writer", "language", "driver", "comment", "walker", "document", "data", "woman", "outer", "report", "editor", "order"], "xmlDir": ["imageDirectory", " xmlFile", "xmlFolder", "imageDir", "imageFolder", "logDir", "xmlFile", "mlDirectory", "xmldir", "logFile", " xmldir", "xmlDirectory", "logFolder", "logdir", "mlFile", "imagedir", "mlFolder", "logDirectory", " xmlFolder", " xmlDirectory", "mlDir"], "databases": ["Datas", "Datelines", " datas", "generabases", "datelines", "datases", " database", " datasha", "notables", "database", "generates", "Datures", " datates", "Database", "notelines", "datasha", "generabase", "Datables", " datables", "basables", "mutables", "datables", "mutasha", "mutases", "datates", "mutabases", "basabases", " datases", "datas", "notabases", "notures", "Datates", "generas", "baselines", "basures", "Databases", "datures", "Datasha", "Datases"], "t": ["T", "term", "x", "j", "n", "template", "it", "te", "tt", "ct", "tm", "q", "id", "p", "y", "o", "h", "mt", "pt", "typ", "v", "e", "str", "tc", "w", "tr", "k", "txt", "i", "ot", "s", "ts", "temp", "c"], "type": ["style", "site", "top", "shape", "ping", "template", "instance", "config", "time", "te", "link", "class", "title", "ver", "address", "id", "root", "y", "p", "to", "relation", "test", "kind", "resource", "typ", "tag", "this", "key", "null", "TYPE", "rule", "error", "unit", "module", "ype", "tool", "other", "ime", "Type", "result", "pe", "base", "check", "object", "action", "language", "match", "parse", "info", "role", "ty", "single"], "currentName": ["baseName", "basePort", " currentDir", " currentFace", "reportedDir", "updateName", "thisYear", "reportedNames", "baseFace", " currentParent", "currentYear", "currentParent", " currentNames", "updateFace", "thisKey", "currentDir", "reportedLock", "currentFace", "currentSet", "currentlySet", "currentLock", "currentlyName", "currentTime", "completeName", "currentlyPath", "updatePort", "baseOrder", " currentPort", "thisName", "reportedName", "currentNames", "reportedParent", "currentlyLock", "CurrentNames", "CurrentPath", "CurrentName", "CurrentDir", "reportedTime", "CurrentParent", "updateOrder", "completeKey", "currentlyKey", "CurrentLock", "thisSet", "currentPath", " currentOrder", "CurrentTime", "completeSet", "currentlyTime", "currentOrder", "currentPort", "reportedPath", "completeYear", "currentlyYear", "currentKey"], "baseCopy": ["baseName", "basicCopy", "buffercopy", "BaseStore", "parentName", "basicCop", "basicStore", "baseCop", " basecopy", "baseStore", "BaseName", " baseCop", "basecopy", "Basecopy", "BaseCop", "parentCop", "basiccopy", " baseName", "BaseCopy", "parentCopy", "bufferCop", " baseStore", "bufferCopy", "parentcopy"], "source": ["site", "owner", "se", "init", "space", "SOURCE", "connection", "shell", "master", "ource", "console", "local", "sample", "size", "scan", "iterator", "from", "create", "subject", "channel", "resource", "initial", "scope", "Source", "parent", "ources", "src", "store", "inner", "original", "reader", "stream", "service", "sequence", "before", "base", "input", "select", "system", "join", "target", "data", "search", "origin", "start"], "destination": ["Destination", "destinator", "Destinator", " destinated", "datregation", "destregation", "declination", " destructure", "messinations", "messuation", "declinations", "Destinated", "destuation", "messination", "Destructure", " destuation", " destinations", "datinator", "declinator", "Destuation", "Destinations", "destinated", "messructure", "datination", "datinations", "destinations", "declregation", "messinated", "destructure", "Destregation"], "clefs": ["Clecs", " CleFs", "cleFS", " Clefs", "CleFS", "clefits", "CLEfs", "CleFs", " Clefits", " cleFS", "clebs", "Clebs", "Clefits", "clecs", " CleFS", " Clecs", " clebs", "CLEfits", " Clebs", "Clefs", "CLEFs", "CLEcs", "cleFs", " cleFs"], "st": ["ist", "sy", "est", "sl", "se", "it", "tt", "ST", "irst", "statement", "ct", "stra", "St", "sc", "h", "bl", "sw", "ost", "mt", "std", "fr", "bt", "sm", "pt", "cr", "sts", "str", "dd", "sth", "sn", " ST", "ste", "cl", "stat", "sb", "sp", "inst", "query", "start", "ts", "storage", "rest"], "rs": ["ls", " cs", " RS", "ris", " iss", " ps", "as", "ds", "rc", "os", "rd", "cs", "ins", " ms", "ps", "rys", "ers", "rt", "sts", "ks", "mr", "Rs", " pts", " sr", "res", "ts", " ins", "RS"]}}
{"id1": "21092340", "id2": "20660203", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addToHariver", "addToExFile", "addInHariver", "addToExiver", "addToExive", "addInArchive", "addInHarZip", "addToZipiver", "addToArchFile", "addToZipFile", "addToArchZip", "addToArchiver", "addInArchiver", "addInHarive", "addToHarive", "addToExZip", "addToHarFile", "addToHarZip", "addInArchZip", "addToZipive", "addInArchFile", "addInHarFile", "addToZipZip"], "pod": ["proc", "message", "disk", "top", "task", "volume", "pkg", "od", "zone", "body", "p", "pick", "wp", "report", "op", "spec", "component", "pack", "module", "ods", "poll", "post", "cp", "ack", "policy", "pc", "project", "check", "point", "device", "archive", "table", "job", "pad", "start", "Pod", "ad"], "podArchiveOutputStream": ["podArchiverOutputMap", "podArchiveEntryStream", "podArchiveResourceContext", "podArchiveInputStream", "podArchiverInputSync", "podArchiveOutputStreamer", "podArchiveOUForm", "podArchiverInputStreamer", "podArchiveStreamForm", "podArchiveOutStream", "podArchiveStreamSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiveoutputForm", "podArchiveOUStream", "podArchiveOutputstream", "podArchiverOutputStreamer", "podArchiveOutputMap", "podArchiveStreamStream", "podArchiveOutContext", "podArchiveoutputStreamer", "podArchiverOutputPoint", "podArchiveOutPoint", "podArchiveResourceSteam", "podArchiveMainStreamer", "podArchiveOUMap", "podArchiveoutputStream", "podArchiveInputContext", "podArchiveoutputSteam", "podArchiveMainSteam", "podArchiveOutputSteam", "podArchiverOutputSync", "podArchiveInputStreamer", "podArchiveOutputSync", "podArchiverOutputSteam", "podArchiveMainStream", "podArchiverInputContext", "podArchiveOutputContext", "podArchiveInputForm", "podArchiveResourcestream", "podArchiveOutstream", "podArchiveOutputForm", "podArchiverInputSteam", "podArchiveInputSteam", "podArchiveOutSteam", "podArchiveInputMap", "podArchiverInputMap", "podArchiveInputPoint", "podArchiveEntryPoint", "podArchiveMainForm", "podArchiverInputStream", "podArchiverInputPoint", "podArchiverOutputContext", "podArchiverOutputForm", "podArchiverOutputStream", "podArchiveOUSync", "podArchiveResourceStream", "podArchiverInputstream", "podArchiveInputstream", "podArchiverOutputstream", "podArchiveInputSync", "podArchiveEntrySteam", "podArchiveStreamMap"], "filename": ["fn", "path", "nil", "message", "output", "binary", "description", "location", "prefix", "jpg", "fil", "title", "latest", "nm", "p", "FN", "Filename", "folder", "fp", "stem", "subject", "uri", "resource", "png", "NAME", "ename", "ame", "release", "key", "name", "original", "version", "println", "upload", "username", "family", "txt", "directory", "kl", "FILE", "string", "archive", "file", "names", "url"], "source": ["series", "ser", "proc", "style", "password", "template", "SOURCE", "force", "seed", "address", "shell", "body", "loader", "ource", "sql", "sample", "iterator", "from", "use", "resource", "spec", "Source", "component", "src", "inner", "store", "view", "get", "service", "stream", "sequence", "copy", "input", "select", "file", "info", "context", "start", "image", "supp"], "entry": ["ment", "task", "cell", "or", "cue", "book", "se", "ent", "ie", "link", "tmp", "attribute", "connection", "sheet", "ry", "row", "ce", "card", "element", "channel", "resource", "nt", "component", "key", "ace", "quick", "char", "obj", "good", "record", "enter", "line", "set", "archive", "file", "log", "job", "comment", "system", "query", "data", "Entry", "word", "zip"]}}
{"id1": "6613944", "id2": "300397", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOevalEntitions", " saveOevalDefinitions", " saveOvaldefaults", " saveOvalDeclitions", " saveOvaldefinitions", " saveOvalDeclinitions", " saveOvalEntinitions", " saveOvaldefitions", " saveOvalDeclaults", " saveOvalEntaults", " saveOevalDefitions", " saveOvalDefaults", " saveOevalEntinitions", " saveOevalEntications", " saveOvalDefinitions", " saveOvalEntitions", " saveOevalEntaults", " saveOevalDefications", " saveOvalDefications", " saveOvalDeclications", " saveOvalDefitions", " saveOevalDefaults", " saveOvaldefications", " saveOvalEntications"], "xml_location": ["xml_position", " xml_Location", "xmlContentLocation", "xmlContentloc", " xml_loc", "xml_Location", "xml_uri", "xml_loc", " xml_position", " xml_uri", "xmlContentlocation", "xmlContenturi"], "in_stream": ["xml_stream", " in_view", "in_iter", "in64stream", "in___path", "in_ream", "xmlptresource", "in___stream", "in64Stream", "inMemstore", "input_path", "inptresource", " in_ream", "in67view", "xml_resource", "in2stream", " in_Stream", "inptstream", "in64ream", "xmlptStream", "xmlptstore", "in___iter", "in2store", "in67sign", " in_sign", "in_sign", "inptStream", "xmlptstream", " in_iterator", "in2Stream", "in_view", "in___buffer", "input_iter", "in_buffer", "in_Stream", "inMemstream", "input_stream", "inMemresource", "in67iterator", "xml_store", "in2resource", "in67stream", "in_store", "xml_Stream", "in_iterator", "in_resource", "inptstore", "in_path", "inMemStream", "input_buffer"], "url": ["path", "http", "mail", "ls", "location", "abs", "sl", "org", "bel", "link", "ur", "Url", "f", "address", "ul", "URL", "rel", "download", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "browser", "gl", "ref", "null", "impl", "name", "xml", "mount", "ll", "str", "service", "l", "char", "lr", "rl", "file", "web", "cert", "r", "host"], "type": ["style", "function", "mail", "shape", "core", "model", "ping", "types", "class", "title", "tp", "ct", "ver", "y", "sche", "test", "create", "kind", "ped", "t", "typ", "tree", "cast", "where", "TYPE", "module", "ype", "tool", "ime", "Type", "event", "pe", "base", "check", "cl", "file", "otype", "info", "what", "oid", "role", "ty"], "object": ["output", "message", "json", "node", "model", "instance", "not", "detail", "class", "id", "entity", "o", "element", "resource", "name", "version", "obj", "dict", "result", "event", "entry", "string", "value", "job", "system", "document", "info", "data", "array", "context", "oid", "out", "objects"], "pid": ["proc", "doi", "pm", "PK", "pn", "pkg", "pan", "title", " PID", "pg", "park", "id", "p", "prop", "pa", "pr", " persistent", "ido", " pc", "png", "ps", "ids", "pty", "rpm", "process", "bid", "uid", "pc", "pet", "print", "sid", "pd", "port", "vid", "pic", "po", "cert", "oid", "pp"]}}
{"id1": "12389873", "id2": "9647576", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"load": ["save", "init", " cleanup", " fetch", " build", " Init", " validate", " refresh", " parse", "execute", " construct", " dump", " register", " read", " recover", " ingest", " fill", " startup", " test", " ping", " destroy", " scan", "construct", " search", " find", " reload", "insert"], "conn": ["ch", "nc", "wr", "connect", "db", "Con", "Connection", "con", "close", "n", "ln", "org", "open", "mc", "gate", "connection", "pg", "ct", "dn", "ds", "pen", "enc", "ens", "rel", "en", "col", "mt", "conv", "pas", "client", "pt", "cfg", "nt", "ns", "ctr", "cp", "comm", "cb", "coll", "obj", "yn", "ctx", "cn", "cc", "ann", "co", "mn", "cert", "die", "cmd", "com", "conf", "act", "Conn", "c", "cur"], "stmt": ["constmt", "ststat", "staddr", "restmg", "stacktab", "stopmm", "ostmt", "ostolt", "Stm", " superstmt", "estmm", " StMT", "stygt", "styMT", "histgt", "putmm", "Stst", "esttx", "estmt", " stst", " stmp", "histmt", "stymt", "stmem", "restmm", "osttab", " stm", "istMT", "stmsg", "histtry", " superstmg", " ststat", "stytx", "strm", "stackolt", " stmn", "putolt", "Stmm", "ostgr", "stpt", "styaddr", "stMT", "ostgt", "strmg", "stm", "stopmt", "stmid", "restgt", "ostpt", "stackmt", "putmp", " stolt", "ostmid", "Stmb", " superstmn", "stmp", "stymem", " superstMT", "stymb", "istgt", " Stm", "Stgr", "ostmem", "estgt", "stst", "stoprm", " supersttr", "istmt", "stymg", "stackgt", "stackmid", "constMT", "strmt", " sttry", " stmg", "resttx", "putMT", "sttry", "stmm", "puttab", "Stcmd", "stymsg", "STmsg", "restmp", "Sttry", " strm", "sttr", "stym", "Stmt", "stcmd", " stmem", "Stgt", "constst", "stackpt", "stolt", " Stmt", "ostmm", "Stmem", "STmb", "STMT", "estmg", "stmb", " stMT", " stpt", " stcmd", " superststat", " stmm", "stgt", " Sttr", "puttx", "sttx", "STmt", "estm", "stackmm", "stgr", "putmt", "restMT", "restgr", "sttab", "stackMT", " staddr", "restaddr", "StMT", "histcmd", " stmid", "restmt", "strmn", " superstm", "Stmsg", " sttx", " stmsg", "constm", " stgt", " sttr", "stmg", "strstat", "stmn", "ostmn", "estgr", "STtx", "ostrm", "estmb", "STgt", " stmb", " stgr", "restpt", "stopmn"]}}
{"id1": "13981689", "id2": "18202328", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"md5Hash": ["md7Sum", "md2hash", "md7Hash", "MD5Hash", "MD5Sum", "MD7hash", "md5Sum", "md3Hash", "md3hash", "MD5hash", "md2Sum", "MD7Sum", "md7hash", "md2Hash", "MD7Hash", "md3Sum", "md5hash"], "src": ["ser", "text", "st", "mph", "jpg", "RC", "sys", "rx", "b", "sc", "rc", "conv", "filename", "rs", "this", "obl", "str", "impl", "name", "ctr", "dest", "bytes", "fx", "obj", "txt", "sec", "sr", "string", "source", "input", "ipl", "sb", "inst", "data", "s", "url", "usc", "r", "sq"], "md": ["dr", "spread", "pm", "db", "ms", "nd", "sd", "msg", "mc", "bd", "od", "MD", "der", "cd", "ds", "mg", "dir", "mm", "dm", "rm", "mt", "ind", "down", "red", "pt", "sm", "nt", "det", "ld", "mb", "d", "dd", "mp", "mk", "amd", "mod", "pd", "m", "hash", "df", "mn", "mand", "cmd", "hd"]}}
{"id1": "335223", "id2": "23273706", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "9275622", "id2": "18782385", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" duplicateStream", " copyFiles", " cpfile", " duplicateFiles", " cpStream", " duplicatefile", " duplicateFile", " copyStream", "copyStream", " cpFiles", "copyFiles", " copyfile", "copyfile", " cpFile"], "_file1": ["_linkInit", "_ileOne", "_fileFirst", "_ileFirst", "_ile2", "_FileInit", "_ile1", "_FileFirst", "_filesOne", "_FileOne", "_fileInit", "_link1", "_filesFirst", "_linkOne", "_files1", "_fileOne", "_link2", "_File1", "_File2", "_ileInit", "_files2"], "_file2": [" _Filetwo", "_filetwo", " _File2", "_Fileb", " _fileb", " _FILE1", "_FILE1", " _FILE02", "_image2", "_linktwo", "_FileTwo", " _fileTwo", "_link1", "_FILE2", " _FileTwo", " _filetwo", "_FILE02", "_link2", " _FILE2", "_File1", "_fileTwo", " _FILEb", " _File1", "_linkTwo", "_File02", "_imageb", "_File2", " _file02", "_image1", "_image02", "_file02", "_FILEb", "_Filetwo", "_fileb"], "fis": [" fi", "cais", " fiss", "cios", "cos", "kis", "cfis", "cfois", "qis", "cis", "qiss", "fiss", "kais", "fi", "Fis", " fris", " fais", "Fiss", "qios", "cfris", "fli", "Fios", "flis", "qos", "kos", "fais", "Fos", "flios", " fios", "cfiss", "fliss", "kios", " fois", "fois", "ufi", "fios", "ufiss", "Fois", "ufis", "Fris", "fris", "ufios"], "fos": ["mos", "faos", "ffoes", "hos", "moes", "sfoes", "ffis", "sfoss", "mows", " foes", "hose", "maos", "flos", "flis", "floes", "wows", " fose", "foes", "ffoss", "sfose", "wis", "floss", "hoss", "sfos", " foss", "hoes", "woes", "fows", " fows", "waos", " faos", "foss", "fose", "woss", "ffos", "wos"], "canalFuente": ["canallFueree", "canallfueree", "canallfuje", "canalFuenza", "canalKuente", "canalfuperor", "canallFuent", "canalUtente", "canallFuje", "canalFuje", "canalFuestro", "canalfuent", "canalFueree", "canalTenenza", "canalTenente", "canalfueree", "canalfuje", "canalTenent", "canallfuperor", "canalFaleree", "canalFuent", "canallFuente", "canalFuperor", "canalFalente", "canallfuestro", "canalfuenza", "canalKuje", "canalFalent", "canalFalestro", "canallFuestro", "canallfuent", "canalFienza", "canalTenperor", "canallFuperor", "canallfuente", "canallfuenza", "canalFiperor", "canalFalperor", "canalUtestro", "canalUtent", "canalFient", "canalKuperor", "canalKuent", "canalFiente", "canalfuente", "canalFalje", "canalUteree", "canallFuenza", "canalfuestro"]}}
{"id1": "18114701", "id2": "6008635", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"resolveEntity": ["resloveEnt", "consolveEnt", "consolveObject", "resolvingEntity", "resolvingInternal", "consolvingObject", "resolvingEnt", "resolvingObject", "resolvedObject", "resloveObject", "resloveInternal", "resloveEntity", "consolveInternal", "consolvingInternal", "resolvedEnt", "resolvedInternal", "resolvedEntity", "resolveObject", "resolveEnt", "resolveInternal", "consolvingEntity", "consolveEntity", "consolvingEnt"], "publicId": ["openPart", "ublicId", "fullInt", "publicTime", "privateId", " publicLink", " publicAnd", "privateInt", "privatePart", "ublicID", "openID", "publicLink", "publicAnd", "ublicPart", "primaryTime", " publicInt", "fullLink", "fullID", "openId", "primaryID", " publicID", "publicInt", "primaryId", "publicPart", "privateAnd", "primaryPart", "privateID", "publicID", "openAnd", " publicPart", "ublicTime", " publicTime", "privateLink", "fullId"], "systemId": ["userId", "externalName", " systemUrl", "userID", "systemID", " systemName", "externalId", "externalUrl", "sysId", "systemName", "userName", " systemID", "systemUrl", "userUrl", "sysName", "sysID", "externalID", "sysUrl"], "resolved": ["revolution", "presolver", "involved", "Resolver", "rolution", "resultsolution", "Resolve", "remolves", "resolution", "presolve", "revolved", "involution", "resolver", "remolution", "resolve", "Resolved", "solves", " resolver", "Resolving", " reserved", "resolving", "reserved", "involve", "presolution", "solving", "resultsolved", "solve", " resolve", "presolved", "served", "involving", "rolved", "rolving", " resolving", "consolving", "revolving", "remolved", "resolves", "resultsolver", "preserved", "rolve", "consolves", "consolution", " resolution", "solution", "Resolution", "presolving", "remolving", "revolver", "solved", "resultsolving", "consolved"], "iSource": [" iService", " iSourceFile", "qiSource", "iuSources", "uiSourceFile", "iSourceFile", "IMember", "iSOURCE", "liSources", "qiSOURCE", " iSources", "iiMember", "iiSite", "uiSite", "iuSourceFile", "ISource", "IResource", "liSite", "iMember", "aiStream", "iuSOURCE", "iResource", "iniResource", "iiSource", "iService", "liSource", "aiSource", " iSOURCE", "iuSource", "iSources", "iniMember", "iSite", "liService", "ISite", "uiSource", "aiService", "iniSource", "aiSourceFile", "qiSources", "uiSources", "qiSourceFile", "iniSite", " iSite", "liSourceFile", "iiResource", "liStream"], "url": ["path", "http", "mail", "html", "ls", "location", "sl", "arl", "user", "build", "bel", "link", "ur", "Url", "f", "address", "ul", "URL", "rel", "mol", "re", "ssl", "dl", "uri", "nl", "resource", "browser", "gl", "ref", "null", "str", "mount", "name", "mb", "ll", "l", "u", "char", "rl", "log", "web", "r", "hl"], "iStream": ["riStream", "ipstream", "uStreamer", "ipStream", "ipStreamer", "inputRead", "sourceSteam", "riSteam", "inputStream", "sourceStream", "sourceStreamer", "inputStack", "ipSteam", "sourcestream", "inputSteam", "riStack", "uStream", "istream", "ustream", "riRead", "iStreamer", "iSteam", " iRead", "uSteam", " iStack", "iRead", "iStack", " iSteam"]}}
{"id1": "8064604", "id2": "8166767", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 0, "substitutes": {"init": ["load", "connect", "update", "bind", "it", "config", "open", "Init", "prep", " Init", "reset", "create", "register", "auth", "use", "hook", "login", "initial", "setup", "dump", "get", "set", "construct", "start", "dial"], "mgr": ["lnd", " mmg", "mdr", "rmGr", "rmnd", "lgr", "cdr", " mnd", "Mgr", "MGr", "mGr", "lGr", "lmg", "cgr", "Mmg", " mdr", "mnd", " mGr", "mmg", "rmgr", "cmg", "Mdr", "rmmg", "cGr"], "cfg": [" msg", "db", " cs", "config", " cp", "ct", " sane", " cf", " md", " df", "Config", "map", " sched", " sp", " conf", " cz", "Conf", "g", " config", "ctr", "cb", " mc", "keys", " sch", " caps", " setup", "cf", "conf", " cc"], "sock": ["spock", "jsock", "slip", "sink", "snip", "spocks", "spox", " sox", "sip", "svc", " svc", "sox", "snock", " socks", "jsocks", "spink", "snvc", " sip", "jsox", "snow", " sink", "sow", " sow", "slvc", "jsink", "slock", "socks", "slow"], "_cman": ["_dgr", "_mman", " _cgr", "_dml", " _cml", " _dml", "_cml", "_cctr", "_dctr", "_rctr", "_rman", "_mctr", " _dctr", " _dgr", "_mml", "_rgr", " _cctr", "_dman", "_cgr", "_mgr", "_rml", " _dman"], "_sock": ["_Socked", "_tock", "_csocked", "_nsq", "_tocks", " _ssocked", "_rsock", "_sice", "_Sck", "_rsocket", "_svq", "_sck", " _sek", " _rsock", "_sourceockey", "_csocket", "_sourceock", "_Src", "_dsrc", "_sq", "_socket", "_csck", " _rsck", "_Socks", " _sck", " _ssek", "_ssocked", "_socks", " _rsocket", "_Sock", " _socked", "_lsq", "_trc", "_soc", "_sockey", "_dsock", "_spockey", "_tck", "_svoc", "_rsocked", "_dsck", "_lsock", "_sourceocked", "_sek", "_rsck", " _rsocked", " _socket", " _ssockey", "_ssockey", "_nsock", " _sockey", "_socked", "_csock", "_spocked", "_lsoc", "_spek", "_nsoc", "_lsice", "_ssek", "_spock", " _ssock", "_nsice", "_sourceek", "_dsocks", "_svock", "_ssock", "_svice", "_Socket", "_src"], "i": ["it", "ic", "iu", "qi", "t", "gi", "err", "set", "iy", "cli", "li", "j", "my", "ini", "is", "ui", "f", "q", "sql", "o", " I", "ex", "e", "this", "hi", "g", "ti", "bi", "name", "l", "k", "print", "batch", "us", "ami", "chain", "sim", "ip", "\u0438", "multi", "im", "counter", "ity", "n", "ie", "loop", "me", "id", "ci", "ii", "client", "index", "mac", "u", "m", "xi", "pi", "x", "phi", "ai", "p", "y", "integer", "io", "mi", "gu", "ki", "v", "si", "I", "di", "info", "in", "c", "ix"], "key": ["ch", "path", "json", "Key", "prefix", "by", "x", "phrase", "cy", "n", "my", "ie", "item", "title", "et", "q", "p", "y", "row", "col", "test", "ke", "ex", "client", "KEY", "lock", "parent", "pair", "code", "this", "str", "name", "index", "cp", "mac", "char", "sum", "k", "mk", "print", "command", "entry", "string", "tip", "def", "air", "primary", "check", "value", "chain", "cert", "foo", "important", "ip", "conf", "cmd", "word", "list"], "_sout": [" _svamp", "_ssamp", "_wsout", "_svout", "_svco", "_svamp", "_sres", " _svout", "_wsamp", "_wsco", "_ssres", "_svres", "_wsres", " _svco", "_samp", " _svres", " _sco", " _samp", "_ssout", "_ssco", "_sco", " _sres"], "_sinp": ["_senP", "_cinm", " _sinh", " _cinP", "_binm", "_senp", "_senh", "_sinP", "_cinh", "_sinh", "_cinP", "_cinp", "_senm", " _cinm", "_binP", " _sinm", "_binp", "_binh", "_sinm", " _cinh", " _sinP", " _cinp"], "seed": ["ser", "db", "offset", "node", "password", "prime", "prefix", "sl", "se", "dev", "then", "now", "shift", "draw", "tmp", "feed", "secret", "socket", "id", "token", "sample", "row", "test", "sel", "slot", "sudo", "server", "pse", "eed", "Salt", "stable", "store", "index", "dd", "serial", "shadow", "uid", "sum", "sequence", "delay", "sn", "entry", "source", "finger", "iter", "set", "sid", "sp", "random", "insert", "mix", " seeded", "temp", "sett", "zip"], "rand": ["bot", "dr", "spr", "reg", "nd", "kick", "by", "add", "ng", "dev", "user", "draw", "sys", "normal", "and", "rx", "rev", "rc", "inv", "rad", "rd", "red", "pos", "radius", "rt", "rot", "mr", "round", "mk", "max", "z", "ro", "range", "random", "res", "r", "rest", "gen", "Rand"], "hex": ["ch", "alpha", "lit", "json", "html", "rex", "tex", "password", "term", "x", "prefix", "rh", "hello", "des", "pex", "raw", "wh", "prop", "h", "hook", "ex", " Hex", "buff", "kw", "hp", "length", "sex", "str", "sh", "hl", "index", "he", "serial", "mac", "bytes", "none", "char", "tr", "cas", "form", "print", "mem", "string", "def", "iter", "tx", "ph", "oct", "exp", "cert", "full", "random", "cf", "com", "mix", "hw", "temp", "color", "zip"], "pass": ["path", "strip", "out", "task", "password", "step", "add", "prefix", "phrase", "access", "rep", "val", "ret", "press", "gate", "secret", "send", "p", "wd", "read", "reset", "test", "pas", "allow", "pos", "ps", "pair", "fail", "PASS", "Pass", "pack", "name", "process", "ask", "str", "alt", "ress", "ack", "sum", "print", "conf", "def", "parse", "ass", "pillar", "res", "handle", "push", "act", "word", "pp", "gen"], "md5": ["dig45", " Md2", "hash3", " md2", " md64", "MD3", "hash5", " md45", " md_", "md45", "md64", "MD_", "dig4", "dig_", "dig3", " Md5", "hash23", "MD2", "hash2", "md23", "md4", "MD4", " MD3", " md3", " md4", " md23", "MD64", "md2", "MD45", "MD23", " MD64", " MD2", " MD5", "md_", "MD5", "dig5", " Md4", "md3"], "hash": ["style", "rh", "html", "password", "bolt", "host", "addr", "Hash", "hz", "hat", "header", "type", "title", "sha", "id", "token", "ssh", "h", "alph", "test", "buster", "total", "browser", "name", "flash", "version", "mac", "sum", "crypt", "print", "cert", "search", "data", "height", "random", "handle", "her", "temp", "ash"], "banner": ["scaninner", " baninner", " baner", "banker", "buginner", "broadnel", "bugker", "baninner", "bannel", "binker", "raininner", "broadline", "banter", "broadinner", "scanter", "binter", "binner", "baner", "bugner", "rainner", " bannel", "rainer", "Banler", " banler", "banline", "bininner", " banline", "scannel", "Banner", "banler", "scanline", "broadner", "rainler", "Baner", "Baninner", "scanner", "bugter", "scanker"], "txt": ["fn", "priv", "btn", "text", "qt", "json", "html", "plain", "words", "TEXT", "ret", "msg", "ext", "tmp", "notes", "ct", "tp", "mint", "tm", "xt", "lt", "nm", "tk", "dat", "htm", "kt", "writers", "ws", "Text", "tin", "t", "XT", "typ", "buff", "js", "nt", "wt", "ns", "rt", "str", "xml", "obj", "tif", "tn", "cont", "print", "tch", "sit", "details", "def", "tx", "tg", "data", "res", "out", "utt"], "sname": [" sName", "ssname", "spadmin", "lsnam", "ssnam", "lsadmin", "ssName", "ssame", "spnam", " same", "sName", "spname", "snam", "lsname", "ssadmin", "sadmin", "lsame", "spame", "same", " snam"], "spass": [" spwd", "psass", " spASS", "sposs", "osposs", " spred", "spred", " sposs", "spack", "ospss", "pswd", " spack", "psss", "ospack", "SPoss", "SPack", "SPass", "ospASS", "ospass", "spss", " spss", "psred", "SPASS", "spwd", "ospwd", "spASS", "ospred"], "sseed": ["tsiter", "wsentry", " sser", "tsser", "pspass", "Seed", "tsseed", "sentry", "ssel", "psentry", " siter", "Srandom", "Ssecret", "Sseed", "ssiter", "ssser", "ssecret", "wsseed", "siter", "ssseed", "tseed", "pssel", "wspass", "psecret", "prandom", "psseed", "sser", "wssel", "peed", "srandom", "pseed"], "items": ["ims", "faces", "cases", "links", "ms", "abs", "mods", "ops", "types", "orders", "item", "times", "lets", "arts", "images", "stats", "ues", "its", "rows", "qs", "ars", "pages", "airs", "Items", "boxes", "xs", "amps", "ins", "lines", "files", "ics", "rs", "cats", "styles", "actions", "ids", "aux", "terms", "ips", "ites", "keys", "values", "stuff", "EMS", "details", "phones", "flows", "results", "arms", "els", "groups", "blocks", "objects"]}}
{"id1": "21488868", "id2": "3187685", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "22135199", "id2": "949327", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCodingFullFile", " testCodingemptyStream", " testCodingemptyFiles", " testCodingSizeFiles", " testCodingSizeFile", " testCachingEmptyFiles", " testCodingFullFiles", " testCodingSizeStream", " testCachingEmptyStream", " testCachingEmptyfile", " testCodingSizefile", " testCodingemptyfile", " testCodingFullfile", " testCachingemptyFiles", " testCachingemptyfile", " testCachingEmptyFile", " testCodingFullStream", " testCachingemptyFile", " testCodingEmptyFiles", " testCodingemptyFile", " testCachingemptyStream", " testCodingEmptyStream", " testCodingEmptyfile"], "baos": ["aoOS", " baoss", "Bao", "boOS", "cao", "caOs", "taos", " bao", " baOs", "bao", "booss", "baOs", "taoS", "baoS", "aoOs", "boOs", "caoS", " baoS", "tao", "boos", "Baoss", "baOS", "BaOs", "caos", "aoos", "Baos", "taOs", "baoss", " baOS", "aoo", "boo"], "channel": ["ch", "buffer", "message", "session", "application", "con", "password", "window", "block", "chan", "caster", "room", "controller", "connection", "socket", "can", "console", "queue", "io", "client", "resource", "server", "cm", "component", "handler", "container", "service", "stream", "command", "batch", "input", "file", "chain", "system", "Channel", "context", "out", "c", "cache", "network"], "params": ["proc", "units", "limits", "json", "password", "properties", "config", "pps", "headers", "ops", "types", "sys", "ams", "p", "pretty", "pool", "mm", "cms", "fps", "AMS", "pins", "spec", "par", "param", "tags", "ps", "rs", "cmp", "settings", "radius", "Par", "name", "Parameters", "parts", "details", "ctx", "pi", "names", "data", "phys", "options", "caps", "conf", "services", " parameters"], "outbuf": ["outrb", "inrb", " outbuffer", "inbuff", "outBuffer", "OutBuffer", "inbuf", "Outbuffer", "Outbuf", "outputbuff", " outbuff", " outrb", "Outbuff", " outBuffer", "outputbuf", "inBuffer", "outputbuffer", "inbuffer", "outputrb", "outbuffer", "outbuff"], "metrics": ["metrices", " metcs", "mtths", "Metric", "monrors", " metrices", "mtrics", "matrors", "mtcs", "matric", "matrix", "monrics", "metcs", "metrix", "mutrics", " metths", "monrix", "monric", "matrics", "metths", "metrors", "mutcs", "Metrix", "Metrors", "metric", "Metrics", "mutrices", "mutths", "mtrices"], "encoder": [" encressor", "ecoder", " encoding", "enciever", "Encramer", "encoding", " encuter", "enoding", "enressor", "encrier", "encoded", "execrier", "execoding", "Encrier", "enramer", "ecrier", " encoded", "encressor", "execoder", "encuter", "enoder", "ecoding", " encrier", "eniever", "enoded", "Encoder", "Enciever", " encramer", "executer", "ecoded", "eciever", "ecressor", "enrier", "ecramer", "Encoding", "Encuter", "encramer"], "tmpFile": ["fakeFile", "tmpFILE", "imgKey", "testFilename", "testfile", "tmpFiles", "mpFile", "testName", " tmpPath", "mpfile", " tmpfile", " tmpFILE", "fakeFilename", "tempKey", "tmpPath", "tempFiles", "tempFILE", "imgFILE", "txtFile", "tempPath", " tmpFilename", "fakeFiles", "imgFile", " tmpKey", " tmpName", "tmpName", "txtfile", "tempFile", "mpName", "testFile", "mpFilename", "tempFilename", " tmpFiles", "tmpFilename", "txtPath", "tmpKey", "tmpfile", "tempfile", "fakefile", "imgfile"], "fout": ["lbal", "fouts", "sfout", "fOut", "dfOUT", "fullbal", "fullout", "dfout", "vouts", "dfoutput", "fao", "dfbal", "lout", "vao", "sfao", "sfouts", "fbal", "wouts", "sfOut", "vout", "wout", "fullOUT", "foutput", "fOUT", "vOut", "wOut", "wao", "fulloutput", "lOUT", "loutput"], "wrtout": ["ewrtin", "wgtout", "wRTn", "Wrdwriter", "wwtw", "hwrcw", "hwrtex", "wrdgen", "wltgen", "Wrtout", "wrtwriter", "Wrdn", "ewltout", "Wrdout", "wwtex", "wrtgen", "wttout", "wrtio", "wgtex", "hwrtout", "wgtwriter", "wttn", "hwrcwriter", "wrdio", "wdrwriter", "ewrtgen", "wrtn", "ewrtout", "wrtex", "wdrin", "wwtout", "ewrtwriter", "hwrcout", "wrcex", "ewltin", "hwrcex", "wRTio", "Wrtn", "wRTout", "Wrtio", "wgtw", "Wrdio", "wrcw", "wrcwriter", "wltin", "wrdwriter", "hwrtwriter", "wRTwriter", "wdrout", "ewltwriter", "ewltgen", "hwrtw", "wrdn", "wrcout", "wrtw", "wrdin", "wrdout", "wltout", "wttio", "wttwriter", "Wrtwriter", "wltwriter", "wdrgen", "wwtwriter", "wrtin"], "fchannel": ["wcontroller", " fcontroller", "fccontroller", "flconsole", "fcontroller", " fconnection", "Fnet", "fconsole", "Fconsole", " fChannel", "wchannel", "fcconnection", "fcchan", "fconnection", "fnet", "FChannel", "flchannel", " fnet", "Fchannel", "flnet", " fconsole", "flChannel", "fcchannel", "wconnection", " fchan", "fChannel", "fchan", "wchan"], "s": ["ls", "j", "n", "a", "gets", "is", "b", "f", "gs", "p", "ss", "ds", "ws", "h", "qs", "t", "v", "rs", "js", "e", "ns", "g", "str", "w", "r", "sg", "c", "string", "m", "csv", "i", "sv", "ts", "S", "sq"]}}
{"id1": "22411381", "id2": "4798332", "code1": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"stop": ["quit", "runner", "pause", "proc", "update", "st", "step", "close", "save", " stops", "ops", "kill", "worker", "end", "Stop", " stopped", "execute", " Stop", " stopping", "exit", "run", "process", "poll", "service", "check", " halt", "status", "work", "start"], "task": ["function", "term", "unknown", "config", "trial", "to", "scan", "t", "transform", "component", "ask", "service", "Task", "problem", "form", "tip", "that", "job", "work", "query", "trace", "word", "description", "msg", "link", "token", "trigger", "this", "remote", "project", " Task", "rake", "cmd", "remove", "session", "dev", "worker", "tag", "request", "null", "rule", "index", "unit", "activity", "action", "table", "tg", "app", "target", "what", "asks", "question", "article", "message", "self", "node", "kick", "type", "item", "piece", "master", "test", "total", "setup", "key", "module", "process", "tc", "thread", "event", "command", "point"], "con": ["fn", "nc", "out", "connect", "Con", "db", " conn", "cond", "cur", "ln", "mc", "ic", "gate", "connection", "ct", "ain", "socket", "sql", "sc", "can", "pool", "pen", "console", "rc", "en", "anc", "conv", "client", "win", "current", "fc", "cm", "tc", "cp", "cons", "comm", "dc", "coll", "don", "bc", "un", "conn", "gc", "nn", "ctx", "CON", "cn", "cc", "log", "ran", "co", "context", "cf", "com", "conf", "Conn", "c", "cache", "cin"], "s": ["ls", "ms", "sl", "is", "sys", "gs", " ss", "bs", "p", "ss", "ds", "sing", "stats", "ws", "h", "iss", "ses", "hs", "sa", "os", "xs", "sub", "cs", "ssl", "ins", "ps", "rs", "serv", "js", "ns", "sol", "less", "g", "sts", "comm", "ess", "fs", "sg", "c", "set", "m", "us", "sb", " ts", "sv", "search", "res", "ts", "S", "sq", "single"], "result": ["runner", "proc", "block", "se", "currency", "connection", "make", "complete", "rc", "re", "created", "bridge", "sequence", "err", "gc", "set", "status", "r", "report", "list", "cur", "ch", "buffer", "Result", "successfully", "json", "description", "response", "f", "row", "fr", "release", "mate", "done", "obj", "ter", "conn", "data", "res", "output", "ser", "valid", "ret", "dat", "relation", "answer", "resource", "current", "server", "page", "table", "success", "ge", "first", "message", "su", "raw", "test", "true", "all", "sen", "stream", "record", "RESULTS", "source", "results", "we", "out", "successful", "cache"], "url": ["path", "http", "json", "html", "ls", "addr", "term", "user", "ret", "build", "link", "Url", "address", "URL", "id", "rel", "api", "uri", "dl", "nl", "resource", "server", "gl", "ref", "key", "null", "mount", "l", "href", "remote", "base", "lr", "rl", "log", "job", "sb", "web", "r", "host"], "i": ["http", "im", "phi", "it", "ini", "ri", "ai", "ic", "is", "ui", "bis", "iu", "p", "fi", "o", "io", "ci", "mi", "ki", "ii", "t", "qi", "gi", "il", "hi", "bi", "ib", "si", "inter", "I", "l", "ir", "iter", "xi", "ori", "ami", "cli", "di", "pi", "ij", "in", "ip", "li", "oi", "isi"], "b": ["B", "bo", "bf", "db", "binary", "nb", "bar", "bp", "f", "bis", "ob", "bs", "y", "bl", "bound", "bu", "fb", "big", "buff", "bin", "ab", "eb", "bg", "be", "bit", "bi", "pb", "ib", "mb", "cb", "gb", "l", "bc", "lib", "base", "z", "sb", "bh", "br", "rb"], "bb": ["bf", "db", "nb", "bd", "bar", "bm", "ob", "kb", "bn", "deb", "nob", "bl", "fb", "gg", "bt", "buff", "ab", "eb", "bg", "ld", "ib", "mb", "cb", "gb", "bank", "obb", "ogg", "bc", "bj", "bread", "sb", "ble", "BB", "berry", "rb", "ad"], "ll": ["elt", "lex", "ls", "lf", "ln", "tl", "bl", "LL", "dl", "oll", "nl", "lc", "ly", "resp", "arr", "nt", "le", "sol", "gz", "ld", "dll", "fl", "l", "wn", " l", "lr", "ell", "lam", "wl", " LL", "ble", "gn", "lv", "coll", "len"], "k": ["VK", "kick", "j", "kk", "n", "km", "alk", "ek", "ck", "aka", "tk", "p", "ikk", "kt", "kj", "ke", "ki", "t", "ak", "ku", "kw", "key", "g", "kh", "ks", "ka", "uk", "ik", "wk", "kl", "mk", "kar", "kn", "ko", "dk", "kr", "sk", "K", "kan"], "s2": ["ts1", "is2", "ls2", "ds4", "ses6", "ss12", " s4", "ses12", "ss2", "ds02", " s02", " s1", "is52", "ts4", "s02", "ps02", "s6", "ats52", "des4", "ats02", " s6", "des02", "des2", " s12", "lstwo", "ps1", "ps4", "ls02", "s12", "ds2", "ats2", "is02", "istwo", "ts2", "s52", "ss02", "ses2", "stwo", "ts02", "s4", "ls52", "atstwo", "ss6", "ps2", "s1", "ses02"]}}
{"id1": "15409512", "id2": "364438", "code1": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"inFileName": [" inFileFace", "inFileNames", "inPageSource", "inStreamSize", "inFilenamePath", "infileSource", "inFilenameSource", "infilePath", "inStreamName", " infilePath", "inPageNames", "intModelname", " infileSize", "inStreamPath", " inFileSource", "inModelSource", "inFilenameName", "inFILEName", "inFileFace", "infilename", "intModelNames", "infileName", " inFileNames", "intFileSource", "intModelName", " infileNames", "inPagename", "inFILESource", "inFilenameNames", "intFileNames", " inFileSize", " infileName", "inFilename", "inFileSource", " infileFace", "intFilename", "inFilenameSize", "inFILEFace", " inFilePath", "inModelName", "infileFace", "inFilenameFace", "intFileName", "inStreamNames", "intModelSource", "inFilePath", "inModelNames", "inPageName", "inFileSize", " infileSource", "infileNames", "infileSize", "inModelname", "inFILEPath"], "outFileName": ["outFileParent", "outFileDir", "inFileNames", " outFilenameName", "inFilenamePath", "outfilePath", "infileDef", "infileFile", "inFileFile", " outFilePath", "outfileParent", "outFILEPath", " outFilenameParent", "outFilenameName", "outTileNames", "outFilenameDef", "inFileDef", "outPathPath", "inFilenameName", "outPathDir", "outfileDef", "outPathName", "outPathNames", "infileName", "outTileName", " outFileParent", " outFilenamePath", "inFileDir", "inFilenameNames", "outfileDir", " outFilenameNames", "outFilenameNames", "outFilenameParent", "inFilenameDir", "outFilenamePath", "outfileFile", "outTileDef", "outTileFile", "outFileDef", "outFileNames", "outFilePath", "outFilenameDir", " outFileNames", "outfileNames", "inFilePath", "outFILEName", "outFileFile", "outFilenameFile", "infileNames", "outFILENames", "outFILEParent", "outfileName"], "position": ["ment", "buffer", "expression", "application", "pointer", "ion", "offset", "description", "location", "block", "volume", "now", "resolution", "present", "type", "move", "connection", "condition", "see", "address", "reference", "Position", "usage", "p", "no", "character", "to", "size", "relation", "from", "slot", "pos", "initial", "total", "length", "direction", "journal", "request", "POS", "operation", "index", "number", "sequence", "osition", "command", "limit", "source", "point", "padding", "capacity", "port", "amount", "value", "zero", "minimum", "option", "document", "memory", "layout", "start", "portion", "order", "seek"], "bis": ["bat", "ais", "idis", "ls", "ris", "abin", "is", "oris", "nis", "phis", "bps", "bs", "obos", "dos", "uds", "its", "bb", "BS", "onis", "fps", "conv", "bits", "obs", "pins", "ubis", "opus", "ints", "rots", "js", "rison", "ads", "bil", "ubs", "cgi", "bi", "bid", "bes", "isin", "obb", "iris", "avi", "los", "lbs", "oss", "bh", "ios", "oi", "irs", "lis"], "bos": ["bo", "cos", "oops", "nos", "tis", "oos", "jas", "ows", "bs", "dos", "uds", "bys", "aos", "os", "boards", "BS", "oks", "ots", "bits", "obs", "pins", "ubis", "ippers", "bones", "rots", "webkit", "ns", "ubs", "bi", "ods", "aus", "ats", "bes", "eros", "fits", "oids", "fs", "ols", "los", "oss", "tes", "bh", "ios", "ths", "asket", "ts"], "b": ["ch", "B", "db", "j", "buf", "nb", "a", "bar", "bp", "f", "q", "body", "ob", "bs", "p", "h", "bb", "t", "fb", "v", "bin", "back", "ab", "eb", "bg", "g", "bit", "be", "pb", "ib", "mb", "d", "cb", "gb", "l", "bc", "base", "batch", "m", "i", "sb", "br", "bh", "c", "rb"]}}
{"id1": "13024538", "id2": "4118412", "code1": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"getHash": ["getSum", "GetSum", " getKey", " getSum", " gethash", "gethash", "createHash", "GetKey", "createKey", "createSum", "GetHash", "getKey", "Gethash", "createhash"], "uri": ["path", "message", "http", "html", "description", "password", "uni", "ri", "msg", "link", "ui", "ur", "requ", "address", "iu", "q", "su", "via", "wiki", "dir", "io", "subject", "qi", " ur", "resource", "filename", " URI", "ou", "uu", "course", "this", "du", "name", "har", "unit", "URI", "u", "remote", "source", "file", "url"], "mDigest": ["mDefake", "mdigests", "mDests", " mDiger", "mDester", "mdigUse", "hdiget", "mDer", "hdigester", "mDesignests", " mDse", "mDigse", " mDer", "hDigests", "mDiget", "mDesignester", "mDigake", "mdigester", "mDigester", "mModake", "mDet", "mDigUse", "mDefest", "mCritester", "hDigest", "hDiget", "mDse", "mdiget", "mCritUse", " mDigse", "mdigest", "hdigest", "mModer", "hDigester", "mDesignet", "dDigUse", "mDesignest", "mDake", " mDigake", "ddigest", "mDigests", "hdigests", "ddigester", "mCritest", "mDiger", " mDake", "mModest", " mDest", "mDefse", "dDigest", "ddigUse", "mDest", "dDigester", "mModse", "mDefer"], "d": ["db", "nd", "j", "n", " D", "sd", "des", "bd", "b", "p", "dat", "ds", "cd", "h", "dm", "ed", "ind", "t", "with", "v", "dh", "D", "dot", "done", "g", "dist", "ld", "da", "dd", "dim", "dec", "l", "td", "md", "dict", "dig", "pd", "def", "m", "df", "s", "data", "diff", "c", "de"], "hash": ["output", "buffer", "message", "html", "shape", "password", "window", "block", "Hash", "hz", "now", "user", "shift", "build", "header", "used", "bar", "echo", "filter", "address", "ssh", "h", "reset", "test", "oh", "map", "total", "transform", "tag", "square", "always", "summary", "ah", "hex", "esh", "key", "sh", "dump", "shadow", "sum", "print", "check", "archive", "bh", "search", "memory", "array", "random", "host", "report", "cache", "ash"], "i": ["multi", "ims", "im", "ms", "zi", "x", "init", "j", "phi", "it", "my", "ini", "ai", "is", "ic", "a", "ui", "ski", "ie", "ri", "q", "y", "fi", "io", "ci", "gu", "ind", "mi", "ex", "qi", "ii", "v", "gi", "hi", "ti", "ji", "bi", "index", "si", "I", "span", "u", "err", "ei", "yi", "point", "m", "xi", "us", "cli", "di", "sim", "pi", "in", "ip", "li", "\u0438", "ix"]}}
{"id1": "88047", "id2": "16719805", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "530882", "id2": "2668634", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndReprite", "readAndrewrites", "readAndRepend", "readAndResWrite", "readAndRepWrite", "readAndrewrite", "readAndRewrites", "readAndResrite", "readAndRewWrite", "readAndrewWrite", "readAndReprites", "readAndRewend", "readAndResend", "readAndResrites", "readAndrewend"], "inFile": ["initFile", "inputPlace", "iFile", "INFILE", "inFace", "docFILE", "INFace", "INFile", "initFace", "INPlace", "initFilename", "docTime", "InFile", "inputFace", "Infile", " infile", "outFilename", "iTime", "inputFilename", "infile", "INFilename", "iFILE", "InFilename", "inFilename", "outfile", "inputFile", "inTime", "inFILE", "initPlace", "inPlace", "docFile", "INTime", " inFilename", "docFilename", "iFilename"], "outFile": ["namefile", "nameFilename", " outFilename", "reportFILE", "checkFilename", "reportFilename", "nameFILE", " outfile", "outFilename", "toFILE", "tofile", "checkfile", "infile", "reportFile", "toFile", "inFilename", "outfile", "reportfile", "checkFILE", "inFILE", "toFilename", "checkFile", "nameFile", "outFILE", " outFILE"], "iis": ["iiisc", "aiis", "iIS", "liris", "IIs", "iIs", "Iis", "Ii", " iIS", "eIS", " iIs", "eis", "diiss", "ii", " iris", "aiIs", "iiris", "iiss", "aiIS", "liisc", "iiIs", "Iiss", "iris", "diIs", " iiss", "dii", "iiis", " iisc", " ii", "liIs", "diis", "iisc", "liis", "eIs"], "dcmParser": ["dmmarser", "dfmBuilder", "dpmReader", "dmmmparser", "drumReader", "dcmReader", "dromListener", "dmmAdapter", "DcmBuilder", "dmoduleAssistant", "dromReader", "dpmarser", "dromarser", "dcommParser", "dcfPar", "dmmmReader", "dcmListener", "dgrParser", " dpmarser", "dcomLoader", "drumParser", " dcmBuilder", "dmParser", "dfmParser", "decmParser", "DpmReader", "dcomParser", "DcmParser", " dpmPar", "deromParser", "dcmPar", "dpmListener", " dpmReader", "dpmAdapter", "dcfParser", "deromparser", "dgrStatement", "dmoduleParser", "dpcParser", "dromParser", " dcmAssistant", "dromparser", "dcrReader", " dpmListener", " dpmLoader", "dcomBuilder", "dpcReader", "Dcmparser", " dpmStatement", "dcmLoader", "dpcAssistant", " dpmPrivate", " dcmLoader", " dcmListener", " dpmAssistant", "dgrPar", "dfmReader", "dmoduleReader", "dmmparser", "dcmStatement", "deromReader", "decmarser", "deromarser", " dcmPrivate", "dcmarser", "DpmPar", "dcommAssistant", "Dpmparser", "dpmPrivate", "DcmReader", "dpmBuilder", " dcmReader", "dcrparser", "dcmAssistant", " dpmParser", "dpmPar", "dpcPrivate", "dcmparser", "dmparser", "DpmParser", " dpmparser", "dmarser", "DcmPar", "dpmStatement", " dcmPar", "DcmAdapter", "dcmPrivate", "dcfReader", "dpmParser", "dpmAssistant", "dmmParser", "dcfStatement", " dcmStatement", " dcmarser", "DpmAdapter", "drumBuilder", "dcomReader", "drumPar", "dcmAdapter", "decmparser", "dmmReader", "DpmBuilder", "dcmBuilder", "dmReader", "dcrParser", "dmmmParser", "dromAssistant", "dpmparser", " dpmBuilder", " dcmparser", "dmmmAdapter", "dpmLoader", "decmReader", "dcommListener", "dfmLoader", "dmodulePrivate", "dgrReader", "dcommReader", "dcrBuilder"], "ds": ["ims", "db", "vs", "ls", "es", " des", "dx", "sd", "des", "sys", "bd", "gs", " DS", "bs", "drivers", "as", "ss", "dos", "der", "uds", "its", "os", "hs", "qs", "ws", "Ds", "eds", "ys", "dt", "cs", "DS", "dl", "xs", "obs", "outs", "ins", "ps", "rs", "ils", "dh", "dat", "js", "ads", "ns", "ods", "gd", "ks", "dd", "d", "da", "fs", "aos", "dds", "details", "pd", "df", "tes", "sv", "s", "data", "eps", "pers", "in", "hd", "sets", "services", "dq"], "pdReader": ["pedCar", "tdParser", "tdWriter", "pedRunner", "xdWriter", "ddCar", "ddHelper", "hdParser", "dpCar", "ddLoader", "xdReader", "pdParser", "tdReader", "xdHelper", "vdLoader", "vdHelper", "hdRead", "pdLoader", "dpLoader", "tdRead", "vdReader", "dpReader", "dpRunner", "ddRunner", "ddRead", "ddWriter", "hdWriter", "pdHelper", "ddReader", "pedReader", "hdReader", "pdRead", "xdLoader", "pdCar", "pedLoader", "ddParser", "pdRunner", "vdWriter"], "out": ["it", "tmp", "aos", "to", "sw", "nr", "t", "at", "inner", "str", "sum", "err", "OUT", "status", "list", "ch", " err", "on", "con", "auto", "ent", "msg", "o", "desc", "ex", "outs", "conv", "pos", "ou", "writer", "name", "cb", "w", "obj", "go", "net", "conn", "oss", "co", "data", "cmd", "res", "outer", "output", "n", "id", "pool", "os", "en", "gen", "ins", "client", "up", "cfg", "nt", "null", "inter", "one", "gr", "over", "Out", "sys", "flush", "raw", "p", "opt", "inv", "end", "io", "v", "serv", "js", "all", "screen", "txt", "gt", "cn", "log", "full", "s", "in", "we", "c", "cache"], "dcmEncParam": ["dcmEnPar", "dmmencMsg", "dcmDecNum", "dcmencNum", "dmmEnParam", "dmmEncMsg", "dmmencParam", "dmmEncVal", "dcmencCmd", "dcmencMsg", "dmmencNum", "dcmEncCmd", "dcmEnParam", "dcmEscNum", "dcmencParam", "dcmEncMsg", "dmmEncCmd", "dcmEscPar", "dcmEncNum", "dcmEscParam", "dcmEscVal", "dmmEncPar", "dmmEncNum", "dcmEncVal", "dmmEnPar", "dmmEncParam", "dmmencCmd", "dcmencPar", "dcmDecCmd", "dcmDecMsg", "dcmEncPar", "dcmDecParam", "dcmEnVal", "dcmEnNum", "dmmEnNum"], "pdWriter": ["dpEditor", "pidWriting", "pcwriter", "tdWriter", "tdWrite", "dpWrite", "pidWriter", "tdReader", "PDWrite", "pidWrite", "pcWrite", "pdEditor", "dpReader", "tdEditor", "PDEditor", "tdWriting", "dpWriter", "pdwriter", "tdwriter", "pidwriter", "PDReader", "pdWrite", "pcWriter", "pdWriting", "PDWriter", "pcWriting"]}}
{"id1": "13362846", "id2": "7911686", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setCont\u00ednU", "setcontensenux", "setContensenu", "setCont\u00ednue", "setContenux", "setContensenux", "setCont\u00ednux", "setContennU", "setContensenue", "setcontenu", "setContenue", "setContenU", "setcontenU", "setcontensenU", "setContennu", "setContensenU", "setcontenue", "setcontensenu", "setcontenux", "setCont\u00ednu", "setContennux", "setContennue", "setcontensenue"], "contenuFichier": ["contenuVechier", "contenuFicheaire", "contenuFiveraire", "contenuFamilyachier", "contenuVichyr", "contenuVchIER", "contenuFichie", "contenuVchie", "contenuMicheiere", "contenuFsrenchaire", "contenuFicheiere", "contenuFihiere", "contenuFrenchier", "contenuFsrenchieri", "contenuFechier", "contenuFileochiere", "contenuFsrenchire", "contenuVchier", "contenuFuffer", "contenuFchiere", "contenuFamilyichie", "contenuFignaire", "contenuFecher", "contenuFihier", "contenuFsechier", "contenuFichtIER", "contenuFileochiers", "contenuFsicher", "contenuFithyr", "contenuFolfire", "contenuFsrenchier", "contenuFChier", "contenuFamilyachie", "contenuVichIER", "contenuFsichieri", "contenuMicheaire", "contenuFechiest", "contenuFileichiere", "contenuFihiest", "contenuFechieri", "contenuFrenchieri", "contenuVichier", "contenuFithier", "contenuFolfier", "contenuMichiere", "contenuFithiest", "contenuFamilyachiere", "contenuVechiere", "contenuMicheier", "contenuFChaire", "contenuFachiers", "contenuFochier", "contenuFsichaire", "contenuFachorie", "contenuFachier", "contenuFiverieri", "contenuFileochie", "contenuFolfer", "contenuVechyr", "contenuFichIER", "contenuFsecher", "contenuVchiere", "contenuFicher", "contenuFigniere", "contenuFichieri", "contenuFechiere", "contenuFechire", "contenuFolfieri", "contenuMichaire", "contenuMicheer", "contenuFochie", "contenuFichire", "contenuFamilyichorie", "contenuFichiest", "contenuFachie", "contenuFicheorie", "contenuFsechire", "contenuFchier", "contenuFochiere", "contenuFamilyichiere", "contenuFileochier", "contenuFachiere", "contenuFiverire", "contenuFchIER", "contenuFamilyachorie", "contenuFignier", "contenuFochiers", "contenuFichaire", "contenuFsichire", "contenuFichtie", "contenuFsechieri", "contenuFichiers", "contenuFicheieri", "contenuFechyr", "contenuFiverier", "contenuFCher", "contenuFichorie", "contenuFChiere", "contenuFichtiere", "contenuFithie", "contenuFileichiers", "contenuFamilyichier", "contenuFicheiers", "contenuFrenchaire", "contenuFicheer", "contenuFithorie", "contenuVichie", "contenuFchie", "contenuFrenchire", "contenuFithiere", "contenuFuffieri", "contenuFihyr", "contenuFileichier", "contenuFuffire", "contenuMichier", "contenuFichtier", "contenuFicheier", "contenuFichyr", "contenuFichiere", "contenuVechiest", "contenuFuffier", "contenuMicher", "contenuFigner", "contenuVichiest", "contenuVichiere", "contenuFicheie", "contenuFochIER", "contenuFileichie", "contenuFicheire", "contenuFsichier"], "fichierElectronique": ["fichierelectronier", "fichierCentronique", "fichierElectRONique", "fichierAdministroniques", "fichierElectroneic", "fichierelectroniques", "fichierElectrenicy", "fichierelectrenique", "fichierCentRONius", "fichierSelectroneiques", "fichierElectrontique", "fichierelectronic", "fichierElectonique", "fichierElectRONaire", "fichierCentronicy", "fichierElectoniques", "fichierElectromius", "fichierElectonier", "fichierAdministroneiq", "fichierElectromie", "fichierElectchronicy", "fichierCentRONique", "fichierElectrontipolar", "fichierTransferronic", "fichierAdministronique", "fichierElectronsie", "fichierElectrenique", "fichierTransferradorie", "fichierElectromicity", "fichierElectronicity", "fichierAdministroniq", "fichierElectronie", "fichierElectrontaire", "fichierSelectroniques", "fichierElectroneiq", "fichierTransferronius", "fichierAdministroneique", "fichierTransferradorique", "fichierCentronius", "fichierCentRONaire", "fichierElectronsiques", "fichierElectreniques", "fichierElectroneius", "fichierElectronsiq", "fichierElectrenaire", "fichierElectradorius", "fichierElectronsicity", "fichierElectronius", "fichierElectromaire", "fichierElectromipolar", "fichierElectRONius", "fichierSelectronicity", "fichierSelectronique", "fichierSelectroneique", "fichierElectronoch", "fichierElectroneie", "fichierTransferradorius", "fichierElectchronaire", "fichierElectricie", "fichierElectRONicy", "fichierElectchronique", "fichierElectronipolar", "fichierElectroneoch", "fichierelectreniques", "fichierElectronier", "fichierAdministroneie", "fichierelectrenier", "fichierelectronique", "fichierTransferronique", "fichierElectrenius", "fichierAdministroneiques", "fichierElectronic", "fichierElectroniq", "fichierElectronsoch", "fichierElectchroniques", "fichierElectroneaire", "fichierElectricique", "fichierElectromic", "fichierElectchronicity", "fichierTransferronie", "fichierElectradorie", "fichierElectradorique", "fichierElectrenic", "fichierelectrenic", "fichierTransferradoric", "fichierElectrenier", "fichierElectroneicity", "fichierCentronaire", "fichierElectroneipolar", "fichierCentRONicy", "fichierSelectroneicity", "fichierElectriciq", "fichierElectromique", "fichierElectronaire", "fichierElectronsier", "fichierElectroniques", "fichierElectroneique", "fichierElectradoric", "fichierElectronsic", "fichierElectronicy", "fichierElectriciques", "fichierElectronticity", "fichierElectroneiques", "fichierElectchronoch", "fichierElectronsique", "fichierElectchronius", "fichierAdministronie", "fichierSelectronoch", "fichierElectonic", "fichierSelectroneoch"], "utilisateurCourant": ["utilisateurParticipant", "utilisateurGovernants", "utilisateurRepresentant", "utilisateursCourant", "utilisateursCouriant", "utilisateursGovernante", "utilisateurRepresentiant", "utilisateurGoverniant", "utilisateurGovernant", "utilisateurParticipants", "utilisateurGovernante", "utilisateursGoverniant", "utilisateurRepresentante", "utilisateurCourants", "utilisateursGovernant", "utilisateurParticipiant", "utilisateursGovernants", "utilisateursCourante", "utilisateursCourants", "utilisateurRepresentants", "utilisateurCourante", "utilisateurParticipante", "utilisateurCouriant"], "support": ["collection", "history", "replace", "access", "cover", "force", "supported", "see", " Support", "accept", "install", "help", "control", "use", "feature", "allow", "pport", "library", "trust", "null", "share", "know", "service", "SUP", "please", "language", "cap", "port", "profile", "system", "document", "evidence", "media", "format", "success", "context", "proof", "storage", "prototype", "supp", "Support"], "ficheDocument": [" ficheDatabase", "bacheDocument", "ficiDocument", "fitimeDocument", "fitimeDatabase", "bacheDatabase", "ficiMatrix", "fiqueDescription", "FicheDatabase", "facheJournal", "ficiTransaction", "frenchDatabase", "foyerDoc", "FicheDocument", "fayeDocuments", "fcheDocument", "hacheJournal", "FayeDoc", "fcheTree", "frenchDoc", "fliciDatabase", "ficiJournal", "bicheDocument", "fachedocument", "facheTransaction", "fifaDatabase", "bicheDoc", "fruitDocument", "facheTree", "frenchDescription", "bacheDoc", "fliciMatrix", "foyerDocument", " frenchDescription", "frenchTransaction", "fcheDoc", "hacheDocument", "fifaDocument", "flicheTransaction", "foyerDatabase", "hicheJournal", "ficidocument", "fayeDoc", "FicheDoc", "flicheDocument", "fliciDocument", "fitimeTransaction", "fiqueDatabase", "frenchDocument", "flicheDatabase", "fruitTransaction", "hichedocument", " frenchDocument", "fayeDatabase", "ficheMatrix", "fichedocument", "frenchMatrix", "hicheDocument", " frenchDatabase", "fruitdocument", "ficheJournal", "fliciTransaction", "foyerTree", "flicheMatrix", "bicheDatabase", "hachedocument", "fifaDoc", "facheDocument", "FayeDocument", "ficheDocuments", "fiqueDocument", "facheDatabase", "ficheDatabase", "ficheDoc", "ficheTransaction", "bacheTree", "hicheTransaction", "ficheDescription", "ficiDatabase", "bicheTree", "fruitJournal", "FicheDocuments", "fitimeMatrix", " ficheDescription", "fitimeDescription", "ficheTree", "hacheTransaction", "facheDoc", "frenchDocuments", "fcheDatabase", "fifaDocuments", "FayeDocuments", "FayeDatabase", "fayeDocument"], "nomFichier": ["nomFichomer", "nomFericier", "nomFcher", "nomFicier", "nomFicher", "nomPFoililler", "nomFchier", "nomFichIER", "nomFichoancer", "nomFachier", "nomFicomer", "nomFichie", "nomPFichiller", "nomUFichire", "nomFericIER", "nomFacherer", "nomNolfiere", "nomPichier", "nomFericanger", "nomFichiere", "nomFicire", "nomUFichIER", "nomFacher", "nomPFoilier", "nomNichie", "nomFoiljer", "nomFachery", "nomPachier", "nomFilicjer", "nomFicheire", "nomFiverire", "nomFiverIER", "nomFoilier", "nomFiverier", "nomFiverery", "nomFoilER", "nomFicER", "nomFchiner", "nomPFoiljer", "nomFachIER", "nomFichoIER", "nomNolfie", "nomFolfier", "nomFicheier", "nomFchomer", "nomFichire", "nomFachomer", "nomUFachier", "nomFihIER", "nomFericancer", "nomPachomer", "nomFiliciller", "nomUFachIER", "nomFolfiere", "nomPicherer", "nomNichire", "nomUFichier", "nomFachiere", "nomFicheer", "nomFichancer", "nomFilicER", "nomFchire", "nomFilicier", "nomFolfie", "nomFihery", "nomUFachery", "nomPichomer", "nomFachire", "nomFicerer", "nomNichiere", "nomFichoanger", "nomFicheiner", "nomFicjer", "nomPichire", "nomFachanger", "nomFichery", "nomFicheiere", "nomPFichER", "nomFchiere", "nomFcherer", "nomPFoilER", "nomFichanger", "nomFiciller", "nomFachie", "nomFolfire", "nomFichjer", "nomUFachire", "nomFichiller", "nomNolfier", "nomFachancer", "nomNolfire", "nomFoililler", "nomPacherer", "nomPFichier", "nomFicheie", "nomPFichjer", "nomFihire", "nomFichER", "nomFichiner", "nomPachire", "nomUFichery", "nomFicherer", "nomFichoier", "nomNichier", "nomFihier", "nomFachiner"], "extension": ["protension", "Extension", "expractor", "strension", "protention", "Extending", "xtensions", "Extensions", "contension", "expension", "protitude", "contention", "xtension", "extending", "expitude", "strensions", "extractor", "strending", "extitude", "protractor", "expention", "extention", "xtending", "extensions", "contitude", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueLocalistent", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusistant", "fichierElectronicityInert", "fichierElectroniqueEXistance", "fichierElectroniquePersistant", "fichierElectronogramLocalistent", "fichierElectroniqueAssclusive", "fichierElectroniquePresentiker", "fichierElectroniquePlusiker", "fichierElectroniqueLocalistant", "fichierElectronogramExistance", "fichierElectronogramLocalistant", "fichierElectroniqueAssistent", "fichierElectroniqueEXert", "fichierElectronicityExert", "fichierElectronogramExistent", "fichierElectroniqueExvant", "fichierElectroniqueExistent", "fichierElectronogramLocalclusive", "fichierElectroniqueInistent", "fichierElectronicityInistant", "fichierElectroniqueEXvant", "fichierElectroniqueInclusive", "fichierElectroniqueInistance", "fichierElectronogueExistant", "fichierElectroniqueLocalistance", "fichierElectronoguePersistent", "fichierElectronogramExclusive", "fichierElectronogramLocalistance", "fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityExistant", "fichierElectroniqueEXistant", "fichierElectroniqueExplvant", "fichierElectroniqueAssistance", "fichierElectroniqueExister", "fichierElectronicityInvant", "fichierElectroniqueExplistant", "fichierElectroniqueInistant", "fichierElectronogueExiker", "fichierElectroniqueExert", "fichierElectronogueExister", "fichierElectronogueExistent", "fichierElectronoguePersiker", "fichierElectroniqueInvant", "fichierElectroniquePersiker", "fichierElectroniqueExistance", "fichierElectronoguePersister", "fichierElectroniqueExplert", "fichierElectroniqueExclusive", "fichierElectroniquePresentistant", "fichierElectronicityExvant", "fichierElectroniqueInert", "fichierElectroniqueLocalclusive", "fichierElectroniqueAssistant", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectroniquePlusistent", "fichierElectroniquePresentister", "fichierElectroniqueExplistance", "fichierElectronicityInistance", "fichierElectroniquePresentistent"], "idIgid": ["idIgcid", "idImgids", "idIgaddress", "idIgcido", "idIIgid", "idIgcoid", "idIigmaddress", "idIIgoid", "idIgzida", "idIegids", "idIgida", "idIgzido", "idAmgaddress", "idAgid", "idAmgis", "idIgoid", "idIgdido", "idIgcida", "idIgido", "idIIgzid", "idImgaddress", "idIgdata", "idIegdata", "idIkglimit", "idIIgzoid", "idIIgzido", "idIkgis", "idAglimit", "idIegid", "idIigmlimit", "idAmglimit", "idIgids", "idIgzid", "idIigmid", "idIgis", "idIIgido", "idIgdid", "idIkgaddress", "idIgdoid", "idAmgid", "idAgaddress", "idIigmis", "idIgzoid", "idIgkey", "idIkgid", "idImglimit", "idIvgkey", "idImgkey", "idImgid", "idIegkey", "idIIgzida", "idIgdida", "idIvgid", "idIvgdata", "idAgis", "idIglimit", "idIvgids", "idImgdata", "idImgis", "idIIgida"], "inputStream": ["InputStream", "outputSteam", "inputTime", " inputThread", "inputstream", "InputSteam", "outputStreamer", "imageLoop", " inputStreamer", "Inputstream", " inputLoop", "imageTime", "helloSteam", " inputSteam", "InputLoop", "helloStreamer", "InputTime", "outputstream", " inputTime", "helloChannel", " inputChannel", "inputSteam", "inputThread", "outputThread", "InputThread", "inputLoop", "imageSteam", " inputstream", "outputChannel", "inputStreamer", "helloStream", "imageStream", "inputChannel"], "outputStream": ["sequenceStream", " outputStreamer", "outputSteam", "webView", "sequenceSteam", "outputStreamer", "inputView", "writeSteam", " outputStyle", "outputForm", "writeView", "OutputView", "webStream", "OutputSteam", "inputSteam", "outputView", "OutputStyle", "sequenceStreamer", "inputForm", "OutputStreamer", "webSteam", "webStreamer", "writeStream", "writeForm", "OutputStream", " outputSteam", "sequenceStyle", "OutputForm", " outputView", "outputStyle"], "typeMime": ["typeRime", "typeSmime", "TypemIME", "TypeMim", "typeSmme", "typeRme", "typeRIME", "typemIME", "TypeMime", "TypeMme", "typeRim", "typeSmim", "Typemime", "typeMim", "TypeMIME", "typeMIME", "typeSmIME", "typemime", "typemim", "Typemim", "Typemme", "typeMme", "typemme"], "tailleFichier": [" tailleFuzzie", " tailleficheiers", " tailleFixiers", " tailleFixie", " tailleFuzzies", " tailleficheies", " taillefichie", " tailleFuzziers", " tailleFixies", " tailleFuzzier", " tailleFicheier", " tailleFichiers", " tailleficheier", " taillefichier", " tailleFichies", " tailleficheie", " tailleFicheies", " taillefichies", " tailleFichie", " tailleFixier", " taillefichiers", " tailleFicheie", " tailleFicheiers"]}}
{"id1": "3683344", "id2": "1985677", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandUID", " genRandomSID", " genRandUU", " genRandomUID", " genRandomRandomID", " genRandGuid", " genRandomUuid", " genRandomGU", " genRandGUID", " genRandomGuid", " genRandomSuid", " genRandomUU", " genRandUuid", " genRandomGID", " genRandomSUID", " genRandGU", " genRandGID", " genRandomUUID", " genRandomRandomUID", " genRandomRandomU", " genRandUUID", " genRandomRandomuid", " genRandomSU"], "secure": [" Secure", "close", "prime", "sync", "force", "strong", "ie", "sys", "nice", "weak", "id", "free", "pretty", "ssl", "encrypted", "security", "client", "Secure", "deep", "server", "quiet", "confirmed", "stable", "clear", "trust", "google", "protect", "sec", "sr", "check", "speed", "status", "domain", "active", " securely", "https", "safe", "sensitive", " insecure"], "valueBeforeMD5": ["valueBeforeMM5", "valueBeforeND3", "valueAfterND4", "valueBeforeMD2", "valueAfterND3", "valueBeforeSHA523", "valueUnderMD5", "valueBeforeND0", "valueAfterMDInvalid", "valueUnderMM0", "valueBeforeDER0", "valueBeforeMM25", "valueAfterMD523", "valueUnderMD0", "valueAfterND5", "valueBeforeDER5", "valueAfterDER2", "valueBeforeND25", "valueAfterDER5", "valueBeforeSHA5", "valueBeforeMD4", "valueUnderMM5", "valueAfterMD0", "valueAfterMD4", "valueBeforeMODFive", "valueBeforeMT0", "valueBeforeND4", "valueBeforeID5", "valueBeforeSHAInvalid", "valueBeforeMDInvalid", "valueBeforeMT25", "valueBeforeDER2", "valueBeforeMT5", "valueUnderMM25", "valueBeforeMOD2", "valueBeforeMD3", "valueBeforeMTFive", "valueBeforeSHA2", "valueBeforeMD0", "valueBeforeMT2", "valueBeforeMD25", "valueUnderMD25", "valueBeforeMM0", "valueBeforeID4", "valueBeforeRDInvalid", "valueAfterDERFive", "valueBeforeID3", "valueBeforeRD2", "valueAfterMD3", "valueBeforeMD523", "valueBeforeMOD5", "valueAfterMD2", "valueBeforeID2", "valueBeforeMDFive", "valueAfterMDFive", "valueBeforeND2", "valueBeforeDERFive", "valueBeforeND5", "valueBeforeMOD0", "valueBeforeRD5", "valueAfterND2", "valueBeforeRD523", "valueAfterDER0"], "valueAfterMD5": ["valueBeforeMM2", "valueBeforeMM5", "valueWithoutMD5", "valueafterEM5", "valueAfterMDODY", "valueBeforeMD2", "valueafterEMLeft", "valueAfterSDRL", "valueBeforeMM3", "valueAfterMI2", "valueBeforeMC5", "valueAfterEM2", "valueAfterEM55", "valueAfterUDODY", "valueAfterMC5", "valueAftermd2", "valueBeforeMDdown", "valueAfterMDPE", "valueAfterMIOK", "valueAfterMT55", "valueAfterMDLeft", "valueAfterCDdown", "valueAfterMD55", "valueAfterEM5", "valueAfterMC3", "valueAftermd5", "valueAfterUDRL", "valueafterMDLeft", "valueBeforeMD8", "valueAfterMT2", "valueBeforeMC2", "valueBeforeMD4", "valueAfterUD3", "valueWithoutmd2", "valueAfterSDODY", "valueAfterMD4", "valueAfterMCdown", "valueWithoutmdPE", "valueAfterMT5", "valueBeforeMDODY", "valueBeforeMD3", "valueAfterMDRL", "valueAfterMD8", "valueAfterMM2", "valueAfterSD3", "valueAfterMTdown", "valueAfterUD5", "valueAftermdOK", "valueAfterMM5", "valueAfterMC4", "valueAfterMC8", "valueAfterMTLeft", "valueBeforeMDRL", "valueBeforeMCdown", "valueAfterMM3", "valueAfterCD5", "valueafterMD55", "valueWithoutMD2", "valueafterMD5", "valueAfterMD3", "valueAfterMI5", "valueAfterMT8", "valueAfterMD2", "valueAftermdPE", "valueAfterMC2", "valueAfterMT3", "valueWithoutmdOK", "valueafterEM2", "valueAfterCD2", "valueAfterSD5", "valueAfterMM4", "valueAfterMDOK", "valueAfterEMLeft", "valueBeforeMM4", "valueafterMD2", "valueWithoutMDPE", "valueAfterMIPE", "valueWithoutMDOK", "valueWithoutmd5", "valueAfterMDdown", "valueafterEM55"], "md5": [" md25", "MD3", " md2", " md7", "dig3", "metadata2", "md25", "MD2", "MD7", " MD3", " md3", " MD7", "md7", "MD25", "dig2", "md2", " MD2", " MD5", "metadata25", "metadata3", "MD5", "dig5", "metadata5", "md3"], "sbValueBeforeMD5": ["sbValueBeforeMDOK", "sbValueDefMD5", "sbValueFrontMD5", "sbValueBeforeMS5", "sbValueBeforeANDFive", "sbValueBeforeMS45", "sbValueBeforeAND5", "sbValueBeforeMON512", "sbValueBeforeMD512", "sbValueAfterMDOK", "sbValueAfterMDLE", "sbValueFrontMD20", "sbValueBeforeMON305", "sbValueDefMD2", "sbValueInsideAMD512", "sbValueBeforeND2", "sbValueBeforeMD65", "sbValueBeforePDLE", "sbValueDefMD45", "sbValueBeforeMON2", "sbValueFrontMD2", "sbValueBeforeMED3", "sbValueBeforeMEDNot", "sbValueInsideMD5", "sbValueBeforeSD5", "sbValueBeforeMED45", "sbValueBeforeMOD45", "sbValueBeforemdLE", "sbValueBeforeAND05", "sbValueInsideMD512", "sbValueBeforeMED2", "sbValueBeforeMT65", "sbValueBeforeMED25", "sbValueFrontLM2", "sbValueBeforeMS3", "sbValueDefmd2", "sbValueBeforeMD05", "sbValueBeforeLM65", "sbValueInsideMD2", "sbValueBeforemd2", "sbValueBeforeMOD5", "sbValueFrontLM5", "sbValueBeforeMT5", "sbValueInsideAMD2", "sbValueBeforeMD2", "sbValueBeforePD2", "sbValueBeforeMOD3", "sbValueInsideMD305", "sbValueBeforeMT20", "sbValueBeforeMS25", "sbValueBeforePDOK", "sbValueBeforeND45", "sbValueAfterMS3", "sbValueBeforeMDNot", "sbValueBeforeLM20", "sbValueBeforeAMD5", "sbValueAfterMDFive", "sbValueBeforePD5", "sbValueInsideAMD5", "sbValueAfterMS45", "sbValueBeforeLM2", "sbValueAfterMS5", "sbValueAfterMD2", "sbValueAfterMD05", "sbValueAfterMS25", "sbValueBeforeAMD2", "sbValueBeforeSDNot", "sbValueBeforemd45", "sbValueBeforeMT2", "sbValueBeforeMD20", "sbValueBeforeMOD25", "sbValueInsideAMD305", "sbValueBeforeMDFive", "sbValueBeforemd5", "sbValueBeforeAMD512", "sbValueAfterMD5", "sbValueBeforeMED5", "sbValueBeforeSD2", "sbValueBeforeMT05", "sbValueBeforeAND2", "sbValueBeforeMD45", "sbValueBeforeAMD305", "sbValueDefmd5", "sbValueBeforeMDLE", "sbValueBeforeMD25", "sbValueAfterMD25", "sbValueBeforeMD3", "sbValueBeforeND5", "sbValueAfterMDNot", "sbValueBeforeMD305", "sbValueFrontLM65", "sbValueDefmd45", "sbValueBeforeMTFive", "sbValueBeforemdOK", "sbValueAfterMD3", "sbValueFrontLM20", "sbValueBeforeMON5", "sbValueFrontMD65", "sbValueAfterMD45", "sbValueBeforeLM5"], "time": ["TIME", "window", "timeout", "counter", "now", "user", "hour", "times", "id", "runtime", "duration", "size", "frame", "Time", "t", "etime", "total", "lock", "timer", "length", "clock", "name", "tc", "estamp", "ime", "event", "sequence", "rate", "tim", "date", "port", "value", "race", "system", "year", "order", "age", "start", "ts", "ty"], "rand": ["dr", "rh", "reg", "fine", "nd", "rss", "kick", "init", "sys", "and", "rid", "seed", "roll", "id", "grad", "pick", "rc", "inv", "sample", "pid", "rd", "std", "mid", "with", "ripp", "rank", "nt", "cr", "rest", "frac", "rt", "gz", "trust", "dist", "rot", "uid", "round", "md", "rate", "sid", "gt", "hash", "did", "max", "z", "range", "random", "res", "r", "ng", "Rand"], "array": ["collection", "rays", "our", "assets", "binary", "save", "instance", "var", "ary", "arrow", "ashes", "row", "area", "map", "arr", "v", "length", "RAY", "aster", " Array", "at", "atomic", "angle", "share", "external", "number", "storage", "vector", "upper", "Array", "batch", "string", "amount", "angular", "hash", "stage", "archive", "value", "ami", "range", "stack", "app", "data", "random", "aw", "audio", "ray", "list", "ash"], "strTemp": ["stringUnt", "brTemp", " strCmd", "arrMods", " strUnt", " strTem", " strTr", "drPtr", "stringPtr", " strTest", "strTemplate", "brTem", "txtTemp", "arrUnt", "strTest", "frTemplate", "STRTemp", "strCmd", "arrtemp", "stringTem", "hexTr", "brTemplate", " strPtr", "stringTemp", " strTemplate", "arrTem", "STRtemp", "arrTest", "arrTemp", "STRTem", "txtTr", "txtCmd", "arrNew", "STRNew", "strNew", "drMods", "frPtr", "stringMods", " strNew", "drTemp", "frTemp", "hexCmd", " strtemp", "strtemp", "strPtr", "hexTemp", "strTem", "stringTest", "drTem", "brPtr", "strTr", "strMods", "strUnt", "frTem", "arrPtr", "txtTem", "hexTem"], "i": ["multi", "im", "x", "j", "init", "phi", "it", "ini", "ai", "a", "ic", "ui", "b", "q", "id", "y", "num", "ci", "gu", "ind", "mi", "ki", "uri", "qi", "ii", "v", "gi", "hi", "ti", "ji", "bi", "name", "index", "si", "I", "u", "ei", "yi", "m", "xi", "us", "iq", "di", "sim", "pi", "info", "chain", "ogi", "in", "cli", "li", "c", "\u0438", "ix"]}}
{"id1": "3683344", "id2": "5274228", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandUID", " genRandomSID", " genRandUU", " genRandomUID", " genRandomRandomID", " genRandGuid", " genRandomUuid", " genRandomGU", " genRandGUID", " genRandomGuid", " genRandomSuid", " genRandomUU", " genRandUuid", " genRandomGID", " genRandomSUID", " genRandGU", " genRandGID", " genRandomUUID", " genRandomRandomUID", " genRandomRandomU", " genRandUUID", " genRandomRandomuid", " genRandomSU"], "secure": [" Secure", "close", "prime", "sync", "force", "strong", "ie", "sys", "nice", "weak", "id", "free", "pretty", "ssl", "encrypted", "security", "client", "Secure", "deep", "server", "quiet", "confirmed", "stable", "clear", "trust", "google", "protect", "sec", "sr", "check", "speed", "status", "domain", "active", " securely", "https", "safe", "sensitive", " insecure"], "valueBeforeMD5": ["valueBeforeMM5", "valueBeforeND3", "valueAfterND4", "valueBeforeMD2", "valueAfterND3", "valueBeforeSHA523", "valueUnderMD5", "valueBeforeND0", "valueAfterMDInvalid", "valueUnderMM0", "valueBeforeDER0", "valueBeforeMM25", "valueAfterMD523", "valueUnderMD0", "valueAfterND5", "valueBeforeDER5", "valueAfterDER2", "valueBeforeND25", "valueAfterDER5", "valueBeforeSHA5", "valueBeforeMD4", "valueUnderMM5", "valueAfterMD0", "valueAfterMD4", "valueBeforeMODFive", "valueBeforeMT0", "valueBeforeND4", "valueBeforeID5", "valueBeforeSHAInvalid", "valueBeforeMDInvalid", "valueBeforeMT25", "valueBeforeDER2", "valueBeforeMT5", "valueUnderMM25", "valueBeforeMOD2", "valueBeforeMD3", "valueBeforeMTFive", "valueBeforeSHA2", "valueBeforeMD0", "valueBeforeMT2", "valueBeforeMD25", "valueUnderMD25", "valueBeforeMM0", "valueBeforeID4", "valueBeforeRDInvalid", "valueAfterDERFive", "valueBeforeID3", "valueBeforeRD2", "valueAfterMD3", "valueBeforeMD523", "valueBeforeMOD5", "valueAfterMD2", "valueBeforeID2", "valueBeforeMDFive", "valueAfterMDFive", "valueBeforeND2", "valueBeforeDERFive", "valueBeforeND5", "valueBeforeMOD0", "valueBeforeRD5", "valueAfterND2", "valueBeforeRD523", "valueAfterDER0"], "valueAfterMD5": ["valueBeforeMM2", "valueBeforeMM5", "valueWithoutMD5", "valueafterEM5", "valueAfterMDODY", "valueBeforeMD2", "valueafterEMLeft", "valueAfterSDRL", "valueBeforeMM3", "valueAfterMI2", "valueBeforeMC5", "valueAfterEM2", "valueAfterEM55", "valueAfterUDODY", "valueAfterMC5", "valueAftermd2", "valueBeforeMDdown", "valueAfterMDPE", "valueAfterMIOK", "valueAfterMT55", "valueAfterMDLeft", "valueAfterCDdown", "valueAfterMD55", "valueAfterEM5", "valueAfterMC3", "valueAftermd5", "valueAfterUDRL", "valueafterMDLeft", "valueBeforeMD8", "valueAfterMT2", "valueBeforeMC2", "valueBeforeMD4", "valueAfterUD3", "valueWithoutmd2", "valueAfterSDODY", "valueAfterMD4", "valueAfterMCdown", "valueWithoutmdPE", "valueAfterMT5", "valueBeforeMDODY", "valueBeforeMD3", "valueAfterMDRL", "valueAfterMD8", "valueAfterMM2", "valueAfterSD3", "valueAfterMTdown", "valueAfterUD5", "valueAftermdOK", "valueAfterMM5", "valueAfterMC4", "valueAfterMC8", "valueAfterMTLeft", "valueBeforeMDRL", "valueBeforeMCdown", "valueAfterMM3", "valueAfterCD5", "valueafterMD55", "valueWithoutMD2", "valueafterMD5", "valueAfterMD3", "valueAfterMI5", "valueAfterMT8", "valueAfterMD2", "valueAftermdPE", "valueAfterMC2", "valueAfterMT3", "valueWithoutmdOK", "valueafterEM2", "valueAfterCD2", "valueAfterSD5", "valueAfterMM4", "valueAfterMDOK", "valueAfterEMLeft", "valueBeforeMM4", "valueafterMD2", "valueWithoutMDPE", "valueAfterMIPE", "valueWithoutMDOK", "valueWithoutmd5", "valueAfterMDdown", "valueafterEM55"], "md5": [" md25", "MD3", " md2", " md7", "dig3", "metadata2", "md25", "MD2", "MD7", " MD3", " md3", " MD7", "md7", "MD25", "dig2", "md2", " MD2", " MD5", "metadata25", "metadata3", "MD5", "dig5", "metadata5", "md3"], "sbValueBeforeMD5": ["sbValueBeforeMDOK", "sbValueDefMD5", "sbValueFrontMD5", "sbValueBeforeMS5", "sbValueBeforeANDFive", "sbValueBeforeMS45", "sbValueBeforeAND5", "sbValueBeforeMON512", "sbValueBeforeMD512", "sbValueAfterMDOK", "sbValueAfterMDLE", "sbValueFrontMD20", "sbValueBeforeMON305", "sbValueDefMD2", "sbValueInsideAMD512", "sbValueBeforeND2", "sbValueBeforeMD65", "sbValueBeforePDLE", "sbValueDefMD45", "sbValueBeforeMON2", "sbValueFrontMD2", "sbValueBeforeMED3", "sbValueBeforeMEDNot", "sbValueInsideMD5", "sbValueBeforeSD5", "sbValueBeforeMED45", "sbValueBeforeMOD45", "sbValueBeforemdLE", "sbValueBeforeAND05", "sbValueInsideMD512", "sbValueBeforeMED2", "sbValueBeforeMT65", "sbValueBeforeMED25", "sbValueFrontLM2", "sbValueBeforeMS3", "sbValueDefmd2", "sbValueBeforeMD05", "sbValueBeforeLM65", "sbValueInsideMD2", "sbValueBeforemd2", "sbValueBeforeMOD5", "sbValueFrontLM5", "sbValueBeforeMT5", "sbValueInsideAMD2", "sbValueBeforeMD2", "sbValueBeforePD2", "sbValueBeforeMOD3", "sbValueInsideMD305", "sbValueBeforeMT20", "sbValueBeforeMS25", "sbValueBeforePDOK", "sbValueBeforeND45", "sbValueAfterMS3", "sbValueBeforeMDNot", "sbValueBeforeLM20", "sbValueBeforeAMD5", "sbValueAfterMDFive", "sbValueBeforePD5", "sbValueInsideAMD5", "sbValueAfterMS45", "sbValueBeforeLM2", "sbValueAfterMS5", "sbValueAfterMD2", "sbValueAfterMD05", "sbValueAfterMS25", "sbValueBeforeAMD2", "sbValueBeforeSDNot", "sbValueBeforemd45", "sbValueBeforeMT2", "sbValueBeforeMD20", "sbValueBeforeMOD25", "sbValueInsideAMD305", "sbValueBeforeMDFive", "sbValueBeforemd5", "sbValueBeforeAMD512", "sbValueAfterMD5", "sbValueBeforeMED5", "sbValueBeforeSD2", "sbValueBeforeMT05", "sbValueBeforeAND2", "sbValueBeforeMD45", "sbValueBeforeAMD305", "sbValueDefmd5", "sbValueBeforeMDLE", "sbValueBeforeMD25", "sbValueAfterMD25", "sbValueBeforeMD3", "sbValueBeforeND5", "sbValueAfterMDNot", "sbValueBeforeMD305", "sbValueFrontLM65", "sbValueDefmd45", "sbValueBeforeMTFive", "sbValueBeforemdOK", "sbValueAfterMD3", "sbValueFrontLM20", "sbValueBeforeMON5", "sbValueFrontMD65", "sbValueAfterMD45", "sbValueBeforeLM5"], "time": ["TIME", "window", "timeout", "counter", "now", "user", "hour", "times", "id", "runtime", "duration", "size", "frame", "Time", "t", "etime", "total", "lock", "timer", "length", "clock", "name", "tc", "estamp", "ime", "event", "sequence", "rate", "tim", "date", "port", "value", "race", "system", "year", "order", "age", "start", "ts", "ty"], "rand": ["dr", "rh", "reg", "fine", "nd", "rss", "kick", "init", "sys", "and", "rid", "seed", "roll", "id", "grad", "pick", "rc", "inv", "sample", "pid", "rd", "std", "mid", "with", "ripp", "rank", "nt", "cr", "rest", "frac", "rt", "gz", "trust", "dist", "rot", "uid", "round", "md", "rate", "sid", "gt", "hash", "did", "max", "z", "range", "random", "res", "r", "ng", "Rand"], "array": ["collection", "rays", "our", "assets", "binary", "save", "instance", "var", "ary", "arrow", "ashes", "row", "area", "map", "arr", "v", "length", "RAY", "aster", " Array", "at", "atomic", "angle", "share", "external", "number", "storage", "vector", "upper", "Array", "batch", "string", "amount", "angular", "hash", "stage", "archive", "value", "ami", "range", "stack", "app", "data", "random", "aw", "audio", "ray", "list", "ash"], "strTemp": ["stringUnt", "brTemp", " strCmd", "arrMods", " strUnt", " strTem", " strTr", "drPtr", "stringPtr", " strTest", "strTemplate", "brTem", "txtTemp", "arrUnt", "strTest", "frTemplate", "STRTemp", "strCmd", "arrtemp", "stringTem", "hexTr", "brTemplate", " strPtr", "stringTemp", " strTemplate", "arrTem", "STRtemp", "arrTest", "arrTemp", "STRTem", "txtTr", "txtCmd", "arrNew", "STRNew", "strNew", "drMods", "frPtr", "stringMods", " strNew", "drTemp", "frTemp", "hexCmd", " strtemp", "strtemp", "strPtr", "hexTemp", "strTem", "stringTest", "drTem", "brPtr", "strTr", "strMods", "strUnt", "frTem", "arrPtr", "txtTem", "hexTem"], "i": ["multi", "im", "x", "j", "init", "phi", "it", "ini", "ai", "a", "ic", "ui", "b", "q", "id", "y", "num", "ci", "gu", "ind", "mi", "ki", "uri", "qi", "ii", "v", "gi", "hi", "ti", "ji", "bi", "name", "index", "si", "I", "u", "ei", "yi", "m", "xi", "us", "iq", "di", "sim", "pi", "info", "chain", "ogi", "in", "cli", "li", "c", "\u0438", "ix"]}}
{"id1": "21092340", "id2": "23215235", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addToHariver", "addToExFile", "addInHariver", "addToExiver", "addToExive", "addInArchive", "addInHarZip", "addToZipiver", "addToArchFile", "addToZipFile", "addToArchZip", "addToArchiver", "addInArchiver", "addInHarive", "addToHarive", "addToExZip", "addToHarFile", "addToHarZip", "addInArchZip", "addToZipive", "addInArchFile", "addInHarFile", "addToZipZip"], "pod": ["proc", "message", "disk", "top", "task", "volume", "pkg", "od", "zone", "body", "p", "pick", "wp", "report", "op", "spec", "component", "pack", "module", "ods", "poll", "post", "cp", "ack", "policy", "pc", "project", "check", "point", "device", "archive", "table", "job", "pad", "start", "Pod", "ad"], "podArchiveOutputStream": ["podArchiverOutputMap", "podArchiveEntryStream", "podArchiveResourceContext", "podArchiveInputStream", "podArchiverInputSync", "podArchiveOutputStreamer", "podArchiveOUForm", "podArchiverInputStreamer", "podArchiveStreamForm", "podArchiveOutStream", "podArchiveStreamSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiveoutputForm", "podArchiveOUStream", "podArchiveOutputstream", "podArchiverOutputStreamer", "podArchiveOutputMap", "podArchiveStreamStream", "podArchiveOutContext", "podArchiveoutputStreamer", "podArchiverOutputPoint", "podArchiveOutPoint", "podArchiveResourceSteam", "podArchiveMainStreamer", "podArchiveOUMap", "podArchiveoutputStream", "podArchiveInputContext", "podArchiveoutputSteam", "podArchiveMainSteam", "podArchiveOutputSteam", "podArchiverOutputSync", "podArchiveInputStreamer", "podArchiveOutputSync", "podArchiverOutputSteam", "podArchiveMainStream", "podArchiverInputContext", "podArchiveOutputContext", "podArchiveInputForm", "podArchiveResourcestream", "podArchiveOutstream", "podArchiveOutputForm", "podArchiverInputSteam", "podArchiveInputSteam", "podArchiveOutSteam", "podArchiveInputMap", "podArchiverInputMap", "podArchiveInputPoint", "podArchiveEntryPoint", "podArchiveMainForm", "podArchiverInputStream", "podArchiverInputPoint", "podArchiverOutputContext", "podArchiverOutputForm", "podArchiverOutputStream", "podArchiveOUSync", "podArchiveResourceStream", "podArchiverInputstream", "podArchiveInputstream", "podArchiverOutputstream", "podArchiveInputSync", "podArchiveEntrySteam", "podArchiveStreamMap"], "filename": ["fn", "path", "nil", "message", "output", "binary", "description", "location", "prefix", "jpg", "fil", "title", "latest", "nm", "p", "FN", "Filename", "folder", "fp", "stem", "subject", "uri", "resource", "png", "NAME", "ename", "ame", "release", "key", "name", "original", "version", "println", "upload", "username", "family", "txt", "directory", "kl", "FILE", "string", "archive", "file", "names", "url"], "source": ["series", "ser", "proc", "style", "password", "template", "SOURCE", "force", "seed", "address", "shell", "body", "loader", "ource", "sql", "sample", "iterator", "from", "use", "resource", "spec", "Source", "component", "src", "inner", "store", "view", "get", "service", "stream", "sequence", "copy", "input", "select", "file", "info", "context", "start", "image", "supp"], "entry": ["ment", "task", "cell", "or", "cue", "book", "se", "ent", "ie", "link", "tmp", "attribute", "connection", "sheet", "ry", "row", "ce", "card", "element", "channel", "resource", "nt", "component", "key", "ace", "quick", "char", "obj", "good", "record", "enter", "line", "set", "archive", "file", "log", "job", "comment", "system", "query", "data", "Entry", "word", "zip"]}}
{"id1": "4716110", "id2": "19134229", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFile", " copyingPath", "cpfile", " CopyResource", " CopyPath", " copyPath", " copyingFile", " copyingResource", "cpResource", " copyResource", " Copyfile", " copyingfile", " CopyFile", " copyfile", "cpPath"], "in": ["IN", "on", "din", "gin", "n", "it", "rin", "is", "ic", "vin", "b", "old", "id", "o", "en", "inc", "from", "mm", "ind", "ins", "ar", "el", "up", "edIn", "isin", "l", "r", "In", "input", "source", "i", "inn", "inf", "cin"], "out": ["output", "ch", "n", "Out", "it", "b", "p", "o", "to", "os", "io", "ex", "outs", "t", "v", "serv", "ou", "nt", "at", "str", "w", "l", "k", "net", "err", "OUT", "check", "gt", "ne", "file", "log", "po", "i", "oss", "ot", "s"], "sourceChannel": ["srcChannel", "sourceButton", "sourceGate", "srcChan", "localConnection", "fromChain", "sourceChain", " sourcechannel", "ourceChannel", "SourceStream", "srcButton", "ourceButton", "sourceChan", "srcchannel", "sourceChuck", "localChuck", "givenStream", "fromConnection", "Sourcechannel", "scopeConnection", "SourceChannel", "sourceStream", "sourcechannel", "localChain", "ourcechannel", "SourceGate", "localChannel", " sourceGate", "scopeChan", "givenChannel", "SourceChuck", "fromChannel", "scopechannel", " sourceConnection", "ourceChan", "givenConnection", " sourceStream", "givenGate", "SourceChan", "SourceConnection", "fromChuck", " sourceChan", " sourceButton", "SourceChain", "scopeChannel", "sourceConnection"], "destinationChannel": [" destinationClient", " destinationContext", " destensionContext", "destinatedChannel", "destinationClient", "destensionClient", "destensionChan", "destinatedEntry", "DestinationConnection", "destinatedClient", "destationConnection", "destructionChannel", "destensionContext", "destinationsChan", " destensionChannel", " destinationEntry", "Destinationchannel", "DestinationChannel", " destinationchannel", "DestensionConnection", "destinatedContext", "destinationsChannel", "destensionchannel", "destensionConnection", "destructionClient", "destinationchannel", "destinationsEntry", "destinatedchannel", "Destensionchannel", "destinationContext", "destensionChannel", "destinationEntry", " destensionChan", " destinationChan", "destationChan", "destationChannel", "DestensionClient", "destationContext", "destinationChan", "destinationschannel", "destationchannel", "DestensionChannel", "destinatedChan", " destensionClient", "DestinationClient", "destructionConnection", "destinationConnection", "destationClient", "destructionchannel"]}}
{"id1": "13757855", "id2": "9236363", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["proc", "load", "task", "step", "add", "replace", "save", "build", "apply", "loop", "filter", "processor", "create", "execute", "transform", "run", "Process", "call", "processing", "write", "project", "render", "parse", "format", "display", "handle"], "tpl": ["stpg", "tpg", "stspl", "tpr", " tld", "tpp", "stbl", "atuple", "timpl", "tuple", "terpl", "tld", "ttplug", "tyPL", "timspl", "ptplates", "terplate", "ttPL", "Tpp", "itplate", "Tph", "ptld", "itbl", "topl", "ttpl", "stopl", "tembl", "Tld", "Tbl", "atplate", "TPL", "Tspl", "itpl", "templ", "otpl", "tmbl", "ttph", "tspr", "tmpl", "teruple", "otld", "tmpp", "stplate", "tempr", "temPL", "itPL", "atpl", "tplug", "tbl", "timbl", "Tpr", " tpp", "ptbl", "ptpl", "ttbl", "atld", "otplate", "timplate", "tph", "Tpl", "tspl", "tsPL", "tsbl", "tmplate", "ttpg", "stpl", "Tplate", "ttopl", " tuple", " tplate", "tplate", "timopl", "Tplates", " turtle", "turtle", " tbl", "typl", "stplug", "timplug", "timpg", "tmPL", "terld", "tPL", "otbl", " tPL", " tph", "tmplates", "tyurtle", "tplates", " tplates", "tsurtle"], "model": ["node", "html", " models", "product", "ml", "M", "el", "parent", "content", "tree", "module", "md", "Model", "record", "base", "project", "models", "object", "m", "file", "log", "document", "data", "Document", " Model"], "packageName": ["PackageClass", "PackageName", "groupName", " packageNames", "packageClass", "viewName", "packagename", "viewClass", " packageVersion", "PackageRoot", " packageFamily", "viewname", "groupFamily", "packageNames", "pkgFamily", "viewRoot", "groupNames", "groupVersion", "Packagename", "packageRoot", "pkgNames", " packageClass", "packageVersion", "pkgName", "packageFamily", " packageRoot", "pkgVersion", " packagename"], "outFileName": ["outfilePath", "outStreamPath", " outTableName", "outTablename", "outFilenameChain", "outDirName", " outFilenameType", "outImagePath", "outFilenameTime", "outImageSize", "outTableName", " outFileTime", "infileType", " outFileNames", " outTableSize", "outDirPath", "outStreamName", "outStreamTime", "outFileTime", "outFilenamename", "inFileTime", "outFilenameType", " outfileName", "outfileType", "outfileTime", "outFilenameNames", "outFileChain", "outStreamNames", "outfileChain", " outfilePath", " outTablePath", "outFName", "outTableType", "outfileName", "inFileNames", "outTableChain", "outFPath", "inFileName", " outfilename", " outFilename", "outImageName", "infilePath", "outFileType", "outTableSize", " outFilenamePath", " outFilenameSize", "outfilename", "outFileNames", "inFileType", " outFileType", " outFileChain", "infileNames", " outfileNames", " outFilenameName", "outDirTime", " outFilePath", "outFilenameName", "outFilenameSize", "infileTime", " outTableTime", "infileName", "outFileSize", "outFilename", "outTablePath", "outImagename", "outFNames", " outFileSize", "outFilenamePath", "outStreamType", "outFilePath", " outFilenamename", "outFname", " outFilenameChain", "outfileNames", "inFilePath", "outTableTime", "outDirSize"], "xsltParam": ["xsmlConf", "xltParameter", "xsmlParam", "xsmlParameter", "xsqlParam", "xsqlConf", "xmlConf", "xsltConf", "xltConf", "xsltParameter", "xsslParam", "xsqlParameter", "xltParam", "xmlParam", "xsslParameter", "xsslConf", "xmlParameter"], "artifact": ["ardifacts", " artificial", "artifacts", "arifacts", "anificial", "ardifact", " artifacts", "partifacts", "partifact", "anifact", "ardificial", "anificate", "anifacts", "Artifacts", "artificial", " artificate", "arifact", "ardificate", "Artifact", "artificate"], "destinationPath": ["destinationLog", "destinatedKey", "destinateNow", "estinationPart", "destociationForm", "termininerTarget", "destinationNow", "generinateJar", "desturationPath", "destinateLog", "destinationName", "origininatedNow", "destinationPoints", "destitutionPATH", "destesticSystem", "destinationAt", "identinatePath", "destinatorpath", "destociationpath", "destinationInfo", "destinateKey", "destificationUrl", "chaininatedHome", "desticationPath", "desturationTarget", "destinatedDisk", "destositoryHost", "destinantDir", "destregationPath", "destinatedTarget", "destinateTime", "destinatedInfo", "estinoPath", "destinationPod", "destionPATH", "DestinationDir", "estionpath", "generinateSystem", "chaininationHome", "estinationTime", "descinationPath", "destinateName", "estionPoint", "destinationHost", "destationDir", "descinationHost", "termininerpath", "destinationJar", "destinerHost", "destATIONHost", "destinatorKey", "destinationTarget", "destinatepath", "destociationTarget", "origininatedForm", "identinateKey", "DestensionPod", "chaininationPath", "destationPath", "estationDir", "destociationHost", "destinoPath", "destensionTemp", "generinationPath", "chaininationDriver", "destranceLog", "destociationPoint", "destinatorHost", "termininerJar", "origininationNow", "destositoryPath", " destinationTarget", "destinateForm", "origininationPath", "destitutionPoint", "destationLocation", "delinatePoints", "destensionPoint", "destionpath", "termininationTarget", "origininationChain", "destATIONPath", "destinantPath", "destociationDriver", "identinationKey", "destinationUrl", "destociationPath", "DestinationTemp", " destociationTarget", "estinationDir", "estinoKey", "destinationForm", "destinatePoints", "chaininationDisk", "destesticPath", "identinationChain", "desticationDir", "termininerPath", "DestificationUrl", "destociationDir", "destinateDir", "DestinationUrl", "destinationTime", "destociationPoints", " destinationDisk", "destinerTarget", "estinationHost", "destinationLocation", "destinerpath", "destinationDriver", "descositoryPort", "destationHost", "destigationPath", "destensionPath", "DestensionDir", "destinatedChain", "destregationTarget", "destinateChain", "DestensionTemp", "chaininatedDriver", "destventionHome", "destinoHost", "destinatePart", "destationPart", "destinationPATH", "destventionPath", "destventionDisk", "identinationInfo", "destATIONParent", "destinatedForm", "destinateAt", "estionPath", "destesticJar", "destinoName", "DestinationLocation", "destinatedNow", "destinationParent", "generinationAt", "DestinationPoint", "destinateTarget", " destociationPath", "destigationChain", "estationHost", "delinatePath", "destinatorPort", "origininatedChain", "DestinationPod", "estinationpath", "descinationPort", "destinateSystem", " destinationpath", "origininationForm", "estinationKey", "DestensionPath", "delinationPath", "destinatedpath", "termininationPath", "destinatedPath", "desturationJar", "DestificationDir", "generinationJar", "destitutionpath", "destositoryPort", "destinoTime", "destacementPath", "termininationpath", "delinationPoints", "destranceForm", "destigationNow", "destinationKey", "destinatorChain", "destesticAt", "estinationPath", "DestificationLocation", "destinerSystem", "destinatorPATH", "destinerJar", "destacementKey", "delinationForm", "desticationTemp", "descositoryParent", "destinationDisk", "destionPath", "destinateUrl", "destociationDisk", "generinationSystem", "destATIONPort", "destinerDir", "DestinationHost", "descinationParent", "destventionDriver", "destinateJar", "destinateHost", "estinationPATH", "destinationPart", "destinerPart", "generinatePath", "destinationHome", "destinateLocation", "origininatedPath", "chaininatedDisk", "chaininatedPath", " destociationpath", "destinatorParent", "desticationPod", "destacementTime", "destinationSystem", "destitutionPath", "destinatedDriver", "DestinationPath", "estinationName", "identinationPath", "destinationpath", "delinateLog", "generinateAt", "destigationForm", "estationPath", "identinateChain", "destacementName", "destregationDisk", "identinateInfo", "estationPart", "DestensionPoint", "destionPoint", "delinateForm", "descositoryHost", "destensionDir", "destinatorInfo", "destrancePath", "destinantTemp", "estinoTime", "destationUrl", " destociationDisk", "destinoKey", "destinantPod", "DestensionHost", "destificationLocation", "descositoryPath", "termininationJar", "destinateInfo", "destinationPoint", "destinatePath", "destositoryParent", "destinationChain", "delinationLog", "destrancePoints", "estinoName", "destensionHost", "destociationLog", "destinerPath", "destinationDir", "estinationPoint", "destificationDir", "destinatorPath", "destinatorPoint", "destregationpath", "destinerAt", "destinoDir", "destociationHome", "DestificationPath", "estionPATH", "desturationpath", "destinationPort", "destensionPod", "destinoPoint", "destificationPath", "destinatedHome", "destinationTemp"], "in": ["IN", " IN", "din", "n", "f", "id", "o", "io", "ins", "t", "bin", "inner", "doc", "reader", "d", "w", "l", "r", "In", "input", "m", "file", "i", "info", "c"], "out": ["output", "ch", "gr", "list", "con", "ger", "or", "ln", "n", "Out", "dis", "it", "msg", "sys", "b", "f", "raw", "can", "p", "o", "aos", "inv", "to", "os", "io", "ex", "outs", "ins", "nr", "t", "client", "up", "cfg", "v", "ou", "nt", "oe", "all", "e", "write", "null", "inner", "writer", "println", "w", "screen", "l", "u", "obj", "go", "err", "net", "c", "conn", "print", "OUT", "conf", "cn", "cache", "file", "log", "co", "s", "res", "outer", "cmd", "report", "gen"], "root": ["json", "node", "parents", "se", "config", "graph", "id", "p", "dir", "roots", "create", "Root", "New", "ok", "initial", "scope", "parent", "tree", "group", "name", "impl", "Template", "dump", "println", "_", "child", "m", " roots", "def", "table", "chain", "data", "context", "start", "r", "de"]}}
{"id1": "5551393", "id2": "21316706", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "label": 0, "substitutes": {"getMD5": ["getSHA2", "getMD4", " getMD3", "getSHA4", "getmd2", "getmd4", "getSHA5", " getMD2", " getMD4", "getMD2", "getmd5", "getmd3", "getMD3", "getSHA3"], "source": ["output", "message", "style", "text", "site", "reason", "space", "template", "now", "config", "SOURCE", "force", "seed", "body", "ource", "sample", "from", "subject", "resource", "filename", "Source", "spec", "content", "src", "name", "sequence", "base", "string", "input", "object", "file", "value", "target", "data", "s", "url", "context", "start", "image"], "tmp": ["output", "db", "attr", "nd", "buf", "qq", "img", "msg", "pkg", "tt", "tar", "bag", "p", "np", "test", "aaa", "cv", "bb", "MP", "t", "resp", "bt", " mp", "buff", "etc", "nt", "cmp", "src", "cp", "cb", "gb", "perm", "mp", "obj", "snap", "txt", "mk", "tn", "managed", "Temp", "result", "cont", "input", "rup", "m", "po", "sp", "mobi", "foo", "data", "jp", "found", "out", "lambda", "temp", "pp", "cache"], "md": ["dr", "pm", "ms", "nd", "pdf", "sd", "bd", "od", "and", "ad", "MD", "der", "cd", "wd", "desc", "mm", "dm", "mt", "ind", "rm", "red", "sm", "dh", "nt", "det", "ld", "dd", "d", "mb", " Md", "mac", "td", "mp", "mk", "amd", "mod", " MD", "pd", "m", "df", "sam", "di", "mn", "mand", "cmd", "hd", "de"]}}
{"id1": "1954410", "id2": "21608109", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"doExecute": ["doEditute", "doCommutes", "doCommExec", "DoExecute", "DoExecit", "doCommit", "DoExecutes", "doExecutes", "doExecit", "doEditit", "DoExecExec", "doExecExec", "doEditutes", "doCommute", "doEditExec"], "mapping": ["smappings", " mappings", "mapper", "Mappings", "mapped", " mapped", "Mapper", "Mapped", " mapper", "smapped", "mappings", "Mapping", "smapper", "smapping"], "form": ["path", " forms", "orm", "session", "owner", "self", "template", "config", "type", "f", "raw", "forms", " Form", " FORM", "subject", "map", "Form", "parent", "fc", "view", "formed", "command", "FORM", "m", "sam", "app", "format"], "request": ["http", "window", "se", "instance", "sw", "parent", "version", "upload", "Request", "query", "url", "report", "QUEST", "template", "create", "allow", "this", "impl", "quest", "container", "_", "w", "remote", "project", "def", "document", "application", "session", "Upload", "model", "address", "Exception", "reset", "frame", "client", "resource", "current", "server", "xml", "view", "input", "first", "order", "question", "message", "open", "user", "reference", "true", "initial", "req", "store", "post", "cont", "command", "context", "host"], "response": ["output", "message", "application", "session", "connection", "send", "ce", "re", "respond", "frame", "resp", "server", "content", "write", "view", "xml", "Response", "result", "print", "status", "reply", "sp", "document", "success", "res", "report"], "errors": [" mess", " steps", " messages", " success", " managers", " logs", " messenger", " sessions", " manager", " storage", " changes", " fails", " requests", " flashes", " status", " statements", " error", " states", " problems", " state", " warnings", " flash", " updates", " moves", " elements", "Mess", "ages", " Messages"], "isMultipart": ["isMultipod", "isMultipain", "isMultIPare", "isMultiade", "isMultiplod", "isMultiIPod", "isMultifarts", "isMultiparts", "isMultosparts", "isMultiipart", "isMultiIPade", "isMultipare", "isMultIPain", "isMultiarts", "isMultifare", "isMultiIPain", "isMultiplarts", "isMultiIPare", "isMultiIPart", "isMultIPade", "isMultiiparts", "isMultifart", "isMultiipare", "isMultospart", "isMultIParts", "isMultospain", "isMultiart", "isMultiipain", "isMultiod", "isMultospare", "isMultiplade", "isMultIPod", "isMultipade", "isMultiplart", "isMultiipade", "isMultifain", "isMultiipod", "isMultiIParts", "isMultIPart"], "mailInstance": ["flexance", " mailance", " mailInst", "mailinstance", " mailBuilder", " MailInstance", " Mailinstance", "emailance", "emailBuilder", "mailance", " MailBuilder", "flexInstance", "mailInst", "flexinstance", "flexInst", "emailinstance", " MailInst", "mailBuilder", "emailInstance", "emailInst", " mailinstance"], "fields": ["field", "states", "faces", "strings", "links", "balls", "properties", "headers", "workers", "types", "orders", "posts", "users", "ports", "locks", "checks", "prints", "plugins", "drivers", "comments", "images", "frames", "sections", "qs", "forms", "rows", "boxes", "rules", "views", "flags", "pages", "packs", "files", "dates", "lists", "bits", "lines", "tags", "classes", "levels", "packages", "tests", "holders", "features", "members", "terms", "days", "keys", "parts", "details", "models", "reports", "phones", "relations", "lights", "modules", "names", "groups", "atts", "objects", "services"], "attachments": ["achensions", "attensions", " attachions", "payances", " attachresses", "attitions", "attachMENTS", "payements", "attachitions", "acheements", "attachensions", "Attachments", " attachements", "attachions", "achMENTS", "acheances", "Attachresses", "achements", "attMENTS", " attachitions", "AttachMENTS", " attachances", "payitions", "achitions", "Attachions", "achments", "attachresses", "attachements", "payments", "achresses", "attments", "achions", "Attachensions", "attachances", "Attachitions", "acheitions"], "items": ["cases", "links", "orders", " Items", "images", "Items", " images", "its", "rows", "pages", "qs", "files", "lines", "tests", "packages", "photos", " files", "actions", "ids", " results", "members", "ips", "archives", "keys", "parts", "reports", "phones", "apps", "resources", "results", "names", " samples", " inputs", "issues", "groups", "events", "objects", "services"], "iter": ["each", "ser", "ite", "ator", "iner", "init", "it", "Iter", "loop", "orient", "li", "its", "read", "iterator", "test", "maker", "altern", "re", "older", "ind", "dir", "er", "oper", "loc", "el", "cmp", "inner", "store", "writer", "ait", "reader", "inter", "coll", "ipper", "tr", "ter", "Iterator", "result", "tif", "upper", "ner", "former", "set", "gener", "i", "walker", "outer", "list", "order"], "item": ["cell", "member", "instance", "it", "change", "attribute", "att", "element", "atom", "inner", "other", "status", "file", "job", "url", "word", "zip", "on", "json", "internal", "or", "template", "link", "entity", "claim", "row", "ex", "group", "name", "obj", "anything", "details", "entry", "object", "data", "ip", "attr", "add", "local", "area", "mm", "er", "resource", "up", "rule", "xml", "unit", "one", "page", "stat", "app", "order", "step", "addr", "type", "detail", "raw", "Item", "initial", "el", "spec", "key", "related", "store", "module", "event", "record", "layer", "match", "info", "image", "ix", "single"], "aux": ["af", "eu", "abs", "cu", "auto", "used", "uds", "aim", "aos", "area", "av", "airs", "au", "ex", "AU", "etc", "ox", "lim", "aff", "buff", "fax", "uf", "du", "aus", "ax", "fx", "net", "fuck", "imp", "pet", "extra", "tx", "us", "vers", "mu", "max", "fu", "uff", "ux", "off", "foo", "fam", "pad", "aw", "ras", "ups", "ix", "fat"], "part": ["top", "block", "member", "peer", "tmp", "and", "zone", "bound", "card", "parent", "component", "pre", "inner", "version", "job", " parts", "work", "art", "word", "list", "split", "pos", "pair", "photo", "group", "mod", "print", "partial", "object", "sp", "Part", "start", "temp", "html", "add", "prefix", "section", "worker", "person", "local", "relation", "PART", "pod", " Part", "pet", "tx", "join", "admin", "message", "party", "patch", "step", "pkg", "detail", "piece", "tab", "p", "api", "sample", "pt", "par", "wrapper", "comp", "parts", "half", "base", "point", "primary", "layer", "pad", "format"], "baos": ["booses", "baops", "waols", "boOS", "cao", "kaops", "pois", "bais", "waoss", "caOs", "bios", "taos", "taoss", "baols", "pooss", "kaoss", "bio", "bao", "booss", "baOs", "kais", "vaOs", "caoss", "caOS", "vaols", "boOs", "tao", "biOS", "boos", "kaos", "baOS", "poops", "vaoss", "caos", "poo", "baoses", "caols", "bioses", "vaos", "tais", "poOS", "taOs", "waOs", "baoss", "waos", "poos", "taops", "pooses", "boo"], "body": ["output", "buffer", "message", "binary", "text", "json", "html", "description", "mail", "plain", "template", "head", "header", "detail", "loop", "title", "shell", "send", "bill", "rel", "Body", "size", "subject", "note", "default", "ody", "t", "content", "summary", "pass", "tree", "null", "name", "post", "foot", "business", "base", "port", "file", "log", "ODY", "comment", "data", "format", "tail", "display", "scroll", "layout", "report"], "preferencesInstance": ["prefiesinstance", "preffiesinstance", "prefferencesinstance", "prefutesObj", "preferencesObj", "preffiesObj", "preffiesImpl", "prefancesInstance", "prefutesImpl", "prefancesObj", "preferencesinstance", "prefancesImpl", "prefutesInstance", "prefferencesImpl", "prefancesinstance", "prefiesInstance", "preferencesImpl", "prefferencesInstance", "prefiesImpl", "prefferencesObj", "prefutesinstance", "prefiesObj", "preffiesInstance"]}}
{"id1": "14688886", "id2": "20091126", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["populatesResources", "PopureResource", "populatedFiles", "populatesFiles", "populatedResource", "populatedReferences", "popureResource", "PopulateResource", "popureFiles", "populateResource", "populatesResource", "populatesReferences", "PopulateFiles", "popureReferences", "popureResources", "populateFiles", "PopureReferences", "populatedResources", "PopureResources", "PopulateResources", "populateReferences", "PopulateReferences", "PopureFiles"], "templates": ["typles", "timples", "tctions", "memples", "Temports", "sequplates", "Temples", "tmeters", "tiles", "timporary", "temeters", "teniles", "Temmen", "filports", "tmports", "temctions", "sequeters", "memeters", "filplates", "temmen", "teters", "tples", "memables", "tenables", "filples", " temctions", "tables", "temporary", "sequples", "tmporary", "temports", "tmmen", "sequporary", "tyables", "tenctions", " temiles", "tmples", "tenplates", "temables", "tyeters", "timeters", "tmplates", "memplates", "Templates", "filmen", " temables", "tplates", "typlates", "temiles", "timplates", "temples"], "url": ["path", "http", "mail", "html", "location", "term", "sl", "n", "a", "link", "item", "handle", "b", "ur", "Url", "f", "address", "ml", "URL", "p", "rel", "row", "pl", "ssl", "uri", "dl", "nl", "resource", "browser", "gl", "ref", "e", "key", "name", "mount", "mb", "ll", "get", "l", "u", "char", "base", "entry", "string", "rect", "m", "rl", "file", "web", "res", "r", "li", "pattern"], "fileName": ["fileFamily", "FILEname", "fBody", "filenamename", "fileLoad", "Filename", "tilename", "filenamePart", "fName", "ilePath", "fileTime", "FILEName", "moduleTitle", " filePath", "urlName", "FileString", "templateString", "blockname", "ileName", "urlPath", "fileKey", "tileName", "namePart", "FILELine", "blockLoad", "resourceName", "blockTime", "filenameParent", " fileFamily", "fileString", " filename", "namename", "FileFamily", " filePart", "moduleKey", "familyLoad", "FileFull", "fPath", "familyTime", "ileCopy", "urlFamily", "templateName", "filenameName", "fileBody", "urlKey", "FileName", "ileLine", "fileParent", "ilename", "fileTitle", "fileLine", " fileTime", " fileParent", "templatePath", "FilePath", "FileBody", "resourceKey", "filePath", " fileKey", "moduleName", "blockName", " fileType", "familyname", "tileCopy", " fileBody", "fileFull", "ileFull", "fname", " fileFull", "ilePart", "resourceTitle", "FilePart", "filePart", "FileKey", "resourceType", "filename", " fileLoad", "fileType", "templatename", "FILECopy", " fileTitle", "tileLine", "fileCopy", "nameParent", "moduleType", " fileString", "familyName", "nameName"], "templateResource": [" templateEntry", "documentResource", "TemplateReference", " templateReference", "TemplateResources", "TemplateProperty", "templateRes", "documentRole", "componentRes", "resourceEntry", "TemplateResource", "resourceRes", "resourceResource", "TemplateEntry", "componentResource", "componentResources", "resourceProperty", " templateProperty", " templateRes", " templateResources", "templateEntry", "templateReference", "componentReference", "resourceRole", " templateRole", "templateProperty", "documentRes", "templateResources", "TemplateRes", "templateRole"], "is": ["ais", "im", "es", "isc", "iso", "ris", "sels", "ri", "ic", "sys", "isl", "nis", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "are", "ins", "fr", "rs", "rys", "isf", "\u00eds", "Is", "ir", "fs", "iris", "us", "ios", "sis", "in", "isi", "IS"], "strBuff": ["arrComb", "drBuffer", " strComp", "stringBas", "brBuffer", "arrbuff", " strBu", "strBas", " strbuff", "Strbuff", "strFac", "arrFac", "strbuff", " strBuffer", "brComp", "stringBuffer", "arrBuffer", "drComp", "arrBas", "stringComb", "brBuff", "StrBuffer", "strBu", "strComp", "arrBuff", "StrBuff", "drBuff", "brBu", "stringBuff", " strBas", "StrFac", "strComb", " strComb", "strBuffer", "drBu", " strFac"], "br": ["ch", "wr", "gr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "bm", "bs", "BR", "bn", "bl", "hr", "pr", "er", "fr", "bt", "Br", "cr", "bg", "bro", "bi", "next", "ctr", "vr", "mr", "tr", "bc", "sr", "lr", "bh", "kr", "ber", "r", "yr", "rb"], "str": ["gr", "dr", "ust", "text", "st", "n", "sl", "msg", "draw", "del", "p", "St", "bl", "pr", "cs", "seq", "t", "arr", "fr", "pt", "spec", "cr", "stable", "g", "name", "ctr", "STR", "sts", "tr", "obj", "txt", "err", "cont", "print", "string", "set", "sp", "chain", "cert", "s", "ocr", "res", "r", "Str", "coll", "list"], "images": ["uploads", "ims", "assets", "faces", "vs", "ms", "games", "types", "versions", "times", " pictures", "rooms", "image", "frames", "pages", "boxes", "eds", "views", "xs", "amps", "ins", "files", "pins", "raphics", "styles", "photos", "actions", "ids", "ages", "scripts", " photos", "Textures", " Images", "reports", "apps", "resources", "videos", "modules", "media", "arms", "names", "blocks", "eps", "thumbnails", "atts", "items", "ups", "Images"], "i": ["http", "it", "qi", "gi", "status", "ij", "cli", "li", "j", "my", "ini", "ui", "this", "hi", "ti", "bi", "name", "_", "def", "us", "ami", "sim", "ip", "multi", "im", "n", "ie", "me", "Exception", "id", "ci", "ii", "index", "get", "u", "ei", "m", "xi", "pi", "x", "phi", "ai", "p", "y", "io", "mi", "gu", "ki", "v", "key", "si", "I", "mu", "di", "info", "ix"], "img": ["im", "html", "j", "jpg", "amp", "buf", "a", "pkg", "tmp", "gif", "f", "pg", "iam", "medium", "aug", "p", "small", "mg", "av", "bl", "att", "png", "fig", "fm", "bg", "g", "src", "gd", "mp", "obj", "md", "mk", "anim", "imp", "gm", "m", "file", "ami", "pic", "ij", "div", "r", "Image", "li", "image"], "imgProperty": [" tmpProp", "imageImage", " imgProp", "imageProperty", " imgImage", "imgProp", " imgPro", "imageProp", " tmpPro", "imgImage", " tmpImage", "imgPro", " tmpProperty", "imagePro"]}}
{"id1": "8132219", "id2": "11032546", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "Copyfile", " copyFiles", "CopyStream", "CopyFiles", " copyStream", "copyStream", " CopyStream", " Copyfile", " CopyFiles", "copyFiles", " CopyFile", " copyfile", "copyfile"], "inFile": ["inName", " inRow", "inputName", "innPath", "dinRow", "innFile", "inTemplate", "ninTemplate", " inEmail", "dinPath", "inputTemplate", "outFilename", "inputFilename", "inRow", "ninFilename", "ninName", " inPath", "ninFile", "inFilename", "innRow", "inputFile", "dinEmail", "dinFile", "outTemplate", "innEmail", "outName", "inPath", "inEmail"], "outFile": ["ouFILE", "ouFile", "outputFilename", "outputFILE", "outputFile", "outputFormat", "outputfile", "outputTable", "outTable", " outfile", "outFilename", "destfile", "inFilename", "destFormat", "outfile", "outFormat", " outFormat", "ouFilename", "inTable", "inFILE", "destFILE", "outFILE", "destFile", "ouTable", " outFILE"], "in": ["IN", "on", "din", "gin", "init", "it", "ini", "rin", "ai", "ic", "is", "ze", "sin", "old", "ain", "id", "o", "en", "inc", "from", "irm", "ind", "ins", "el", "up", "bin", "inner", "isin", "ir", "In", "input", "source", "i", "info", " din", "s", "inn", " input", "inf", "cin"], "out": ["output", "by", "n", "Out", "it", "b", "p", "can", "o", "aos", "to", "os", "en", "io", "ex", "outs", "t", "client", "v", "ou", "e", "all", "at", "g", "name", "w", "one", "net", "OUT", "gt", "ne", "file", "ot", "co", "res", "c"], "inChannel": ["vinCategory", " inButton", "sinCategory", "cinHandler", "inConnection", " inConnection", "vinChannel", "inColumn", "cinChannel", "newChannel", "insideChannel", "innCategory", "sinChannel", "cinStream", "inchannel", "inHandler", "insideHandler", "sinBlock", "inCategory", "innerConnection", "newCase", "ginPanel", "isinCase", " inchannel", "ginChannel", "inChan", "innerchannel", "ginCategory", "innerChan", "cinComponent", " inComponent", "outBlock", "sinColumn", "sinStream", "cinColumn", "outchannel", "newPanel", " inChan", "inBlock", "sinSlot", "inStream", "vinPanel", "cinButton", "outColumn", "isinChannel", "innCase", "inPanel", "inSlot", "isinSlot", "vinCase", "innChannel", "inComponent", "insideComponent", "innSlot", "outChan", "inCase", "outConnection", "insideButton", "outStream", " inHandler", "newCategory", "sinCase", "inButton", "isinCategory", "ginCase", "cinBlock", "innerChannel"], "outChannel": ["nChan", "exBlock", "outCh", " outBlock", "exChan", "OutChan", " outCh", "nchannel", "oPassword", "exChain", "OutChannel", "outputConnection", "OutConnection", " outStream", "inchannel", " outchannel", "oChan", "inChan", "OutCh", "outPassword", "outClient", "outBlock", "outchannel", " outConnection", "inStream", "exChannel", "nChannel", "nStream", "outputChan", " outPassword", " outChain", "outChain", " outChan", "outChan", "oClient", "oChannel", "outputChannel", "inPassword", "outConnection", " outClient", "outStream", "outputCh", "inClient"]}}
{"id1": "7103223", "id2": "17202157", "code1": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "code2": "    static Matrix readMatrix(String filename, int nrow, int ncol) {\n        Matrix cij = new Matrix(nrow, ncol);\n        try {\n            URL url = filename.getClass().getResource(filename);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            for (int i = 0; i < nrow; i++) for (int j = 0; j < ncol; j++) cij.set(i, j, Double.parseDouble(lnr.readLine()));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return cij;\n    }\n", "label": 0, "substitutes": {"testPost": ["TestPosts", " testPosts", " testRequest", "echoRequest", "testPosts", "echoPosts", "TestPost", "testRequest", "echoPost", "TestRequest"], "request": ["message", "http", "application", "load", "list", "template", "instance", "QUEST", "reference", "root", "claim", "complete", "reset", "create", "execute", "register", "resource", "initial", "insert", "call", "key", "req", "post", "quest", "get", "service", "position", "upload", "record", "enter", "print", "command", "project", "batch", "object", "Request", "copy", "job", "trip", "join", "document", "query", "search", "url", "remove", "ip", "begin", "report", "first", "question"], "response": ["output", "ve", "message", "http", "application", "social", "de", "json", "description", "block", "user", "onse", "connection", "see", "body", "sample", "relation", "respond", "answer", "pos", "resp", "client", "channel", "server", "exit", "tree", "version", "next", "view", "still", "service", "one", "respons", "sequence", "result", "Response", "remote", "command", "entry", "line", "that", "object", "status", "reply", "document", "data", "trace", "res", "soc", "report", "cache", "network"]}}
{"id1": "149935", "id2": "19251426", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["consverting", "converted", "converts", "Conversion", "converting", "compversion", "CONverting", "conprocess", "compprocess", "CONversion", "consversion", "consVERT", "unverted", "compverts", "CONfer", "ConVERT", "CONVERT", "Converting", "unprocess", "unvert", "unversion", "Converted", "unverts", "compvert", "conversion", "Convert", "conVERT", "unfer", "confer", "Conprocess", "Converts", "consvert", "CONvert", "CONverted", "Confer"], "src": ["path", "ser", "http", "attr", "st", "orig", "addr", "RC", "config", "SOURCE", "img", "pkg", "sys", "rx", "sin", "ur", "ource", "sc", "rel", "rc", "its", "scan", "scene", "from", "ebin", "buster", "uri", "ins", "loc", "filename", "Source", "rs", "iv", "rest", "dist", "req", "str", "stream", "upload", "txt", "href", "cont", "sit", "sr", "source", "input", "file", "cc", "ipl", "usr", "func", "inst", "s", "url", "start", "host", "hl", "sq", "SourceFile", "cur"], "dest": ["disk", "gin", "est", "orig", "img", " Destination", "dat", " orig", "dir", "test", "foreign", "write", "dist", " destinations", "txt", " destination", "result", "Dest", "tif", "source", "port", "table", "target", " dst", "mat", "temp", "rest", " Dest"], "in": ["IN", "din", "st", "rin", "is", "b", "as", "sql", "en", "io", "from", "ind", "ins", "ar", "el", "up", "bin", "serv", "inner", "reader", "d", "stream", "isin", "r", "l", "In", "input", "source", "m", "file", "i", "inn", "res", "inf", "ad", "cin"], "p": ["vp", "dp", "P", "pm", "per", "part", "ping", "j", "rep", "it", "pkg", "b", "prot", "f", "tp", "pg", "lp", "parser", "wp", "pa", "h", "fp", "pl", "pro", "er", "t", "op", "pt", "ps", "pre", "at", "g", "ap", "pb", "cp", "d", "post", "l", "pc", "c", "pe", "pd", "m", "ph", "parse", "i", "sp", "pi", "py", "pers", "jp", "php", "r", "pp"], "ds": ["loads", " ads", "workers", "ports", "bs", "iffs", "ss", "its", "aws", "dt", "obs", "lists", "yes", "ils", "dh", "ads", "terms", "ats", "nas", "dds", "tes", " dd", "db", "vs", " des", "des", "tp", "ws", "uds", "qs", "hs", "cs", "dl", "outs", "ks", "dd", "points", "pd", "edes", "ls", " d", "sd", "gs", " DS", "cks", "os", "Ds", "DS", "dates", "tests", "rs", "ags", "ods", "gd", "scripts", "d", "docs", "ands", "els", "ras", "ts", "dp", "posts", "drivers", "dos", "ys", "xs", "eds", "amps", "ps", "tags", "mys", "js", "ns", "sts", "df", "di", " os", "s", "eps", "hd", "sets"], "format": ["output", "path", "style", "top", "shape", "template", "it", "type", "title", "filter", "ct", "f", "id", "pretty", " Format", "size", "sche", "lat", "mt", "feat", "feature", "t", "Format", "spec", "mode", "fc", "fm", "tag", "settings", "at", "module", "version", "ats", "MAT", "unit", "name", "l", "policy", "form", "source", "set", "status", "table", "file", "parse", "pi", "cf", "layout", "act", "mat", "pattern"], "hasPixelData": ["hasFrameData", "HaspixelDATA", "HasPixelDATA", "HasPixelData", "hasixelDATA", "hasPixeldata", "hasixeldata", " hasPixelDATA", "hasPixelDATA", "haspixelData", "HasPixeldata", "Haspixeldata", " hasPixeldata", "haspixeldata", "hasFrameDATA", "haspixelDATA", "HaspixelData", "hasixelData", "hasFramedata"], "inflate": ["Inflated", "infolated", " invalidate", "Informate", "inFLate", " invalidicate", "invalidate", "inFLated", "Informated", "inflicate", "invalidicate", "informocate", "inflat", "invalidocate", "Inflate", "inflATE", "inflated", " inflicate", " inflATE", "informat", "informate", "Informat", "incelocate", "inFlate", "Informocate", "Inflat", "incelicate", "infolocate", "incelate", "inFlATE", "inFlocate", "inFLat", "inFLocate", " invalidATE", "incelATE", "infolate", "Inflocate", "informated", "invalidATE", "infolat", " inflocate", " invalidocate", "inflocate", "inFlicate"], "pxlen": ["xyln", "xylength", "mxdec", "packln", "packfun", "tmplen", "phplen", "mxlength", "cplength", "packlength", "pexls", "mmlength", "pexlen", "pxdec", "pixelfun", "pexfun", "tmpln", "mxlen", "pixellength", "pixellen", "pxden", "mmln", "xplen", "cplen", "packlen", "packls", "mmlen", "pixells", "pxls", "pxfun", "phplength", "phpln", "pexln", "pexlength", "pexden", "xplength", "pxlin", "mmlin", "phpdec", "pxlength", "xpden", "xpln", "tmplength", "cpden", "pxln", "packdec", "xylen", "tmplin", "cpln", "xylin", "mxln"], "out": ["output", "gr", "gov", "prefix", "init", "ln", "Out", "user", "msg", "sys", "pretty", "inv", "aos", "dir", "io", "ex", "outs", "crit", "client", "up", "cfg", "ou", "group", "writer", "store", "name", "inter", "screen", "sum", "obj", "net", "err", "conn", "print", "OUT", "log", "res", "outer", "cmd", "temp", "list"]}}
{"id1": "7118860", "id2": "20073619", "code1": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 1, "substitutes": {"getEncoding": ["getEncoder", " getEnReading", "getChording", " getEnoder", "getEncording", "getEnoder", "getEnReading", "getChReading", " getEncReading", " getEnording", " getEnoding", " getEncoder", "getChoder", "getIntegording", "getIntegReading", "getIntegoding", "getEnording", "getChoding", " getEncording", "getEnoding", "getEncReading", "getIntegoder"], "reader": ["runner", "buffer", "owner", "builder", "rar", "volume", "instance", "user", "peer", "worker", "author", "controller", "manager", "review", "holder", "rer", "loader", "parser", "read", "row", "iterator", "older", "creator", "er", "client", "resource", "liner", "server", "timer", "wrapper", "length", "operator", "library", "inner", "linger", "writer", "dd", "reading", "handler", "stream", "event", "rr", "redo", "Reader", "ner", "source", "loading", "upper", "iter", "rl", "layer", "driver", "ro", "range", "query", "r"], "encoding": ["enaging", "ecoder", "decoding", "entension", "capping", "cryption", "enumoder", "enoder", "encination", "integryption", "enmentation", "continoding", "decryption", "increoded", "increapping", "increignment", "decension", "ecapping", "entination", "encasting", "coded", "enumension", "octoding", "entoding", "ecryption", "encoded", "encryption", "entryption", "cacheoding", "equapping", "enination", "encaling", "cending", "octaging", "integmentation", "ecaling", "continryption", "entging", "enictionary", "encignment", "integoding", "encacing", "increging", "enoding", "enumacing", "octending", "entoded", "acacing", "encending", "encapping", "acoder", "ecoding", "encmentation", "acension", "enoded", "encictionary", "enging", "increoding", "equination", "encoder", "decaling", "caging", "continasting", "enasting", "encaging", "increictionary", "entapping", "enumoding", "cacheapping", "enapping", "enignment", "cacheictionary", "integapping", "enaling", "encging", "enending", "acoding", "enacing", "coding", "entoder", "ecasting", "enryption", "ecension", "equension", "cmentation", "octoded", "increoder", "enension", "equoding", "encension", "cacheignment", "continoder"], "connection": ["management", "application", "connect", "session", "ion", "Connection", "con", "close", "config", "open", "database", "link", "response", "statement", "generation", "condition", "reference", "socket", "console", "character", "relation", "uri", "client", "resource", "channel", "office", "writer", "communication", "opening", "number", "service", "position", "established", "online", "directory", "conn", "command", "remote", "document", "url", "context", "network"], "header": ["output", "buffer", "history", "dr", "http", "block", "term", "template", "head", "menu", "headers", "attribute", "heading", "filter", "metadata", "title", "holder", "environment", "h", "client", "initial", "request", "rule", "version", "hidden", "position", "policy", "dict", "event", "meta", "Header", "layer", "status", "table", "comment", "profile", "document", "info", "column", "handle", "hd", "question"], "entry": ["node", "cell", "space", "se", "cue", "instance", "section", "ent", "member", "ie", "link", "attribute", "see", "q", "ary", "ry", "row", "ce", "card", "from", "element", "up", "pair", "e", "atom", "be", "inner", "key", "ace", "char", "obj", "pixel", "record", "command", "check", "let", "object", "set", "def", "directory", "escape", "info", "data", "search", "Entry", "alias", "enter", "word", "pattern"], "item": ["text", "attr", "im", "cell", "addr", "term", "prefix", "template", "instance", "it", "user", "link", "attribute", "title", "em", "id", "entity", "tab", "local", "row", "area", "mm", "element", "Item", "el", "tag", "pair", "atom", "key", "name", "label", "xml", "unit", "char", "event", "anything", "om", "string", "object", "iter", "layer", "value", "file", "app", "info", "ip", "items", "word", "image", "order", "question"], "line": ["message", "text", "part", "level", "cell", "model", "block", "lin", "phrase", "ln", "n", "se", "valid", "user", "lo", "msg", "eline", "link", "piece", "detail", "zone", "body", "entity", "sql", "row", "sample", "queue", "frame", "term", "note", "slice", "channel", "liner", "continue", "le", "e", "code", "inline", "ine", "where", "rule", "label", "edge", "LINE", "ice", "l", "online", "page", "char", "sequence", "err", "record", "pe", "print", "point", "iter", "port", "file", "log", "range", "comment", "chain", "lined", "query", "search", "ge", "trace", "cmd", "word", "Line", "network"]}}
{"id1": "19739421", "id2": "11377441", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownCommandClass", "UnknownOptionError", " UnknownCommandException", "UnknownFormatError", "UnknownCommandError", "UnknownOptionClass", "UnknownParameterHandler", "UnknownParameterClass", "UnknownCommandHandler", " UnknownOptionHandler", " UnknownOptionError", " UnknownCommandHandler", "UnknownFormatException", " UnknownCommandError", "UnknownParameterException", "UnknownFormatHandler", "UnknownFormatClass", "UnknownCommandException", " UnknownCommandClass", "UnknownOptionHandler", "UnknownParameterError", " UnknownOptionClass"], "cmdLineParser": ["cmdListParser", "commandLineParser", "cmdBlockOptions", "mdlineparser", "cmdlineBuilder", "cmdFramePers", "mdlinearser", "cmdLOptions", " cmdLineReader", "cmdlineRunner", "cmdBlockParser", "mdLineLoader", "commandLineRunner", "commandLineReader", "cmdLineparser", "cmdNetParser", "mdLineparser", "cmdNetStreamer", "cmdLineBuilder", "cmdChainReader", "cmdChainLoader", "CmdlineBuilder", "cmdLinePers", "commandlineBuilder", "cmdFrameParser", "cmdNetHandler", "mdLineStreamer", " cmdPageParser", "cmdlineparser", "cmdlineProvider", "cmdBlockProvider", "cmdBlockReader", "mdlineParser", "cmdListBuilder", "cmdFrameReader", "mdLineParser", "cmdChainarser", "cmdPageReader", "cmdLinearser", "cmdSetparser", "cmdLineOptions", "commandlineReader", "cmdlineStreamer", "cmdLineReader", "commandlineParser", "commandLineBuilder", "cmdlinePers", "cmdBlockHandler", "cmdlineReader", "commandlinePers", "mdlineReader", "mdLineOptions", "CmdlineProvider", "cmdSetReader", "CmdlineReader", "cmdBlockBuilder", "commandLineProvider", "mdlineLoader", "CmdLineBuilder", " cmdPageReader", "cmdlineHandler", "mdLineBuilder", "CmdlineParser", "cmdListReader", "mdLineReader", "CmdLineProvider", "cmdlinearser", "mdlineBuilder", "CmdLineReader", "cmdlineOptions", "cmdFrameRunner", "commandLinePers", "cmdLParser", "mdlineOptions", "cmdSetParser", "cmdLineRunner", "cmdLineHandler", "cmdPageParser", "cmdNetReader", "cmdListparser", "cmdLineStreamer", "cmdLineProvider", "commandlineRunner", "cmdlineParser", " cmdPageBuilder", "cmdSetBuilder", "cmdPageProvider", "commandlineProvider", "mdlineStreamer", "mdLinearser", "cmdChainParser", "cmdlineLoader", "mdlineHandler", "cmdPageBuilder", "cmdLHandler", "cmdLBuilder", "CmdLineParser", "mdLineHandler", " cmdLineBuilder", "cmdLineLoader"], "formatOption": [" formatEntry", "filterEntry", "transformEntry", " formatOptions", "FormatOption", "formatEntry", "formatOptions", "filterOption", "formatOperation", "FormatOptions", " formatOperation", "transformOption", "transformOperation", "FormatOperation", "transformOptions"], "outputEncodingOption": ["outputencodingOptions", "outputEncachingOptional", "outputencodingOptional", "outputEncappingoption", "outputEncachingOptions", "outputencodingOption", "outputEncgingOption", "outputEncodingOptions", "outputencachingOptions", "outputencodingoption", "outputEncappingOption", "outputEncamingOption", "outputEncgingOptional", "outputencachingOption", "outputencappingOption", "outputEncachingOption", "outputEncamingoption", "outputencappingOptional", "outputEncamingOptional", "outputEncamingOptions", "outputEncappingOptions", "outputEncodingOptional", "outputencappingoption", "outputEncappingOptional", "outputencachingOptional", "outputEncgingoption", "outputEncodingoption"], "inputEncodingOption": ["inputEnclingOptions", "inputenclingOption", "inputEncordingOptions", "inputEncappingOptions", "inputEncachingOptions", "inputencodingAttribute", "inputEncappingOption", "inputEncappingoption", "inputCachingOption", "inputCachingOptional", "inputCachingOptions", "inputCodingOption", "inputCodingOptional", "inputEncendingOptions", "inputencodingOptions", "inputEncodingAttribute", "inputCodingOptions", "inputenclingAttribute", "inputEncordingoption", "inputEncodingoption", "inputEncordingOption", "inputEnclingoption", "inputenclingOptions", "inputEnclingOption", "inputEncodingOptional", "inputEnclingAttribute", "inputEncendingOption", "inputEncachingOptional", "inputencodingOption", "inputEncappingOptional", "inputEncappingAttribute", "inputencodingoption", "inputEncendingOptional", "inputEncachingOption", "inputEncodingOptions", "inputEncordingAttribute", "inputenclingoption"], "format": ["output", "printf", "style", "term", "prefix", "template", "method", "config", "it", "force", "type", "sort", "title", "filter", "f", "api", "pretty", "export", "accept", "note", "use", "with", "Format", "filename", "transform", "at", "module", "error", "version", "name", "fix", "unit", "get", "scale", "policy", "license", "form", "tif", "print", "command", "string", "source", "set", "status", "language", "table", "file", "parse", "option", "join", "pi", "what", "display", "layout", "pattern"], "outputEncoding": ["outputEngoding", " outputEncaling", "outputDecoding", "outputencoding", "outputEncaming", "outputDecalling", " outputEncaming", "outputEncaching", "outputMessaming", " outputDecaming", "responseEncalling", "currentEncaching", "outputEncling", "outputEnording", "outputEngacing", "responseEncoding", "outputencaging", " outputEncryption", "outputencording", "outputMessryption", "outputencaching", "outputEngoder", " outputEngacing", "outputEnacing", "outputCompining", "outputEnaging", "outputencging", "outputEncryption", "outputEncoder", " outputEngaling", "outputEncining", "outputEncording", "currentEncling", " outputEncoder", "currentEnoding", "outputCompryption", "currentEnging", "outputEngling", "outputEngging", "outputCompaming", " outputEngoding", "responseEncryption", "outputMessining", "outputEnaling", " outputEncining", "outputencling", " outputDecoding", "outputEnryption", "publicEncaging", "outputEnoding", "outputEncging", "outputEncaling", "outputCompoding", "currentEnling", "outputDecining", "outputEncaging", "outputDecling", "outputEncalling", "publicEncling", "outputEngaching", "outputEncacing", "publicEncording", " outputEncacing", "outputDecaming", "outputEnalling", "currentEncging", "outputEnling", "outputMessoding", "outputEnging", "publicEncoding", "outputEnoder", "responseEncling", " outputEngoder", " outputDecryption", "outputDecryption", "outputEngaling", "outputEnaching", "currentEnaching", " outputDecining", "currentEncoding"], "inputEncoding": ["inputChoding", "inputCodling", "inputPackoder", "contextEncale", "inputEnling", "inputEncoder", "inputChacing", "contextEnoding", "inputEnacing", "inputChale", "inputEnging", "outputEnging", "sourceEnling", "inputEncacing", "outputEncoder", "outputEnoding", "sourceEncoding", "inputEning", "inputEncling", "inputEncging", "inputCodacing", "outputEncging", "inputEnale", "contextEncacing", "inputEngoder", "inputencale", "outputEncale", "inputChoder", "contextEnale", "inputCododing", "inputEngging", "inputCoding", "outputEnoder", "contextEncoder", "inputEngale", "contextEnacing", "sourceEncacing", "inputencoder", "inputencoding", "inputEncale", "outputEnale", "inputencing", "sourceEncing", "inputEnoding", "inputPackging", "inputencling", "sourceEncling", "sourceEnacing", "inputPackale", "contextEncoding", "inputEncing", "inputencacing", "inputEngoding", "sourceEning", "contextEnoder", "sourceEnoding", "inputEnoder", "inputPackoding"], "remainingArgs": ["remainingFrames", "resainingargs", "remainingBlocks", "remainedParts", "resainedParameters", "remendingGS", "trainingGS", "mainingParts", "removalArgs", "remendingFrames", "remainsArgs", "remistingGS", "resainingGS", "remainedBlocks", "resainedArgs", "removalGS", "remainFrames", "trainingArgs", "remgoingArgs", "remainedGS", "resainedGS", "resainingArgs", "remainedJs", "remainedArgs", "resainingBlocks", "remainingParts", "resainingLinks", "remgoingGS", "remendingItems", "remainBlocks", "remainJs", "remainsParameters", "remainArgs", "remainedargs", "remgoingParts", "remgoingargs", "resainingParameters", "remistingArgs", "mainedArgs", "trainFrames", "remainingParameters", "remainsBlocks", "removalBlocks", "resainedargs", "resainedLinks", "remainGS", "remainingItems", "remistingLinks", "mainingJs", "remainedItems", "resainingItems", "remainingGS", "trainGS", "removalParameters", "resainedBlocks", "mainingArgs", "remainsGS", "trainingFrames", "remgoingItems", "mainedParts", "trainArgs", "mainedJs", "remendingArgs", "trainItems", "remistingBlocks", "remainingLinks", "remainedFrames", "resainedItems", "remainItems", "remainParts", "remainLinks", "remainedParameters", "remainargs", "remgoingJs", "mainedGS", "remainingJs", "mainingGS", "trainingItems", "remainedLinks", "remainingargs"], "inputFile": ["inputPlace", "hiddenfile", "inputPath", " inputLike", "inputFILE", "acceptPlace", "acceptFile", "hiddenFile", " inputfile", "requestFile", "hiddenPath", "inputLike", " inputPlace", "hiddenLike", "outputPath", "outputfile", "Inputfile", "acceptLine", " inputFILE", "requestPath", " inputLine", "requestfile", "outputLike", "requestFILE", "InputLine", " inputPath", "InputFile", "InputPlace", "InputPath", "acceptfile", "InputFILE", "inputLine", "inputfile"], "outputFile": ["OutputDo", "outputFolder", "outputFilename", " outputFiles", "clientDir", " outputDo", "clientFiles", "cacheDir", "writefile", "coinfile", "outputfile", "Outputfile", "writeFile", "clientFile", "inputFilename", "writeFolder", "outputDir", "coinFile", "inputDir", "clientDo", " outputfile", "OutputFilename", "outputDo", " outputDir", "cacheFilename", "OutputFile", "coinDo", "OutputFiles", "outputFiles", "OutputDir", "cachefile", "cacheFile", " outputFolder", "writeDo", "coinFolder", "inputfile"], "out": ["output", "gr", "ser", "list", "on", "session", "con", "init", "n", "ln", "Out", "user", "msg", "sys", "manager", "pretty", "inv", "aos", "dir", "io", "ex", "outs", "ins", "up", "cfg", "ou", "all", "inner", "null", "writer", "error", "inter", "screen", "obj", "net", "err", "conn", "print", "OUT", "log", "in", "res", "outer", "temp", "report", "gen", "inf"]}}
{"id1": "160739", "id2": "8452134", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createFileStream", "createInputstream", " createOutputFile", " createFilestream", " createInputSteam", " createFileSteam", " createOutFile", "createOutputstream", "createInputFile", " createOutStream", "createInputStream", " createOutputSteam", "createOutputSteam", " createFileFile", " createInputStream", " createOutSteam", "createInputSteam", " createInputFile", " createOutstream", " createInputstream", "createOutputFile", " createOutputstream"], "inFile": ["inputPath", "inDir", "dinPort", "ninPath", "dinPath", "dinDir", " infile", "outFilename", " inPort", "infile", "ninFilename", "inputDir", " inPath", "ninFile", "outPath", "inFilename", "inPort", "outfile", "inputFile", "inputPort", "dinFile", " inDir", "inPath", " inFilename", "ninfile"], "outFile": ["Outfile", "exfile", "outPlace", "outPort", "outputFilename", "OutFilename", "outputFile", "outputPlace", "exFile", "newfile", "OutPort", "outputfile", "exPlace", "OutFile", "toPort", "outFilename", "newFilename", "tofile", "infile", "newFile", "toFile", "inFilename", "inPort", "outfile", "toFilename", "exFilename", "newPlace"], "k_blockSize": ["k_BlockTime", "k4BlockName", "k_BlockStyle", "k2byteLength", "k_byteSize", "k2blockLength", "k_blockName", "k4blockSize", "k2byteTime", "k4blockCount", "k2blockTime", "k_blockTime", "k_byteName", "k_batchLength", "k4BlockStyle", "k_BlockLength", "k_BlockSize", "k_BlockCount", "k2blockSize", "k4BlockSize", "k_byteTime", "k_batchTime", "k_blockCount", "k4BlockCount", "k2byteCount", "k_blockLength", "k_byteLength", "k4blockStyle", "k2byteSize", "k_blockStyle", "k_BlockName", "k_batchSize", "k4blockName", "k_byteCount", "k2blockCount", "k_batchCount", "k_byteStyle"], "byteCount": ["byteLength", "wordN", "bitN", "byteSize", "byteCode", "charPtr", "bitSize", "bitCounter", "linePtr", "bytecount", "wordCode", " byteLength", "bitCount", "bytePtr", "charCount", "lineLength", "byteCounter", " bytecount", "bbCode", "wordSize", "bitLength", " bytePtr", "bbN", "blockCounter", "blockLength", "charLength", "bitCode", "byteCheck", "blockCount", "bbSize", " byteCheck", "byteN", "wordCount", "charcount", "bbCount", " byteCounter", "linecount", "lineCount", "bitCheck", "blockCheck"], "buf": ["buffer", "proc", "Buffer", "db", "block", "img", "msg", "pkg", "fg", "b", "bag", "raw", "Buff", "bn", "alph", "cat", "bl", "queue", "cv", "seq", "conv", "arr", "buff", "uf", "bg", "cast", "pb", "ctr", "str", "vec", "cb", "doc", "bytes", "txt", "bc", "batch", "mem", "ctx", "tx", "cap", "exp", "cmd", "rb", "cur"], "ofp": ["owlpa", " ofpa", "ofd", "OFP", "owlp", "ofl", " ofP", "ofP", "owlP", "Ofpa", "Ofl", " ofl", "ofpa", "OFd", "Ofp", "OfP", "Ofd", "OFp", " ofd", "OFl", "owld"], "zos": ["ossus", "cos", "sbm", "esa", "zen", "zi", "es", "rss", "tis", "init", "hz", "amia", "zik", "jas", "ze", "zy", "zu", "psy", "gs", "osi", "zin", "bs", "za", "socket", "ez", "hess", "rez", "ws", "os", "zers", "zon", "css", "zag", "zes", "std", "zzle", "LOS", "ps", "webkit", "js", "enos", "rose", "settings", "zh", "zb", "bes", "eros", "zl", "cz", "south", "zer", "los", "python", "sch", "z", "zo", "oss", "sis", "jp", "zona", "nz", "zip"], "osw": ["iswx", "aosW", "osiw", "cosw", "ospace", "osd", "aosw", "sysw", "sysW", "aosd", "cosew", "oW", "syswd", "isw", "owa", "cosd", "issw", "osew", "ossw", "cosws", "osrw", "sysrw", "aoswd", "osws", " ossw", "osswx", "osiW", "opace", "ow", " oswx", "aoswa", "aospace", "aosrw", "osswd", "osiwa", "osipace", " osew", "ossrw", " osW", "osW", "isW", "aosew", " osd", "ossW", "oswa", "oswx", "osssw", "aosws", "oswd", " osws"], "bw": ["nbwe", "abwe", "besw", "bbx", "pbwb", "sbwb", "bex", "pbz", "sbw", "pbwe", "bwk", " bem", " bx", "bbz", " bwl", "obwb", "bwp", "bsw", "bbend", "nbew", "bwl", "bewk", "bbwp", " bex", "pbwt", "rbw", " bz", "bwb", "abew", "bwy", "nbw", "obwl", "bewl", "pbw", "wbw", "sbz", "pbwy", " bsw", "bew", "bem", "bbws", " bwp", "rbex", "wbz", "wbwp", " bwk", "wbem", " bwt", "bwt", "bwe", "obsw", "abwy", "bbex", "wbwt", "nbwy", " bend", "rbws", "wbend", "pbew", "bbw", "bz", "bws", "bx", "wbx", "abw", "sbwt", "obwt", " bws", "rbz", "obw", "obwk", "bbwt", "obz", "bend", "bbem"], "zot": ["ziot", "zerot", "zeronet", "zeror", "zonet", "zipot", "Zot", " ziat", "zoor", "Zit", " zott", "zott", " zo", "zerote", "zoot", "ziphot", "zoonet", "zoo", "zipiat", "zerit", "zeriat", " ziot", " zor", "zor", "zerhot", "zerott", "zipiot", " zonet", "Zote", "zhot", "zero", "Zott", "zote", "ziat", "zeriot", "zo", " zote", " zhot"], "ifp": [" ifd", " ifr", "iwd", " ifth", "iwp", " ifP", " iftp", "ifP", "isP", "Ifth", " ifjp", "iwr", "ifjp", "isjp", "ihp", "Ifjp", "isp", "ifr", "ihr", "ihtp", "iwtp", "IfP", "ifth", "ihd", "Ifp", "iftp", "ifd", "isth"], "zis": [" ziss", "izis", "zeris", " zi", "ezis", "zi", "izisa", "izi", "zoisa", " zIS", "zipic", "zoinit", "eziss", "zois", "zisa", "zerIS", "zIS", "zipis", " zic", "zisc", "zoiss", "zinit", "izinit", "ziinit", "izisc", "zic", "zeric", "ziisa", "ziis", "zipIS", "iziss", "ziss", "ziiss", " zisc", "ezi", "ezisc"], "isr": ["sisrs", "ispr", "iosstr", "itssr", "iospr", "isalr", "issrc", "iossr", "isscr", "issrs", "iosr", "itsstr", "isstr", "iscr", "issr", "isalpr", " isrs", "sisr", "siscr", "itspr", " isrc", "isalstr", "isrs", "sisrc", "isalsr", " iscr", "itsr", "isrc"], "br": ["wr", "gr", "dr", "shr", "bf", "bd", "b", "bp", "bm", "BR", "rel", "bn", "bl", "hr", "pr", "fr", "bt", "js", "Br", "cr", "bro", "bi", "obl", "str", "ctr", "Fr", "vr", "mr", "tr", "ptr", "bj", "sr", "lr", "ba", "bh", " Br", "kr", "ber", "r", "yr", "rb"], "zit": ["zeop", "zipIT", "iziti", "ziti", "zipit", "izip", "zist", "ozit", "czip", "czit", "ezlit", "zite", "ozunit", "ezIT", "lexIt", "ziit", "lexIT", "czop", "czunit", " zlit", "ziplit", "zIT", "zipist", "ziIt", "zlit", "ezite", " zip", " zIT", "cziti", "lexist", "zipite", "zunit", "lexit", "oziti", "ziIT", "zeit", "zipIt", "ezit", "zeip", "czot", "izit", "ozip", " zite", "zIt", "ziist", "zeot", "zop", " zop", "izunit", "zip"]}}
{"id1": "1141361", "id2": "3197876", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"makeRead": ["doRead", "doPost", " doPost", " doRead", " processCreate", " initialRead", " initialFind", " doCreate", "doFind", " initialCreate", " initialPost", " doFind", " processFind", " processRead", "doCreate", " processPost"], "user": ["field", "message", "owner", "password", "by", "author", "users", "human", "database", "plugin", "account", "connection", "person", "usage", "nick", "creator", "User", "use", "auth", "client", "server", "rule", "name", "post", "USER", "uid", "username", "project", "string", "date", "table", "file", "student", "url", "host", "word"], "databaseID": ["databaseTime", "directoryid", "databaseIDs", "connectionTime", "directoryId", "directoryID", " databaseTime", " databaseAND", " databaseIDs", "directoryTime", "directoryAND", "databaseId", "connectionIDs", " databaseId", "databaseid", "connectionId", "directoryIDs", " databaseid", "connectionID", "connectionid", "connectionAND", "databaseAND"], "time": ["second", "message", "TIME", "timeout", "now", "money", "type", "tt", "hour", "times", "zone", "tm", "id", "runtime", "duration", "end", "frequency", "Time", "t", "created", "etime", "mode", "timer", "length", "clock", "version", "tc", "ime", "sequence", "delay", "rate", "tim", "date", "port", "value", "info", "year", "age", "start"], "query": ["message", "task", "description", "term", "menu", "then", "qa", "gate", "condition", "title", "q", "ql", "body", "sql", "execute", "note", "eries", "transform", "qu", "content", "run", "call", "request", "code", "script", "view", "quest", "quote", "command", "entry", "string", "clean", "select", "Query", "comment", "find", "work", "search", "cmd", "sq", "question"], "statement": ["buffer", "message", "expression", "session", "binary", "function", "word", "description", "phrase", "template", "se", "volume", "bind", "database", "connection", "condition", "ct", "shell", "definition", "sql", "usage", "console", "state", "Statement", "execute", "mt", "slot", "frequency", "subject", "fr", "yahoo", "confirmed", "call", "library", "journal", "le", "rule", "communication", "number", "position", "quote", "page", "sequence", "result", "print", "command", "batch", "entry", "that", "ements", "stat", "status", "table", "language", "comment", "sp", "document", "media", "finder", "memory", "cmd", "ts", "commit", "storage", "report", "list", "article"], "count": ["message", "counter", "now", "nb", "state", "complete", "size", "num", "ind", "loc", "current", "total", "length", "nt", "call", "flag", "Count", "code", "OUNT", "all", "any", "index", "number", "contact", "sum", "ount", "c", "batch", "check", "amount", "set", "status", "table", "find", "found", "handle", "coll", "report", "list"]}}
{"id1": "8490710", "id2": "8815137", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 0, "substitutes": {"actualizar": [" actualiser", " actualizeAR", " actualizAR", " actualizaAR", " actualizaar", " actualiziar", "ualizAR", " actualizer", " actualizeer", " actualizeiar", " actualisAR", " actualisiar", "ualizaiar", " actualizaiar", "ualizer", "ualizaer", "ualizaAR", " actualizear", " actualizaer", "ualizar", "ualiziar", " actualisar", "ualizaar"], "ClassNotFoundException": ["ClassNotfoundException", "ClassNotfoundError", "ClassNotPresentError", "ClassNotFoundError", "ClassNotPresentException"], "Exception": ["Instance", "T", "Connection", "Event", "None", "Example", "Message", "Handler", "File", "Time", "Exc", "Transaction", "Application", "Configuration", "E", " exception", "Un", "Class", "Status", "Index", "Warning", "Exit", "Throw", "I", "EX", "Response", "Type", "Null", "Ex", "End", "ION", "Operation", "ception", "Context", "Option", "Interface", "Error", "Result"], "conn": ["ch", "nc", "session", "connect", "Con", "db", "Connection", "con", "close", "init", "n", "config", "ln", "org", "open", "mc", "sys", "gate", "connection", "ont", "ct", "pg", "socket", "sc", "sql", "pool", "pen", "enc", "Connect", "ens", "en", "ws", "rc", "mt", "pas", "client", "yes", "rs", "js", "nt", "ns", "ks", "ec", "cp", "comm", "cb", " con", "exec", "obj", "yn", "ctx", "cn", "cc", "ann", "ctrl", "oss", "die", "cert", "jp", "cmd", "act", "conf", "Conn", "c"], "ms": ["Ms", "ims", "mos", "pm", "vs", "cus", "mes", "posts", "is", "mc", "sys", "uts", "ml", "bs", "inv", "ws", "qs", "ants", "os", "mm", "mi", "mt", "cms", "cs", "mx", "ys", "ces", "ma", "sm", "ins", "ps", "rs", "mys", "xs", "js", "eds", "ns", "mic", "ks", "terms", "ats", "mill", "mp", "fs", "md", "mod", "MS", "ems", "m", "uns", "mn", "arms", "s", "ents", "eps", "ocks", "pers", "res", "ts", "windows", "ies"], "fechaSystem": ["fechaeSys", "fochtaSTEM", "fochaSystem", "fechaeSTEM", "fetaSys", "fechiSystem", "fechoSTEM", "fechaeSystem", "fetisystem", "fechoaSystem", "fetaeSystem", "feshoSystem", "fechasystem", "fechlaSystem", "feshaServer", "fechiSys", "fetaSystem", "fechaSys", "fechtaServer", "fechtaSystem", "fechaServer", "fechaSTEM", "fochtaSystem", "fochaServer", "fechoasystem", "feshosystem", "fechisystem", "fetiSystem", "fechlasystem", "fechaesystem", "feshoServer", "fetasystem", "fechaeServer", "fetiSys", "fetaesystem", "fechoaSys", "fechlaSys", "fochtaServer", "fechoServer", "fechoSystem", "feshasystem", "fochaSTEM", "fetaeSys", "fechoSys", "fechoaServer", "fechtaSTEM", "feshaSystem", "fechosystem"], "aaaammdd": ["aaaammm", "aaaamldd", "aammdd", "aammd", "aaaaumdd", "aaammd", "aaammmd", "aaaamdd", "aaammds", "aaaammmm", "aaaammd", "aammmd", "aaaaammd", "aaaaammdd", "aaammdd", "aaaammmd", "aaaamlmm", "aaammmm", "aaaamd", "aammds", "aaaaumd", "aaaaamdd", "aaaamds", "aaaaummd", "aaaammds", "aaaaamd", "aaaaammm", "aaaaammmm", "aaaamld", "aaaaumds"], "fzafsis": ["fzeajsis", "fzeafses", "fzafesi", "fzamsis", "fzajses", "fzamsi", "fzajesi", "fzeajsi", "fzeafsi", "fzahses", "fzamesi", "fzahesi", "fzeafsis", "fzeafesi", "fzamses", "fzahsi", "fzajsi", "fzeajses", "fzafses", "fzeajesi", "fzafsi", "fzajsis"], "hhmmss": ["hhmmms", "hhmmmss", "hhmmess", "hhMMms", "hhMMse", "hhmmse", "hmmmse", "hhmbs", "HHmmss", "hhmmps", "hmmms", "hhmbess", "hhmmmess", "HHMMs", "hmmbs", "HHMMps", "hmmbess", "HHmms", "hhmmmse", "hhmmmps", "hhmbss", "hhMMss", "hhmbse", "hhmmmms", "hhMMps", "HHMMss", "hhms", "hhmms", "HHmmms", "hmmbss", "hhmss", "hhmps", "HHmmps", "HHMMms", "hmmbse", "hhMMs", "hhMMess", "hmmmess", "hmmmss"], "sss": ["essjs", "issl", "isses", "esss", "ssn", "ossjs", "ssjs", "isss", " ssjs", "ssss", " ssss", "essss", "rssss", "rssl", "ssl", "rsss", "osss", "essn", "essl", "ossn", "sses", "ossss", " ssn", "esses", "rsses", "issss"], "ss": ["SS", "ius", "rss", "sl", "se", "pps", "sd", "tt", "sys", "su", "bs", "sql", "ds", "hess", "stats", "ws", "iss", "ses", "hs", "css", "ys", "cs", "ssl", "lower", "pse", "ps", "rs", "styles", "js", "pass", "ns", "less", "\u00df", "str", "sh", "xx", "si", "ress", "ess", "txt", "good", "string", "tx", "pres", "ass", "sb", "oss", "https", "sv", "s", "tz", "ts", "sf", "sq"], "fzahsis": ["fizahorus", "fzaqsis", "fzaqsi", "fzaqorus", "fzabsis", "fzahses", "fzaforus", "fizahsis", "fizafses", "fizafsis", "fizafsi", "fzaqses", "fizaforus", "fzahsi", "fizahsi", "fizahses", "fzafses", "fzaborus", "fzahorus", "fzabses", "fzafsi", "fzabsi"], "afectados": ["afelectados", "affettados", "afectionarians", "afectionados", "affecturated", "afECTado", "affectado", "afECTurated", "affECTarians", "afettados", "affECTado", "afitectarians", "afettadas", "affectators", "afittulas", "afitecturated", "afitectado", "affECTados", "affectados", "afectadas", "afettators", "afelectulas", "afECTados", "afecturated", "afelectators", "afectulas", "affectarians", "afECTarians", "affECTurated", "affectulas", "afectionado", "afittados", "afectado", "afectators", "afitectados", "affettators", "afectarians", "afectionurated", "affettulas", "afittators", "afittadas", "afettulas", "affettadas", "affectadas", "afelectadas"]}}
{"id1": "4501356", "id2": "720361", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileChangeDigest", "calculateProfileDiffSigne", "calculateProfileChangeDigests", "calculateProfileDiffSignests", "calculateProfileChangedigst", "calculateProfileChangedigest", "calculateProfileDiffDigests", "calculateProfileDiffDiffests", "calculateProfileDiffSignst", "calculateProfileChangeDige", "calculateProfileDiffdigst", "calculateProfileDiffDige", "calculateProfileDiffdigests", "calculateProfileDiffdigest", "calculateProfileChangeDigst", "calculateProfileDiffDiffe", "calculateProfileDiffdige", "calculateProfileChangedigests", "calculateProfileChangedige", "calculateProfileDiffSignest", "calculateProfileDiffDigst", "calculateProfileDiffDiffest", "calculateProfileDiffDiffst"], "profileDiff": ["jsonData", "templateDelta", "pictureInf", "profileChange", "personDelta", "phdiff", "jsonDifferent", "phDiff", "jsonDelta", " profilediff", "ProfileDelta", "userChange", " profileDelta", "ProfileChange", "profileData", "personDiff", "profileDifferent", "profileInf", "caseUpdate", "jsonDiff", "pictureChange", "userDelta", "templateDifferent", "persondiff", "caseDelta", "userDiff", "profileDelta", "pictureDiff", "ProfileDifferent", "phInf", "profilediff", "templateDiff", "phChange", "casediff", "ProfileDiff", "profileUpdate", "picturediff", "caseDiff", "personUpdate", " profileInf", "ProfileData", " profileUpdate", "templateData", " profileChange"], "normaliseWhitespace": ["normaliseWipspace", "normaliseWhitesspace", "normaliseWhipsSpace", "normaliseWhatsSpace", "normaliseWipspaces", "normaliseWhipsspace", "normaliseWhitesace", "normaliseWhipsace", "normaliseWhipspaces", "normaliseWhipspace", "normaliseWipsSpace", "normaliseWhitspaces", "normaliseWitesace", "normaliseWhitsspace", "normaliseWhitspace", "normaliseWitespace", "normaliseWitespaces", "normaliseWatsace", "normaliseWipsspace", "normaliseWhitesSpace", "normaliseWhatsspace", "normaliseWhatspace", "normaliseWhatsace", "normaliseWitesSpace", "normaliseWhitsSpace", "normaliseWhatspaces", "normaliseWatspace", "normaliseWatsspace", "normaliseWatsSpace", "normaliseWitesspace", "normaliseWhitespaces"], "md": ["dr", "pm", "ms", "add", "nd", "pdf", "sd", "mc", "bd", "od", "and", "ad", "MD", "grad", "der", "cd", "mg", "dir", "mm", "dm", "mt", "ind", "rm", " df", "red", "sm", "deep", "js", "nt", "det", "ld", "dist", "dd", "d", "mac", "obj", "mk", "amd", "mod", "pd", "m", "df", "sam", "mn", "fd", "cmd", "hd", "de", " sd"]}}
{"id1": "8329093", "id2": "19134229", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["arse", "load", "update", "patch", "init", "se", "fire", "build", "apply", "link", "send", "parser", "read", "scan", "execute", "rule", "process", "handler", "get", "page", "print", "match", "render", "document", "format", "start", "handle"], "event": ["ev", "window", "config", "it", "exc", "instance", "author", "ext", "attribute", "connection", "complete", "flow", "att", "element", "content", "atom", "error", "ec", "external", "ay", "form", "let", "archive", "events", "Event", "on", "now", "ent", "msg", "response", "after", "claim", "except", "enc", "from", "ex", "e", "this", "ow", "object", "comment", "document", "age", "cmd", "when", "arg", "dev", "address", "er", "request", "rule", "view", "page", "result", "action", "device", "app", "exp", "information", "message", "load", "owner", "state", "argument", "initial", "el", "handler", "command", "ctx", "vent", "log", "info", "empty", "context", "image", "network"], "stmt": ["ostMT", "Stmm", "STm", "stpt", "stMT", "strmt", "ostmt", "Stm", "stm", " Stmp", "spm", "StMT", "stmm", "spmt", "STmm", "strMT", "strmm", "Stmp", "STmt", "Stmt", " stmp", "Stgt", "strmb", " stgt", " Stmt", " stms", "stmp", "STpt", "ostmm", "Stpt", " Stm", "STMT", "stms", " stm", "spMT", "stmb", "ostmb", " stMT", " stpt", " stmb", " stmm", "stgt", "spgt", "Stms", " Stms"], "rs": ["ims", "rings", "vs", "otes", "ls", "ms", "ris", "sels", "rets", "pps", "ows", "times", "ares", "gs", "arts", "bs", "ues", "ds", "rc", "ires", "ws", "its", "qs", "ars", "hs", "rows", "xs", "hr", "ys", "rd", "cs", "ins", "amps", "ps", "rys", "js", "rt", "ags", "sts", "ks", "ats", "rates", "ts", "mr", "acks", "fs", "sr", "ems", "Rs", "rl", "vals", "vers", "icks", "ros", "results", "arms", "ges", "els", "caps", "res", "ras", "usr", "RS"], "checksum1": [" checksumer4", "checkssum2", "checkssum4", "checkssum1", "cksum2", "checksumm0", "cksums2", "checksumone", "checksnum3", "checksums01", "checkssum01", "csumOne", "checksum51", "checksave81", "cssumOne", "checksam1", "checkssum81", "checksums1", "cksum15", "checksump4", "checksum0", "cksumOne", "checksnum0", "checksatum51", "cssum0", " checksum01", "checksum15", "cksumone", "checksumer4", "checksum3", "checksump2", " checksumer01", "checksumm1", "checksamOne", " checksum4", "ckssum1", "checksuum81", " checksumer2", "checksumer01", "ckssum2", "csum51", "checkssumOne", "checksums2", "checkssum51", "checksumer2", "cksum4", "checksnum2", "cksum0", " checksumer1", "checksump1", "checkssum0", "ckssumOne", "checksum4", "cksums0", "ckssum4", "ckssumone", "checksnumOne", "csum2", "csum1", "checksave2", "checksnumone", "checksums3", "checksum81", "checksumOne", "checkssum3", "checksumm2", "checksuum1", "checksuum2", "checksnum4", "checksumsOne", "checksummOne", "checksatum0", "checkssum15", "checksumm51", "checksums4", "checksums0", "checkssumone", "csum0", "checksum01", "cksum81", "checksave15", "checksam2", "cssum51", "cksums1", "cksums3", "checksnum1", "ckssum81", "checksave1", "cssum2", "ckssum15", "checksumpone", "cssum1", "cksum3", "checksuum15", "checksatum1", "cksum1", "checksatumOne", "checksumer1", "checksamone"], "url": ["path", "buffer", "http", "load", "mail", "html", "ls", "location", "abs", "ol", "sl", "cal", "open", "build", "msg", "bel", "link", "item", "ur", "b", "Url", "f", "ul", "connection", "URL", "id", "rel", "ssl", "uri", "dl", "loc", "nl", "resource", " URL", "browser", "ref", "content", "null", "error", "name", "str", "ll", "get", "l", "char", "u", "page", "result", "conn", "base", "string", "lr", "input", "rl", "file", "log", "job", "value", "web", "UR", "cert", "document", "data", "r", "image"], "adler32": ["adder31", "adsll64", "adsll31", "adger34", " adlder31", "adler40", "adll31", "adle33", "adger33", "adsler33", "adle16", "adlder34", "adlder32", " adle34", "adsll32", "adling40", " adler31", "adger31", "adle31", " adle64", "adger16", "adder30", "adder32", "adling30", " adlder30", "adle32", "adsll33", " adle32", "adlder30", "adger64", "adlder31", "adling31", "adler16", "adler30", "adle64", "adlder40", "adsler64", "adger32", " adle16", " adler30", " adler40", "adll64", "adll32", "adlder64", "adler33", "adsler32", "adsler31", "adler64", "adler34", " adlder40", "adle34", " adler34", "adling32", "adll33", " adler64", "adder40", " adlder32", "adler31", " adler16", "adlder16"], "nodes": ["noms", "nos", "mnoms", "node", " nods", "mnets", "mnode", " nets", "Node", "renos", "Nods", "nods", " node", "Nodes", " noms", "mnodes", "renodes", "renode", " nos", "Nets", "nets", "renods", "Noms", "Nos"], "checksum2": ["checksume1", "checksum02", "checkssum2", " checksnum02", "checkssum1", "checksume2", "checkssum02", " checksnum21", " checksnum1", "checksnum21", " checksnum3", " checksum21", "checksums02", "checksnum3", "checksnum1", " checksnum2", " checksum02", "checksums3", "checksums1", "checkssum3", "checkssum21", "checksume02", "checksume21", "checksum21", "checksums2", " checksum3", "checksnum2", "checksnum02", "checksum3"]}}
{"id1": "11475527", "id2": "6188784", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDatafromUrl", "addTextFromURL", "addDataFormLocation", "addDataToURL", "addDataFormUrl", "addDatafromURL", "addTextFromurl", "addDatafromLocation", "addDataFromLocation", "addTextFormLocation", "addTextFromLocation", "addTextFormUrl", "addTextFormurl", "addDatafromurl", "addTextFormURL", "addDataFromurl", "addDataFormURL", "addDataToLocation", "addDataToUrl", "addTextFromUrl", "addDataTourl", "addDataFormurl", "addDataFromUrl"], "theurl": ["teuri", "thUrl", " thefile", "teurl", " theURL", " theloader", "heUrl", "thloader", "heloader", "theloader", "heuri", "thfile", "heURL", "teUrl", "TheUrl", " theuri", "theuri", "TheURL", "heurl", "hefile", "Theurl", "Theuri", " theUrl", "teURL", "thefile", "thurl", "theUrl", "theURL"], "line": ["message", "text", "node", "cell", "lin", "block", "ln", "valid", "header", "eline", "link", "zone", "lane", "sample", "row", "frame", " inline", "liner", "email", "le", "code", "inline", "ine", "rule", "name", "LINE", "ice", "day", "l", "char", "page", "online", "sequence", "record", "entry", "string", "source", "point", "print", "status", "ner", "stroke", "comment", "chain", "lined", "Line"], "in": ["proc", "IN", "din", "gin", "con", "st", "or", "init", "n", "it", "open", "rin", "ai", "is", "mc", "lo", "oin", "ic", "f", "old", "ain", "id", "pin", "o", "read", "en", "inc", "from", "mi", "al", "ins", "t", "win", "ma", "ac", "bin", "serv", "inner", "reader", "isin", "l", "r", "In", "conn", "include", "input", "source", "again", "i", "inn", "phys", "out", "inf", "cin"], "data": ["buffer", "text", "window", "user", "a", "ata", "ad", "feed", "body", "raw", "dat", "read", "size", "iterator", "io", "DATA", "client", "pipe", "content", "this", "writer", "da", "reader", "bus", "d", "next", "stream", "dec", "result", "input", "def", "file", "join", "info", "query", "out", "cache"], "e": ["ve", "eu", "es", "or", "x", "se", "n", "a", "te", "ie", "ze", "me", "b", "f", "p", "y", "o", "eeee", "h", "ele", "ce", "re", "ed", "er", "element", "t", "ex", "ee", "v", "E", "le", "oe", "g", "ine", "be", "error", "ec", "d", "ue", "ae", "event", "err", "pe", "entry", "m", "ne", "i", "ge", "r", "c", "de"]}}
{"id1": "15580610", "id2": "12004824", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"trainClassifier": [" trainClassification", " trainObjectizer", " trainClassizer", " trainClassifer", " runclassizer", " trainObjectifer", " runClassifier", " trainModification", " trainModifer", " trainObjectifier", " trainclassifer", " trainModizer", " runclassifier", " runclassifer", " trainObjectification", " trainclassifier", " runClassifer", " runClassification", " trainclassification", " runclassification", " trainModifier", " runClassizer", " trainclassizer"], "dir": ["output", "path", "disk", "dr", "db", "addr", "prefix", "config", "pkg", "tmp", "root", "grad", "wd", "folder", " directory", "direct", "local", "io", "rad", "dm", "dl", "files", "loc", "pos", "this", "done", "src", "dist", "module", "DIR", "doc", "null", "dd", "d", "ir", "lib", "directory", "md", "Dir", "base", "log", "data", "div", "url", "report"], "command": ["Command", "buffer", "message", "expression", "application", "binary", "function", "text", "history", "description", "password", "program", "template", "method", "menu", "config", "button", "volume", "shift", "force", "multiple", "link", "and", "attribute", "statement", "response", "connection", "condition", "shell", "send", "pretty", "execute", "sudo", "control", "power", "argument", "initial", "relative", "component", "content", "clear", "request", "three", "key", "script", "group", "delete", "operation", "mpeg", "mac", "position", "call", "sequence", "directory", "event", "form", "base", "string", "set", "archive", "option", "chain", "comment", "document", "query", "search", "display", "requisite", "paste", "column", "cmd", "pattern"], "length": ["collection", "strip", "load", "depth", "shape", "space", "volume", "now", "shift", "build", "last", "available", "count", "ength", "character", "duration", "size", "end", "factor", "creator", "loc", "Length", "power", "total", "deep", "transform", "ctors", "bus", "number", "dump", "position", "ENGTH", "level", "SIZE", "sequence", "upper", "form", "limit", "capacity", "value", "max", "given", "distance", "full", "pad", "append", "height", "pieces", "fleet", "needs", "diff", "prototype", "len"], "process": ["output", "proc", "message", "session", "connect", "function", "task", "node", "load", "term", "program", "method", "worker", "link", "handle", "class", "processor", "p", "console", "flow", "pid", "use", "pp", "channel", "component", "call", "Process", "run", "processing", "request", "script", "mpeg", "view", "post", "cp", "service", "thread", "position", "event", "result", "record", "complex", "check", "object", "status", "parse", "system", "search", "display", "in", "cmd", "start", "exec", "network"]}}
{"id1": "17792212", "id2": "2199604", "code1": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"createButtonCopyToClipboard": ["createButtonCopyToCLimBoard", "createButtonCopyToClimboard", "createButtonCopyToClimpad", "createButtonCopyToCLipboard", "createButtonCopyToClitBoard", "createButtonCopyToClippad", "createButtonCopyToClimBoard", "createButtonCopyToClitboard", "createButtonCopyToCLippad", "createButtonCopyToClitpad", "createButtonCopyToCLimboard", "createButtonCopyToClipppad", "createButtonCopyToCLipBoard", "createButtonCopyToClippboard", "createButtonCopyToClippBoard", "createButtonCopyToClipBoard", "createButtonCopyToCLimpad"], "buttonCopyToClipboard": ["buttonCopyToclipboard", "buttonCopyToClipback", "buttonCopyToCLipback", "buttonCopyToclimBoard", "buttonCopyToClimbox", "buttonCopyToClippingbox", "buttonCopyToClippedBoard", "buttonCopyToclimbox", "buttonCopyToCLippingboard", "buttonCopyToClapBoard", "buttonCopyToCLippingBoard", "buttonCopyToCLippingbox", "buttonCopyToclipBoard", "buttonCopyToClippad", "buttonCopyToClipBoard", "buttonCopyToClippingBoard", "buttonCopyToCLipbox", "buttonCopyToclipbox", "buttonCopyToclimboard", "buttonCopyToClippBoard", "buttonCopyToCLippingback", "buttonCopyToClappad", "buttonCopyToClippbox", "buttonCopyToClapbox", "buttonCopyToClimboard", "buttonCopyToClimBoard", "buttonCopyToClapboard", "buttonCopyToClimpad", "buttonCopyToCLimboard", "buttonCopyToCLipboard", "buttonCopyToClipbox", "buttonCopyToClimback", "buttonCopyToCLipBoard", "buttonCopyToClippedboard", "buttonCopyToClippingback", "buttonCopyToclippad", "buttonCopyToClippingpad", "buttonCopyToClapback", "buttonCopyToClippedpad", "buttonCopyToCLimBoard", "buttonCopyToClippingboard", "buttonCopyToClippback", "buttonCopyToClippboard", "buttonCopyToclimpad", "buttonCopyToCLimback"], "event": ["message", "ev", "self", "style", "selection", "window", "ie", "state", "ed", "ex", "er", "t", "ee", "v", "E", "e", "name", "index", " EVENT", " Event", "result", "vent", "selected", "value", "events", "in", "Event"]}}
{"id1": "14450108", "id2": "14733078", "code1": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["con", "close", "ping", "bind", "init", "config", "sync", "open", "build", "connection", "ssh", "pen", "Connect", "read", "create", "download", "reset", "client", "initial", "login", "setup", "write", "process", "connected", "conn", "remote", "set", "select", "log", "secure", "construct", "join", "establish", "attach", "dial", "network"], "ftpe": ["oftse", "attpa", "attp", "iftcle", "iftple", "iftpe", "etpe", "etse", "aftpa", "iftpa", "aptpe", "iftse", " ftpy", "ftcle", "etp", "aftpy", "aftcle", "ftpy", "oftme", " ftme", "aftse", "ftme", "ftse", "oftple", "ftple", "etpy", "attpe", "oftpe", "aptp", "aptse", "aftme", "aftp", " ftple", "aftple", "aftpe", " ftse", "aptcle", "iftp", "attple", "ftpa"], "ftp": ["threadtp", "ftping", "http", " ftcp", "aftpp", "ottt", "ftpp", "ttr", " ftc", " ftd", "aftpi", " fttp", "cttp", "aftt", " ftP", "ftk", "oftp", "aftr", " ftt", "rotr", "ottp", " ftpn", "aftpn", "fftp", "ftP", " ftport", "iftpe", "ttpn", "ttport", "ftpat", "afttp", "httpe", "ttpe", " ftpi", "ftcp", "ftpn", "topr", "oftt", "raftphp", "iftcp", "rotk", "ftpi", " fty", "fabr", "rotpe", "toppe", "ffcp", "ttc", "ftr", "ctcp", "ottphp", "ffp", "ottpat", "ttp", "aftk", "ffr", " ftr", "ftt", " ftpp", "httr", "fty", "aftping", "aftP", "threadpe", "iftr", "aftcp", "ftd", "ifttp", "ffping", "fabp", "oftping", "fttp", "oftr", "threadp", "ifty", "fabc", "afty", "ctp", "iftk", "topp", "iftd", "ftport", "ftc", "raftp", "fft", "fabpi", "htttp", "iftt", "aftport", "aftd", "aftpat", "aftc", "ctr", "toptp", "iftpp", "rotp", "ttP", "threadc", "ftphp", "raftt", "aftphp", "aftp", "aftpe", "raftpat", "iftp", "ffc"], "path": ["Path", "prefix", "PATH", "ath", "pkg", "root", "p", "wd", "prop", "dir", "filename", "ref", "name", "str", "cp", "dest", "directory", "copy", "port", "chain", "cert", "full", "context", "url", "cmd", "host", "c", "pattern"], "currentDir": ["activeDir", "reportedPos", "tempDir", "activePath", "reportedDir", "CurrentPos", " currentPath", "currentPos", " currentDirectory", " currentFile", "reportedDIR", "reportedDirectory", "tempDirectory", "currentDIR", "activeFile", "tempPath", " currentPos", "CurrentDir", "CurrentDirectory", "tempDIR", "activePos", "reportedFile", "currentPath", "activeDIR", "currentFile", "currentDirectory", "activeDirectory", " currentDIR"], "reply": ["ch", "message", "reason", "timeout", "notice", "close", "replace", "time", "sync", "nb", "ret", "response", "onse", "echo", "shell", "proxy", "send", "vote", "state", "transfer", "reset", " Reply", "re", "mi", "answer", "respond", "nr", "back", "continue", "call", "flag", "code", "pty", "write", "trust", "error", "next", "post", "Reply", "err", "result", "record", "print", "consider", "status", "pop", "zero", "match", "info", "query", "repl", "report", "ply"]}}
{"id1": "1485383", "id2": "2324868", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetAppListening", "runGetApplicationListING", "runGetApplicationListings", "runGetAppListING", "runGetApplistING", "runGetApplistening", "runGetAppAllening", "runGetAppAllING", "runGetApplicationListing", "runGetApplisting", "runGetApplistings", "runGetAppAllings", "runGetAppAlling", "runGetApplicationListening", "runGetAppListings"], "url": ["path", "http", "ls", "location", "abs", "user", "ret", "link", "ur", "lb", "Url", "ul", "address", "URL", "id", "api", "au", "ssl", "uri", "dl", "nl", "server", "ref", "google", "ll", "service", "l", "u", "k", "result", "gc", "base", "acl", "domain", "job", "sb", "web", "https", "res", "host"], "appListingList": ["appListningNot", "applistlingL", "appListuingL", "appListlingSpec", "appParterList", "appLististingL", "appListerList", "appLististingList", "applistlingList", "appBlockingStatus", "appHoldingList", "appListINGlist", "appListlingGroup", "appHoldingType", "appListningL", "appBlocklingList", "appListedList", "appListeninglist", "appListingslist", "appBlockingList", "appBlocklingGroup", "appListingNot", "appPartingList", "appListedSpec", "appBlockINGL", "appListingsList", "applistlingSpec", "appHoldinglist", "appListhingSpec", "appListingEx", "appHoldingslist", "appBlockINGStatus", "appListingStatus", "applistingList", "appListingGroup", "appListninglist", "appListedType", "appListedL", "appListINGStatus", "applistlingEx", "appListeningList", "appBlockINGList", "appListerNot", "appParterL", "appListuingList", "appListhingEx", "appHoldingL", "applistingEx", "appLististingNot", "appHoldingsList", "appListningList", "appBlockingGroup", "appListeningL", "appListINGList", "appListuingGroup", "appListinglist", "appListingsGroup", "appListingsL", "appPartinglist", "appListlingEx", "appHoldingsType", "appListhingL", "appListerL", "appBlockingL", "appBlockINGlist", "appListeningType", "appParterlist", "appPartingL", "appListingType", "appListlingList", "appListINGL", "appListningStatus", "appHoldingsL", "applistingSpec", "appLististinglist", "appListhingList", "appListlingL", "appBlockinglist", "appParterNot", "appPartingNot", "appListingSpec", "applistingL", "appListedlist", "appListingsType", "appListingL", "appBlocklingL", "appListedEx", "appListerlist", "appListingsStatus"], "request": ["buffer", "message", "http", "application", "list", "shape", "close", "QUEST", "method", "instance", "hello", "open", "over", "change", "condition", "connection", "q", "root", "complete", "reset", "accept", "create", "queue", "re", "use", "client", "resource", "initial", "relative", "setup", "call", "forward", "req", "apache", "writer", "process", "quest", "get", "service", "position", "record", "rate", "print", "command", "project", "input", "copy", "Request", "set", "object", "select", "job", "trip", "query", "remove", "ip", "begin", "report", "first", "order", "question"], "readTimeout": ["connecttimeout", "connectTimeout", "connectLimit", "writeLimit", "httptimeout", "httpTime", "readTime", "httpTimeout", "ReadLimit", "writetimeout", "readLimit", "httpLimit", "ReadTime", "sendTimeout", "connectTime", "readtimeout", "writeTimeout", "ReadTimeout", "sendLimit", "Readtimeout", "sendtimeout", "sendTime", "writeTime"], "response": ["output", "ve", "message", "http", "application", "json", "description", "block", "open", "onse", "connection", "feed", "body", "ce", "frame", "respond", "answer", "resp", "resource", "channel", "server", "exit", "e", "tree", "group", "process", "next", "view", "service", "bytes", "respons", "page", "Response", "result", "sequence", "remote", "entry", "object", "status", "reply", "document", "data", "success", "trace", "res", "out", "image", "report", "network"]}}
{"id1": "20991673", "id2": "13233761", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"generateTopicId": ["generateTopicDir", "generateThreadName", "generatesTopicId", "generateNodeDir", "generatesNodeDir", "generateThreadDir", "generatesNodeID", "generateTopicName", "generateThreadID", "generateTransactionDir", "generateTransactionId", "generatesNodeName", "generateTransactionName", "generateNodeId", "generatesNodeId", "generateNodeID", "generateTopicID", "generateTransactionID", "generatesTopicDir", "generateNodeName", "generateThreadId", "generatesTopicName", "generatesTopicID"], "topicName": ["topicInfo", "topicFamily", "TopicData", "threadData", "Topicname", "messageNames", "threadKey", "topicData", "TopicFamily", "messageInfo", "messagename", " topicname", "opicFamily", " topicNames", "topicNames", " topicFamily", "topicKey", "threadName", "topicname", " topicKey", " topicInfo", "TopicKey", "opicName", "opicData", "TopicName", "threadname", "opicInfo", "TopicInfo", " topicData", "TopicNames", "messageName"], "md": ["alg", "dr", "bf", "ms", "pdf", "msg", "sd", "mc", "bd", "od", "me", "metadata", "MD", "sha", "grad", "der", "cd", "mg", "mm", "dm", "mt", "M", "rm", "ind", "red", "ma", "sm", "ME", "dh", "det", "ld", "mb", "d", "dd", " mc", "mac", " Md", "mp", "mk", "mod", "dig", "pd", "m", "hash", "df", "di", "mn", "mand", "cmd", "med", "hd", "ng", "de"], "digest": ["decests", "candEST", " digested", "Digest", "digested", " digEST", "decest", "designest", "designested", "decested", "signests", "candest", "Digests", "DigEST", "hashest", "diggest", "digEST", "Digested", "digressed", "digests", "signest", "digidate", "designEST", "Digidate", "hashEST", "candested", " digressed", "hashested", "signested", "candressed", "Digressed", "signidate", "decidate", "designgest", "Diggest", "hashgest"], "newId": [" newMid", "NewById", "nextMid", "newsById", "Newid", "NewMid", "nodeMid", " newById", "nextId", "newMid", "newById", "NewId", " newid", "nextById", "newsMid", "nextid", "newsid", "nodeId", "newid", "newsId", "nodeid", "nodeById"]}}
{"id1": "13414771", "id2": "17817568", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "label": 0, "substitutes": {"encriptPassword": [" descryptField", "EncriptKey", " desribeField", "EncriptAuth", " desizePassword", " descryptPassword", " desizeAuth", " desribePassword", "EncriptPassword", " descriptAuth", " desribeAuth", " descryptKey", " descryptAuth", " desizeField", "EncriptField", " descriptKey", " desizeKey", "EnribeField", " desribeKey", "EnribeAuth", " descriptPassword", " descriptField", "EnribeKey", "EnribePassword"], "passwd": ["pw", "psword", "assphrase", "mailword", "password", " passsword", "pword", "pasword", "passphrase", "assword", "defwd", " passw", "mailw", "defw", "defphrase", "asswd", "assw", "passsword", "paswd", "defword", " password", "mailwd", "pasw", "pwd", "passw", "mailphrase"], "md": ["dr", "pm", "mail", "mask", "ms", "add", "pdf", "sd", "mc", "bd", "od", "and", "MD", "hm", "der", "ds", "cd", "mg", "desc", "mm", "dm", "mt", "ind", "down", "red", "rm", "ma", "sm", "dh", "nt", "at", "ld", "mb", "d", "dd", "td", "mk", "mod", "managed", " MD", "pd", "m", "df", "di", "mo", "mn", "cmd", "hd"], "hash": ["message", "rh", "mask", "password", "Hash", "score", "hed", "has", "sq", "filter", "sha", "ssh", "h", "sample", "checked", "ashed", "mass", "oh", "uh", "ah", "key", "hex", "trust", "sh", "mac", "shadow", "hidden", "sum", "check", "bh", "proof", "her", "hd", "kernel", "cache", "ash"]}}
{"id1": "2396191", "id2": "11005804", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFormURLfast", "getLinksFromUrlfast", "getLinksFromHTTPfast", "getLinksFromURISafe", "getLinksFormHTTPfast", "getLinksFormHTTPFast", "getLinksFromURLSafe", "getLinksFromURLfast", "getLinksFromUrlFast", "getLinksFromHTTPSafe", "getLinksFromUrlSafe", "getLinksFormURLFast", "getLinksFromURIfast", "getLinksFormHTTPSafe", "getLinksFromHTTPFast", "getLinksFormURLSafe", "getLinksFromURIFast"], "p_url": ["pswlr", "adminoydir", "poymail", "pongorg", "pswjson", "p_html", "p_uri", "porebrowser", "p64org", "pingYurl", "ping_page", "primary_URL", "p6dir", "primary_url", "private_html", "poredir", "p6browser", "primaryongemail", "pongURL", "p_line", "p3lr", "vp_link", "poyuid", "p6html", "primaryongurl", "x3dir", "p_json", "p_URL", "primaryongURL", "pingYline", "ping_line", "p___page", "pYpage", "ping_url", "p3dir", "poydir", "postonemail", "admin_uid", "private_url", "postonorg", "p_uid", "p64URL", "x3lr", "poreurl", "admin_url", "p_email", "private_dir", "private_browser", "adminoymail", "primary_email", "p_org", "pswlink", "p_link", "p64email", "postonurl", "x_lr", "primaryongorg", "pongurl", "p_dir", "vp_json", "postonURL", "p3url", "pYlr", "p3uri", "pingYlr", "vp_lr", "p_lr", "vp_url", "p___url", "p64url", "p6url", "pswurl", "adminoyurl", "admin_mail", "p___line", "poyurl", "pongemail", "p_browser", "x3url", "porehtml", "p_page", "pYurl", "ping_lr", "adminoyuid", "p_mail", "x_uri", "pYline", "p___lr", "x3uri", "primary_org", "admin_dir", "pingYpage"], "x_url": [" x_net", "xJweb", "x_web", "xJlog", "xJnet", "x_net", "x_ls", " x_web", " x_cn", " x_log", "xJurl", "x_cn", " x_ls", "x_log"], "x_conn": ["x_client", "x3connection", "x3client", " x_nt", "x_con", "x_connection", "x3nt", "x_nt", "p_ws", " x_client", "p_con", "p_connection", "p_conn", "x_ws", "x3conn", " x_connection"], "x_is_reader": ["x_isresreader", "x_ais_rx", "x_ais_writer", "x_isresparser", "x_is2Reader", "x_ais_parser", "x_isresrx", "x_is2reader", "x_ais_reader", "x_is2read", "x_is2writer", "x_is_rx", "x_is_parser", "x_is_Reader", "x_is_read", "x_is_writer", "x_isreswriter"], "x_reader": ["ex_rr", "ex_reader", "x_rot", "rx_reader", "ex_stream", "rx_writer", "x8reader", "x8writer", "x_buffer", "x_writer", "x_stream", "x8buffer", "x_rr", "x8rot", "rx_buffer", "ex_writer", "rx_rot"], "x_line": ["xLEpage", "xmyline", "x_____print", "xmypage", "x_route", "ex_line", "ex_iter", "x_iter", "ex_link", "ex_page", "xLEstream", "ex_stream", "xLEiter", " x_print", "x_print", "xmyiter", "x_stream", "x_____match", "x_____line", "xLEline", "xmystream", "x_____page", "ex_route"], "e": ["ev", "eu", "es", "x", "se", "n", "ent", "te", "ef", "ye", "ie", "ze", "fe", "a", "me", "f", "et", "y", "eg", "o", "ele", "xe", "eeee", "en", "h", "ce", "re", "end", "ed", "er", "element", "t", "ere", "el", "ee", "ea", "E", "le", "oe", "eb", "g", "be", "ec", "d", "EEE", "he", "one", "l", "ae", "ue", "u", "event", "err", "pe", "eur", "ei", "ne", "m", "exp", "eps", "ge", "we", "r", "c", "de"], "x_match": ["ex_result", "xi_fire", "xi_message", "x__find", "xi_move", "x2process", "x_fire", "x_process", " x_member", "x__mat", "x___mat", "x__match", " x2match", "x_tag", "x___member", "x67match", "x_mat", "ex_entry", "x2mat", "x10entry", "ex_look", "x_find", "x_message", "x10result", "ex_member", " x2member", "x___message", "x10member", "x_look", "x___move", "x67member", "x_move", "rx_match", "rx_member", "rx_tag", "x2member", "x__result", "x_member", "rx_mat", " x_find", "x67process", "x67mat", "x___fire", "x10match", " x2process", "xi_match", "x___tag", "x2match", " x_process", "x_entry", " x_mat", "ex_match", "x___match", " x2mat"], "x_dir": ["x5path", "ex_path", "ex_file", "x_file", "x_div", "ex_dir", "ex_div", "x_path", "x5file", "x5div", "x5dir"], "x_root": ["x__path", "inx7root", "x_parent", "x7target", "x__target", "inx7path", "x7root", "x_target", "x7path", "x_path", "inx_path", "x__root", "inx7parent", "inx_parent", "x7parent", "x__parent", "inx_target", "inx7target", "inx_root"], "x_links": [" x_relations", " x_lines", "x__lines", "x__links", "x_lines", "x__relations", " x_pages", "x__pages", "x_pages", "x_relations"], "x_texts": ["x_lengthls", "x__textls", "x__loges", "x_paths", "x__texts", "x_pathes", "x_lengthes", "x__logls", "x_textes", "x__textes", "x_textls", "x_lengthsets", "x_logls", "x__logsets", "x_textsets", "x_logs", "x_pathls", "x__logs", "x__textsets", "x_lengths", "x_logsets", "x_loges", "x_pathsets"], "x_buf": ["x2buff", "x64buf", "x7buff", "x___Buff", " x_buffer", "x64temp", "x2temp", "x_Buff", " x2buf", "ex_temp", "x7pool", "x64bag", " x_uf", "x2bag", " x_pool", "ex_Buff", "x2buffer", "x___buf", " x2pool", "x2pool", "x_pool", " x2buff", "x2buf", "x_bag", " x2temp", "x2uf", "ex2buf", "x_buffer", "ex2Buff", "ex_buf", "x7buf", "ex2temp", "x_uf", " x_temp", "x_buff", " x_buff", "x_temp", "x7temp", "x___bag", "x2Buff", "x___temp", "x64Buff", "ex2bag", "ex_bag"], "x_matches": ["x_masets", "x_maschers", "x_matqs", "x_catchers", "x__masets", "x_morters", "x_patets", "x_morets", "x__matches", "x_matets", "x_maqs", "x_attches", "x_attets", "x_memches", "x_maaches", "x_catters", "x__masists", "x_matcher", "x_matchchers", "x_matists", "x_actches", "x_catists", "x_masches", "x__matets", "x_matters", "x_morcher", "x_formatcher", "x_catets", "x_matchets", "x_memaches", "x_matchers", "x_attchers", "x__matchers", "x_machers", "x_patchers", "x_attists", "x_Matices", "x_catches", "x_Mataches", "x_patters", "x_matchches", "x_formatices", "x_morches", "x_Matches", "x_actchers", "x__masches", "x_memchers", "x_masists", "x_formatchers", "x_maches", "x_memqs", "x_mataches", "x2patets", "x_patches", "x_formatches", "x2matches", "x2patches", "x_patcher", "x_actices", "x2matcher", "x_matchters", "x_actcher", "x_matices", "x2matets", "x__matists", "x_Matcher", "x2patters", "x2patcher", "x2matters", "x_Matqs", "x_matchcher", "x_Matchers", "x__maschers"], "x_page": ["p_line", "xturl", "x_pp", " x_pp", "xhomeline", " x_port", "xhomeport", "p_page", "p_net", "xtmessage", "x_net", "x_message", "xtpage", " x_message", "xhomepp", "xhomepage", "x_port", "xtline"], "x_link": ["xe_ink", " x_path", "xe_link", "x42location", "x42page", "xe_url", "x42path", "x_ink", "x_path", "x_location", "xe_links", "x42link", " x_location"], "i": ["multi", "ims", "im", "x", "j", "n", "phi", "init", "it", "ini", "ai", "is", "ic", "fire", "ui", "me", "id", "y", "fi", "io", "mi", "ci", "ki", "ii", "qi", "v", "gi", "PI", "this", "hi", "key", "ti", "bi", "ji", "si", "I", "u", "batch", "m", "iter", "xi", "us", "iq", "cli", "ori", "ami", "di", "sim", "pi", "info", "chain", "origin", "in", "ip", "li", "oi", "ix"]}}
{"id1": "16621499", "id2": "7103223", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadUrlToBytes", "loadUrl2Buff", "loadURLToBytes", "loadURLtoBytes", "loadURL2Buffer", "loadUrlToBuffer", "loadUrlToBuff", "loadURL2Bytes", "loadUrl2Buffer", "loadURLtoBuff", "loadURL2Buff", "loadURLtoBuffer", "loadUrl2Bytes", "loadURLToBuff"], "url": ["http", "mail", "html", "ls", "location", "sl", "open", "bel", "link", "ur", "b", "Url", "ul", "address", "URL", "loader", "pl", "ssl", "uri", "dl", "nl", "el", "browser", "gl", "str", "name", "xml", "ll", "l", "char", "page", "base", "file", "log", "job", "web", "cert", "r"], "buf": ["buffer", "bo", "Buffer", "db", "font", "nb", "img", "msg", "pkg", "tmp", "bar", "b", "bp", "bs", "bag", "Buff", "dat", "axe", "bn", "cat", "bl", "BU", "queue", "cv", "desc", "seq", "conv", "bu", "fb", "arr", "bt", "buff", "nt", "uf", "box", "str", "vec", "cb", "bytes", "tr", "txt", "bc", "batch", "ctx", "tx", "cap", "capt", "mu", "log", "br", "bh", "div", "cmd", "mus", "rb"], "data": ["bo", "it", "tmp", "count", "to", "size", "bin", "buff", "content", "str", "set", "br", "list", "buffer", "text", "json", "a", "msg", "arr", "this", "done", "name", "bytes", "only", "obj", "batch", "partial", "def", "div", "res", "output", "part", "missing", "ret", "ata", "dat", "no", "map", "nt", "null", "dec", "good", "result", "action", "table", "message", "step", "type", " DATA", "item", "raw", "p", "rel", "default", "DATA", "initial", "total", "length", "all", "next", "bus", "txt", "zero", "value", "mu", "di", "results", "info", "format", "out", "image", "cache"], "temp": ["buffer", "fake", "deg", "mont", "emp", "term", "vol", "template", "font", "ret", "unt", "EMP", "tt", "tmp", "rem", "tar", "em", "tm", "dat", "ta", "variable", "util", "met", "test", "mm", "t", "pos", "pt", "current", "buff", "v", "pre", "null", "alt", "tc", "unit", "dest", "ptr", "mp", "tr", "txt", "result", "mod", "Temp", "porary", "tim", "mem", "partial", "copy", " Temp", "nom", "tem", "div", "cache"], "iCount": ["iCounter", "iCategory", "uiTotal", "liTotal", "biTotal", "jCount", "iuCount", "piCount", "phiMark", "phiNumber", "liCount", "icount", "iiTotal", "iriNow", "giTotal", "diCount", "iNow", " iCode", "giCode", "iCP", "iniMark", " icount", "iiNow", "biCount", "iiCounter", "giCount", "diCounter", "uiCounter", "iuTotal", "phiCount", "jcount", " iCheck", "aiCount", "piCP", "iiCall", "iniLength", " iMark", "aicount", "aiTotal", "uiCall", "iuCP", "intProcess", "jTotal", "diTotal", "iniNumber", "jLength", "intNow", "piCounter", "piLength", "phiLength", "ciTotal", "uiCount", " iNumber", "ciCounter", "piTotal", "ciCP", "biCheck", "iiCount", "aiCounter", " iLength", "liCall", "iMark", "giCounter", "ciCount", "intCategory", " iCounter", "iriCount", "iiCategory", "iniCount", "giLength", "iuCounter", "dicount", "aiLength", "iiProcess", "intCount", "giCheck", "liCounter", "iProcess", "iLength", "iCheck", "iriCategory", "iCall", "iriProcess", "biCode", "iNumber", "iCode"], "iTotal": ["iDone", "iiZero", "aiToken", "uiTotal", "phiTemp", "liTotal", "jCount", "phiLast", "piCount", "miNew", "iFull", "piFull", "miAll", "liCount", "iiTotal", " iCurrent", "imZero", "aiAll", "diCount", "phiNew", "iNow", "piParent", "diNow", "iuTarget", "iAll", " iParent", "iCurrent", "ciToken", " iZero", "iToken", "iuTotal", "ditotal", " iNow", " iFull", "ciComplete", " iTarget", "iuLast", "liLast", "iuNew", "iZero", "miZero", "mitotal", "iComplete", "miComplete", "imTotal", " iNew", "uiFull", "jNow", "aiComplete", "aiTotal", "jTotal", "piDone", "iNew", " iTemp", "diTotal", "itotal", "liNew", "miToken", "miTotal", " iLast", "ciTotal", "ciAll", "iLast", "iParent", "piTotal", "miLast", "iiCount", "liTemp", "jtotal", "uiDone", " iDone", "jCurrent", "iitotal", "liParent", " itotal", "iTemp", "imtotal", "phiTotal", "iTarget", "miCurrent", "imCount", "miTarget", "jZero"], "in": ["IN", "on", "per", "din", "con", "add", "or", "by", "it", "is", "mc", "ic", "and", "b", "h", "en", "inc", "io", "from", "mm", "re", "ind", "al", "ins", "ma", "up", "bin", "v", "serv", "inner", "reader", "get", "isin", "r", "l", "sum", "In", "check", "input", "i", "mn", " din", "info", "inn", "out", "conf", "inf", "cin"]}}
{"id1": "11477906", "id2": "20375440", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadFAULTSetting", "loaddefaultsettings", "readdefaultSetting", "loaddefaultSettings", "readdefaultSettings", "loaddefaultSetting", "loadFAULTSettings", "readDefaultValues", "readDefaultSettings", "loadDefaultSetting", "readdefaultsettings", "loadFAULTsettings", "readDefaultSetting", "loadDefaultsettings", "readDefaultsettings", "loadDefaultValues", "readdefaultValues", "loaddefaultValues", "loadFAULTValues"], "configFileName": ["configfilePath", "configPagePath", "configFilenamename", "confFileLocation", "configFilenameLocation", "configFILEName", "configFILELocation", "conffileName", "configFILEname", "confFilePath", "configFilenameName", "configFileNames", "configStreamName", "conffilePath", "configFilename", "confFilenameLocation", "configStreamname", "configfileName", "configfilename", "conffileNames", "configFilenameNames", "configfileNames", "confFilenameName", "confFileNames", "configFILEPath", "configFilenamePath", "configFileLocation", "confFilename", "configStreamLocation", "configPagename", "conffilename", "configPageNames", "confFilenamename", "confFilenamePath", "configFilePath", "configPageName", "confFileName", "configStreamPath"], "in": ["IN", "on", "din", "con", "gin", "ls", "or", "im", "init", "n", "it", "user", "ini", "rin", "is", "mc", "ai", "ze", "ain", "id", "o", "en", "from", "mi", "re", "ind", "al", "ins", "t", "ar", "ma", "up", "bin", "run", "e", "inner", "doc", "isin", "l", "In", "check", "input", "source", "m", "i", "ro", "info", " din", "inn", "inf", "ad", "cin"], "out": ["ion", "it", "not", "aos", "to", "ind", "t", "at", "gc", "OUT", "port", "file", "con", "or", "init", "auto", "une", "ent", "des", "o", "ex", "outs", "conv", "ou", "writer", "w", "obj", "net", "po", "oss", "co", "off", "res", "handle", "are", "output", "n", "can", "os", "en", "OU", "ins", "client", "up", "server", "nt", "null", "check", "copy", "m", "cache", "ge", "update", "over", "Out", "user", "sys", "raw", "read", "io", "v", "ing", "all", "store", "gt", "ne", "cn", "log", "ot", "de"]}}
{"id1": "11341711", "id2": "7087108", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makebackups", "createbackups", "makeDups", "makeDpoint", "createbackupid", "createBackup", "makeStpoint", "makebackup", "makebackpoint", "createbackpoint", "createBackups", "makeStups", "makebackupid", "createBackpoint", "makeBackpoint", "makeBackupid", "makeDupid", "makeStupid", "makeDup", "makeBackups", "createbackup", "makeStup", "createBackupid"], "dir": ["path", "disk", "dr", "db", "mail", "window", "or", " d", "vol", "addr", "dis", "draw", "pkg", "tmp", "handle", "del", "dat", "y", "wd", "folder", "local", "direct", "rad", "dm", "ind", "dep", "dl", "loc", "src", "dist", "store", "DIR", "doc", "dd", "d", "Directory", "md", "ir", "directory", "Dir", "base", "iter", "file", "data", "fd", "in", "url", "out", "zip"], "sourcedir": ["isourcedr", " sourcesir", "isourcer", "sourcesel", "senderr", "sourcedirs", " sourcesirs", "sourcedr", "sourceirs", "senderel", "sourcedire", "sourcesirs", "senderdir", "senderir", "sourcesire", "soreddir", "sourcesdir", "sourceir", "soredire", "soredir", "isourcedir", "sourceddir", "sourcesir", "isourceddir", "sourceel", " sourceddir", " sourcedire", "sourcer", " sourcesire", "sourcesr", "soredirs", "isourcedel", "sourceire", " sourcesdir", " sourcedirs", "sourcedel", "isourceel", "isourceir"], "destinationdir": ["estinatordb", "destensionfolder", "destinatorfolder", "stinationir", "stinationdir", "destinationsdb", "destensiondir", "destinatordir", "stinationsir", "destinatordiv", "destinationdiv", "estinationDir", "destiondb", "destiondir", "stinationdb", "stinationsdiv", "destensionDir", "destionfolder", "stinationsdir", "destineddb", "destinationsdiv", "destineddir", "stinationsdb", "destinationfolder", "estinatorfolder", "destinationsir", "destensiondb", "destinationdb", "destinedir", "destinatorir", "estinationfolder", "destinationDir", "estinatorDir", "destinatorDir", "destinatordb", "destineddiv", "destinationsdir", "estinationdb", "estinationdir", "estinatordir", "stinationdiv", "destionDir", "destinationir"], "destinationDirEnding": ["destinationDirEndging", "destinationDirFeediting", "destinationDirectoryEnding", "destinationDirectoryEnder", "destinationFileEveniting", "destinationDirectoryENDing", "destinationDirServing", "destinationDirEnder", "destinationDirENDding", "destinationDirENDing", "destinationDirectoryEndging", "destinationDirectoryENDding", "destinationDirENDer", "destinationFileEnditing", "destinationDirEveniting", "destinationDirENDiting", "destinationDirEvenging", "destinationDirectoryENDer", "destinationDirEvending", "destinationFileEnding", "destinationDirENDging", "destinationFileEvener", "destinationDirFeedING", "destinationDirFeeder", "destinationDirServging", "destinationFileEnder", "destinationDirFeeding", "destinationDirEnditing", "destinationDirectoryENDging", "destinationDirEvenING", "destinationDirServer", "destinationDirectoryEndding", "destinationDirEndding", "destinationDirServding", "destinationDirENDING", "destinationFileEndING", "destinationFileEvening", "destinationDirEndING", "destinationDirEvener", "destinationDirEvening", "destinationFileEvenING"], "files": ["uploads", "states", "faces", "assets", "strings", "ls", "links", "words", "parents", "plates", "headers", "users", "types", "ports", "prints", "facts", "iles", "lets", "bs", "images", "Files", "params", "its", "sections", "qs", "forms", "pages", "tests", "items", "lines", "obs", "filename", "classes", "actions", "ids", "features", "fixes", "ames", "bytes", "keys", "mails", "errors", "values", "fs", "projects", "parts", "details", "reports", "tools", "fields", "file", "resources", "docs", "modules", "names", "issues", "events", "members", "objects", "list"], "checkdir": [" checkdirectory", "checkir", "getfolder", "Checkfolder", "keydb", "getdir", " checkurl", "Checkir", "keydir", " checkdb", "checkeddir", "checkroom", "checkurl", "Checkblock", "workurl", " checkfolder", "ckthis", "keyfolder", "Checkroom", "checkblock", " checkblock", "Checkdb", "checkthis", "checkeddirectory", "workdir", "getdb", "keyroom", "Checkdir", "ckroom", "checkedDir", "checkdb", "ckdb", " checkthis", "checkeddb", "workDir", "checkedfolder", "ckDir", "checkfolder", "getblock", "ckdir", " checkir", "ckdirectory", "ckfolder", "checkedir", "Checkdirectory", "checkdirectory", "workthis", "CheckDir", "checkDir", "ckurl", " checkDir"], "date": ["close", "add", "iso", "time", "now", "cal", "user", "te", "msg", "zone", " Date", "dat", "ATE", "late", "dt", "note", "use", "month", "resource", "Date", "tag", " day", "key", "doc", "ate", "d", "day", "get", "none", "today", "event", "set", "file", "year", "data", "start", "diff", "de", "when"], "msec": [" mstr", "mstr", "mtstr", " msc", "cmsec", "gmsec", "MSec", "Msec", "mtcl", "cmisec", "msc", "mSec", " mcl", "mtisec", "mtct", "gmSec", "Mct", " mSec", "misec", " mct", "mcl", "cmsc", "gmsc", "mtsec", " misec", "mtsc", "gmstr", "mct", "cmcl", "mtSec"], "checkFile": ["readFiles", "CheckFILE", "readFile", " checkFiles", "readFILE", "CheckFiles", "updateFiles", "readfile", "readSourceFile", " checkSourceFile", "checkSourceFile", "Checkfile", "checkfile", "CheckFile", "updateSourceFile", "checkFILE", "updateFile", "checkFiles", "updateFILE", " checkfile", " checkFILE"], "i": ["multi", "im", "zi", "x", "j", "init", "phi", "it", "my", "ini", "ai", "is", "ic", "ie", "ui", "ri", "me", "major", "iu", "id", "y", "io", "ci", "mi", "gu", "ki", "ex", "ind", "ii", "qi", "gi", "hi", "key", "ti", "bi", "ji", "name", "index", "si", "I", "sequence", "ei", "base", "batch", "m", "xi", "cli", "iq", "di", "sim", "pi", "info", "exp", "ij", "in", "ip", "li", "ix"], "f": ["bf", "lf", "j", "fo", "fe", "fg", "b", "p", "o", "fi", "fp", "ft", "t", "fr", "fb", "v", "fc", "uf", "e", "d", "fl", "fac", "l", "u", "fs", "m", "df", "file", "fw", "F", "cf", "fd", "tf", "fa"], "g": ["j", "config", "msg", "graph", "fg", "b", "gs", "pg", "p", "eg", "mg", "gy", "gu", "t", "gg", "cfg", "v", "G", "gi", "gl", "e", "bg", "group", "gd", "d", "gb", "w", "l", "ig", "go", "vg", "ga", "gc", "gm", "m", "gp", "file", "tg", "og", "s", "ge", "out"], "destinationFile": ["destarationFiles", "destationFiles", "DestationFiles", "destinatorDirectory", "destinatedFile", "destationEmail", "destinateEmail", "DestationFile", "destarationDirectory", "destinatorFilename", "destarationFilename", "destationFilename", "destinationsFiles", "destinationsFile", "DestinationFilename", "transinatedFiles", "transinatedDirectory", "destinatorFile", "destinationFiles", "transinationDirectory", "destinatedFiles", "destinatedDirectory", "transinationFile", "transinationFiles", "transinatedFile", "destinationsFilename", "destarationFile", "destinatedFilename", "destinateFilename", "destinateFiles", "transinationFilename", "transinatedFilename", "destinationFilename", "DestinationFiles", "destinationsEmail", "DestationFilename", "destinationEmail", "DestinationFile", "destationFile", "destinationDirectory", "destinateFile", "DestinationEmail", "destinatorFiles", "DestationEmail"], "sourceFile": ["ourceFile", "Sourcefile", "ourcefile", "sourceLine", " sourceFILE", "sourceFiles", "staticFile", "sourceFILE", "SourceFilename", "ourceLine", "srcLine", "srcFile", " sourcefile", "SourceFiles", "staticfile", "sourceFilename", "srcfile", "srcFilename", "staticFILE", "SourceLine", "SourceFILE", "ourceFilename", "staticFiles", "sourcefile", " sourceFiles", "SourceFile"], "infile": ["Instream", " instream", "INfile", "pinline", "outFile", "INline", "pinfield", "inblock", "INFile", "inputblock", "insblock", "InFile", "Infile", " inline", "infield", "insFile", "inline", "insfile", "inputline", " inblock", " infield", "inputFile", "pinFile", "INfield", "insstream", "pinfile", "inFile", "Inblock", "outblock", "outline", "inputfile", "instream", " inFile"], "outfile": ["Outfile", "outerstream", " outline", " outbuffer", "inlink", "outpage", "outlink", " outFile", " outlink", "outview", "outputfile", "outputline", " outstream", "OutFile", "outputstream", "Outlink", "outerbuffer", " outpage", "inline", "outstream", "inpage", "outputpage", "inview", "Outstream", "outerview", "inFile", " outview", "inbuffer", "outline", "outFile", "outerfile", "outbuffer", "instream"], "c": ["ch", "nc", "cos", "C", "cu", "close", "x", "n", "a", "mc", "uc", "\u00e7", "ct", "count", "sc", "y", "cd", "rc", "o", "p", "col", "ce", "cs", "t", "lc", "unc", "ac", "v", "cm", "cr", "e", "code", "ec", "d", "cp", "dc", "cb", "char", "r", "k", "pc", "err", "bc", "u", "gc", "cl", "m", "cc", "z", "arc", "chain", "cf", "out", "conf", "ca", "cache"]}}
{"id1": "20208819", "id2": "14691829", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"hash": ["message", "update", "password", " sum", "Hash", "sign", "sha", "id", "h", "read", "uri", " hashing", "tag", "run", " fingerprint", "code", "key", "name", "dump", "get", "sum", "print", "check", "value", "render", "format", " Hash"], "input": ["output", "buffer", "message", "text", "password", "prefix", "hello", "config", "valid", "example", "q", "raw", "p", "accept", "sample", "lat", "Input", "current", "request", "this", "bit", "null", "char", "sequence", "form", "command", "string", "source", "select", "value", "active", "data", " inputs", "url", "in", "out", "empty", "image", "pattern"], "algorithm": ["aloch", "arabet", "alphabet", "validgo", "alphoch", "alabet", "validometry", "assometry", "algo", "assabet", "alometry", " Alabet", " Algorithm", "alphgo", "argorithm", "Algorithm", "validabet", " Aloch", "Aloch", "arometry", "assgo", "validgorithm", "assgorithm", "alphgorithm", "argo", "Alabet", "Algo", " Algo"], "dig": ["alg", "ve", "deg", "db", "add", "nd", "sd", "des", "bd", "od", "del", "Dig", "grad", "dat", "cd", "rip", "enc", "dir", "desc", "ind", "rd", "dep", " Dig", "dh", "cong", "cr", "g", "ld", "dd", "d", "fun", "dim", "comm", "dec", "dash", "round", "md", "mod", "df", "find", "pers", "plug", "div", "fin", "her", "ng", "de"], "result": ["output", "out", "proc", "part", "reason", "description", "mark", "prefix", "term", "user", "ret", "response", "currency", "product", "dat", "make", "rc", "complete", "region", "ral", "create", "relation", "true", "answer", "use", "created", "current", "up", "total", "wrapper", "continue", "component", "summary", "run", "this", "pair", "mate", "group", "next", "position", "event", "pixel", "print", "date", "match", "render", "comment", "results", "br", "profile", "join", "display", "success", "res", "r", "report", "Result"], "digest": ["Digse", "digist", "displaytest", "displayEST", "displayest", "Digest", "digested", " digested", "hasate", "Digate", "equgest", "displayested", "digenge", "equse", "digtest", "equested", " digenge", " digEST", " digate", "hasested", "equest", "hasest", "digate", "DigEST", "definedest", "dist", "diggest", "dest", "displaygest", "Digested", "digse", "digEST", "Digist", "definedse", "Digtest", "dgest", " digtest", "dested", "Digenge", "hasenge", "definedested", "displayist", "Diggest", "definedgest"], "hex": ["ch", "alpha", "json", "rex", "html", "tex", "term", "x", "ape", "des", "pex", "xf", "nuts", "percent", "raw", "wh", "prop", "h", "alph", "row", "ex", " Hex", "sex", "solid", "comp", "key", "sh", "index", "serial", "char", "form", "print", "hist", "check", "def", "utf", "tx", "iter", "ph", "zero", "oct", "exp", "https", "sv", "full", "com", "hw", "hl", "color", "zip"], "i": ["multi", "im", "zi", "x", "j", "n", "phi", "it", "ai", "ini", "a", "ic", "ri", "ui", "me", "f", "iu", "id", "y", "io", "ci", "mi", "ind", "ki", "uri", "conv", "ii", "qi", "v", "gi", "e", "hi", "g", "ti", "bi", "ji", "index", "si", "I", "k", "ei", "print", "batch", "m", "status", "xi", "cli", "z", "di", "pi", "ij", "info", "ip", "li", "\u0438", "ix"], "u": ["U", "eu", "cu", "unsigned", "uni", "user", "pu", "uc", "ui", "ur", "b", "ul", "um", "tu", "f", "iu", "su", "q", "util", "h", "num", "au", "bu", "t", "uj", "up", "v", "ou", "uu", "nu", "hu", "uv", "d", "uid", "ue", "you", "c", "uint", "us", "mu", "fu", "ut", "lu"], "highCount": ["hiCast", "highPtr", " highFlag", "lowCast", "highFlag", "higherAmount", "highLength", "highAmount", "higherCount", " highCode", "HighCount", "highcount", " highcount", "lowFlag", " highPtr", "Highcount", "HighCode", "highercount", "lowLength", "topCode", "HighPtr", " highLength", "topCount", "highCast", "lowcount", "highCode", "topcount", "hiFlag", "hiLength", "hiCount", "topPtr", "higherCast", " highAmount", " highCast", "lowAmount"], "lowCount": ["lowButton", "ownButton", "littleCounter", "lowCounter", "lowCold", " lowButton", "highLength", "littleLength", "ownSum", "midCold", "lowSum", "midLength", "highCountry", " lowSum", "ownCount", "midCountry", " lowCold", "midCounter", "midCount", "lowLength", "littleCount", "littleCountry", "midSum", "ownCold", "lowCountry", "midButton", "highCounter"]}}
{"id1": "6742637", "id2": "22977189", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 0, "substitutes": {"findExtensions": [" findExtions", " findEXTensions", "findextions", " findExtras", "findEXTensions", "findEXTions", "findextensions", "findAppensions", "findExtions", "findEXTension", "findextras", "findAppension", "findEXTras", "findAppions", " findEXTras", " findEXTions", "findAppras", "findextension", " findExtension", "findExtras", " findEXTension", "findExtension"], "url": ["path", "ch", "http", "mail", "ls", "location", "addr", "abs", "sl", "config", "val", "link", "ur", "Url", "ul", "address", "URL", "loader", "rel", "norm", "util", "row", "pl", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "filename", "server", "lim", "email", "browser", "gl", "ref", "key", "req", "str", "mount", "xml", "name", "ll", "l", "char", "string", "lr", "cl", "rl", "file", "domain", "parse", "sb", "web", "https", "cert", "host", "hl"], "extensions": ["Extension", "Extends", "xtensions", "dimends", "extences", "appendperties", "Extensions", "Extences", "expension", " extension", "exended", "appendended", "expperties", "extperties", "xtperties", "expensions", "xtended", "appendensions", "exensions", "expends", "expences", "extances", "dimensions", "dimances", "xtances", "exances", " extences", "extended", "extension", "appendends", "dimended", "xtends", "exends", "expended"], "res": ["ch", "gr", "ser", "proc", "rex", "reg", "ms", "es", "abs", "vol", "resolution", "sys", "rem", "ver", "ry", "rel", "rez", "reset", "re", "er", "ins", "RES", "ps", "ers", "rs", "rys", "ref", "rt", "req", "cons", "ress", "mr", "Res", "mer", "us", "vers", "pres", "ro", "range", "pers", "ber", "r", "rest"], "prop": ["priv", "proc", "attr", "add", "term", "properties", "buf", "val", "pkg", "ext", "tmp", "property", "tab", "p", "rel", "col", "np", "plot", "desc", "att", "pr", "feat", "pro", "rop", "pos", "op", "pt", "pid", "ps", "cfg", "etc", "kw", "comp", "pred", "key", "pb", "cp", "Prop", "mp", "def", "cap", "pic", "po", "exp", "jp", "cmd", "conf", "bug", "prot"], "msg": ["message", "gov", "text", "reason", "ms", "notice", "kg", "pkg", "gs", "body", "desc", "mt", "Message", "sm", "cfg", "cmp", "bg", "g", "str", "ug", "Msg", "char", "mun", "txt", "md", "err", "sg", "good", "print", "string", "gm", "m", "uint", "nom", "hog", "log", "og", "mn", "mess", "urg", "cmd", "med", "utt"]}}
{"id1": "13595251", "id2": "18693224", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargarArchico", " descargarActico", " descargarActive", " descargarRico", " descargarRiv", " descargarMotive", " descargarRivo", " descargarActiv", " descargoArchico", " descargoMotico", " descargoMotivo", " descargoMotiv", " descargarActivo", " descargarArchiv", " descargoMotive", " descargoArchive", " descargarMotiv", " descargarRive", " descargoArchivo", " descargarMotivo", " descargarMotico", " descargoArchiv", " descargarArchive"], "fis": ["ufos", " fiss", "fiis", "dfris", "fiiss", "ffis", " fris", "fiss", "Fis", "ffix", "dfis", "Fiss", "ffiss", "dfiss", "fiix", "Fos", "ffris", "fix", " fios", "ufris", "ufiss", "fios", "ufis", "Fris", "ffios", "dfos", " fix", "ffos", "fris", "fiios"], "fos": [" fOS", "faos", "infbos", " fOs", "woses", "lfoses", "fedOs", "fOS", "fbos", "flaos", "voss", " foes", "fedbos", "infOS", "wbos", "vows", "infos", "flos", "lfos", "fedos", "vos", "infOs", "fOs", "wows", "floses", "foes", " fbos", " foss", "woes", "fows", "lfbos", "fedOS", "flbos", " fows", "lfaos", "foses", "foss", "woss", "waos", "wos", "voes"], "inChannel": ["innChan", "inputConnection", " inButton", "inConnection", "inchannel", "InChannel", "InConnection", "aiRow", "aichannel", "inGray", " inchannel", "inChan", "inputChan", "InButton", "innerchannel", "Inchannel", "innerChan", " inChan", "outchannel", "inRow", "aiChan", "innerButton", "innRow", "initConnection", "innChannel", "InGray", "initGray", "outChan", "initChan", "initChannel", "innchannel", "InChan", "inputGray", "aiChannel", "inButton", "outRow", "inputChannel", "innerChannel"], "outChannel": ["OUTConsole", "OUTButton", " outStream", "inchannel", " outchannel", "inChan", "OUTStream", " outConsole", "outchannel", "OUTChannel", "inStream", " outButton", "outButton", " outChan", "outChan", "OUTchannel", "OUTChan", "outStream", "inButton", "outConsole", "inConsole"]}}
{"id1": "19584877", "id2": "2461169", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromDisk", "encodeFiletoStream", "encodeFiletoFiles", "encodeStringAsFiles", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileToFiles", "encodeStringToDisk", "encodeFileAsDisk", "encodeFileToStream", "encodeStringToStream", "encodeStringAsStream", "encodeFileAsFiles", "encodeFileFromStream", "encodeFileAsFile", "encodeFileAsStream", "encodeFiletoFile", "encodeStringAsDisk", "encodeFileFromFiles", "encodeStringAsFile", "encodeFileFromFile", "encodeStringToFile", "encodeFileToDisk"], "infile": ["Inpath", "inputpath", "inputfile", "infilename", "InFile", "Infile", "inputfilename", "Inbase", "outfilename", "outbase", " infilename", "inputFile", " inpath", "inFile", " inbase", "inbase", "outFile", "inpath", "outpath", " inFile"], "outfile": ["fromfp", "fromdir", "outname", " outfilename", " outname", "fromfile", "infp", " outFile", "newfile", "outdir", "todir", "infilename", "outfp", "fromFile", "newname", "tofile", "tofp", "newFile", "outfilename", "newfilename", "toFile", "inname", "indir", "inFile", "outFile"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "image", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "ro", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "up", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "queue", "frame", "note", "bone", "initial", "total", "buff", "length", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "append", "display", "paste", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "reading", "index", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " Success", " okay", "valid", "ceed", "support", "response", "town", "condition", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "warning", "photo", "sufficient", "error", "done", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first", "ith"]}}
{"id1": "18731843", "id2": "1133123", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "label": 0, "substitutes": {"doBody": [" doContent", " writebody", "loadContent", " dobody", " doHead", "loadbody", " sendBody", " sendHead", " sendbody", " sendContent", " writeHead", "loadHead", " writeBody", "loadBody", " writeContent"], "req": ["gr", "proc", "http", "express", "qt", "reg", "j", "qq", "pkg", "rec", "requ", "aj", "q", "inv", "hr", "crit", "pro", "fr", "Requ", "ps", "js", "request", "quest", "quick", "exec", "err", "def", "Request", "ctx", "tx", "query", "jp", "urg", "cmd", "res", "conf", "sq", "wx"], "resp": ["output", "wr", " res", "http", "Resp", "vol", "rep", "ret", "rec", "response", "wa", "rel", "re", "respond", "pos", "client", "RES", "esp", "serv", "js", "sol", "next", "comm", "respons", "Res", "Response", "err", "result", "Rep", "trans", "def", "cl", "sp", "exp", "res", "out", "soc"], "bis": ["bat", "atis", "ais", "mis", "idis", "lin", "iso", "ris", "is", "nis", "bie", "phis", "bps", "bs", "pin", "iss", "os", "ses", "mi", "onis", "fps", "bits", "obs", "pins", "ubis", "bt", "webkit", "rison", "ads", "bil", "be", "bi", "aus", "bid", "bes", "isin", "iris", "avi", "los", "lbs", "isi", "oss", "zo", "bh", "ios", "sb", "inet", "oi", "lis", "cin"], "bos": ["bo", "oops", "nos", "tis", "asis", "oos", "banks", "mes", "jas", "is", "ows", "uts", "gs", "bs", "dos", "aos", "uds", "os", "its", "ys", "BS", "outs", "bits", "obs", "pins", "ubis", "bin", "bas", "ubs", "bil", "ods", "acs", "bi", "stones", "bes", "zb", "eros", "fits", "fs", "ols", "los", "vas", "oss", "tes", "bh", "ios", "asket", "ts", "oi"]}}
{"id1": "21092340", "id2": "3958807", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"addToArchive": ["addToHariver", "addToExFile", "addInHariver", "addToExiver", "addToExive", "addInArchive", "addInHarZip", "addToZipiver", "addToArchFile", "addToZipFile", "addToArchZip", "addToArchiver", "addInArchiver", "addInHarive", "addToHarive", "addToExZip", "addToHarFile", "addToHarZip", "addInArchZip", "addToZipive", "addInArchFile", "addInHarFile", "addToZipZip"], "pod": ["proc", "message", "disk", "top", "task", "volume", "pkg", "od", "zone", "body", "p", "pick", "wp", "report", "op", "spec", "component", "pack", "module", "ods", "poll", "post", "cp", "ack", "policy", "pc", "project", "check", "point", "device", "archive", "table", "job", "pad", "start", "Pod", "ad"], "podArchiveOutputStream": ["podArchiverOutputMap", "podArchiveEntryStream", "podArchiveResourceContext", "podArchiveInputStream", "podArchiverInputSync", "podArchiveOutputStreamer", "podArchiveOUForm", "podArchiverInputStreamer", "podArchiveStreamForm", "podArchiveOutStream", "podArchiveStreamSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiveoutputForm", "podArchiveOUStream", "podArchiveOutputstream", "podArchiverOutputStreamer", "podArchiveOutputMap", "podArchiveStreamStream", "podArchiveOutContext", "podArchiveoutputStreamer", "podArchiverOutputPoint", "podArchiveOutPoint", "podArchiveResourceSteam", "podArchiveMainStreamer", "podArchiveOUMap", "podArchiveoutputStream", "podArchiveInputContext", "podArchiveoutputSteam", "podArchiveMainSteam", "podArchiveOutputSteam", "podArchiverOutputSync", "podArchiveInputStreamer", "podArchiveOutputSync", "podArchiverOutputSteam", "podArchiveMainStream", "podArchiverInputContext", "podArchiveOutputContext", "podArchiveInputForm", "podArchiveResourcestream", "podArchiveOutstream", "podArchiveOutputForm", "podArchiverInputSteam", "podArchiveInputSteam", "podArchiveOutSteam", "podArchiveInputMap", "podArchiverInputMap", "podArchiveInputPoint", "podArchiveEntryPoint", "podArchiveMainForm", "podArchiverInputStream", "podArchiverInputPoint", "podArchiverOutputContext", "podArchiverOutputForm", "podArchiverOutputStream", "podArchiveOUSync", "podArchiveResourceStream", "podArchiverInputstream", "podArchiveInputstream", "podArchiverOutputstream", "podArchiveInputSync", "podArchiveEntrySteam", "podArchiveStreamMap"], "filename": ["fn", "path", "nil", "message", "output", "binary", "description", "location", "prefix", "jpg", "fil", "title", "latest", "nm", "p", "FN", "Filename", "folder", "fp", "stem", "subject", "uri", "resource", "png", "NAME", "ename", "ame", "release", "key", "name", "original", "version", "println", "upload", "username", "family", "txt", "directory", "kl", "FILE", "string", "archive", "file", "names", "url"], "source": ["series", "ser", "proc", "style", "password", "template", "SOURCE", "force", "seed", "address", "shell", "body", "loader", "ource", "sql", "sample", "iterator", "from", "use", "resource", "spec", "Source", "component", "src", "inner", "store", "view", "get", "service", "stream", "sequence", "copy", "input", "select", "file", "info", "context", "start", "image", "supp"], "entry": ["ment", "task", "cell", "or", "cue", "book", "se", "ent", "ie", "link", "tmp", "attribute", "connection", "sheet", "ry", "row", "ce", "card", "element", "channel", "resource", "nt", "component", "key", "ace", "quick", "char", "obj", "good", "record", "enter", "line", "set", "archive", "file", "log", "job", "comment", "system", "query", "data", "Entry", "word", "zip"]}}
{"id1": "22235113", "id2": "19113613", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallEml", "unmarshalXml", "unmarshallXsl", "unmarshallYml", "unmarshallEplex", "unmarshallAsml", "unmarshalYml", "unmarshallAsplex", "unmarshallEsl", "unmarshalXplex", "unmarshallAssl", "unmarshallXplex", "unmarshalYplex", "unmarshallYxml", "unmarshallExml", "unmarshallXxml", "unmarshallYsl", "unmarshalXxml", "unmarshalYxml", "unmarshalXsl", "unmarshallAsxml", "unmarshallYplex", "unmarshalYsl"], "unmarshaller": ["unmachailing", "unmachailer", "unmarshillier", "unmarshcalloser", "unmarshailable", "unmarshCalling", "unmachailable", "unmarshcallier", "unmMarshcallers", "unmarshellers", "unmachallable", "unmarshiller", "unmachallers", "unmarshalling", "unmachalling", "unmarshelloser", "unmMarshcallier", "unmarshallable", "unmarshcalling", "unmarshallier", "unmMarshalloser", "unmarshailer", "unmMarshcalloser", "unmarshcallable", "unmMarshallers", "unmachailers", "unmarshilloser", "unmarshalloser", "unmarshailing", "unmMarshaller", "unmarshailers", "unmMarshallier", "unmarshcaller", "unmarshillers", "unmarshellier", "unmarshCallable", "unmarshCallers", "unmachaller", "unmarshcallers", "unmarsheller", "unmarshallers", "unmMarshcaller", "unmarshCaller"], "accessUrl": ["execUrl", "uploadurl", "accessPage", "accessurl", "uploadURL", "accessibleUr", "AccessDb", " accessurl", " accessURL", "accessibleUrl", "AccessPath", "accessURL", "accessUr", "uploadUr", "ccessUrl", "ccessurl", " accessUr", "accessPath", "axURL", "aceUrl", "ccessURL", "execPath", "accessibleURL", "execUr", "accessDb", "ccessPage", "Accessurl", "execURL", "AccessURL", "acePage", "aceurl", "axUrl", "AccessUrl", "axUr", "accessibleDb", "AccessPage", "axDb", "aceURL", "AccessUr", " accessPath", "uploadUrl", "ccessUr"], "nameSpace": ["NameSpace", "whiteSpace", "nameBox", " nameSp", "resourceSpace", "whitespace", "NameType", "linkSpace", " nameBox", "Namespace", "nameSp", "resourceBox", "nameAccount", "wordSpace", "wordBox", "whiteSp", " nameAccount", "linkspace", "resourcespace", " namespace", "wordspace", "nameType", "whiteAccount", "linkSp", " nameType", "namespace", "NameAccount", "linkType", "NameSp"], "replace": ["strip", "place", "each", "update", "add", "prefix", "close", "template", "save", "over", "cover", "force", "apply", "align", "change", "after", "filter", "repeat", "places", "old", "alter", "gre", "re", "register", "use", "sub", "map", "insert", "transform", "wrapper", "pair", "delete", "write", "group", "store", "fix", "share", "tool", "record", "fill", "string", "look", "hash", "same", "match", "escape", "join", "find", "search", "format", "remove", "include", "repl"], "with": ["path", "spr", "self", " without", "add", "using", "now", "x", "by", "then", "apply", " WITH", "without", "after", "repeat", "title", "via", "id", "sql", "default", "spec", "require", "where", "xml", "With", "form", "set", "here", "tx", "cap", "value", "join", "work", "format", "php", "context", "handle", "which", "color", "ith"], "url": ["http", "mail", "ls", "sl", "open", "user", "bel", "link", "ur", "Url", "ul", "address", "URL", "ssl", "uri", "dl", "nl", "channel", "resource", "browser", "ref", "this", "str", "mount", "xml", "impl", "ll", "external", "service", "l", "u", "char", "base", "rl", "sb", "https", "web", "cert", "r"], "inputStream": [" InputSteam", "outputSteam", " inputThread", "inputstream", "imagestream", " Inputstream", " inputSteam", "imageThread", "outputstream", " InputStream", "inputThread", "inputSteam", "inStream", " InputThread", "inSteam", "activestream", "imageSteam", "activeStream", " inputstream", "activeSteam", "outputStream", "imageStream", "instream"], "xmlContent": [" xmlcontent", "xaValue", " xmlAccept", "phpContents", " xmlRaw", "xmlRaw", "xmlAccept", " xmlText", "xaAccept", "phpcontent", "xmlContents", "mlContents", "xmlcontent", " xmlName", "xfName", "textName", "mlcontent", "formContent", "xmlName", "textContent", "xfContents", "mlText", "xfContent", "mlRaw", "jsonContent", "textContents", "jsonText", "formContents", "phpText", "mlContent", "textcontent", " xmlValue", "xaText", "xmlText", "textText", "formText", "jsoncontent", " xmlContents", "jsonContents", "xaContent", "xfcontent", "mlValue", "phpContent", "xmlValue", "formRaw", "mlAccept"], "out": ["output", "cos", "con", "n", "auto", "Out", "ent", "user", "init", "sys", "flush", "o", "aos", "to", "os", "io", "ex", "outs", "conv", "client", "t", "up", "ou", "nt", "at", "write", "inner", "null", "writer", "external", "net", "conn", "OUT", "extra", "check", "conf", "copy", "cn", "file", "log", "comment", "co", "in", "cmd", "outer", "list"], "xmlRequestNumber": ["xmlEventNumber", " xmlResponseNo", "xmlEventNo", "xmlCounterCount", "xmlEventCounter", "xmlRequestNo", " xmlResponseNumber", " xmlResponseCount", "xmlRequestCounter", "xmlResponseNo", "xmlCounterCounter", "xmlResponseCounter", "xmlResponseNumber", "xmlCounterNumber", "xmlResponseCount", "xmlEventCount", " xmlRequestCount", " xmlRequestNo", "xmlCounterNo", " xmlResponseCounter", " xmlRequestCounter", "xmlRequestCount"], "byteArrayInputStream": ["byteArrayOutputStream", "byteOrderInputSteam", "byteArrayHttpForm", "byteArrayHttpStream", "byteArrayOutputSet", "byteArrayOutputSteam", "byteOrderInputSource", "byteStringOutputSocket", "byteArrayReadSource", "byteStringOutputStream", "byteStreamInputStream", "byteArrayInputSocket", "byteStringInputForm", "byteArrayinputStream", "byteArrayReadStream", "byteStringOutputSteam", "byteArrayinputSteam", "byteArrayinputSocket", "byteStreamOutputSet", "byteOrderReadStream", "byteStringInputStream", "byteArrayIntSet", "byteArrayStorageForm", "byteArrayinputForm", "byteArrayStorageSteam", "byteStreamOutputStream", "byteOrderInputForm", "byteArrayStorageSet", "byteArrayReadSteam", "byteArrayOutputForm", "byteArrayReadForm", "byteStringInputSocket", "byteArrayHttpSource", "byteArrayRawSocket", "byteArrayOutputSource", "byteArrayInputForm", "byteArrayRawSteam", "byteStreamOutputSteam", "byteArrayHttpSteam", "byteOrderReadForm", "byteArrayIntSteam", "byteArrayRawForm", "byteStreamOutputForm", "byteArrayOutputSocket", "byteArrayInputSource", "byteStreamInputForm", "byteArrayIntForm", "byteStringInputSteam", "byteOrderInputStream", "byteArrayInputSteam", "byteStreamInputSet", "byteArrayStorageStream", "byteStreamInputSteam", "byteOrderReadSteam", "byteArrayInputSet", "byteOrderReadSource", "byteArrayRawStream", "byteStringOutputForm", "byteArrayIntStream"], "source": ["ser", "expression", "style", "site", "ident", "json", "reason", "template", "config", "se", "SOURCE", "instance", "handle", "proxy", "params", "body", "ource", "state", "console", "relation", "from", "subject", "resource", "scope", "Source", "parent", "content", "component", "where", "src", "inner", "store", "cause", "xml", "unit", "stream", "service", "position", "sequence", "details", "object", "copy", "status", "input", "table", "file", "select", "parse", "comment", "join", "target", "context", "trace", "layout", "in", "report"]}}
{"id1": "7166270", "id2": "4593012", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"issueCommandToServer": [" sendCommandFromserver", " sendCmdToRemote", " sendCommandFromRemote", " sendCmdToServer", " sendCommandtoServer", " sendCommandToClient", " sendCommandtoClient", " sendCmdtoserver", " sendCmdtoRemote", " sendCommandtoserver", " sendCommandtoRemote", " sendCmdtoServer", " sendCommandTOClient", " sendCommandToserver", " sendCmdtoClient", " sendCommandFromClient", " sendCommandTOserver", " sendCmdToserver", " sendCommandToServer", " sendCommandTOServer", " sendCmdToClient", " sendCommandFromServer", " sendCommandTORemote", " sendCommandToRemote"], "command": ["Command", "message", "history", "application", "text", "description", "password", "program", "template", "method", "menu", "controller", "attribute", "title", "connection", "send", "execute", "help", "uri", "power", "argument", "channel", "mode", "direction", "clear", "request", "code", "communication", "operation", "comm", "sequence", "directory", "event", "form", "string", "action", "document", "query", "requisite", "cmd", "pattern"], "changeCapsule": ["changeClapsularity", "changeCcapsale", "changeCipherale", "changeCapsULE", "changeClcapsule", "changeCarsularity", "changeCarsal", "changeClcapsue", "changeCapsularity", "changeClpsule", "changeCapsal", "changeCmsULE", "changeCcapsue", "changeClapsue", "changeClcapsale", "changeClapsules", "changeClpsules", "changeCcapsules", "changeCpsules", "changeCpsularity", "changeCipherule", "changeClcapsULE", "changeCmsue", "changeCcapsularity", "changeCpsal", "changeCapsale", "changeCipherULE", "changeCmsale", "changeCmsule", "changeCapsue", "changeCarsule", "changeCcapsal", "changeClapsULE", "changeCapsules", "changeClapsule", "changeClpsal", "changeCipherue", "changeClapsale", "changeCpsule", "changeClapsal", "changeCcapsule", "changeClpsularity", "changeCcapsULE", "changeCarsules"], "urlConn": ["httpConn", "strCon", " urlCons", "dlconn", "urlconn", "httpCon", "strConnect", "strNum", "httpConnection", "httpCo", "urlConnect", "fileconn", "retCons", " urlconn", "httpConnect", " urlCo", "logConnect", "fileConn", "urlConnection", "retConnect", "UrlConnect", "urlNum", "fileConnect", "urlCons", "httpconn", " urlNum", "Urlconn", "UrlNum", " urlConnect", "strConnection", "logConnection", "logconn", " urlCon", "strConn", "strconn", "urlCon", "dlConn", "dlConnect", "retconn", "urlCo", "httpCons", "logConn", "UrlConn", "strCo", "retConn"], "wr": ["spr", "RW", "wm", "rew", "WR", "ew", "wer", "vet", "wa", "iw", "writers", "Wr", "wp", "sw", "writ", "hr", "pr", "fr", "rw", "cr", "wt", "write", "writer", "nw", "wb", "vr", "w", "mr", "wid", "wk", "tn", "conn", "wn", "Writer", "tw", "wo", "fw", "kr", "vo", "we", "wy", "wx"], "content": ["output", "message", "Content", "expression", "text", "application", "json", "reason", "description", "core", "add", "update", "template", "config", "section", "header", "ext", "metadata", "address", "body", "ce", "equ", "css", "resource", "current", "code", "write", "key", "script", "version", "label", "load", " Content", "txt", "sequence", "cont", "string", "source", "value", "comment", "document", "media", "data", "format", "search", "context", "join", "layout", "c", "ontent"], "input": ["output", "alpha", "http", "update", "internal", "add", "init", "unknown", "it", "open", "feed", "via", "q", "raw", "read", "local", "iterator", "accept", "inc", "ssl", "Input", "qi", "initial", "current", "ahead", "request", "inner", "background", "reader", "ao", "xml", "get", "upload", "form", "enter", "partial", "submit", "acl", "iter", " Input", "active", "file", "info", "query", "data", "in", "ip", "inside", "storage", "image", "pattern"], "response": ["collection", "output", "buffer", "message", "application", "description", "block", "detail", "onse", "reset", "relation", "frame", "verse", "answer", "respond", "pos", "resp", "server", "alert", "continue", "summary", "library", "request", "related", "version", "next", "view", "still", "service", "position", "respons", "vector", "sequence", "Response", "dict", "result", "line", "object", "value", "reply", "csv", "display", "format", "trace", "image", "report", "network"], "str": ["gr", "dr", "text", "part", "st", "j", "n", "ent", "msg", "piece", "del", "p", "dat", "cat", "re", "cs", "t", "fr", "arr", "le", "g", "hex", "name", "STR", "ctr", "comm", "char", "tr", "obj", "txt", "err", "bc", "cont", "print", "line", "string", "set", "expr", "status", "iter", "i", "br", "sp", "chain", "cert", "data", "s", "exp", "r", "Str", "exec", "list"]}}
{"id1": "18504192", "id2": "7872659", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "Copyfile", "CopyStream", " transferFiles", "CopyFiles", " transferfile", "copyStream", " CopyStream", " Copyfile", " transferStream", " CopyFiles", "copyFiles", " CopyFile", "copyfile", " transferFile"], "in": ["IN", "on", "din", "gin", "or", "n", "it", "rin", "is", "ic", "vin", "b", "old", "id", "as", "o", "en", "inc", "from", "mm", "ind", "ins", "el", "up", "edIn", "isin", "l", "In", "input", "i", "inn", "inf", "cin"], "out": ["output", "n", "Out", "it", "b", "o", "to", "os", "io", "help", "ex", "outs", "t", "v", "ou", "serv", "nt", "at", "g", "w", "l", "k", "net", "err", "OUT", "gt", "ne", "log", "po", "i", "oss", "ot", "s"], "source": ["style", "space", "template", "se", "init", "open", "force", "SOURCE", "volume", "ie", "instance", "sin", "seed", "me", "secret", "shell", "ource", "local", "sample", "scan", "create", "iterator", "from", "subject", "use", "resource", "pse", "Source", "scope", "spec", "back", "ources", "src", "store", "inner", "reader", "access", "service", "position", "sequence", "before", "input", "copy", "file", "match", "parse", "comment", "system", "info", "query", "search", "origin", "start", "inside"], "destination": [" destato", "Destination", "destinator", "Destation", "Destinator", "destation", "seeension", " destinated", "restination", " destregation", "destregation", "coordato", "Destinated", " destation", "seeinated", "seeinator", "destension", "destato", "destification", "comification", " destification", "restinator", "coordination", "restation", "Destension", "comato", "seeination", "destinated", "comregation", "coordification", "restinated", "coordregation", "comination", " destinator", " destension"]}}
{"id1": "350482", "id2": "17580775", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionsCheck", " doVersionsCheck", " doVersionscheck", " doApplicationInfo", "doFeatureUpdate", "doVersionscheck", "doImageCheck", "doApplicationInfo", "doVersionsUpdate", "doBuildUpdate", "doBuildcheck", " doApplicationQuery", "doVersionUpdate", "doImageTest", "doFeaturecheck", " doVersionUpdate", "doFeatureCheck", "doImageInfo", "doVersionTest", "doApplicationQuery", "doImageQuery", " doVersionTest", " doVersionsTest", "doFeatureInfo", "doVersionQuery", " doVersionQuery", " doVersioncheck", " doApplicationCheck", "doFeatureQuery", "doBuildCheck", " doVersionsUpdate", "doVersioncheck", "doBuildTest", "doFeatureTest", "doApplicationTest", "doVersionsTest", "doVersionInfo", " doApplicationTest", "doApplicationCheck", " doVersionInfo"], "view": ["buffer", "http", "self", "update", "html", "window", "model", "block", "cell", "iew", "vm", "controller", "manager", "see", "review", "ml", "q", "pool", "h", "row", "cv", "views", "subject", "VIEW", "client", "server", "v", "lock", "browser", "component", "call", "this", "tree", "box", "version", "index", "engine", "virtual", "page", "form", "eye", "print", "project", "check", "input", "View", "tv", "file", "port", "show", "document", "query", "display", "context", "layout", "widget", "image", "report"], "url": ["http", "mail", "html", "sl", "build", "bel", "link", "ur", "lb", "Url", "f", "address", "ul", "b", "URL", "rel", "pl", "ssl", "uri", "dl", "loc", "nl", "client", "v", "browser", "gl", "ref", "str", "mount", "ll", "get", "l", "char", "rl", "file", "log", "domain", "job", "oul", "r", "host", "hl"], "in": ["IN", "on", "din", "gin", " IN", "asin", "init", "ln", "n", "rin", "is", "vin", "sin", "f", "body", "ain", "can", "inc", "from", "ins", "inner", "reader", "stream", "isin", "l", "In", "input", "source", "i", "mn", " din", "info", "inn", "out", "mat", "inf", "cin"], "bin": ["buffer", "cos", "binary", "db", "session", "din", "gin", "con", "by", "init", "ln", "nb", "abin", "spin", "bed", "rin", "sin", "b", " Bin", "body", "bn", "local", "bl", "re", "ebin", "conv", "ins", "win", "bur", "buff", "len", "bg", "all", "inner", "bi", "mon", "jin", "reader", "cb", "stock", "lib", " bins", "obin", "brain", "file", "ran", "sam", " din", "inn", "out", "thin", "rb", "cache", "cin"], "line": ["field", "message", "style", "part", "cell", "lin", "block", "ln", "section", "tile", "lo", "eline", "link", "detail", "zone", "lane", "cat", "row", "sample", "frame", "stay", "lines", "channel", "liner", " block", "le", "code", "inline", "key", "ine", "rule", "next", "LINE", "ice", "stream", "l", "char", "page", "sequence", "err", "record", "entry", "string", "base", "point", "print", "status", "iter", "port", "file", "log", "job", "parse", "comment", "range", "chain", "trace", "cmd", "column", "word", "Line"], "develBuild": ["devBuilder", "devBuild", "duvelBuilt", "deployBuilder", "deVELBoot", "depoBuild", "deVELBuilder", "deeltaLoad", "DeVELBuilt", "deployLoad", "deploybuild", "develLoad", "develbuild", "deeltabuild", "develBuilt", "deVELBuild", "DeVELBuild", "DevelBuild", "DeVELbuild", "depoBuilt", "duVELbuild", "desvelbuild", "duVELBoot", "desVELLoad", "develLog", "deVELRelease", "duvelBoot", "desVELBuild", "deeltaBuild", "deployBoot", "deVELLog", "deeltaRelease", "DevelBuilt", "devBuilt", "DevelLog", "duvelBuild", "DeVELLog", "desvelLoad", "deffbuild", "deffBuild", "devBoot", "deployRelease", "desvelBuild", "deployBuilt", "develRelease", "duffBuilder", "deVELBuilt", "duvelBuilder", "deVELbuild", "depobuild", "develBuilder", "duvelbuild", "duVELBuilder", "duVELBuild", "desvelRelease", "desVELbuild", "deVELLoad", "develBoot", "deployBuild", "duffBuilt", "depoLog", "devbuild", "deffBuilder", "Develbuild", "duffbuild", "deffBuilt", "desVELRelease", "duffBuild", "devLog"], "stableBuild": ["devBuilder", "devBuild", " unstablebuild", "confirmedBuild", "confirmedBoot", " stablebuild", "confirmedbuild", "activeBuilder", "activeBuild", "stableMake", "stableLong", " unstableBuild", "stableBoot", "stablebuild", "secureBuild", " unstableBuilder", " stableBoot", " unstableLong", " unstableBind", "stableBuilder", " stableLong", "stableBind", " stableBind", " unstableBoot", "secureCraft", " stableCraft", "activebuild", " stableBuilder", "devBind", " stableMake", " unstableCraft", "devMake", "devbuild", "confirmedLong", "stableCraft", "activeMake", "securebuild", "secureBuilder"]}}
{"id1": "21092340", "id2": "823074", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToHariver", "addToExFile", "addInHariver", "addToExiver", "addToExive", "addInArchive", "addInHarZip", "addToZipiver", "addToArchFile", "addToZipFile", "addToArchZip", "addToArchiver", "addInArchiver", "addInHarive", "addToHarive", "addToExZip", "addToHarFile", "addToHarZip", "addInArchZip", "addToZipive", "addInArchFile", "addInHarFile", "addToZipZip"], "pod": ["proc", "message", "disk", "top", "task", "volume", "pkg", "od", "zone", "body", "p", "pick", "wp", "report", "op", "spec", "component", "pack", "module", "ods", "poll", "post", "cp", "ack", "policy", "pc", "project", "check", "point", "device", "archive", "table", "job", "pad", "start", "Pod", "ad"], "podArchiveOutputStream": ["podArchiverOutputMap", "podArchiveEntryStream", "podArchiveResourceContext", "podArchiveInputStream", "podArchiverInputSync", "podArchiveOutputStreamer", "podArchiveOUForm", "podArchiverInputStreamer", "podArchiveStreamForm", "podArchiveOutStream", "podArchiveStreamSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiveoutputForm", "podArchiveOUStream", "podArchiveOutputstream", "podArchiverOutputStreamer", "podArchiveOutputMap", "podArchiveStreamStream", "podArchiveOutContext", "podArchiveoutputStreamer", "podArchiverOutputPoint", "podArchiveOutPoint", "podArchiveResourceSteam", "podArchiveMainStreamer", "podArchiveOUMap", "podArchiveoutputStream", "podArchiveInputContext", "podArchiveoutputSteam", "podArchiveMainSteam", "podArchiveOutputSteam", "podArchiverOutputSync", "podArchiveInputStreamer", "podArchiveOutputSync", "podArchiverOutputSteam", "podArchiveMainStream", "podArchiverInputContext", "podArchiveOutputContext", "podArchiveInputForm", "podArchiveResourcestream", "podArchiveOutstream", "podArchiveOutputForm", "podArchiverInputSteam", "podArchiveInputSteam", "podArchiveOutSteam", "podArchiveInputMap", "podArchiverInputMap", "podArchiveInputPoint", "podArchiveEntryPoint", "podArchiveMainForm", "podArchiverInputStream", "podArchiverInputPoint", "podArchiverOutputContext", "podArchiverOutputForm", "podArchiverOutputStream", "podArchiveOUSync", "podArchiveResourceStream", "podArchiverInputstream", "podArchiveInputstream", "podArchiverOutputstream", "podArchiveInputSync", "podArchiveEntrySteam", "podArchiveStreamMap"], "filename": ["fn", "path", "nil", "message", "output", "binary", "description", "location", "prefix", "jpg", "fil", "title", "latest", "nm", "p", "FN", "Filename", "folder", "fp", "stem", "subject", "uri", "resource", "png", "NAME", "ename", "ame", "release", "key", "name", "original", "version", "println", "upload", "username", "family", "txt", "directory", "kl", "FILE", "string", "archive", "file", "names", "url"], "source": ["series", "ser", "proc", "style", "password", "template", "SOURCE", "force", "seed", "address", "shell", "body", "loader", "ource", "sql", "sample", "iterator", "from", "use", "resource", "spec", "Source", "component", "src", "inner", "store", "view", "get", "service", "stream", "sequence", "copy", "input", "select", "file", "info", "context", "start", "image", "supp"], "entry": ["ment", "task", "cell", "or", "cue", "book", "se", "ent", "ie", "link", "tmp", "attribute", "connection", "sheet", "ry", "row", "ce", "card", "element", "channel", "resource", "nt", "component", "key", "ace", "quick", "char", "obj", "good", "record", "enter", "line", "set", "archive", "file", "log", "job", "comment", "system", "query", "data", "Entry", "word", "zip"]}}
{"id1": "13333160", "id2": "11673907", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"run": ["runner", "proc", "eval", "apply", "wal", "Run", "flow", "read", "scan", "execute", "test", "pass", "running", "process", "view", "unit", "go", "action", "ran", "render", "app", "work", "query", "start", "exec"], "xmlIn": ["domOut", "htmlIns", "xmlOut", "xIns", "xIn", "htmlIn", "fileIns", "xmlIns", "domIn", "jsonInput", "fileIn", "filein", "htmlin", "xmlin", "jsonOut", " xmlIns", "jsonIn", " xmlin", "domIns", "domInput", "xOut", "xInput", "jsonIns", "xmlInput"], "out": ["output", "Out", "raw", "p", "pool", "o", "aos", "to", "end", "os", "ws", "io", "OU", "sw", "ex", "outs", "t", "client", "up", "v", "ou", "nt", "null", "d", "w", "stream", "one", "obj", "err", "OUT", "set", "file", "log", "i", "off", "s", "in", "res", "report"], "dom": ["yang", "dr", "db", "node", "html", "window", "model", "j", "DOM", "img", "iam", "p", "dn", "cd", "parser", "os", "dm", "frame", "dem", "dl", "fr", "el", "browser", "atom", "tree", "process", "doc", "xml", "d", "comm", "utils", "page", "md", "result", "om", "m", "df", "domain", "web", "document", "Dom", "data", "div", "mom", "host", "mat"], "f": ["af", "bf", "Factory", "inf", "lf", "it", "fo", "fy", "fg", "xf", "fi", "conv", "ft", "fb", "fr", "v", "foreign", "fab", "fc", "fm", "uf", "g", "fl", "fac", "w", "rf", "fx", "fort", "fs", "l", "ff", "df", "d", "of", "full", "fd", "cf", "F", "forge", "conf", "tf", "c", "sf"], "b": ["B", "bf", "db", "builder", "j", "nb", "a", "bd", "bs", "p", "Builder", "bb", "fb", "bt", "v", "ab", "e", "bg", "eb", "be", "g", "bi", "pb", "mb", "d", "gb", "l", "bc", "base", "m", "sb", "bh", "r", "c", "rb"], "root": ["rap", "top", "instance", "author", "available", "ain", "av", "element", "right", "parent", "tree", "mount", "doc", "r", "bot", "ram", "nav", " Root", "row", "create", "feature", "scope", "rank", "box", "ow", "group", "container", "mr", "object", "chain", "document", "data", "div", "res", "start", "roid", "html", "valid", "cover", "DOM", "used", "h", "os", "area", "roots", "Root", "loc", "browser", "null", "xml", "get", "ax", "bank", "result", "m", "rown", "table", "oot", "first", "gr", "owner", "node", "wrap", "head", "type", "ul", "raw", "p", "ok", "ree", "rt", "module", "base", "primary", "ro", " rooted", "host"], "att": ["attr", "ATT", "addr", "rib", "aria", "tt", "tmp", "attribute", "aj", "ct", "Att", "dat", "prop", "av", "feat", "ach", "t", "pt", "ar", "ac", "adj", "aff", "nt", "acc", "at", "rt", "aux", "alt", " dat", " attribute", "ap", "nat", "tr", "txt", "pet", "def", "set", " ut", "info", "data", "apt", "atts", "attach", " matt", "ts", "mat"], "menu": ["site", "node", "window", "block", "config", "button", "nav", "header", "men", "Menu", "ui", "item", "title", "ul", "um", "manager", "li", "usage", "row", "wiki", "queue", " Menu", "mouse", "pie", "up", "category", "parent", "cm", "library", "summary", "tree", "settings", "module", "next", "consumer", "family", "page", "sequence", "command", "movie", "m", "theme", "cache", "us", "mu", "ctrl", "option", "chain", "admin", "options", "omo", "list", " menus"], "id": ["description", "init", "method", "Id", "type", "link", "class", "title", "icon", "pid", "uri", "mid", "scope", "tag", "ref", "ids", "key", "name", "version", "uid", "source", "status", "file", "value", "target", "data", "url", "ID"], "zout": ["zup", "czOut", "zipOut", "enzout", "zot", "ziposs", "ozout", "izOut", "ozouts", "zoss", "Zin", "gznet", " zserv", "gzout", "ozot", "zOUT", "zerout", " zor", "izserv", "Zaos", "ZOut", "zerot", "ozOUT", " zpoint", "enzOut", "zipnet", " zclient", "zipOUT", "zipouter", "zclient", "ozpoint", "zOut", "ezout", "zipin", " zup", "zouts", "zipserv", "czout", "ezpoint", " zOut", "czup", "zipup", "ozOut", " zaos", "zipot", "ozouter", "zaos", "zpoint", "zerouter", "zor", "zipaos", "zouter", "zipclient", "zserv", "zerOUT", " znet", "zipor", "czclient", "zipout", " zin", "znet", "zin", "izout", "gzin", "ozup", "izaos", "gzor", " zouts", "zeross", "Zout", "zippoint", "ozoss", "zerup", "zerOut", "ezouts", "enzpoint"], "content": ["core", "block", "config", "header", "ext", "title", "size", "code", "tree", "inner", "sequence", "padding", "file", "query", "layout", "ontent", "cur", "path", "text", "json", "description", "template", "now", "condition", "create", "script", "string", "object", "comment", "document", "search", "data", "cmd", "output", "expression", "html", "section", "lay", "address", "body", "htm", "pool", "current", "request", "xml", "good", "page", "result", "article", "message", "Content", "load", "reason", "x", "time", "metadata", "raw", "read", "accept", "ce", "default", "wrapper", "position", "txt", "cont", "command", "source", "value", "media", "full", "format", "context", "host", "image", "c", "cache"], "signal": ["seale", "signaling", "signil", "several", "severature", "SIGNaling", " signature", "signale", "scature", "SIGNature", " signil", " signAL", "signature", "sealing", "Signature", "severaling", "signAL", "SIGNal", "severale", "Signaling", "scal", "seil", " signaling", "SIGNale", "seature", "Signal", " signale", "scale", "scaling", "seAL", "severil", "seal", "severAL"], "n": ["nan", "nc", "on", "node", "j", "nb", "ln", "count", "nm", "p", "no", "norm", "dn", "o", "h", "num", "np", "en", "nr", "t", "nl", "pos", "nt", "ns", "g", "nor", "nu", "natural", "ni", "index", "d", "number", "nw", "nv", "l", "unn", "N", "c", "nn", "sn", "un", "an", "tn", "m", "ne", "cn", "zero", "z", "i", "mn", "ng", "len"], "entry": ["cell", "add", "se", "cue", "member", "ent", "instance", "ie", "link", "tmp", "connection", "sheet", "ry", "row", "slot", "element", "nt", "e", "office", "next", "ace", "quick", "RY", "page", "pixel", "record", "line", "result", "table", "log", "comment", "escape", "join", "system", "query", "data", "Entry", "insert", "enter", "zip"], "pout": ["pouter", "pnew", "ppto", "Pin", "phpin", "wpto", "wpent", "pinner", "ptout", "ptouter", " pto", "zot", "ptOut", "psys", "ppout", "pin", "ppent", "ppinner", " pou", " pOut", " pconn", "Pout", " pin", "pto", " psys", "zinner", "pOut", "wpout", "phpot", "zconn", "Psys", "ppouter", "jpou", "phpsys", "phpout", "pou", "wpond", "zouter", "phpouter", " pouter", "pot", "zou", "jpout", "POut", " pond", "phpinner", " pnew", " pent", "pent", "pconn", "jpconn", "ptnew", "jpinner", "ppond", "phpnew", "phpOut", "ppot", " pinner", "pond"]}}
{"id1": "8135072", "id2": "4164833", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"setImg": ["getIMg", "setIMg", "setImgs", "setIMgs", "setimg", "getImg", "setimG", "setimgn", "getIMgs", "getImgs", "setImageG", "setIMgn", "setImageg", "setimgs", "getIMgn", "setImG", "setImagegn", "setIMG", "setImgn", "getImgn", "getImG", "getIMG", "setImagegs"], "jFileChooser1": ["jFileSeose0", "jFileChoer4", "jFileComperOne", "jFileChoester2", "jFileChoickerOne", "jFileChoikerOne", "jFileChoerOne", "jFileSeose1", "jFileChicker1", "jFileChooser4", "jFileComposerOne", "jFileChooserFirst", "jFileComper1", "jFileCompicker1", "jFileChoister0", "jFileChoickerFirst", "jFileComposer2", "jFileChoester1", "jFileChoicker2", "jFileChooseOnce", "jFileChoicer1", "jFileChooserOne", "jFileSeoser1", "jFileChoose2", "jFileChoikerControl", "jFileChicker2", "jFileChoser2", "jFileChoose1", "jFileComposer1", "jFileChooserOnce", "jFileChickerOnce", "jFileChoserOnce", "jFileChoer1", "jFileChoicker1", "jFileChoister2", "jFileCompickerFirst", "jFileCompickerControl", "jFileSeoser2", "jFileChickerOne", "jFileComposerControl", "jFileChoose0", "jFileChoser1", "jFileSeoser0", "jFileComper4", "jFileCompickerOne", "jFileComposer4", "jFileChoikerFirst", "jFileChoserOne", "jFileChoickerOnce", "jFileChoicer2", "jFileChoicer4", "jFileChoickerControl", "jFileChopter1", "jFileChoister1", "jFileChooseOne", "jFileComposerFirst", "jFileSeose2", "jFileChopterOne", "jFileChoer2", "jFileChoiker1", "jFileChooserControl", "jFileChooser2", "jFileChopterFirst", "jFileComper2", "jFileChoose4", "jFileChopterControl", "jFileChoicerOne", "jFileChoester0", "jFileChoicerOnce", "jFileChooser0"], "separator": ["terminater", "semitter", "variate", "splater", "terminator", "generacer", "termininator", "generate", "separitter", "separativity", "generator", "semate", "splacer", " separinator", "collativity", "generater", "seator", " separATOR", "semator", " separigator", "seigator", "terminATOR", "seATOR", "separate", "splator", "variator", "separater", "separigator", "collator", "terminate", " separate", "variater", "generoder", " separater", " separacer", "seate", "separoder", "terminigator", "generATOR", "separATOR", "varioder", "semATOR", "collate", "separacer", "collATOR", "splATOR", "terminativity", "seinator", " separitter", "terminoder", " separativity", "separinator", "seitter"], "dirImg": ["DirIMig", "DirImg", "DirIMg", "dirIMge", "dirIfG", "dirIfig", "dirIfm", "DirIMgs", "dirImm", "dirIfg", "DirImG", "dirImge", "dirIG", "dirimig", "DirImgs", "DirIMic", "dirImgs", "folderIMg", "folderImG", "dirIgs", "folderIMG", "dirimg", "folderIMge", "DirImic", "folderImgs", "dirImvg", "dirIvg", "dirIfgs", "folderImg", "dirImG", "dirIMvg", "DirIMG", "dirImig", "dirimge", "dirIMgs", "dirIMg", "dirimG", "DirIMm", "dirimgs", "dirIMm", "folderImvg", "DirImm", "dirIMG", "dirIfic", "dirIg", "dirIMic", "dirimm", "folderIMgs", "dirImic", "DirImig", "folderIMvg", "dirIMig", "folderImge"], "index": ["second", "connect", "ion", "timeout", "add", "n", "open", "draw", "sign", "condition", "seed", "count", "address", "num", "test", "ind", "ex", "pos", "length", "exit", "all", "key", "sol", "IND", "Index", "number", "position", "level", "set", "point", "axis", "zero", "value", "match", "max", "i", "find", "info", "exp", "success", "height", "start", "diff"], "imgName": ["imgNo", "jpgname", " imgId", "jpgId", " imgname", "htmlPath", "imgname", "htmlName", "htmlNo", "jpgType", "jpgName", "imgId", " imgPath", "jpgNo", "animName", " imgNo", "animPath", "jpgPath", "htmlType", " imgType", "animname", "animId", "imgPath", "imgType"], "newPath": ["newsPath", "newUrl", "newPassword", "uniqueTh", "oldPart", " newName", "newPart", "oldTime", "newFormat", "newsTh", "newsPassword", "oldPassword", "newTime", " newFormat", "newTh", "validPath", "NEWPath", "newDir", "uniquePassword", "uniquePath", "oldDir", "newName", "oldTh", "validName", "NewUrl", "uniquePart", "newpath", "validUrl", "NEWDir", " newTime", " newUrl", "oldFormat", "NEWFormat", " newpath", "NewName", "newsPart", "validpath", "oldPath", " newDir", "NEWTime", "NewPath", "Newpath"], "inputFile": ["inputPlace", "inputPath", "saveFILE", "inputFILE", "outputFILE", "acceptPlace", "acceptFile", " inputfile", " inputPlace", " inputBe", "createFile", "inputStream", "createBe", "importStream", "importPlace", "inStream", "saveFile", "createfile", "importFile", "inFILE", "importPath", "inPlace", "saveStream", "inFile", "createPlace", "inPath", " inputStream", " inputPath", "outputStream", "inputfile", "acceptBe", "acceptfile", "inputBe"], "outputFile": ["displayFile", "inputDisk", "outputPage", "putFile", "putPage", "outputFormat", "newfile", "outputfile", "displayStream", "putModel", "outModel", "Outputfile", "outDisk", " outputStream", "outputDir", "inputDir", "newFile", "outPage", " outputBe", "outputDisk", " outputfile", "putDisk", "outfile", "outFormat", "outputBe", "OutputFile", "newStream", "OutputDir", "displayBe", "inputPage", "outputModel", "newBe", "inputModel", "displayfile", "outputStream", "inputFormat", "OutputFormat", "outDir", "outFile", "inputfile"], "in": ["IN", "per", "din", "con", "by", "init", "it", "ini", "rin", "is", "ic", "sin", "ain", "read", "en", "inc", "io", "from", "ind", "al", "ins", "ex", "ar", "el", "up", "bin", "inner", "isin", "In", "input", "source", "iter", "i", " din", "inn", "inside", "cin"], "out": ["output", "gr", "cos", "list", "on", "con", "n", "auto", "Out", "it", "dis", "sys", "put", "can", "o", "aos", "to", "os", "en", "end", "io", "OU", "help", "ex", "outs", "t", "v", "ou", "nt", "at", "write", "inner", "writer", "screen", "sum", "net", "OUT", "ne", "cn", "log", "co", "cmd", "outer", "cache"], "c": ["ch", "nc", "C", "cu", "n", "a", "uc", "mc", "ct", "f", "count", "q", "sc", "cut", "cd", "rc", "cat", "col", "ce", "cs", "ex", "t", "lc", "unc", "ac", "v", "cm", "cr", "e", "code", "cod", "ec", "d", "cp", "dc", "char", "u", "k", "go", "bc", "l", "cont", "r", "gc", "cl", "m", "cc", "max", "z", "i", "arc", "chain", "com"], "bckImg": ["bckIMge", "bckIMg", "bckIfg", "bckImn", "bckImgs", "bckIfgs", "bkgImgs", "bckIMgs", "bkgIMgs", "bckImge", "bckIfn", "bckimge", "bckIfge", "bckIMn", "bckimn", "bkgImg", "bckimgs", "bkgImge", "bkgIMge", "bkgImn", "bckimg", "bkgIMn", "bkgIMg"]}}
{"id1": "21326424", "id2": "16388708", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"delete": ["update", "close", "save", "put", "del", "send", "download", "create", "execute", "Delete", " purge", "clear", "request", "write", "release", "null", "post", "dump", "get", "service", "destroy", "check", "query", "data", "remove", "insert", "commit", "de"], "id": ["path", "ment", "message", "ident", "db", "part", "description", "template", "n", "Id", "type", "item", "and", "rid", "token", "variable", "pid", "kid", "iden", "ref", "ids", "code", "key", "name", "aid", "uid", "k", "md", "event", "string", "hash", "value", "vid", "show", "data", "oid", "url", "ID"], "response": ["output", "collection", "message", "application", "self", "site", "json", "function", "description", "model", "detail", "onse", "me", "attribute", "see", "controller", "example", "api", "reset", "relation", "frame", "respond", "answer", "default", "resp", "server", "content", "summary", "exit", "request", "tree", "error", "version", "next", "view", "service", "position", "respons", "page", "Response", "result", "sequence", "command", "entry", "object", "hash", "action", "information", "value", "reply", "render", "document", "data", "format", "display", "res", "image", "report", "network"], "connection": ["bo", "application", "connect", "ion", "session", "Connection", "con", "cone", "pointer", "function", "close", "location", "description", "open", "link", "generation", "statement", "condition", "database", "controller", "reference", "console", "character", "to", "reset", "relation", "subject", "client", "channel", "wrapper", "library", "request", "office", "creation", "government", "communication", "writer", "operation", "engine", "number", "position", "established", "builder", "connected", "license", "directory", "conn", "remote", "command", "entry", "set", "language", "information", "document", "city", "c", "network"]}}
{"id1": "10690321", "id2": "23035537", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"readData": ["processArray", "ReadInfo", "loadData", "readArray", "ReadResults", "loadInfo", "processInfo", "processResults", "loadResults", "readInfo", "ReadArray", "readResults", "ReadData", "processData", "loadArray"], "sTok": ["nsEar", "STok", "stsEp", "sApp", "dsTok", "stsSax", "newTok", "sIter", "stsTok", "tsNik", "itsTok", "atsEp", "nsSax", "tsTok", "tIter", "sysIter", "sysIv", " sOct", "gsCorp", "sOK", "newEar", "stsOct", "sesSocket", "tesAsk", "atsIter", "gsTok", "gsRex", "sqlNob", "stsOtt", "sNik", "tsEar", "sysSax", "qsApp", "gsEar", "sysAsk", "simpleRap", "simpleTok", "sEp", " sToy", "gsEp", "usTok", "sqlEp", "sPick", "itsArch", "gsToy", "atsOct", "simpleIter", "rsIter", " sIter", " sApp", "qsIter", "fsNob", " sPick", "sToy", "SInst", "persIter", "sNob", " sNob", "gsSax", "stsPick", "sOtt", "simpleOK", "qsTok", "tesTok", "sRex", "SOp", "tesIv", "tsRex", "gsOct", "sIv", "sVal", "sOct", "stsTyp", "sysVo", "atsOtt", "fsEp", "sRap", "sqlTyp", "sqlEar", "sLex", "tsCorp", "tsOtt", "nsIter", " sEp", " sEar", " sPet", "seOK", "tSax", "qsToy", "fsEar", "sesObj", "jsSax", " sAsk", "fsTok", " sVal", " sSax", "sysNik", " sIv", " sRap", "usIter", " sPut", "stsIter", "sEar", "sysOK", "newEp", "sPet", "persTok", " sNik", "rsEp", "fsObj", "jsArch", "rsTok", "fsRex", "itsSax", "atsTok", " sArch", "sObj", "usOtt", "dsInst", "sTyp", " sSocket", "sesTok", "jsIter", "usPet", "tsEp", "fsCorp", "jsOtt", " sLex", "tTok", " sOp", "sPut", "tsIter", "sSocket", "nsEp", " sTyp", "gsTyp", "gsOtt", "seIter", "sAsk", " sVo", " sOK", "atsPet", "sysTok", "tesPut", "seRap", " sOtt", "gsPick", "nsAsk", "sqlIter", "atsLex", " sObj", "fsOp", "gsApp", "persOct", "sArch", "sqlOtt", "nsVo", "SEp", "rsOtt", "seTok", "sInst", "tOtt", "jsTok", "tsSax", "sSax", "fsOtt", "sOp", " sInst", "atsTyp", "gsAsk", "sqlTok", "gsIter", "sysVal", "nsOtt", "jsEp", "dsIter", "persOtt", "tesSocket", "tesObj", "sesPut", "itsEp", "gsNik", "nsTok", "newNik", "sVo", "nsInst", "atsAsk", "sCorp", "dsVo", "tesVal"], "topSet": ["topScan", "hopSet", "topsScan", "bottomSet", "bottomSize", "rightMap", "topLog", " topSize", "bottomMap", "rightSize", "topMap", "hopMap", "bottomLog", " topScan", " topMap", "topsSet", " topLog", "hopScan", "topsMap", "topSize", "rightLog"], "leftSet": ["leftNet", "leftMap", " leftset", "rightGroup", "oldMap", "LeftSum", "oldSet", "LeftSet", "LeftNet", "LeftGroup", "Leftset", " leftMap", "rightSum", "LeftMap", "oldset", "oldNet", " leftGroup", " leftSum", "leftGroup", "leftSum", " leftNet", "leftset"], "rightSet": [" rightHat", "blockSet", " rightGen", "blockSET", "rowHat", "rightSET", "blockHat", "rowEx", "leftEx", " rightEx", "leftGen", " rightPos", "rowPos", " rightSET", "rightPos", "rightHat", "blockPos", "rowSET", "rightEx", "rightGen", "rowGen", "rowSet"], "farRightSet": ["farLeftSet", "farrightUse", "farRoleSet", "farRForce", " farLeftSet", "farrightSet", "farrightset", "farRightForce", "farRUse", " farLeftUse", "farRightset", "farRset", " farRightset", "farLeftset", "farRoleset", "farRightUse", "farrightForce", " farLeftset", " farrightSet", " farRightForce", "farRSet", " farRightUse", " farrightForce", "farLeftUse", "farRoleForce", " farrightset"], "vowelSet": ["voxellUse", "vowellBase", "voxellBase", "voxelSet", "vowellList", "vowsellSet", "vowellSet", "voxellSet", "vowellUse", "vowleBase", "vowelBase", "vowselMap", "vowelsBase", "vowsellMap", "vowelList", "vowilMap", "vowsellList", "vowellMap", "vowselList", "vowleUse", "vowelsMap", "vowelUse", "vowilSet", "vowelsUse", "vowelsSet", "vowselSet", "vowleSet", "vowelsList", "voxelUse", "vowilList", "voxelBase", "vowelMap"], "ntk": ["detK", "ntq", "ontak", "ntkw", "oddkid", "ntr", "oddkar", "retok", "cmdik", "otq", "rentp", "detk", "onty", "ftk", "retk", "gtkn", "ptp", "dettek", "nnik", "pty", "ftmk", " syntok", "ntch", "ntmk", "ontkid", "etmk", "entok", "cmdk", "retkar", "ntok", "ntkn", "ntks", "ontK", "gtq", "ontkr", "ntkar", "ontr", "gtik", "detok", "retik", "entk", "mdkw", "ontch", "ossik", "detkar", "renty", "osskw", "entch", "enttek", "gtk", " etik", "cmdok", "rtkar", "ontz", "oddr", "rtk", "cmdcp", "ptykar", "rentk", "gtK", "etk", "rentkj", "ptykr", "cmdak", "otK", "nty", "mdk", "ptyK", "ftok", "otk", "ntkid", "montke", " etok", "ontik", "entik", "gtke", "nextk", "ontok", "ntcp", " etkw", "rentik", " syntkw", "montq", "montkn", "otkn", "ntke", "ptk", "montk", "ntkj", "ntik", "entz", "nextkn", "rtks", "mdik", "ptyok", "renttek", "gtcp", "rettk", "ontp", "onttk", "ptyk", "rentks", " syntk", "etok", "rentK", "rtik", "ntkr", "nnkar", "rentkar", "nextkar", "otcp", "ontkar", "ftkw", "ntak", "nextkr", "rentok", "otke", "retch", "nttek", "retz", "ntz", "ontkj", "otik", "nnks", "rtok", " syntmk", "nttk", "detkid", "entK", "nnk", "etkw", "ptyak", "ontkn", "ossok", "ossk", "detr", "mdok", "oddk", "ptkj", "rttk", " etk", "ntK", "ontk", "ptykn", "ntp", "cmdK"], "maxEwtsVowelLength": ["maxEwtsVovelWidth", "maxEwtsVowalWidth", "maxEwtsVowellength", "maxEwtsVowelsWidth", "maxEwtsVowellLen", "maxEwtsVovellLen", "maxEwtsVowelWidth", "maxEwtsVoxalWidth", "maxEwtsVowelsLength", "maxEwtsVovelLength", "maxEwtsVovellWidth", "maxEwtsVoxellength", "maxEwtsVowelLen", "maxEwtsVowellWidth", "maxEwtsVowellLength", "maxEwtsVowelslength", "maxEwtsVovellDuration", "maxEwtsVowellDuration", "maxEwtsVoxelWidth", "maxEwtsVowelsLen", "maxEwtsVowalDuration", "maxEwtsVowylDuration", "maxEwtsVoxalLength", "maxEwtsVowylWidth", "maxEwtsVowalLen", "maxEwtsVoxallength", "maxEwtsVowallength", "maxEwtsVovellLength", "maxEwtsVoxalLen", "maxEwtsVoxelLength", "maxEwtsVowelDuration", "maxEwtsVowalLength", "maxEwtsVowylLen", "maxEwtsVovelLen", "maxEwtsVovelDuration", "maxEwtsVoxelLen", "maxEwtsVowelllength", "maxEwtsVowylLength"], "puncSet": [" pfuncGroup", " pfuncBase", "cpuncSetting", "paucGroup", " pfuncSet", "ptcset", "pocoSet", "puncBase", "puncGroup", " puncBase", "puncSetting", "punctSet", "ptcSet", "pocoSetting", "cpuncSet", "paucBase", "pfuncGroup", "pocoset", "cpunctSetting", "pfuncSet", "pfuncBase", "pacGroup", "ptcSetting", "punctset", "punctSetting", "pacBase", " puncGroup", "cpuncset", "puncset", "paucSet", "cpunctSet", "cpunctset", "pacSet"], "charSet": ["charBase", " charLog", " charset", "byteList", "byteset", "characterSet", "charList", " charBase", "CharSet", "charset", "characterLog", "charLog", " charList", "CharList", "CharacterLog", "byteSet", "Charset", "CharacterSet", "CharacterBase", "characterBase"], "tibSet": ["tibEn", "nibiSet", "tiberChain", "tilibSet", " tibSum", "torgEn", "nibEn", "tibChain", "torgSet", "tobEn", "tiberSet", "tibSum", " tibiSum", "nibiEn", "tibiEn", "tobSet", "tilibSum", " tibChain", "tilibChain", "tibiSum", "tibiChain", " tibiSet", "tiberSum", "nibSet", "tibiSet", " tibiChain"], "sanskritStackSet": ["sanskraStackBase", "sanskraStateSet", "sanskritStepSet", "sanskriticBase", "sanskritStepBase", "sanskritStateSet", "sanskraStateHash", "sanskritStackBase", "sanskraStackSet", "sanskritStateHash", "sanskriticSet", "sanskraStateBase", "sanskritStateBase", "sanskraStackHash", "sanskriticHash", "sanskritStepHash", "sanskritStackHash"]}}
{"id1": "15516136", "id2": "18748516", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPILImages", "loadBufferedMPEGFrame", "loadBufferedMPEGImage", "loadBufferedJPEGElement", "loadBufferedMPEGImages", "loadBufferedJPILElement", "loadBufferedJPECElement", "loadBufferedJPECImages", "loadBufferedMPEGElement", "loadBufferedJPPGElement", "loadBufferedJPECImage", "loadBufferedJPECFrame", "loadBufferedJPPGFrame", "loadBufferedMPILImages", "loadBufferedMPILFrame", "loadBufferedJPILImage", "loadBufferedJPILFrame", "loadBufferedJPPGImages", "loadBufferedMPILElement", "loadBufferedJPEGFrame", "loadBufferedMPILImage", "loadBufferedJPPGImage", "loadBufferedJPEGImages"], "url": ["http", "html", "ls", "location", "abs", "term", "addr", "sl", "org", "link", "ur", "lb", "Url", "ul", "address", "URL", "loader", "id", "rel", "sql", "util", "download", "github", "ssl", "uri", "dl", "nl", "loc", "resource", "el", "email", "browser", "gl", "ref", "fail", "all", "key", "null", "name", "mount", "xml", "str", "ll", "hl", "impl", "get", "l", "char", "k", "kl", "un", "print", "rect", "string", "cl", "lr", "rl", "date", "file", "domain", "job", "web", "full", "r"], "image": ["http", "window", "block", "instance", "img", "attribute", "crop", "size", "scene", "icon", "channel", "png", "game", "inner", "error", "external", "sequence", "archive", "file", "word", "buffer", "description", "auto", "entity", "row", "ilo", "feature", "photo", "still", "remote", "print", "entry", "object", "document", "data", "display", "memory", "age", "pixel", "output", "application", "im", "model", "unsigned", "me", "manager", "address", "picture", "no", "frame", "video", "resource", "xml", "view", "one", "page", "input", "m", "device", "ge", "audio", "message", "binary", "update", "shape", "user", "item", "sample", "mi", "associated", "all", "none", "figure", "policy", "event", "source", "value", "media", "empty", "out", "Image", "cache"], "in": ["IN", "on", "din", "gin", "im", "con", "by", "init", "n", "it", "oin", "ai", "rin", "is", "mc", "and", "f", "body", "ain", "o", "h", "to", "read", "en", "inc", "from", "nin", "mi", "ind", "re", "al", "ins", "er", "ma", "ar", "up", "bin", "serv", "cin", "inner", "xml", "reader", "stream", "get", "isin", "sum", "l", "r", "In", "include", "mem", "input", "source", "again", "file", "i", " din", "s", "inn", "out", "inside", "inf"], "decoder": ["decer", "desoding", "decoding", "encode", "decode", "desode", "Decade", "deode", "encade", "decade", "desade", " decoding", "encer", "Decoder", " decode", " decade", "Decode", "encoder", "Decer", "desoder", "deoding", "deoder", "deade", " decer"]}}
{"id1": "6304373", "id2": "15129155", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTempTemplate", "uploadOrDeleteMediaOrTempics", "uploadOrDeleteMediaOrTemppl", "uploadOrDeleteMediaAndTTemplate", "uploadOrDeleteMediaAndTemplates", "uploadOrDeleteMediaAndTpl", "uploadOrDeleteMediaAndTplates", "uploadOrDeleteMediaAndTempl", "uploadOrDeleteMediaOrTTemplate", "uploadOrDeleteMediaOrTemTemplate", "uploadOrDeleteMediaOrTemics", "uploadOrDeleteMediaOrTplates", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaAndTemics", "uploadOrDeleteMediaOrTics", "uploadOrDeleteMediaAndTemTemplate", "uploadOrDeleteMediaOrTpl", "uploadOrDeleteMediaAndTics", "uploadOrDeleteMediaOrTempplates"], "action": ["Action", "edit", "expression", "on", "function", "update", "step", "ACT", "ase", "method", "instance", "now", "type", "change", "controller", "address", "exclusive", "scene", "ACTION", "feature", "op", "mode", "ction", "actions", "call", "operator", "verb", "error", "process", "operation", "version", "view", "wrong", "fun", "policy", "go", "event", "behavior", "acl", "actor", "active", "what", "admin", "format", "act", "commit", "activation", "article"], "object": ["function", "node", "model", "volume", "instance", "unknown", "not", "detail", "item", "attribute", "class", "property", "address", "thing", "entity", "no", "o", "integer", "relation", "subject", "element", "resource", "office", "module", "version", "operation", "number", "one", "obj", "event", "project", "entry", "hash", "information", "actor", "job", "document", "what", "format", "oid", "act", "objects", "image", "article"], "numElements": [" numelement", "numElelements", " numeles", "numElelem", "numNlements", " numelem", "numelem", "numElelement", "numelements", "numEleles", "numEles", "numNles", " numelements", "numNlement", "numelement", "numeles", " numEles", "numElem", " numElem", "numNlem"], "req": [" res", " msg", " cmd", "qt", " serv", "Resp", " std", " requ", " request", "msg", "requ", "q", " fr", " resp", " cir", "Requ", " cred", " conf", "request", "quest", "Msg", "txt", "obj", "Cmd", "Request", "tx", "res", "conf"], "session": ["http", "task", "window", "config", "Session", "response", "connection", "manager", "socket", "state", "local", "ses", "subject", "ssl", "use", "client", "browser", "parent", "request", "group", "store", "ession", "thread", "ess", "event", "conn", "sid", "status", "tx", "essions", "stack", "system", "search", "context", "cache"], "ftp": ["FTp", "fttp", " fttp", "aftp", " ftps", "FTP", "afps", " ftP", "afP", "ftP", "FTps", "FTtp", "afp", "ftps"], "user": ["ser", "self", "owner", "per", "part", "db", "by", "dev", "config", "instance", "open", "users", "human", "author", "sys", "used", "plugin", "account", "me", "manager", "person", "ver", "usage", "util", "to", "basic", "User", "use", "auth", "er", "client", "current", "browser", "parent", "store", "rule", "group", "view", "USER", "username", "other", "ter", "event", "result", "record", "form", "mem", "device", "job", "system", "info", "student", "query", "display", "usr", "word", "usa", "order"], "links": ["self", "html", "ls", "properties", "types", "link", "rel", "dir", "pages", "flags", "lines", "packages", "tags", "js", "actions", "blogs", "scripts", "mails", "href", "projects", "details", "relations", "Links", "owners", "groups", "items", "Link", "network"], "folders": ["dires", "foldories", "temories", "conters", "temers", "contes", "dirors", "contors", "foldes", "foldors", "temes", "contories", "temors", "dirories", "dirers"], "folder": ["path", "buffer", "topic", "collection", "location", "host", "volume", "room", "database", "loop", "controller", "zone", "feed", "sheet", "old", "root", "region", "size", "dir", "area", "card", "center", "letter", "older", "lower", "files", "resource", "filename", "email", "box", "module", "division", "container", "upload", "family", "sequence", "directory", "Folder", "project", "base", "stage", "device", "system", "context", "layout", "gallery", "fold", "enter", "zip"], "server": ["buffer", "ser", "site", "owner", "instance", "peer", "database", "seed", "manager", "connection", "ver", "socket", "root", "console", "center", "area", "test", "er", "client", "resource", "email", "browser", "erver", "slave", "store", "version", "engine", "handler", "mobile", "service", "scale", "serving", "directory", "enter", "localhost", "remote", "stage", "device", "port", "domain", "system", "url", "host", "computer", "Server"], "login": ["fn", "ident", "owner", "mail", "cell", "ping", "author", "database", "account", "connection", "secret", "blog", "id", "pin", "token", "nick", "basic", "note", "auth", "nic", "filename", "email", "john", "lock", "pass", "fail", "ername", "name", "skin", "number", "username", "bridge", "license", "net", "print", "submit", "match", "log", "cookie", "profile", "join", "admin", "search", "in", "Login", "ip", "insert", "computer", "phone"], "password": ["path", "strip", "description", "performance", "prefix", "phrase", "restricted", "hello", "worker", "another", "database", "attribute", "secret", "picture", "token", "pool", "parser", "pretty", "exclusive", "ssh", "sudo", "auth", "power", "Password", "resource", "encrypted", "email", "confirmed", "pass", "PASS", "photo", "sword", "productive", "username", "policy", "crypt", "command", "hash", "padding", "python", "device", "stroke", "value", "profile", "comment", "escape", "wordpress", "paste", "word", "pattern"], "fileTransferFolder": ["FileUploadFile", "fileTransferfolder", "FileTransferFile", "fileImportLocation", "fileDownloadArea", "fileDownloadFolder", "fileImportArea", "fileUploadDirectory", "FileUploadDirectory", "fileUploadFolder", "fileMoveDirectory", "fileDownloadDirectory", "fileImportfolder", "fileMovefolder", "fileUploadFile", "FileTransferFolder", "FileTransferfolder", "fileTransferDirectory", "fileUploadfolder", "fileUploadLocation", "fileMoveFile", "fileUploadArea", "fileDownloadFile", "FileTransferArea", "FileUploadfolder", "fileTransferArea", "FileUploadFolder", "FileUploadArea", "FileTransferDirectory", "fileDownloadfolder", "fileTransferLocation", "fileDownloadLocation", "FileUploadLocation", "FileTransferLocation", "fileTransferFile", "fileImportFolder", "fileMoveFolder"], "liveFolder": ["embedFolder", "LiveFolder", "Livefolder", "embedDir", "embedfolder", " liveDir", "liveDir", " livefolder", "livefolder", "LiveDirectory", "liveDirectory", "LiveDir", "embedDirectory", " liveDirectory"], "servers": ["servvers", "serctors", "teors", "Serers", "tectors", "Servers", "serers", "servctors", "Serctors", "serors", "teers", "servors", "tevers", "Serors"], "message": ["buffer", "management", "application", "mail", "reason", "description", "window", "template", "msg", "response", "body", "Message", "alert", "browser", "content", "summary", "warning", "flash", "say", "number", "contact", "sequence", "result", "command", "string", "m", "status", "essage", "language", "log", "show", "comment", "media", "document", "data", "mess", "memory", "trace", "report"]}}
{"id1": "8778962", "id2": "20735941", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeString2String", "decodeFileToString", "decodeString2file", "decodeStringToFiles", "decodeFileFileFiles", "decodeString2File", "decodeFileFilefile", "decodeFileAsfile", "decodeFile2File", "decodeFile2file", "decodeFileTofile", "decodeFileAsFiles", "decodeFileAsString", "decodeFileToFiles", "decodeString2Files", "decodeFileAsFile", "decodeStringToString", "decodeStringTofile", "decodeFileFileString", "decodeStringToFile", "decodeFile2Files", "decodeFileFileFile"], "infile": ["outname", "outfolder", "fromfile", "infolder", "isinname", "frombase", "infilename", "fromfilename", "InFile", "inputfolder", "Infile", "isinfile", "fromFile", "isinfolder", "Inbase", "outfilename", "outbase", "inputname", "inputFile", "inname", "inFile", "isinFile", "inbase", "outFile", "Infilename", "inputfile"], "outfile": ["Outfile", "tofilename", "outname", " outname", " outFile", "outdir", "todir", "infilename", "OutFile", "Outdir", "tofile", "otname", "otFile", "otfile", "outfilename", "toFile", "inname", "otFILE", "inFILE", "indir", "inFile", "Outfilename", "outFile", "outFILE", " outFILE"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "auto", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "shape", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "frame", "note", "bone", "initial", "total", "buff", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "display", "paste", "append", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "shift", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "index", "reading", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " okay", "valid", "ceed", " succeed", "support", "response", "town", "condition", "exist", " succeeds", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "scope", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "done", "photo", "sufficient", "error", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first"]}}
{"id1": "20232250", "id2": "8754809", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["sendCommand", " sendMessage", "executeCommand", "executeMessage", "processrequest", "sendrequest", "executeRequest", " sendrequest", "sendMessage", " sendCommand", "processRequest", "executerequest", "processMessage", "processCommand"], "seq": ["session", "cell", "block", "prefix", "buf", "config", "exc", "msg", "item", "q", "Sequ", "tab", "id", "state", "rez", "enc", "test", "queue", "desc", "frame", "sel", "sub", "que", "client", "pos", "pse", "serv", "ref", "clus", "comp", "protein", "req", "str", "next", "ence", "sec", "sequence", "err", "batch", "struct", "cl", "sequ", "ctx", "iter", "iq", "eq", "sim", "cmd", "cli", "res", "cas", "sq", "gen"], "IOException": ["ReadingException", "ioStatus", " IOStatus", " IOFailure", "ioFailure", "IOFailure", "ReadingFailure", "IOStatus", "ReadingStatus", "ioException"], "putBuf": ["putEBuf", "putLbuff", "posBUF", "putBeUF", "putPurg", "PUTGbuff", "putBbuff", "outputBbuff", "PUTGbuf", "posBuf", " putLuf", "PUTBuf", "putbagg", "PUTGurg", "putLagg", " putBpkg", "outputburg", "putbpkg", "PUTBbuff", "putLuf", "PUTMuf", "putDebuf", "putLpkg", "putBpkg", "putGuf", "putBurg", "posBeuf", "putbuf", "putbbuf", "putDebimg", "putBbuf", " putLbuf", "PUTMld", "posBeagg", "putCimg", "putGub", "PUTMuff", "PUTBurg", "outputGuff", "outputGuf", "putOutuf", "posBagg", "outputbbuf", "putPbuff", "PUTBimg", "putEBpkg", "outputBbuf", "outputbuf", "putEBbuf", "putbbuff", "putBub", "putMld", "PUTBuff", "putLuff", "putOutuff", "putGbuf", " putBagg", "putBeagg", "putDebuff", "putGbuff", "outputGub", "putCuff", "putBuff", "putGuff", "putMuf", "putLurg", "PUTBld", "posBebuf", "PUTMimg", "putBagg", " putLpkg", "outputBub", "putBebuf", " putBbuf", "putOutbuf", "posBeUF", "PUTBbuf", " putLagg", "outputBuff", "putCuf", "putBld", "putburg", "putCld", "putPbuf", "putBimg", "posBbuf", "putLub", "putBUF", "outputBuf", "PUTGuf", "putDebld", "putPuf", "putGUF", "putMimg", "putLbuf", "putGurg", "putBeuf", "putGagg", "putMuff", "outputbbuff", "outputGbuf", "putOutub", "putEBagg", "outputBurg"], "url": ["http", "ls", "abs", "addr", "sl", "open", "ret", "build", "pkg", "bel", "link", "ur", "lb", "Url", "URL", "p", "rel", "att", "ssl", "dl", "uri", "loc", "nl", "atl", "client", "browser", "str", "xml", "ll", "get", "l", "net", "rl", "log", "ctrl", "sb", "https", "cert", "oul", "cmd", "r", "hl"], "conn": ["ch", "nec", "nc", "connect", "db", "con", "addr", "close", "ln", "n", "open", "connection", "ct", "socket", "iw", "inv", "enc", "ws", "sw", "dl", "conv", "loc", "resp", "pas", "win", "client", "nt", "syn", "ns", "write", "ctr", "cb", "comm", "nw", "cp", "obj", "net", "cont", "tn", "cl", "ctx", "cn", "secure", "ann", "ctrl", "cert", "jp", "cmd", "res", "fin", "soc", "Conn", "exec", "cur"], "wr": ["fn", "dr", "spr", "wm", "rew", "WR", "ln", "wer", "vet", "wrote", "wa", "iw", "writers", "Wr", "mg", "ws", "sw", "writ", "pr", "fr", "rw", "wt", "write", "writer", "nw", "vr", "w", "wb", "mr", "wid", "kl", "wk", "mk", "wn", "Writer", "tw", "wo", "mn", "fw", "kr", "we", "hw", "wy", "wx"]}}
{"id1": "22844377", "id2": "10212189", "code1": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"scrapeForIsbns": ["scrapeForIsrbms", "scrapeForIsbbcs", "scrapeForIsbms", "scrapeForISBns", "scrapeForIsBbn", "scrapeForIsrbbn", "scrapeForIsBcs", "scrapeForISbcs", "scrapeForIsbbbn", "scrapeForISBbn", "scrapeForISbms", "scrapeForIsBns", "scrapeForISBcs", "scrapeForIsrbns", "scrapeForISbns", "scrapeForISbbn", "scrapeForIsrbcs", "scrapeForIsbbns", "scrapeForISBms", "scrapeForIsbbms", "scrapeForIsbcs", "scrapeForIsbbn", "scrapeForIsBms"], "url": ["http", "html", "ls", "sl", "open", "build", "link", "ur", "Url", "ul", "address", "f", "URL", "loader", "download", "bl", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "browser", "gl", "mount", "ll", "stream", "l", "char", "u", "string", "rl", "file", "https", "web", "r"], "matches": ["matizes", "parums", "exchers", "exets", " matizes", "matchatches", "isets", "ischers", "mataches", " mataches", "matchedaches", "retizes", "ispects", " matets", " matpects", " matums", "matchers", "retums", "parchers", "parches", "retchers", "matchches", "matchedchers", "isches", "matchchers", "matets", " matatches", "matchedches", "matpects", "expects", " matchers", "matatches", "exches", "matums", "parizes", "matchaches", "matchedatches", "retches"], "p": ["proc", "P", "per", "ping", "pn", "rep", "pkg", "bp", "tp", "q", "lp", "parser", "h", "pa", "np", "re", "pl", "pr", "pro", "t", "pp", "pt", "up", "par", "ps", "hp", "g", "ap", "pb", "pat", "cp", "policy", "perm", "pc", "pe", "sp", "jp", "r", "c", "pattern"], "m": ["pm", "mask", "ms", "model", "j", "n", "man", "arm", "vm", "mc", "me", "em", "tm", "bm", "hm", "met", "mm", "mi", "mt", "M", "dm", "er", "rm", "t", "sm", "v", "cm", "lem", "e", "all", "g", "mate", "mut", "d", "mac", "mun", "mr", "l", "md", "mp", "perm", "mod", "managed", "om", "mem", "gm", "meter", "am", "match", "mu", "mo", "sim", "r", "mat"], "i": ["multi", "im", "x", "j", "n", "phi", "init", "it", "ini", "ai", "is", "ic", "ie", "ui", "a", "me", "ri", "f", "count", "iu", "ia", "id", "y", "io", "ci", "mi", "ind", "ki", "ii", "t", "qi", "v", "gi", "e", "hi", "ti", "bi", "index", "mill", "si", "I", "l", "u", "ei", "batch", "yi", "xi", "us", "di", "sim", "pi", " ii", "ip", "li", "oi", "c", "ix"], "in": ["out", "IN", "dr", "din", "n", "it", "rin", "is", "ic", "b", "f", "o", "inc", "io", "from", "ind", "al", "ins", "fr", "el", "bin", "inner", "reader", "stream", "l", "In", "input", "us", "info", "inn", "r", "inf", "cin"], "br": ["ch", "wr", "out", "dr", "shr", "gr", "buf", "bd", "b", "bp", "bm", "bs", "BR", "bl", "hr", "io", "pr", "er", "fr", "bt", "browser", "Br", "cr", "bro", "be", "bi", "vr", "mr", "tr", "lr", "ro", "bh", "kr", "ber", "r", "yr", "rb"], "str": ["ch", "dr", "text", "part", "st", "vol", "j", "n", "msg", "piece", "b", "del", "exec", "enc", "bl", "sent", "re", "t", "fr", "arr", "spec", "v", "syn", "e", "g", "hex", "STR", "name", "comm", "w", "l", "tr", "obj", "txt", "bc", "char", "cont", "print", "line", "form", "string", "source", "cl", "sp", "chain", "s", "r", "Str", "c", "list", "cur"]}}
{"id1": "14001795", "id2": "17630906", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyOverWarFiles", "copyOverwarFile", "copyoverwarFiles", "copyoverWarFilename", "copyOverTarFiles", "copyOverWarfile", "copyOverTarFile", "copyoverWarFile", "copyoverwarFilename", "copyOverwarFilename", "copyOverTarFilename", "copyoverWarFiles", "copyoverwarfile", "copyoverwarFile", "copyOverWarFilename", "copyOverwarfile", "copyoverWarfile", "copyOverwarFiles", "copyOverTarfile"], "dir": ["path", "disk", "dr", "db", "window", "addr", " d", "add", "cur", "vol", "tmp", "del", "old", "dat", "rel", "wd", "cd", "folder", " directory", "direct", "local", "desc", "dm", "re", "ind", "dep", "dl", "loc", "fin", "parent", " Dir", "dist", "ld", "DIR", "doc", "name", "dd", "d", "dim", "good", "ir", "md", "directory", "mk", "form", "Dir", "def", "iter", "df", "file", "log", "di", "div", "fd", "res", "out", "url", "dial", "coll", "zip"], "ff": ["af", "bf", "alf", "ffe", " aft", " eff", "wind", "lf", "cond", "ef", " af", "fg", "xf", "filter", "ck", " cf", "fp", "aft", "mt", "fact", " df", "ft", " ref", "FF", "buff", "aff", "fc", "uf", "ld", "fl", " def", "cb", "UFF", "fx", "df", "tf", "file", "eff", "uff", "xff", "off", "fd", "cf", "F", "iff", "sf", " FF"], "files": ["uploads", "faces", "assets", "ls", "balls", "plates", "ports", "facts", "iles", "images", "Files", "frames", "rows", "forms", "jobs", "mas", "les", "lines", "tests", "ions", "styles", "features", "members", "days", "leases", "bees", "keys", "values", "fs", "parts", "models", "fields", "file", "resources", "flows", "ories", "names", "issues", "ails", "items", "objects"], "f": ["bf", "alf", "lf", "n", "a", "fe", "xf", "b", "p", "h", "col", "fp", "ft", "t", "v", "sf", "fc", "fab", "fm", "uf", "e", "g", "d", "fl", "w", "fac", "l", "rf", "k", "fs", "elf", "def", "m", "file", "i", "exp", "fw", "F", "cf", "fd", "tf", "c", "fa"], "newFile": ["newsKey", "newsFile", "NewKey", "newFiles", "newPage", "anotherFiles", "NEWNode", "NewFiles", "newfile", "NEWFile", "oldFilename", "newNode", "NewNode", "uniquefile", "uniqueFile", "NewPlace", " newPlace", "NewPage", "newFilename", "newsfile", "NEWPage", "NewFilename", "securefile", "newKey", "anotherfile", "secureFile", "secureKey", "NEWfile", "uniquePage", " newFiles", " newfile", "NewFile", "uniqueNode", "anotherPlace", "oldFile", "Newfile", " newFilename", "anotherFile", "newPlace", "oldfile"], "fi": ["bf", "zi", "lf", "phi", "ini", "fe", "ri", "iu", "FI", "fp", "io", "ci", "mi", "ki", "ii", "fr", "flo", "ifa", "ife", "uf", "ti", "bi", "ni", "si", "afi", "Fi", "i", "di", "pi", "fd", "cf", "fin", "li", "sf", "isi", "fa"], "fo": ["bo", "eno", "FO", "eto", "jo", "te", "ato", "xf", "tk", "tto", "o", "zz", "ki", "flo", "oo", "uo", "ott", "ho", "wt", "hi", "ti", "opa", "oe", "ow", "tif", "oooo", "sty", "hea", "ph", "wo", "po", "zo", "ko", "mo", "fam", "co", "vo", "cf", "tf", "sf"]}}
{"id1": "12783713", "id2": "5035872", "code1": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"sendErrorMessage": ["SendErrorMsg", "sendExceptionMessage", "endInfoMail", "endInfoAction", "senderrorAction", "sendErrorFile", "sendErrorMsg", "sendERRORMessage", "sendERRORAction", "SendUserAction", "sendExceptionAction", "endInfoMsg", "sendErrorMail", "sendInfoMail", "sendUserMessage", "senderrorMsg", "sendUserFile", "SendErrorFile", "sendUserMsg", "sendInfoMsg", "sendInfoAction", "SendErrorMessage", "endErrorAction", "sendExceptionMsg", "SendErrorAction", "sendUserAction", "sendERRORMail", "endErrorMsg", "sendExceptionFile", "endErrorMail", "SendUserMsg", "endInfoMessage", "senderrorMessage", "SendUserMessage", "SendUserFile", "sendInfoMessage", "senderrorMail", "sendERRORMsg", "endErrorMessage", "sendErrorAction", "senderrorFile"], "message": ["text", "reason", "description", "password", "phrase", "template", "hello", "msg", "detail", "response", "title", "payment", "body", "definition", "sample", "subject", "Message", "email", "content", "translation", "request", "error", "name", "number", "sequence", "result", "command", "string", "essage", "language", "value", "log", "job", "comment", "document", "mess", "age", "format", "report", "question"], "NotConnectedException": ["NotConnecttedMessage", "NotLinkedError", "NotConnectEDException", "NotConnecturedError", "NotConnectEDExit", "NotConnectedMessage", "NotConnectEDEntry", "NotLinkEDEntry", "NotConnectEDError", "NotLinkedException", "NotConnecttedException", "NotLinkedEntry", "NotConnectEDMessage", "NotConnecttedEntry", "NotConnectsExit", "NotConnectingMessage", "NotConnectsError", "NotConnectedError", "NotConnecttedError", "NotLinkEDException", "NotConnectsException", "NotConnecturedException", "NotConnectingEntry", "NotLinkedMessage", "NotLinkEDMessage", "NotLinkEDError", "NotConnectingError", "NotConnecturedExit", "NotConnectingException", "NotConnectedExit", "NotConnectedEntry"], "MessagingException": ["MessGettingFailure", " MessingConfiguration", " MessingException", "MessGettingException", "MessgingException", "MessGettingConfiguration", " MessagingFailure", "MessgingFailure", "MessgingConfiguration", "MessagingConfiguration", "MessingConfiguration", " MessagingConfiguration", "MessingFailure", "MessagingFailure", "MessingException", " MessingFailure"], "recipients": ["recipents", "relidents", "relidions", "Recipivers", "Recicions", "recipresses", "recicivers", "relipents", "relidresses", "recisions", "recipers", "Recicivers", "recacients", "recidients", "recipivers", "recentresses", "recentients", "recacivers", "recicers", "recipions", "relipresses", "recidions", "recisers", "recacions", "relipients", "Recipients", "Recicers", "recidents", "Recipions", "relidients", "recentions", "recicients", "recentents", "relipions", "Recipers", "recidresses", "recicions", "Recicients", "recicresses", "recicents", "recisivers", "recacers", "recisients"], "mail": ["nel", " email", "msg", "link", "detail", "echo", "manager", "ul", "ml", "del", "send", "mint", "dm", "mt", "al", "nl", "Mail", "el", "email", "mill", "ll", "contact", "tool", "mun", "l", "mails", "gmail", "bird", "imp", "print", "mem", "m", "select", "file", "log", "plant", "mo", "cert", "cmd", "dial", "report", "list", "zip"], "zos": ["ossus", "zen", "zi", "hz", "opens", "phi", "zik", "jas", "ze", "zu", "zin", "zan", "za", "ez", "hess", "Zen", "rez", "zers", "os", "ozo", " sands", "zon", "css", "zes", "zzle", "estro", "ps", "webkit", "enos", "less", "eus", "zh", "zb", "bes", "enz", "eros", "zl", "fits", "cz", "fs", "zer", "los", "z", "zo", "zar", "ros", "oss", "Sax", "nz"], "fis": [" fi", " fiss", "bfris", " fIs", "fiis", "foires", "fibis", "bfisl", " fris", "fiss", "fi", "foi", "sfIs", "flisl", "fli", "fbis", "flris", "flis", "fisl", "flires", "bfis", "fliss", "fIs", " fbis", "fiIs", " fires", "foiss", "fois", " fisl", "fires", "sfbis", "fris", "sfis"], "entry": ["ion", "cell", "internal", "password", "add", "existent", "rance", "member", "ent", "se", "instance", "ie", "ze", "response", "and", "connection", "see", "sheet", "address", "ry", "row", "letter", "slot", "er", "e", "journal", "office", "inter", "ace", "event", "record", "command", "def", "archive", "table", "csv", "log", "comment", "zo", "data", "search", "Entry", "cel", "enter", "zip"], "buffer": ["Buffer", "binary", "shape", "window", "block", "phrase", "buf", "template", "button", "database", "available", "attribute", "variable", "sample", "queue", "frame", "note", "bone", "buff", "length", "library", "texture", "bytes", "char", "vector", "sequence", "print", "command", "batch", "base", "mem", "padding", "iter", "table", "stack", "document", "scroll", "display", "memory", "paste", "append", "temp", "cache"], "read": ["load", "text", "connect", "add", "close", "bind", "n", "take", "open", "build", "used", "Read", "count", "old", "send", "body", "raw", "q", "end", "en", "size", "sample", "test", "ind", "give", "READ", "allow", "length", "ready", "run", "write", " Read", "req", "need", "next", "readable", "index", "reader", "get", "w", "stream", "print", "mem", "check", "fill", "input", "iter", "wait", "skip", "log", "range", "i", "find", "query", "scroll", "tail", "height", "in", "start", "push", "play", "reads", "len"]}}
{"id1": "18731843", "id2": "732800", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"doBody": [" doContent", " writebody", "loadContent", " dobody", " doHead", "loadbody", " sendBody", " sendHead", " sendbody", " sendContent", " writeHead", "loadHead", " writeBody", "loadBody", " writeContent"], "req": ["gr", "proc", "http", "express", "qt", "reg", "j", "qq", "pkg", "rec", "requ", "aj", "q", "inv", "hr", "crit", "pro", "fr", "Requ", "ps", "js", "request", "quest", "quick", "exec", "err", "def", "Request", "ctx", "tx", "query", "jp", "urg", "cmd", "res", "conf", "sq", "wx"], "resp": ["output", "wr", " res", "http", "Resp", "vol", "rep", "ret", "rec", "response", "wa", "rel", "re", "respond", "pos", "client", "RES", "esp", "serv", "js", "sol", "next", "comm", "respons", "Res", "Response", "err", "result", "Rep", "trans", "def", "cl", "sp", "exp", "res", "out", "soc"], "bis": ["bat", "atis", "ais", "mis", "idis", "lin", "iso", "ris", "is", "nis", "bie", "phis", "bps", "bs", "pin", "iss", "os", "ses", "mi", "onis", "fps", "bits", "obs", "pins", "ubis", "bt", "webkit", "rison", "ads", "bil", "be", "bi", "aus", "bid", "bes", "isin", "iris", "avi", "los", "lbs", "isi", "oss", "zo", "bh", "ios", "sb", "inet", "oi", "lis", "cin"], "bos": ["bo", "oops", "nos", "tis", "asis", "oos", "banks", "mes", "jas", "is", "ows", "uts", "gs", "bs", "dos", "aos", "uds", "os", "its", "ys", "BS", "outs", "bits", "obs", "pins", "ubis", "bin", "bas", "ubs", "bil", "ods", "acs", "bi", "stones", "bes", "zb", "eros", "fits", "fs", "ols", "los", "vas", "oss", "tes", "bh", "ios", "asket", "ts", "oi"]}}
{"id1": "18793482", "id2": "338852", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyApplicationData", "modureAppMessage", "modifyapplicationData", "modifyapplicationMsg", "modifyAppMessage", "modifyServerData", "modureAppMsg", "modureApplicationData", "modifyAppMsg", "modifyServerMsg", "modifyServerMessage", "modifyAppmessage", "modureApplicationmessage", "modifyapplicationmessage", "modureAppmessage", "modureAppData", "modifyServermessage", "modifyApplicationmessage", "modureApplicationMsg", "modifyApplicationMsg", "modureApplicationMessage", "modifyapplicationMessage", "modifyAppData"], "locale": ["localALE", "Locational", "locALE", "locational", "regALE", "regational", "Locales", "localale", "localey", "LocALE", "localaley", " locALE", "regales", " locales", "regale", "Locale", "localales", "Localey", " locational", "localational", " localey", "locales"], "messageName": [" messageType", "mediaKey", "MessageType", " messageNames", "mediaNAME", "MessageNames", "messageNames", " messageNAME", "MessageValue", "messageType", "MessageName", "msgType", "msgKey", "MessageNAME", "messageNAME", "MessageKey", "messageKey", "mediaName", " messageKey", "mediaNames", "msgValue", "msgName"], "messageValue": ["essageVal", " messageType", "languageValue", "MessageType", "essageValue", " messageVal", "MessageValue", "messageVal", "languagevalue", "messageType", "MessageName", "languageVALUE", "languageName", "essageType", "MessageVALUE", "essageName", "messagevalue", "msgVALUE", "messageVALUE", "Messagevalue", "MessageVal", "msgvalue", "msgValue", "msgName"], "properties": ["message", "json", " Properties", "pdf", "config", " props", "perties", "types", "metadata", "property", "params", "prop", "pid", "pro", "files", "ps", "settings", "utils", "policy", "parts", "details", "project", "profile", "results", "data", "options", "report"], "i18nPath": ["i18neStr", "i18bDir", "i8lPath", "i18rDriver", "i18anDriver", "i18nyIf", "i18anDir", "i18nyPath", "i18neDriver", "i18lStr", "i8nStr", "i18lPath", "i18natPath", "i18anPath", "i8nPath", "i18nUrl", "i18anPoints", "i8nUrl", "i18rPath", "i18rIf", "i8lStr", "i18lDir", "i18neDir", "i8nDir", "i18nDriver", "i8lUrl", "i18lUrl", "i18natP", "i18nePath", "i18anP", "i18neUrl", "i18nePoints", "i18nP", "i18natPoints", "i18rDir", "i18nDir", "i18nPoints", "i18anIf", "i18bPath", "i18nyDir", "i18nyDriver", "i18bStr", "i18natDriver", "i18nIf", "i18neP", "i18nStr", "i18bUrl", "i8lDir"], "englishFile": ["ianafile", "ianaDirectory", " englishTable", "englishFilename", "enFilename", "englishDirectory", "languagefile", "languageFilename", " englishfile", "EnglishFiles", "enFile", "languageFile", "ianaTable", "EnglishFile", "englishPath", "EnglishFilename", "englishfile", "electricFile", "englishFiles", "ianaFile", "englishPort", "ianaDir", "wikifile", "enFiles", "languageFiles", "enfile", "englishTable", " englishPath", "wikiFile", "electricPort", "electricDirectory", " englishDirectory", "ianaPort", "ianaPath", " englishPort", " englishDir", "englishDir", "wikiPath", "Englishfile", "wikiTable", "electricDir"], "propertiesFilePath": ["propertiesFilenamePath", "pertiesfilepath", "propertiesfileName", "settingsFilePath", "pertiesFileType", "pertiesFilePath", "settingsFilenamePath", "pertiesfileName", "pertiesFileName", "propertiesfilepath", "propertiesfileType", "propertiesFilesLocation", "propertiesfileLocation", "settingsFilenameName", "pertiesfileType", "propertiesFilesType", "settingsFilenamepath", "propertiesFilesName", "propertiesFilenamepath", "propertiesFilepath", "propertiesFilenameType", "settingsFileName", "propertiesFileLocation", "propertiesFilenameLocation", "propertiesfilePath", "propertiesFilenameName", "settingsFileLocation", "settingsFilepath", "pertiesFilepath", "pertiesfilePath", "propertiesFileType", "propertiesFilesPath", "settingsFilenameLocation", "propertiesFileName", "propertiesFilespath"], "file": ["path", "buffer", "output", "message", "style", "application", "model", "type", "handle", "class", "connection", "attribute", "f", "console", "pool", "complete", "local", "fi", "fp", "create", "io", "os", "use", "File", "files", "channel", "resource", "current", "filename", "parent", "content", "library", "run", "write", "key", "null", "module", "be", "name", "rule", "xml", "page", "ile", "result", "record", "print", "FILE", "entry", "string", "source", "object", "base", "language", "table", "domain", "port", "comment", "document", "info", "data", "format", "image", "report"], "in": ["IN", "din", "gin", "asin", "init", "it", "oin", "rin", "ri", "ini", "ai", "ic", "sin", "ain", "read", "en", "inc", "io", "from", "ind", "al", "ins", "ar", "bin", "inner", "reader", "get", "isin", "ir", "In", "input", "iter", "i", " din", "inn", "inside", "inf", "cin"], "out": ["output", "cos", "con", "n", "Out", "it", "put", "can", "o", "aos", "to", "sw", "os", "end", "io", "ex", "outs", "conv", "ou", "nt", "at", "write", "inner", "external", "w", "screen", "net", "print", "OUT", "conf", "check", "set", "again", "log", "csv", "co", "we", "outer", "cache"], "c": ["ch", "nc", "cos", "C", "con", "cu", "x", "n", "mc", "\u00e7", "ct", "count", "cd", "rc", "character", "col", "ce", "cs", "t", "lc", "unc", "ac", "v", "etc", "fc", "cm", "cr", "call", "code", "cod", "ec", "cb", "d", "dc", "cp", "char", "l", "k", "pc", "bc", "u", "cont", "gc", "cl", "cap", "cc", "arc", "i", "chain", "co", "cf", "r", "conf", "ca", "cache"], "is": ["ais", "es", "isc", "tis", "iso", "ris", "it", "ri", "ic", "sys", "isl", "nis", "bis", "isa", "as", "its", "iss", "os", "ins", "isf", "\u00eds", "Is", "isin", "sit", "iris", "isi", "i", "ios", "sis", "lis", "IS"], "breader": ["bleder", "brewger", "breadger", "breadber", "bbar", "browger", "brewber", "breadder", "breadr", "browber", "blear", "bbder", "brower", "breadar", "brewer", "bler", " breadger", "browe", "bbr", "bber", " breadber", " breadar", " breade", "brewe", " breadr", " breadder", "breade", "bleer"], "line": ["message", "text", "part", "mail", "node", "cell", "block", "lin", "phrase", "ln", "se", "section", "lo", "header", "eline", "link", "detail", "handle", "normal", "shell", "lane", "body", "entity", "no", "row", "sample", "queue", "frame", "left", "note", "slice", "stay", "nl", "lines", "liner", "email", "continue", "le", "code", "inline", "ine", "rule", "label", "edge", "next", "LINE", "ice", "l", "char", "online", "page", "sequence", "record", "entry", "string", "point", "iter", "port", "log", "stroke", "parse", "comment", "range", "chain", "side", "query", "trace", "column", "ip", "cmd", "word", "Line"], "strBuilder": ["arrbuilder", "stringParser", "strBuilt", "frParser", " strBu", "strBuild", "arrBuilder", "stringBuilder", "arrBuild", " strBuffer", "stringBuffer", "objBuilder", "arrBuffer", "strbuilder", "Strbuilder", "arrParser", "stringBuilt", "arrBu", "stringbuilder", "frBuilt", "strParser", "StrBuffer", "frBuilder", "strBu", " strBuild", "objBuffer", "StrBuilder", "frBuild", "StrBu", "StrParser", "StrBuild", " strParser", "objbuilder", "objBuild", "stringBuild", "strBuffer", " strbuilder", "StrBuilt"], "pieces": ["cuts", "tips", "rings", "strings", "units", "links", "cars", "words", "players", "plates", "ops", "types", "piece", "checks", "times", "feet", "places", "pointers", "its", "sections", "ces", "steps", "lines", "bits", "pins", "ps", "xes", "ctors", "Parts", "letters", "fixes", "terms", "maps", "sts", "fits", "bytes", "keys", "parts", "tools", "knife", "ties", "powers", "blocks", "groups", "eps", "caps", "finals", "items", "services"], "found": ["loaded", "printed", "valid", "focused", "released", "Found", "supported", " founded", "used", "available", "built", "installed", "count", "old", "expected", "read", "sent", "filled", "ed", "bool", "started", "created", "needed", "fixed", "tested", "confirmed", "done", "index", "opened", "changed", "compl", "mounted", "good", "err", "identified", "sold", " detected", "finished", " caught", "defined", "forced", "find", "given", "finder", "search", "success", "empty", "successful", "failed", " Found", "first"]}}
{"id1": "19810820", "id2": "22977189", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFileChannel": [" copyStreamchannel", "copyFilechannel", " copyByteChannel", " copyStreamFile", " copyFilesStream", " copyFileschannel", "copyFileStream", "copyBytechannel", " copyBytechannel", " copyFileStream", "copyByteStream", "copyByteChannel", " copyStreamStream", " copyFilechannel", " copyFilesChannel", " copyByteStream", " copyByteFile", "copyByteFile", " copyFileFile", " copyFilesFile", "copyFileFile", " copyStreamChannel"], "src": ["ser", "st", "ls", "sl", "init", "RC", "sync", "SOURCE", "img", "sys", "tmp", "rx", "bs", "sc", "rel", "rc", "from", "ins", "obs", "loc", "filename", "Source", "rs", "js", "syn", "rt", "req", "ctr", "dest", "txt", "sec", "cont", "sr", "source", "input", "rl", "sb", "inst", "s", "usc", "in", "start", "usr", "sf", "sq", "SourceFile", "cur"], "dst": [" ddest", " dist", "Dnd", "sest", "bist", "dth", " dnd", "jst", "sut", "ddest", "best", "bdest", "jdest", "Ddest", "Dst", " dest", "dist", "Dist", "bst", "dest", "sth", "snd", "dut", "dnd", "sdest", "jest", "Dest", "Dut", " dth", "sst", "jut", "Dth"], "preserveModificationTime": ["preserveModificationTimes", "preserveModificationTim", "preserveSpecificationTime", "preserveModifierTimes", "preserveSpecificationsTime", "preserveModifyingTime", "preserveQualificationsTimes", "preserveModifiedTimes", "preserveModifierTim", "preserveModifiedTime", "preserveModifyTime", "preserveModificationsLength", "preserveQualificationsLength", "preserveModifyLength", "preserveModifiedTim", "preserveModifyingPoint", "preserveModifyingTimes", "preserveModificationsPoint", "preserveModificationsTim", "preserveModificationPoint", "preserveQualificationsPoint", "preserveModifyTimes", "preserveSpecificationsTim", "preserveSpecificationTimes", "preserveQualificationTime", "preserveQualificationTimes", "preserveModifierTime", "preserveModifyPoint", "preserveSpecificationTim", "preserveModificationsTime", "preserveSpecificationsTimes", "preserveQualificationPoint", "preserveModifyingLength", "preserveModificationLength", "preserveQualificationsTime", "preserveModificationsTimes", "preserveQualificationLength"], "inputChannel": ["interfaceChannel", "InputStream", "entityChannel", "inputConnection", "hiddenListener", "inputChuck", "outputBuffer", "hiddenCategory", "interfaceCategory", "inputCategory", " inputGray", "infoChuck", " inputConnection", "openChannel", "infochannel", "outputChuck", "inputBuffer", "openGray", "inputListener", "InputChannel", " inputchannel", "evalChannel", "infoChan", "inputChan", " inputChuck", "innerchannel", "innerChan", "inputStream", "evalChan", "InputChan", "hiddenChannel", "clientConnection", "infoChannel", "outputchannel", " inputChan", "InputBuffer", "inputchannel", "innerStream", "openConnection", " inputBuffer", "clientChannel", "Inputchannel", "outputChan", " inputListener", "openChan", "clientChan", "entityChan", "clientGray", "inputGray", " inputStream", "outputStream", " inputCategory", "interfaceListener", "innerChannel"], "outputChannel": ["putChannel", " outputChan", "displayChannel", "writeChannel", "coinChan", "inputConnection", "doubleInstance", "webManager", "doubleChannel", "writeManager", "outputInstance", "outputManager", "outputConnection", " outputchannel", " outputButton", "webchannel", "putchannel", " outputConnection", "coinChannel", "inputChan", "inputField", "putButton", "OutputChan", "displayButton", "writeChan", "outputchannel", " outputStream", "coinInstance", "outputButton", "displayChan", "inputManager", "OutputConnection", "outputField", "OutputManager", "webChannel", "inputInstance", "outputChan", "Outputchannel", "putChan", "displaychannel", "writeStream", "coinField", "writechannel", " outputManager", "OutputStream", "outputStream", "doubleField", "OutputChannel", "doubleChan"], "length": ["buffer", "history", "load", "list", "text", "json", "offset", "shape", "term", "volume", "time", "then", "present", "type", "available", "loop", "ength", "count", "expected", "duration", "size", "to", "end", "Length", "needed", "component", "library", "all", "required", "number", "bytes", "position", "l", "ENGTH", "family", "sequence", "base", "details", "limit", "amount", "HH", "padding", "capacity", "partial", "value", "max", "join", "full", "data", "height", "width", "start", "left", "len"], "total": ["equal", "offset", "description", "unknown", "valid", "last", "human", "used", "bar", "available", "title", "eta", "count", "otal", "raw", "Total", " Total", "ta", "no", "free", "local", "to", "checked", "num", "complete", "size", "note", "t", "created", "current", "translation", "summary", "stable", "this", "all", "less", "done", "required", "index", "number", "scale", "sum", "good", "sequence", "unique", "base", "meta", "amount", "quant", "zero", "active", "max", "info", "full", "successful"]}}
{"id1": "7166270", "id2": "2668634", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"issueCommandToServer": [" sendCommandFromserver", " sendCmdToRemote", " sendCommandFromRemote", " sendCmdToServer", " sendCommandtoServer", " sendCommandToClient", " sendCommandtoClient", " sendCmdtoserver", " sendCmdtoRemote", " sendCommandtoserver", " sendCommandtoRemote", " sendCmdtoServer", " sendCommandTOClient", " sendCommandToserver", " sendCmdtoClient", " sendCommandFromClient", " sendCommandTOserver", " sendCmdToserver", " sendCommandToServer", " sendCommandTOServer", " sendCmdToClient", " sendCommandFromServer", " sendCommandTORemote", " sendCommandToRemote"], "command": ["Command", "message", "history", "application", "text", "description", "password", "program", "template", "method", "menu", "controller", "attribute", "title", "connection", "send", "execute", "help", "uri", "power", "argument", "channel", "mode", "direction", "clear", "request", "code", "communication", "operation", "comm", "sequence", "directory", "event", "form", "string", "action", "document", "query", "requisite", "cmd", "pattern"], "changeCapsule": ["changeClapsularity", "changeCcapsale", "changeCipherale", "changeCapsULE", "changeClcapsule", "changeCarsularity", "changeCarsal", "changeClcapsue", "changeCapsularity", "changeClpsule", "changeCapsal", "changeCmsULE", "changeCcapsue", "changeClapsue", "changeClcapsale", "changeClapsules", "changeClpsules", "changeCcapsules", "changeCpsules", "changeCpsularity", "changeCipherule", "changeClcapsULE", "changeCmsue", "changeCcapsularity", "changeCpsal", "changeCapsale", "changeCipherULE", "changeCmsale", "changeCmsule", "changeCapsue", "changeCarsule", "changeCcapsal", "changeClapsULE", "changeCapsules", "changeClapsule", "changeClpsal", "changeCipherue", "changeClapsale", "changeCpsule", "changeClapsal", "changeCcapsule", "changeClpsularity", "changeCcapsULE", "changeCarsules"], "urlConn": ["httpConn", "strCon", " urlCons", "dlconn", "urlconn", "httpCon", "strConnect", "strNum", "httpConnection", "httpCo", "urlConnect", "fileconn", "retCons", " urlconn", "httpConnect", " urlCo", "logConnect", "fileConn", "urlConnection", "retConnect", "UrlConnect", "urlNum", "fileConnect", "urlCons", "httpconn", " urlNum", "Urlconn", "UrlNum", " urlConnect", "strConnection", "logConnection", "logconn", " urlCon", "strConn", "strconn", "urlCon", "dlConn", "dlConnect", "retconn", "urlCo", "httpCons", "logConn", "UrlConn", "strCo", "retConn"], "wr": ["spr", "RW", "wm", "rew", "WR", "ew", "wer", "vet", "wa", "iw", "writers", "Wr", "wp", "sw", "writ", "hr", "pr", "fr", "rw", "cr", "wt", "write", "writer", "nw", "wb", "vr", "w", "mr", "wid", "wk", "tn", "conn", "wn", "Writer", "tw", "wo", "fw", "kr", "vo", "we", "wy", "wx"], "content": ["output", "message", "Content", "expression", "text", "application", "json", "reason", "description", "core", "add", "update", "template", "config", "section", "header", "ext", "metadata", "address", "body", "ce", "equ", "css", "resource", "current", "code", "write", "key", "script", "version", "label", "load", " Content", "txt", "sequence", "cont", "string", "source", "value", "comment", "document", "media", "data", "format", "search", "context", "join", "layout", "c", "ontent"], "input": ["output", "alpha", "http", "update", "internal", "add", "init", "unknown", "it", "open", "feed", "via", "q", "raw", "read", "local", "iterator", "accept", "inc", "ssl", "Input", "qi", "initial", "current", "ahead", "request", "inner", "background", "reader", "ao", "xml", "get", "upload", "form", "enter", "partial", "submit", "acl", "iter", " Input", "active", "file", "info", "query", "data", "in", "ip", "inside", "storage", "image", "pattern"], "response": ["collection", "output", "buffer", "message", "application", "description", "block", "detail", "onse", "reset", "relation", "frame", "verse", "answer", "respond", "pos", "resp", "server", "alert", "continue", "summary", "library", "request", "related", "version", "next", "view", "still", "service", "position", "respons", "vector", "sequence", "Response", "dict", "result", "line", "object", "value", "reply", "csv", "display", "format", "trace", "image", "report", "network"], "str": ["gr", "dr", "text", "part", "st", "j", "n", "ent", "msg", "piece", "del", "p", "dat", "cat", "re", "cs", "t", "fr", "arr", "le", "g", "hex", "name", "STR", "ctr", "comm", "char", "tr", "obj", "txt", "err", "bc", "cont", "print", "line", "string", "set", "expr", "status", "iter", "i", "br", "sp", "chain", "cert", "data", "s", "exp", "r", "Str", "exec", "list"]}}
{"id1": "16623181", "id2": "11704429", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"srcDir": ["sbDir", " srcDirectory", "sourceDir", "sourceRel", "sitDir", "sitDirectory", "sbPath", "sbRel", "rcDirectory", " srcPath", "srcRel", "srcPath", "srcdir", " srcRel", "sourcePath", "sitPath", "rcDir", "rcPath", "sourceDirectory", "sbDirectory", "rcdir", "srcDirectory", " srcdir", "sitdir"], "dstDir": [" dotdir", "dstDirectory", " dotFile", "dstir", " dndDirectory", "dotir", " dnddir", " dstFile", "ddestDir", "dstFile", "dnddir", " dstDirectory", "destDir", "dndDir", " dstdir", " dotir", " dndFile", "dotFile", "ddsDir", " dstir", "ddsFile", "dotDir", "destDirectory", "ddestFile", "ddsir", "dotdir", "dndDirectory", "ddestdir", "ddestDirectory", "dndFile", " dndDir", " dotDir", "ddsdir", "dndir", "destFile", "destdir", "dstdir"], "srcFiles": [" srcfiles", "sourceFiles", " srcFile", "srcfiles", "rcFiles", "srcFile", "rcfiles", "sourceResources", "rcFile", "srcResources", "rcResources", " srcResources", "sourceFile", "sourcefiles"], "f": ["bf", "alf", "part", "lf", "j", "n", "a", "fo", "fe", "xf", "b", "p", "y", "fi", "o", "h", "col", "fp", "dir", "t", "fr", "fb", "v", "fc", "fm", "ref", "e", "g", "name", "d", "fl", "fac", "w", "l", "k", "good", "fs", "fx", "rf", "perm", "elf", "m", "tf", "file", "z", "i", "exp", "s", "full", "F", "cf", "fd", "r", "sf", "c"], "srcChannel": [" srcchannel", " srcCommand", "sourceButton", "sourcePanel", "rxChannel", "srcChan", " srcPanel", "rxButton", "rcConnection", "srcButton", "srcchannel", "sourceChan", "sslChannel", " srcCh", "srcBuffer", " srcConnection", " srcBuffer", " srcChan", "sourcechannel", "rcChannel", "srClient", "rxPanel", "sourceBuffer", "rcCommand", "rcBuffer", "srcCommand", "sslCh", " srcClient", "sourceChannel", "rcCh", "rcchannel", "srChannel", "srcPanel", "rcChan", "sslChan", "srcCh", "srcConnection", "rxchannel", "srConnection", "rcClient", "sourceClient", "srcClient", " srcButton", "sslBuffer", "srCommand"], "dstChannel": ["dstCategory", "dstChan", "DstChan", "dotConnection", "DotCategory", "dotchannel", "dstchannel", "ddestConnector", "dblConnection", "destConnector", " dstConnector", "dblCategory", "ddestCategory", "destChan", "dstConnection", "Destchannel", "dblChannel", "dustConnector", "DestConnection", " destConnector", "destConnection", " dstChan", "ddestChannel", "ddestComponent", "dustChan", "DstCategory", "dotChannel", "dustChannel", "ddestchannel", " destChan", "ddestChan", "dblChan", "Dstchannel", "dustComponent", "dotCategory", "DstConnection", "destchannel", "DestChan", "DstChannel", "DotChan", "destChannel", " destChannel", "dstConnector", " dstComponent", "ddestConnection", "DotConnection", "destComponent", "dstComponent", "DestChannel", " destComponent", "dotChan", "DotChannel"], "buffer": ["output", "message", "Buffer", "binary", "history", "function", "pause", "shape", "window", "timeout", "block", "phrase", "buf", "template", "button", "header", "database", "hold", "attribute", "filter", "address", "reference", "ob", "variable", "reset", "sample", "queue", "frame", "re", "note", "channel", "resource", "total", "buff", "length", "summary", "library", "null", "rule", "number", "position", "screen", "char", "sequence", "result", "event", "print", "command", "batch", "base", "source", "iter", "grow", "table", "comment", "stack", "chain", "document", "data", "scroll", "memory", "context", "temp", "cache"], "nr": ["nc", "wr", "gr", "out", "our", "attr", "eno", "addr", "byter", "n", "nb", "ln", "sys", "nm", "no", "norm", "vr", "num", "np", "hr", "nl", "uj", "obs", "arr", "rand", "rw", " ni", "radius", "nor", "ns", "next", "ctr", "ni", "nv", "number", "nw", "inter", "ptr", "mr", "nut", "tr", "rr", "Ni", "nir", "nn", "rb", "tn", "bj", "sr", "iter", "adr", "NR", "br", "sim", "ocr", "kr", " NR", "r", "usr", "ng", "nz", "nie"]}}
{"id1": "3801655", "id2": "19868933", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"helper": ["homer", "helhel", "helmer", "hyper", "helporter", "duhel", "heler", "transer", "duter", "transper", "helpporter", "transter", "hyhel", "duper", "helpter", "helpmer", "hyter", "hoper", "helphel", "helter", "duporter", "transmer", "hoer", "hoter", "helpper", "hyporter"], "dataset": ["datassetic", "Datassets", "datatets", "datassetter", "datassset", "datisetter", "databasesset", "datarsET", "dataassetic", "datassets", "dataassets", "Datassetter", "datasET", "datasetic", "dataasetic", "datarsets", "datasets", "datisET", "datatetter", "datbasetic", "dataaset", "Datasets", "datatet", "dataasets", "datasetter", "datisset", "datisets", "datbaset", "Datasset", "datasset", "dataasset", "databasesets", "datiset", "Dataset", "dataasET", "dataassetter", "dataassET", "Datasetter", "dataassset", "datarset", "datisetic", "datarsset", "datbasetter", "databaseset", "datatset", "Datassset", "databasesET", "datbasET", "datassET", "dataasetter"], "zip": ["mail", "json", "lex", "wrap", "pdf", "se", "rar", "pkg", "ze", "link", "xf", "tar", "zone", "handle", "feed", "sheet", "bag", "folder", "download", "dir", "io", "install", "lock", "comp", "code", "box", "Zip", "module", "xml", "lib", "directory", "project", "archive", "file", "zero", "z", "zo", "system", "cf", "ip", "pack", "sea", "jar"], "entries": ["attries", "trs", "currs", "entsers", "attrys", "entsries", "curables", "Entities", "attities", "Entires", "entables", "contresses", "Entrs", "curries", "enresses", "currys", "Enters", "Entables", "Entries", "entsents", "Entrys", "getrys", "entires", "entlements", "Entents", "entslements", "tables", "entrs", "entresses", "attents", "enries", "contires", "entsities", "enters", "entents", "trys", "geters", "getries", "getlements", "enires", "enrys", "Entresses", "tries", "entities", "entrys", "entsrys", "Entlements", "contries", "contrys"], "performance": ["load", "shape", "step", "volume", "split", "force", "cost", "ul", "grade", "mult", "union", "expected", "util", "duration", "evaluate", "dimension", "test", "spec", "fit", "due", "scale", "sum", "speed", "capacity", "log", "minimum", "work", "maximum", "storage"], "index": ["update", "offset", "x", "j", "open", "type", "available", "loop", "connection", "count", "size", "ind", "pos", "total", "lock", "length", "Index", "number", "level", "limit", "set", "capacity", "value", "max", "order", "seek"], "entry": ["keeper", "part", "cell", "internal", "add", "or", "member", "instance", "se", "ent", "it", "ie", "link", "item", "sheet", "ry", "row", "test", "io", "element", "channel", "resource", "e", "key", "office", "module", "name", "next", "xml", "ace", "char", "result", "record", "cont", "archive", "match", "job", "data", "context", "Entry", "enter", "word", "jar"], "temp": ["fake", "emp", "orig", "wrap", "template", "pdf", "EMP", "tmp", "tar", "tm", "mint", "tab", "root", "local", "por", "create", "test", "dir", "stem", "mt", "t", "created", "pt", "current", "wrapper", " temporary", "parent", "this", "pre", "null", "tc", "cp", "dest", "thread", "tr", "txt", "mp", "mk", "mod", "Temp", "porary", "base", "partial", "mem", "copy", "tim", "tx", "table", "file", " tmp", "tem", "empty"], "writer": ["output", "message", "builder", "owner", "ger", "window", "penter", "worker", "connection", "wrote", "riter", "loader", "writers", "master", "console", "variable", "writing", "wp", "iterator", "writ", "maker", "creator", "er", "server", "rw", "browser", "wrapper", "parent", "write", "null", "wire", "handler", "external", "w", "stream", "thread", "player", "service", "ter", "Reader", "ner", "print", "Writer", "iter", "file", "driver", "system", "walker", "document", "ler", "network"], "reader": ["runner", "dr", "builder", "rar", "volume", "peer", "ri", "handle", "rx", "feed", "rer", "loader", "ry", "ard", "row", "iterator", "er", "wrapper", "inner", "readable", "reading", "handler", "stream", "rot", "rr", "Reader", "ner", "roller", "input", "iter", "file", "driver", "ro", "r"], "buffer": ["message", "Buffer", "binary", "history", "window", "block", "phrase", "buf", "template", "font", "header", "database", "bar", "variable", "row", "sample", "queue", "frame", "buff", "length", "null", "background", "char", "vector", "sequence", "command", "batch", "padding", "capacity", "iter", "table", "stroke", "stack", "document", "scroll", "memory", "append", "column", "word", "cache"], "read": ["each", "load", "text", "add", "close", "bind", "time", "take", "open", "build", "Read", "mix", "hold", "used", "count", "send", "old", "q", "raw", "end", "create", "test", "en", "size", "like", "give", "READ", "enable", "length", "ready", "len", "run", "write", " Read", "need", "next", "readable", "reading", "get", "stream", "tell", "before", "print", "mem", "check", "source", "set", "fill", "iter", "input", "select", "skip", "parse", "find", "query", "format", "start", "handle", "word", "report", "reads", "seek"], "outfile": ["initFile", "initfile", "outputfolder", "inputstream", " outbuffer", "outfolder", "OUTFile", "outputFile", " outFile", "inchannel", "infolder", " outchannel", "outputfile", " outstream", "outchannel", "outputstream", "initfolder", "infile", "inputbuffer", "OUTfile", "outstream", "inputFile", "initstream", "OUTchannel", "inFile", "inbuffer", "outFile", "outbuffer", "instream", "inputfile"], "line": ["message", "text", "cell", "block", "lin", "phrase", "ln", "section", "lo", "msg", "header", "eline", "detail", "link", "statement", "Line", "row", "sample", "frame", "note", "lines", "liner", "train", "le", "e", "code", "inline", "ine", "LINE", "l", "online", "page", "char", "sequence", "string", "point", "iter", "port", "file", "log", "range", "chain", "comment", "column", "word"], "parser": ["runner", "builder", "arser", "penter", "auto", "worker", "hander", "processor", "rer", "loader", "lp", "iterator", "maker", "er", "music", "conv", "asser", "uler", "Parser", "operator", "pair", "magic", "xml", "handler", "bank", "policy", "ner", "ler", "layer", "file", " scanner", "parse", "system", "cer", "walker", "finder", "format"], "list": ["collection", "output", "ist", "part", "member", "menu", "detail", "pool", "queue", "left", "map", "lists", "parent", "all", "null", "group", "l", "LIST", "level", "dict", "result", "record", "sequence", "print", "batch", "table", "file", "match", "range", "chain", "data", "listed", "array", "out", "li"], "rule": ["field", "Rule", "style", "function", "node", "block", "force", "ULE", "rol", "item", "statement", "filter", "definition", "ule", "row", "relation", "re", "feature", "rank", "run", "module", "policy", "rr", "result", "record", "command", "rl", "table", "value", "match", "file", "parse", "range", "chain", "r", "play", "role"], "measure": ["MeMeasure", "peasured", "peMeasure", "Measure", "Measuring", "MEasured", "Measured", "measured", "MEasuring", "MEasure", "peasure", "MEMeasure", "peasuring", "meMeasure", "measuring"]}}
{"id1": "17716716", "id2": "14303294", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "label": 1, "substitutes": {"plainToMD": [" convertToMC", " convertAsMC", " stringFromDM", " convertAsMD", " stringToDM", " convertToDM", " stringFromMC", " convertToMD", " convertTomd", " stringAsDM", " stringAsmd", " stringFromMD", " stringToMD", " stringTomd", " convertAsmd", " stringAsMC", " convertAsDM", " stringAsMD", " stringToMC", " stringFrommd"], "loggerCol": ["logggerColl", "loggerCOL", "logGERCOL", "logggerCOL", "loggeCol", "loginatorCl", "loggeCl", " loggerCOL", " loggerColumn", "logggerColumn", "badinatorCl", "logGERCol", "logggerCl", "loggeColl", " logggerCol", "badgerCol", "logggerCol", "logiderCol", "logiderColumn", "badinatorCol", "loggerCl", "loggerColl", " logggerCOL", "loggeCOL", "loginatorCOL", "loginatorColl", "badinatorCOL", "badgerCOL", "badgerColl", "badgerCl", "logiderCOL", "logGERColumn", "badinatorColl", "loginatorCol", " logggerColumn", "loggerColumn"], "input": ["output", "buffer", "text", "prefix", "hello", "it", "config", "example", "q", "raw", "from", "subject", "Input", "initial", "up", "request", "this", "str", "background", "char", "result", "form", "base", "command", "string", "source", "hash", " Input", "value", "file", "active", "document", "data", " inputs", "url", "in", "out", "context", "image", "pattern"], "byteHash": ["binaryHas", "byteLength", "ByteTr", "binaryHash", "bytehash", "uehash", "byteMap", " byteLength", "bytesHas", " byteTr", " byteHas", "ueTr", " bytehash", "Bytehash", "byteHas", "bytesHash", "byteshash", "ByteHas", "ueLength", "ByteMap", "byteTr", "binaryhash", " byteMap", "ByteLength", "ueHash", "ByteHash", "bytesMap"], "md": ["gr", "dr", "pm", "ded", "ms", "nd", "add", "cond", "msg", "sd", "mc", "bd", "od", "ct", "MD", "grad", "der", "cd", "ds", "mg", "met", "mm", "dm", "mt", "rm", "ind", "red", "sm", "det", "comp", "ld", "doc", "dd", "d", " Md", " mc", "mb", "mac", "mp", "mk", "mod", "dig", " MD", "gm", "pd", "def", "m", "hash", "df", "material", "sam", "di", "mo", "mn", "cmd", "med", "hd", "ng", "de"], "md5result": ["md64result", " md5Result", "MD5Result", "md3Result", "md5string", "md2Result", "md45results", "md65Result", "md3proc", "md2string", "md45result", "md45comment", "md64response", "MD2comment", "md5comment", "md3result", "md7result", "md5message", "md8proc", "MD5results", " md8proc", "md64results", "md7Result", "MD2Result", "MD5response", " md5proc", "MD5comment", "MD5result", " md8result", "md3results", "md5response", "md2results", "md7string", "MD2result", "MD5string", "MD2string", "md8message", "md64comment", "md3message", " md8message", "md65result", "md5results", "md65proc", "md45response", "md2comment", "md2result", "md5Result", "md65message", "MD2results", "md5proc", "md2response", "md8result", "MD2response", "md7results", "md8Result", " md5message", "md3string", " md8Result"], "i": ["multi", "ims", "im", "x", "j", "n", "phi", "it", "init", "my", "ai", "a", "is", "ic", "ie", "ui", "b", "me", "q", "id", "y", "fi", "o", "io", "ci", "mi", "ind", "gu", "uri", "qi", "ii", "v", "gi", "key", "ti", "ji", "bi", "index", "si", "I", "span", "u", "l", "ei", "m", "iter", "xi", "us", "cli", "z", "di", "sim", "pi", "in", "ip", "li", "c", "\u0438", "ix"]}}
{"id1": "15241397", "id2": "13886238", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "DoGET", "Doget", "doGET", "DoPut", "doget", "DoGet", "handleGet", "handlePut", "doPut", " doPut", "handleget", " doget"], "request": ["each", "message", "http", "application", "QUEST", "hello", "user", "attribute", "connection", "address", "reference", "complete", "reset", "create", "frame", "re", "client", "initial", "current", "server", "transform", "setup", "forward", "req", "quest", "get", "position", "command", "input", "Request", "the", "document", "query", "in", "start", "context", "report", "first", "question"], "response": ["output", "ve", "message", "http", "application", "site", "session", "json", "description", "block", "fire", "onse", "connection", "send", "body", "console", "reset", "ce", "frame", "respond", "answer", "resp", "resource", "server", "content", "exit", "write", "version", "next", "xml", "view", "service", "position", "page", "Response", "result", "sequence", "form", "print", "object", "status", "reply", "document", "success", "context", "res", "image", "report", "network"], "rewrittenQueryString": ["rewartedQueryStream", "rewrittenquerystring", "rewwrittenquerystring", "rewrittenURLString", "rewartedHeaderStr", "rewwrittenqueryStr", "rewartedHeaderStream", "rewliedqueryStr", "rewrittenQuerystring", "rewwrittenQueryStr", "rewrittenqueryStream", "rewrittenURLstring", "rewrittenQuStr", "rewwrittenQueryString", "rewrittenURLStr", "rewliedqueryStream", "rewwrittenqueryString", "rewartedQuerystring", "rewrittenHeaderString", "rewrittenRequestQuery", "rewartedQueryString", "rewrittenRequeststring", "rewrittenURLStream", "rewwrittenqueryQuery", "rewliedQueryString", "rewrittenHeaderStream", "rewartedHeaderstring", "rewrittenQuestionString", "rewliedqueryString", "rewrittenHeaderstring", "rewrittenQuestionStream", "rewrittenCurrentQuery", "rewliedQueryStr", "rewrittenCurrentStr", "rewrittenHeaderStr", "rewrittenQueryQuery", "rewartedQueryStr", "rewrittenQueryStream", "rewrittenqueryQuery", "rewliedQueryStream", "rewrittenQuString", "rewrittenqueryStr", "rewrittenQuStream", "rewwrittenQuerystring", "rewartedHeaderString", "rewrittenQuestionStr", "rewrittenQueryStr", "rewrittenQustring", "rewrittenRequestString", "rewrittenCurrentstring", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenqueryString", "rewrittenRequestStr"], "rewrittenUrl": ["rewwrittenPort", "rewriddenURL", "rewroteLink", "RewwrittenString", "rewriteurl", "RewrittenUrl", "RewrittenPosition", "rewrownURL", "rewwrittenUrl", "rewrapedUrl", "rewittenURL", "RewrittenString", "rewroteUr", "RewwrittenLink", "Rewwrittenurl", "RewwrittenUrl", "rewartedPosition", "RewwrittenURL", "RewrittenUr", "rewedUrl", "rewrownUrl", "rewrapedURL", "RewwrittenPosition", "rewrittenPort", "rewrownUr", "rewroteurl", "rewrapedPort", "rewedString", "RewrittenPort", "rewriddenPosition", "rewrittenLink", "rewartedUrl", "rewrittenUr", "RewrittenLink", "rewittenUrl", "Rewrittenurl", "rewriteUrl", "rewriterString", "rewartedUr", "rewriterUr", "rewittenurl", "rewrownPosition", "rewwrittenUr", "rewadjustedUrl", "rewrittenString", "RewwrittenPort", "rewadjustedPort", "rewwrittenURL", "rewwrittenLink", "rewartedURL", "rewrotePosition", "rewwrittenPosition", "rewrittenurl", "rewedUr", "rewadjustedUr", "rewriddenUrl", "rewroteURL", "rewriteURL", "rewedURL", "rewriteUr", "rewadjustedURL", "rewwrittenString", "rewriterURL", "rewartedurl", "rewwrittenurl", "rewrapedUr", "rewrittenPosition", "rewittenLink", "rewriddenUr", "rewroteUrl", "RewrittenURL", "rewriterUrl", "rewrittenURL", "RewwrittenUr"], "httpURLConnection": ["HttpURLConnection", "httpURLConnect", "httpUrlApplication", "HttpURLConnect", "ttpURLConnect", "HttpHTTPConnect", "httpSRApplication", "httpHTTPConnect", "ttpUrlConnect", "ttpUrlConn", "ttpUrlApplication", "httpURLApplication", "httpFileConn", "httpURLConn", "ttpURLApplication", " httpUrlApplication", "httpUrlConfiguration", "HttpURLApplication", "httpMLConnect", "HttpHTTPConfiguration", "httpHTTPControl", "httpMLconnection", "httpUrlConnect", "ttpURLConnection", "httpHTTPconnection", "httpURLControl", "ttpUrlconnection", " httpUrlConnection", "ttpUrlControl", "httpRLConnect", "httpRLconnection", "httpFileConnection", " httpUrlconnection", "httpHTTPConn", "HttpUrlConnect", " httpUrlConnect", "httpURLconnection", "httpFileApplication", "httpHTTPConnection", "ttpURLConn", "HttpUrlconnection", "httpSRconnection", "httpURLConfiguration", "HttpHTTPConnection", "httpMLApplication", "ttpURLconnection", "httpMLConnection", " httpURLconnection", "httpSRConnect", "httpSRConnection", "ttpUrlConnection", "httpSRControl", " httpURLConnect", "httpUrlConnection", "httpHTTPConfiguration", "httpUrlconnection", "HttpURLconnection", "HttpUrlConnection", "httpHTTPApplication", " httpURLApplication", "HttpURLConfiguration", "ttpURLControl", "HttpHTTPconnection", "httpFileConnect", "httpRLConnection", "httpSRConfiguration", "httpUrlControl", "httpUrlConn", "HttpHTTPApplication", "httpRLApplication"], "header": ["field", "buffer", "dr", "part", "core", "term", "block", "init", "prefix", "head", "section", "user", "peer", "headers", "shift", "detail", "attribute", "heading", "metadata", "title", "zone", "filter", "address", "holder", "state", "token", "variable", "h", "relation", "er", "feature", "client", "argument", "wrapper", "tag", "component", "operator", "rule", "version", "handler", "hidden", "policy", "ter", "page", "event", "line", "meta", "check", "hash", "Header", "layer", "status", "padding", "device", "port", "comment", "option", "info", "query", "format", "column", "handle"], "value": ["field", "VALUE", "message", "expression", "text", "json", "description", "password", "save", "hello", "val", "instance", "des", "attribute", "zone", "see", "example", "property", "address", "sample", "create", "test", "default", "element", "current", "server", "v", "email", "content", "pair", "Value", "key", "version", "label", "name", "unit", "ue", "values", "vector", "sequence", "record", "entry", "string", "hash", "language", "python", "job", "comment", "sv", "data", "format"], "inputStream": ["InputStream", "outputSteam", " inputThread", "inputWindow", "inputstream", "inputView", "errorSteam", "errorWindow", " inputLoop", " inputSteam", "InputView", "InputLoop", "outputstream", "inputThread", "inputSteam", "outputView", "outputLoop", "outputThread", "inputLoop", "InputThread", " inputWindow", "errorstream", " inputstream", "errorStream", " inputView", "outputWindow"], "outputStream": ["outputSteam", "responseLength", " outputLength", "inputstream", " outputForm", "inputView", "displayView", "displaySteam", "displayStream", "OutputLength", "outputForm", "responseSteam", "outputstream", "OutputSteam", "responseStream", "outputLength", "inputSteam", "outputView", "displaystream", " outputstream", "OutputStream", "responseForm", " outputSteam", "OutputForm", " outputView"]}}
{"id1": "21995302", "id2": "22264586", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"open": ["load", "connect", "update", "on", "close", "add", "save", "init", "access", "Open", "present", "transfer", "o", "read", "download", "accept", "create", "reset", "use", "t", "op", "lock", "alert", "release", "write", "be", "error", "process", "get", "un", "check", "set", "match", "show", "render", "parse", "construct", "document", "find", "start", "handle", "enter", "are"], "input": ["output", "buffer", "load", "text", "add", "init", "config", "it", "qa", "attribute", "feed", "address", "q", "raw", "p", "local", "accept", "reset", "read", "io", "from", "context", "Input", "channel", "initial", "client", "up", "spec", "request", "inner", "any", "error", "pull", "xml", "view", "reader", "stream", "upload", "get", "form", "enter", "cont", "base", "entry", "PUT", "source", "submit", "check", "file", "active", "media", "data", "empty", "format", "in", "out", "start", "act", "image", "exec", "list", "cur"], "uri": ["ahi", "nil", "http", "term", "force", "ri", "requ", "connection", "folder", "basic", "qi", "component", "du", "cp", "form", "archive", "defined", "based", "zip", "description", "uni", "link", "ui", "ur", "uno", "util", "queue", "e", "hi", "ue", "char", "quote", "remote", "details", "project", "domain", "die", "distance", "ip", "multi", "cos", "sky", "prefix", "manager", "address", "via", "id", "iri", "local", "frame", "resource", " URI", "library", "uu", "direction", "nu", "unit", "u", "directory", "copy", "country", "ve", "mail", "thus", "phi", "proxy", "reference", "mi", "filename", "none", "username", "URI", "source", "i", "range", "image"], "url": ["out", "http", "mail", "html", "window", "sl", "user", "build", "bel", "link", "ul", "Url", "f", "URL", "rel", "ssl", "dl", "nl", "bool", "client", "el", "browser", "gl", "str", "name", "mb", "ll", "external", "l", "char", "err", "kl", "rl", "log", "job", "sb", "web", "cert", "r", "coll", "il"]}}
{"id1": "160739", "id2": "1421557", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createFileStream", "createInputstream", " createOutputFile", " createFilestream", " createInputSteam", " createFileSteam", " createOutFile", "createOutputstream", "createInputFile", " createOutStream", "createInputStream", " createOutputSteam", "createOutputSteam", " createFileFile", " createInputStream", " createOutSteam", "createInputSteam", " createInputFile", " createOutstream", " createInputstream", "createOutputFile", " createOutputstream"], "inFile": ["inputPath", "inDir", "dinPort", "ninPath", "dinPath", "dinDir", " infile", "outFilename", " inPort", "infile", "ninFilename", "inputDir", " inPath", "ninFile", "outPath", "inFilename", "inPort", "outfile", "inputFile", "inputPort", "dinFile", " inDir", "inPath", " inFilename", "ninfile"], "outFile": ["Outfile", "exfile", "outPlace", "outPort", "outputFilename", "OutFilename", "outputFile", "outputPlace", "exFile", "newfile", "OutPort", "outputfile", "exPlace", "OutFile", "toPort", "outFilename", "newFilename", "tofile", "infile", "newFile", "toFile", "inFilename", "inPort", "outfile", "toFilename", "exFilename", "newPlace"], "k_blockSize": ["k_BlockTime", "k4BlockName", "k_BlockStyle", "k2byteLength", "k_byteSize", "k2blockLength", "k_blockName", "k4blockSize", "k2byteTime", "k4blockCount", "k2blockTime", "k_blockTime", "k_byteName", "k_batchLength", "k4BlockStyle", "k_BlockLength", "k_BlockSize", "k_BlockCount", "k2blockSize", "k4BlockSize", "k_byteTime", "k_batchTime", "k_blockCount", "k4BlockCount", "k2byteCount", "k_blockLength", "k_byteLength", "k4blockStyle", "k2byteSize", "k_blockStyle", "k_BlockName", "k_batchSize", "k4blockName", "k_byteCount", "k2blockCount", "k_batchCount", "k_byteStyle"], "byteCount": ["byteLength", "wordN", "bitN", "byteSize", "byteCode", "charPtr", "bitSize", "bitCounter", "linePtr", "bytecount", "wordCode", " byteLength", "bitCount", "bytePtr", "charCount", "lineLength", "byteCounter", " bytecount", "bbCode", "wordSize", "bitLength", " bytePtr", "bbN", "blockCounter", "blockLength", "charLength", "bitCode", "byteCheck", "blockCount", "bbSize", " byteCheck", "byteN", "wordCount", "charcount", "bbCount", " byteCounter", "linecount", "lineCount", "bitCheck", "blockCheck"], "buf": ["buffer", "proc", "Buffer", "db", "block", "img", "msg", "pkg", "fg", "b", "bag", "raw", "Buff", "bn", "alph", "cat", "bl", "queue", "cv", "seq", "conv", "arr", "buff", "uf", "bg", "cast", "pb", "ctr", "str", "vec", "cb", "doc", "bytes", "txt", "bc", "batch", "mem", "ctx", "tx", "cap", "exp", "cmd", "rb", "cur"], "ofp": ["owlpa", " ofpa", "ofd", "OFP", "owlp", "ofl", " ofP", "ofP", "owlP", "Ofpa", "Ofl", " ofl", "ofpa", "OFd", "Ofp", "OfP", "Ofd", "OFp", " ofd", "OFl", "owld"], "zos": ["ossus", "cos", "sbm", "esa", "zen", "zi", "es", "rss", "tis", "init", "hz", "amia", "zik", "jas", "ze", "zy", "zu", "psy", "gs", "osi", "zin", "bs", "za", "socket", "ez", "hess", "rez", "ws", "os", "zers", "zon", "css", "zag", "zes", "std", "zzle", "LOS", "ps", "webkit", "js", "enos", "rose", "settings", "zh", "zb", "bes", "eros", "zl", "cz", "south", "zer", "los", "python", "sch", "z", "zo", "oss", "sis", "jp", "zona", "nz", "zip"], "osw": ["iswx", "aosW", "osiw", "cosw", "ospace", "osd", "aosw", "sysw", "sysW", "aosd", "cosew", "oW", "syswd", "isw", "owa", "cosd", "issw", "osew", "ossw", "cosws", "osrw", "sysrw", "aoswd", "osws", " ossw", "osswx", "osiW", "opace", "ow", " oswx", "aoswa", "aospace", "aosrw", "osswd", "osiwa", "osipace", " osew", "ossrw", " osW", "osW", "isW", "aosew", " osd", "ossW", "oswa", "oswx", "osssw", "aosws", "oswd", " osws"], "bw": ["nbwe", "abwe", "besw", "bbx", "pbwb", "sbwb", "bex", "pbz", "sbw", "pbwe", "bwk", " bem", " bx", "bbz", " bwl", "obwb", "bwp", "bsw", "bbend", "nbew", "bwl", "bewk", "bbwp", " bex", "pbwt", "rbw", " bz", "bwb", "abew", "bwy", "nbw", "obwl", "bewl", "pbw", "wbw", "sbz", "pbwy", " bsw", "bew", "bem", "bbws", " bwp", "rbex", "wbz", "wbwp", " bwk", "wbem", " bwt", "bwt", "bwe", "obsw", "abwy", "bbex", "wbwt", "nbwy", " bend", "rbws", "wbend", "pbew", "bbw", "bz", "bws", "bx", "wbx", "abw", "sbwt", "obwt", " bws", "rbz", "obw", "obwk", "bbwt", "obz", "bend", "bbem"], "zot": ["ziot", "zerot", "zeronet", "zeror", "zonet", "zipot", "Zot", " ziat", "zoor", "Zit", " zott", "zott", " zo", "zerote", "zoot", "ziphot", "zoonet", "zoo", "zipiat", "zerit", "zeriat", " ziot", " zor", "zor", "zerhot", "zerott", "zipiot", " zonet", "Zote", "zhot", "zero", "Zott", "zote", "ziat", "zeriot", "zo", " zote", " zhot"], "ifp": [" ifd", " ifr", "iwd", " ifth", "iwp", " ifP", " iftp", "ifP", "isP", "Ifth", " ifjp", "iwr", "ifjp", "isjp", "ihp", "Ifjp", "isp", "ifr", "ihr", "ihtp", "iwtp", "IfP", "ifth", "ihd", "Ifp", "iftp", "ifd", "isth"], "zis": [" ziss", "izis", "zeris", " zi", "ezis", "zi", "izisa", "izi", "zoisa", " zIS", "zipic", "zoinit", "eziss", "zois", "zisa", "zerIS", "zIS", "zipis", " zic", "zisc", "zoiss", "zinit", "izinit", "ziinit", "izisc", "zic", "zeric", "ziisa", "ziis", "zipIS", "iziss", "ziss", "ziiss", " zisc", "ezi", "ezisc"], "isr": ["sisrs", "ispr", "iosstr", "itssr", "iospr", "isalr", "issrc", "iossr", "isscr", "issrs", "iosr", "itsstr", "isstr", "iscr", "issr", "isalpr", " isrs", "sisr", "siscr", "itspr", " isrc", "isalstr", "isrs", "sisrc", "isalsr", " iscr", "itsr", "isrc"], "br": ["wr", "gr", "dr", "shr", "bf", "bd", "b", "bp", "bm", "BR", "rel", "bn", "bl", "hr", "pr", "fr", "bt", "js", "Br", "cr", "bro", "bi", "obl", "str", "ctr", "Fr", "vr", "mr", "tr", "ptr", "bj", "sr", "lr", "ba", "bh", " Br", "kr", "ber", "r", "yr", "rb"], "zit": ["zeop", "zipIT", "iziti", "ziti", "zipit", "izip", "zist", "ozit", "czip", "czit", "ezlit", "zite", "ozunit", "ezIT", "lexIt", "ziit", "lexIT", "czop", "czunit", " zlit", "ziplit", "zIT", "zipist", "ziIt", "zlit", "ezite", " zip", " zIT", "cziti", "lexist", "zipite", "zunit", "lexit", "oziti", "ziIT", "zeit", "zipIt", "ezit", "zeip", "czot", "izit", "ozip", " zite", "zIt", "ziist", "zeot", "zop", " zop", "izunit", "zip"]}}
{"id1": "6371589", "id2": "20663364", "code1": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"insertUser": [" insertPerson", "addUser", "addPerson", "insertPerson", "insertUsers", "insertAccount", "addAccount", "InsertUsers", "addUsers", "InsertAccount", "InsertUser", " insertAccount", " insertUsers", "InsertPerson"], "newUsers": ["newsUsers", "newsVersions", "NEWUsers", "newVersions", "newIDs", "latestStudents", "New", "latestUsers", "Secure", " newusers", "givenVersions", "givenPosts", "newusers", "newStudents", " NewIDs", "newsPosts", "newPosts", "_", " newVersions", "latestPosts", "givenUsers", "NEWStudents", " NewPosts", "givenusers", "NEWPosts", "NEWIDs", " NewStudents", " newPosts", " NewUsers", "newsusers", "latestIDs"], "pass": ["priv", "dr", "session", "miss", "password", "add", "save", "access", "cross", "pg", "params", "p", "wd", "pool", "prop", "cat", "col", "pl", "auth", "pas", "crit", "allow", "pos", "use", "ps", "par", "fail", "na", "PASS", "Pass", "post", "ack", "conn", "conf", "def", "hash", "skip", "parse", "ass", "oss", "res", "push", "pillar", "pp"], "realmPass": ["RealamAdd", "realnCat", "realmnpass", "realimAss", "balmDrag", "realmnCat", "RealamAss", "realmiPass", "realrAct", "realemPass", "realnPass", "realrpass", "realmCat", "realmnPass", "realamFail", "realrPass", "RealamPass", "calmAdd", "balmpass", "realmspass", "balmiDrag", "realrAdd", "RealmPass", "realmFail", "realmpass", "balmiPass", "balmCat", "balmipass", "realnpass", "realmiCat", "RealgmPass", "calmsAct", "realgmPass", "RealgmFail", "realmDrag", "calmpass", "realgmpass", "realemFail", "realemAdd", "balmPass", "realamAdd", "RealmCat", "realmAct", "RealgmAdd", "RealmAdd", "realgmFail", "RealamCat", "realmiDrag", "realmsAct", "realamPass", "RealmAss", "realgmAdd", "Realmpass", "realmnDrag", "realmsPass", "realnDrag", "realmipass", "realamCat", "realempass", "RealmFail", "realamAss", "realampass", "calmspass", "balmiCat", "calmsPass", "Realgmpass", "realgmAct", "realimCat", "realmsAss", "realmAdd", "realimPass", "calmPass", "calmAct", "realimAdd", "realmsAdd", "realmAss", "realmsCat", "calmsAdd"], "userDirs": ["userDirns", " userDirirs", " userDirir", "userDns", "userDirirs", " userDs", " userDirns", "userPathir", "userDir", "userDirir", "userDs", "userPaths", "userPathns", " userDir", " userDns", "userPathirs"], "iter": ["ser", "ator", "iner", "it", "valid", "peer", "Iter", "loop", "orient", "del", "ver", "ill", "rer", "loader", "test", "maker", "altern", "ci", "inc", "ind", "iz", "er", "loc", "oper", "el", "spec", "train", "iv", "hex", "inner", "next", "ait", "reader", "inter", "coll", "ipper", "ptr", "tr", "ter", "ir", "err", "vis", "ner", "here", "gener", "itter", "skip", "fer", "i", "range", "info", "kit", "ip", "outer", "li", "exec", "il"], "user": ["bo", "per", "core", "term", "by", "author", "parent", "component", "pre", "error", "version", "USER", "other", "form", "status", "date", "file", "job", "query", "word", "role", "or", "entity", "row", "from", "User", "char", "player", "ter", "entry", "project", "object", "us", "comment", "display", "part", "password", "dev", "volume", "menu", "users", "used", "me", "person", "body", "use", "client", "resource", "browser", "confirmed", "uu", "rule", "contact", "u", "result", "check", "device", "system", "student", "usa", "message", "self", "owner", "time", "open", "item", "plugin", "account", "ver", "vote", "usage", "test", "creator", "module", "store", "post", "event", "record", "match", "profile", "info", "usr"], "realm": ["rall", "rems", "ralms", "palmin", "palmi", "realmo", "calmo", "realmi", "chemi", "calM", "Realmn", "schems", " realgm", "calmi", "Realmo", "realM", "rec", "rem", "Realmi", "cheM", "palm", "reall", "trc", "rel", "schemi", "realmn", "calm", "RealM", "chem", "calgm", "realc", "realmin", "schem", "trm", " realmi", "ralc", "Realgm", "Realm", "chemn", " realmo", "schemin", "trl", "calmn", "trms", " realmin", "realgm", "ralm", "palms"], "username": ["term", "unknown", "instance", "human", "currency", "title", "attribute", "platform", "character", "email", "component", "sword", "status", "minimum", "software", "wordpress", "url", "approximately", "json", "description", "utm", "method", "aka", "uno", "token", "rue", "uri", "NAME", "summary", "name", "ername", "batch", "impact", "phone", "output", "password", "prefix", "monitor", "person", "via", "latest", "dn", "mass", "subject", "seat", "ame", "journal", "mobile", "uid", "directory", "localhost", "twitter", "target", "gender", "information", "history", "owner", "pron", "database", "account", "metadata", "master", "sudo", "frequency", "month", "login", "initial", "filename", "river", "number", "kin", "family", "today", "href", "java", "source", "utf", "language", "profile", "displayText", "successful", "usr", "network"], "ph": ["ch", "uph", "rh", "mph", "phi", "uth", "pha", "fo", "pkg", " pl", "phil", "oth", "prot", "gh", "arch", "pal", "hm", "wh", "p", "alph", "eph", "PH", "h", "ih", "pl", "pr", "pas", "oh", "iph", "th", "pt", "phy", "eh", "hp", "dh", "ah", "Ph", "kh", "aph", " ep", "sh", "prof", "ht", "mk", "tch", "pd", " perf", "pi", "php", "her", "pp", "eth"], "realms": ["rems", "tenarms", "alents", "realmins", "trarms", "alarms", "rem", "trmins", "alm", "realarms", "Realarms", "tenmes", "rearms", "realmes", "almes", "rens", "Realmes", "Realms", "Realmins", "Realents", "Realm", "realents", "alms", "tenms", "tenents", "remes", "trms", "realns", "remins", "trns", "Realns"], "realmName": ["realmcNames", "realrId", "almName", "realarmFull", " realmNames", "realmoId", " realcType", "realmSpec", "realmcType", "realmoSpec", "alrName", " realmType", " realmFull", " realcNames", "realcName", "realmcFull", "almSpec", "realrNames", "realrName", "realarmName", " realcName", "realrSpec", " realcFull", "realcNames", "realmcName", "realmId", "realmFull", "realcType", "realmiSpec", "realmiName", "realarmType", "realarmNames", "alrNames", "realmoNames", "realmiNames", "almId", "realmNames", "realcFull", "realmiId", "almNames", "realmType", "realmoName", "alrId", "alrSpec"], "psImpl": ["dsImpl", "pseImpl", "pseStr", "psInstance", "persStr", "dsimpl", "psStr", "persimpl", "dsInstance", "pseimpl", "psimpl", "pseInstance", "persInstance", "dsStr", "persImpl"], "iterator": ["collection", "runner", "history", "ator", "instance", "loader", "integer", "size", "current", "wrapper", "operator", "inner", "next", "stream", "ter", "vector", "sequence", "Iterator", "values", "result", "set", "walker", "trace", "order", "information"]}}
{"id1": "18891988", "id2": "3801655", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"getFile": ["selectfile", "getFilename", "createFilename", "GetFile", "selectFilename", "createString", "GetString", "createFile", "getfile", "createfile", "GetFilename", "getString", "selectFile", "Getfile", "selectString"], "serviceName": [" serviceCode", "libraryName", "ServiceFamily", "libraryType", "serverCode", "ServiceType", "serviceType", "serverType", "libraryFamily", "serviceCode", "serviceNames", "ServiceName", " serviceFamily", "ServiceNames", "ServiceCode", "libraryNames", "serviceFamily", "serverName", " serviceType", " serviceNames"], "wsdlLocation": ["wslLocation", "wlLoc", "awsdlURL", "wslLoc", "wssdFolder", "wslFolder", "wssdlocation", "awsdlocation", "wsdLoc", "wsDLlocation", "wsdllocation", "wsDLPath", "wsdlURL", "wsdLocation", "wsDLLoc", "wsDLFolder", "wsollocation", "wlFolder", "awsdllocation", "wsdURL", "wdlLocation", "wlPath", "wsolLoc", "awsdlLocation", "awsdlLoc", "wsolLocation", "wsDLURL", "wssdPath", "wssdLocation", "awsolLocation", "wsdlPath", "wsdlocation", "wsDLLocation", "wsdlFolder", "awsdURL", "wdlLoc", "awsolURL", "awsdLocation", "awsollocation", "wdlFolder", "wdlPath", "wlLocation", "wslPath", "wsdlLoc", "awsdLoc", "wssdLoc", "wsolURL", "wssdURL", "awsolLoc"], "endpoint": ["endword", "bindport", "startPoint", "idpoints", "bindpoints", "bindpoint", "endPoint", "Endpoint", "startpoints", "beginPoint", " endpoints", "beginword", "bindPoint", " endline", "idPoint", " endport", "Endpoints", "EndPoint", "beginpoint", "startword", "Endport", "startpoint", "idpoint", "Endword", "startline", "endport", "endline", " endPoint", "endpoints", "beginpoints", "idline"], "fileLocation": ["FileLoc", "Filelocation", "FileLocation", "fileLoc", "filePosition", " fileLoc", " filelocation", "documentLoc", " filePosition", "documentPosition", "filelocation", "FilePosition", "documentLocation", "documentlocation"], "tempDir": ["tmpUrl", "TempUrl", "TempPath", "TempDir", "tempDirectory", "tmpDirectory", "tmpdir", "tmpPath", " tempFolder", "tmpFolder", "tempPath", " tempdir", " tempUrl", "tempFolder", "TempDirectory", "TempFolder", " tempDirectory", "tmpDir", "tempUrl", "Tempdir", " tempPath", "tempdir"], "url": ["http", "mail", "ls", "window", "location", "sl", "open", "ret", "build", "bel", "link", "ur", "ul", "Url", "f", "socket", "URL", "rel", "sur", "pl", "re", "ssl", "uri", "dl", "loc", "nl", "up", "browser", "gl", "cr", "str", "mount", "ll", "cp", "service", "l", "char", "un", "conn", "base", "m", "job", "ctrl", "web", "https", "cert", "r", "li", "github", "il"], "WSDLFile": ["WSDLLFilename", "WSDLString", "WSDQLFile", "WIDDLString", "WHDLfile", "WIDDLType", "WSDDLString", "WIDLFile", "WHDDLFile", "WSDDLFILE", "WNDLFILE", "WSDDLType", "WHDDLfile", "WSDLLString", "WSDLLFILE", "WIDDLFile", "WNDLFile", "WSDDLFile", "WNDDLfile", "WSDLLType", "WHDDLFILE", "WSDELfile", "WSDLSFile", "WNDLFilename", "WIDLType", "WIDLString", "WSDQLfile", "WIDLfile", "WNDDLFILE", "WSDLLfile", "WSDMLfile", "WSDQLFILE", "WSDMLFILE", "WSDLLFile", "WSDMLFile", "WSDELFILE", "WNDLfile", "WSDLSType", "WSDLSString", "WSDLFILE", "WSDLType", "WSDLSfile", "WSDDLfile", "WHDLFILE", "WSDLFilename", "WSDLfile", "WSDELFile", "WNDDLFilename", "WSDDLFilename", "WHDLFile", "WIDDLfile", "WNDDLFile", "WSDELFilename"], "tmpWSDLFile": ["tmpWSDDLFiles", "tmpWSDlFile", "tmpWSDLDFilename", "tmpWIDDLFILE", "tmpWNDDLFilename", "tmpWSDLDFILE", "tmpWIDDLfile", "tmpWSDLLFilename", "tmpWSDLLFiles", "tmpWNDDLfile", "tmpWNDDLFiles", "tmpWSDlFiles", "tmpWSDlfile", "tmpWSDLFiles", "tmpWNDDLFile", "tmpWNDLFile", "tmpWSDlFilename", "tmpWIDDLFilename", "tmpWSDLLFILE", "tmpWNDLFiles", "tmpWSDLDFile", "tmpWSDDLFILE", "tmpWSDLDfile", "tmpWIDLfile", "tmpWSDLLfile", "tmpWIDDLFile", "tmpWSDLFilename", "tmpWSDDLFilename", "tmpWIDLFILE", "tmpWSDDLFile", "tmpWNDLFilename", "tmpWIDLFilename", "tmpWNDLfile", "tmpWSDLLFile", "tmpWIDLFile", "tmpWSDLFILE", "tmpWSDLfile", "tmpWSDDLfile"], "inputFile": ["inputPlace", "InputStream", "inputPath", "indexFILE", "indexStream", "intFiles", "inputSourceFile", "tmpFILE", "inputFILE", "outputFILE", "clientPath", "outputFile", "clientFiles", " inputfile", "indexfile", "errorFile", "tmpSourceFile", " inputPlace", "interfacePlace", "errorfile", "outputfile", "Inputfile", " inputFILE", "inputStream", "interfaceSourceFile", "InputFiles", "tmpStream", "clientFile", "intFILE", "inputFiles", "infile", "inputDo", "clientFILE", " inputFiles", "intfile", "errorFILE", " inputDo", "intFile", "tmpPlace", "inDo", "indexFile", "inFile", "interfaceFile", "inPath", " inputPath", "InputFile", "interfacefile", "tmpfile", " inputSourceFile", "InputPath", "InputDo", "errorStream", "InputFILE", "outputStream", "inputfile"], "tmpFile": ["tmpFILE", "inputFILE", "empFilename", "tmpFiles", "mpFile", " tmpPath", "empFILE", "mpfile", " tmpfile", "tmpPath", "tempFiles", "tempFILE", "tempPath", "mpFiles", "inputFilename", "empFile", "mpPath", "tempFile", "tempFilename", " tmpFiles", "empfile", "tmpFilename", "tmpfile", "tempfile", "inputfile"], "in": ["ch", "IN", "din", "init", "ln", "n", "it", "rin", "ri", "ai", "is", "ic", "ini", "sin", "ain", "id", "o", "inv", "en", "inc", "io", "from", "mi", "ind", "ins", "t", "client", "ar", "bin", "inner", "stream", "isin", "r", "In", "cont", "conn", "input", "source", "file", "inn", "inf", "c", "cin"], "out": ["output", "ch", "buffer", "on", "by", "n", "auto", "Out", "sys", "tmp", "connection", "can", "pool", "o", "inv", "to", "os", "en", "aos", "io", "OU", "ex", "outs", "t", "client", "conv", "ou", "lock", "cm", "all", "write", "at", "null", "group", "writer", "this", "ao", "w", "obj", "net", "conn", "OUT", "conf", "ne", "file", "log", "oss", "co", "we", "outer", "c", "cache"], "con": ["ch", "fn", "nc", "cos", "connect", "Con", "cone", "const", "cur", "ln", "cal", "exc", "mc", "connection", "acon", "ain", "can", "ws", "num", "re", "conv", "login", "win", "fc", "cm", "tc", "cp", "cons", "sec", "un", "conn", "cn", "CON", "ran", "func", "co", "cf", "com", "conf", "soc", "Conn", "c", "cin"], "fileLength": ["objectSize", "objectFontSize", "channelSize", "objectDuration", "FILESize", "channelLength", "ileLen", "FILELength", "fileDuration", "ileLength", " fileDuration", "fileSize", "FILEDuration", " fileLen", " fileSize", "FILELen", " fileFontSize", "fileLen", "ileDuration", "channelDuration", "fileFontSize", "channelFontSize", "ileSize", "objectLength"], "channelIn": ["channelIN", "chanIn", "consoleIn", "ChannelIn", "clientSet", "channelSet", "Channelin", "consoleedIn", "clientIn", "clientOut", "ChannelIN", "ChannelSet", " channeledIn", "ChanneledIn", "channeledIn", "ChannelOut", "channelin", "consoleOut", "consoleIN", "chanSet", "clientin", "chanIN", "chanOut", "clientIN", " channelIN", " channelin"], "channelOut": ["chanIn", "consoleIn", "ChannelIn", "channelOUT", " channelConn", "ChannelConn", "courseout", "courseOut", "courseOUT", "courseIn", "chanout", "chanConn", "ChannelOut", "consoleOUT", "channelout", "Channelout", "consoleout", "consoleOut", "chanOut", " channelout", "channelConn", " channelOUT", "ChannelOUT"], "tmpDocument": ["tmpDoc", "tpFile", "npDocument", "mkdocument", "npFile", " tmpDocuments", "mpDoc", "npMedia", "tpDocument", "tempDoc", "cpDocument", "tmDoc", "tpMedia", " tmpDoc", "tmDocument", " tmpMedia", "tmpDocuments", "cpDoc", "cpdocument", "tempdocument", " tmpdocument", "mpDocument", "mkDocument", "npDocuments", "mkDoc", "tmpdocument", "tpDocuments", "tmpMedia", "tmdocument", "mpdocument", "tempDocument"], "nl1": ["ln01", "rn6", "NL0", "pelOne", "sol0", "sol1", "nl01", "sol2", "nrOne", "nelOne", "rn3", "nl2", "ln2", "nl3", "pel1", "nel1", "lnOne", "ln6", "nel3", "nl6", "nlOne", "nr1", "sol9", "nr01", "ln3", "nel6", "nl0", "rn1", "pel01", "NL2", "nl9", "ln0", "ln9", "NL1", "ln1", "NL9", "rnOne"], "i": ["multi", "ims", "ms", "x", "j", "n", "init", "it", "ai", "a", "is", "ic", "ini", "ui", "ie", "me", "ri", "id", "y", "o", "io", "mi", "ci", "qi", "ii", "v", "gi", "hi", "key", "ti", "bi", "ji", "index", "si", "I", "span", "u", "k", "m", "xi", "cli", "us", "mu", "ami", "ori", "di", "sim", "pi", "info", "ij", "ip", "li", "\u0438", "ix"], "node1": ["Node2", "ode001", "nOne", "node91", "ode2", "component0", "node001", "NodeOne", "component2", "Node1", "layer91", "layer0", " node2", "layerOne", "ode1", "ode0", " node91", "node0", "Node001", " node0", " node001", "componentOne", " nodeOne", "layer1", "n1", "n0", "nodeOne", "node2", "n91", "Node0", "component1"], "tmpOut": ["tmpObj", " tmpIs", "tmpIs", "mpOut", "empIs", "mpout", "TempOUT", "npIn", "mpObj", "cmpIn", "cmpout", "TempIn", "tmpOUT", " tmpObj", "tempout", " tmpIn", "empout", "npout", "mpIn", " tmpOUT", "cmpOut", "TempObj", "tmpout", "tempObj", "tmpIn", "npObj", "tempIn", "tempOUT", "tempIs", "TempOut", "tempOut", "empOut", " tmpout", "npOut"], "retVal": ["retValue", "returnVal", "returnValue", "returnTrue", "returnval", "retval", "RetTrue", "RetValue", "Retval", "retTrue", " retValue", " retval", " retTrue", "RetVal"]}}
{"id1": "5744493", "id2": "23452437", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doPageMove", " synchronizedFullDownload", " synchronizedFileMove", " doFileMove", " synchronizedFullMove", " doFullMove", " doPageCopy", " doFullDownload", " doFileDownload", " doFileCopy", " synchronizedFileCopy", " doStreamCopy", " doStreamMove", " synchronizedFullCopy", " doPageDownload", " synchronizedFileDownload", " doFullCopy", " doStreamDownload"], "in": ["IN", "din", "gin", "or", "init", "n", "it", "rin", "ic", "b", "ck", "old", "ain", "as", "o", "en", "inc", "from", "mm", "ind", "ex", "ins", "el", "up", "ac", "isin", "l", "In", "input", "source", "file", "i", "inn", "r", " input", "inf", "cin"], "out": ["output", "ch", "n", "Out", "it", "p", "as", "o", "to", "os", "io", "help", "ex", "outs", "t", "op", "up", "v", "serv", "ou", "nt", "at", "write", "null", "w", "l", "net", "OUT", "check", "gt", "ne", "file", "log", "po", "ot", "s", "res", "c"], "inChannel": ["inCh", " inCommand", "vinConnection", "outCh", " inButton", "dinButton", "inConnection", " inConnection", "dinCommand", "vinChannel", "cinChannel", "INStream", "isinChan", "innCategory", "inchannel", "InChannel", "inCategory", "innCommand", "INChannel", " inchannel", "vinCommand", "inChan", "innerchannel", "innerChan", "Inchannel", "cinCategory", " inChan", "InCh", "outchannel", "dinChan", "innButton", "inStream", "inCommand", "INChan", " inCh", "isinConnection", "dinCase", "innerStream", "cinButton", "isinChannel", "isinButton", "vinCase", "innChannel", "outChan", "inCase", "cinCommand", "dinConnection", "dinChannel", " inCategory", "outStream", "InChan", " inCase", "inButton", "INchannel", "innerChannel"], "outChannel": ["upMachine", "outCh", " outRoom", "OutChan", " outCh", "outMachine", "OutChannel", "newChannel", " outStream", " outchannel", "inChan", "aosSection", "OutCh", "aosDisk", "aosChannel", "OutStream", "newConnection", "outchannel", "upSection", "cosMachine", "outDisk", " outConnection", "outerRoom", "inStream", "upChannel", "upDisk", "newchannel", "cosChannel", "onChannel", "outRoom", "outputChan", "outerChannel", " outChan", "outChan", "onConnection", "cosDisk", "aosMachine", "outputChannel", "onChan", "outConnection", "outerStream", "outSection", "newChan", "outStream", "outputStream", "outputCh", "cosSection", "inRoom", "onchannel", "outerChan"], "maxCount": ["maxFlag", "maxSize", " maxSize", "MAXLength", " maxLength", "maxLength", "minLength", "maxCast", "MaxLength", "MaxCount", "minCount", " maxCast", "minSize", "MaxSize", "minFlag", "MAXCount", "MAXFlag", " maxFlag", "minCast", "MaxCast"], "size": ["equal", "message", "Size", "fee", "shape", "ms", "notice", "close", "space", "resolution", "sd", "gets", "is", "ze", "shift", "small", "count", "send", "body", "export", "duration", "area", "ize", "sample", "read", "sent", "total", "length", "len", "write", "any", "name", "readable", "si", "bytes", "scale", "position", "sum", "keys", "SIZE", "south", "speed", "m", "capacity", "set", "ose", "range", "show", "scroll", "empty", "height", "start", "score", "seek"], "pos": ["cos", "pointer", "part", "offset", "slot", "x", "n", "it", "pg", "p", "no", "Position", "rel", "o", "to", "os", "coord", "row", "pl", "pid", "pr", "pro", "seq", "loc", "pose", "pt", "spec", "ps", "resp", "length", "Pos", "pass", "POS", "doc", "index", "position", "l", "page", "pc", "limit", "point", "def", "port", "zero", "po", "i", "sp", "pi", "off", "exp", "start", "left", "len"]}}
{"id1": "7143591", "id2": "11334468", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getUrlByString", "getWebFromURL", "getWebFromString", "getWebbyUrl", "getUrlByURL", "getUrlbyString", "getWebFromUrl", "getUrlbyurl", "getUrlByUrl", "getWebFromurl", "getWebByurl", "getUrlbyUrl", "getWebbyurl", "getWebbyString", "getUrlByurl", "getUrlbyURL", "getWebByString", "getWebByURL", "getWebbyURL"], "strUrl": ["strurl", " strurl", "drDb", "txtGl", "stringUr", "txtURL", "drurl", "StrStr", "strStr", "drURL", " strStr", "arrEmail", "strUr", "insturl", "nameStr", "STRUrl", "STRUr", "nameurl", "instURL", "txtUrl", "volUrl", "stringURL", " strDb", "stUrl", "nameUr", "nameURL", "stDb", " strURL", "instUrl", " strGl", " strUr", "stUr", "arrUr", "arrURL", "txtStr", "strGl", "strURL", "stringUrl", "STRURL", "nameEmail", "StrUr", "StrURL", "drUrl", "StrUrl", "arrStr", "stURL", "volStr", "Strurl", "sturl", "drUr", "STRStr", "StrGl", "nameUrl", "arrurl", "arrUrl", "volURL", "instUr", "volUr", "nameDb", "STREmail", "strDb", "stringDb", "strEmail"], "charset": ["ChARSET", "charsET", "chorsets", "Charsec", "charsets", "chARSec", "chorsET", "charsec", "ChARSet", "chARSet", "chorsec", "CharsET", "ChARSets", "Charsets", "ChARSec", "Charset", "chorset", "chARSET", "chARSets"], "fileIndex": ["stringPath", "byteIndex", "ileIndex", "ileNum", " fileNum", "filePos", "stringPos", "ileindex", "byteInd", " fileInd", "fileindex", "ileInd", " filePos", "byteNum", "bytePos", "byteindex", "fileNum", "stringIndex", "bytePath", "fileInd", " fileindex", "stringindex"], "url": ["http", "con", "ls", "sl", "open", "ret", "build", "bel", "link", "ur", "connection", "Url", "f", "ul", "socket", "URL", "rel", "bl", "ssl", "uri", "dl", "nl", "client", "resource", "browser", "gl", "g", "str", "name", "ll", "cp", "get", "l", "obj", "www", "net", "rl", "https", "web", "cert", "cmd", "r", "hl", "il"], "conn": ["ch", "nec", "nc", "connect", "Con", "con", "Connection", "addr", "access", "ln", "open", "sys", "connection", "pg", "socket", "iw", "ws", "enc", "ens", "en", "conv", "pas", "nt", "ctr", "cp", "cb", "nw", "comm", "l", "obj", "net", "ctx", "cn", "oss", "cmd", "handle", "act", "ca", "Conn", "c"], "is": ["ist", "http", "ists", "im", "ms", "ls", "isc", "or", "es", "ais", "iso", "ris", "it", "ri", "sys", "isl", "ip", "has", "nis", "bis", "bs", "id", "isa", "as", "its", "ws", "os", "iss", "are", "ins", "bits", "rs", "serv", "js", "isf", "ib", "si", "Is", "ir", "fs", "iris", "iter", "us", "isi", "i", "info", "ios", "s", "in", "res", "out", "was", "lis", "IS"], "filePath": ["familyPATH", "FileSystem", "filepath", "ioSystem", " filepath", "FileName", " fileSystem", "FilePATH", "FileFile", "familySystem", "fSystem", "fFile", "fileFile", "FilePath", "ioFile", "fileName", "fName", "ioName", "familypath", "filePATH", " filePATH", "fileSystem", "fPath", "Filepath", "ioPath", "familyPath"], "pw": [" pwr", "jwd", "wpwt", "pv", "fws", "fW", " pws", "apwb", "pwh", "pwt", "wpwe", "pwe", "apw", " pv", "PW", "cpw", "pwp", "pws", "npv", "npwp", "jW", "Pwd", "npwe", "apwh", "mwd", "pW", "mwh", "jw", "wpv", "npwt", "apwd", "npwr", " pwp", " pwt", "Pw", "npwd", "mwb", "Pws", "cpwp", "cpwr", "pwb", " pW", "pwr", "fwd", "fw", "pwd", "mw", " pwh", "wpw", " pwe", " pwb", "cpwd", "Pwb", " pwd", "npw", "jwb"], "fos": ["bo", " fOS", "bOs", " fo", "fo", "wOs", " foses", " fOs", "bos", "fOS", "eOs", "eOS", "flo", "flos", "eoss", "fOs", "boses", "floses", " foss", "flOs", "foses", "foss", "woss", "wOS", "wos", "eos"], "writer": ["output", "buffer", "wr", "ser", "builder", "rew", "usher", "window", "aver", "member", "worker", "author", "wrote", "riter", "master", "console", "writing", "wp", "writ", "desc", "liner", "rw", "wright", "nt", "aster", "write", "reader", "written", "handler", "nw", "w", "println", "wb", "player", "ter", "wn", "Writer", "walker", "width", "fw", "woman", "out", "widget", "editor"], "bReader": ["aReader", "bcBuffer", "rbReader", "bWriter", " bBuffer", " bRead", "rbR", " bWriter", "aRead", "bcReader", "bhBuffer", "bRead", " bClient", " bR", "bcClient", "bBuffer", "rbRead", "aR", "bR", "rbWriter", "bhReader", "bClient", "aWriter", "bhClient"], "sb": ["bf", "nb", "SB", "CB", "bd", "b", "lb", "bis", "bs", "lp", "kb", "bsp", "sw", "bb", "sa", "erb", "ssl", "bt", "eb", "bg", "pb", "ib", "zb", "cb", "mb", "gb", "wb", "sth", "sg", "bj", "rob", "bh", "sp", "sv", "stab", "sf", "sq", "rb"], "rLine": ["rrLe", "brL", "rLe", "srFrame", "lRow", "rrChan", "lLink", "bline", "rrEl", "rRow", "srLine", " rline", "rFrame", "bLink", "srEl", "bLine", "rL", "bRow", "brLine", " rEl", " rRow", " rLe", "rline", "brFrame", "lLine", "rrLine", " rChan", "rEl", "brRow", "srLe", " rL", "rLink", "srL", "srChan", " rFrame", " rLink", "rChan", "srRow", "lline"], "tmp_rLine": ["tmp_rVal", "tmp_rnLine", "tmp_rChain", "tmp_drline", "tmp_rObj", "tmp_nSet", "tmp_RSet", "tmp_nrRow", "tmp_rgRule", "tmp_RChain", "tmp_lLine", "tmp_nLine", "tmp_rSet", "tmp_lRecord", "tmp_nrVal", "tmp_RL", "tmp_RLine", "tmp_RVal", "tmp_nL", "tmp_pL", "tmp_bline", "tmp_hLine", "tmp_pBlock", "tmp_pSet", "tmp_rgOrig", "tmp_bLine", "tmp_rL", "tmp_lline", "tmp_eObj", "tmp_drRow", "tmp_Rline", "tmp_hOrig", "tmp_RRecord", "tmp_lRow", "tmp_cObj", "tmp_pRow", "tmp_cLine", "tmp_rnOrig", "tmp_rgLine", "tmp_eRow", "tmp_lChain", "tmp_RBlock", "tmp_rnRule", "tmp_bRow", "tmp_drLin", "tmp_nrLine", "tmp_rRow", "tmp_hRule", "tmp_nrChain", "tmp_rline", "tmp_rRule", "tmp_rLin", "tmp_lObj", "tmp_nBlock", "tmp_hLin", "tmp_eRecord", "tmp_rnLin", "tmp_cline", "tmp_pLine", "tmp_drLine", "tmp_RRow", "tmp_cRow", "tmp_rBlock", "tmp_pLin", "tmp_rgLin", "tmp_eline", "tmp_rOrig", "tmp_bLin", "tmp_pline", "tmp_lVal", "tmp_rRecord", "tmp_eLine"], "str_len": ["str2ll", "string_vec", " str_Len", "str3ls", "string_length", "str_ls", "str2Len", "str_Len", "string3len", "str__ls", "str3vec", "str2ls", " str_ll", "str3length", " str2len", "str3len", " str2Len", " str2ll", "string3ls", "str_ll", "str__len", " str2ls", "string_len", "str__Len", "string3length", "str_vec", " str_ls", "string3vec", "str2len", "str_length", "str__ll", "string_ls"]}}
{"id1": "20675046", "id2": "13159394", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["GetBody", "setContent", "getContents", " getText", " getBody", "GetContents", "getText", "getBody", "setText", "GetText", "setBody", "setContents", "GetContent", " getContents"], "context": ["output", "message", "application", "text", "TEXT", "template", "config", "type", "processor", "state", "parser", "channel", "resource", "content", "component", "event", "command", "base", "input", "object", "ctx", "tx", "value", "Context", "chain", "document", "data", "network"], "ctxAttrName": ["ctxAttrKey", "ctxAddrname", "ctxAttrsName", "ctxAttrsValue", "ctxAttribKey", "ctxAddmname", "ctxAttribName", "ctxAddrValue", "ctxAttribValue", "ctxAttrname", "ctxAttrsKey", "ctxAttmName", "ctxAttmKey", "ctxAddrName", "ctxAddrKey", "ctxAddmValue", "ctxAttmValue", "ctxAddmKey", "ctxAttribname", "ctxAttmname", "ctxAddmName", "ctxAttrsname"], "ctxAttrValue": ["ctxAttrbvalue", "ctxAttmType", "ctxAttrdName", "ctxAttrType", "ctxAddrvalue", "ctxDetrVal", "ctxAttrdValue", "ctxAddrElement", "ctxAddrValue", "ctxAddrbName", "ctxAttribValue", "ctxAttribData", "ctxAttrbValue", "ctxAttrdvalue", "ctxAttuData", "ctxAttmName", "ctxAttmVal", "ctxAttrVal", "ctxAttmData", "ctxAttrbName", "ctxDetribType", "ctxAddrbvalue", "ctxAttribVal", "ctxAttrbElement", "ctxAddrName", "ctxDetribValue", "ctxAddrbElement", "ctxAttmvalue", "ctxAttuType", "ctxAttrData", "ctxAttribType", "ctxDetrData", "ctxAttmValue", "ctxAttrElement", "ctxAddrbValue", "ctxDetrType", "ctxDetribVal", "ctxAttmElement", "ctxAttuValue", "ctxDetrValue", "ctxDetribData", "ctxAttrdElement", "ctxAttrvalue", "ctxAttuVal"], "url": ["path", "http", "ls", "location", "sl", "build", "link", "ur", "b", "Url", "ul", "address", "URL", "rel", "io", "ssl", "uri", "dl", "loc", "nl", "resource", "el", "client", "browser", "ref", "null", "name", "mount", "str", "ll", "external", "service", "l", "char", "base", "lr", "rl", "file", "log", "sb", "web", "cert", "handle", "hl"], "reader": ["buffer", "runner", "builder", "per", "shape", "ator", "rar", "volume", "open", "peer", "ri", "user", "handle", "rx", "loader", "parser", "read", "row", "iterator", "test", "io", "sample", "older", "er", "uri", "READ", "resource", "length", "inner", "writer", "readable", "reading", "handler", "dd", "stream", "rot", "rr", "upper", "Reader", "check", "input", "source", "iter", "rl", "file", "driver", "ro", "info", "data", "r", "dra", "image"], "available": ["played", "buffer", "missing", "loaded", "added", "valid", "enough", "visible", "released", "supported", "Available", "used", "installed", "count", "free", "acity", "usage", "can", "alloc", "no", "read", "locked", "checked", "bound", "produced", "num", "end", "ed", "enabled", "created", "current", "total", "needed", "ready", "length", "release", "all", "ap", "readable", "required", "written", "opened", "index", "position", "bytes", "good", "ocated", " unavailable", "capacity", "selected", "availability", "active", "max", "i", "sp", "usable", "provided", "full", "out", "allowed", "len"], "contents": ["CONTacts", "contented", "contContents", "Content", "CONTented", "Contents", "Contours", "mintented", " contentials", "contours", "mintents", " contours", "CONTars", "requentials", " contacts", "Contented", "Contentials", "CONTents", "mintars", "requents", "ContContents", "requries", " contries", "Contries", "content", "requours", "Contacts", " contContents", "CONTent", "Contars", "contars", "contentials", " content", "mintent", "contacts", "contries", "CONTContents"]}}
{"id1": "13439950", "id2": "18238468", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["readLocalFile", "downloadStaticFile", "readRemoteRemote", "readremoteRemote", "readremoteFrom", "downloadRemoteFrom", "downloadStaticRemote", "readStaticFrom", "readremoteFile", "downloadStaticFilename", "readremoteFilename", "downloadStaticFrom", "readStaticFile", "readLocalRemote", "readRemoteFrom", "readLocalFilename", "readLocalFrom", "downloadRemoteRemote", "readStaticFilename", "readRemoteFilename", "readStaticRemote", "downloadRemoteFilename", "downloadRemoteFile"], "response": ["output", "message", "application", "json", "description", "block", "resolution", "onse", "example", "connection", "secret", "address", "body", "send", "reset", "sample", "relation", "answer", "resp", "server", "continue", "summary", "settings", "request", "version", "next", "view", "str", "service", "respons", "vector", "Response", "result", "sequence", "line", "command", "print", "string", "source", "status", "value", "reply", "data", "format", "res", "image", "report", "cache", "network"], "url": ["http", "mail", "abs", "sl", "ret", "build", "bel", "link", "ur", "lb", "Url", "b", "ul", "URL", "rel", "pl", "ssl", "dl", "uri", "nl", "loc", "resource", "el", "browser", "gl", "ref", "name", "mount", "str", "ll", "fl", "l", "char", "base", "lr", "rl", "https", "web", "cmd", "r", "hl"], "is": ["ists", "ais", "ms", "es", "isc", "ates", "iso", "ris", "it", "sels", "ri", "ic", "sys", "isl", "nis", "lis", "bis", "bs", "isa", "as", "its", "iss", "os", "does", " Is", "ins", "rs", "serv", "isf", "\u00eds", "Is", "ir", "fs", "iris", "i", "ios", "sis", "in", "ip", "isi", "IS"], "br": ["wr", "gr", "dr", "bf", "shr", "buf", "bd", "b", "bp", "ver", "bm", "bs", "BR", "rel", "bn", "bl", "hr", "pr", "nr", "fr", "bt", "browser", "Br", "cr", "bro", "be", "bi", "str", "vr", "mr", "tr", "bridge", "bc", "lr", "rob", "adr", "ro", "bh", "sp", "jp", "ber", "res", "r", "repl", "rb"], "s": ["series", "strings", "ms", "es", "ls", "stats", "j", "n", "se", "a", "gets", "b", "sq", "gs", "bs", " gets", "ss", "p", "y", "its", "h", "os", "o", "qs", "sample", "ins", "t", "sym", "ps", "rs", "v", "js", "e", "ns", "less", "sports", "g", "str", "sts", "ats", "still", "w", "sql", "l", "r", "txt", "ves", "sn", "string", "m", "value", "csv", "z", "i", "sb", "tes", " ts", " samples", " inputs", "sv", "res", "ts", "S", "ies", "single"], "eof": ["eeol", "eeef", "eow", " eol", "seof", "Eov", "eov", "eot", "ef", " eow", "Eomp", "seef", "Eol", "eeif", " eef", " eos", "Eof", "eeow", "eef", " eomp", "eeot", " eot", "geif", "eeov", "EOf", " eOF", "eOf", "sef", "eOF", "eeOf", "eif", "eeOF", "Eef", " ef", "eomp", " eif", "seot", " eov", "eeos", "geow", "eeomp", "geOF", " eOf", "geof", "eeof", "eol", "Eos", "eos"]}}
{"id1": "1357662", "id2": "539195", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["CopFileTo", "copyfileTO", "copyfileFrom", "copyToFrom", "CopFileTO", "copyDirectoryFrom", "copyToFile", "copyToTO", "CopDirectoryTO", "copyFileFrom", "copyFileTO", "CopDirectoryFrom", "CopDirectoryFile", "copyDirectoryTO", "copyfileFile", "copyDirectoryTo", "CopDirectoryTo", "copyDirectoryFile", "CopFileFrom", "copyFileFile", "CopFileFile", "copyfileTo", "copyToTo"], "destination": ["destinity", "delification", "Destination", "destinator", "disturation", "catification", " destinated", "restination", "descinated", "distification", "domination", "delination", "dominated", "dominations", "deluration", "descinate", "Destinate", " destinator", "distinate", " destinity", "catinate", "estination", "Destinated", "distinity", "descification", "restification", "descination", "catination", "dominator", "destification", "desturation", " destification", " destinations", "delinity", "restinate", "estinated", "destinate", "destinated", " desturation", "estinator", "restinated", "destinations", "estinations", "distinated", "Destification", " destinate", "distination", "catinated"], "srcChannel": [" srcchannel", " srcCase", "srcChan", "srcStream", "srcCase", "sinChain", "rcConnection", "sourceChan", "srcchannel", "sinChannel", " srcCh", " srcConnection", "rcStream", "insChannel", "sysConnection", " srcChan", "sourcechannel", "srCase", "insCh", "sourceCh", "rcChannel", "insChain", "insChan", "srChannel", "srChain", "rcCh", "sourceChannel", "rcchannel", "rcChain", "sysChan", "sysStream", "rcChan", "srcConnection", "sinChan", "srcCh", " srcStream", "srcChain", "srChan", " srcChain", "sysChannel", "sinCase", "sourceConnection"], "destChannel": ["srcC", " destCategory", "srcChan", " destCh", "destCan", "srcchannel", "destChan", "destC", "Destchannel", "homechannel", "DestConnection", "certCh", "destConnection", "DestCh", "DestCategory", "destCategory", " destChan", "homeChan", "etcChan", "certChannel", "destchannel", "homeCategory", "destCh", "DestChan", "etcChannel", " destchannel", "certCan", "srcConnection", "homeChannel", "etcConnection", " destCan", "DestChannel", " destConnection", "certConnection", " destC", "DestCan", "etcC"]}}
{"id1": "16388708", "id2": "19912848", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeString2String", "decodeFileToString", "decodeString2file", "decodeStringToFiles", "decodeFileFileFiles", "decodeString2File", "decodeFileFilefile", "decodeFileAsfile", "decodeFile2File", "decodeFile2file", "decodeFileTofile", "decodeFileAsFiles", "decodeFileAsString", "decodeFileToFiles", "decodeString2Files", "decodeFileAsFile", "decodeStringToString", "decodeStringTofile", "decodeFileFileString", "decodeStringToFile", "decodeFile2Files", "decodeFileFileFile"], "infile": ["outname", "outfolder", "fromfile", "infolder", "isinname", "frombase", "infilename", "fromfilename", "InFile", "inputfolder", "Infile", "isinfile", "fromFile", "isinfolder", "Inbase", "outfilename", "outbase", "inputname", "inputFile", "inname", "inFile", "isinFile", "inbase", "outFile", "Infilename", "inputfile"], "outfile": ["Outfile", "tofilename", "outname", " outname", " outFile", "outdir", "todir", "infilename", "OutFile", "Outdir", "tofile", "otname", "otFile", "otfile", "outfilename", "toFile", "inname", "otFILE", "inFILE", "indir", "inFile", "Outfilename", "outFile", "outFILE", " outFILE"], "in": ["IN", "on", "per", "din", "gin", "con", "im", "or", "by", "init", "it", "oin", "rin", "ini", "is", "ain", "id", "pin", "en", "inc", "from", "re", "nin", "ind", "al", "ins", "t", "ar", "up", "bin", "inner", "get", "isin", "In", "form", "conn", "input", "source", "iter", "amin", "i", "info", " din", "inn", "inside", "inf", "cin"], "out": ["output", "fn", "on", "ion", "con", "n", "auto", "Out", "it", "sys", "b", "flush", "can", "opt", "o", "aos", "to", "os", "en", "end", "io", "OU", "ex", "outs", "t", "ou", "nt", "at", "write", "g", "inner", "null", "writer", "net", "print", "OUT", "gt", "ne", "cn", "file", "oss", "ot", "co", "res", "outer"], "buffer": ["message", "Buffer", "binary", "history", "shape", "black", "window", "password", "block", "phrase", "buf", "template", "button", "header", "available", "bar", "attribute", "variable", "character", "sample", "row", "frame", "note", "bone", "initial", "total", "buff", "library", "view", "number", "sequence", "print", "command", "batch", "base", "mem", "padding", "table", "comment", "stack", "document", "info", "pad", "memory", "display", "paste", "append", "column", "temp", "cache"], "read": ["each", "load", "connect", "text", "add", "close", "first", "n", "open", "shift", "Read", "hold", "count", "send", "raw", "size", "end", "ok", "ind", "give", "READ", "allow", "ready", "length", "len", "run", "write", " Read", "req", "need", "readable", "reader", "index", "reading", "get", "stream", "before", "print", "check", "input", "set", "wait", "iter", "select", "skip", "range", "i", "find", "through", "query", "start", "push", "reads", "seek"], "success": ["second", "successfully", " okay", "valid", "ceed", " succeed", "support", "response", "town", "condition", "exist", " succeeds", "positive", "complete", "accept", " succ", "growth", "danger", "ok", "crit", "scope", "ccess", "continue", "setup", "ratulations", "summary", "release", "fail", "done", "photo", "sufficient", "error", "cess", " failure", "unity", "snap", "good", "result", "please", "democracy", "submit", "primary", "status", "same", "value", " successful", " successes", "Success", "safe", "surv", "city", "successful", "commit", "first"]}}
{"id1": "5399593", "id2": "237493", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["ecode", "deccode", "enccode", "enrypted", "ecrypt", "encode", "eccode", "decrypted", "enrypt", "decode", "encrypted", "ecrypted", "decrypt", "enode"], "plaintext": ["plainth", " Plaininput", "plainpassword", "preText", " Plaintext", " plaininput", "aintext", "plaincontext", "plaininput", "maintext", "plainText", " plainText", "mainText", "preword", " Plainth", "pretext", "mainword", " plainword", " Plainpassword", " plaincontext", "ainth", "precontext", "maincontext", " plainth", "aininput", "ainpassword", " plainpassword", "plainword"], "UnsupportedEncodingException": ["UnsupportedEncryptionError", "UnsupportedCompoderError", "UnsupportedCompodingException", "UnsupportedEncodedError", "UnsupportedEncoderError", "UnsupportedEncoderEx", "UnsupportedCompodingError", "UnsupportedEncodingError", "UnsupportedCompoderEx", "UnsupportedEncryptionEx", "UnsupportedEncodedException", "UnsupportedEncoderException", "UnsupportedCompoderException", "UnsupportedCompodingEx", "UnsupportedEncryptionException", "UnsupportedEncodingEx", "UnsupportedEncodedEx"], "md": [" dd", "dr", " cmd", "pm", "ms", "nd", "add", "sd", "mc", "bd", "od", "del", "MD", "sha", "grad", "der", "cd", "mg", "mm", "dm", "mt", "ind", "red", "sm", "nt", "det", "ld", "dd", "d", " Md", " mc", "mb", " mm", " m", " mo", "mk", "mp", "mod", " MD", "gm", "pd", "def", "m", "df", "mo", "mn", "mand", "cmd", "med", " ma", "hd", "exec", "ad"], "raw": ["strip", "message", "load", "json", "core", "orig", "unsigned", "n", "buf", "valid", "draw", "des", "available", "known", "bare", "read", "row", "hook", "rendered", "clear", "all", "hex", " Raw", "sh", "serial", "bytes", "RAW", "cooked", "custom", "mem", " RAW", "input", "clean", "data", "full", "empty", "aw", "out", "Raw", "pack", "was"], "hash": ["message", "html", "mask", "password", "Hash", "unknown", "hat", "hed", "has", "sha", "id", "ssh", "ashes", "h", "ASH", "ashed", "total", "tag", "cloth", "component", "code", "hex", "key", "name", "zh", "sh", "dump", "mac", "shadow", "hidden", "sum", "tr", "result", "check", "bh", "search", "height", "proof", "ash"]}}
{"id1": "3958807", "id2": "20128728", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadEmbinaryFile", "loadBignedStream", "loadBbinaryStreamer", "loadBbinaryInput", "loadEmbbinaryStream", "loadBinaryStreamer", "loadBixedInput", "loadEmbinaryStream", "loadEmbbinaryStreamer", "loadEmbinaryStreamer", "loadBbinaryFile", "loadBixedFile", "loadEmbbinaryInput", "loadBignedInput", "loadBignedFile", "loadBbinaryStream", "loadBixedStreamer", "loadBinaryFile", "loadEmbinaryInput", "loadBignedStreamer", "loadBixedStream", "loadBinaryInput", "loadEmbbinaryFile"], "streamName": ["streamHandle", "recordName", " streamNAME", "longName", "resourceName", "recordname", " streamname", "streamNAME", "StreamName", "stringName", "resourceNAME", "stringType", "recordHandle", "fileName", "resourceType", "streamname", "StreamHandle", "recordNAME", "Streamname", " streamType", "streamType", "longPath", "filePath", "longNAME", "StreamNAME", " streamPath", "fileNAME", "stringNAME", "streamPath", " streamHandle"], "streamToLoad": ["streamTORead", " stream2load", "stringToLoad", "stringToload", "streamToUse", " streamToUse", " stream2Use", "streamWillLoad", " streamToRead", "stringToAdd", "streamtoLoad", "streamTOLoad", "streamtoAdd", "streamToAdd", "stringWillAdd", "streamTOUse", "streamWillAdd", " stream2Read", "streamTOAdd", "stringWillload", "stream2load", "stringWillLoad", "streamToload", "stream2Load", "streamTOload", "stream2Read", "streamWillload", "streamToRead", " streamToload", " streamWillLoad", " streamWillload", "stream2Use", "streamtoload", " stream2Load"], "sz": ["insch", "insze", "insz", "rsze", "rsiz", "insiz", "Sz", "rsz", "Siz", " sze", "sze", "Sze", " siz", "sld", " sch", "Sch", "siz", " sld", "sch", "Sld", "rsld"], "req": ["gr", "proc", "http", "attr", "qt", "dq", "qq", "org", "pkg", "rx", "requ", "wcs", "q", "inv", "qs", "seq", "pas", "fr", "Requ", "client", "require", "request", "comp", "quest", "comm", "quick", "Request", "ctx", "query", "jp", "urg", "cmd", "res", "usr", "sq", "wx", "cur"], "resp": ["output", "wr", "proc", "http", "gr", "html", "Resp", "vol", "rep", "dis", "ret", "msg", "sys", "response", "rec", "body", "p", "rend", "rel", "inv", "os", "re", "respond", "pas", "conv", "pos", "fr", "RES", "esp", "client", "serv", " Resp", "content", "nt", "cmp", "request", "sol", "comm", "compl", "r", "respons", "Res", "Response", "fs", "result", "conn", "obj", "cl", "status", "sp", "https", "exp", "jp", "res", "cmd", "soc", "report", "wx"], "out": ["output", "cos", "vol", "n", "Out", "sys", "yout", "gs", "bs", "o", "aos", "to", "os", "sw", "ws", "io", "conv", "outs", "ex", "ins", "t", "client", "ou", "nt", "null", "ts", "w", " outs", "obj", "net", "OUT", "gt", "cn", "us", "log", "oss", "co", "ot", "in", "res", "utt"], "bos": ["bat", "bo", "bot", "mos", "oops", "nos", "oos", "banks", "jas", "des", "sys", "uts", "bis", "bs", "dos", "aos", "ws", "os", "boards", "BS", "ys", "bits", "obs", "ubis", "bones", "bin", "buff", "js", "bas", "bi", "ods", "bes", "eros", "fits", "bytes", "oids", "ols", "base", "los", "oss", "tes", "bh", "ios", "ts", "bles"]}}
{"id1": "1954410", "id2": "15409512", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"doExecute": ["doEditute", "doCommutes", "doCommExec", "DoExecute", "DoExecit", "doCommit", "DoExecutes", "doExecutes", "doExecit", "doEditit", "DoExecExec", "doExecExec", "doEditutes", "doCommute", "doEditExec"], "mapping": ["smappings", " mappings", "mapper", "Mappings", "mapped", " mapped", "Mapper", "Mapped", " mapper", "smapped", "mappings", "Mapping", "smapper", "smapping"], "form": ["path", " forms", "orm", "session", "owner", "self", "template", "config", "type", "f", "raw", "forms", " Form", " FORM", "subject", "map", "Form", "parent", "fc", "view", "formed", "command", "FORM", "m", "sam", "app", "format"], "request": ["http", "window", "se", "instance", "sw", "parent", "version", "upload", "Request", "query", "url", "report", "QUEST", "template", "create", "allow", "this", "impl", "quest", "container", "_", "w", "remote", "project", "def", "document", "application", "session", "Upload", "model", "address", "Exception", "reset", "frame", "client", "resource", "current", "server", "xml", "view", "input", "first", "order", "question", "message", "open", "user", "reference", "true", "initial", "req", "store", "post", "cont", "command", "context", "host"], "response": ["output", "message", "application", "session", "connection", "send", "ce", "re", "respond", "frame", "resp", "server", "content", "write", "view", "xml", "Response", "result", "print", "status", "reply", "sp", "document", "success", "res", "report"], "errors": [" mess", " steps", " messages", " success", " managers", " logs", " messenger", " sessions", " manager", " storage", " changes", " fails", " requests", " flashes", " status", " statements", " error", " states", " problems", " state", " warnings", " flash", " updates", " moves", " elements", "Mess", "ages", " Messages"], "isMultipart": ["isMultipod", "isMultipain", "isMultIPare", "isMultiade", "isMultiplod", "isMultiIPod", "isMultifarts", "isMultiparts", "isMultosparts", "isMultiipart", "isMultiIPade", "isMultipare", "isMultIPain", "isMultiarts", "isMultifare", "isMultiIPain", "isMultiplarts", "isMultiIPare", "isMultiIPart", "isMultIPade", "isMultiiparts", "isMultifart", "isMultiipare", "isMultospart", "isMultIParts", "isMultospain", "isMultiart", "isMultiipain", "isMultiod", "isMultospare", "isMultiplade", "isMultIPod", "isMultipade", "isMultiplart", "isMultiipade", "isMultifain", "isMultiipod", "isMultiIParts", "isMultIPart"], "mailInstance": ["flexance", " mailance", " mailInst", "mailinstance", " mailBuilder", " MailInstance", " Mailinstance", "emailance", "emailBuilder", "mailance", " MailBuilder", "flexInstance", "mailInst", "flexinstance", "flexInst", "emailinstance", " MailInst", "mailBuilder", "emailInstance", "emailInst", " mailinstance"], "fields": ["field", "states", "faces", "strings", "links", "balls", "properties", "headers", "workers", "types", "orders", "posts", "users", "ports", "locks", "checks", "prints", "plugins", "drivers", "comments", "images", "frames", "sections", "qs", "forms", "rows", "boxes", "rules", "views", "flags", "pages", "packs", "files", "dates", "lists", "bits", "lines", "tags", "classes", "levels", "packages", "tests", "holders", "features", "members", "terms", "days", "keys", "parts", "details", "models", "reports", "phones", "relations", "lights", "modules", "names", "groups", "atts", "objects", "services"], "attachments": ["achensions", "attensions", " attachions", "payances", " attachresses", "attitions", "attachMENTS", "payements", "attachitions", "acheements", "attachensions", "Attachments", " attachements", "attachions", "achMENTS", "acheances", "Attachresses", "achements", "attMENTS", " attachitions", "AttachMENTS", " attachances", "payitions", "achitions", "Attachions", "achments", "attachresses", "attachements", "payments", "achresses", "attments", "achions", "Attachensions", "attachances", "Attachitions", "acheitions"], "items": ["cases", "links", "orders", " Items", "images", "Items", " images", "its", "rows", "pages", "qs", "files", "lines", "tests", "packages", "photos", " files", "actions", "ids", " results", "members", "ips", "archives", "keys", "parts", "reports", "phones", "apps", "resources", "results", "names", " samples", " inputs", "issues", "groups", "events", "objects", "services"], "iter": ["each", "ser", "ite", "ator", "iner", "init", "it", "Iter", "loop", "orient", "li", "its", "read", "iterator", "test", "maker", "altern", "re", "older", "ind", "dir", "er", "oper", "loc", "el", "cmp", "inner", "store", "writer", "ait", "reader", "inter", "coll", "ipper", "tr", "ter", "Iterator", "result", "tif", "upper", "ner", "former", "set", "gener", "i", "walker", "outer", "list", "order"], "item": ["cell", "member", "instance", "it", "change", "attribute", "att", "element", "atom", "inner", "other", "status", "file", "job", "url", "word", "zip", "on", "json", "internal", "or", "template", "link", "entity", "claim", "row", "ex", "group", "name", "obj", "anything", "details", "entry", "object", "data", "ip", "attr", "add", "local", "area", "mm", "er", "resource", "up", "rule", "xml", "unit", "one", "page", "stat", "app", "order", "step", "addr", "type", "detail", "raw", "Item", "initial", "el", "spec", "key", "related", "store", "module", "event", "record", "layer", "match", "info", "image", "ix", "single"], "aux": ["af", "eu", "abs", "cu", "auto", "used", "uds", "aim", "aos", "area", "av", "airs", "au", "ex", "AU", "etc", "ox", "lim", "aff", "buff", "fax", "uf", "du", "aus", "ax", "fx", "net", "fuck", "imp", "pet", "extra", "tx", "us", "vers", "mu", "max", "fu", "uff", "ux", "off", "foo", "fam", "pad", "aw", "ras", "ups", "ix", "fat"], "part": ["top", "block", "member", "peer", "tmp", "and", "zone", "bound", "card", "parent", "component", "pre", "inner", "version", "job", " parts", "work", "art", "word", "list", "split", "pos", "pair", "photo", "group", "mod", "print", "partial", "object", "sp", "Part", "start", "temp", "html", "add", "prefix", "section", "worker", "person", "local", "relation", "PART", "pod", " Part", "pet", "tx", "join", "admin", "message", "party", "patch", "step", "pkg", "detail", "piece", "tab", "p", "api", "sample", "pt", "par", "wrapper", "comp", "parts", "half", "base", "point", "primary", "layer", "pad", "format"], "baos": ["booses", "baops", "waols", "boOS", "cao", "kaops", "pois", "bais", "waoss", "caOs", "bios", "taos", "taoss", "baols", "pooss", "kaoss", "bio", "bao", "booss", "baOs", "kais", "vaOs", "caoss", "caOS", "vaols", "boOs", "tao", "biOS", "boos", "kaos", "baOS", "poops", "vaoss", "caos", "poo", "baoses", "caols", "bioses", "vaos", "tais", "poOS", "taOs", "waOs", "baoss", "waos", "poos", "taops", "pooses", "boo"], "body": ["output", "buffer", "message", "binary", "text", "json", "html", "description", "mail", "plain", "template", "head", "header", "detail", "loop", "title", "shell", "send", "bill", "rel", "Body", "size", "subject", "note", "default", "ody", "t", "content", "summary", "pass", "tree", "null", "name", "post", "foot", "business", "base", "port", "file", "log", "ODY", "comment", "data", "format", "tail", "display", "scroll", "layout", "report"], "preferencesInstance": ["prefiesinstance", "preffiesinstance", "prefferencesinstance", "prefutesObj", "preferencesObj", "preffiesObj", "preffiesImpl", "prefancesInstance", "prefutesImpl", "prefancesObj", "preferencesinstance", "prefancesImpl", "prefutesInstance", "prefferencesImpl", "prefancesinstance", "prefiesInstance", "preferencesImpl", "prefferencesInstance", "prefiesImpl", "prefferencesObj", "prefutesinstance", "prefiesObj", "preffiesInstance"]}}
