{"id1": "20275821", "id2": "15202804", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getAttribute": [" getDirectory", "readAtt", "GetAttribute", " getAttributes", "readAttribute", "readattribute", "fileAttributes", " getattribute", "Getattribute", "fileattribute", "GetDirectory", "getAttributes", " getAtt", "readDirectory", "readAttributes", "getattribute", "getDirectory", "fileAttribute", "fileAtt", "getAtt", "GetAtt"], "url": ["dl", "cl", "ul", "conn", "rl", "host", "nl", "str", "connection", "base", "user", "u", "server", "el", "file", "log", "loc", "document", "l", "b", "web", "gl", "uri", "https", "il", "string", "q", "r", "ssl", "path", "ls", "job", "ref", "sl", "address", "name", "conv", "ur", "pl", "http", "ll", "link", "abs", "sql", "URL", "char", "null", "call", "resource", "Url", "page"], "con": ["c", "ct", "trans", "close", "can", "conn", "ver", "cone", "cont", "re", "Con", "connection", "po", "Conn", "cal", "bean", "col", "pen", "pos", "en", "go", "const", "free", "bc", "ln", "cf", "comm", "ain", "mc", "cp", "bon", "cc", "proc", "client", "clean", "cons", "CON", "open", "don", "conv", "ran", "un", "on", "co", "soc", "conf", "cur", "num", "cn", "fin", "cm", "pc", "fc", "fl", "dial", "canon", "com", "ctrl", "nc", "connect"], "response": ["version", "onse", "request", "usage", "country", "status", "state", "se", "es", "connection", "respons", "roads", "esp", "server", "des", "os", "total", "pos", "compliance", "next", "trace", "result", "e", "body", "client", "esi", "none", "index", "zero", "application", "res", "success", "position", "amount", "resp", "description", "http", "network", "json", "number", "relative", "net", "sequence", "message", "entry", "reset", "yes", "code", "Response", "error", "when", "def"], "redirect": ["redrict", " redirection", "Redirection", "preditional", "redirection", "Redirect", "predirect", " Redrict", " redir", "rewind", " redrict", "reditional", "rewirect", " Redirect", " Redirection", "rewrict", "predirection", "predir", " reditional", "redir", "redind", "Reditional", " redind", " Redind", "Redir", "rewirection"], "location": ["history", "where", "details", "usage", "zone", "translation", "behavior", "operation", "comment", "loc", "document", "relation", "phrase", "region", "language", "uri", "origin", "pointer", "path", "reference", "hold", "ocation", "address", "Location", "command", "direction", "position", "layout", "slot", "relative", "directory", "template", "local", "link", "sample", "area", "LOC", "holder", "resource", "remote", "filename", "system"]}}
{"id1": "10218878", "id2": "5299276", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeMAPFiles", "DecodeMapFiles", "DecodeToLog", "DecodeMAPfile", "DecvertMAPfile", "DecvertMAPFile", "DecodeFromLog", "DecvertMapfile", "DecodeToFiles", "DecodeMapfile", "DecodeTofile", "DecvertMapFiles", "DecvertMapLog", "DecodeFromfile", "DecodeMAPFile", "DecvertMapFile", "DecodeFromFile", "DecvertMAPFiles", "DecodeToFile", "DecvertMAPLog", "DecodeFromFiles", "DecodeMAPLog", "DecodeMapLog"], "mapFile": ["mapFILE", "mapFilename", "MapStream", "listFile", "imageFile", "MapFile", "listPath", " mapFilename", "mapfile", "mapStream", "Mapfile", "cacheFile", " mapPath", "cacheFILE", "imageStream", "cachePath", "imageFilename", " mapStream", "listFILE", " mapFILE", " mapfile", "imagefile", "MapFilename", "mapPath"], "outputFile": ["outputDir", "OutputDir", "outputStream", "inputName", "outFile", "OutputPath", " outputDir", "writeName", "outPath", "mapStream", "mapName", "OutputFilename", "outDir", "writeStream", "outFilename", "outputPath", "mapDir", "writeFile", " outputPath", "inputStream", "OutputFile", "outputFilename", "inputFile", " outputFilename", "inputDir", "outputName", "writeDir"], "magicKey": [" magicCode", "prefixKey", "magicChar", "uniqueCounter", " magicChar", "prefixValue", " magicField", "serialKEY", "encryptedKey", " magicKEY", "anticKey", "serialKey", "antickey", "MagicName", "prefixCounter", "magicValue", "magicCounter", "uniqueValue", "magicField", "serialId", " magicId", "magicKEY", " magicValue", "magicName", "serialName", "MagicKey", "prefixCode", "magicId", "magicCode", "encryptedChar", "MagicKEY", "magickey", "anticField", " magickey", " magicCounter", "anticChar", "uniqueKey", "encryptedkey", " magicName", "uniqueCode", "MagicId", "encryptedField"], "buffer": ["history", "memory", "Buffer", "binary", "detail", "stack", "stream", "black", "pad", "buff", "base", "length", "total", "attribute", "batch", "document", "flash", "print", "phrase", "iter", "button", "shape", "queue", "stroke", "index", "cache", "check", "program", "database", "screen", "command", "variable", "mem", "buf", "bone", "paste", "frame", "template", "row", "sample", "block", "sequence", "message", "bo", "display", "vector", "char", "sum", "initial", "append", "table", "filter", "code", "bridge", "window", "page", "header"], "nread": ["ncwrite", "renwrite", "nreadable", "rawreader", "rawwrite", "rentry", "maxget", "rawtry", "Nread", "maxread", "ncRead", " nwrite", "rnread", "maxadd", "Nwrite", "NRead", "nREAD", "maxRead", " ntry", " nREAD", "ncget", "rawread", "ncread", "nwrite", "ntry", "rnwrite", "rnRead", "NREAD", "ncreadable", " nreadable", "renreader", "ncadd", " nRead", "nreader", "nget", "nRead", "rnREAD", "Nget", "Nadd", "renread", " nreader", "Nreadable", "nadd"], "map": ["meta", "apper", "parse", "ip", "aps", "app", "ml", "where", "memory", "window", "read", "manager", "maps", "view", "down", "mount", "mt", "file", "batch", "mod", "image", "mate", "place", "shape", "mask", "cache", "open", "pack", "ace", "ape", "address", "up", "op", "mem", "apping", "mp", "clear", "co", "per", "pl", "load", "set", "man", "module", "con", "pose", "lock", "cm", "block", "master", "com", "config", "MAP", "m", "collect", "table", "ap", "bridge", "make", "form"], "output": ["object", "four", "exit", "write", "can", "oe", "blue", "stream", "auto", "log", "file", "batch", "icon", "print", "next", "web", "result", "secure", "console", "update", "out", "client", "hidden", "queue", "input", "Output", "put", "cache", "plain", "open", "entity", "format", "online", "network", "target", "o", "net", "response", "block", "display", "latest", "ilo", "socket", "port", "ou", "current", "outer", "other"], "i": ["ip", "t", "li", "y", "v", "span", "bi", "ii", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "mi", "iu", "batch", "b", "gu", "gi", "spin", "uri", "q", "cli", "ami", "x", "is", "ti", "ie", "index", "ci", "pi", "ji", "n", "qi", "ni", "si", "ix", "di", "ini", "ei", "it", "ish", "sim", "j", "m", "fi", "ai", "g", "us", "ic", "ri", "ms"]}}
{"id1": "19652200", "id2": "14450108", "code1": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"init": ["save", "create", "read", "run", "release", "construct", " intern", "update", " initiate", "index", " constructor", "start", " Init", "get", "load", "info", "launch", " relocate", " initialization", "reset", "initial", "store", "config", "empty", "connect", "Init"], "file": ["le", "io", "create", "binary", "buffer", "current", "data", "tree", "base", "user", "fil", "FILE", "this", "attribute", "File", "log", "upload", "full", "document", "image", "disk", "dir", "uri", "body", "il", "ile", "line", "path", "open", "name", "format", "handle", "f", "http", "load", "be", "info", "local", "link", "output", "message", "report", "null", "real", "page", "resource", "table", "port", "rule", "source", "filename", "form"], "url": ["cl", "location", "host", "nl", "str", "mount", "base", "u", "loc", "l", "b", "gl", "web", "uri", "string", "q", "r", "browser", "ssl", "path", "util", "open", "mail", "sl", "address", "name", "ur", "get", "f", "http", "api", "ll", "link", "rel", "abs", "URL", "char", "resource", "i", "Url"], "stream": ["buffer", "status", "view", "stack", "download", "pool", "ream", "session", "console", "input", "path", "open", "engine", "chain", "handle", "channel", "Stream", "link", "context", "message", "socket", "page", "port", "resource", "source", "form"], "byteArray": ["charList", "ByteArray", "ByteList", " byteString", "byteString", "charString", " byteList", "charArray", "ByteString", "byteList"], "content": ["version", "text", "status", "data", "comment", "raw", "action", "body", "section", "hash", "path", "Content", "comments", "title", "format", "media", "json", "value", "template", "size", "message", "config", "code", "page", "cont", "source", "header", "summary"]}}
{"id1": "14001795", "id2": "20100809", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverwarFile", "copyoverwarFilename", "copyOverTarfile", "copyOverWarFiles", "copyoverWarFile", "copyoverwarFiles", "copyOverwarFilename", "copyOverTarFile", "copyOverwarfile", "copyoverWarFiles", "copyOverTarFilename", "copyoverWarfile", "copyoverwarfile", "copyOverWarfile", "copyoverwarFile", "copyOverTarFiles", "copyoverWarFilename", "copyOverWarFilename", "copyOverwarFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "dr", "re", "md", "ind", "file", "disk", "log", "div", "loc", "add", "dd", "iter", " directory", "del", "out", "df", "mk", "path", "dm", "Dir", "res", "DIR", "dat", "name", "dim", "old", "url", "coll", "fd", "d", "folder", "di", "ld", "directory", "dist", "cur", " Dir", "fin", "local", " d", "desc", "rel", "vol", "ir", "dial", "direct", "doc", "addr", "parent", "zip", "good", "window", "db", "form", "def"], "ff": ["fact", "tf", " aft", "aff", " cf", "fx", " ref", "off", "ef", "buff", "bf", "FF", "mt", "file", " FF", " eff", "xf", "ck", "UFF", "xff", "af", "df", "uf", "lf", "cb", "cond", "ft", "fd", " df", "aft", "ld", "wind", "fp", " def", "ffe", " af", "fc", "fl", "fg", "F", "filter", "sf", "uff", "iff", "eff", "cf", "alf"], "files": ["features", "facts", "faces", "ions", "Files", "parts", "forms", "file", "images", "frames", "assets", "ports", "balls", "items", "rows", "leases", "ls", "objects", "days", "styles", "mas", "plates", "ails", "iles", "names", "bees", "models", "flows", "members", "fs", "les", "jobs", "uploads", "lines", "resources", "tests", "values", "fields", "keys", "issues", "ories"], "f": ["c", "t", "tf", "v", "rf", "fe", "k", "fac", "col", "bf", "fa", "file", "l", "b", "e", "fab", "xf", "uf", "lf", "fm", "fw", "a", "n", "ft", "exp", "p", "d", "fd", "fs", "fp", "w", "fc", "fl", "elf", "m", "F", "g", "sf", "i", "h", "cf", "alf", "def"], "newFile": ["newPlace", "oldFilename", "NewNode", "NewFile", " newPlace", "oldFile", "secureFile", "newsfile", "uniqueNode", "newsFile", "newNode", "newFiles", "uniquePage", "anotherFile", "NewPlace", "newFilename", " newFiles", "anotherPlace", "securefile", "newKey", "NewPage", "oldfile", "uniqueFile", "NEWfile", "newPage", "uniquefile", "NewFilename", "NEWFile", "secureKey", "NEWPage", "newfile", "Newfile", "anotherfile", "NewKey", "newsKey", "NewFiles", "anotherFiles", " newfile", " newFilename", "NEWNode"], "fi": ["fr", "li", "io", "fe", "bi", "ii", "phi", "bf", "fa", "iu", "mi", "isi", "flo", "ti", "uf", "lf", "ki", "FI", "ci", "pi", "ni", "fd", "si", "di", "ini", "fp", "fin", "afi", "ifa", "ife", "zi", "i", "sf", "ri", "cf", "Fi"], "fo": ["tf", "te", "oe", "po", "hea", "sty", "uo", "oo", "ato", "FO", "ho", "oooo", "xf", "flo", "eto", "tk", "ph", "hi", "ti", "ki", "ott", "mo", "wo", "ow", "eno", "fam", "zz", "vo", "tif", "co", "opa", "o", "tto", "bo", "wt", "jo", "zo", "sf", "ko", "cf"]}}
{"id1": "13152325", "id2": "11546108", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadExistingAntlibs": ["loadExistingantlibs", "loadExistingAntlibz", "loadExistingAntibs", "loadExistingAntribz", "loadExistingantLibs", "loadExistingantLibd", "loadExistingAntLibs", "loadExistingAntibz", "loadExistingAntribd", "loadExistingAntLibd", "loadExistingAntibFiles", "loadExistingAntlibFiles", "loadExistingAntribs", "loadExistingAntribFiles", "loadExistingantlibFiles", "loadExistingantLibz", "loadExistingantlibd", "loadExistingAntLibz", "loadExistingAntLibFiles", "loadExistingantLibFiles", "loadExistingAntibd", "loadExistingAntlibd", "loadExistingantlibz"], "classLoader": ["Classloader", "classloader", "classReader", "ClassLoader", " ClassLoad", " ClassLoader", " classReader", " ClassPath", "ClassReader", "classLoad", " classloader", " ClassReader", "ClassPath", " Classloader", "ClassLoad", " classLoad", " classPath", "classPath"], "antlibUrl": ["antlibURL", "AntLibUr", "antslibRel", "antslibUr", "antlaburl", "antsLiburl", "antlibraryUrl", "antdburl", "antsLibRel", "antLibRel", "antLiburl", "antlabStr", "antLibStr", "antdbUrl", "antlabUrl", "antlabUr", "AntlibUrl", "antlibraryURL", "antliburl", "antribUrl", "antsliburl", "antlibraryRel", "antdbURL", "AntLiburl", "AntlibUr", "antlibraryStr", "antlibraryUr", "antslibStr", "antLibUrl", "antsLibURL", "antlibraryurl", "antsLibStr", "AntlibURL", "AntLibURL", "antriburl", "antLibUr", "antlibUr", "antLibURL", "antslibUrl", "antappUr", "antslibURL", "antsLibUrl", "antsLibUr", "AntLibUrl", "antappUrl", "antappRel", "antlibRel", "Antliburl", "antdbUr", "antappURL", "antribURL", "antlibStr", "antribUr"], "antlibUri": ["antlibURmi", "antlibraryUne", "antlibUsne", "antLibIRI", "antlibGerid", "antlibURris", "antlibIne", "antlibraryUsri", "antLibUtri", "antLibIrid", "antLibIri", "antlibUtrid", "antLibIURI", "antlibraryUsne", "antlibEURI", "antlibOne", "antlibOr", "antlibUURI", "antlibIri", "antlibEri", "antlibraryUsmi", "antlibUtmi", "antlibraryUris", "antlibUsri", "antlibraryUr", "antLibUri", "antlibUsRI", "antLibUtris", "antlibGeRI", "antlibUrid", "antlibraryUmi", "antlibraryUsRI", "antlibOri", "antlibIURI", "antlibUsURI", "antlibIrid", "antlibUris", "antlibUtris", "antlibUsis", "antlibIpi", "antLibUrid", "antlibUtRI", "antlibUmi", "antLibUis", "antlibIRI", "antlibUsris", "antlibUsr", "antlibEUri", "antlibraryUsr", "antlibGeri", "antLibUpi", "antlibOris", "antLibIis", "antlibUtpi", "antlibUr", "antlibraryUsris", "antlibGeris", "antLibIris", "antlibUpi", "antlibEris", "antLibUris", "antLibURI", "antlibEUpi", "antlibEUris", "antlibURRI", "antlibraryUri", "antlibraryURI", "antlibUtri", "antlibEis", "antlibUis", "antlibUne", "antLibUURI", "antlibIr", "antlibIris", "antlibURI", "antLibUtpi", "antlibURri", "antlibIis", "antlibUsmi"], "resources": ["states", "parents", "modules", "ries", "ions", "ples", "maps", "links", "classes", "iers", "headers", "services", "workers", "images", "relations", "roots", "ports", "books", "these", "pages", "objects", "reports", "stores", "years", "res", "dates", "archives", "actions", "checks", "builders", "names", "models", "rs", "works", "users", "types", "packages", "seconds", "writers", "values", "bytes", "files", "groups", "ues", "Resources", "keys", "issues", "events"], "url": ["lb", "dl", "li", "location", "request", "rl", "host", "nl", "mount", "str", "base", "server", "el", "file", "loc", "lr", "l", "add", "gl", "web", "string", "r", "ssl", "browser", "path", "ls", "util", "ref", "sl", "address", "name", "format", "bel", "ur", "get", "date", "f", "github", "http", "service", "ll", "link", "rel", "abs", "URL", "char", "entry", "addr", "resource", "xml", "Url", "remote", "source", "key"], "stream": ["content", "history", "io", "buffer", "read", "view", "stack", "data", "pipe", "user", "file", "inner", "ream", "zip", "loader", "body", "console", "client", "out", "progress", "path", "input", "open", "sl", "feed", "sw", "Stream", "channel", "row", "standard", "sample", "response", "context", "message", "socket", "store", "resource", "window", "source", "system", "iterator"], "reader": ["reviewed", "read", "buffer", "instance", "READ", "range", "rl", "volume", "rx", "server", "length", "file", "layer", "liner", "collection", "inner", "review", "loader", "dd", "Reader", "ro", "older", "iter", "console", "parser", "r", "client", "ner", "driver", "rer", "input", "upper", "rar", "er", "per", "row", "query", "via", "reading", "roller", "reads", "sample", "runner", "readable", "entry", "socket", "rr", "handler", "resource", "writer", "ri", "iterator"], "line": ["text", "le", "li", "buffer", "lin", "inline", "range", "point", "nl", "str", "column", "comment", "pos", "file", "log", "liner", "LINE", "print", "l", "next", "ln", "cell", "body", "iter", "string", "eline", "Line", "lo", "profile", "ls", "lf", "sl", "ine", "n", "handle", "online", "pe", "len", "frame", "row", "link", "lines", "block", "sample", "message", "sql", "entry", "stay", "label", "msg", "port", "word", "page", "header"], "pkg": ["ip", "dl", "plugin", "pid", "jar", "pod", "rpm", "wd", "fx", "ctx", "lib", "patch", "part", "key", "imp", "col", "ppa", "mod", "prefix", "pt", "pg", "dir", "cp", "kg", "deb", "path", "mask", "gp", "family", "pack", "alias", "name", "var", "req", "password", "root", "p", "pair", "perm", "init", "module", "packages", "entry", "pp", "quote", "msg", "port", "cmp", "zip", "Package", "kid", "lang"], "uri": ["ip", "io", "location", "uid", "connection", "base", "id", "ui", "mi", "file", "profile", "cli", "library", "reference", "util", "pi", "address", "uu", "term", " URI", "ur", "iri", "folder", "http", "directory", "URI", "api", "proxy", "local", "link", "domain", "handler", "resource", "i", "ri", "source", "system"], "resource2antlib": ["resource2agentlib", "resource2ANTib", "resource2ntlib", "resource2etlibrary", "resource2Antlib", "resource2agentLib", "resource2Antli", "resourcetoantloc", "resource2antlibrary", "resource2etLib", "resource2Antib", "resource2antsloc", "resource1agentlibrary", "resource2agentib", "resource2boltconfig", "resource2boltlib", "resource1agentLib", "resource2ntLib", "resource2etlib", "resource2ntib", "resource2ANTconfig", "resource2etli", "resource2ANTloc", "resource2antli", "resource2antsconfig", "resourcetoantconfig", "resourcetoANTlib", "resource2antsib", "resource2antconfig", "resource1agentib", "resourcetoANTib", "resource2agentlibrary", "resourcetoANTconfig", "resourcetoANTloc", "resourcetoantib", "resource2Antlibrary", "resource2AntLib", "resource1antlibrary", "resource2ntlibrary", "resource1antLib", "resource2antib", "resource2antslib", "resource1antib", "resource1antlib", "resource2ANTlib", "resource2ntli", "resource2antloc", "resource2boltib", "resource1agentlib", "resource2boltloc", "resourcetoantlib", "resource2antLib"]}}
{"id1": "6188784", "id2": "16621503", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "save", "create", "read", " replicate", " mirror", "upload", " duplicate", "transfer", "download", " dup", " cp", "clip", "clone", "cp", " copying", " Copy", "gc", "slice", " clone", "paste", "move", "load", "delete", "link", "cat", "Copy", " move"], "source": ["se", "src", "scene", "view", "scope", "base", "space", "ce", "image", "original", "iter", "origin", "sys", "SOURCE", "input", "ource", "check", "spec", "start", "Source", "init", "search", "target", "template", "query", "site", "sample", "sql", "from", "subject", "null", "style", "parent", "resource", "sf", "sp", "seed", "s"], "dest": ["est", "img", "then", "th", "Dest", "trans", "bin", "tom", "src", "des", "usr", "nom", "this", "rest", "test", "loc", "them", "foreign", "result", "dir", "https", "del", "origin", "way", "cas", "nw", "pot", "orig", "exp", "d", "search", "target", "dist", "it", "st", "lit", "that", "null", "deg", "master", "decl", "cont", "good"], "in": ["bin", "can", "din", "min", "conn", "or", "ac", "sin", "inc", "isin", "rin", "ind", "mi", "en", "inner", "l", "ln", "inf", "ain", "inside", "vin", "mc", "r", "is", "input", "nin", "pi", "al", " IN", "up", "In", "n", "on", "old", "get", "co", "gin", "init", "ma", "all", "win", "info", "ini", "IN", "net", "like", "con", "one", "local", "it", "ch", "from", "ins", "inn", "cin", "doc", "ai", "i", "ca", "mm", "oin"], "out": ["c", "t", "io", "v", "write", "can", "ac", "conn", "oe", "ne", "os", "over", "user", "server", "ext", "en", "om", "inner", "ln", "ent", "at", "na", "ot", "gt", "client", "oss", "cmd", "opt", "no", "cache", "res", "nt", "up", "conv", "n", "on", "note", "co", "o", "net", "con", "cn", "outs", "ch", "it", "output", "Out", "ex", "null", "ns", "to", "cos", "ion", "writer", "not", "msg", "ou", "aos", "OUT", "outer"], "size": ["scale", "count", "small", "read", "write", "fee", "score", "speed", "close", "buffer", "max", "range", "sn", "sm", "space", "length", "total", "file", "en", "gets", "now", "ze", "body", "shape", "is", "sy", "name", "n", "position", "city", "amount", "notice", "capacity", "width", "export", "send", "get", "start", "si", "height", "len", "number", "num", "sample", "sum", "area", "SIZE", "bytes", "see", "ize", "empty", "Size", "sp", "set"], "buf": ["cv", "Buffer", "buffer", "bh", "data", "buff", "Buff", "batch", "func", "b", "bc", "next", "result", "vec", "bar", "cmd", "queue", "uf", "cb", "br", "job", "fam", "rb", "map", "aka", "bag", "foo", "orig", "seq", "pkg", "row", "gen", "cam", "bp", "cap", "cat", "tab", "nm", "msg", "good", "db"]}}
{"id1": "20929570", "id2": "22611968", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"toMd5": ["toMMD5", "toDd512", "toMMD512", "toMmHash", "toDd5", "toDm5", "toMm5", "toMMDHash", "toMmdHash", "toDm4", "toMMD4", "toDd4", "toMd512", "toMmd512", "toMm512", "toMmd5", "toDm512", "toDdHash", "toMmd4", "toMm4", "toMd4", "toDmHash", "toMdHash"], "str": ["text", "t", "c", "ctr", "v", "enc", "Str", "in", "arr", "data", "this", "print", "b", "wr", "e", "string", "r", "out", "input", "br", "obj", "name", "a", "n", "p", "utt", "STR", "w", "it", "ch", "st", "char", "msg", "cr", "s", "sp", "txt"], "messageDigest": ["Messagedigse", "messageDigester", "messageDigse", "messagedigEST", "messageDefEST", "applicationdigester", "messageDse", "messageDefist", "MessageDigse", "messageDesignester", " messageDiger", " messageDigse", " messageDest", "applicationdigest", "applicationDigest", "messagedigse", "messageDefester", "messagemdse", "MessageDigests", "messageDecester", "applicationDigse", "MessageDigester", "applicationDigester", "messagedigist", "Messagediger", "messageDigist", "applicationDigested", "messageDecest", "messageDest", "messageDert", "messagedigests", "messagedigested", "Messagedigests", "messageDigert", "messagemdest", " messageDse", "messagemdester", "Messagedigester", "messageDecse", "messageDecested", "messageDecests", "messageDigested", "MessageDigEST", "MessagedigEST", "MessageDigest", "messageDesignest", " messageDigester", "messageDesignse", "messageDigEST", "applicationdigse", "messagedigest", "MessageDiger", "applicationdigested", "messagemdert", "messagedigert", " messageDert", "messageDefer", "messagediger", "messageDiger", "messageDester", "Messagedigest", "messageDesignested", " messageDigist", " messageDigert", "messageDigests", " messageDester", "messageDesignests", "messagedigester", "messageDefest"], "byteArray": ["bytearray", "byteString", "viewStream", "fieldRAY", "entityArray", "basicList", " byteList", " bytearray", "entityList", "seArray", "byteBuffer", "viewBuffer", "bytesString", "helloBuffer", "entityarray", "bytesArray", "fieldLength", "resourceStream", "bytesAddress", "resourceArray", "helloArray", "basicarray", "basicString", "seBuffer", "basicArray", "viewArray", " byteRAY", "fieldArray", "resourceBuffer", "byteRAY", " byteBuffer", " byteAddress", "byteStream", "entityBuffer", "byteAddress", " byteString", " byteStream", "bytesLength", "bytesRAY", "basicAddress", "basicBuffer", " byteLength", "byteLength", "byteList"], "md5StrBuff": ["md65TextBuffer", "md5StringDb", "md8StrBuff", "md5StPref", "md65StrBuffer", "md7StrPref", "md5StringCop", "md4StrDb", "md5ObjVert", "md5StrVert", "md5strComp", "md5RatComp", "md65TextCop", "md5StringBu", "md5TextBuffer", "md5ObjComp", "md5StComp", "md7StrBu", "md5TextBuff", "md5Strbuff", "md5TextComp", "md5Stbuff", "md5RatBuff", "md5strBu", "md5strDb", "md5strVert", "md5strbuff", "md4StrBuff", "md5StringPref", "md5Stringbuff", "md65StrComp", "md5ObjBuff", "md65StrBuff", "md5StrPref", "md4Strbuff", "md5StrComp", "md5BuffDb", "md5ObjBuffer", "md8RatBuff", "md5StBuffer", "md4StrPref", "md7StringPref", "md4StringBuff", "md4StringPref", "md65StrCop", "md5strPref", "md5TextCop", "md7StrBuff", "md4Stringbuff", "md5StBuff", "md5StrDb", "md8RatComp", "md65TextBuff", "md5StringBuff", "md5StringComp", "md5StrBu", "md5RatBuffer", "md4StringDb", "md7Stringbuff", "md5StrCop", "md5Buffbuff", "md7Strbuff", "md8StrBuffer", "md8StrVert", "md5RatVert", "md7StringBu", "md5StBu", "md5StrBuffer", "md5strBuffer", "md7StringBuff", "md5strBuff", "md5StCop", "md5StringBuffer", "md5BuffBuff", "md65TextComp", "md8RatVert", "md8RatBuffer", "md8StrComp", "md5BuffPref"], "i": ["ip", "c", "t", "li", "y", "io", "gravity", "v", "bi", "status", "in", "ii", "phi", "multi", "xi", "I", "u", "ui", "ind", "mi", "iu", "go", "batch", "l", "gu", "e", "gi", "uri", "im", "q", "hi", "cli", "x", "cgi", "ki", "ti", "is", "index", "major", "ci", "slice", "pi", "chain", "ji", "conv", "a", "n", "me", "si", "ix", "di", "info", "ini", "ei", "o", "list", "json", "it", "j", "ex", "my", "m", "ai", "us", "h", "s", "ic"]}}
{"id1": "11673907", "id2": "13063241", "code1": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"_checkLanguagesFiles": ["_checkAllangsfiles", "_checkAllangsFiles", "_checkLangsFiles", "_checkLuesfiles", "_checkLuesFiles", "_checkLuesFile", "_checkLangsWindows", "_checkAllanguagesfiles", "_checkAllangsFile", "_checkLangsfiles", "_checkLanguagesfiles", "_checkAllangsWindows", "_checkLanguagesFile", "_checkAllanguagesWindows", "_checkLanguagesWindows", "_checkLangsFile", "_checkAllanguagesFiles", "_checkLuesWindows", "_checkAllanguagesFile"], "req": ["fr", "request", "inv", " request", "ctx", "src", "usr", "md", "jp", "comm", " requ", "require", "q", "pas", "cmd", "r", "cgi", "tr", "ux", "ref", "quest", "qt", "Request", "pkg", "http", "conf", "cur", "rs", "required", "wx", "Requ", "ch", "tx", " cir", "xml", "msg", "attr", " fr", "requ"], "res": [" Res", "Resp", "state", "re", "des", "Rep", "data", "os", "next", "result", "Res", "out", "resp", " rs", " gr", " resp", "conf", "rs", "con", "ch", "tx", "doc", "RES", "s", "sp", "sol", "txt"], "config": ["c", "ct", "cfg", "state", "ctx", "etc", "base", "ext", "Configuration", "log", "Conf", " Config", "admin", "rc", "map", "param", " fig", "fig", "params", "conf", "con", " configuration", "context", "Config", "auth", "cont", "cf", "set"], "form": ["fr", "submit", "app", "instance", "state", "view", "base", "sam", "forms", "pool", "flash", "session", " Form", "input", " forms", " app", "map", "FORM", "f", "d", "set", "row", "apply", "fc", "Form", "parent", "owner", "sp"], "list": ["history", "dl", "li", "ml", "cl", "detail", "type", "state", "ul", "status", "range", "alist", "acl", "L", "data", "tree", "LIST", "log", "test", "pool", "batch", "print", "lists", "l", "now", "lat", "ist", "r", "shape", "the", "queue", "out", "listed", "ls", "index", "al", "map", "old", "layout", "names", "all", "load", "info", "local", "sequence", "st", "def", "show", "table", "filter", "cont", "set"], "i": ["ip", "ori", "c", "li", "y", "bi", "in", "k", "eu", "phi", "multi", "ii", "mill", "I", "id", "u", "ui", "ind", "mi", "iu", "batch", "b", "gu", "gi", "im", "q", "hi", "client", "ami", "x", "is", "ki", "ie", "ti", "index", "major", "ci", "pi", "chain", "ji", "name", "me", "qi", "si", "init", "ix", "di", "ini", "ims", "it", "yi", "sim", "j", "my", "m", "ai", "us", "ic"], "langId": ["langInt", "locById", "posID", "convInfo", "angOne", "posId", "wanOne", "langName", "wanId", "angInt", "wanID", "angById", "langInfo", "posById", "locId", "wanById", "langById", "convID", " langInt", "posOne", "convById", " langInfo", "angId", " langName", " langID", "angID", " langById", "convId", "angName", "langOne", "langID", "locInt", "angInfo", "locName"], "filePath": ["sourcepath", " fileName", "fileSet", "FileSocket", "fileSocket", "projectPath", " fileSocket", "FilePath", "FileName", " fileSet", "fileName", "filepath", "projectName", "FilePATH", "projectSet", "sourcePath", "filePATH", " filePATH", "sourcePATH", "sourceName", "Filepath", "FileSet", "projectSocket", " filepath"], "from": ["fr", "create", "bound", "or", "in", "se", "re", "src", "part", "view", "default", "base", "os", "bean", "html", "this", "pos", "with", "self", "l", "original", "add", "before", "so", "still", "origin", "normal", "ie", "path", "name", "a", "old", "From", "start", "false", "simple", "of", "f", "init", "set", "local", "via", "link", "vol", "st", "entry", "reset", "initial", "store", "empty", "source", "by"], "tmpFilePath": ["tmpfileName", "tempFileLocation", "tmpileUrl", "tmpFolderName", "tempfilePath", "tmpFilenameSet", "tmpilePath", "tmpfileLocation", "tmpfileId", "tmpFileSet", "tmpFileName", "tmpFileId", "tmpfilePath", "tempfileUrl", "tmpileName", "tmpFilenameId", "tmpFilenamePath", "tmpFolderLocation", "tempFileUrl", "tempfileId", "tempFileSet", "tempFileId", "tempFilePath", "tmpFolderId", "tmpFileUrl", "tmpFileLocation", "tmpFilenameName", "tmpFolderPath", "tmpileSet", "tmpfileSet", "tempfileSet", "tmpFilenameUrl", "tmpfileUrl", "tempFileName", "tempfileLocation", "tempfileName", "tmpFilenameLocation"], "to": ["et", "t", "io", "create", "TO", "tom", "top", "te", "or", "phi", "etc", "by", "too", "this", "total", "tt", "file", "l", "b", "temp", "at", "eto", "out", "no", "nt", "To", "format", "news", "f", "target", "o", "it", "bo", "toc", "st", "that", "null", "ta", "pro", "table", "into", "set"], "copy": ["sync", "save", "fire", "where", "scale", "create", "same", "replace", "write", "close", "part", "core", "transfer", "download", "image", "trace", "other", "drop", "clip", "clone", "cp", "cop", "split", "fill", "check", "slice", "policy", "title", "map", "cover", "escape", "clear", "opy", "paste", "move", "delete", "match", "repeat", "set", "force", "link", "lock", "apply", "cap", "Copy", "store", "share", "pixel", "ignore", "remote", "source", "quote", "skip", "push", "remove"], "srcChannel": ["srcEntry", "rcChannel", " srcEntry", " srcChan", "rcChan", "srEntry", "srchannel", "srChannel", "srcChain", "rcchannel", "rcEntry", "sourceButton", " srcButton", "sourcechannel", "srcchannel", "sourceCh", "rcChain", "sourceChain", "ctrchannel", "srChan", "srConnection", " srcConnection", " srcchannel", "sourceChan", "srcCh", "srcButton", "srcChan", "rcCh", "srButton", "sourceConnection", "srChain", "sourceChannel", "ctrCh", " srcCh", "ctrChannel", "srcConnection", "ctrChan", "srCh"], "dstChannel": ["dltMethod", "dbrchannel", "dndChannel", " dbrChan", "dstchannel", "ddestChannel", " dotChannel", "dbrCh", "dotCh", "dotChannel", "dltCh", " dblMethod", "dndchannel", " dotVideo", "dblChannel", "ddestVideo", "destCh", " dstCh", " dstChan", "dltChannel", " dblChannel", "dndChan", "destChannel", "destchannel", "ddestMethod", "dotChan", " dbrCh", "dotVideo", "ddestchannel", " dstVideo", "dblCh", "dndVideo", " dstchannel", "dbrChan", "dltChan", " dbrchannel", "dstCh", " dblCh", "ddestChan", "destChan", "ddestCh", "dstChan", "dotchannel", "dstVideo", " dotchannel", " dbrChannel", " dotChan", " dstMethod", "dblChan", "dstMethod", "dbrChannel", "dblMethod", " dblChan"]}}
{"id1": "16079868", "id2": "665420", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readIntIntMenu", "readIntTolist", "readintoList", "readintoMenu", "readintintoMap", "readIntoMenu", "readintintoMenu", "readIntIntlist", "readintintolist", "readIntToList", "readintoMap", "readintolist", "readintintoList", "readIntintolist", "readIntToMenu", "readIntToMap", "readIntIntList", "readIntoMap", "readIntintoList", "readIntIntMap", "readIntolist", "readIntintoMenu", "readIntintoMap"], "url": ["dl", "location", "nl", "mount", "str", "id", "log", "file", "el", "loc", "mol", "image", "l", "b", "web", "uri", "string", "r", "ssl", "browser", "cert", "input", "open", "mail", "ref", "address", "name", "bel", "ur", "f", "http", "hub", "ll", "link", "domain", "ret", "URL", "char", "from", "xml", "resource", "Url", "window", "rect"], "list": ["level", "t", "v", "detail", "type", "top", "dict", "state", "status", "view", "part", "tree", "LIST", "test", "pool", "collection", "print", "l", "lists", "batch", "relation", "add", "out", "is", "listed", "cache", "map", "name", "format", "n", "get", "p", "all", "network", "info", "rm", "module", "only", "record", "block", "group", "st", "label", "m", "show", "table", "port", "parent", "set", "summary"], "in": ["reader", "bin", "read", "din", " din", "re", "inc", "isin", "rin", "file", "en", "ill", "inner", "add", "inf", "r", "out", "is", "line", "pin", "input", "check", "up", "er", "In", "on", "get", "gin", "all", "val", "conf", "IN", "mn", "con", "sum", "from", "ins", "inn", "cin", "doc", "i", "ic", "source", "by", "and"], "inputLine": ["nameline", "formLINE", " inputline", "httpLin", "httpLINE", "actLINE", "contextLINE", "formLine", "nameBlock", "nextText", "InputLine", "actLine", "inputText", " inputBlock", "htmlLINE", "textLin", "httpLine", "actline", "htmlBlock", "selectRow", "inputLin", "helloLINE", "textLine", "dataLINE", "outputLINE", "nextLINE", "attLINE", "nextLine", "activeLINE", "InputLINE", "helloL", " inputLINE", "htmlline", "activeLine", "Inputline", "dataLine", "httpL", "contextLine", "helloLin", "nameLine", "selectLine", "nameLINE", "textLINE", "outputLine", "selectLINE", "inputL", " inputRow", "inputRow", "commandLINE", "InputBlock", "latLine", "formBlock", "commandLine", "contextline", "latLINE", "formline", "htmlLine", " inputText", "helloLine", "inputBlock", "selectText", "inputLINE", "commandline", "nextRow", "textL", "inputline", "outputline", "attLine"], "commandNameBegin": ["CommandNamesbegin", "commandNameStart", "commandSizeEGIN", " commandSizeMorning", "commandOrderbegin", "commandFamilyEGIN", "commandSizeMorning", "commandFamilyInitial", "commandNameEGIN", " commandSizeBegin", "commandFamilyBeginning", " commandNameBeginning", "commandnameEGIN", "commandNameBeginning", "commandFamilyMon", "CommandNameStart", "commandTypebegin", "commandNamesStart", " commandNameStart", " commandNameEGIN", "commandnamebegin", " commandNameMorning", " commandNamebegin", "CommandNameBeginning", " commandOrderStart", " commandNameBeg", "commandSizeBeg", " commandSizeEGIN", "commandNAMEBeginning", "commandNamesBeginning", "commandLineBeginning", "commandNAMEInitial", " commandSizeBeg", "commandFamilyMorning", "commandSizeBegin", "commandnameBeginning", "CommandNamesBeginning", "commandNamesBegin", "commandnameMorning", " commandNameMon", " commandOrderBeginning", "commandNamesbegin", "commandTypeBegin", " commandNameInitial", "CommandNamesBegin", "commandLineStart", "commandNameMorning", "commandNAMEBegin", "commandnameBegin", "commandOrderStart", " commandOrderbegin", "commandFamilyBegin", "CommandNamebegin", "commandNAMEMon", "commandTypeBeginning", "CommandNamesStart", "commandLinebegin", "commandOrderBegin", "commandNameInitial", "commandNameBeg", "CommandNameBegin", "commandNameMon", "commandnameStart", "commandnameBeg", "commandTypeStart", "commandOrderBeginning", " commandOrderBegin", "commandLineBegin", "commandFamilyBeg", "commandNamebegin"], "commandNameEnd": ["commandTimeend", "cmdNameend", "commandSizeStart", " commandNameStart", "commandNameend", " commandLineEND", "commandSizeEnd", " commandNameend", " commandLineend", "formNameEND", "commandNameStart", "commandTypeBegin", "commandStringStart", "commandLineend", "formSizeEnd", "cmdNameEND", " commandNamesStart", "formSizeEND", " commandNamesEnd", " commandNameEND", "commandTypeend", "commandStringEnd", "cmdTimeEND", "commandLineEND", "commandSizeend", "commandTypeStart", "commandTypeEND", "commandnameEnd", "cmdNameEnd", "commandNamesEnd", "commandnameend", "formNameend", " commandLineEnd", "formNameEnd", "commandTypeEnd", " commandNamesEND", "commandStringEND", "commandStringBegin", "commandLineEnd", "commandSizeEND", "commandNameEND", "formNameStart", "commandTimeEND", "cmdTimeend", " commandNamesBegin", "commandNamesBegin", "commandnameEND", "commandNamesEND", "cmdTimeEnd", "commandNamesend", "commandTimeEnd", "commandNamesStart", "formSizeend", "formSizeStart"], "item": ["object", "li", "app", "unit", "widget", "monitor", "type", "instance", "or", "member", "tree", "base", "this", "el", "Item", "info", "image", "inner", "add", "option", "im", "iter", "mix", "button", "items", "bar", "module", "menu", "index", "hit", "check", "obj", "title", "related", "command", "mem", "exp", "p", "match", "element", "em", "template", "row", "question", "local", "it", "event", "link", "sim", "group", "entry", "label", "m", "store", "article", "task", "owner", "i", "mm", "handler", "rule", "page", "key", "other"], "e": ["et", "c", "t", "le", "ae", "v", "fe", "ev", "te", "eur", "se", "es", "eu", "ef", "oe", "re", "eeee", "ne", "u", "el", "ce", "en", "l", "b", "ze", "ent", "ge", "q", "eg", "r", "ie", "x", "eb", "ue", "de", "err", "end", "a", "er", "n", "ec", "p", "f", "d", "ve", "pe", "be", "o", "event", "one", "w", "ea", "E", "ee", "ex", "m", "g", "h", "i", "error", "ed"]}}
{"id1": "15445861", "id2": "7044685", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyDir", "cpfile", " copyfile", "copyfile", "copyFiles", " cpfile", "cpFile", "cpFiles", " copyDir", " copyFiles", " cpFile", " cpDir", " cpFiles", "cpDir"], "srcFile": [" srcModel", "destPage", "sysLine", " srcfile", " srcLine", "srcModel", "srcPath", "sourceDir", "synWeb", "rcPath", "sqFile", "rcDir", "rcfile", "sourceFile", "sysfile", "synFile", "srcWeb", "sysFile", "srcLine", " srcTime", "sysWeb", "sourceModel", "sourcePage", " srcDir", "destfile", "sqPage", " srcPath", "sourcefile", "srcfile", "sqTime", "srcPage", "synLine", "sourceLine", " srcPage", "rcFile", "synfile", "srcTime", " srcWeb", "sourcePath", "rcPage", "rcTime", "rcLine", "destModel", "srcDir", "sqLine"], "destFile": ["destPage", "DestDir", "gtEmail", "destTable", "DestFine", " destTable", " destFolder", "tomFILE", "destLine", "tomPort", "destEmail", "DestFolder", " destfile", "gtFILE", "sourceDir", "imgfile", "optFile", "tomFile", "destDir", "optTable", "potfile", "sourceFile", "imgFile", "destFolder", "estFile", "estEmail", "destFILE", "Destfile", "tomEmail", "expPlace", "destPort", "portPlace", "potFile", "sourceFine", "destfile", "sourcefile", "DestFile", "destFine", "potPort", "gtPlace", "potDir", "gtLine", "expPage", "destPlace", "gtPort", "imgFine", "gtFile", "DestTable", "expFile", "gtPage", "estFILE", "estPort", "optFolder", "optDir", "portLine", "DestPort", "portFile", " destDir", "portPage", "expLine", " destPort", "imgDir"], "in": ["io", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "ze", "inf", "ain", "inside", "im", "iter", "is", "input", "irm", "al", "up", "In", "on", "old", "gin", "init", "info", "ini", "IN", "con", "it", "from", "ar", "ins", "inn", "cin", "act", "i", "mm", "ic", "source", "by"], "out": ["c", "t", "io", "v", "dis", "can", "write", "OUT", "ne", "user", "auto", "log", "inner", "at", "sys", "client", "gc", "cache", "res", "err", "end", "obj", "nt", "up", "n", "on", "co", "o", "net", "con", "one", "cn", "outs", "it", "ch", "output", "sum", "Out", "ex", "null", "to", "writer", "ou", "aos", "by", "outer", "and"], "buffer": ["history", "binary", "memory", "Buffer", "stack", "pad", "base", "buff", "length", "comment", "total", "raw", "attribute", "bank", "batch", "document", "phrase", "print", "temp", "body", "iter", "word", "bar", "queue", "library", "cache", "reason", "command", "variable", "mem", "buf", "bone", "paste", "frame", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "bridge", "window"], "no": ["NO", "nos", "io", "read", "sn", "po", "ne", "nr", "os", "total", "pos", "go", "na", "lo", "sha", "nn", "never", "none", "mo", "zero", "index", "eno", " No", "orno", "a", "n", "un", " NO", "vo", "start", "ni", "No", "number", "o", "num", "bo", "how", "ano", "yes", "to", "node", "not", "i", "who", "ko"]}}
{"id1": "310182", "id2": "8801436", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "5682569", "id2": "755203", "code1": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"metodo1": ["\u00e9todo1", "\u00e9tulo6", " metoaOne", " metoa6", " metodo01", " metulo1", "\u00e9tuloOne", " metosa6", "\u00e9todoOne", " metoa1", " metulo6", "\u00e9tulo01", " metulo01", " metodo6", " metoa01", "\u00e9todo6", " metosa01", "\u00e9tulo1", " metosa1", "\u00e9todo01", " metosaOne", " metodoOne", " metuloOne"], "temp": ["tem", "t", "tmp", "count", "unit", "mint", "v", "buffer", "coord", "Temp", "status", "max", "vt", "cont", "data", "str", "fac", "dest", "test", "mod", "pt", "result", "timer", "cum", "tc", "iter", "porary", "tr", "index", "EMP", "Temperature", "partial", "cu", "dat", "ptr", "orig", "mp", "p", "cel", "template", "texture", "emp", "pre", "sum", "tim", "unt", "null", "deg", "fake", "current", "alt", "txt"], "flagDesordenado": ["flagDesordennada", "flagDesorensada", "flagDesorenados", "flagDesordinato", "flagDesordennadic", "flagDesordennato", "flagDesordunano", "flagDesorenada", "flagDesordinnada", "flagDesordanated", "flagDesordinnano", "flagDesordenados", "flagDesordanadic", "flagDesordunable", "flagDesendanano", "flagDesordanado", "flagDesordentados", "flagDesordenato", "flagDesorensados", "flagDesordenable", "flagDesorenadic", "flagDesordentado", "flagDesordinnado", "flagDesorensado", "flagDesordinada", "flagDesrunenada", "flagDesendanable", "flagDesendenado", "flagDesordensados", "flagDesordinado", "flagDesrunenados", "flagDesordentada", "flagDesordinated", "flagDesrunenado", "flagDesrunenato", "flagDesordunado", "flagDesordanano", "flagDesorenado", "flagDesrunennados", "flagDesordenano", "flagDesordensada", "flagDesordentato", "flagDesordunada", "flagDesordensated", "flagDesordanable", "flagDesendenano", "flagDesendenada", "flagDesordensadic", "flagDesordennado", "flagDesordinados", "flagDesendanada", "flagDesordenadic", "flagDesrunennato", "flagDesendenable", "flagDesrunennada", "flagDesordenada", "flagDesordennados", "flagDesordensado", "flagDesordinnable", "flagDesrunennado", "flagDesordanados", "flagDesendanado", "flagDesorensadic", "flagDesordanada", "flagDesordenated"], "i": ["ip", "ori", "t", "li", "io", "y", "bi", "status", "in", "ii", "phi", "multi", "xi", "I", "ui", "mi", "iu", "ski", "oi", "batch", "gi", "uri", "im", "iter", "q", "uni", "hi", "cli", "ami", "is", "ki", "ti", "index", "ri", "ci", "pi", "ij", "ji", "chain", "vi", "me", "iri", "qi", "f", "si", "ix", "init", "di", "info", "ini", "ei", "list", "it", "sim", "j", "my", "\u0438", "m", "ai", "zi", "iti", "ic", "us", "s", "g", "by"], "tabla": [" tabelo", "tabelo", " tablo", "tableela", "softlar", "tabela", "celllo", "tablela", "Tablas", "lablla", " tablla", "labla", "bedlar", "celllar", "Tabula", "softela", "tablas", " tabela", "bedela", "tablar", "cellelo", "cellela", "tabula", "Tablo", "softla", "tablelo", "cellla", " tabda", "tablla", "tablo", " tabula", "celllas", "Tablar", "tabda", "Tabelo", "Tablla", "bedla", "labula", "labela", "softula", "Tabela", "Tabla", "bedda", " tablas", "cellda", " tablar", "tableula"]}}
{"id1": "8932510", "id2": "19608872", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doPost": ["actionPre", "doPut", "doPre", "doPOST", "DoPut", "actionPost", " doPre", "actionPut", " doPOST", " doPut", "DoPost", "actionPOST", "DoPOST", "DoPre"], "request": ["object", "memory", "select", "web", "session", "reference", "address", "position", "pair", "frame", "search", "first", "condition", "message", "subject", "change", "initial", "xml", "remote", "order", "server", "this", "client", "time", "application", "java", "art", "req", "get", "project", "record", "context", "error", "requ", "remove", "create", "copy", "user", "QUEST", "document", "self", "post", "setup", "quest", "start", "url", "info", "query", "question", "block", "have", "reset", "call", "resource", "forward", "instance", "re", "connection", "complete", "register", "cgi", "input", "enter", "command", "Request", "http", "container", "report", "store", "current", "form"], "response": ["version", "reply", "respond", "object", "onse", "write", "default", "view", "connection", "respons", "tree", "release", "ce", "document", "image", " responding", "result", "session", "render", "application", "res", "success", "resp", "send", "description", "frame", "event", "one", "site", "context", "output", " Response", "report", "reset", "information", "model", "Response"], "is": ["ip", "tis", "ists", "iris", "in", "es", "sis", "isin", "bis", "isc", "isi", "has", "image", "isp", "was", "bits", "xs", "as", "iso", "lis", "ys", "ois", "its", "IS", "si", "init", "ris", "info", "ims", "ais", "isa", "mis", "iss", "ios", "isl", "ir", "obs", "ins", "icks", "i", "Is", "ips", "ms"], "page": ["content", "object", "age", "point", "view", "stream", "po", "part", "html", "data", "server", "pos", "file", "go", "pool", "document", "image", "next", "post", "result", "wiki", "session", "out", "pages", "browser", "menu", "line", "index", "cache", "address", "title", "url", "p", "pe", "token", "frame", "o", "row", "proxy", "link", "Page", "pc", "message", "entry", "pp", "article", "node", "port", "table", "resource", "sp", "error", "form"], "os": ["io", "ps", "Os", "or", "es", "po", " o", "OS", "ui", "pos", "pool", "so", "oss", "iso", "mo", "ops", "res", "op", "si", "sw", "o", "ios", "oid", "offset", "s", "oos", "ms"], "rootUrl": ["baseURL", "baseUr", "homeurl", "parenturl", "homeURL", " rootURL", "parentUrl", "parentURL", "webDir", "webURL", " rootDir", "baseUrl", "webUr", " rootUr", "baseDir", "homeUrl", "rootDir", "rootURL", "rooturl", "rootUr", "parentUr", "homeUr", " rooturl"], "isMultipart": ["isManipand", "isMulticart", "isMultisparted", "isMultiparted", "isMultiisparted", "isManipage", "isMulticarts", "isManIPage", "isMultisparts", "isMultiisparts", "isMultIPage", "isMultiparts", "isManiparts", "isMultiispart", "isManipart", "isMultispand", "isMultiipage", "isMulticage", "isMultiipart", "isMultiiparted", "isMultIParted", "isMultipand", "isMultipland", "isMultiplart", "isMultispart", "isMultiplarts", "isMultIPand", "isMultispage", "isManIPart", "isManIParts", "isMultipage", "isMulticarted", "isMultiispage", "isMultiiparts", "isMultIPart", "isMultiplage", "isMultIParts", "isManIPand"], "rd": ["ird", "rid", "RD", "fr", "ard", "rg", "dr", "td", "rl", "dk", "rown", "ud", "rob", "ind", "xd", "dd", "ro", "rend", "dra", "vd", "nder", "dig", "hd", "erd", "r", "rer", "nd", "rus", "hr", "adr", "rb", "rc", "ra", "hod", "rh", "ptr", "fd", "rt", "ld", "ord", "rs", "yd", "rw", "rand", "gd", "rr", "red", "rn", "rod"], "upload": ["save", "imgur", "ack", "tmp", "create", "pload", "archive", "transfer", "ud", "file", "insert", "download", "ut", "select", "image", "add", "grab", " Upload", "post", "update", "allow", "install", "input", "ow", "aw", "util", "own", "art", "up", "attach", "Upload", "move", "load", "delete", "execute", "row", "uploads", "fax", "form"], "webUrl": ["WebUrl", "netUrl", "wwwUr", "webPort", "httpUr", "WebURL", "httpUrl", "rootVer", "neturl", "weUrl", "wwwUrl", "wwwURL", "weUr", "webURL", "netUr", "weURL", "netPath", "webUr", "webPath", "rootPort", "weVer", "wwwPath", "weurl", "netURL", "Weburl", "rootPath", "weburl", "rootURL", "httpVer", "httpPort", "WebUr", "wePort", "rootUr", "webVer"], "iter": ["ip", "ator", "li", "former", "cer", "reader", "where", "fer", "iz", "inv", "ver", "orient", "IT", "order", "ind", "inter", "loc", "ipper", "oper", "inner", "ait", "next", "loader", "kit", "dir", "ner", "tr", "er", "iterator", "loop", "tif", "coll", "iv", "init", "train", "it", "valid", "ir", "iner", "walker", "i", "ter", "iver", "ser", "outer", "Iter"], "item": ["ip", "object", "li", "unit", "instance", "status", "or", "member", "in", "order", "base", "el", "file", "Item", "attribute", "image", "error", "other", "im", "hit", "step", "obj", "rule", "up", "mem", "info", "element", "json", "row", "value", "option", "module", "event", "it", "record", "link", "local", "area", "block", "tab", "entry", "stat", "container", "m", "store", "mm", "atom", "word", "source", "key", "iterator"], "name": ["named", "type", "Name", "part", "data", "order", "id", "base", "file", "ame", "prefix", "common", "string", "normal", "path", "no", "family", "alias", "magic", "title", "a", "term", "n", "old", "on", "NAME", "names", "ma", "len", "channel", "o", "module", "event", "local", "size", "block", "one", "cap", "num", "sequence", "label", "resource", "parent", "word", "source", "key", "class"], "baos": ["BAis", "BAoes", "baOS", " baops", "BAoss", "boos", "wais", "daOS", "booS", "booes", "aooss", "BAoS", "kaoes", "waOS", "gaos", "bois", "BAOS", "gaoS", "kaOS", " baoss", "baoss", "baops", "bais", "kaoss", "boo", "daos", "aoOS", "gais", "booss", "daoes", "baoes", "waos", "boops", "BAops", "aoos", "daoss", "gaoss", "boOS", "BAo", "waoss", "kaos", "BAos", "bao", "baoS", " bao", "aooS", "gaOS", " baoes"], "wpIs": ["xpI", "wpShares", "wpIm", "ipInst", "wtShares", "hwIS", "phpis", "cpIS", "wtI", "phpIS", "wtIs", "cpis", "WPI", "hwInst", "wpI", "WPUrl", "phpIs", "wordpressis", "WPInst", "fwI", "wpAre", "wpis", "WPIS", "wordpressIm", "hwI", "ipIs", "wpInst", "cpIs", "fwIm", "WPIm", "wpIS", "ipI", "phpI", "phpShares", "xpShares", "wordpressUrl", "fwIs", "wordpressIS", "fwUrl", "wordpressIs", "wordpressI", "WPIs", "xpIs", "wtAre", "hwIs", "wpUrl", "xpAre", "ipIS", "phpAre"], "u": ["fu", "uv", "io", "ul", "nu", "eu", "uid", "user", "ui", "iu", "l", "gu", "su", "uri", " nu", "hu", "uni", "r", "uf", "ux", "ue", "cu", "uu", "ur", "url", "p", "f", "o", "uj", "tu", "w", "it", "au", "U", "mu", "us", "lu", "ru", "i", "bu", "ou"]}}
{"id1": "18891988", "id2": "1473212", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"getFile": ["selectfile", "GetFile", "getString", "createfile", "Getfile", "selectString", "getfile", "createFile", "getFilename", "selectFilename", "GetString", "GetFilename", "createFilename", "selectFile", "createString"], "serviceName": ["libraryFamily", "serviceNames", "serverName", "ServiceNames", "serviceCode", " serviceNames", "serverType", "serviceType", "ServiceName", "serviceFamily", "serverCode", " serviceType", "libraryName", "ServiceCode", " serviceCode", "ServiceType", "libraryNames", "ServiceFamily", "libraryType", " serviceFamily"], "wsdlLocation": ["wslPath", "awsolLocation", "wsDLLoc", "wslLocation", "wsDLLocation", "wssdPath", "wsolLocation", "wsollocation", "wsDLFolder", "awsdLoc", "wlFolder", "wdlLocation", "wssdlocation", "awsdlLocation", "wsdllocation", "awsolLoc", "awsdlURL", "wsdlURL", "wsolLoc", "wsDLPath", "wsDLURL", "wsdlPath", "wdlLoc", "awsolURL", "wssdLocation", "wslLoc", "awsollocation", "wsdlocation", "wssdLoc", "wssdURL", "wslFolder", "wsdlFolder", "wsdLoc", "wlLocation", "awsdllocation", "wsdURL", "wssdFolder", "wdlPath", "wlLoc", "awsdLocation", "awsdlocation", "wsDLlocation", "awsdURL", "awsdlLoc", "wlPath", "wsdlLoc", "wsdLocation", "wsolURL", "wdlFolder"], "endpoint": ["idpoint", "startpoint", "startpoints", "startPoint", "beginpoints", " endport", "startword", "endpoints", "beginPoint", " endPoint", "Endpoint", "endline", "idPoint", "startline", "bindPoint", "beginpoint", "endword", " endpoints", "Endpoints", " endline", "bindport", "idline", "Endport", "bindpoint", "idpoints", "endPoint", "endport", "bindpoints", "EndPoint", "beginword", "Endword"], "fileLocation": ["filelocation", "FileLoc", "documentPosition", " filePosition", "FileLocation", "documentlocation", "fileLoc", "documentLocation", "documentLoc", " filelocation", "filePosition", " fileLoc", "Filelocation", "FilePosition"], "tempDir": ["tmpPath", " tempPath", "tmpFolder", "tempFolder", " tempUrl", "tempdir", "tmpDirectory", "TempDirectory", " tempFolder", "tempDirectory", "Tempdir", " tempDirectory", "TempPath", "TempFolder", "TempUrl", "tmpUrl", " tempdir", "tempPath", "tmpDir", "tempUrl", "TempDir", "tmpdir"], "url": ["dl", "li", "location", "build", "ul", "conn", "re", "nl", "mount", "str", "base", "loc", "l", "web", "gl", "uri", "il", "https", "cp", "r", "ssl", "browser", "cert", "ls", "open", "job", "mail", "sl", "up", "sur", "bel", "un", "ur", "f", "pl", "github", "http", "service", "ll", "link", "rel", "ret", "URL", "char", "m", "socket", "ctrl", "cr", "Url", "window"], "WSDLFile": ["WSDLFilename", "WSDLLFile", "WIDDLfile", "WSDLLString", "WNDLfile", "WSDELFile", "WSDELFilename", "WIDDLType", "WSDLSType", "WHDLfile", "WNDDLFile", "WSDMLfile", "WHDLFILE", "WSDLLFILE", "WIDLfile", "WSDLSFile", "WIDDLString", "WIDDLFile", "WHDDLFILE", "WSDDLType", "WIDLType", "WHDLFile", "WNDDLFILE", "WSDLSfile", "WSDLType", "WIDLFile", "WNDDLfile", "WSDLFILE", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDQLfile", "WSDMLFILE", "WSDDLFilename", "WSDDLfile", "WIDLString", "WSDLLType", "WHDDLFile", "WSDQLFile", "WSDQLFILE", "WSDLString", "WSDMLFile", "WSDELFILE", "WHDDLfile", "WNDLFILE", "WNDLFile", "WSDLSString", "WSDLLFilename", "WSDELfile", "WSDDLString", "WSDLfile", "WNDLFilename", "WSDDLFILE"], "tmpWSDLFile": ["tmpWSDLLFILE", "tmpWSDLDFile", "tmpWSDLFILE", "tmpWSDlfile", "tmpWSDDLFile", "tmpWSDLLFilename", "tmpWSDlFile", "tmpWIDDLFilename", "tmpWSDLFiles", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWSDDLfile", "tmpWNDLFiles", "tmpWNDLfile", "tmpWSDDLFiles", "tmpWSDLDFilename", "tmpWSDLLFile", "tmpWNDLFilename", "tmpWSDlFilename", "tmpWSDLDFILE", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWNDDLFiles", "tmpWNDDLFile", "tmpWIDDLfile", "tmpWSDLfile", "tmpWNDDLFilename", "tmpWIDLfile", "tmpWSDDLFILE", "tmpWSDLLfile", "tmpWSDLLFiles", "tmpWSDDLFilename", "tmpWNDDLfile", "tmpWSDLFilename", "tmpWIDLFile", "tmpWIDLFilename", "tmpWIDLFILE", "tmpWSDlFiles"], "inputFile": ["InputFILE", "InputPath", "outputStream", "clientFile", "InputDo", "inputPlace", "inputFILE", "inputfile", "errorfile", "inputDo", "infile", "errorFILE", "tmpStream", "intFile", "InputFiles", "indexfile", "interfaceFile", "Inputfile", "inPath", " inputDo", "interfacePlace", " inputfile", " inputSourceFile", "tmpfile", "intFiles", "outputfile", "indexFile", "outputFILE", "errorFile", "inputStream", "inputPath", "inputSourceFile", "outputFile", "interfacefile", "intfile", "inDo", "intFILE", "tmpFILE", "clientFILE", "InputStream", " inputFiles", "InputFile", " inputFILE", "inputFiles", "clientPath", "inFile", "tmpPlace", "tmpSourceFile", "errorStream", "clientFiles", " inputPath", "interfaceSourceFile", "indexFILE", "indexStream", " inputPlace"], "tmpFile": ["tempFilename", " tmpfile", "tmpPath", "mpPath", "inputFILE", "tempFile", "inputfile", "empFile", " tmpFiles", "empFILE", "mpFile", "empFilename", "tmpfile", "tmpFiles", "tempFILE", "tempFiles", " tmpPath", "tmpFILE", "empfile", "tmpFilename", "tempPath", "mpFiles", "mpfile", "tempfile", "inputFilename"], "in": ["c", "t", "io", "bin", "din", "inv", "conn", "stream", "id", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "ln", "inf", "ain", "source", "r", "client", "is", "ic", "input", "In", "n", "init", "o", "IN", "ini", "it", "ch", "from", "ar", "ins", "inn", "cin", "ai", "cont", "ri", "sin"], "out": ["c", "t", "tmp", "io", "buffer", "can", "write", "inv", "conn", "connection", "ne", "by", "os", "auto", "OU", "log", "file", "this", "en", "pool", "at", "sys", "client", "oss", "cache", "obj", "conv", "n", "on", "ao", "co", "all", "o", "conf", "net", "w", "outs", "ch", "group", "Out", "output", "we", "ex", "cm", "null", "to", "lock", "writer", "ou", "aos", "OUT", "outer"], "con": ["c", "can", "conn", "cone", "re", "cal", "Con", "connection", "Conn", "func", "const", "ln", "ain", "tc", "mc", "cp", "cons", "CON", "ws", "conv", "connect", "login", "un", "ran", "co", "soc", "exc", "win", "sec", "cur", "conf", "num", "cn", "cm", "ch", "fc", "com", "cin", "cos", "nc", "fn", "cf", "acon"], "fileLength": ["FILELength", "ileDuration", "fileLen", "fileSize", "objectLength", "channelDuration", "channelLength", "FILESize", "FILEDuration", "ileLen", "objectDuration", "ileSize", "fileFontSize", "channelFontSize", "objectFontSize", "channelSize", "fileDuration", "FILELen", " fileFontSize", " fileDuration", " fileLen", "objectSize", "ileLength", " fileSize"], "channelIn": [" channeledIn", "channelIN", "chanIn", "ChannelOut", "consoleedIn", "chanOut", "ChannelIN", "consoleIN", "clientin", "clientIn", "channeledIn", "clientSet", "clientOut", "channelin", "ChannelSet", "consoleIn", "chanIN", "ChannelIn", "chanSet", "channelSet", "ChanneledIn", "clientIN", "consoleOut", " channelin", " channelIN", "Channelin"], "channelOut": ["chanIn", "ChannelOut", "chanOut", "channelout", "courseout", " channelConn", "courseOUT", "chanConn", "Channelout", "ChannelConn", "channelConn", "consoleIn", "chanout", "ChannelIn", "consoleOUT", "ChannelOUT", "courseIn", " channelOUT", "courseOut", "consoleOut", "consoleout", " channelout", "channelOUT"], "tmpDocument": ["npDocuments", "tmDoc", "tpMedia", "tpDocument", " tmpDocuments", "tmpdocument", "tempDocument", "mkDoc", "tmpDocuments", "tmDocument", "tpFile", " tmpDoc", "tempDoc", "cpDoc", "mpdocument", " tmpdocument", "mkdocument", "tmdocument", "npDocument", "tpDocuments", " tmpMedia", "mpDocument", "cpDocument", "mpDoc", "cpdocument", "tmpDoc", "npFile", "mkDocument", "tmpMedia", "npMedia", "tempdocument"], "nl1": ["nlOne", "NL2", "nel3", "ln2", "pel1", "lnOne", "nl9", "nl0", "NL0", "nl01", "nr1", "sol9", "rn6", "nr01", "rn1", "rn3", "rnOne", "nrOne", "nl2", "sol0", "pelOne", "NL1", "nl3", "ln1", "nl6", "nel6", "pel01", "nel1", "ln0", "sol2", "NL9", "ln01", "nelOne", "ln6", "ln3", "sol1", "ln9"], "i": ["ip", "ori", "li", "y", "io", "v", "span", "bi", "ii", "k", "multi", "key", "xi", "I", "u", "id", "ui", "mi", "gi", "hi", "cli", "ami", "x", "is", "ie", "ti", "index", "ci", "pi", "ij", "ji", "a", "n", "me", "qi", "si", "ix", "init", "di", "info", "ini", "ims", "o", "it", "sim", "j", "\u0438", "m", "ai", "mu", "us", "ic", "ri", "ms"], "node1": ["layer0", "component2", "component1", "NodeOne", "component0", "Node001", "n0", "node0", "node2", "Node2", "layer91", "node91", "layer1", "Node0", " node91", "node001", "nodeOne", "n1", " node0", " node001", "n91", "layerOne", " node2", "ode001", "ode0", " nodeOne", "ode1", "ode2", "nOne", "componentOne", "Node1"], "tmpOut": ["tempIn", " tmpObj", "TempOUT", "npIn", "TempIn", "cmpout", "tempObj", "tmpIs", "mpOut", "mpObj", "cmpOut", "empOut", "tempout", "npOut", "tempOUT", "npObj", "tmpIn", "cmpIn", " tmpIs", "TempObj", "TempOut", " tmpout", "empIs", "npout", "tempIs", " tmpOUT", "tmpout", "mpIn", " tmpIn", "tmpObj", "tmpOUT", "tempOut", "empout", "mpout"], "retVal": ["RetVal", " retTrue", " retValue", "retTrue", "retValue", "RetValue", "RetTrue", "returnval", " retval", "retval", "returnVal", "Retval", "returnTrue", "returnValue"]}}
{"id1": "12869602", "id2": "2511579", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopAllbumments", "test_validate_tag_getTopAloggments", "test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAllbumls", "test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAllalbumes", "test_validate_tag_getTopAlbumments", "test_validate_tag_getTopAlalbumments", "test_validate_tag_getTopAllalbums", "test_validate_tag_getTopAlogges", "test_validate_tag_getTopAloggs", "test_validate_tag_getTopAllalbumls", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAllbums", "test_validate_tag_getTopAloggls", "test_validate_tag_getTopAlalbumes", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopAllbumes", "test_validate_tag_getTopAllalbumments"], "factory": [" facter", "cancy", "fFactory", "liller", "Factory", "Facter", "vactory", "vade", "lacter", "facacter", "facactory", " fancy", "facade", "filler", "vacter", "facFactory", "cacter", "lancy", "cactory", "Fade", "FFactory", " filler", "facter", "lactory", "vFactory", "ciller", "fade", "fancy"], "schemaLocation": ["syalPath", "scheaturelocation", "scheallocation", "schembolLoc", "symalocation", "schemaPath", "scheaturePath", "schemeLocation", "schemePath", "schemasLoc", "semaLoc", "schemelocation", "seaturelocation", "schealLocation", "scheatureLoc", "syallocation", "semalocation", "symaLocation", "seatureLoc", "schembolLocation", "scheatureLocation", "schealPath", "symaPath", "schemaslocation", "semaLocation", "syalLocation", "schemalocation", "schemasLocation", "schemaLoc", "seatureLocation", "schembollocation"], "schema": ["schem", "Schema", "chem", " scheme", "mame", "chema", "cheature", " scheature", "cheEMA", "scheme", "Scheator", "maator", "scheature", " schem", "maEMA", "validature", "scheEMA", "validma", "validm", "ScheEMA", "mama", "validme", "scheator", "Scheme", "cheme", "cheator"], "validator": ["varima", "scheener", " valider", "validigator", "naver", "verator", "variator", "verener", "valider", "verma", "validener", "varier", " validigator", "valener", "verer", "variigator", "valator", " validma", "scheer", "valma", "validma", "valer", "navigator", "navma", "scheator", "navator"], "url": ["dl", "location", "ul", "nl", "mount", "str", "base", "user", "u", "html", "external", "log", "file", "l", "b", "web", "gl", "uri", "r", "ssl", "browser", "res", "sl", "address", "name", "bel", "ur", "get", "f", "http", "service", "channel", "api", "hub", "ll", "link", "abs", "rel", "URL", "char", "null", "resource", "xml", "Url", "window"], "inputStream": ["sourcestream", "feedstream", "inputSource", "feedSteam", "sourceStream", "feedStream", "inputStreamer", "sourceSteam", "Inputstream", " inputSource", "sourceSource", " inputStreamer", "feedSource", "audioStream", "InputStreamer", "inputstream", " inputSteam", "InputStream", "audioStreamer", "inputSteam", "audiostream", " inputstream"], "source": ["reader", "status", "in", "src", "stream", "data", "scope", "str", "file", "series", "inner", "class", "result", "body", "session", "console", "SOURCE", "input", "ource", "sl", "Source", "wrapper", "service", "channel", "sample", "sequence", "response", "sql", "from", "context", "store", "resource", "xml", "sf", "sp", "ser", "iterator"]}}
{"id1": "6988216", "id2": "20924119", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" testQueryQuestion", " executeSimpleQ", " executeBasicQuestion", " testSimpleQuestion", " testSimpleContent", " testRawContent", " testRawQ", " executeBasicQuery", " testQueryContent", " testRawQuery", " testBasicContent", " executeBasicQ", " testRawQuestion", " executeSimpleQuestion", " executeSimpleQuery", " testBasicQ", " testSimpleQ", " testBasicQuery", " testQueryQ", " testQueryQuery", " executeBasicContent", " testBasicQuestion", " executeSimpleContent"], "dummySource": ["dummContent", "dummyStore", "dummInput", "determinedContent", "dancyInput", "daummyResource", "duffySourceFile", "daatumInput", "dancySourceFile", "udeterminedSource", "datalFile", "datumSource", "dummiesResource", " duffySource", "dancyContent", "dummyInput", " dummySourceFile", " dummyInput", "datalSource", "determinedSource", " duffySourceFile", "duffySource", "datumStore", "daatumStore", "udeterminedContent", "dumpInput", "dummyResource", "daummyInput", "dumpStore", "dummiesStore", "dancyFile", "datalParent", "dummiesInput", "daummyStore", "dummyFile", "udeterminedParent", "udummyFile", "duffyContent", "dummSourceFile", "daatumSource", "daatumResource", "daummySource", "dancyParent", "dummyParent", "udummyContent", "udummyParent", "dumpSource", "determinedFile", "udeterminedFile", "udummySource", " duffyInput", "dummySourceFile", "determinedParent", "duffyInput", "datumInput", "datumResource", "datalContent", "dancySource", "dumpResource", "dummSource", " duffyContent", "dummiesSource"], "os": ["et", "oids", "ori", "dos", "io", "ose", "mos", "dis", "Os", "ors", "conn", "ats", "bs", "es", "ros", "or", "js", "des", "ui", "OS", "pos", "om", "oS", "aos", "oa", "bos", "sys", "ot", "oss", "ds", "out", "is", "ows", "oses", "ops", "ys", "ants", "windows", "asis", "uts", "ox", "si", "ols", "los", "fs", "o", "ims", "ost", "ens", "ios", "css", "obs", "osi", "socket", "oes", "cos", "s", "ts", "oos", "ms"], "dummyContent": ["dynamicContent", "determinedInt", "dumpingContents", "DumpMedia", "dumpInt", "deltaMedia", "dumpContent", "determinedContent", "dynamicTemplate", "dynamicCode", "dummyContents", "dummyCode", "dummiesCode", "DummyInt", " dummiesContent", "dumpingContent", " dummiesCode", "DummyMedia", "dummiesTemplate", "dumpMedia", "determinedText", "dumpingTemplate", "deltaText", "dummyInt", " dummyCode", " dummiesContents", " dummyContents", "deltaInt", " dummyTemplate", "dummyMedia", "dumpText", "deltaContent", "DumpText", "dummyText", "dummyTemplate", "dummiesContent", "DumpInt", "DummyText", "dummiesContents", "determinedMedia", "dumpingCode", "dynamicContents", "DumpContent", " dummiesTemplate", "DummyContent"], "source": ["sr", "instance", "status", "in", "se", "src", "scope", "user", "space", "server", "core", "series", "relation", "join", "image", "inner", "result", "google", "uri", "sys", "ie", "SOURCE", "ource", "ace", "spec", "Source", "use", "search", "service", "template", "proxy", "site", "sample", "sp", "sql", "from", "store", "table", "resource", "sf", "s", "pse", "seed", "ser", "sin"], "content": ["version", "text", "txt", "example", "license", "status", "data", "tree", "html", "ext", "comment", "document", "expression", "result", "action", "body", "section", " contents", "path", "Content", "cache", "application", "title", "activity", "format", "command", "quest", "script", "layout", "description", "json", "value", "template", "response", "sequence", "context", "output", "message", "tx", "summary", "ontent", "config", "code", "xml", "article", "node", "resource", "cont", "current", "key", "header", "editor"], "qResult": [" qResponse", "iqResults", "iqReport", "QRes", "iqResponse", "qResponse", " qRes", "QResult", " qResults", "queryResponse", " qView", "qView", "iqResult", "dqRes", "queryReport", "queryResults", "dqResult", "dqView", "qResults", "Qresult", "iqRes", "qReport", " qReport", "queryResult", "queryRes", "QView", "qRes", "qresult", " qresult", "dqresult"], "results": ["features", "terms", "ries", "details", "missions", "Contents", " Results", "posts", "data", "views", "olds", "roads", "products", "xes", "forms", "ults", "assets", "relations", "hips", "result", "photos", "children", "ULTS", "thumbnails", "items", "rows", "pages", "versions", "reports", "objects", "res", "RESULTS", "archives", "actions", "its", "chains", "lections", "members", "Results", "ands", "runs", "users", "resources", "blocks", "tests", "values", "settings", "orders", "events", "s", "times", "ms"], "it": ["et", "ip", "t", "li", "v", "read", "iz", "ul", "in", "ite", "IT", "id", "It", "MIT", "rit", "pit", "ait", "at", "iter", "out", "is", "hit", "ci", "op", "its", "exec", "p", "init", "info", "he", "mit", "st", "lit", "stat", "m", "h", "i", "ic", "they"], "rSrc": [" rSrs", "rDesrc", "crDesRC", "crDesrc", "rSourcers", " rSsrc", "rSlrs", "rSysource", "rSecs", "crSrs", " rScs", "rSrs", "rSysrc", "rSourcesrc", "rSyssrc", "crSsrc", "crSRC", "rSource", "rSRC", " rSource", "crSrc", "rSourceRC", "crDesrs", "rSlcs", "rSlRC", "rSeRC", "rSsrc", "rDesrs", "rDesRC", "rScs", "rDessrc", "crDessrc", "rSlrc", "rSers", "rSourcerc", "rSerc", " rSRC", "rSysRC"], "rSrcIn": ["rSrcOut", "rSetrcIn", "rSncCon", "rSRCIN", "rSrsIN", "rSetsrcOut", "rSsrcIN", "rSsrcInput", "rSetrcin", "rSetrcOut", "rSRCOut", "rSetsrcin", "rSncOut", "rSrcIN", "rSrsIn", "rSsrcOut", "rSldOut", "rSetrcIN", "rSrcin", "rSrsInput", "rSldin", "rSsrcin", "rSrsOut", "rSsrcIn", "rSrcInput", "rSncin", "rSRCIn", "rSldIN", "rSRCCon", "rSetsrcIn", "rSetsrcIN", "rSncIn", "rSldIn", "rSRCin", "rSldInput", "rSldCon", "rSrcCon"], "actualOut": ["actualIs", "finalIn", "actualBytes", "ualEnd", "UALOut", " actualCopy", "actualout", "actuallyIs", "ualIn", " actualIn", "UALIn", " actualBytes", "actualCopy", "actuallyIn", " actualIs", "ualBytes", "ualOut", "actuallyCopy", "realIn", " actualEnd", "realIs", "virtualOut", "actualEnd", "actualIn", "virtualIn", "UALBytes", " actualout", "actuallyOut", "finalOut", "finalout", "realOut", "realCopy", "UALEnd", "ualout"]}}
{"id1": "10451698", "id2": "12034046", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    private InputStream openRemoteStream(String remoteURL, String pathSuffix) {\n        URL url;\n        InputStream in = null;\n        try {\n            url = new URL(remoteURL + pathSuffix);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            in = connection.getInputStream();\n        } catch (Exception e) {\n        }\n        return in;\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "create", "write", "Cop", "core", "archive", "transfer", "file", "download", "continue", "clip", "clone", "cp", "cop", "split", "gc", "crop", "slice", "map", "export", "opy", "co", "move", "perm", "paste", "delete", "proxy", "link", "cat", "Copy", "share", "pixel", "zip", "remove"], "source": ["create", "details", "unit", "instance", "status", "in", "se", "src", "sin", "current", "scope", "base", "space", "sit", "raw", "file", "ce", "image", "inner", "original", "secure", "body", "origin", "ie", "none", "SOURCE", "index", "ource", "cache", "spec", "name", "note", "start", "Source", "get", "use", "init", "http", "target", "service", "directory", "template", "query", "force", "local", "size", "site", "sp", "sql", "from", "subject", "entry", "null", "store", "config", "shell", "resource", "parent", "style", "empty", "remote", "table", "class"], "destinationDirectory": ["targetinationdirectory", "destineApplication", "destinateFolder", "destinationLocation", "destationApplication", "targetinationsFolder", "destinationsFolder", "destinatorInternal", "destineDirectory", "destinationsInternal", "destarationDirectory", "destinateDirectory", "destmentDirectory", " destationDirectory", "destarationInternal", "destineFolder", " destationdirectory", "destmentdirectory", "targetinationsDirectory", "targetinationDir", "destinatorDirectory", "destationFolder", "targetinationFolder", "destinationsDir", "destinatorLocation", "destinationApplication", "destinationDir", "targetinationDirectory", "identinatorLocation", "identinationLocation", "destinatedirectory", "identinatorDirectory", " destinationFolder", "destinationsDirectory", "destationDirectory", "destarationLocation", " destinationApplication", "destmentFolder", "destationdirectory", "destinedirectory", "destmentDir", "targetinationsDir", "destinationFolder", "destinationsdirectory", "destinationsLocation", "identinationDirectory", "destinateApplication", "targetinationsdirectory", "identinationInternal", "identinatorInternal", "destinationInternal", "destinationdirectory", " destationFolder", " destinationdirectory", " destationApplication"], "newDir": ["nextdir", "NewFile", "newsdir", "newsFile", "newsFolder", "NewDir", "newsDirectory", " newDirectory", "newdir", "nextRel", " newFolder", "newDirectory", "nextDir", " newRel", "Newdir", " newdir", "NewDirectory", "newFolder", "NewFolder", "newsDir", "nextFile", "NewRel", "newRel"], "children": ["parents", "may", "modules", "pres", "projects", "ml", "follow", "details", "links", "classes", "each", "unknown", "services", "images", "sub", "bc", "relations", "ports", "nil", "these", "ren", "items", "pages", "child", "reports", "ls", "objects", "gc", "cache", "ids", "Children", "related", "its", "his", "apps", "names", "all", "members", "jobs", "kids", "uploads", "users", "packages", "blocks", "resources", "desc", "lines", "files", "stories", "groups", "keys", "times", "cont", "when", "many"], "i": ["ip", "t", "li", "y", "um", "io", "span", "bi", "in", "ii", "phi", "multi", "point", "key", "I", "base", "u", "id", "ui", "remote", "xi", "iu", "mi", "ski", "oi", "batch", "gu", "gi", "im", "iter", "q", "hi", "client", "x", "is", "ki", "ti", "ie", "index", "ci", "pi", "chain", "uu", "ji", "iq", "ij", "me", "qi", "init", "si", "ix", "di", "json", "ims", "ini", "info", "it", "sim", "j", "you", "my", "ex", "m", "ai", "g", "us", "ic", "ri", "ms"], "newFile": [" newGlobal", "newSourceFile", "NewFile", "goodDir", " newSourceFile", "newsfile", "goodFile", "ewfile", "newsFile", "NewDir", "newsGlobal", "NewLe", "NewGlobal", "createSourceFile", "createDir", "newLe", "NewTh", "NEWfile", "goodSourceFile", "nextDir", "newTh", "newsTh", "createfile", "NEWFile", "nextfile", "createFile", "ewDir", "goodfile", "newfile", "Newfile", "NEWDir", "ewFile", "ewLe", " newfile", "NEWTh", "newGlobal", "nextLe", "nextFile", "newsDir"], "output": ["object", "text", "four", "exit", "io", "monitor", "write", "buffer", "blue", "connection", "stream", "auto", "enabled", "file", "batch", "document", "print", "next", "web", "result", "body", "console", "update", "out", "client", "Output", "put", "admin", "open", "success", "format", "position", "export", "online", "pretty", "cut", "network", "net", "internal", "response", "block", "message", "display", "ilo", "config", "parent", "writer", "current", "connect", "outer"], "input": ["ip", "io", "reader", "buffer", "in", "current", "active", "back", "inc", "upload", "raw", "insert", "ahead", "image", "inner", "add", "before", "inf", "iter", "storage", "out", "child", "operator", "open", "rc", "ink", "op", "start", "Input", "get", "exec", "feed", "init", "info", "unsigned", "internal", "it", "local", "from", "initial", "ic", "error", "form"], "buff": ["sb", "bg", "text", "img", "buffer", "bin", "bound", "qq", "ff", "printf", "bs", "bed", "black", "data", "bf", "fb", "Buff", "tt", "ind", "batch", "b", "cmd", "xff", "uf", "nd", "eb", "mb", "cb", "hold", "cond", "bl", "old", "xx", "buf", "mem", "seq", "comp", "gb", "nb", "pb", "ch", "bo", "cat", "bytes", "tab", "msg", "uff", "box", " buf", "bb", "txt"], "read": ["text", "t", "count", "write", "buffer", "READ", "in", "run", "each", "str", "bind", "stream", "need", "length", "select", "ind", "raw", "test", "en", "print", "add", "before", "give", "iter", "q", " Read", "index", " write", "check", "hold", "end", " count", "ink", "mem", "start", "handle", "old", "get", "send", "d", "feed", "len", "load", "height", "find", "hello", "set", "Read", "like", "query", "tell", "reading", "size", "reads", "seek", "readable", "ready", "wait", "config", "skip", "push", "and"]}}
{"id1": "9261777", "id2": "12172485", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"source": ["content", "text", "where", "details", "status", "copy", "se", "src", "view", "volume", "str", "scope", "back", "base", "lower", "tree", "ui", "file", "ce", "component", "prefix", "language", "expression", "uri", "body", "string", "origin", "clip", "SOURCE", "path", "input", "index", "ource", "check", "title", "reason", "spec", "address", "start", "Source", "script", "use", "init", "target", "search", "service", "template", "query", "info", "site", "size", "sample", "sequence", "context", "sql", "from", "char", "subject", "store", "config", "style", "resource", "parent", "table", "filename", "form"], "destination": ["declinant", "origine", "tempinator", "origend", "declination", "declinations", "distinations", "declinate", "certination", "declacement", "certacement", "distination", "certinator", "combinant", "destacement", "combination", "testino", "testinator", " destinate", "destino", "destinator", "goodacement", "portine", "originator", "goodination", "destinate", "portination", "certinate", "declinator", "origination", " destinator", "portend", " destino", "destinations", "destinant", "destend", "goodinator", "distinant", "tempination", "tempino", "goodinate", "tempinate", "combinations", " destine", "testinate", "combinator", " destend", "distinator", "portinator", "testination", "destine"], "is": ["ip", "ains", "tis", "ps", "dis", "iris", "in", "es", "bs", "js", "sis", "isin", "vs", "bis", "isc", "isi", "mus", "has", "webkit", "ib", "was", "isf", "im", "bits", "iter", "ics", "ist", "sys", "oss", "ie", "iso", "ic", "lis", "nis", "ires", "ois", "its", "IS", "si", "ris", "init", "info", "are", "ims", "ais", "isa", "mis", "iss", "ios", "isl", "abs", "vis", "ir", "obs", "ins", "icks", "us", "zes", "i", "Is", "s", "ns", "ri", "ts", "ms"], "os": ["dos", "ss", "io", "ose", "mos", "dis", "Os", "or", "es", "bs", "OS", "pos", "mot", "bis", "oS", "ones", "aos", "oa", "ks", "bos", "ot", "sys", "oss", "oses", "zero", "ob", "ops", "ys", "asis", "on", "uts", "ox", "ols", "los", "fs", "o", "\u00f3", "ost", "outs", "ios", "css", "obs", "osi", "oes", "cos", "s", "ts", "mes", "ns", "oos", "ms"], "buffer": ["history", "binary", "memory", "Buffer", "padding", "background", "view", "stack", "pad", "buff", "total", "comment", "batch", "available", "document", "phrase", "temp", "word", "button", "bar", "queue", "shape", "library", "cache", "database", "command", "variable", "mem", "buf", "paste", "frame", "template", "row", "event", "sample", "sequence", "block", "message", "append", "display", "table", "window"], "length": ["history", "text", "count", "th", "ENGTH", "type", "Length", "ence", "bow", "needed", "padding", "frequency", "point", "volume", "tail", "pad", "stop", "total", "ind", "full", "collection", "component", "bus", "ty", "l", "integer", "before", "string", "shape", "distance", "split", "path", "duration", "time", "database", "family", "end", "partial", "position", "width", "capacity", "start", "loop", "of", "len", "height", "enth", "character", "number", "load", "hello", "ith", "size", "reading", "sequence", "display", "offset", "ength", "angle", "last", " Length", "ment", "span"]}}
{"id1": "10451698", "id2": "310182", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "create", "write", "Cop", "core", "archive", "transfer", "file", "download", "continue", "clip", "clone", "cp", "cop", "split", "gc", "crop", "slice", "map", "export", "opy", "co", "move", "perm", "paste", "delete", "proxy", "link", "cat", "Copy", "share", "pixel", "zip", "remove"], "source": ["create", "details", "unit", "instance", "status", "in", "se", "src", "sin", "current", "scope", "base", "space", "sit", "raw", "file", "ce", "image", "inner", "original", "secure", "body", "origin", "ie", "none", "SOURCE", "index", "ource", "cache", "spec", "name", "note", "start", "Source", "get", "use", "init", "http", "target", "service", "directory", "template", "query", "force", "local", "size", "site", "sp", "sql", "from", "subject", "entry", "null", "store", "config", "shell", "resource", "parent", "style", "empty", "remote", "table", "class"], "destinationDirectory": ["targetinationdirectory", "destineApplication", "destinateFolder", "destinationLocation", "destationApplication", "targetinationsFolder", "destinationsFolder", "destinatorInternal", "destineDirectory", "destinationsInternal", "destarationDirectory", "destinateDirectory", "destmentDirectory", " destationDirectory", "destarationInternal", "destineFolder", " destationdirectory", "destmentdirectory", "targetinationsDirectory", "targetinationDir", "destinatorDirectory", "destationFolder", "targetinationFolder", "destinationsDir", "destinatorLocation", "destinationApplication", "destinationDir", "targetinationDirectory", "identinatorLocation", "identinationLocation", "destinatedirectory", "identinatorDirectory", " destinationFolder", "destinationsDirectory", "destationDirectory", "destarationLocation", " destinationApplication", "destmentFolder", "destationdirectory", "destinedirectory", "destmentDir", "targetinationsDir", "destinationFolder", "destinationsdirectory", "destinationsLocation", "identinationDirectory", "destinateApplication", "targetinationsdirectory", "identinationInternal", "identinatorInternal", "destinationInternal", "destinationdirectory", " destationFolder", " destinationdirectory", " destationApplication"], "newDir": ["nextdir", "NewFile", "newsdir", "newsFile", "newsFolder", "NewDir", "newsDirectory", " newDirectory", "newdir", "nextRel", " newFolder", "newDirectory", "nextDir", " newRel", "Newdir", " newdir", "NewDirectory", "newFolder", "NewFolder", "newsDir", "nextFile", "NewRel", "newRel"], "children": ["parents", "may", "modules", "pres", "projects", "ml", "follow", "details", "links", "classes", "each", "unknown", "services", "images", "sub", "bc", "relations", "ports", "nil", "these", "ren", "items", "pages", "child", "reports", "ls", "objects", "gc", "cache", "ids", "Children", "related", "its", "his", "apps", "names", "all", "members", "jobs", "kids", "uploads", "users", "packages", "blocks", "resources", "desc", "lines", "files", "stories", "groups", "keys", "times", "cont", "when", "many"], "i": ["ip", "t", "li", "y", "um", "io", "span", "bi", "in", "ii", "phi", "multi", "point", "key", "I", "base", "u", "id", "ui", "remote", "xi", "iu", "mi", "ski", "oi", "batch", "gu", "gi", "im", "iter", "q", "hi", "client", "x", "is", "ki", "ti", "ie", "index", "ci", "pi", "chain", "uu", "ji", "iq", "ij", "me", "qi", "init", "si", "ix", "di", "json", "ims", "ini", "info", "it", "sim", "j", "you", "my", "ex", "m", "ai", "g", "us", "ic", "ri", "ms"], "newFile": [" newGlobal", "newSourceFile", "NewFile", "goodDir", " newSourceFile", "newsfile", "goodFile", "ewfile", "newsFile", "NewDir", "newsGlobal", "NewLe", "NewGlobal", "createSourceFile", "createDir", "newLe", "NewTh", "NEWfile", "goodSourceFile", "nextDir", "newTh", "newsTh", "createfile", "NEWFile", "nextfile", "createFile", "ewDir", "goodfile", "newfile", "Newfile", "NEWDir", "ewFile", "ewLe", " newfile", "NEWTh", "newGlobal", "nextLe", "nextFile", "newsDir"], "output": ["object", "text", "four", "exit", "io", "monitor", "write", "buffer", "blue", "connection", "stream", "auto", "enabled", "file", "batch", "document", "print", "next", "web", "result", "body", "console", "update", "out", "client", "Output", "put", "admin", "open", "success", "format", "position", "export", "online", "pretty", "cut", "network", "net", "internal", "response", "block", "message", "display", "ilo", "config", "parent", "writer", "current", "connect", "outer"], "input": ["ip", "io", "reader", "buffer", "in", "current", "active", "back", "inc", "upload", "raw", "insert", "ahead", "image", "inner", "add", "before", "inf", "iter", "storage", "out", "child", "operator", "open", "rc", "ink", "op", "start", "Input", "get", "exec", "feed", "init", "info", "unsigned", "internal", "it", "local", "from", "initial", "ic", "error", "form"], "buff": ["sb", "bg", "text", "img", "buffer", "bin", "bound", "qq", "ff", "printf", "bs", "bed", "black", "data", "bf", "fb", "Buff", "tt", "ind", "batch", "b", "cmd", "xff", "uf", "nd", "eb", "mb", "cb", "hold", "cond", "bl", "old", "xx", "buf", "mem", "seq", "comp", "gb", "nb", "pb", "ch", "bo", "cat", "bytes", "tab", "msg", "uff", "box", " buf", "bb", "txt"], "read": ["text", "t", "count", "write", "buffer", "READ", "in", "run", "each", "str", "bind", "stream", "need", "length", "select", "ind", "raw", "test", "en", "print", "add", "before", "give", "iter", "q", " Read", "index", " write", "check", "hold", "end", " count", "ink", "mem", "start", "handle", "old", "get", "send", "d", "feed", "len", "load", "height", "find", "hello", "set", "Read", "like", "query", "tell", "reading", "size", "reads", "seek", "readable", "ready", "wait", "config", "skip", "push", "and"]}}
{"id1": "1097146", "id2": "17792212", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentdigested", "getContentdigest", "getMessageDecests", "getMessageDecest", "getMessagedigest", "getMessageDecested", "getMessageDecester", "getContentDigest", "getContentDigested", "getMessageDigester", "getMessageDigests", "getMessagedigests", "getMessagedigested", "getContentdigester", "getContentDigests", "getMessageDigested", "getContentdigests", "getMessagedigester", "getContentDigester"], "input": ["text", "request", "buffer", "any", "state", "in", "active", "human", "data", "unknown", "this", "raw", "file", "quick", "image", "string", "q", "cmd", "missing", "pattern", "focus", "out", "check", "address", "uu", "name", "format", "up", "Input", "password", "url", "p", "qi", "get", "hello", "value", "cur", "qa", "required", "it", "sample", "output", "from", "char", "valid", "null", "initial", "act", "config", "empty", "msg", "xml", "source", "form"], "md": ["pm", " Md", "bd", "MD", "managed", "dh", "pdf", "det", "cd", "med", "dr", "sd", "sm", "sam", "mand", "mt", "mod", "dd", "hd", "mc", "cmd", "ds", "df", "mk", "mb", "ms", "dm", "pd", "nt", "grad", "mp", "d", "comp", "der", "di", "ld", "mn", "od", "cm", "m", "mu", "ad", "mm", "mg", "def"], "bytes": ["qs", "videos", "ings", "terms", "strings", "binary", "classes", "es", "bs", "parts", "forms", "units", "b", "rings", "bits", "pages", "versions", "objects", "ls", "reports", "bags", "windows", "bps", "Bytes", "words", "outs", "lines", "blocks", "nets", "seconds", "users", "files", "values", "latest", "groups", "pieces", "steps", "bles", "keys", "s", "tes", "ms", "clips"]}}
{"id1": "17999474", "id2": "8778962", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipFromfile", "getZipToPath", "getBoxAsLocal", "getZipInfile", "getBoxAsPath", "getBoxFromfile", "getZipInLocal", "getZipAsPath", "getZipInPath", "getZipTofile", "getBoxAsfile", "getZipFromPath", "getBoxFromLocal", "getZipToLocal", "getBoxFromPath", "getZipFromFile", "getZipToFile", "getZipAsfile", "getZipAsLocal", "getBoxAsFile", "getZipInFile", "getBoxFromFile", "getZipFromLocal"], "digOb": [" digObj", "divOcc", " digOcc", "chemObj", "digObject", "divObject", "DigObj", "gradOb", "digEx", "gradObj", "digOcc", " digOB", " digEx", "chemEx", "digOB", "digObj", "divOb", "gradObject", "chemOB", "divObj", "gradOB", "chemOb", "DigObject", "DigOb", "DigOcc", "DigOB", "DigEx", " digObject"], "folderName": [" folderPath", "foldNames", "foldname", "fileSize", "folderNames", "fileKey", "folderSize", " folderNames", "Foldername", " folderSize", "fileName", "folderPath", "fileNames", "foldername", "FolderName", "foldKey", "foldPath", "foldSize", "FolderPath", "foldName", "FolderNames", " folderKey", "folderKey", " foldername"], "tmpFolder": ["cmpParent", "cmpDir", "tempFolder", " tmpDirectory", "mpFolder", "tmpfolder", "tmpDirectory", " tmpfolder", "tempDirectory", "mpParent", "mpfolder", "mpDir", "cmpFolder", " tmpDir", "tempParent", "mpDirectory", "tempDir", "tempfolder", "tmpDir", "tmpParent", "cmpfolder"], "zip": ["ip", "content", "tmp", "io", "gz", "pdf", "jar", "zone", "se", "cloud", "col", "archive", "upload", "csv", "file", "test", "pool", "temp", "post", "cf", "body", "install", "library", "ow", "pack", "mail", "tar", "bag", "exp", "project", "f", "folder", "feed", "pkg", "json", "template", "row", "proxy", "wrap", "lock", "sample", "link", "sp", "sea", "sheet", "Zip", "report", "entry", "z", "xml", "box", "drop", "quote", "form"], "out": ["t", "tmp", "io", "v", "write", "copy", "in", "inv", "os", "auto", "OU", "en", "print", "inner", "ln", "serv", "ent", "flush", "oss", "check", "res", "conv", "up", "n", "co", "all", "list", "o", "set", "net", "one", "outs", "it", "output", "Out", "ex", "null", "ins", "to", "cos", "us", "writer", "i", "sp", "s", "ou", "aos", "OUT"]}}
{"id1": "14783950", "id2": "18731843", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["composeWithzip", "compressWithzip", "compresswithExt", "composeWithZip", "compressByExt", "composeWithExt", "compressWithExt", "compressWithFiles", "composeWithoutExt", "compresswithFiles", "compressByZip", "composeWithFiles", "composeWithoutZip", "compressByzip", "compresswithZip", "compressByFiles", "compressWithoutzip", "compresswithzip", "compressWithoutExt", "composeWithoutFiles", "composeWithoutzip", "compressWithoutZip", "compressWithoutFiles"], "fileList": [" FileLIST", "fileL", "fileIterator", "tileLIST", "pageList", "itemNames", "fileSet", "pageCode", "fileLIST", "fileCode", "pageLIST", "tileIterator", " fileLIST", "pagelist", " fileCode", "resourceNames", " fileIterator", "ileLIST", "itemList", "fileLock", "wordLIST", "pageL", " FileList", "filelist", "resourceLock", " fileSet", "wordList", "wordIterator", "fileNames", "itemLock", "wordSet", " fileL", "ileL", " FileSet", " filelist", " fileLock", "ileList", "pageSet", " fileNames", " FileCode", "ilelist", "tileSet", "tileList", "resourceList"], "zipFileName": ["zFilenameName", "zipFilenamePath", "zFileFilename", "zipFilenameName", "zipDirName", " zipFileNames", "zipfileName", "zFilenamename", "zipFileNames", "zFileName", " zipFileFilename", "zipfileFilename", "zFilename", "zipDirPath", "zipFilenamename", "zFilePath", "zipFilePath", "zipFileFilename", " zipFilePath", "zFilenameFilename", " zipfilePath", "zipileName", "zipfilePath", "zipfileNames", "zipilename", " zipfileName", "zipDirNames", "zipileFilename", " zipfileNames", " zipfileFilename", "zipilePath", "zipFilenameNames", "zipFilename", "zFilenamePath", "zipDirFilename", "zipFilenameFilename", "zipfilename"], "fos": ["loos", "flis", "lfos", "lOS", "Foos", "flOS", "Foss", "FOS", " foos", " fOS", "woss", "lfOS", "foss", "Fos", "wOS", "floos", "fOS", "flos", "los", "lfoos", "foos", "woos", "lfis", "loss", "wos"], "zos": ["zb", "ss", "zar", "ps", "zan", "Sax", "iners", "es", "zin", "js", "rez", "sbm", "sis", "hz", "os", "ippers", "nz", "cz", "zen", "webkit", "ze", "zip", "zer", "zh", "hess", "oss", "ess", "han", "bes", "zero", "zag", "ws", "ossus", "zzle", "eros", "iaz", "enos", "ses", "los", "ez", "jas", "zu", "css", "za", "enz", "zers", "zon", "z", "rys", "zo", "zes", "zi", "zik", "less"], "iter": ["ip", "ator", "li", "former", "cer", "ger", "where", "fer", "reader", "ver", "re", "Iterator", "gener", "orient", "order", "user", "el", "inter", "loc", "ipper", "oper", "inner", "ait", "izer", "Iter", "loader", "kit", "ner", "is", "tr", "er", "ptr", "loop", "its", "exp", "maker", "coll", "iv", "train", "list", "it", "vis", "valid", "ir", "iner", "ee", "walker", "i", "ter", "iver", "ser", "liter", "here", "outer", "iterator"], "fileName": ["fieldname", "FileString", "fNumber", "ileCurrent", "localNAME", " fileNumber", "fileSet", "fileStore", "shortStore", "ileString", "fBody", "getname", "fName", "getSource", "localname", "ileNAME", "ileBody", "localName", " fileSource", "shortSource", "fNames", " fileStore", "ilename", "tableName", "fileBody", "fieldList", "FilePath", "FileName", "ilePath", "FileCurrent", "fileCurrent", "fileNumber", "fileNAME", "fSource", "filePath", " fileSet", "fileSource", "fileNames", "tableSet", "ileSet", "ileName", "fieldNAME", " filePath", " fileString", " fileCurrent", " fileBody", "fileString", "FileNames", " fileNames", "ileSource", "ileList", "Filename", "getStore", "getName", "tablePath", "fString", "fname", "localList", "fieldName", "shortname", " filename", "filename", "ileNumber"], "ind": ["count", "cd", "kind", "med", "td", "pred", "inder", "bind", "md", "Ind", "inc", "pos", "butt", "stick", "div", "loc", "mod", "hend", "draw", "ent", "cod", "cand", "sign", "nd", "index", "cond", "IND", "att", "mind", "n", "ptr", "req", "typ", "d", "pl", "find", "ld", "wind", "num", "j", "dial", "roll", "inn", "red", "i", "seed", "dj", "ded"], "shortName": ["shortType", " shortKey", "shortFilename", "ShortType", "ShortCode", "fullType", "shortKey", "quickString", "smallCode", "fullName", "smallName", "recentname", "smallFilename", "recentFilename", "ShortKey", " shortType", "ShortString", "recentCode", "quickname", " shortString", "fullString", "shortString", "smallname", "shortCode", "fullname", "Shortname", "quickKey", " shortname", "quickName", "ShortFilename", "shortname", "recentName", "ShortName"], "fis": ["ufois", "sfIs", "pris", "sfis", "wois", "ufi", "cfris", "ufris", "ufIs", "sfi", "fois", "hi", "ufis", " fris", "FIs", "pi", "hris", " fIs", "wi", "Fris", "cfois", "wis", "his", "wIs", "pois", "cfis", "fIs", "Fis", "fi", "hois", "cfi", "pis", "sfois", "fris"], "buf": ["img", "cv", "Buffer", "buffer", "bin", "wb", "arr", "bed", "buff", "fb", "Buff", "batch", "b", "bus", "bc", "temp", "vec", "bar", "cmd", "uf", "tr", "cb", "br", "ref", "bl", "fam", "rb", "conv", "var", "bag", "mem", "orig", "aka", "seq", "pkg", "cur", "block", "cap", "cat", "fg", "bytes", "tab", "mu", "msg", "box", "db"], "bytesRead": ["blocksLoad", "blocksRead", "BytesWritten", "bytesNeed", "postsLoad", "bytesLoad", "BytesLength", " bytesNeed", " bytesLength", "usersReady", "postsFind", "secondsWritten", "BytesRead", "postsRead", "flowsLoad", " bytesLoad", "blocksWritten", "bytesFind", "postsReady", "flowsFind", "BytesNeed", "usersFind", " bytesWrite", "bytesWritten", "linesWritten", " bytesWritten", "secondsRead", "linesLength", "bytesWrite", "secondsWrite", "usersRead", "secondsLoad", "flowsRead", "linesRead", "bytesLength", "blocksWrite", "bytesReady", "usersLoad", "flowsReady", "linesNeed"]}}
{"id1": "8069594", "id2": "9857412", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyHeader", " copyfile", " cpDirectory", " cpfile", " copyingDirectory", "CopyDirectory", "CopyFile", " copyingfile", " copyHeader", " copyingFile", "Copyfile", " cpFile", " copyingHeader", " copyDirectory", " cpHeader"], "in": ["bin", "or", "id", "inc", "isin", "rin", "el", "ind", "en", "inner", "l", "inf", "im", "as", "is", "input", "irm", "In", "n", "on", "old", "gin", "init", "info", "o", "IN", "ini", "local", "it", "st", "from", "ar", "ins", "inn", "cin", "xml", "h", "i", "mm", "ic", "s", "source", "by"], "out": ["t", "io", "v", "write", "inv", "ne", "help", "os", "OU", "log", "file", "l", "b", "at", "ent", "update", "gt", "ot", "oss", "end", "nt", "up", "op", "name", "n", "on", "target", "o", "net", "one", "w", "it", "outs", "output", "Out", "ch", "ex", "null", "to", "parent", "msg", "i", "s", "ou", "OUT"], "inChannel": [" inFilter", "cinCommand", "inButton", "issueFace", "inChan", "cinChan", "cinChannel", "inputChannel", "inVolume", "innChannel", " inHandler", "InChannel", "outchannel", " inchannel", "InHandler", "binVolume", "netChannel", " inChan", "cinButton", "netVolume", "netChuck", " inFace", "inClient", "inchannel", "iChan", " inConnection", "innChan", " inCommand", " inButton", "inChuck", "ichannel", "netClient", "inputConnection", "inputChan", "iChannel", "inHandler", "inConnection", "inCommand", "InChan", " inChuck", "inputchannel", "innFilter", "issueCommand", "iHandler", "inFilter", "outChan", " inClient", "Inchannel", "inFace", "binChuck", "cinFilter", "binClient", "binChannel", "cinFace", " inVolume", "issueButton", "outConnection", "issueChannel"], "outChannel": ["outSection", "tmpChan", "inButton", "noteChannel", "inChan", "outerButton", "courseChain", " outCategory", "onChan", "outCategory", "netField", " outChain", "outputchannel", "outchannel", "tmpCategory", "netChannel", "noteButton", "onCategory", "inchannel", "tmpButton", "courseSection", " outChan", "tmpChannel", " outSection", "netSection", "netChain", "onButton", "outputChan", "outerChannel", "outButton", "outputConnection", "outputChannel", "noteChan", "inConnection", "courseChannel", "outerChan", "outChan", " outchannel", "onChannel", "inCategory", "outField", " outConnection", "noteCategory", "outChain", "courseField", " outButton", "outerCategory", "outConnection", " outField"]}}
{"id1": "21754659", "id2": "18974466", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getButtonSonico", "getButtonDonida", "getButtonSonida", "getButtonDonido", "getbuttonSonida", "getbuttonSonico", "getbuttonSonilo", "getButtonLeonido", "getbuttonSonido", "getButtonDonico", "getButtonLeonico", "getButtonLeonida", "getButtonDonilo", "getButtonLeonilo", "getButtonSonilo"], "buttonSonido": ["positionSonido", "labelSONphp", "fieldsoningo", "buttonSonano", "buttonHonilo", "buttonSunao", "ButtonSonao", "buttonSONilo", "ButtonSunico", "buttonSonicho", "buttonNorthingo", "buttonsonilo", "buttonSunata", "labelSONido", "buttonJonphp", "buttonDenicho", "buttonSynido", "buttonSunido", "ButtonSunao", "buttonBoningo", "keySonardo", "secondSonicho", "buttonJonida", "fieldSonida", "secondSynido", "buttonNorthano", "labelSonido", "buttonSonao", "keysonilo", "buttonJonidable", "buttonSonata", "secondSynidable", "buttonJonito", "buttonSynicho", "buttonSynphp", "keyson\u00ed", "fieldsonano", "buttonJonao", "fieldSoningo", "ButtonSonico", "buttonSonito", "positionSonito", "buttonJonilo", "buttonsonardo", "buttonBonida", "buttonSunilo", "buttonSonardo", "keySonido", "positionJonico", "buttonsonano", "buttonSONico", "buttonsoningo", "buttonHonardo", "fieldSonido", "buttonBonata", "labelSonida", "buttonBon\u00ed", "buttonDenidable", "buttonBonilo", "ButtonSonata", "labelSONida", "buttonSONida", "buttonSynidable", "buttonSONila", "buttonHon\u00ed", "fieldSonano", "buttonNorthida", "buttonJonicho", "buttonNorthido", "keysonido", "buttonSunito", "buttonsonido", "buttonBonao", "buttonJonico", "secondSynito", "buttonJonido", "buttonSONphp", "buttonsonida", "buttonDenito", "labelSonila", "buttonSonidable", "fieldsonido", "buttonSonilo", "buttonJonata", "ButtonSunata", "keySon\u00ed", "positionJonito", "buttonSonida", "buttonBonido", "buttonSoningo", "buttonSynito", "secondSynicho", "buttonSunico", "buttonSonphp", "labelSonphp", "positionJonilo", "ButtonSunido", "buttonBonano", "keysonardo", "secondSonido", "positionSonico", "buttonSONido", "positionJonido", "buttonBonardo", "buttonJonila", "positionSonilo", "buttonSynida", "labelSONila", "secondSonidable", "buttonDenido", "fieldsonida", "buttonSon\u00ed", "buttonBonico", "buttonHonido", "secondSonito", "buttonSONito", "buttonSonico", "buttonSynila", "keySonilo", "buttonSonila", "ButtonSonido", "buttonson\u00ed"], "e": ["t", "ese", "ae", " ie", "ev", "te", "es", " ate", "AE", " ke", " pe", "ie", "ED", " ge", " ve", "a", "er", "ing", "me", "pe", " fe", "event", "E", "ee", "act", " sent", " who", "ed"], "fc": ["c", "tf", "cv", "FC", "rl", "abc", "WC", "etc", "uc", "bf", "fb", "inc", "fa", "isc", "dc", "bc", "fab", "tc", "mc", "cc", "ic", "icc", "lf", "fm", "gc", "mac", "rc", "conv", "ec", "RFC", "irc", "coll", "soc", "f", "fd", "fs", "fp", "con", "vc", "pc", "fl", "anc", "ifa", "fi", "ctrl", "nc", "fn", "cf", "lc"], "returnVal": ["retValue", "retval", "ReturnVal", " returnValue", "ReturnVAL", "resultVAL", "retVal", "ReturnValue", "Returnval", "resultValue", "resultval", "resultVal", "returnValue", " returnval", " returnVAL", "returnVAL", "returnval", "retVAL"], "file": ["io", "create", "buffer", "type", "fe", "data", "tree", "base", "user", "this", "FILE", "full", "File", "disk", "document", "image", "dir", "uri", "ile", "single", "input", "path", "time", "spec", "name", "format", "handle", "url", "get", "f", "http", "info", "channel", "template", "fp", "local", "link", "block", "output", "message", "valid", "files", "null", "stat", "show", "to", "table", "resource", "page", "parent", "word", "source", "form"], "rutaGlobal": ["RutoLocal", "rutanGlobal", "rutaglobal", "redutaGeneral", "RutoGlobal", "rutoStatic", "redutaLocal", "RutaGlobal", "RutoRemote", "redutaDefault", "rutenGlobal", "Rutaglobal", "RutaLocal", "rutiDefault", "rutaStatic", "rutiFile", "rontoLocal", "rutoLocal", "rutoRemote", "rutoglobal", "rutiRemote", "rutiStatic", "rutoGlobal", "rutenRemote", "rutaRemote", "rutenStatic", "redutanDefault", "RutaRemote", "rutiglobal", "rutanLocal", "rutaGeneral", "rutoFile", "RutoFile", "redutaGlobal", "rutenglobal", "redutanGeneral", "rontoGlobal", "rutiGlobal", "rontoDefault", "rutanDefault", "rutenLocal", "RutoStatic", "rutiGeneral", "rutanGeneral", "redutanLocal", "rontoGeneral", "rutaLocal", "redutanGlobal", "RutaFile", "rutenFile", "rutaFile", "rutaDefault", "rutiLocal", "Rutoglobal", "RutaStatic"], "rutaRelativa": ["rutaRELativa", "rutaRELATiva", "rutaRelantiv", "rutaRelATivo", "rutaRELATiv", "rutaRelativ", "rutaRELitiva", "rutaRelantiva", "rutaRELitivo", "rutaRelitiv", "rutaRelatiiva", "rutaRelatiivo", "rutaRelativo", "rutaRELATivas", "rutaRelATiv", "rutaRelantivo", "rutaRelatiiv", "rutaRELATivo", "rutaRELitivas", "rutaRelantivas", "rutaRelitivas", "rutaRelATiva", "rutaRELitiv", "rutaRelitivo", "rutaRELativo", "rutaRelativas", "rutaRelATivas", "rutaRELativ", "rutaRelitiva", "rutaRelatiivas", "rutaRELativas"], "fis": ["flis", "dfois", "vois", "dfis", "dfiss", "fiss", " fais", "ros", "df\u00eds", "dfisa", "viss", "dfais", "lfisa", " fois", " fiss", "fois", "lfiss", "flys", "fais", "flisc", "f\u00eds", " fisa", "ris", "flos", "fisa", "fys", "lf\u00eds", " fisc", "vis", " fys", "rys", " f\u00eds", "vais", "risc", "fisc", "lfis"], "fos": ["ioses", "woes", "foes", "mos", "mops", "wios", "fows", "fops", "woses", "fios", "iios", "hos", "fdoss", "woss", " foss", "fdaos", "foss", "hios", "vos", "faos", "vows", " fops", "vops", "fdos", "foses", "moes", "mows", "fdoes", "hoss", "waos", "ios", " faos", " fows", "ioss", "voes", " foes", "hoses", "wos"], "canalFuente": ["canallfucer", "canalFuestro", "canallFuper", "canalfuelia", "canallFuente", "canalFUent", "canelFaelia", "canelFuante", "canalfumelon", "canalFaent", "canalFaante", "canalFaestro", "canalPotper", "canallFuent", "canalFuencia", "canalfuestro", "canelFaent", "canallFuencia", "canalFient", "canalFaelia", "canelFuent", "canallFuestro", "canallfumelon", "canalFraencia", "canallfuestro", "canalFramelon", "canalFUelia", "canelFaente", "canalFucer", "canalfuente", "canelFuelia", "canalFuante", "canallfuent", "canalFiente", "canalFaente", "canalFuper", "canalPotmelon", "canallfuper", "canelFuente", "canalFuelia", "canalFacer", "canalPotente", "canallFucer", "canallfuente", "canalFUente", "canallFumelon", "canalfuencia", "canelFaante", "canalfucer", "canalfuper", "canalfuante", "canalFiestro", "canalFUante", "canalFicer", "canallfuencia", "canalFraper", "canalFuent", "canalfuent", "canalFraente", "canalFumelon", "canalPotencia"], "canalDestino": ["canaldOrigine", "canalNegina", "canalsDestina", "canaldDestina", "canaldOrigination", "canalsDestinian", "canalDescina", "canalDescination", "canalOrigination", "canalNegination", "canalDestine", "canaldestinian", "canalOrigine", "canalNegino", "canalDescine", "canalsdestina", "canalDestinian", "canalsdestination", "canalsDestination", "canaldestination", "canalsdestino", "canalsDestino", "canalDestination", "canaldDestino", "canalOrigino", "canaldestina", "canalOrigina", "canalDescino", "canaldDestination", "canaldOrigina", "canalsdestinian", "canalDestina", "canaldestino", "canalNeginian", "canaldOrigino", "canaldDestine"]}}
{"id1": "838844", "id2": "21824901", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "647224", "id2": "19251426", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["putFiles", "saveFiles", "uploadImage", " uploadfile", "putfile", " uploadImage", " uploadFiles", "uploadFiles", "putImage", "savefile", "saveFile", "putFile", "saveImage", "uploadfile"], "inputFile": ["imgOne", "infoFilename", "inputFILE", "inputfile", " inputLe", "inputField", "InputFiles", "Inputfile", "inputResource", "imgLe", "targetField", "fromField", "evalField", "imgFile", "outputLine", " inputfile", "inputLe", "outputPath", "imgLine", "updateOne", "infoFile", "updateFile", "thisLine", "targetFILE", "outputfile", "inputLine", "evalFile", "targetResource", "inputPath", "fromResource", "InputLine", "fromFile", "inputOne", "inFILE", "thisPath", "updateLe", "outputFiles", "fromFILE", "inLine", "infoFILE", " inputFiles", "thisfile", " inputFilename", " inputFILE", " inputLine", "InputFile", "inputFiles", "inFilename", " inputPath", "evalResource", "inFile", "inputFilename", "evalFILE", "infoLine", "updateLine", "thisFile", " inputOne"], "targetFile": ["sourceFiles", "outputDir", "targetPath", "detailString", "targetString", " targetFilename", "TargetFile", " targetString", "tofile", "toDir", " targetFILE", "outputDate", "TargetString", "sourceDir", "targetFilename", "outputFolder", "TargetPath", "sourceFile", "detailDir", "TargetFiles", "outputPath", "targetDir", "targetDate", "toFile", "toFolder", "targetFILE", "sourceDate", "outputfile", " targetPath", "sourcefile", " targetDir", "targetfile", "outputFilename", "targetFiles", "targetFolder", "detailFILE", "detailFile", "sourceFolder", "outputFiles", "sourcePath", "sourceFilename", " targetDate", "TargetDir", "TargetFILE"], "outputFile": ["sourceFiles", " outputGe", "outputDir", "inputLog", "removePlace", "displayFILE", "targetDirectory", "outFile", "outputPlace", " outputDir", "inputfile", "inputDo", "putFile", "noGe", "putPlace", "sourceDir", "displayPlace", " outputDirectory", "displayStore", "nullStyle", "noPlace", "targetFilename", "outDir", "sourceFile", "nofile", "targetDir", "outModel", " outputLog", "inputDirectory", "outFiles", "outputfile", "outputDo", "outputFILE", "displayFile", "sourcefile", "removeFile", "outfile", "putfile", "nullfile", "targetfile", "targetFiles", " outputStore", "removeStore", " outputStyle", "outputFilename", "targetLog", "outputLog", " outputModel", "outputFiles", " outputFILE", "removeFILE", "outDo", " outputFilename", "inputDir", "outStyle", "targetModel", " outputPlace", "inputFiles", "putGe", "nullFile", "outputStore", "inputModel", "nullModel", " outputfile", "outputDirectory", " outputDo", " outputFiles", "noFile", "outputStyle", "outputModel", "outputGe", "inputFilename"], "in": ["io", "read", "bin", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "l", "ze", "inf", "ain", "inside", "iter", "ro", "mc", "im", "is", "input", "al", "In", "on", "per", "init", "info", "ini", "IN", "like", "con", "it", "ar", "ins", "inn", "cin", "act", "ai", "i", "mm", "ic", "ri", "source", "by"], "out": ["t", "println", "io", "v", "dis", "can", "write", "by", "os", "auto", "log", "print", "inner", "b", "ln", "at", "console", "sys", "ot", "client", "put", "cache", "res", "err", "end", "obj", "screen", "name", "nt", "up", "n", "on", "co", "all", "list", "conf", "IN", "net", "o", "con", "cn", "outs", "it", "vol", "Out", "output", "sum", "report", "null", "we", "ex", "to", "cos", "g", "writer", "s", "ou", "aos", "OUT", "outer", "and"], "line": ["detail", "lin", "lane", "inline", "range", "point", "nl", "column", "comment", "log", "LINE", "phrase", "l", "ln", "cell", "eline", "Line", "lo", "stroke", "entity", "rule", "chain", "ine", "command", "ide", "frame", "row", "query", "edge", "record", "sample", "block", "field", "sequence", "lock", "message", "link", "entry", "label", "node", "code", "word", "page"], "bytes": ["gs", "terms", "ies", "oms", "uses", "classes", "es", "bs", "gments", "parts", "ales", "xes", "frames", "gets", "ones", "books", "errors", "bits", "lements", "ges", "ites", "pages", "ows", "rows", "bes", "ls", "comments", "odes", "bps", "Bytes", "otes", "cells", "les", "ices", "amples", "ends", "outs", "lines", "seconds", "blocks", "nets", "reads", "files", "comes", "values", "steps", "bles", "times", "vals", "ips", "tes", "units", "sofar"]}}
{"id1": "7149578", "id2": "3767903", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"parseContent": ["readContent", "parserContents", "readMedia", " parseHTML", "parserMedia", " parseContents", "readHTML", "parseHTML", "parserContent", "readContents", "parseContents", "parseMedia", "parserHTML", " parseMedia"], "streamLimiter": ["resourceLimititing", " streamLimititter", "streamLimited", "StreamLimitor", "streamlimiter", "streamRangeitor", " streamLimititing", "streamMillitable", "Streamlimitter", "streamLimitier", "resourceLimititable", "streamLockier", "streamlimier", "StreamLimite", "resourceLimiter", "streamlimiting", "Streamlimiter", "streamRangeiter", "streamlimer", "StreamLimited", "streamLockiter", "streamMilliter", "Streamlimitor", " streamLimer", "streamLimier", "Streamlimier", "Streamlimited", "resourceLimiting", "streamlimited", "streamLimititing", "StreamLimitter", "streamLimitited", "streamLimer", "resourceLimititer", "StreamLimiter", "streamLimite", "streamLimitter", "streamLimititable", "streamLockited", "streamLimitor", "streamRangeitter", "streamLiting", "streamLiter", "resourceLimitter", "streamLimiting", " streamLimiting", "streamLitable", "streamRangeite", " streamLimititer", "streamMilliting", "streamlimite", " streamLimitter", "streamLitter", "streamlimitter", "streamLimititer", "Streamlimite", "resourceLimitable", "streamMillitter", "streamlimitor", "resourceLimititter", "streamLockitter", "streamLimititter", "streamLimitable", "StreamLimier"], "forcedLang": [" forcedLig", " forcedlng", " contentlig", " contentLang", " forcedLlang", " contentlang", " contentUig", " forcedlang", " contentLanguageang", " contentLng", " contentllang", " contentLanguageng", " contentLig", " forcedllang", " contentlng", " forcedlig", " forcedLng", " contentUang", " contentUlang", " contentLanguagelang", " contentUng", " contentLlang", " contentLanguageig"], "charset": ["cherset", "charsant", "scartsset", "chashesect", "chipsset", "chashespace", "chorsSet", "channelarsett", "choset", "CHarset", "chorset", "chartset", "capsetter", "chaptersum", "scarsel", "chararset", "whaptersen", "whaptersett", "scartsel", "chordsett", "channelashesset", "capsET", "chanksect", "chosetter", "charsect", "charatsen", "Charset", "chararsiet", "scarsant", "charpetter", "chipsetter", "chaptersal", "channelashespace", "chararsET", "chapspace", "chasen", "CHapsET", "CHorset", "scartset", "chacterspace", "charpant", "chasetter", "channelasheset", "chashesetter", "echARSET", "charsET", "chapsett", "chipset", "charpet", "CHarsect", "chatsiet", "chipsant", "charsen", "charsetter", "chordset", "charspace", "carsen", "CHorsetter", "chapset", "chapsET", "chatsett", "Charsett", "chrasET", "chactersetter", "CHorsect", "chapterspace", "charsset", "chatsetter", "chapsSet", "chararsen", "charpale", "chatsect", "chaptersect", "chipsel", "chipsET", "chacterset", "chararsetter", "charsiet", "chartsel", "chearsett", "chatspace", "chankset", "cARSetter", "CHapsett", "chrasetter", "charpset", "scarset", "CHapset", "echarspace", "chARSen", "chashesSet", "capset", "capsale", "chatset", "chartsant", "whaptersect", "CHarspace", "charatsiet", "charatsetter", "chaptersetter", "chatorsET", "chorsect", "charsum", "chearspace", "chersET", "chactersET", "wharsen", "chosET", "chARSetter", "chaset", "chatorsett", "charpET", "chARSET", "chaptersen", "chipspace", "chashesset", "Charsetter", "charactersET", "charsSet", "charatset", "chatsum", "cARSet", "chasal", "CHarsET", "chapsale", "scartsant", "chactersSet", "chearsum", "chanksett", "echARSet", "echarsET", "chARSal", "chapsetter", "chapterset", "channelarspace", "wharsett", "CHorsSet", "CHarsetter", "chararsSet", "chanksetter", "chersetter", "chatsen", "CharsSet", "carsal", "characterset", "chashesett", "CHarsett", "chanksen", "CHarsSet", "cheapsum", "carsetter", "chaptersett", "whapterset", "charactersSet", "chapsum", "chrasect", "chosSet", "chordsET", "CharsET", "chatorspace", "chersale", "charsel", "wharset", "cARSen", "chARSett", "carsale", "echarset", "chARSet", "CHapspace", "charsale", "chartsett", "chatorset", "chanksiet", "cheapset", "charsett", "chraset", "cARSal", "echARSpace", "charactersetter", "chartsset", "chearset", "cheapspace", "chARSSet", "chARSpace", "cheapsett", "channelashesett", "chrasSet", "chartspace", "carsET", "charpel", "channelarset", "scarsset", "carset", "wharsect", "chorsetter", "echarsetter", "chasheset", "chARSset", "charsal", "echARSetter", "chordsetter", "channelarsset"], "sourceDocument": ["sourceMedia", "resourceRoot", "sampleTransaction", "SourceDoc", "srcDocuments", "targetDocument", " sourceDoc", "SourceDocument", "SourceDocuments", "resourceDoc", "targetDoc", "sourceFile", "srcMedia", "sampleRecord", "resourceDocument", "sourcePage", "srcTransaction", "sourceRoot", "contentMedia", "thisDocuments", "contentTransaction", "sampleDocument", "srcPage", "sourceDocuments", "contentRecord", "SourceFile", "srcRecord", "thisDocument", "sampleMedia", "sourceRecord", " sourceDocuments", " sourceRoot", " sourcePage", "srcFile", "contentDocument", "SourcePage", "sourceTransaction", "thisDoc", "sourceDoc", "targetRoot", "srcDocument", " sourceFile"], "fieldValueItem": ["fieldvalueEntry", "fieldVALUEArea", " fieldValueitem", "fieldValueIt", "FIELDValueValue", "fieldvalueItem", "rowValueValue", "fieldItemValue", "fieldReferenceValue", "fieldsValueObject", "fieldFieldItemImage", "fieldVALUEitem", "fieldsValueItemImage", "fieldInfoEntry", "fieldValueArea", "fieldKeyItem", "fieldVALUEEntry", "fieldvalueitem", "fieldValuesInfo", "fieldValueResult", "rowValueitem", " fieldvalueItemImage", "fieldVALUEItemImage", "fieldValueEntry", "fieldValuesItem", "fieldItemInfo", "fieldItemResult", "fieldvalueItemImage", "fieldsValueResult", "fieldReferenceItemImage", " fieldValuesItems", " fieldValueInfo", "fieldItemArea", " fieldvalueEntry", "fieldItemEntry", "fieldItemitem", "fieldListInfo", "fieldFieldValue", " fieldvalueitem", "FIELDValueEntry", "fieldItemItemImage", " fieldValueItemImage", " fieldvalueIt", "FIELDKeyItemImage", "fieldValuesitem", "FIELDKeyValue", "fieldKeyItemImage", "fieldListItem", " fieldValueEntry", "fieldItemObject", "fieldInfoItem", "fieldValueItemImage", " fieldValuesItem", "fieldValueitem", " fieldValuesInfo", "fieldVALUEResult", "fieldValuesItems", "FIELDValueItemImage", "FIELDValueItem", "fieldVALUEIt", "fieldInfoIt", "rowValueItem", " fieldvalueItem", "fieldVALUEValue", "fieldValueItems", "fieldItemItems", " fieldValueItems", "fieldReferenceEntry", "fieldValueInfo", " fieldValueIt", "fieldFieldEntry", "fieldListItems", "fieldFieldItem", "fieldInfoItemImage", "fieldKeyEntry", "fieldListitem", "FIELDKeyEntry", " fieldValuesitem", "fieldReferenceItem", "fieldValueObject", "fieldItemItem", "fieldKeyValue", "fieldsValueItem", "FIELDKeyItem", "fieldVALUEObject", "rowValueArea", "fieldvalueIt", "fieldValueValue", "fieldVALUEItem"], "charsetWasNull": ["charssetWasNone", "charsetWasUnknown", "charsetWrittenUnknown", "charsetWerenull", "charsectDidNULL", "charssetPreviouslyInvalid", "charsetPreviouslyInvalid", "charsectDidNull", "charsetWereNull", "charsectWasNULL", "charsetEverUnknown", "charsetWasNULL", "charsectDidnull", "charsetWasSet", "charsetEverValid", "charssetWasInvalid", "charsetterWasNull", "charsETWerenull", "charsetterEverNULL", "charsETWasnull", "charsetterWasSet", "charsetAlreadyNone", "charsetPreviouslyValid", "charsETWereValid", "charsetWereNULL", "charsetUsedNull", "charsETWereChanged", "charssetWasNull", "charsetOriginallyNULL", "charsetDidnull", "charsetEverSet", "charsETWasChanged", "charsetWrittenNull", "charsetEverNone", "charsetIsChanged", "charsetEverNull", "charsectWasNull", "charsetterEverSet", "charsetWasnull", "charsetEverNULL", "charsetDidNull", "charsetWereChanged", "charsetUsednull", "charsetWrittenSet", "charsetWasInvalid", "charsectWasnull", "charsetPreviouslyNull", "charssetPreviouslyNone", "charsetPreviouslyNone", "charsetWasNone", "charsetAlreadyInvalid", "charsetAlreadyNull", "charsetAlreadyValid", "charsetterEverUnknown", "charsetterEverNull", "charsETWasNull", "charsetWereValid", "charsetOriginallyUnknown", "charssetPreviouslyNull", "charsetWrittenNULL", "charsetDidNULL", "charsetIsNULL", "charsetterWasUnknown", "charsetOriginallyNull", "charsetUsedValid", "charsetOriginallySet", "charsetWasChanged", "charsetIsNull", "charssetPreviouslyValid", "charsetUsedChanged", "charsETWasValid", "charsetEverInvalid", "charsetterWasNULL", "charssetWasValid", "charsETWereNull", "charsetIsValid", "charsetIsnull", "charsetWasValid"], "writer": ["written", "reader", "buffer", "write", "worker", "wire", "stream", "comment", "external", "auto", "attribute", "document", "inner", "loader", "word", "string", "console", "update", "creator", "ner", "out", "driver", "riter", "writing", "rew", "counter", "format", "variable", "builder", "wrapper", "writ", "caster", "Writer", "network", "wright", "unsigned", "w", "output", "writers", "walker", "null", "master", "WR", "handler", "to", "owner", "wrote", "ter", "window", "access", "outer", "iterator"], "htmlProvider": ["cssConsumer", " htmlParser", "htmlAdapter", "dbStore", "httpPath", "httpProvider", "tmlAdapter", "httpReader", "htmlReader", "contentPath", "webAdapter", "contentHost", " htmlVersion", "webSource", " htmlReader", "tmlProv", "cssProvider", "htmlProv", "htmlPort", "httpSource", "dbParser", " htmlPlayer", " htmlPort", "cssAdapter", "htmProvider", "contentVersion", "htmlPlugin", "htmlConsumer", "webProvider", "htmlHost", "tmlSource", "htmlPath", "htmVersion", "tmlPlayer", "tmlConsumer", "htmReader", " htmlConsumer", "htmPlugin", " htmlSource", "contentParser", "tmlStore", " htmlHost", "tmlPath", "dbProv", "tmlProvider", "htmlParser", "tmlParser", " htmlAdapter", "tmlReader", "htmlPlayer", "tmlPort", "contentSource", "dbProvider", "httpPort", "htmlVersion", "webPlayer", "httpParser", " htmlProv", "htmHost", "tmlPlugin", " htmlPlugin", "contentProvider", "htmlSource", "htmlStore", " htmlStore", "cssProv"], "contentType": ["requestTime", "wordLength", "messageTime", "keyForm", "mediaType", "questTime", "requestType", "keyTime", "wordTYPE", "loadTYPE", "questtype", "requestLength", "contentLength", "questType", "contentDiff", "mediatype", " contentDiff", "messageLength", "messageDiff", " contentLength", "mediaTime", "keytype", "loadType", "mediaForm", "contentTime", "contentTYPE", "wordType", " contentTYPE", "keyType", "loadLength", "messageType", "questForm", "requestDiff", "contentForm", " contentTime", "contenttype"], "contentTypeCharset": ["contentTypeCasue", "contentTypeChasue", "contentTypeCharsen", "contentTypeChatsett", "contentTypeCharse", "contentTypeChartse", "contentTypeChARSet", "contentTypeChatsetter", "contentTypeChapsets", "contentTypeChaptersetter", "contentTypechatsett", "contentTypechothesetter", "contentTypeCasetter", "contentTypeCHatsen", "contentTypeChartsant", "contentTypeChorset", "contentTypechothesant", "contentTypeChatsets", "contentTypeChapterset", "contentTypeCARSET", "contentTypeCharsetter", "contentTypeClarset", "contentTypeChARSue", "contentTypecharsant", "contentTypeChasET", "contentTypeCherset", "contentTypeClersetter", "contentTypeChartset", "contentTypeCARSet", "contentTypeCHarsetter", "contentTypeChARSett", "contentTypeCHatsetter", "contentTypeChothesET", "contentTypeCHatsport", "contentTypeChothesSet", "contentTypeChatset", "contentTypechatset", "contentTypeCaset", "contentTypeClerset", "contentTypeCasET", "contentTypeChatsport", "contentTypeChartsET", "contentTypecharsSet", "contentTypechatse", "contentTypeChothesetter", "contentTypeCharsue", "contentTypeClersET", "contentTypeChapsite", "contentTypeCarsue", "contentTypeCHarset", "contentTypeChatse", "contentTypeChARSET", "contentTypeChapset", "contentTypeCHatset", "contentTypeChotheset", "contentTypechatsET", "contentTypeCharsets", "contentTypeChARSen", "contentTypeChatsET", "contentTypeClarsen", "contentTypeChARSport", "contentTypeClarsET", "contentTypeChartsSet", "contentTypeChorsetter", "contentTypeChARSetter", "contentTypecharsett", "contentTypeCarsets", "contentTypeCharsport", "contentTypeChartsett", "contentTypeCharsant", "contentTypecharsets", "contentTypeCharsite", "contentTypeCarsET", "contentTypeChaptersport", "contentTypeChothesite", "contentTypecharsite", "contentTypecharsET", "contentTypeChersET", "contentTypeChartsetter", "contentTypeCarset", "contentTypeChapsET", "contentTypeCarsetter", "contentTypeChothesets", "contentTypeCharsSet", "contentTypeClersen", "contentTypeCharsett", "contentTypeChersen", "contentTypeChersant", "contentTypeChersSet", "contentTypeClarsetter", "contentTypeChARSe", "contentTypecharse", "contentTypeChorsET", "contentTypecharsetter", "contentTypeCARSets", "contentTypeCharsET", "contentTypechothesSet", "contentTypeChersetter", "contentTypeCHarsport", "contentTypeChasetter", "contentTypecharset", "contentTypeChaset", "contentTypeChorsue", "contentTypeChaptersen", "contentTypeChothesant", "contentTypechotheset", "contentTypeCARSetter", "contentTypeCHarsen", "contentTypeChatsen", "contentTypeChasen", "contentTypeChARSets"]}}
{"id1": "5142039", "id2": "22611968", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"uncompress": ["unompract", "UnCompress", "uncompract", "uncompact", "unapplate", "unappact", "UnCompact", "UnCompract", "Uncompress", "Uncompact", "Uncomplate", "unappress", "unCompract", "unomplate", "unompress", "unComplate", "unappract", "UnComplate", "unompact", "unCompress", "uncomplate", "unCompact", "Uncompract"], "readPath": ["loadDir", "ReadId", "writeP", "readDir", "writepath", "loadName", "ReadFile", " readName", "readUrl", " readpath", "readId", "readName", "writeTime", "readablePath", " readP", "readCh", " readDir", "writeFile", " readUrl", "writeCh", " readTime", "readpath", " readPos", "ReadTime", "loadPath", "ReadP", " readId", "ReadPath", "writeId", " readCh", "readPos", "readableCh", "Readpath", "baseP", "writeUrl", "loadP", "readFile", "readableUrl", "writePos", "ReadUrl", "readP", "readTime", "readablePos", " readFile"], "mkdir": ["kir", "makefolder", " mkir", "makeir", " mkDir", "kDir", "workdir", "kfolder", "workDir", "workfile", "mkfile", "kdir", "makeDir", "mkDir", " mkfolder", "makefile", "mkir", "makedir", "workir", " mkfile", "mkfolder"], "arcInputStream": ["ecStreamStreamer", "ecInputStreamer", "arcAudioSteam", "arcArchStreamer", "ecStreamStream", "arcStreamSteam", "arcInputTrans", "ecInputStack", "ascAnalysisStream", "arcInputForm", "arcInPath", "arcRawStream", "arcStreamStack", "arcArchStream", "arcUpContext", "arcExecContext", "ecStreamSteam", "pcInputSteam", "arcExecSteam", "arcInputSteam", "arcStreamStream", "arcStreamStreamer", "arcExecTrans", "arcReadStream", "arcInForm", "arcReadStack", "ascInputForm", "arcInputStreamer", "arcInputStack", "ascAnalysisPath", "arcExecStream", "arcAnalysisStream", "arcArchStack", "pcInputContext", "ecStreamStack", "ascInputPath", "pcUpTrans", "arcAnalysisForm", "arcUpSteam", "arcAudioContext", "arcRawForm", "ascInputStream", "arcInStream", "pcUpStream", "arcUpStream", "arcArchSteam", "arcReadStreamer", "pcUpSteam", "arcInputContext", "pcUpContext", "arcReadSteam", "arcUpTrans", "pcInputTrans", "arcAnalysisPath", "arcAudioTrans", "pcInputStream", "ascAnalysisForm", "arcRawPath", "arcInputPath", "ecInputStream", "ecInputSteam", "arcAudioStream"], "bis": ["sb", "atis", "dos", "rison", "bones", "iris", "bi", "bh", "bs", "vor", "bf", "BS", "isin", " Bis", "vs", "oi", "liner", "pins", "webkit", "bits", "sys", "oss", "is", "bes", "pin", "ls", "iso", "nis", "bps", "bil", "ubis", "ints", "ris", "ses", "opus", "los", "fs", "onis", "bp", "ios", "fps", "obs", "ubs", "rys", "bid", "cin", "mes", "uds", "bb"], "baseDir": ["bufferFolder", "basedDir", " basedir", "boundFile", "BaseDr", "boundDir", "baseFile", " baseFolder", "baseFolder", "basedir", "boundPath", "bufferdir", "BaseFile", "basedFolder", " baseDr", "BaseDir", "bufferDir", "baseddir", "BasePath", "boundDr", " baseFile", "baseDr"], "basePath": [" basePage", "basePoint", "newDir", " basePoint", "readDir", "baseTime", "BaseHalf", "bTime", "basePort", "asePath", "BasePoint", "baseHalf", " baseAnd", " basePod", "bufferForm", "baseSet", "aseHas", "bPort", " baseNow", "readName", "asePage", "bufferPort", "BaseName", " baseSet", "basePod", "basPath", "aseDir", " baseHas", "readPage", "bufferTime", "basPort", "asePod", "newPath", " baseHalf", "readPod", "baseForm", "baseNow", "bDir", "bufferPath", "bForm", "BaseDir", "baseHas", "baseP", "newAnd", "BaseNow", "newNow", "BaseSet", "bufferDir", "newHalf", "BaseAnd", "bP", "aseSet", "bPath", "basePage", "BasePath", "bufferP", "basDir", "baseAnd", "basP", "BaseForm", "readPoint", "readHas", "BaseTime", "aseName", "newPoint"], "schema": ["verge", "symas", "schege", "sema", "Schema", "semas", "chema", "seema", "verma", "seme", "syname", "seege", "sedule", "verme", "scheme", "seement", "Schedule", "chemas", "schename", "Schemas", "sydule", "Schege", "Schename", "schement", "schedule", "seeme", "Schement", "syme", "chename", "Scheme", "schemas", "cheme", "verment", "syma"], "baseName": ["basNAME", "caseUnique", "commonNames", "baseNames", "basedName", "fixedTitle", "aseNAME", "basName", "caseNames", "BaseUnique", "basename", "barePath", "BaseName", "fixedPath", "basedTitle", "basedPath", "fixedNAME", "bareTitle", " basename", "aseKey", " baseKey", "fixedName", "asename", "basKey", "baseNAME", "baseUnique", "baseTitle", "commonUnique", "basedNAME", " baseNAME", "BaseNames", "caseName", "commonName", "bareName", "bareNAME", "baseKey", "basname", "aseName"], "entry": ["pty", "ry", "member", "se", "data", "connection", "comment", "attribute", "ce", "inter", "existent", "add", "next", "e", "result", "je", "cell", "ent", "rent", "piece", "ie", "item", "index", "check", "entity", "obj", "enter", "nt", "name", "ace", "Entry", "escape", "http", "info", "list", "match", "row", "directory", "rance", "office", "element", "record", "link", "nel", "event", "context", "valid", "char", "ex", "null", "see", "empty", "zo", "table", "RY", "zip", "cont", "word", "key", "header"], "writePath": ["riteTh", "WritePort", "writeP", "ritePort", "createKey", "writeKey", "writeName", "createPath", " writeName", "riteP", "WriteLog", "riteHead", "WriteName", "writData", "WriteKey", "WritePath", "createName", "createPal", "newTh", "ritePath", "writLog", "newPath", "newHead", " writePal", "writePal", "readTh", "WriteData", "riteLog", "writeHead", "writeData", "riteData", "writeLog", "newP", "writePort", "writeTh", "WritePal", "writPath", "readP", " writeKey", "readHead", "writPort"], "dirName": ["folderConf", "folderDef", " dirConf", "detName", "directoryName", "dbDef", " dirname", "folderName", "dirNAME", "dirKey", "directoryDef", "detname", "folderNAME", "foldername", "dirname", "detConf", " dirDef", "dirDef", "directoryKey", "dirConf", "directoryNAME", "detDef", "dbNAME", "dbKey", "dbName", "folderKey"], "bos": ["oids", "dos", "nos", "bones", "bin", "bi", "bh", "bs", "fits", "js", "os", "BS", "bas", "pins", "webkit", "aos", "bits", "acs", "oss", "bes", "bat", "bol", "banks", "eros", "boards", "stones", "oops", "ols", "los", "jas", "outs", "bo", "ios", "obs", "zo", "ths", "ods", "uds", "oos"], "i": ["ip", "t", "li", "io", "y", "bi", "in", "ii", "phi", "multi", "I", "id", "u", "mi", "print", "l", "b", "gi", "iter", "q", "hi", "x", "is", "index", "ci", "pi", "a", "n", "p", "qi", "ni", "si", "info", "di", "ini", "o", "ei", "php", "it", "j", "m", "ai", "mu", "zi", "h", "ic"]}}
{"id1": "3024992", "id2": "411595", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2null_"], "baout": ["BAouth", "dboul", "caout", "BAin", "BAOut", "dbin", "gaouth", "gaout", "gaoul", "caOut", " bain", "dbouth", "BAouts", "baouts", "bain", "baouth", "gain", "buin", "cain", "cait", "abain", "abait", "bait", "abaout", "buOut", "BAoul", "BAout", "baoul", "buouts", " baOut", "dbout", "abaOut", "baOut", "BAit", "buout", " baouts"], "out": ["tmp", "io", "gr", "write", "in", "pool", "serv", "result", "sys", " OUT", "res", "err", "er", "n", "o", "gen", "net", "outs", "it", "Out", "output", "ex", "null", "ser", "OUT"], "writer": ["println", "widget", "reader", "buffer", "write", "worker", "killer", "data", "this", "usher", "file", "print", "inner", "document", "client", "driver", "player", "NULL", "riter", "er", "nw", "builder", "maker", "processor", "writ", "woman", "Writer", "target", "wright", "service", "channel", "w", "rw", "output", "null", "handler", "wrote", "window", "outer"]}}
{"id1": "620855", "id2": "2221297", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionUpdate", "DoDateFix", "DoDatecheck", "doDateFix", "doVersionsCheck", "doDatecheck", "doDateUpdate", "DoDateCheck", "DoVersionCheck", "DoDateUpdate", "DoVersionUpdate", "doVersioncheck", "doDateCheck", "doLicenseFix", "doVersionscheck", "doLicenseUpdate", "DoVersionFix", "doVersionsFix", "doLicensecheck", "doLicenseCheck", "doVersionsUpdate", "DoVersioncheck", "doVersionFix"], "view": ["VIEW", "widget", "cv", "v", "buffer", "manager", "View", "host", "views", "tree", "help", "html", "server", "controller", "this", "eye", "file", "blade", "document", "image", "print", "review", "self", "component", "web", "cell", "console", "q", "update", "out", "client", "browser", "iew", "input", "index", "check", "open", "util", "engine", "layout", "get", "wrapper", "http", "row", "query", "hl", "tv", "block", "context", "display", "report", "subject", "show", "doc", "see", "call", "table", "model", "window", "page", "form"], "url": ["lb", "dl", "location", "v", "org", "ul", "rl", "host", "nl", "mount", "str", "html", "id", "log", "file", "loc", "lr", "l", "b", "language", "gl", "web", "uri", "string", "oul", "r", "client", "ssl", "browser", "path", "ls", "sl", "address", "bel", "ur", "date", "f", "pl", "github", "http", "json", "hl", "ll", "link", "rel", "URL", "char", "null", "socket", "Url"], "in": ["reader", "mat", "din", " din", "stream", "asin", "inc", "isin", "rin", "file", "l", "b", "inner", "ln", "inf", "ain", "body", "vin", "source", "out", "is", "input", " IN", "In", "n", "gin", "f", "init", "info", "IN", "mn", "ins", "inn", "cin", "i", "sin", "kin"], "bin": ["bg", "binary", "reader", "buffer", "din", "bi", " din", "conn", "bed", "lib", "pipe", "by", "buff", "sam", "rin", "file", "inner", "b", "ln", "stock", "spin", "loader", "out", "abin", "cache", "bl", "rb", "bur", "ran", "mem", "thin", "gin", "len", " bins", "win", "nb", "con", "local", "bn", "ebin", "inn", "cin", "cos", " Bin", "sin", "obin", "mon"], "line": ["level", "text", "le", "lin", "lane", "inline", "state", "range", "se", "point", "part", "base", "col", "column", "comment", " Line", "el", "file", "log", "liner", "LINE", "print", "l", "ln", "trace", "cell", "body", "iter", "Line", "string", "eline", "lo", "cmd", "section", "path", "ice", "ls", "no", "job", "err", "chain", "ine", "ide", "load", "frame", "channel", "row", "one", "record", "link", "sample", "block", "lines", "cat", "field", "char", "entry", "style", "store", "code", "port", "word", "page"], "version": ["vers", "scale", "river", "license", "v", "usage", "type", "serial", "status", "translation", "ver", "VER", "volume", "release", "vision", "software", "test", "python", "image", "language", "string", "update", "client", "versions", "virtual", "browser", "iso", "hash", "video", "index", "major", "title", "spec", "name", "format", "command", "Version", "position", "project", "feature", "date", "description", "match", "number", "value", "info", "tag", "sequence", "latest", "VERSION", "resource", "ion", "key", "form"], "build": ["th", "bor", "ship", "uild", "where", "binary", "unit", "boost", "built", "ver", "lib", "dev", "release", "full", "log", "test", "print", "add", "b", "update", "install", "hash", "work", "hold", "util", "develop", "ble", "old", "Build", "builder", "arch", "project", "date", "use", "load", "building", "match", "bug", "dist", "be", "tag", "link", "ward", "latest", "struct", "round", "style", "last", "fail", "make", "db", "other"]}}
{"id1": "22022715", "id2": "22114133", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"digest": ["dested", "digests", "decest", "mnist", "mdest", "decge", "Digge", "mdests", "dest", "Digate", "den", "digine", "mnests", "mdested", "digen", "mdum", "decate", "digge", "Digine", "mdist", "digested", "dine", "mnest", "date", "mden", "mnen", "mdine", "digate", "dum", "dist", "dge", "Digest", "decested", "dests", "digist", "Digested", "Digum", "digum"], "s": ["sb", "text", "t", "c", "ss", "y", "ps", "strings", "v", "ats", "js", "str", "space", "sv", "sq", "l", "b", "e", "string", "r", "is", "ls", "a", "n", "p", "f", "ses", "o", "S", "sts", "sql", "bytes", "m", "h", "ts", "i", "ms"], "ret": ["t", "tmp", "det", "arr", "re", "RET", "rem", "back", "reg", "over", "ext", "data", "Return", "mt", "az", "test", "xt", "Ret", "jp", "rets", "result", "ert", "gt", "out", "r", "uf", "tr", "res", "repl", "elt", "att", "found", "ref", "nt", "ft", "buf", "resp", "pet", "rt", "val", "gb", "rm", "rs", "arg", "it", "cat", "report", "reset", "ts", "cont", "rep", "txt"], "md": ["pm", " Md", "bd", "MD", "managed", "dh", "pdf", "det", "cd", "med", "dr", "sd", "sm", "mand", "mt", "ind", "mod", "dd", "hd", "del", "mc", "cmd", "ds", "df", "mk", "mb", "nd", "dm", "mo", "mail", "pd", " MD", "d", "der", "di", "ld", "rm", "man", "mn", "od", "met", "m", "red", "mm", "mg", "ms", "and"]}}
{"id1": "11475527", "id2": "15799935", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDataFromLocation", "addTextFromurl", "addTextFromURL", "addDatafromUrl", "addDatafromurl", "addDataFormUrl", "addTextFormUrl", "addDataFormLocation", "addDataFromurl", "addTextFormLocation", "addDataFromUrl", "addTextFormurl", "addDatafromLocation", "addTextFormURL", "addDataFormurl", "addTextFromLocation", "addDataToUrl", "addDataTourl", "addDataToURL", "addDataToLocation", "addTextFromUrl", "addDataFormURL", "addDatafromURL"], "theurl": ["teurl", "theloader", "hefile", "theuri", " thefile", "thurl", "heloader", " theUrl", "heuri", "teuri", "teUrl", "heUrl", "thefile", "TheUrl", "heurl", "thfile", "Theuri", " theuri", " theloader", " theURL", "teURL", "theURL", "heURL", "thloader", "theUrl", "thUrl", "TheURL", "Theurl"], "line": ["text", "day", "le", "zone", "lin", "lane", "status", "inline", "point", "comment", " inline", "LINE", "liner", "print", "l", "ln", "cell", "Line", "source", "string", "eline", "ner", "stroke", "ice", "email", "chain", "ine", "name", "online", "lined", "frame", "row", "record", "link", "sample", "block", "sequence", "message", "valid", "char", "entry", "code", "node", "rule", "page", "header"], "in": ["t", "reader", "bin", "read", "din", "conn", "or", "ac", "id", "inc", "isin", "rin", "mi", "en", "inner", "l", "serv", "inf", "ain", "lo", "mc", "out", "r", "proc", "is", "ic", "input", "pin", "open", "phys", "al", "In", "n", "old", "gin", "f", "ma", "init", "win", "o", "IN", "con", "it", "st", "from", "ins", "inn", "cin", "ai", "again", "i", "include", "source", "oin"], "data": ["content", "text", "io", "reader", "read", "buffer", "DATA", "stream", "pipe", "user", "ata", "this", "raw", "file", "join", "da", "bus", "next", "result", "body", "client", "out", "dec", "input", "cache", "dat", "a", "d", "feed", "info", "query", "size", "ad", "writer", "window", "def", "iterator"], "e": ["c", "t", "le", "ele", "y", "ae", "v", "te", "or", "se", "es", "eeee", "re", "oe", "eu", "ne", "ce", "b", "ze", "ge", "r", "x", "ie", "ue", "err", "de", "ine", "er", "a", "ec", "n", "me", "p", "ve", "pe", "d", "f", "be", "element", "o", "event", "E", "ee", "entry", "ex", "m", "g", "h", "i", "error", "ed"]}}
{"id1": "4531653", "id2": "3745402", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"md5": ["MD4", " md3", "md7", "sha3", "MD5", "MD3", "sha7", " md4", "sha4", "MD7", "sha5", "md3", "md4", " md7"], "data": ["content", "text", "any", "type", "serial", "padding", "DATA", "html", "id", "os", "ata", "this", "raw", "batch", "image", "now", "result", "string", "sha", "input", "no", "cache", "name", "dat", "a", "format", "command", "foo", "d", "json", "info", "value", "hello", "block", "message", "output", "bytes", "valid", "table", "msg", "mu", "txt"], "md": ["pm", "bd", "MD", "managed", "dh", "pdf", "det", "cd", "sd", "sm", "mand", "mt", "ind", "mod", "da", "dd", "hd", "dir", "mc", "cmd", "ds", "df", "mk", "mb", "nd", "dm", "amd", "de", "pd", "nt", "mp", "d", "der", "di", "ld", "rm", "mn", "od", "m", "msg", "red", "mm", "db", "mg", "ms"]}}
{"id1": "12171364", "id2": "4798332", "code1": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"getFrameworkFactory": ["getFramwareLoader", "getFramernelInterface", "getFramenceService", "getFramwareService", "getFramernelFactory", "getFramenceInterface", "getFramwareInterface", "getFramenceLoader", "getFramernelLoader", "getFrameworkseworkInterface", "getFrameworkseworkService", "getFrameworkLoader", "getFramenceFactory", "getFrameworkswareLoader", "getFrameworkService", "getFrameworkswareService", "getFrameworkseworkFactory", "getFrameworkseworkLoader", "getFrameworkswareInterface", "getFrameworkInterface", "getFramwareFactory", "getFrameworkswareFactory", "getFramernelService"], "url": ["lb", "sb", "dl", "ml", "org", "ul", "rl", "re", "nl", "mount", "str", "html", "user", "base", "el", "file", "loc", "lr", "l", "b", "gl", "loader", "web", "uri", "r", "deb", "ssl", "browser", "ls", "res", "mail", "ref", "sl", "address", "bel", "ur", "f", "pl", "github", "http", "ll", "hl", "link", "rel", "abs", "URL", "fl", "char", "resource", "Url", "bb"], "br": ["sb", "bg", "fr", "bd", "ctr", "io", "vr", "gr", "Br", "bm", "bh", "dr", "shr", "bs", "mr", "str", "nr", "rem", "rob", "el", "lr", "pr", "b", "jp", "bt", "bc", "wr", "ber", "bar", "ab", "r", "browser", "eb", "tr", "gc", "hr", "repl", "bl", "rb", "buf", "bro", "it", "bp", "rel", "block", "abs", "sh", "cr", "bridge", "BR", "bn", "bb"], "s": ["qs", "gs", "ains", "t", "sb", "ss", "y", "ps", "v", "state", "ats", "bs", "less", "es", "hs", "js", "str", "sm", "os", "als", "des", "full", "csv", "raw", "sv", "eps", "sq", "gets", "series", "cs", "comm", "has", "sort", "ves", "string", "xs", "as", "ds", "is", "tes", "ls", "ys", "sl", "ws", "n", "sw", "search", "ims", "rs", "S", "sts", "stats", "w", "abs", "sp", "sql", "sym", "ins", "syn", "m", "z", "g", "sf", "ts", "i", "ns", "h", "set", "ms", "txt"]}}
{"id1": "12146394", "id2": "12869602", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"md5Crypt": ["md3Dec", " Md3Enc", "md5crypt", "md3Enc", "md4Crypt", "md2Enc", " Md5Crypt", " Md5Dec", "md4Enc", "md3crypt", "md2Crypt", "md4Dec", "md5Enc", "md3Crypt", "md5Dec", " Md3Crypt", "md2Dec", "md2crypt", " Md5Enc", " Md3crypt", " Md5crypt", "md4crypt", " Md3Dec"], "key": ["text", "y", "state", "k", "data", "prime", "Key", "cert", "address", "blow", "iv", "token", "pair", "list", "message", "char", "ek", "null", "change", "act", "ion", "KEY", "seed", "box", "version", "any", "host", "file", "icon", "prefix", "gem", "client", "piece", "x", "none", "index", "policy", "ace", "root", "net", "event", "link", "entry", "ey", "keys", "ca", "window", "by", "type", "poly", "default", "user", "id", "length", "air", "phrase", "image", "string", "hash", "ice", "item", "no", "mac", "check", "er", "password", "start", "p", "json", "value", "query", "block", "to", "table", "source", "ip", "str", "base", "ce", "test", "input", "chain", "name", "note", "ke", "sum", "ex", "code", "word", "form"], "salt": ["sash", "save", "psave", "seash", "Siv", "hiv", "hALT", "unsalt", "Sil", "SALT", "cass", "sig", "siv", "pig", "Sol", "tsALT", "sass", "pALT", "sol", "Sash", "Salt", "seALT", " sass", "calt", " shet", "psALT", "slash", " sol", " sint", "Salted", "salted", "chet", "cig", "sil", "Sert", "unsalted", "tsalt", "halt", "Sint", "hig", "seil", "unsig", "psalt", " sig", " sALT", "sert", "shet", " save", "Save", "unsALT", "Sig", " salted", "Sass", "piv", "slalt", "tsol", "slALT", "sealt", "slil", "psass", "tsave", "palt", "sint", "sALT", " sert"], "_md": ["_____dm", "_mg", " _mn", " _dm", "___mn", " _sd", "_____mg", "_dm", "_mn", "_____mp", " _mand", "_____md", "_____mn", "_sd", " _MD", "_cmd", "___MD", " _df", "_____mb", "_MD", "_mb", " _cmd", "_mand", "_mk", "_mp", "___md", "_df", "___dm"], "md2": ["dd5", "sdTwo", "mb2", "mode4", "mode2", "md6", " md1", "rm6", "mand5", "md1", "cmd52", " md5", "modetwo", "sd1", "mdTwo", "cmdto", "cmd6", "dd1", "ddtwo", "mdtwo", "sd2", "ddTwo", "cmd2", " md6", "mandto", "mdto", "mb4", "cmd4", "rm2", "mand4", " mdTwo", "md5", "mb52", " md4", "mb5", "rm4", "mand2", "cmd5", "dd2", "md52", "mode5", "cmdtwo", "sd5", " mdto", " md52", "rm5", "md4", "dd4"], "abyFinal": ["abyDual", "BabyLast", "washingDual", "boatInitial", "washingFull", "uffyFinal", "sayFinal", "boatFinal", "andyAll", "abyFin", "aberTotal", "sayFixed", "alyFixed", "phiFinal", "uffyTotal", "alyAll", "boatDual", "washingLast", "boatFixed", "sayUpdated", "boatFull", "phiReal", "satFin", "aberFinal", "washingFixed", "abyUpdated", "andyFixed", "abyReal", "satLast", "inessReal", "aberInitial", "inessInitial", "uyTotal", "aberFin", "seatTotal", "phiFull", "sayReal", "inessFinal", "BabyZero", "abyInitial", "andyFinal", "boatReal", "washingFin", "agusFixed", "BabyFinal", "washingFinal", "BabyFin", "inessFixed", "uyFinal", "agusFinal", "abyAll", "seatInitial", "uyInitial", "uyFin", "washingComplete", "phiDual", "agusUpdated", "abyLast", "seatFin", "washingReal", "abyFull", "sayInitial", "washingAll", "satZero", "agusTotal", "abyTotal", "alyComplete", "alyFinal", "washingZero", "abyFixed", "uffyUpdated", "uffyFixed", "satFinal", "abyComplete", "abyZero", "seatFinal", "sayTotal", "andyComplete"], "n": ["dn", "c", "np", "t", "count", "y", "v", "ul", "pn", "sn", "nu", "k", "nl", "ng", "nr", "ne", "el", "en", "l", "norm", "ln", "na", "nn", "out", "an", "no", "nt", "name", "nan", "nw", "un", "note", " N", "N", "non", "p", "d", "ni", "len", "all", "names", "network", "number", "o", "nb", "mn", "net", "con", "num", "yn", "cn", "size", "w", "nor", "syn", "z", "gn", "m", "nm", "g", "nc", "ns", "ren"], "j": ["jj", "ja", "y", "J", "v", "aj", "bi", "k", "js", "I", "jc", "jp", "oj", "b", "at", "im", "q", "out", "x", "jump", "index", "br", "obj", "ji", "ij", "jit", "ia", "p", "si", "ix", "json", "uj", "bj", "it", "jl", "z", "g", "dj", "kj"], "i": ["ip", "c", "li", "y", "v", "bi", "ii", "k", "phi", "multi", "xi", "I", "u", "mi", "iu", "l", "gu", "gi", "hi", "cli", "ami", "ti", "ki", "ci", "pi", "ij", "ji", "p", "qi", "ia", "ni", "si", "init", "ix", "di", "info", "ini", "ei", "it", "m", "ai", "ic", "ri"], "sbPasswd": ["sbGuess", "sbChainwd", "zbPasswd", "zbDefweight", "sbpasssword", "cbPassess", "sbPushenc", "cbMassWD", "cbMassenc", "cbPassWD", "sbWorkwd", "sbpasswd", "sbWorkweight", "sbPasssword", "cbMasswd", "sbGuenc", "sbAssweight", "sbPASSw", "sbMassess", "cbpassrc", "sbGuwd", "sbPassw", "ebPassWD", "sbGuWD", "sbPassenc", "sbDefwd", "sbAssword", "sbDefsword", "sbpassrc", "sbPASSgrad", "sbMassWD", "sbAsswd", "ebChainWD", "zbPassw", "sbPushwd", "sbChainWD", "sbAssWD", "sbpassweight", "ebPasswd", "sbPushgrad", "zbDefsword", "cbPassw", "ebChainweight", "cbpassgrad", "sbpassw", "sbMassenc", "zbDefw", "sbMasswd", "sbWorksword", "sbPassWD", "ebChainword", "ebChainwd", "cbPassrc", "cbPasswd", "cbpassw", "sbDefw", "sbPushess", "ebPassword", "zbDefwd", "cbpasswd", "sbPassrc", "sbPushw", "sbPassword", "sbPASSrc", "cbPassgrad", "sbPassgrad", "sbPassweight", "sbDefweight", "sbPushrc", "ebPassweight", "zbPassweight", "cbMassess", "cbPassenc", "sbpassgrad", "sbPassess", "sbWorkw", "sbChainweight", "zbPasssword", "sbPushWD", "sbPASSwd", "sbChainword"], "md3": ["dm3", "dm03", "mt03", "mt30", "md43", "cmd33", "cmd3", " md5", "md30", "mdThree", "MD43", "md03", "mt5", "rmThree", "MD3", "mt2", "mt43", "m43", "m4", "mt3", "cmd2", "rm30", "m5", "mt33", "mb4", "mb43", "cmd03", "m3", "md5", " md4", "mtThree", "mb5", "cmd30", "cmdThree", "dm5", "mb3", "cmd43", "MD2", "cmd5", "dm33", "rm3", "md33", "MD5", " md43", "rm5", "md4"]}}
{"id1": "14001795", "id2": "13159394", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyOverwarFile", "copyoverwarFilename", "copyOverTarfile", "copyOverWarFiles", "copyoverWarFile", "copyoverwarFiles", "copyOverwarFilename", "copyOverTarFile", "copyOverwarfile", "copyoverWarFiles", "copyOverTarFilename", "copyoverWarfile", "copyoverwarfile", "copyOverWarfile", "copyoverwarFile", "copyOverTarFiles", "copyoverWarFilename", "copyOverWarFilename", "copyOverwarFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "dr", "re", "md", "ind", "file", "disk", "log", "div", "loc", "add", "dd", "iter", " directory", "del", "out", "df", "mk", "path", "dm", "Dir", "res", "DIR", "dat", "name", "dim", "old", "url", "coll", "fd", "d", "folder", "di", "ld", "directory", "dist", "cur", " Dir", "fin", "local", " d", "desc", "rel", "vol", "ir", "dial", "direct", "doc", "addr", "parent", "zip", "good", "window", "db", "form", "def"], "ff": ["fact", "tf", " aft", "aff", " cf", "fx", " ref", "off", "ef", "buff", "bf", "FF", "mt", "file", " FF", " eff", "xf", "ck", "UFF", "xff", "af", "df", "uf", "lf", "cb", "cond", "ft", "fd", " df", "aft", "ld", "wind", "fp", " def", "ffe", " af", "fc", "fl", "fg", "F", "filter", "sf", "uff", "iff", "eff", "cf", "alf"], "files": ["features", "facts", "faces", "ions", "Files", "parts", "forms", "file", "images", "frames", "assets", "ports", "balls", "items", "rows", "leases", "ls", "objects", "days", "styles", "mas", "plates", "ails", "iles", "names", "bees", "models", "flows", "members", "fs", "les", "jobs", "uploads", "lines", "resources", "tests", "values", "fields", "keys", "issues", "ories"], "f": ["c", "t", "tf", "v", "rf", "fe", "k", "fac", "col", "bf", "fa", "file", "l", "b", "e", "fab", "xf", "uf", "lf", "fm", "fw", "a", "n", "ft", "exp", "p", "d", "fd", "fs", "fp", "w", "fc", "fl", "elf", "m", "F", "g", "sf", "i", "h", "cf", "alf", "def"], "newFile": ["newPlace", "oldFilename", "NewNode", "NewFile", " newPlace", "oldFile", "secureFile", "newsfile", "uniqueNode", "newsFile", "newNode", "newFiles", "uniquePage", "anotherFile", "NewPlace", "newFilename", " newFiles", "anotherPlace", "securefile", "newKey", "NewPage", "oldfile", "uniqueFile", "NEWfile", "newPage", "uniquefile", "NewFilename", "NEWFile", "secureKey", "NEWPage", "newfile", "Newfile", "anotherfile", "NewKey", "newsKey", "NewFiles", "anotherFiles", " newfile", " newFilename", "NEWNode"], "fi": ["fr", "li", "io", "fe", "bi", "ii", "phi", "bf", "fa", "iu", "mi", "isi", "flo", "ti", "uf", "lf", "ki", "FI", "ci", "pi", "ni", "fd", "si", "di", "ini", "fp", "fin", "afi", "ifa", "ife", "zi", "i", "sf", "ri", "cf", "Fi"], "fo": ["tf", "te", "oe", "po", "hea", "sty", "uo", "oo", "ato", "FO", "ho", "oooo", "xf", "flo", "eto", "tk", "ph", "hi", "ti", "ki", "ott", "mo", "wo", "ow", "eno", "fam", "zz", "vo", "tif", "co", "opa", "o", "tto", "bo", "wt", "jo", "zo", "sf", "ko", "cf"]}}
{"id1": "9275622", "id2": "5035872", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyfile", " copyStream", " cpStream", " cpfile", " duplicateStream", "copyStream", " duplicateFiles", " copyFiles", " cpFile", " duplicateFile", " duplicatefile", " cpFiles"], "_file1": ["_fileOne", "_linkInit", "_ileInit", "_FileOne", "_ileOne", "_ileFirst", "_ile1", "_filesOne", "_linkOne", "_FileFirst", "_link2", "_fileFirst", "_link1", "_fileInit", "_ile2", "_File2", "_FileInit", "_files2", "_File1", "_files1", "_filesFirst"], "_file2": ["_FILE02", "_fileTwo", " _Filetwo", " _FILE1", "_FILE2", "_fileb", " _filetwo", " _FILEb", "_link2", "_file02", "_FILE1", " _fileb", " _fileTwo", "_File02", "_link1", "_image02", "_image1", "_linktwo", " _FileTwo", "_Fileb", "_linkTwo", " _File2", "_File2", " _FILE2", "_Filetwo", "_FILEb", "_filetwo", "_image2", "_FileTwo", "_imageb", " _File1", " _file02", " _FILE02", "_File1"], "fis": ["kios", "Fios", " fi", "kais", "fiss", " fais", "kis", "fios", "fliss", "Fois", " fois", "ufi", "cfris", " fiss", "fois", "ufis", "qiss", "qios", "qis", "qos", "Fos", "fli", " fios", "fais", " fris", "cios", "cais", "Fris", "cfois", "kos", "cfis", "flios", "Fiss", "ufiss", "cfiss", "Fis", "fi", "cos", "ufios", "flis", "cis", "fris"], "fos": ["woes", "foes", "hose", "mos", "ffos", "fows", " fose", "ffoes", "hoes", "hos", "woss", " foss", "foss", "floes", "sfoss", "sfoes", "faos", "sfos", "moes", "maos", "mows", "wis", "flos", "ffis", "floss", "ffoss", "hoss", "waos", "wows", " faos", "sfose", " fows", "fose", "flis", " foes", "wos"], "canalFuente": ["canalFuestro", "canalKuperor", "canalFalent", "canallfueree", "canallFuente", "canallfuperor", "canalTenperor", "canalUtent", "canalKuent", "canallFuenza", "canallFuent", "canalfuestro", "canalFueree", "canallFuperor", "canalFient", "canalFuje", "canallfuje", "canalUteree", "canallFuestro", "canalFaleree", "canallfuestro", "canallFuje", "canalKuente", "canalfuente", "canallfuenza", "canallfuent", "canalFiente", "canalFalestro", "canalUtente", "canalFalente", "canalFienza", "canalTenenza", "canallfuente", "canalTenent", "canallFueree", "canalfuje", "canalTenente", "canalFalperor", "canalFiperor", "canalFalje", "canalKuje", "canalUtestro", "canalfueree", "canalFuent", "canalfuent", "canalFuperor", "canalFuenza", "canalfuenza", "canalfuperor"]}}
{"id1": "17786231", "id2": "11484416", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 0, "substitutes": {"downloadFile": ["downloadfile", "transferFile", "downloadContent", "loadfile", "downloadResource", "loadFile", "loadContent", "getFile", "transferContent", "transferfile", "getfile", "getContent", "transferResource", "loadResource", "getResource"], "downloadUrl": ["downloadURL", "DownloadURL", "downloadWar", "transferUrl", "reportWar", "reportUrl", "transferURL", "installUr", "reportURL", "transferUr", "DownloadWar", "downloadUr", "linkUr", "reportUr", "installUrl", "transferWar", " downloadLink", "installURL", " downloadUr", "DownloadUrl", "linkURL", " downloadURL", "linkLink", "DownloadUr", "linkUrl", "downloadLink", "installLink"], "destinationFile": ["destarationName", "destiningDir", "coordacementFolder", " destificationSourceFile", "coordinationfile", "destarationFolder", "destacementfile", "destificationFile", "coordacementFile", "destarationFile", " destinationDir", "coordacementName", "destinationSourceFile", "destiningFile", "destinationName", "destinationPath", "destinationfile", " destificationDir", " destificationPath", " destificationFile", "destinationDir", "destinatedFolder", "destacementName", "destacementFile", "destiningSourceFile", "destificationSourceFile", "destificationDir", " destinationPath", "destarationDir", "destinatedfile", "destinationFolder", "coordinationName", "destinatedFile", "destarationfile", "destificationPath", "destiningPath", "coordacementfile", "destinatedName", " destinationSourceFile", "destarationPath", "destacementFolder", "coordinationFolder", "coordinationFile", "destarationSourceFile"], "client": ["cl", "io", "request", "conn", "connection", "server", "pool", "collection", "phone", "google", "https", "uri", "tc", "console", "cli", "cache", "ci", "city", "url", "co", "wrapper", "http", "contact", "network", "service", "channel", "template", "api", "query", "net", "force", "cm", "context", "Client", "call", "resource", "remote", "key", "system"], "httpGet": ["utilPut", "ttpGet", "hGet", " httpPut", "httpget", "httpGET", "utilGet", "Httpget", " httpQuery", "HttpPut", "HttpGET", "HttpGet", "utilQuery", "utilGET", "ttpget", "hPut", "HttpQuery", "httpQuery", "httpPut", "ttpPut", "hget", " httpGET"], "outputFile": ["outPlace", "newPlace", "regionFile", "betaFILE", "outFile", "outputPlace", "tempFile", "regionFILE", "tempStream", "regionStream", "OutputStream", "seeFILE", "outStream", "betaFile", "outputFILE", "newFile", "tempFILE", "outputPoint", "OutputFile", "newStream", "OutputPlace", " outputFILE", "outPoint", "seeFile", "OutputPoint", "newPoint"], "outputStream": [" outputstream", "printSteam", " outputStreamer", "OutputStyle", "responseStyle", "outputStreamer", "OutputSteam", "outputstream", "OutputView", "putSteam", "inputStyle", "OutputStream", "printForm", "outputSteam", " outputView", "putStyle", "outputView", "responseStreamer", "inputStreamer", "printFile", "coinStreamer", "printStream", "coinSteam", "coinStream", "outputForm", "coinStyle", "putStream", "responseStream", " outputStyle", "responseSteam", "putStreamer", "inputFile", "inputstream", "Outputstream", "inputView", " outputForm", " outputSteam", "inputForm", "inputSteam", "outputStyle"], "response": ["version", "reply", "content", "onse", "example", "request", "details", "status", "connection", "data", "answer", "server", "attribute", "document", "image", "post", "result", "still", "body", "application", "resp", "description", "http", "json", "service", "block", "output", "message", "entry", "yes", "initial", "resource", "Response", "given", "remote", "page"], "entity": ["content", "object", "peer", "encrypted", "details", "buffer", "detail", "type", "account", "status", "translation", "enc", "ity", "member", "instance", "data", "comment", "total", "el", "attribute", "existent", "document", "component", "image", "e", "secure", "result", "ent", "body", "profile", "security", "iso", "line", "cache", "email", "obj", "activity", "name", "metadata", "note", "pe", "json", "info", "properties", "event", "existing", "local", "group", "person", "valid", "message", "entry", "Entity", "ilo", "resource", "xml", "associated", "unique", "error", "quote"], "inputStream": ["imageView", "sourcestream", "upSteam", "InputSteam", "evalStream", "outputstream", "readstream", "readStream", "readForm", "sourceView", "imageSteam", "inputStyle", "sourceStream", "outputSteam", "activeView", "inputStreamer", "outputView", "thisSteam", "sourceSteam", "Inputstream", "readSteam", "thisStyle", "upstream", " inputView", "outputForm", "imageStream", "imagestream", "activeStream", " inputStreamer", "InputStyle", "inputstream", "activeSteam", " inputSteam", "inputView", "InputStream", "thisForm", "upForm", "inputForm", "thisStream", "InputForm", "evalView", "evalSteam", "inputSteam", "outputStyle", "evalStreamer", " inputstream", " inputForm", "activeStreamer", "upStream"], "callback": ["facebook", "closure", "binding", "window", "lambda", "manager", "Callback", "actor", "back", "sound", "func", "hook", "continue", "loader", "cell", "parser", "update", "creator", "cc", "pattern", "browser", "library", "gc", "cb", "job", "policy", "alias", "backs", "builder", "wrapper", "processor", "token", "finder", "CB", "message", "display", "consumer", "handler", "call", "function", "soon", "filter", "background"], "copiedLength": ["copiedSize", "copedLength", "CopiedLen", "copyLength", "CopiedDuration", "copifiedDuration", "CopedDuration", "CopedSize", "copiedLen", "copedLen", "copIEDDuration", "copySize", "copifiedSize", "copedNumber", "CopiedLength", "CopedLen", "CopedLength", "CopiedNumber", "copedDuration", "copyLen", "copifiedLength", "CopiedSize", "copiedNumber", "copIEDLength", "copifiedLen", "copiedDuration", "copedSize", "copyDuration", "copIEDNumber", "copifiedNumber", "CopedNumber"], "percentage": ["capage", "CENTure", " percenture", " percentaging", "CENTage", "Percentages", "percentages", "Percentale", "Percentage", "percentale", " percentale", "CENTages", "Percentaging", "percentaging", "percenture", " percentages", "capale", "capages", "capaging", "Percenture"]}}
{"id1": "9371421", "id2": "23335922", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"eventHash": ["EventName", "EventRender", " eventhash", " eventRender", " eventName", "eventRender", "textName", "textHash", "EventHash", "textRender", "Eventhash", "eventName", "texthash", "eventhash"], "eventstr": ["msgstr", " eventStr", "Eventname", "msgStr", "eventstring", "msgname", "msgstring", "ventStr", "Eventstr", " eventenc", "eventenc", " eventstring", "ventenc", "Eventenc", "eventStr", "eventname", "ventstr", "Eventstring", "ventname", " eventname", "EventStr"], "md": ["pm", "bd", "MD", "dh", "det", "cd", "dr", "td", "sd", "down", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "dig", "del", "cmd", "df", "mk", "mb", "nd", "mo", "dm", "pd", "nt", "metadata", "dat", "grad", "mem", "mp", "d", "ma", "der", "di", "ld", "rm", "mn", "od", "met", "m", "red", "ad", "mm", "mg", "ms"], "theDigest": [" theDEST", "theDecest", "theDFEST", "THEDigEST", "theDEST", "theDigEST", "theMDested", "THEMDested", "THEDigest", "theDigests", "theDested", " theDested", " theDigested", "thedigested", "theDecested", "theDFesting", "theDFest", "theDesting", "theDecEST", "theMDest", "THEDigested", " theDesting", "THEMDEST", "theDest", "theDigested", "theDests", "THEDigests", " theDigesting", "theMDEST", "thedigest", "theDigesting", "THEMDest", "THEMDests", "theMDests", "theDFested", " theDigEST", "thedigesting", "theDecests", " theDest", "thedigEST"]}}
{"id1": "838844", "id2": "16623181", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "838844", "id2": "12380475", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "1769771", "id2": "15645004", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", "copyLine", "copyFiles", "CopyStream", " copyStream", " CopyLine", " copyLine", " CopyStream", "CopyFiles", "CopyFile", "copyStream", "CopyLine", " CopyFiles", " copyFiles"], "in": ["io", "bin", "din", "inc", "isin", "rin", "ind", "el", "en", "l", "b", "inner", "inf", "r", "is", "input", "up", "In", "old", "on", "gin", "init", "ini", "IN", " input", "from", "ins", "inn", "cin", "i", "mm", "ic", "source"], "out": ["c", "t", "io", "v", "po", "help", "os", "log", "file", "l", "b", "serv", "at", "update", "gt", "ot", "res", "err", "nt", "up", "op", "n", "p", "o", "net", "it", "w", "outs", "output", "Out", "ex", "to", "msg", "s", "ou", "OUT"], "inChannel": ["sinButton", "sinCase", "innClient", "ainCategory", "dinConnection", "cinRoom", "inButton", " inCase", "cinCommand", "inChan", "ainClient", "insideScope", "cinChannel", "insideCategory", "innButton", "innChannel", "InChannel", " inRoom", "outchannel", " inchannel", "dinChan", "sinClient", " inChan", "sinChannel", "intchannel", "inchannel", "inClient", "intCommand", " inCommand", " inConnection", "insideClient", " inButton", "inCase", " inCategory", "dinChannel", "inRoom", "inConnection", "inCommand", "InChan", "dinchannel", "sinRoom", "outChan", " inClient", "insideChannel", "Inchannel", "intChannel", "inCategory", "intChan", " inScope", "ainScope", "innCase", "InCommand", "ainChannel", "outConnection", "sinCommand", "inScope"], "outChannel": ["outSection", " outManager", "inChan", "outputCh", "parentGate", "cnChan", "outputchannel", "blockChannel", "parentChannel", "outchannel", "cnManager", "cnChannel", "parentChan", "neMember", "aosChannel", "inchannel", "outMember", " outChan", "inSection", "aosChan", "aosSection", "outputChan", "neChannel", "outMany", "outCh", "outManager", "blockGate", "blockChan", "outputChannel", "inCh", "neChan", "outputManager", " outMany", "neSection", "inMember", "outGate", " outGate", "outChan", " outchannel", " outCh", "blockMany", "aosMember", "parentMany"]}}
{"id1": "11305840", "id2": "3375718", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 1, "substitutes": {"setUpdateCliente": [" setupdatecliente", " setupdateCliento", " setUpdatePea", " setUpdatePee", " setUpdatePersono", " setupdateClienta", " setupdatecliento", " setupdateclientes", " setUpdatePeo", " setUpdatecliento", " setUpdateClientes", " setupdateclienta", " setUpdateClienta", " setUpdatecliente", " setupdateCliente", " setUpdatePersone", " setUpdatePersona", " setUpdateclientes", " setUpdatePersones", " setupdateClientes", " setUpdatePees", " setUpdateCliento", " setUpdateclienta"], "IDcliente": ["IDstae", "IDClientE", "idclientE", "IDcellE", "idClientoe", "IDsClienti", "idclientee", "IDCliente", "IDclientee", "IDcello", "IDscliento", "IDactiveel", "IDcodE", "IDclientE", "IDclientes", "IDcliento", "IDcelle", "IDparentE", "IDClientel", "idclientes", "IDactiveE", "IDClientes", "idClientE", "IDcodes", "IDstao", "IDClienti", "idCliente", "IDcode", "IDclientel", "idClientes", "idclientoe", "IDclientoe", "IDstai", "IDClientee", "IDparentee", "IDsCliento", "IDcodel", "IDsclientE", "IDparentoe", "idclientel", "IDsclienti", "IDClientoe", "IDscliente", "IDactivees", "IDcodoe", "idcliente", "IDsClientE", "IDstaE", "IDsCliente", "IDCliento", "IDclienti", "idClientel", "IDparente", "IDcelli", "IDcodee", "IDactivee", "idClientee"], "nombre": [" nombreb", "nombreb", "nometr", "nombres", "nuclere", " nombres", " numbreb", "nometren", " nomeres", "nomereb", "numbreb", " numbres", "numbre", "nucleren", " nombren", " nomere", " nombr", "numbren", "nomeres", "nometre", " numbre", "nomer", "nomere", "numbr", "nucleres", "nombr", " numbren", "nombren", "nomeren", "numbres", " nomer", " nomeren", "nuclereb", "nometres"], "paterno": ["petterna", "pATERna", "tatterna", "peterlo", "patterlo", "patterne", "pATERn", "peterna", "caterno", "pettern", "patterna", "paterna", "pATERlo", "tatterno", "catterne", "peterno", "pATERno", "caterne", "pattern", "tatereno", "pettereno", "patterno", "catterna", "taterno", "taterna", "catterno", "patereno", "tattern", "pATERne", "tatern", "paterne", "peterne", "tattereno", "petterno", "caterlo", "patern", "pATEReno", "catterlo", "paterlo", "pattereno", "caterna"], "materno": ["pATERna", "matternumber", "mterNo", "mterna", "materna", "matterno", "mATERNo", "matterna", "mATERnumber", "mterNO", "paterna", "materNo", "maserno", "pATERno", " materNo", "maserna", "maternumber", "mATERNO", "mATERna", "paterNo", "matterNo", "materNO", "masernumber", "maserNo", " matterNo", " matterna", "mterno", "pATERnumber", "matterNO", " materna", " matterno", "pATERNo", "mATERno", "paternumber", " matterNO", " materNO"], "ocupacion": ["ocueanc", "incuppacion", "ocuptacion", "incupac", "ocupparro", "ocupanc", "ocueacion", "icuptaton", "ocupsacion", "icupidad", "ocuptanc", "ocupsaton", "ocuparro", "ocupidad", "icuptacion", "ocUpacion", "ocueac", "ocuppac", "icupaci", "ocupaton", "ocuppacion", "incupacion", "incupparro", "incuppanc", "ocupac", "icupaton", "ocuearro", "incuppac", "ocupaci", "ocuptac", "incuparro", "ocuppanc", "ocUpidad", "ocUpaci", "ocupsidad", "incupanc", "ocupsaci", "icuptidad", "ocuptaci", "ocuptidad", "ocuptaton", "icuptaci", "ocUpaton", "icupacion", "ocuptarro"], "rfc": ["yrfc", "trtc", "rfl", " rfl", "yrfa", "trfa", "urfl", "rtc", "rco", "mfl", "mwic", " rco", " rfa", "mfc", "rcos", "rfa", "mcos", "yrtc", " rtc", "trfc", " rcos", "yrco", "trco", "urwic", "urcos", " rwic", "rwic", "urfc"], "stm": ["sema", "STM", "stmt", "Stmt", "strem", "statma", "Stmi", "STmc", "statM", "strmt", "seM", "sem", " stem", "statmc", " stmi", "STma", "stmi", "statm", "stM", "stem", "strmi", "strm", "Stem", "STm", "Stm", "stma", " stmt", "semc", "stmc"], "update": ["save", "submit", "create", "ok", "replace", "write", "build", "status", "commit", "run", "remote", "Update", "complete", "component", "add", "draw", "updated", "continue", "result", "flush", "out", "edit", "fill", "equal", "check", "open", "success", "end", "up", "accept", "layout", "send", "feed", "use", "load", "delete", "module", "local", "it", "apply", "append", "valid", "only", "report", "UPDATE", "change", "initial", "fail", "include", "set", "remove"]}}
{"id1": "23273706", "id2": "8754809", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectListdata", "getProjectNodeList", "getProjecttreeData", "getProjectNodedata", "getProjectListList", "getApptreeInfo", "getProjectTreeInfo", "getProjecttreeList", "getProjectTreedata", "getProjectNodeInfo", "getApptreeData", "getProjecttreeInfo", "getAppTreedata", "getProjectListInfo", "getProjectListData", "getAppTreeData", "getAppTreeInfo", "getProjectNodeData", "getApptreeList", "getApptreedata", "getProjectTreeList", "getProjecttreedata", "getAppTreeList"], "treeData": ["tableInfo", "treeInfo", "treeValid", "statusData", "reeList", " treeMap", "reeInfo", "statusMap", "tableData", "treeList", "reeMap", "towerValid", "tableDat", " treeInfo", "treeMap", "reeData", "reeDat", "TreeMap", " treePart", "statusDat", " treeDat", "treeDat", "towerDat", "listPart", " treeList", "listDat", " treeValid", "towerData", "tableMap", "TreeInfo", "cacheDat", "cacheData", "cachePart", "listData", "treePart", "tableValid", "tableList", "TreeData"], "filename": ["save", "println", "jpg", "generation", "river", "location", "fil", "FILE", "file", "FIL", "username", "original", "prefix", "temp", "nil", "uri", "uno", "string", "localhost", "png", "path", "ername", "FN", "title", "lua", "name", "metadata", "root", "url", "SourceFile", "folder", "ames", "json", "fs", "directory", "URI", "FS", "fp", "local", "Filename", "URL", "output", "sql", "fps", "latest", "KEY", "ename", "fax", "fn", "source", "key", "txt"], "urlString": ["URLString", "URLSite", "Urlstring", " urlstring", "lString", "urlSingle", "uriSite", "lStr", "UrlSite", "URLstring", "urlService", "callString", "uristring", "URLSingle", "callstring", "uriSingle", "urlStr", "UrlString", "urlSite", "UrlSingle", "callService", " urlService", "lService", "callStr", "uriString", "lstring", "urlstring", " urlStr"], "urldata": ["urledatum", "urldATA", "urldedata", "udldescription", "udlenata", "urleddata", "urlenATA", " urldeatum", " urldATA", " urldatum", " urldedata", "udldata", " urldeata", "udldATA", "urlfata", " urldeATA", "urldeATA", "uriledatum", "urledata", "urldeata", "urlfatum", "udldatum", "urldatum", "urldescription", "urlddata", "udlenATA", "urldeatum", "urrdatum", "urlfATA", "udlenescription", "urlenatum", "urledATA", "udlenatum", "urlfescription", "urileddata", "uriledATA", "urrdATA", " urlddata", "urrdescription", "urlenata", "uriledata", "urrdata", "urlenescription"], "factory": [" facter", "fault", "votype", "fFactory", "Fotype", "Facter", "Factory", "facault", "vactory", "Frozen", "facacter", "affotype", "facactory", "affactory", "efFactory", "Fixture", " fixture", "Fault", " fFactory", " fault", "vacter", "affFactory", "fotype", "affacter", "facixture", " facet", "facet", "frozen", "FFactory", " frozen", "facter", "fixture", "efacet", "Facet", "efactory", "vFactory", "efrozen"], "parser": ["parse", "io", "pdf", "reader", "manager", "instance", "sup", " parsing", "power", "file", "bank", "fascist", "expression", "loader", "Reader", "x", "df", "jack", "actory", "util", "policy", "conv", "er", "command", " parse", "builder", "p", "processor", "arser", " df", "dom", "Parser", "fp", "php", "au", "walker", "xml", "writer", "sf", "apache", "utils", " p"], "u": ["fu", "uv", "io", "ua", "ul", "nu", "eu", "uid", "ui", "iu", "ut", "l", "su", "uri", "hu", "r", "uf", "ue", "util", "cu", "uu", "un", "ur", "url", "p", "o", "tu", "it", "au", "U", "mu", "us", "lu", "ru", "h", "ou"], "is": ["io", "ists", "dis", "iris", "in", "es", "sis", "ui", "iu", "isc", "bis", "isi", "has", "ib", "im", "il", "ist", "sys", "oss", "iso", "lis", "ys", "ires", "its", "IS", "si", "ris", "are", "info", "fs", "ims", "ais", "isa", "mis", "iss", "ost", "it", "ios", "abs", "isl", "ir", "obs", "ins", "ar", "rys", "ai", "us", "Is", "ic", "ri", "ms"], "os": ["et", "dos", "ss", "io", "mos", "Os", "or", "es", "bs", "ros", "des", "OS", "pos", "so", "aos", "oa", "osa", "bos", "sys", "as", "oss", "ot", "out", "ows", "oses", "ls", "ys", "ops", "uts", "ox", "fs", "o", "ost", "ens", "ios", "css", "obs", "osi", "oes", "socket", "cos", "us", "s", "oos", "ms"], "iBufSize": ["iBphLength", "iRbufSize", "iBuffLen", "iBufLen", "iBuffSize", "iLbufLen", "iRufSize", "iBphCount", "iBbufSIZE", "iRufLength", "iBuffSIZE", "iBphSize", "iBuffCount", "iBulCount", "iBbufCount", "iLbufSize", "iLufCount", "iBulSize", "iBphSIZE", "iBufCount", "iRufCount", "iLufsize", "iRbufLength", "iBuffLength", "iRbufCount", "iBufSIZE", "iBbufSize", "iBulsize", "iRbufSIZE", "iRufSIZE", "iBbufsize", "iBuffsize", "iBbufLength", "iBbufLen", "iBufsize", "iLufLen", "iLufSize", "iLbufsize", "iBufLength", "iBulLen", "iLbufCount"], "inBuf": [" inRuc", "inBigbuf", "inBuff", "inBlBuff", "inBiguc", "outRBuff", "InChuf", "inBuc", "inBBuff", "inBufferuf", "outBBuff", "outBuf", "inChuf", "InBbuf", " inBuc", " inRbuff", "inBufferBuff", "inRBuff", "inRuff", "inBigbuff", "inChuff", "outRbuf", "inBufferuff", "outBbuf", "inBul", "inBluf", " inRbuf", "inLbuff", "outRul", " inBbuf", "inBufferbuf", "inLuc", "InBBuff", "InChBuff", "inBlbuf", "inLuf", "inRuf", "InChbuf", "inLbuf", "inRuc", "inRbuff", "inRul", "InBuff", "inBufferul", " inRuf", "inBbuf", "inChBuff", " inBbuff", "InChuff", "outRuf", "outBul", "inChbuf", "inBiguf", "InBuf", "inBbuff", "inRbuf", "inBlul"], "iNumRead": ["aiNumberRead", "iRemRead", "iiNumRead", "iNumberWrite", "inumNeed", "iNumRun", "aiNumWrite", "iNumberRead", "aiNumRead", "iNumPrint", "inumRead", "iRemWrite", "InumPrint", "iiNumFind", "iNumWrite", "iNUMRead", "iNUMNeed", "inumDef", "iNumNeed", "iNumFind", "INumNeed", "iLenRead", "InumRun", "iLenRun", "inumRun", "iNUMRun", "iNumberFind", "iFatRead", "aiNumberFind", "InumNeed", "INumRead", "InumRead", "inumFind", "iLenNeed", "iFatDef", "iinumRead", "iinumDef", "INumPrint", "aiNumberWrite", "aiNumFind", "iinumFind", "iNumDef", "inumPrint", "INumRun", "iRemFind", "iFatFind", "iLenPrint", "iiNumDef", "iNUMPrint"], "f": ["c", "t", "fr", "tf", "y", "v", "fe", "fac", "bf", "fa", "file", "l", "b", "e", "af", "df", "fm", "fo", "n", "p", "fd", "d", "fs", "o", "fp", "w", "fc", "fi", "F", "g", "h", "sf", "fax", "cf"], "inputstream": ["Inputstyle", "inputform", " inputdraw", "iterscreen", "uploaddraw", " inputform", "uploadStream", "Inputdraw", "Inputstream", " inputStream", "uploadstream", "inputStream", "Inputform", "iterstream", "uploadscreen", "inputscreen", "InputStream", "iterstyle", "inputstyle", "uploadstyle", "uploadform", "iterStream", "Inputscreen", "inputdraw"], "document": ["version", "content", "object", "ml", "tree", "html", "raw", "file", "collection", "complete", "Document", "language", "expression", "result", "browser", "df", "application", "ocument", "database", "command", "n", "media", "present", "dom", "number", "directory", "template", "response", "context", "message", "ree", "information", "m", "doc", "article", "xml", "model", "node", "apache", "window", "page"], "nodelist": ["snodeelist", " nodeseline", "nodeeman", "nannodeemark", "nodeestyle", "snodeline", "nostemark", "nODist", "snodestyle", "nanodety", "nodeseline", "nodedemark", "noyist", "snodemark", "noyeline", "nodestyle", "snodelist", "snodeemark", "nostelist", "nodesist", "nomest", "snodeestyle", " nodeselist", " nodeseto", "nodeety", "nodedeline", "noyeto", "nanodist", "nomelist", "nomeman", "neodelist", "nODelist", "neodeist", "nodeemark", "nodeelist", "nnodeemark", "nodeman", "nodedety", "nodest", "nnodeelist", "neodeeman", "noyelist", "nosteline", "nodedelist", "nodety", "nodeselist", "nodedestyle", "nannodeety", "nodeeline", "nondest", "nomist", "nanodelist", "nodeto", "nannodeelist", "nnodeety", "nondelist", "nODeto", "neodest", "neodeman", "nodeline", "neodist", "nondeman", "nnodeist", "nannodeist", "neodeelist", "nodist", "nodeist", "snodeeline", "nostestyle", " nodesist", " nodeto", "nodemark", "nanodemark", "nodeseto", "neodeest", " nodeline", "nODeline", "nondist", " nodist", "nodedist", "nodeest"], "num": ["np", "count", "coord", "um", "current", "max", "nu", "multi", "cal", "nom", "length", "total", "umi", "mult", "om", "result", "su", "uni", "alph", "proc", "no", "zero", "n", "dim", "un", "mem", "Number", "umer", "NUM", "perm", "all", "Num", "number", "list", "man", "mn", "net", "con", "UM", "sum", "m", "nm", "mu", "nam", "set", "mon"], "i": ["ip", "history", "li", "y", "io", "bi", "in", "ii", "phi", "multi", "xi", "I", "ui", "this", "mi", "iu", "batch", "them", "l", "e", "gi", "im", "q", "hi", "cli", "ami", "x", "ti", "ie", "index", "major", "ci", "pi", "ij", "ji", "a", "iq", "n", "wi", "me", "p", "qi", "si", "ix", "init", "di", "info", "ini", "ei", "it", "sim", "j", "ex", "my", "\u0438", "m", "z", "ai", "us", "zi", "ic", "ri"]}}
{"id1": "4618237", "id2": "3767903", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFile2Stream", "writeFiles2File", "writeFileAndFiles", "writeFileAndDisk", "writeFiles2Stream", "writeFileAsFiles", "writeFile2File", "writeFileAsStream", "writeFileToFiles", "writeFileAsFile", "writeFilesToFile", "writeFiles2Files", "writeFiles2Disk", "writeFileToDisk", "writeFileAsDisk", "writeFileAndFile", "writeFileAndStream", "writeFilesToDisk", "writeFilesToFiles", "writeFile2Disk", "writeFile2Files", "writeFilesToStream", "writeFileToStream"], "fin": ["fr", "mid", "raf", "details", "FIN", "rf", "lin", "din", "Fin", "inv", "in", "mil", "fil", "rin", "fa", "en", "ln", "fur", "lo", "normal", "han", "focus", "lf", "fw", "irm", "n", "ran", "fd", "f", "init", "jen", "ini", "mn", "fp", "fre", "fc", "fl", "syn", "fi", "ic", "fn", "kin"], "fout": ["fbout", "ffou", "Fin", " fpo", "ffOut", "ffin", "Fout", "foutput", "fbpo", "FOut", "kout", "kpo", "fOut", " fOut", "fboutput", "fpo", "fou", "tou", "fbOut", " foutput", "tout", "kOut", "tin", "Fou", "ffout", "tOut", "koutput"], "append": ["app", "animate", "replace", "printf", "flat", "buff", "ext", "ind", "insert", "csv", "batch", "join", "ended", "add", "express", "string", "update", "allow", "pend", "vert", "equal", "end", "command", "note", "bold", "absolute", "send", "folder", "ends", "force", "apply", "fail", "seed", "include", "grow", "push"], "inChannel": ["sinButton", "intClient", "pinCategory", "inMachine", "pinMachine", "inButton", "inChan", "innMachine", "iCommand", "inputChannel", "innButton", "innChannel", "InChannel", "rinListener", "InStream", "rinChan", "outchannel", " inchannel", "sinMachine", " inChan", "outStream", "insideSession", "sinChannel", "inchannel", "inStream", "InConnection", "inClient", "iChan", " inCommand", " inConnection", "inputCategory", "insideClient", "pinChannel", "rinChannel", "insideChan", "inSession", "innCategory", "inListener", " inCategory", "rinCategory", "inputChan", "iChannel", "intSession", "outCommand", "inCommand", "inConnection", " inSession", "iStream", " inStream", "sinCategory", "outChan", " inClient", "insideChannel", "Inchannel", "inCategory", "intChannel", "intChan", "inputListener", " inListener", "outConnection", "pinButton"], "outChannel": ["netController", "inChan", "outputCh", "outputchannel", "netCh", "outScope", "outchannel", " outScope", "OUTChannel", "netchannel", "outputScope", "nameScope", "outConnection", "netChannel", "userMember", "nameChannel", "OUTChan", "invMember", "inchannel", "invChannel", " outController", "outMember", " outChan", "OUTController", "outputChan", "outController", "outCh", "outputConnection", "outputChannel", "nameChan", "inCh", "invCh", "OUTchannel", "outChan", " outchannel", "netChan", "userCh", "nameConnection", " outConnection", " outCh", "userChannel", "netMember"]}}
{"id1": "12085127", "id2": "22114133", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"navigate": ["generinate", "configure", "Naviate", "configigate", "avigate", "generigation", "Navigate", "aviate", "navinate", "navigation", "naviate", "avigation", "avure", "avate", "navure", "avinate", "configate", "Navigation", "generiate", "Navinate", "Navate", "Navure", "generigate", "configigation", "navate"], "url": ["dl", "location", "org", "build", "ul", "conn", "host", "nl", "mount", "str", "html", "base", "external", "this", "log", "file", "loc", "document", "l", "b", "web", "gl", "uri", "il", "string", "ssl", "cert", "path", "ls", "www", "util", "job", "email", "ref", "sl", "address", "term", "name", "req", "ur", "f", "pl", "http", "ll", "link", "domain", "rect", "ret", "URL", "char", "null", "xml", "Url", "page", "key"], "connection": ["generation", "cone", "conn", "controller", "relation", "statement", "still", "session", "console", "established", "client", "pointer", "application", "connected", "open", "database", "created", "communication", "command", "position", "city", "description", "network", "character", "channel", "directory", "net", "con", "Connection", "response", "opening", "condition", "sql", "message", "entry", "socket", "resource", "ion", "nc", "connect", "set"], "is": ["ip", "tis", "dis", "iris", "in", "bs", "stream", "os", "sis", "isc", "bis", "isi", "im", "as", "oss", "iso", "lis", "nis", "ri", "ois", "its", "IS", "si", "ris", "are", "fs", "ais", "ims", "rs", "isa", "mis", "iss", "ios", "isl", "ins", "us", "i", "Is", "ic", "ism", "s", "ms"]}}
{"id1": "22057083", "id2": "2807585", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"Connect": ["Start", "Check", " Close", "Sync", "Bind", "Conn", "Connector", "Interface", "Setup", "Auth", "Error", "Create", "Close", " Open", "connect", "New", "Log", " Init", "Ping", "Login", "Connection", " Connection", "Client", " Dial", "Dial", "Construct", "Open", "Init"], "client": ["batch", "component", "secure", "google", "session", "cp", "cmd", "cli", "browser", "mail", "list", "service", "row", "con", "pc", "null", "config", "node", "writer", "remote", "connect", "version", "product", "conn", "patch", "core", "server", "collection", "phone", "cell", "pattern", "cache", "open", "builder", "pb", "net", "local", "response", "context", "entry", "Client", "window", "plugin", "create", "buffer", "type", "lib", "user", "controller", "url", "wrapper", "channel", "api", "control", "force", "call", "handler", "resource", "table", "to", "key", "c", "cl", "reader", "close", "manager", "connection", "log", "cgi", "ssl", "util", "obj", "chain", "name", "command", "handle", "co", "http", "man", "module", "proxy", "one", "ch", "bo", "store", "port", "form"], "reply": ["close", "type", "echo", "write", "status", "state", "translation", "bill", "Reply", "user", "answer", "comment", "py", "mi", "print", "prefix", "next", "result", "flag", "vote", "line", "no", "success", "job", "address", "rc", "ply", "command", "notice", "resp", "match", "nb", "query", "response", "link", "message", "ret", "report", "entry", "code", "shell", "error", "repl"]}}
{"id1": "7118860", "id2": "22442270", "code1": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"getEncoding": [" getEnoder", " getEnoding", "getEncReading", "getEnording", "getIntegording", "getIntegoder", " getEnReading", " getEncReading", "getEnoder", " getEnording", "getEnReading", "getChording", " getEncording", "getEncoder", "getChReading", "getChoding", "getEnoding", "getEncording", "getIntegReading", "getChoder", "getIntegoding", " getEncoder"], "reader": ["linger", "peer", "read", "buffer", "worker", "manager", "instance", "range", "rl", "volume", "stream", "user", "server", "length", "controller", "layer", "liner", "author", "inner", "review", "loader", "timer", "Reader", "dd", "ro", "iter", "older", "parser", "creator", "r", "ner", "client", "driver", "loading", "operator", "rer", "library", "upper", "rar", "er", "builder", "wrapper", "redo", "row", "query", "event", "reading", "runner", "holder", "handler", "rr", "resource", "writer", "owner", "source", "iterator"], "encoding": ["ecension", "increoding", "increignment", "entryption", "entoder", "cacheictionary", "equination", "ecapping", "enumension", "enension", "ecryption", "enignment", "decryption", "encignment", "encictionary", "encapping", "decoding", "integryption", "continasting", "increictionary", "enasting", "encmentation", "equapping", "enumacing", "cacheignment", "enination", "equoding", "entging", "cmentation", "encending", "enumoding", "integoding", "entination", "entoding", "equension", "enaling", "increoder", "ecaling", "cryption", "entoded", "encryption", "enaging", "encension", "decension", "octending", "integapping", "caging", "octaging", "continoding", "encoder", "coding", "coded", "encination", "ecasting", "increging", "acension", "acoder", "integmentation", "continoder", "encging", "capping", "increoded", "octoded", "enapping", "entapping", "enoder", "continryption", "enmentation", "enging", "enryption", "enoded", "cacheoding", "encasting", "octoding", "enoding", "decaling", "acoding", "enending", "enacing", "encoded", "encaging", "encacing", "cending", "acacing", "enictionary", "ecoding", "encaling", "ecoder", "cacheapping", "entension", "enumoder", "increapping"], "connection": ["generation", "close", "conn", "document", "relation", "statement", "uri", "session", "console", "established", "client", "reference", "application", "open", "database", "communication", "command", "position", "url", "online", "network", "character", "service", "directory", "channel", "number", "con", "Connection", "office", "link", "response", "opening", "context", "condition", "socket", "config", "resource", "ion", "writer", "remote", "management", "connect"], "header": ["version", "meta", "history", "head", "request", "buffer", "dr", "heading", "Header", "dict", "status", "column", "comment", "headers", "attribute", "layer", "document", "hd", "client", "profile", "hidden", "menu", "policy", "title", "environment", "term", "metadata", "position", "handle", "http", "info", "template", "question", "event", "block", "output", "initial", "holder", "table", "filter", "h", "rule"], "entry": ["object", "instance", "ry", "se", "member", "let", "data", "space", "attribute", "ce", "card", "inner", "e", "cell", "ent", "q", "pattern", "section", "ie", "check", "alias", "obj", "ace", "enter", "up", "command", "Entry", "escape", "pair", "ary", "info", "element", "search", "row", "be", "directory", "record", "link", "from", "cue", "char", "see", "node", "pixel", "atom", "word", "key", "set", "def"], "item": ["ip", "text", "object", "app", "unit", "instance", "order", "id", "user", "el", "Item", "layer", "file", "attribute", "om", "image", "prefix", "anything", "cell", "im", "iter", "string", "items", "entity", "title", "term", "name", "pair", "element", "info", "value", "em", "template", "tag", "row", "local", "it", "link", "event", "question", "area", "char", "attr", "tab", "label", "addr", "xml", "mm", "atom", "word", "key"], "line": ["level", "text", "le", "where", "zone", "detail", "lin", "inline", "range", "se", "point", "part", "user", "comment", "log", "file", "liner", "LINE", "print", "l", "phrase", "ln", "continue", "e", "trace", "cell", "body", "ge", "Line", "eline", "lo", "iter", "queue", "piece", "cmd", "ice", "slice", "err", "entity", "rule", "chain", "ine", "term", "n", "note", "online", "pe", "lined", "frame", "network", "search", "channel", "row", "query", "edge", "record", "link", "sample", "block", "sequence", "message", "valid", "char", "sql", "label", "code", "port", "model", "msg", "word", "page"]}}
{"id1": "4618237", "id2": "14785308", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFile2Stream", "writeFiles2File", "writeFileAndFiles", "writeFileAndDisk", "writeFiles2Stream", "writeFileAsFiles", "writeFile2File", "writeFileAsStream", "writeFileToFiles", "writeFileAsFile", "writeFilesToFile", "writeFiles2Files", "writeFiles2Disk", "writeFileToDisk", "writeFileAsDisk", "writeFileAndFile", "writeFileAndStream", "writeFilesToDisk", "writeFilesToFiles", "writeFile2Disk", "writeFile2Files", "writeFilesToStream", "writeFileToStream"], "fin": ["fr", "mid", "raf", "details", "FIN", "rf", "lin", "din", "Fin", "inv", "in", "mil", "fil", "rin", "fa", "en", "ln", "fur", "lo", "normal", "han", "focus", "lf", "fw", "irm", "n", "ran", "fd", "f", "init", "jen", "ini", "mn", "fp", "fre", "fc", "fl", "syn", "fi", "ic", "fn", "kin"], "fout": ["fbout", "ffou", "Fin", " fpo", "ffOut", "ffin", "Fout", "foutput", "fbpo", "FOut", "kout", "kpo", "fOut", " fOut", "fboutput", "fpo", "fou", "tou", "fbOut", " foutput", "tout", "kOut", "tin", "Fou", "ffout", "tOut", "koutput"], "append": ["app", "animate", "replace", "printf", "flat", "buff", "ext", "ind", "insert", "csv", "batch", "join", "ended", "add", "express", "string", "update", "allow", "pend", "vert", "equal", "end", "command", "note", "bold", "absolute", "send", "folder", "ends", "force", "apply", "fail", "seed", "include", "grow", "push"], "inChannel": ["sinButton", "intClient", "pinCategory", "inMachine", "pinMachine", "inButton", "inChan", "innMachine", "iCommand", "inputChannel", "innButton", "innChannel", "InChannel", "rinListener", "InStream", "rinChan", "outchannel", " inchannel", "sinMachine", " inChan", "outStream", "insideSession", "sinChannel", "inchannel", "inStream", "InConnection", "inClient", "iChan", " inCommand", " inConnection", "inputCategory", "insideClient", "pinChannel", "rinChannel", "insideChan", "inSession", "innCategory", "inListener", " inCategory", "rinCategory", "inputChan", "iChannel", "intSession", "outCommand", "inCommand", "inConnection", " inSession", "iStream", " inStream", "sinCategory", "outChan", " inClient", "insideChannel", "Inchannel", "inCategory", "intChannel", "intChan", "inputListener", " inListener", "outConnection", "pinButton"], "outChannel": ["netController", "inChan", "outputCh", "outputchannel", "netCh", "outScope", "outchannel", " outScope", "OUTChannel", "netchannel", "outputScope", "nameScope", "outConnection", "netChannel", "userMember", "nameChannel", "OUTChan", "invMember", "inchannel", "invChannel", " outController", "outMember", " outChan", "OUTController", "outputChan", "outController", "outCh", "outputConnection", "outputChannel", "nameChan", "inCh", "invCh", "OUTchannel", "outChan", " outchannel", "netChan", "userCh", "nameConnection", " outConnection", " outCh", "userChannel", "netMember"]}}
{"id1": "4973095", "id2": "23246123", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 0, "substitutes": {"url": ["lb", "dl", "cl", "io", "location", "org", "build", "conn", "rl", "ado", "nl", "mount", "str", "base", "html", "u", "connection", "el", "file", "log", "loc", "lr", "print", "l", " URL", "web", "gl", "uri", "https", "string", "parser", "cp", "r", "out", "ssl", "impl", "browser", "iol", "ls", "www", "ob", "util", "open", "job", "email", "mail", "sl", "address", "ur", "bad", "pl", "http", "ld", "hub", "con", "hl", "ll", "link", "au", "ol", "URL", "null", "lim", "xml", "Url"], "f": ["c", "t", "fr", "tf", "y", "v", "ff", "stream", "fac", "fb", "bf", "full", "log", "file", "fa", "l", "b", "form", "out", "df", "lf", "fo", "n", "tif", "p", "d", "fd", "fs", "o", "fp", "w", "fc", "j", "fl", "fi", "F", "h", "sf", "i", "s", "fn", "cf", "fort"], "by": ["then", "where", "y", "io", "bin", "re", "each", "por", "buff", "reg", "with", "using", "b", "serv", "BY", "sys", "as", "out", "browser", "fully", "bad", "of", "via", "it", "how", "you", "from", "report", "ody", "g", "ly", "By"], "uc": ["c", "stud", "cl", "ul", "sc", "ac", "ocr", "eu", "chu", "oc", "ub", "u", "ud", "loc", "bc", "cus", "tc", "mc", "cc", "roc", "nic", "usc", "uci", "gc", "cas", "uca", "ux", "cu", "rc", "uu", "userc", "UC", "ucc", "ec", "uch", "uh", "unc", "soc", "cur", "con", "auc", "pc", "fc", "asc", "anc", "cmp", "nc", "lc"]}}
{"id1": "14473711", "id2": "6418781", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"str2md5": ["str_md5", "str2sha5", "str_md7", "str2MD7", "str2sha7", "str2md6", "str2dig7", "str_mdest", "str2mdest", "str_MD7", "str2digest", "str2dig6", "str_md6", "str2dig5", "str_MD6", "str2MD6", "str2MDest", "str2md7", "str_MD5", "str2shaest", "str_MDest", "str2MD5", "str2sha6"], "str": ["text", "t", "c", "fr", "ctr", "oct", "v", "dr", "enc", "Str", "arr", "in", "cont", "data", "print", "b", "hex", "wr", "string", "r", "out", "piece", "input", "tr", "res", "br", "obj", "name", "n", "exp", "url", "p", "f", "cur", "rs", "STR", "sts", "ch", "vol", "wcs", "st", "char", "msg", "s", "sp", "cr", "txt"], "alga": ["balga", " Alga", "agba", " ala", " alxa", " calba", "palGa", "alha", "alba", " alGa", "balba", " Algas", " calGa", "algas", " alba", " algas", "agga", "aga", " calgas", " Alba", " AlGa", "balha", "palha", "alxa", "ala", "palba", "palga", " calga", "agxa", "balxa", "bala", "balGa", " alha", "alGa"], "digesta": [" digista", "designosi", " digresso", " digosi", "designeste", "divella", " digella", "designesta", "designested", "digella", " digested", "divista", "diveste", " digeste", "digista", "igresso", "digested", "igella", "digosi", "divresso", "divosi", "divested", "digeste", "igista", "digresso", "igesta", "divesta"]}}
{"id1": "13362846", "id2": "9319440", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 0, "substitutes": {"setContenu": ["setcontenu", "setcontensenue", "setContensenu", "setContennue", "setCont\u00ednux", "setContennu", "setCont\u00ednu", "setcontenux", "setcontenU", "setcontensenux", "setcontenue", "setContennux", "setContenue", "setContennU", "setContenU", "setContenux", "setCont\u00ednU", "setCont\u00ednue", "setContensenU", "setcontensenu", "setContensenue", "setcontensenU", "setContensenux"], "contenuFichier": ["contenuFchiere", "contenuFigniere", "contenuFrenchire", "contenuFrenchieri", "contenuFiverier", "contenuFsrenchaire", "contenuMicheiere", "contenuFamilyichorie", "contenuFsrenchieri", "contenuFichIER", "contenuFihiest", "contenuFechieri", "contenuVichyr", "contenuFithorie", "contenuFachiere", "contenuFigner", "contenuFechier", "contenuFichtIER", "contenuFrenchier", "contenuFamilyachie", "contenuFicheer", "contenuFechiere", "contenuFileochiere", "contenuFsrenchier", "contenuFCher", "contenuFuffer", "contenuVechier", "contenuVichIER", "contenuFileochie", "contenuMichier", "contenuVchie", "contenuFochie", "contenuFichaire", "contenuFechiest", "contenuVichiest", "contenuFsrenchire", "contenuFileochier", "contenuFuffire", "contenuMicheer", "contenuFiverieri", "contenuFamilyachier", "contenuFithyr", "contenuFithiere", "contenuFileochiers", "contenuFileichie", "contenuFochiers", "contenuFamilyichiere", "contenuMichiere", "contenuVchIER", "contenuFamilyachiere", "contenuFileichiers", "contenuFithiest", "contenuFicheire", "contenuFchIER", "contenuVichie", "contenuFsichire", "contenuFolfier", "contenuVichier", "contenuFicher", "contenuFachie", "contenuMichaire", "contenuFamilyachorie", "contenuFochier", "contenuFChaire", "contenuFachorie", "contenuFicheiere", "contenuFichiers", "contenuVchier", "contenuFiveraire", "contenuFichyr", "contenuFihiere", "contenuFolfire", "contenuFsichieri", "contenuFChier", "contenuFignier", "contenuFamilyichier", "contenuFecher", "contenuFichie", "contenuFchie", "contenuFuffieri", "contenuFolfer", "contenuFsichaire", "contenuFolfieri", "contenuFachier", "contenuFithie", "contenuFicheie", "contenuFamilyichie", "contenuFsechieri", "contenuVichiere", "contenuFicheiers", "contenuFicheaire", "contenuFichire", "contenuFichiest", "contenuVechyr", "contenuFiverire", "contenuVchiere", "contenuFichtie", "contenuFsecher", "contenuFChiere", "contenuFicheieri", "contenuFichtiere", "contenuMicheaire", "contenuMicher", "contenuFsichier", "contenuMicheier", "contenuFileichier", "contenuFachiers", "contenuFichorie", "contenuFithier", "contenuFsicher", "contenuFihyr", "contenuVechiere", "contenuFsechier", "contenuFicheier", "contenuFuffier", "contenuFrenchaire", "contenuFileichiere", "contenuFechyr", "contenuFechire", "contenuFsechire", "contenuFichtier", "contenuFichiere", "contenuFicheorie", "contenuFochIER", "contenuFihier", "contenuFichieri", "contenuFochiere", "contenuFchier", "contenuVechiest", "contenuFignaire"], "fichierElectronique": ["fichierCentronius", "fichierSelectronicity", "fichierAdministroneique", "fichierElectroneiques", "fichierElectroniques", "fichierElectroneiq", "fichierElectromipolar", "fichierElectroniq", "fichierElectronticity", "fichierElectonique", "fichierElectronie", "fichierelectronique", "fichierElectronic", "fichierElectroneius", "fichierElectronius", "fichierAdministronie", "fichierElectroneaire", "fichierElectradorie", "fichierElectronaire", "fichierElectriciq", "fichierElectronsicity", "fichierElectrenius", "fichierElectrenier", "fichierElectRONicy", "fichierElectrenique", "fichierElectrenaire", "fichierElectronipolar", "fichierAdministroneiq", "fichierElectronier", "fichierElectRONique", "fichierElectchronoch", "fichierTransferronic", "fichierElectriciques", "fichierSelectroneiques", "fichierelectronier", "fichierElectchroniques", "fichierCentRONius", "fichierCentRONique", "fichierElectchronique", "fichierTransferronius", "fichierelectreniques", "fichierSelectronique", "fichierElectroneic", "fichierElectrontipolar", "fichierElectradorius", "fichierElectricique", "fichierElectronsic", "fichierElectreniques", "fichierAdministroniq", "fichierElectronsique", "fichierElectromicity", "fichierElectromaire", "fichierElectRONaire", "fichierTransferronie", "fichierCentronicy", "fichierElectricie", "fichierElectronicity", "fichierTransferradoric", "fichierElectchronicity", "fichierSelectroniques", "fichierTransferradorie", "fichierElectronsiq", "fichierSelectroneique", "fichierElectrontique", "fichierElectchronaire", "fichierElectRONius", "fichierTransferradorique", "fichierelectrenique", "fichierCentRONicy", "fichierelectroniques", "fichierElectrontaire", "fichierElectroneicity", "fichierAdministroniques", "fichierSelectroneicity", "fichierElectrenic", "fichierElectromic", "fichierElectronsiques", "fichierElectradoric", "fichierElectroneoch", "fichierAdministronique", "fichierElectonic", "fichierElectchronicy", "fichierElectrenicy", "fichierElectonier", "fichierElectromius", "fichierAdministroneie", "fichierCentRONaire", "fichierElectroneique", "fichierElectronsie", "fichierTransferronique", "fichierElectoniques", "fichierElectradorique", "fichierElectroneie", "fichierAdministroneiques", "fichierSelectronoch", "fichierElectroneipolar", "fichierElectronsier", "fichierElectronoch", "fichierCentronique", "fichierElectromique", "fichierElectronicy", "fichierSelectroneoch", "fichierelectronic", "fichierelectrenier", "fichierElectronsoch", "fichierelectrenic", "fichierElectromie", "fichierCentronaire", "fichierTransferradorius", "fichierElectchronius"], "utilisateurCourant": ["utilisateurGovernant", "utilisateurGovernants", "utilisateursGovernante", "utilisateurGoverniant", "utilisateurRepresentants", "utilisateurRepresentante", "utilisateurParticipante", "utilisateurRepresentiant", "utilisateurCouriant", "utilisateurParticipants", "utilisateursGoverniant", "utilisateurCourants", "utilisateursGovernant", "utilisateurGovernante", "utilisateursCourants", "utilisateurCourante", "utilisateursCouriant", "utilisateurRepresentant", "utilisateurParticipiant", "utilisateursGovernants", "utilisateursCourante", "utilisateursCourant", "utilisateurParticipant"], "support": ["history", "Support", "proof", "replace", "help", "supported", "please", "collection", "document", "trust", "language", "prototype", "allow", "storage", "profile", "install", "library", "success", "format", "accept", "cover", "supp", "feature", "media", "use", "service", "control", "force", "cap", "context", " Support", "SUP", "null", "see", "share", "know", "port", "evidence", "pport", "access", "system"], "ficheDocument": ["facheTransaction", "foyerDatabase", "fitimeDatabase", "ficiDocument", "ficheTransaction", "fcheDatabase", "fayeDocument", "ficiMatrix", "flicheMatrix", "hacheDocument", "fliciDocument", "hicheJournal", "fiqueDocument", "hicheTransaction", "ficheTree", "bacheTree", "FicheDatabase", " ficheDescription", "flicheTransaction", "frenchDocuments", "ficheMatrix", "FayeDoc", "facheDatabase", "fcheDocument", "FicheDocuments", "fruitDocument", "FicheDocument", "FayeDocument", "fiqueDescription", "fitimeMatrix", "hicheDocument", "frenchDocument", "facheDoc", "bicheDoc", " frenchDatabase", "ficiJournal", "bacheDocument", "hacheTransaction", "fliciMatrix", "fruitTransaction", "hacheJournal", "ficiDatabase", "fruitdocument", "ficheJournal", "FayeDatabase", "fitimeDescription", "ficheDocuments", "frenchTransaction", "flicheDocument", "facheTree", "foyerDocument", "fiqueDatabase", " ficheDatabase", "fruitJournal", "flicheDatabase", "bacheDoc", "fcheDoc", "ficheDescription", "fitimeDocument", "fifaDoc", "fliciTransaction", "foyerDoc", "fcheTree", "hachedocument", "ficidocument", "frenchDatabase", "ficheDatabase", " frenchDescription", "bicheDocument", "fayeDatabase", "fliciDatabase", "fifaDatabase", "foyerTree", "fitimeTransaction", "hichedocument", "fifaDocuments", "fayeDoc", "frenchMatrix", "FicheDoc", "frenchDescription", "fifaDocument", "facheDocument", "fayeDocuments", "facheJournal", "FayeDocuments", "ficheDoc", "ficiTransaction", "bacheDatabase", "bicheDatabase", " frenchDocument", "fichedocument", "frenchDoc", "fachedocument", "bicheTree"], "nomFichier": ["nomFolfire", "nomFicheer", "nomFichery", "nomPicherer", "nomFchire", "nomFiliciller", "nomFihIER", "nomPichier", "nomUFachIER", "nomFicheire", "nomNichier", "nomFericancer", "nomFachomer", "nomFicherer", "nomFicheiere", "nomUFachier", "nomFchier", "nomFichiller", "nomFolfie", "nomFicire", "nomPFichiller", "nomFericier", "nomFolfier", "nomUFichery", "nomFacher", "nomPichire", "nomUFichire", "nomFilicER", "nomFichiere", "nomUFichIER", "nomPFoiljer", "nomFicerer", "nomFericanger", "nomFicjer", "nomFichire", "nomFchomer", "nomFcher", "nomPichomer", "nomFiverire", "nomNichie", "nomUFachery", "nomFihery", "nomFiverery", "nomFachIER", "nomFicher", "nomFichiner", "nomPFichjer", "nomFihire", "nomPFoilier", "nomPachire", "nomFachiere", "nomFachery", "nomFichie", "nomFachie", "nomFichIER", "nomFihier", "nomPFichER", "nomFchiere", "nomFicomer", "nomFachire", "nomFericIER", "nomFacherer", "nomFiverier", "nomNolfire", "nomUFachire", "nomFicier", "nomFicheier", "nomNolfier", "nomPFichier", "nomPacherer", "nomFachancer", "nomFichanger", "nomFicheie", "nomFichoancer", "nomFichoanger", "nomFiciller", "nomFichER", "nomNolfiere", "nomUFichier", "nomPFoilER", "nomFcherer", "nomFichomer", "nomFilicjer", "nomFolfiere", "nomFicER", "nomFiverIER", "nomFichancer", "nomFoilier", "nomFachiner", "nomFachier", "nomNolfie", "nomFoiljer", "nomFachanger", "nomFchiner", "nomNichire", "nomFicheiner", "nomFoilER", "nomFilicier", "nomPachier", "nomPFoililler", "nomFichoIER", "nomPachomer", "nomFoililler", "nomNichiere", "nomFichoier", "nomFichjer"], "extension": ["expention", "strensions", "contractor", "Extensions", "Extending", "extensions", "contitude", "protractor", "extractor", "contention", "strension", "contension", "xtending", "extending", "extention", "protension", "xtension", "Extension", "expension", "xtensions", "protention", "extitude", "strending", "protitude", "expitude", "expractor"], "fichierElectroniqueExistant": ["fichierElectroniquePersister", "fichierElectronicityInert", "fichierElectroniqueExclusive", "fichierElectroniquePersiker", "fichierElectroniqueInistant", "fichierElectronogueExistent", "fichierElectroniquePersistant", "fichierElectroniquePresentistent", "fichierElectroniqueExplistance", "fichierElectronogueExistant", "fichierElectroniqueInclusive", "fichierElectroniqueEXert", "fichierElectroniqueLocalclusive", "fichierElectroniqueExistent", "fichierElectronogueExister", "fichierElectroniquePersistent", "fichierElectroniqueAssistant", "fichierElectronoguePersiker", "fichierElectroniquePlusistent", "fichierElectroniqueLocalistent", "fichierElectronogramLocalistance", "fichierElectronoguePersistant", "fichierElectronogramLocalistant", "fichierElectroniqueInert", "fichierElectroniqueEXvant", "fichierElectronogramExistant", "fichierElectronicityExistant", "fichierElectronogramLocalistent", "fichierElectroniqueExvant", "fichierElectroniqueExert", "fichierElectroniquePlusister", "fichierElectroniqueLocalistant", "fichierElectroniqueExister", "fichierElectroniqueExplert", "fichierElectronogramExistance", "fichierElectroniquePlusiker", "fichierElectroniqueInistance", "fichierElectroniquePresentistant", "fichierElectroniquePlusistant", "fichierElectroniqueExiker", "fichierElectroniquePresentister", "fichierElectronicityExvant", "fichierElectroniqueInistent", "fichierElectroniqueAssistance", "fichierElectroniqueExplistant", "fichierElectronicityInistant", "fichierElectroniqueExplvant", "fichierElectronicityInvant", "fichierElectroniqueEXistant", "fichierElectronicityExistance", "fichierElectroniqueExistance", "fichierElectroniqueEXistance", "fichierElectronogramExistent", "fichierElectronogramLocalclusive", "fichierElectronogramExclusive", "fichierElectroniqueLocalistance", "fichierElectronogueExiker", "fichierElectroniqueAssclusive", "fichierElectroniqueInvant", "fichierElectronicityInistance", "fichierElectronoguePersistent", "fichierElectroniquePresentiker", "fichierElectronicityExert", "fichierElectronoguePersister", "fichierElectroniqueAssistent"], "idIgid": ["idIIgoid", "idIIgzid", "idIgcido", "idImgis", "idIgida", "idIgdida", "idIgdido", "idIgids", "idIgaddress", "idImgdata", "idImgid", "idIgdoid", "idAmgaddress", "idAglimit", "idIegid", "idIigmaddress", "idIgido", "idIegkey", "idIkglimit", "idIIgido", "idIgzoid", "idImgkey", "idIvgkey", "idIigmlimit", "idIgis", "idIgcid", "idIglimit", "idIgoid", "idIIgid", "idIIgzoid", "idAmgid", "idIvgid", "idIegdata", "idIIgida", "idIigmis", "idIvgdata", "idIgzid", "idIegids", "idIkgaddress", "idIgcida", "idImgids", "idAgis", "idImglimit", "idIgkey", "idIgdid", "idImgaddress", "idIIgzida", "idIkgid", "idIgzido", "idIigmid", "idAgid", "idIgcoid", "idIgzida", "idAgaddress", "idAmglimit", "idIvgids", "idIkgis", "idIIgzido", "idIgdata", "idAmgis"], "inputStream": ["InputTime", "helloChannel", "outputStreamer", "InputSteam", "outputstream", " inputLoop", "inputChannel", "imageSteam", "helloStreamer", "inputTime", "helloSteam", "outputSteam", " inputThread", "inputStreamer", "Inputstream", "imageLoop", "imageTime", " inputTime", "InputThread", "imageStream", "helloStream", " inputStreamer", "outputChannel", "inputstream", " inputSteam", "InputStream", "inputThread", "InputLoop", " inputChannel", "inputSteam", "outputThread", " inputstream", "inputLoop"], "outputStream": ["sequenceStreamer", " outputStreamer", "webView", "OutputStyle", "outputStreamer", "webSteam", "webStreamer", "OutputSteam", "OutputView", "OutputStream", "outputSteam", " outputView", "webStream", "writeStream", "OutputStreamer", "outputView", "OutputForm", "outputForm", "writeForm", "sequenceStream", " outputStyle", "sequenceStyle", "sequenceSteam", "inputView", "writeView", "writeSteam", " outputSteam", "inputForm", "inputSteam", "outputStyle"], "typeMime": ["TypeMIME", "typeRIME", "typeSmime", "TypemIME", "typemim", "typeSmme", "TypeMime", "Typemime", "typemIME", "typeSmIME", "Typemme", "typeRim", "typeSmim", "typeMIME", "typeRme", "typeRime", "typeMim", "typemime", "Typemim", "TypeMim", "typemme", "TypeMme", "typeMme"], "tailleFichier": [" tailleFicheie", " tailleFicheier", " tailleficheie", " tailleFixies", " tailleficheiers", " taillefichiers", " tailleFuzzie", " taillefichier", " tailleFichie", " tailleFixiers", " tailleFichies", " tailleFixier", " tailleFichiers", " tailleFicheies", " tailleFuzziers", " tailleFuzzies", " tailleFuzzier", " tailleficheier", " tailleFicheiers", " taillefichies", " tailleFixie", " tailleficheies", " taillefichie"]}}
{"id1": "4973095", "id2": "14191679", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"url": ["lb", "dl", "cl", "io", "location", "org", "build", "conn", "rl", "ado", "nl", "mount", "str", "base", "html", "u", "connection", "el", "file", "log", "loc", "lr", "print", "l", " URL", "web", "gl", "uri", "https", "string", "parser", "cp", "r", "out", "ssl", "impl", "browser", "iol", "ls", "www", "ob", "util", "open", "job", "email", "mail", "sl", "address", "ur", "bad", "pl", "http", "ld", "hub", "con", "hl", "ll", "link", "au", "ol", "URL", "null", "lim", "xml", "Url"], "f": ["c", "t", "fr", "tf", "y", "v", "ff", "stream", "fac", "fb", "bf", "full", "log", "file", "fa", "l", "b", "form", "out", "df", "lf", "fo", "n", "tif", "p", "d", "fd", "fs", "o", "fp", "w", "fc", "j", "fl", "fi", "F", "h", "sf", "i", "s", "fn", "cf", "fort"], "by": ["then", "where", "y", "io", "bin", "re", "each", "por", "buff", "reg", "with", "using", "b", "serv", "BY", "sys", "as", "out", "browser", "fully", "bad", "of", "via", "it", "how", "you", "from", "report", "ody", "g", "ly", "By"], "uc": ["c", "stud", "cl", "ul", "sc", "ac", "ocr", "eu", "chu", "oc", "ub", "u", "ud", "loc", "bc", "cus", "tc", "mc", "cc", "roc", "nic", "usc", "uci", "gc", "cas", "uca", "ux", "cu", "rc", "uu", "userc", "UC", "ucc", "ec", "uch", "uh", "unc", "soc", "cur", "con", "auc", "pc", "fc", "asc", "anc", "cmp", "nc", "lc"]}}
{"id1": "3756429", "id2": "7761195", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"scramble": ["scambles", "scrambled", "screambled", "screamble", "scrimbling", " unscramble", "scamble", "scrimbled", "scrambles", " unscrambles", "scrimbles", " unscrambling", "scambling", " unscreamble", "scrambling", "screambles", "screambling", "scrimble", "scambled", " unscreambling", " unscreambles", " unscrambled", " unscreambled"], "text": ["aut", "content", "t", "object", "th", "buffer", "read", "str", "data", "html", "ext", "log", "tt", "test", "document", "print", "now", "TEXT", "body", "string", "source", "pattern", "input", "path", "title", "nt", "name", "command", "value", "template", "message", "output", "char", "act", "config", "code", "msg", "cont", "word", "Text", "txt"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "dr", "sd", "sm", "mand", "ind", "mt", "mod", "add", "dd", "hd", "mc", "sha", "cmd", "df", "mk", "mb", "dm", "mo", "pd", "nt", "material", "grad", " MD", "me", "mp", "d", "ma", "der", "ld", "rm", "mn", "od", "def", "met", "m", "sh", "red", "mm", "mg", "ms"], "sb": ["lb", "zb", "bg", "lp", "sg", "bd", "bh", "bs", "bf", "bis", "sq", "bt", "ib", "sa", "ab", "ssl", "mb", "eb", "sth", "cb", "ob", "obb", "SB", "sl", "rb", "soc", "gb", "erb", "nb", "pb", "bj", "kb", "xb", "abs", "bp", "obs", "gob", "shell", "sf", "sp", "bsp", "db", "ub", "bb"], "b": ["c", "B", "t", "v", "wb", "bi", "k", "bs", "u", "fb", "bc", "ib", "bt", "ab", "r", "eb", "cb", "br", "obj", "rb", "a", "n", "f", "d", "be", "gb", "o", "nb", "bp", "kb", "j", "m", "z", "code", "bit", "g", "s", "i", "bu", "db", "bb"]}}
{"id1": "160739", "id2": "8665321", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createInputFile", "createInputSteam", " createOutFile", " createInputstream", " createOutputstream", " createInputFile", "createInputstream", " createOutputSteam", " createFileSteam", " createOutStream", "createOutputFile", "createInputStream", "createOutputSteam", " createFileFile", " createInputSteam", " createOutSteam", " createInputStream", " createOutstream", " createOutputFile", " createFilestream", " createFileStream", "createOutputstream"], "inFile": [" inPath", " infile", "dinFile", "ninfile", " inDir", "dinPath", "infile", "ninFilename", "inPath", "outPath", "inputPort", "outFilename", " inPort", "dinDir", "inPort", "ninFile", "inputPath", "outfile", "ninPath", "inputFile", "inputDir", "inFilename", "inDir", " inFilename", "dinPort"], "outFile": ["outPlace", "newPlace", "toPort", "OutFilename", "tofile", "outputPlace", "infile", "OutFile", "newFilename", "outFilename", "toFile", "inPort", "toFilename", "outputfile", "newFile", "exfile", "outPort", "outfile", "exFile", "outputFile", "outputFilename", "OutPort", "inFilename", "Outfile", "exPlace", "newfile", "exFilename"], "k_blockSize": ["k_byteName", "k_BlockStyle", "k2blockSize", "k4blockName", "k_BlockName", "k4BlockName", "k_byteLength", "k2byteCount", "k_blockCount", "k_batchLength", "k_batchCount", "k4blockSize", "k4blockCount", "k2byteTime", "k_blockName", "k2byteSize", "k_BlockSize", "k_batchTime", "k2blockTime", "k2byteLength", "k4BlockCount", "k_BlockCount", "k_blockTime", "k4BlockSize", "k4BlockStyle", "k_blockLength", "k_byteTime", "k_batchSize", "k_byteCount", "k_byteSize", "k_BlockLength", "k_blockStyle", "k4blockStyle", "k2blockLength", "k2blockCount", "k_byteStyle", "k_BlockTime"], "byteCount": [" bytePtr", "bitN", "bitCounter", "linecount", "bitSize", "byteCheck", "bbCount", "byteCode", "byteCounter", "bitCode", "bitCount", " bytecount", "byteN", " byteCheck", "linePtr", "blockCount", "bbN", "charPtr", "lineLength", "charcount", "bbSize", "blockCounter", "wordCount", "wordN", "bytecount", "charCount", "wordSize", "bitCheck", "charLength", "lineCount", "wordCode", "bitLength", " byteCounter", "blockLength", "blockCheck", "bbCode", " byteLength", "byteSize", "byteLength", "bytePtr"], "buf": ["bg", "img", "ctr", "cv", "Buffer", "buffer", "arr", "ctx", "str", "buff", "Buff", "raw", "batch", "b", "bc", "vec", "cmd", "alph", "proc", "queue", "uf", "cb", "bl", "rb", "conv", "bag", "mem", "exp", "cast", "seq", "pkg", "cur", "pb", "block", "cap", "cat", "tx", "fg", "bytes", "doc", "db", "msg", "bn", "txt"], "ofp": ["Ofp", "Ofd", " ofd", "OFP", " ofpa", "ofl", "ofpa", "owld", "ofd", "ofP", "owlP", "owlp", "Ofpa", " ofl", "OFp", "Ofl", "owlpa", "OfP", " ofP", "OFd", "OFl"], "zos": ["tis", "gs", "zb", "LOS", "amia", "ps", "esa", "es", "bs", "zin", "js", "rez", "sbm", "os", "hz", "sis", "psy", "nz", "cz", "python", "south", "zen", "jp", "webkit", "ze", "zer", "sch", "zh", "hess", "oss", "zona", "bes", "zag", "ws", "ossus", "zzle", "eros", "zl", "enos", "init", "los", "ez", "jas", "zu", "rose", "std", "zik", "css", "za", "zers", "settings", "zon", "rss", "z", "osi", "socket", "zo", "cos", "zi", "zes", "zip", "zy"], "osw": ["aospace", "sysW", "osd", "aosw", "cosew", "issw", "osrw", "iswx", "osswx", " osws", "osiw", "ossW", "sysrw", "owa", "aosrw", "oswa", "aosew", "osws", "aosws", "aosW", " ossw", "aoswd", "ow", " osW", "oW", "isW", " oswx", "osiwa", "ossw", "osW", "cosws", "osssw", "aoswa", "isw", "osswd", "syswd", "opace", "ospace", "oswd", "sysw", "osiW", "cosw", " osew", "oswx", "osipace", "cosd", "osew", " osd", "aosd", "ossrw"], "bw": [" bws", "obz", "bbem", "besw", "bsw", "pbew", "abew", " bwl", "bend", "wbz", "bew", "obwl", "sbw", "bws", "bbz", "wbwp", "obwk", "bewl", " bx", "bwb", "wbx", "sbwb", " bwk", "obwb", "bwl", "wbend", "pbwe", "obwt", "pbwt", "pbwy", "pbz", "nbew", "bbwp", "bbwt", "bwk", "bbend", "bbex", "rbws", "nbw", "pbwb", "abwe", "rbw", "bbx", " bex", "nbwy", "bz", "bewk", "wbw", " bem", "pbw", "sbz", "nbwe", "bx", "rbz", "bex", "bem", "bwt", "bbw", " bend", "bwy", "wbwt", "wbem", " bsw", "obsw", "bwe", "abw", "rbex", "sbwt", "bbws", "bwp", " bwp", " bwt", "abwy", "obw", " bz"], "zot": ["zeronet", "Zote", "zipiot", "zoonet", " ziat", "zote", "ziat", "zeror", "zerot", "zerhot", " zonet", " ziot", " zhot", "Zit", "Zot", "zipiat", " zo", "zerote", "zoo", " zote", "zerit", "zor", "zhot", "zonet", "zero", "zoot", "Zott", "zipot", "ziot", "ziphot", "zoor", "zott", "zeriat", " zott", "zeriot", " zor", "zerott", "zo"], "ifp": ["Ifjp", "ifP", "iwr", "ifjp", " ifP", " ifjp", "isth", "ihr", "iwtp", "isp", "Ifp", "iftp", " ifr", " iftp", "isjp", "ifth", "ihtp", " ifth", "ifr", "ihp", "isP", "ifd", "Ifth", "IfP", "iwd", "iwp", "ihd", " ifd"], "zis": [" zIS", " zi", "izisa", "zoiss", "izinit", "zisc", " zic", "zinit", " zisc", "ziss", "zipis", "zeris", "zisa", "ziinit", "ezis", "zerIS", "zoisa", "zoinit", "zipic", "ezi", "zois", " ziss", "izi", "zic", "zipIS", "ziiss", "ezisc", "zIS", "eziss", "ziis", "ziisa", "iziss", "zi", "izisc", "izis", "zeric"], "isr": ["itsr", " isrs", " iscr", "itsstr", "ispr", "issrs", "iosr", "isalstr", "sisrs", "sisr", "isalpr", "isalr", "isrc", "isalsr", "isstr", "iosstr", "iscr", " isrc", "itspr", "sisrc", "isrs", "iospr", "itssr", "siscr", "issr", "iossr", "isscr", "issrc"], "br": ["fr", "bd", "ctr", "vr", "gr", "Br", "sr", "bm", "dr", "bh", "ba", "bi", "shr", "mr", "js", "str", "bf", " Br", "lr", "pr", "b", "bt", "wr", "ber", "obl", "yr", "r", "tr", "hr", "bl", "rb", "ptr", "bro", "bj", "bp", "rel", "cr", "Fr", "BR", "bn", "kr"], "zit": ["ziti", "zeip", "izip", "zist", "ozit", "czot", "oziti", "zop", "ozip", "czunit", "zipit", "ziit", "zipIT", "ziist", "czit", " zop", "cziti", "lexIT", "zip", " zIT", "ezIT", "zlit", "zunit", "zipite", "lexIt", "ziIt", "lexit", "zipist", "czop", "zipIt", " zip", "iziti", "zeit", "czip", "izit", "ziplit", "zeop", "zIt", "zeot", "ezlit", " zlit", "zIT", "ezit", "ziIT", "ozunit", "zite", " zite", "ezite", "izunit", "lexist"]}}
{"id1": "13783898", "id2": "22993368", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "11183087", "id2": "10212189", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"doPost": ["Dopost", "handlepost", "handleAdd", "doPOST", "DoPOST", "handlePOST", "doAdd", " doAdd", "handlePost", "DoAdd", "DoPost", " doPOST", "dopost", " dopost"], "request": ["object", "run", "begin", "select", "web", "browser", "reference", "work", "address", "position", "frame", "search", "first", "list", "message", "subject", "initial", "model", "parent", "xml", "remote", "connect", "system", "version", "order", "server", "collection", "require", "client", "the", "application", "open", "req", "project", "get", "event", "record", "context", "law", "requ", "create", "user", "controller", "raw", "QUEST", "document", "post", "setup", "quest", "start", "url", "query", "question", "reset", "argument", "call", "forward", "re", "connection", "print", "complete", "register", "result", "input", "enter", "command", "handle", "Request", "http", "hello", "report", "current"], "response": ["reply", "respond", "content", "onse", "exit", "write", "status", "default", "view", "re", "connection", "server", "ce", "collection", "document", "image", "print", "next", "result", "e", "out", "application", "res", "success", "environment", "resp", "ve", "send", "frame", "service", "one", "context", "output", "message", "report", "entry", "to", "Response", "page"], "senha": [" senhi", "Senja", "tenHa", "ensenHA", "Senca", "senHa", "Senigma", "senja", "tinha", "tenwa", "tenja", "SenHA", "senHA", " senigma", "Senho", "Senwa", "senwa", "ensenca", "tinhas", "Senhas", "senho", "Senha", "ensenha", "tenha", " senho", "senigma", "Senhi", "renha", "renHa", "tinigma", "SenHa", " senHA", "senhas", " senhas", "renja", "ensenho", " senca", "renwa", "senca", "senhi", "tinhi"], "email": ["ip", "le", "license", "example", "echo", "detail", "secret", "oe", "ne", "live", "external", "el", "file", "username", "image", "e", "string", "line", "path", "ql", "alias", "mail", "address", "enter", "login", "IL", "name", "Mail", "password", "ails", "url", "Email", "elly", "gmail", "hello", "office", "lock", "sample", "domain", "message", "ilo", "label", "addr", "zip", "quote"], "messageDigest": ["messagemdest", "messageIGester", "messageDigester", "Messagedigse", "messagedigse", "messagediger", "messagemdester", "Messagedigester", "messageMDest", "messageDiger", "messageDigse", "messageIGse", "messageDester", "messageMDEST", "MessageDig5", "Messagedigest", "messagemdEST", "MessageDigEST", "messagedigEST", "messageDer", "MessagedigEST", "messageMDester", "messageIGest", "MessageDigest", "messageDse", "MessageDigester", "messagedig5", " messageDigester", "Messagedig5", " messagedigest", "MessageDigse", "messageDigEST", " messagedigester", " messagediger", "messagedigest", " messagedigse", " messageDiger", "messageDest", "messageDig5", "messagedigester", " messageDigse", "messageMDse", "messageIGEST", "messagemd5"], "usuario": ["usui\u00e9r", "usruarios", "usnuario", "cusu\u00e9r", "usruino", " ussuarial", "uscuario", "uscuarios", "uscuarial", "cussuario", "ussuarial", " usuarius", "uscuino", "usuarios", "ususarius", "ussuarios", " ussurio", "usruarial", "usnuarial", "ussuino", "ussuario", "ususrio", "cussuino", "usruario", "usnuarius", "cussu\u00e9r", "usuiarios", "ususarial", "usuino", "cusuarial", "ususario", " usuarial", "cusuarios", "ussuarius", "usu\u00e9r", " ussuarius", "cusuino", " ussuario", "usnurio", "ussu\u00e9r", "usuiarial", "uscu\u00e9r", "cussuarios", "ussurio", "usuarius", " usurio", "usuarial", "usurio", "usuiario", "cussuarial", "cusuario"], "redirect": ["redrict", "indirect", "edir", " redirection", "Redirection", "reddigate", "Reddraw", "ederer", " redurl", "Redirect", "redirection", "reddRECT", "inderer", " reddraw", "preddraw", "predirect", " redir", "indrict", "redigate", "rightigate", "REDir", "Redurl", "reddraw", "RedRECT", "redRECT", "predirection", "edirect", "rightRECT", "rightirection", "REDirect", "REDurl", "indirection", "rightirect", "predurl", "edirection", "redir", "Redigate", "redurl", "Rederer", "Redrict", "reddirection", "reddirect", "rederer", "edrict", "edurl", "REDirection"], "session": ["save", "instance", "state", "current", "connection", "data", "user", "server", "shared", "relation", "still", "sid", "client", "browser", "ess", "input", "cache", "application", "activity", "environment", "metadata", "ESSION", "Session", "params", "layout", "use", "cookie", "json", "container", "ession", "local", "context", "sql", "condition", "group", "person", "store", "task", "s", "trip", "window", "system"]}}
{"id1": "18217985", "id2": "3252116", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 0, "substitutes": {"fromHtml": ["fromTttp", "fromVml", "fromJml", " fromJhtml", " fromJtml", "fromVt", " fromHml", "fromXml", " fromJml", "fromPhhtml", " fromHttp", " fromXtml", "fromTtml", "fromJtml", " fromJt", "fromPhttp", " fromXhtml", "fromJt", "fromVhtml", "fromXttp", "fromPhtml", "fromJhtml", "fromPht", "fromHhtml", " fromHhtml", "fromHml", "fromVtml", " fromXttp", " fromHt", "fromPhml", "fromTml", "fromXhtml", "fromHttp", "fromXtml", "fromThtml", "fromHt", " fromXml"], "url": ["content", "dl", "ml", "location", "org", "request", "build", "ul", "rl", "host", "nl", "mount", "str", "connection", "base", "html", "server", "u", "this", "el", "file", "log", "loc", "document", "l", "b", "gl", "web", "uri", "https", "il", "string", "r", "ssl", "cert", "library", "ls", "job", "mail", "ref", "address", "name", "un", "bel", "ur", "get", "http", "element", "value", "ll", "link", "domain", "rel", "URL", "char", "call", "config", "xml", "resource", "Url", "page"], "defaultEncoding": ["defaultMetending", "DefaultEnoding", " defaultEngoding", " defaultEnoding", "defaultCoding", "defaultEncation", "defaultDecation", "defaultMetryption", "defaultEncryption", "defaultencale", "defaultencoding", "defaultDecale", "defaultEncling", "defaultCling", "defaultEnapping", "DefaultEncation", "defaultCryption", " defaultEncending", "DefaultEncale", "defaultEngryption", "defaultEnation", " defaultEngending", "DefaultEncoding", "defaultEngapping", "defaultEnending", " defaultEngapping", " defaultEncapping", "defaultEnling", "defaultEnoding", "defaultDecapping", "defaultDecling", "defaultCapping", " defaultEnling", "defaultencling", "defaultMetapping", "defaultEncapping", " defaultEnryption", " defaultEncling", "defaultencation", "defaultEnryption", " defaultEnapping", " defaultEngryption", "defaultEnale", "DefaultEnation", " defaultEncryption", "DefaultEnale", "defaultEngending", "defaultEncending", "defaultDecryption", "DefaultEnling", "defaultDecoding", "defaultEngoding", "DefaultEncling", "defaultMetoding", "defaultEncale"], "overrideEncoding": ["overOverrideencryption", "overrideEnoding", "overOverrideEncging", "overrideEncording", "overOverrideencording", "overrideencoding", "overrideencording", "overOverrideencoding", "overOverrideEncoding", "overrideencryption", "overrideEnording", "overrideEnging", "overOverrideencging", "overrideCollging", "overrideCollording", "overrideEncryption", "overrideEnryption", "overOverrideEncording", "overrideencging", "overrideColloding", "overrideCollryption", "overOverrideEncryption", "overrideEncging"], "conn": ["ct", "close", "enc", "ctx", "cont", "connection", "Conn", "col", "ca", "reg", "loc", "ait", "jp", "comm", "cell", "https", "pas", "sys", "cc", "cmd", "client", "cp", "cert", "out", "ls", "cb", "res", "open", "obj", "phys", "nt", "conv", "iw", "handle", "resp", "cur", "con", "ll", "gate", "Connection", "ch", "cn", "com", "socket", "addr", "act", "pg", "nc", "connect", "lang"], "contentType": ["ContentTime", "imagetype", "ontentSource", "contentTypes", " contentTypes", "codeTYPE", "ontentTypes", "dataName", "ContentLength", " contentTYPE", " contentVersion", "cacheTYPE", "addressType", " contentName", "timetype", "reasonTime", "imageType", " contentCase", "callTyp", "contentSource", "ontentLength", " contentSource", "ContentTypes", "ontentName", " contentClass", "entityTypes", "reasontype", "resourceCase", "contentString", "cacheVersion", "ContentType", "trustTyp", "contentVersion", "ontenttype", " contenttype", "ontentTime", "resourcetype", " contentTime", "resourceTime", "ontentEvent", "entityType", "cacheType", "contenttype", "trustStyle", "cellModel", "addressString", "ContentSource", "ContentName", " contentModel", "contentName", "ontentVersion", " contentString", "contentStyle", "codetype", "contentEvent", "ontentTYPE", "ontentModel", "contentTime", "contentCode", "dataCode", "contentModel", "codeName", "dataType", "entityName", "resourceType", "ContentCode", " contentTyp", "cacheTime", "timeType", "ContentString", " contentCode", "reasonCase", "dataLength", "ontentString", "cellName", "contentLength", "timeClass", "contentClass", " contentEvent", "cellType", "imageName", "ontentType", " contentLength", "codeType", "contentTYPE", "contentCase", "timeTime", "imageTYPE", " contentStyle", "callType", "addressEvent", "entityLength", "trustType", "contentTyp", "ontentClass", "callStyle", "reasonType"], "encoding": ["decoded", "enling", "entryption", "entoder", "Encryption", "enclanguage", "encication", "colloder", "decoder", "ecryption", "equale", "decryption", "collryption", "contension", "extension", "codication", "decoding", "contentoding", "encaching", "collling", "coder", "eclanguage", "enaching", "contentation", "enning", "cododer", "cododing", "equoding", "encling", "Encale", "encending", "entaching", "entoding", "continending", "continacing", "ecaling", "cryption", "extoder", "Encication", "encryption", "encension", "Encation", "enlanguage", "decension", "ecacing", "continlanguage", "continoding", "contoder", "encoder", "coding", "encale", "enication", "Encoding", "contentending", "penoder", "encning", "penryption", "ecging", "encging", "encation", "enoder", "ecending", "colloding", "extoded", "enryption", "cale", "enoding", "decaling", "contoded", "penling", "contentning", "enending", "Encging", "enacing", "encoded", "encacing", "enation", "Encoder", "Encaling", "ecning", "extoding", "ecoding", "penoding", "encaling", "codation", "equryption", "ecation", "equoder", "decging", "caching", "contoding"], "i": ["ip", "ori", "li", "io", "y", "iy", "bi", "ii", "phi", "multi", "xi", "I", "id", "ui", "ind", "mi", "iu", "pos", "oi", "ski", "gi", "uri", "iter", "hi", "cli", "ami", "x", "iso", "ti", "ie", "is", "ci", "pi", "me", "qi", "ia", "f", "si", "init", "ix", "info", "di", "ini", "ims", "it", "sim", "j", "fi", "m", "ai", "zi", "ic", "ri"], "s": ["qs", "gs", "sb", "t", "ss", "ps", "v", "ats", "bs", "less", "js", "str", "os", "sv", "sq", "l", "b", "south", "https", "string", "sys", "r", "ds", "ess", "is", "ls", "ys", "sl", "spec", "n", "its", "p", "sw", "fs", "ims", "rs", "S", "sts", "sample", "abs", "sp", "sql", "j", "ns", "m", "g", "h", "ts", "sf", "source", "set", "ms"], "expected": ["t", "checked", "example", "encrypted", " Expect", " exp", "type", " expects", " needed", "default", "needed", "supported", "seen", "prop", "used", "pect", "test", " allowed", " expectation", "actual", " assumed", " awaited", "reported", "pattern", " unexpected", " required", "awaited", "allowed", "ped", "sent", "found", "format", "pecting", "foo", "specified", " desired", " expect", " expecting", "pected", "want", "pretty", "announced", "exp", "pe", "p", " supposed", "required", "template", "value", "event", "posted", "forced", "message", "provided", "ex", " wanted", "empty", " mock", " inspected", "fake", "should", "current", "ed"], "index": ["level", "Index", "scale", "count", "exit", "unit", "location", "instance", "point", "active", "inc", "length", "ind", "pos", "test", "loc", "dimension", "add", "draw", "prefix", "axis", " Index", "mix", "nn", "shape", "x", "ice", "zero", "no", "ax", "cond", "slice", "success", "address", "position", "loop", "capacity", "diff", "height", "timeout", "find", "number", "search", "num", "size", "condition", "config", "second", "ion", "connect", "key"], "msg": ["gs", "bg", "sg", "gr", "meg", "med", "cfg", "str", "sm", "md", "nom", "log", "urg", "SG", "kg", "cmd", "Msg", "mess", "mk", "mb", "gp", "alg", "err", "mag", "reason", "notice", "contact", "Message", "mn", "crit", "message", "gov", "gm", "ug", "m", "nm", "mu", "g", "warn", "mg", "ms"], "in": ["reader", "bin", "din", "stream", "id", "rin", "ind", "en", "inner", "serv", "ain", "ck", "mc", "out", "r", "is", "input", "er", "In", "n", "on", "p", "f", "gin", "o", "IN", "mn", "ini", "con", "it", "from", "ins", "inn", "cin", "h", "ad", "ic", "by", "and"]}}
{"id1": "21979714", "id2": "10674824", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "label": 0, "substitutes": {"list": ["version", "scan", "count", "create", "request", "read", "detail", "close", "LIST", "test", "download", "print", "lists", "add", "dump", "ls", "check", "format", "export", "get", "init", "load", "search", "info", "query", "report"], "url": ["lb", "sb", "dl", "ocl", "org", "build", "ul", "conn", "nl", "cal", "uc", "str", "atl", "file", "loc", "l", "gl", "uri", "https", "il", "arl", "cp", "r", "client", "ssl", "ls", "www", "gc", "ob", "open", "sl", "un", "ur", "f", "pl", "http", "ll", "abs", "URL", "fc", "char", "Url"], "con": ["c", "ct", "cl", "create", "trans", "close", "can", "conn", "sin", "ver", "cone", "cal", "Con", "connection", "fac", "Conn", "uc", "pen", "pos", "go", "sub", "bc", "ln", "ain", "cp", "client", "cmd", "cons", "CON", "open", "don", "conv", "connect", "ran", "un", "on", "co", "coll", "soc", "win", "cur", "conf", "num", "cn", "cm", "gate", "fc", "canon", "dial", "ex", "syn", "com", "cin", "ctrl", "cos", "act", "nc", "cf"], "in": ["bin", "din", "asin", "inc", "isin", "rin", "ind", "file", "inner", "ln", "inf", "ain", "vin", "out", "is", "input", "up", "In", "on", "get", "p", "gin", "per", "f", "win", "info", "conf", "IN", "sql", "sum", "from", "ins", "inn", "cin", "to", "i", "sin", "oin", "by"], "buf": ["img", "tmp", "cv", "Buffer", "stab", "buffer", "bin", "arr", "printf", "str", "data", "buff", "Buff", "fb", "log", "batch", "b", "temp", "cf", "bt", "iter", "vec", "bar", "cmd", "alph", "queue", "uf", "mb", "cb", "br", "bl", "rb", "conv", "aka", "bag", "mem", "pkg", "seq", "cur", "cap", "cat", "tx", "bytes", "db", "que", "good", "bn", "txt"], "bytesRead": ["stepsHave", "timesFind", "filesReader", " bytesHave", "timesNeed", "BytesWritten", "pointsNeed", "gradesRead", "bytesNeed", "bytesLoad", " bytesNeed", "mapsHave", "BytesHave", "bytesHave", "BytesRead", "cellsBuild", "gradesLoad", "bytesFind", "filesFind", "pointsFind", "mapsWritten", "bytesReader", "cellsLoad", "BytesNeed", "stepsBuild", "cellsRead", "timesReader", "stepsRead", "bytesWritten", "pointsReader", "timesRead", "bytesBuild", " bytesWritten", "mapsNeed", "stepsLoad", "cellsHave", "filesRead", "filesNeed", "pointsRead", "gradesBuild", "mapsRead", "gradesHave"]}}
{"id1": "3409084", "id2": "5836744", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["getStringEntity", "getResponseEntity", "getStringBody", "getStringData", "getStringContent", "getRequestData", "postRequestData", "postResponseContent", "postRequestEntity", "postRequestContent", "postResponseBody", "postResponseData", "getRequestBody", "getResponseData", "getResponseContent", "getResponseBody", "postRequestBody", "getQueryContent", "getQueryData", "getQueryEntity", "postResponseEntity", "getQueryBody", "getRequestEntity"], "urlText": ["textString", "uritext", "texttext", "textName", "Urltext", "urlName", "urlCh", "urltext", "urlString", "uriCh", " urlName", "UrlName", "UrlText", "stringCh", "uriText", "stringtext", "UrlString", " urltext", " urlCh", "textText", "stringText", " urlString"], "url": ["lb", "dl", "org", "build", "ul", "rl", "re", "nl", "mount", "str", "base", "atl", "auto", "el", "loc", "l", "web", "gl", "google", "uri", "il", "oul", "r", "ssl", "browser", "ls", "www", "email", "ref", "sl", "uu", "bel", "ur", "f", "pkg", "github", "http", "ll", "hl", "abs", "URL", "char", "Url"], "urlcon": ["dllconn", "httpCon", "UrlCon", " urlconv", "dllconst", "Urlconn", "urlcom", "urlconst", "httpconv", "URLcom", "orgcon", "Urlcon", "urlCon", "urlconv", "orgCon", "sslCon", "httpres", " urlCon", "sslfun", "urlconn", "URLconn", "URLcon", "httpconnect", "httpfun", "urlres", "httpcon", "urlconnect", " urlcom", " urlfun", "Urlconst", "sslconv", " urlres", "httpconst", "httpconn", "sslcon", "dllcon", " urlconn", " urlconnect", "orgres", "dllCon", "urlfun", "Urlcom", "orgconnect"], "reader": ["read", "buffer", "worker", "dr", "rd", "ader", "READ", "instance", "rl", "view", "stream", "rx", "data", "comment", "test", "inner", "image", "review", "loader", "radio", "Reader", "ro", "older", "iter", "dd", "parser", "r", "ner", "operator", "upper", "draft", "rar", "rc", "er", "per", "wrapper", "info", "row", "reading", "roller", "reads", "runner", "readable", "master", "holder", "handler", "red", "writer", "source", "iterator"], "line": ["content", "text", "request", "detail", "lin", "inline", "nl", "str", "column", "comment", "log", "file", "LINE", "print", "l", "ln", "trace", "continue", "result", "cell", "eline", "Line", "string", "out", "piece", "chain", "ine", "name", "command", "pe", "frame", "list", "channel", "row", "link", "sample", "block", "sequence", "message", "response", "char", "lines", "entry", "page", "lc", "header"]}}
{"id1": "15645004", "id2": "7149578", "code1": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"unzip": ["unpack", "unpackage", "openpack", "undrop", "openzip", "Unpackage", "Unzip", "openpackage", "Unpack", " unpack", "Undrop", " undrop", " unpackage", "opendrop"], "filename": ["println", "location", "src", "nl", "fil", "archive", "FILE", "doi", "csv", "file", "File", "ame", "bf", "existent", "username", "prefix", "nil", "uri", "word", "source", "path", "ename", "title", "name", "metadata", "n", "url", "p", "NAME", "f", "SourceFile", "pkg", "folder", "directory", "fp", "kl", "via", "Filename", "subject", "nm", "ivo", "sf", "zip", "fn", "kj", "txt"], "in": ["io", "reader", "bin", "din", "ry", " din", "inv", "inc", "isin", "rin", "ind", "mi", "file", "en", "ill", "inner", "add", "ze", "ln", "zip", "inf", "inside", "iter", "vin", "out", "is", "pin", "input", "al", "up", "In", "gin", "init", "info", "ini", "IN", "conf", "con", "local", "it", "fin", "sum", "from", "ar", "ins", "ex", "inn", "ir", "cin", "mm", "i", "ic", "ri", "and"], "entry": ["system", "instance", "ry", "member", "se", "or", "part", "connection", "archive", "comment", "attribute", "file", "ce", "inter", "card", "existent", "image", "add", "inner", "next", "e", "je", "result", "cell", "ent", "pattern", "ie", "line", "item", "index", "check", "entity", "obj", "enter", "nt", "ace", "Entry", "header", "pe", "info", "element", "directory", "row", "list", "rance", "match", "event", "record", "existing", "link", "field", "from", "char", "zo", "xml", "zip", "word", "qual", "key", "set", "def"], "first_entry": ["firstKnownfile", "first_ent", "first_iterator", "first_connection", "first_file", "First_file", "First_needed", "first_directory", "First_existent", "first_record", "firstKnownexistent", " first_Entry", "firstKnownentry", "firstKnownneeded", " first_directory", " first_record", "first_needed", " first_connection", "first_existent", " first_ent", " first_iterator", "first_Entry", "First_entry"], "subdir": ["relfolder", "ubgroup", " subfolder", "Subdef", "subfolder", "Subdir", " subdel", "subvol", "Subdel", "reldir", "supdir", "superdel", "SubDir", "subdel", " subdef", "ubdel", " subgroup", "supfolder", "subDir", "supdel", "Subvol", "subdef", "Subfolder", "superdir", "relvol", "ubfolder", "superfolder", "supgroup", "ubvol", "ubDir", "subgroup", "ubdir", "relDir", "ubdef", " subDir"], "dir": ["tmp", "io", "wd", "dr", "copy", "src", "id", "ind", "file", "pos", "dest", "div", "loc", "self", "mod", "prefix", "temp", "uri", "iter", "out", "path", "Dir", "DIR", "name", "direction", "root", "url", "fd", "folder", "d", "init", "pkg", "all", "directory", "row", "cur", "module", "vol", "desc", "ir", "doc", "addr", "parent", "zip", "window", "db"], "outfile": ["altFile", "outline", "inline", "outFile", "infile", "altfile", "inload", "Outdb", "OutFile", "fromfile", "infield", "outputdir", "newdir", "Outlink", "altload", "fromline", "outputfile", "newFile", " outFile", "fromfield", "newlink", "outlink", "outputFile", "outdb", "Outdir", "outputdb", "outfield", "indb", " outload", "inFile", "Outfile", "outputline", "outload", "indir", " outlink", "fromFile", "newfile", "outputfield"], "outdir": ["outputDir", "newDir", "OUTrun", "subfolder", "outwd", "outfolder", "Outcond", "Outrun", "OUTfolder", "subcond", "outputfolder", " outfolder", " outfd", "outputwd", "Outfolder", "outDir", "outputdir", " outdb", "newdir", "outrun", "newdb", "outfd", "outcond", "OUTdir", "newfolder", "OUTcond", "subrun", "outdb", "Outdir", "outputdb", " outwd", "subdb", " outDir", "subwd", "subfd", "outputfd"], "fo": ["io", "obo", "te", "oe", "po", "ero", "hea", "os", "sty", "uo", "oo", "ato", "so", "ho", "FO", "xf", "flo", "eto", "ott", "mo", "wo", "tif", "co", "soc", "aco", "opa", "info", "o", "bo", "wt", "fi", "jo", "zo", "fif", "oos", "oso"], "bos": ["dos", "nos", "mos", "pdf", "bin", "ots", "bi", "bh", "es", "bs", "fits", "js", "os", "bis", "bas", "cs", "so", "aos", "bits", "ts", "sys", "ows", "oss", "ds", "bes", "bys", "ops", "ws", "tops", "uts", "eros", "boards", "oops", "los", "fs", "jas", "outs", "bo", "ios", "obs", "bytes", "cos", "zo", "ods", "uds", "oos", "tes"], "read": ["parse", "text", "count", "write", "buffer", "build", "close", "copy", "READ", "view", "run", "stream", "bind", "length", "select", "transfer", "log", "en", "print", "add", "draw", "next", "continue", "give", "iter", "allow", " Read", "input", "index", "fill", "check", "open", "pack", "end", " count", "n", "loop", "start", "old", "play", "get", "send", "feed", "len", "load", "find", "val", "first", "Read", "query", "depth", "w", "reading", "reads", "size", "seek", "readable", "ad", "skip", "ready"], "data": ["content", "text", "dl", "results", "buffer", "bin", "DATA", "pad", "extra", "str", "ata", "length", "raw", "batch", "image", "bus", "da", "next", " DATA", "out", "no", "zero", "cache", "res", "step", "partial", "dat", "n", "d", "all", "json", "number", "value", "o", "row", "sample", "sequence", "size", "message", "valid", "ATA", "bytes", "area", "done", "block", "table", "good", "window", "def"], "read_position": [" read_location", " read_size", "read_size", " read_chain", "read_location", "read_chain"]}}
{"id1": "21531069", "id2": "17202157", "code1": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "code2": "    static Matrix readMatrix(String filename, int nrow, int ncol) {\n        Matrix cij = new Matrix(nrow, ncol);\n        try {\n            URL url = filename.getClass().getResource(filename);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            for (int i = 0; i < nrow; i++) for (int j = 0; j < ncol; j++) cij.set(i, j, Double.parseDouble(lnr.readLine()));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return cij;\n    }\n", "label": 0, "substitutes": {"updateuser": ["UPDATEuser", " updateusername", "setuser", "updateusers", " updateaccount", "updateaccount", " updateusers", "UPDATEusers", "UPDATEusername", "setusers", "setaccount", "UPDATEaccount", "updateusername", "setusername"], "u": ["c", "fu", "uv", "du", "ul", "nu", "eu", "uid", "user", "ui", "ud", "iu", "ut", "b", "gu", "su", "hu", "uni", "out", "uf", "ux", "ue", "util", "cu", "uu", "up", "un", "ur", "o", "pu", "uj", "ju", "tu", "bo", "au", "you", "U", "mu", "us", "lu", "ru", "bu", "ou"], "i": [" bi", "c", "t", "li", "y", " im", " I", "v", "bi", "in", "ii", "phi", "I", "xi", "mi", "iu", "oi", "l", "e", "gi", "im", " n", "hi", "r", "cli", "x", "is", "ti", "ki", " iT", "index", "ri", "ci", "pi", "n", "iat", "p", "iri", "qi", "f", "si", "di", "ini", "ei", "o", "it", "j", "fi", "m", "ai", " j", "iti", "ic", " Ai"], "conn": [" ac", "org", "ann", " comm", "ctx", "Con", " cc", " ch", " ce", "en", "comm", " con", "cp", "cmd", "cert", "conv", "conf", "con", "cm", "j", " connection", "socket", "addr", "sp", "tn", "ht", "connect", " c", "po", "js", " cx", " cont", "ont", "pt", "cell", "cc", "client", "nec", "open", "req", " cur", "wp", "net", "Connection", "gate", " ex", " cs", "ca", "pg", "ct", "tp", "ln", "pas", " mc", "att", "nt", "dat", "resp", "p", "pkg", "cur", "yn", "cn", "dial", "gn", "nc", "cont", "db", "c", "cl", "close", "enc", "connection", "Conn", "loc", "pool", "jp", " core", "cb", " net", "obj", "iw", "n", "co", " pc", "win", "ch", "bo", "port", "ns"], "pm": ["lp", "ps", "pa", "rpm", "px", "bm", "asm", "pn", "mr", "po", "js", "rem", "md", "py", " mp", "mt", "mi", "PM", "pr", "om", "pool", "esm", "jp", "pt", "vp", "hm", "ph", "cp", "ams", "mk", "fm", "pi", "pd", "vm", "tm", "term", "pol", "mp", "p", "pkg", "pl", "perm", "mx", "ym", "wp", "pb", "am", "rm", "em", "pc", "cm", "gm", "arm", "pp", "m", "nm", "dem", "mm", "pse", "lem", "mmm", "ms"]}}
{"id1": "22046596", "id2": "8069594", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" move", "write", " replicate", " rename", " mirror", "upload", " duplicate", "transfer", " dup", " cp", " restore", " swap", " replace", "cp", " copying", " parallel", " insert", " populate", "paste", " seek", " overwrite", " share", " cop", "Copy", " paste", " Transfer", " extend"], "s": ["qs", "gs", "sb", "ss", "ies", "ps", "v", "es", "ats", "less", "src", "js", "str", "os", "sv", "sq", "gets", "b", "l", "south", "cs", "string", "ds", "is", "input", "ls", "ms", "ys", "sl", "ws", "n", "its", "p", "f", "ses", "fs", "rs", "S", "sts", "st", "ins", "z", "g", "sf", "ts", "ns", "source", "xs"], "t": ["T", "ct", "v", "te", "k", "tt", "mt", "test", "l", "kt", "pt", "at", "ent", "tc", "ot", "gt", "tr", "title", "nt", "n", "p", "f", "rt", "o", "template", "it", "w", "ret", "j", "st", "unt", "wt", "g", "h", "i", "ts", "ht", "txt"], "in": ["io", "bin", "din", " din", "user", "inc", "isin", "rin", "ind", "mi", "en", "inner", "inf", "im", "inside", "source", "iter", "ie", "is", "input", "up", "In", "gin", "init", "info", "IN", "con", "it", "from", "ar", "ins", "ir", "inn", "cin", "ai", "i", "ic", "sin", "oin", "and"], "out": ["c", "io", "v", "can", "k", "or", "ac", "conn", "by", "this", "en", "l", "b", "result", "gt", "sys", "client", "ot", "check", "res", "nt", "up", "n", "co", "channel", "o", "net", "con", "cn", "it", "w", "outs", "Out", "output", "j", "ch", "ex", "to", "g", "msg", "i", "ou", "aos", "OUT", "outer"]}}
{"id1": "14609912", "id2": "5138455", "code1": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"lastModified": ["lastVerified", "LastModified", "lastQualified", "lastMinUsed", "lastQualmented", "LastVerification", "lastModUsed", "lastVermented", "LastModUsed", "lastQualification", "LastVerUsed", "lastMinified", "lastQualUsed", "lastModmented", "lastMinmented", "LastModification", "lastMinification", "lastModification", "lastVerification", "LastModmented", "lastVerUsed", "LastVermented", "LastVerified"], "url": ["dl", "build", "in", "host", "nl", "run", "re", "str", "mount", "user", "file", "l", "b", "web", "uri", "string", "cmd", "client", "browser", "ssl", "cert", "job", "dll", "ref", "sl", "address", "name", "un", "ur", "get", "http", "ll", "link", "abs", "ret", "URL", "char", "Url", "page", "key"], "conn": ["c", "ct", "close", "enc", "ctx", "connection", "Conn", "loc", "jp", "comm", "serv", "cell", "pas", "client", "cmd", "oss", "cert", "nec", "cb", "cons", "res", "open", "obj", "nt", "conv", "dat", "n", "exec", "resp", "cur", "net", "con", "cn", "gate", "ch", "fin", "sql", "j", "canon", "socket", "addr", "db", "nc", "connect"]}}
{"id1": "4852691", "id2": "3536332", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"hash": [" Hash", " text", " sum", "run", " check", "id", "Hash", "print", "dump", "hex", " encoding", " key", "string", "update", " hashing", "sign", " equals", " message", " h", " fingerprint", "sum", "code", " salt", "h", " signature", " mac"], "data": ["content", "text", "any", "buffer", "secret", "state", "padding", "DATA", "space", "ata", "this", "raw", "batch", "image", "dump", "result", "action", "string", "input", "name", "dat", "command", "password", "d", "json", "hello", "value", "info", "sample", "sequence", "message", "output", "area", "bytes", "what", "form"], "digest": ["duist", "deEST", " hexests", "digests", "digse", "deest", " digEST", "redist", "mdest", " digger", "duest", " digester", "signested", "Digests", "digute", " hexute", " digse", "redger", "signEST", "redose", "mdse", "digester", " hexested", "mdester", "duger", " digested", " digose", "Digute", " digests", "digEST", "digested", "DigEST", "digger", "redest", " digute", "Digist", "signse", "mdEST", "digose", "duose", "dese", " digist", "Digest", "digist", "Digester", "Digested", "signest", "mdested", " hexest", "deist", "Digse"]}}
{"id1": "18489832", "id2": "21425787", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadZressedImage", " tryLoadXZipfile", " tryLoadZippedFile", " tryLoadXippedfile", " tryLoadZZipFile", " tryLoadXippedDir", " tryLoadZressedfile", " tryLoadZressedDir", " tryLoadZppedfile", " tryLoadXZipImage", " tryLoadZippedfile", " tryLoadZippedDir", " tryLoadXippedImage", " tryLoadZressedFile", " tryLoadZppedImage", " tryLoadXZipFile", " tryLoadZZipfile", " tryLoadZippedImage", " tryLoadZppedDir", " tryLoadZZipDir", " tryLoadZppedFile", " tryLoadXZipDir", " tryLoadXippedFile", " tryLoadZZipImage"], "url": ["parse", "dl", "location", "request", "build", "ul", "nl", "mount", "str", "base", "external", "log", "file", "raw", "l", "b", "loader", "web", "uri", "https", "r", "ssl", "browser", "open", "err", "ref", "sl", "address", "name", "un", "ur", "get", "http", "row", "ll", "link", "ret", "URL", "char", "call", "xml", "Url", "key"], "destDir": ["originDir", "originFolder", "distDIR", "targetDirectory", "originDirectory", " destFolder", " destFile", "originDIR", "sourceDir", "sourceDirectory", "sourceFile", "destFolder", "targetDIR", "targetDir", "destDirectory", " destDIR", "distDirectory", "targetFolder", " destDirectory", "sourceFolder", "destDIR", "srcFile", "distFolder", "srcDIR", "destFile", "srcDir", "srcFolder", "distDir", "srcDirectory"], "urlConnection": ["streamCompany", "UrlConnect", "UrlConnection", "httpConnect", "urlDialog", "streamConnection", "urlConnect", "streamClient", "urlLink", "urlCompany", "httpDialog", "streamConnector", "UrlDialog", "URLConnection", "httpLink", " urlConnect", " urlDialog", "URLCompany", "urlClient", " urlCompany", "UrlLink", "URLConnector", " urlConnector", " urlClient", "URLClient", "httpConnection", "urlConnector", " urlLink"], "tmpFile": ["tempFilename", " tmpfile", "destPage", "tempPage", "tempFile", "tmpPage", "empTile", "empFile", "thisFilename", "empDir", "tempTile", "tmpTile", "mpFile", "empFilename", " tmpView", "tmpfile", " tmpTile", "tmpBe", "tmpView", "cmpFile", "destfile", "tempChain", "empChain", "empView", "cmpfile", " tmpDir", " tmpPage", "cmpPage", "destBe", "thisChain", "tempView", "tempDir", " tmpFilename", " tmpBe", "empfile", "tempBe", "thisfile", "tmpFilename", "cmpFilename", "tmpDir", "destFile", "mpfile", "tmpChain", "thisFile", "tempfile"], "in": ["ains", "bin", "din", "or", "sin", "re", "inc", "isin", "rin", "ind", "mi", "el", "en", "inner", "l", "ze", "ln", "inf", "ain", "inside", "im", "iter", "as", "ie", "is", "none", "input", "index", "al", "up", "In", "n", "on", "old", "co", "pass", "gin", "ma", "init", "all", "win", "info", "ini", "IN", "query", "con", "one", "it", "st", "from", "ins", "inn", "cin", "ai", "i", "source", "oin", "by"], "out": ["t", "tmp", "io", "exit", "v", "can", "write", "or", "oe", "po", "ne", "col", "os", "OU", "external", "print", "at", "ent", "na", "flush", "sys", "client", "oss", "no", "obj", "nt", "up", "conv", "n", "note", "on", "co", "all", "o", "net", "con", "one", "cn", "outs", "ch", "it", "output", "Out", "ex", "null", "to", "cos", "writer", "ou", "aos", "OUT", "outer"], "localURL": ["LocalLL", " localUrl", "publicURI", "LocalUrl", "publicUrl", "localhostURL", "publicUR", "publicURL", " localUL", "localLL", " localLL", "localID", "LocalURI", "localUrl", "LocalUL", "localUL", "localURI", "LocalUR", "localhostUL", " localID", "localhostLL", " localUR", "LocalURL", "localUR", " localURI", "localhostID", "LocalID"]}}
{"id1": "397240", "id2": "12782570", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "20751378", "id2": "7981642", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["updatePassword", "HashPrivate", " hashPrivate", "updatePrivate", "HashPassword", " hashpassword", "hashPrivate", " hashText", "Hashpassword", "updatepassword", "hashpassword", "hashText", "HashText", "updateText"], "password": ["encrypted", "request", "wd", "secret", "padding", "PASS", "default", "key", "connection", "user", "column", "comment", "attribute", "username", "phrase", "print", "prefix", "expression", "language", "sword", "string", "client", "pattern", "security", "crypt", "input", "application", "device", "email", "database", "address", "login", "name", "command", "wordpress", "shadow", "pass", "p", "token", "description", "property", "hello", "value", "directory", "query", "w", "message", "argument", "reset", " Password", "auth", "word", "Password"], "hash": ["object", "oh", "also", "has", "hex", "locking", "ho", "alg", "cloth", "address", "token", "search", "reading", "message", "sh", "filter", "other", "version", " Hash", "replace", "build", "bh", "ah", "username", "trust", "dig", "mask", "tr", "index", "cache", "ha", "rh", "shadow", "mass", "height", "checking", "ping", "response", "h", "where", "copy", "hing", "html", "user", "total", "ash", "string", "crypt", "shift", "check", "alert", "hed", "value", "ashing", "block", "key", "proof", "method", "str", "log", "test", "Hash", "print", "result", "sha", " hashing", "put", "zero", "title", "handle", "uh", "array", "her", "number", "hello", "tag", "sum", "report", "here", "class"], "md": ["pm", "bd", "MD", "managed", "dh", "det", "cd", "dr", "sd", "sm", "js", "sam", "mand", "ind", "mt", "mod", "add", "dd", "hd", "dir", "del", "sha", "mc", "cmd", "ds", "df", "mk", "nd", "dm", "obj", "pd", "grad", "mp", "d", "der", "di", "ld", "man", "mn", "od", "m", "red", "ad", "mm", "ms", "and"]}}
{"id1": "22057083", "id2": "15757836", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"Connect": ["Start", "Check", " Close", "Sync", "Bind", "Conn", "Connector", "Interface", "Setup", "Auth", "Error", "Create", "Close", " Open", "connect", "New", "Log", " Init", "Ping", "Login", "Connection", " Connection", "Client", " Dial", "Dial", "Construct", "Open", "Init"], "client": ["batch", "component", "secure", "google", "session", "cp", "cmd", "cli", "browser", "mail", "list", "service", "row", "con", "pc", "null", "config", "node", "writer", "remote", "connect", "version", "product", "conn", "patch", "core", "server", "collection", "phone", "cell", "pattern", "cache", "open", "builder", "pb", "net", "local", "response", "context", "entry", "Client", "window", "plugin", "create", "buffer", "type", "lib", "user", "controller", "url", "wrapper", "channel", "api", "control", "force", "call", "handler", "resource", "table", "to", "key", "c", "cl", "reader", "close", "manager", "connection", "log", "cgi", "ssl", "util", "obj", "chain", "name", "command", "handle", "co", "http", "man", "module", "proxy", "one", "ch", "bo", "store", "port", "form"], "reply": ["close", "type", "echo", "write", "status", "state", "translation", "bill", "Reply", "user", "answer", "comment", "py", "mi", "print", "prefix", "next", "result", "flag", "vote", "line", "no", "success", "job", "address", "rc", "ply", "command", "notice", "resp", "match", "nb", "query", "response", "link", "message", "ret", "report", "entry", "code", "shell", "error", "repl"]}}
{"id1": "5760649", "id2": "13666876", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"createFile": ["uploadStream", "uploadFile", "saveStream", "saveFiles", "createStream", " createfile", "createfile", " createStream", "uploadFiles", "savefile", "saveFile", "createFiles", " createFiles", "uploadfile"], "src": ["sb", "ctr", "sr", "ipl", "sc", "stream", "rx", "str", "sit", "dest", "loc", "sq", "uri", "sys", "is", "SOURCE", "input", "pour", "res", "obj", "rc", "start", "url", "SourceFile", "comp", "sec", "cur", "rs", "fp", "abs", "rect", "from", "st", "fc", "config", "resource", "inst", "ser", "source", "txt"], "filename": ["println", "jpg", "location", "v", "nl", "xxx", "fil", "bf", "FILE", "file", "username", "prefix", "ln", "nil", "string", "png", "path", "family", "FN", "title", "name", "stem", "n", "SourceFile", "fp", "kl", "Filename", "output", "subject", "nm", "ename", "fn", "ren", "txt"], "fis": ["fIS", "bfos", "Fios", "fiss", " fais", "ffos", "FIS", "afios", " fIS", "sfis", "fios", "afis", " fiss", "afais", "sfais", "fisi", "bfios", " fisi", "Fos", "fais", " fios", "ffis", "Fisi", "sfiss", "Fiss", "bfis", "ffIS", "Fis", "sfios", "bfiss", "ffisi", "afiss"], "fos": ["tis", "foes", "vOS", "Foss", "wios", "vor", "woses", "fios", " foses", "bis", "boes", " fOS", "woss", " foss", "voses", "foss", "bos", "Foes", "vos", "tios", "Fos", "wOS", "foses", "boss", "wis", "fOS", "flos", "floss", "flios", "toss", "wor", "tos", "Fis", "flis", " foes", "wos"]}}
{"id1": "9210168", "id2": "18989018", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "label": 0, "substitutes": {"run": ["exit", "close", "default", "invoke", "begin", "test", "func", "result", "Run", "render", "normal", "running", "work", "thread", "name", "play", "exec", "start", "get", "pass", "execute", "all", "launch", "runs", "apply", "block", "process", "display", "true", "show", "call", "function", "def", "class"], "url": ["io", "rl", "nl", "mount", "str", "file", "lr", "l", "b", "gl", "web", "uri", "https", "ssl", "browser", "impl", "path", "ls", "res", "ref", "sl", "bel", "ur", "gif", "f", "pl", "http", "hl", "rel", "abs", "ret", "URL", "fl", "char", "resource", "Url", "rect"], "fis": ["fIS", "fiIS", "dfis", " fi", "dfiss", "fiss", "sfien", "fbiss", "sfis", "fbibus", "fibus", "lfIs", "fiIs", "fiim", "fbi", " fiss", "ifien", "lfim", "fim", "fiis", " fIs", "ifIS", " fibus", "dfibus", "fbis", "fien", "fiien", "sfIS", "fIs", "ifis", "fi", "lfis", "dfi", "ifIs", " fim", "sfIs"], "r": ["fr", "R", "vr", "reader", "gr", "sr", "rd", "rf", "dr", "rl", "re", "mr", "nr", "rx", "pr", "l", "b", "ro", "tr", "hr", "ri", "res", "rb", "rar", "rc", "ra", "er", "ran", "ur", "p", "f", "rt", "rs", "rel", "ar", "rec", "rr", "cr", "rn", "kr", "rect"], "br": ["fr", "bd", "vr", "bb", "Br", "sr", "bm", "bh", "dr", "bs", "mr", "rx", "nr", "str", "lr", "pr", "b", "bt", "ber", "ab", "browser", "tr", "adr", "hr", "cb", "err", "bl", "rb", "n", "buf", "p", "bro", "be", "nb", "bp", "rel", "cr", "bridge", "BR", "kr"], "line": ["le", "li", "zone", "lin", "lane", "inline", "point", "nl", "str", "base", "user", "comment", " inline", "log", "file", "LINE", "liner", "print", "l", "ln", "e", "cell", "Line", "eline", "string", "stroke", " error", "no", " frame", "check", "entity", "email", "ine", "name", "n", " chunk", " block", " row", "frame", "number", "row", "record", "link", "lines", "block", "sequence", " entry", "bo", "char", "sample", "valid", "entry", "code", "model", "word", "page", " status"], "sb": ["lb", "sync", "zb", "lp", "bd", "sg", "bg", "gs", "stab", "bh", "sn", "bs", "nl", "sbm", "bf", "sam", "rob", "bis", "sv", "sq", "b", "bt", "ib", "sa", "ssl", "mb", "eb", "sth", "cb", "orb", "SB", "rb", "soc", "si", "gb", "erb", "nb", "pb", "bj", "kb", "xb", "db", "shell", "sf", "sp", "bsp", "bn", "ub", "bb"], "text": ["content", "t", "pdf", "read", "buffer", "translation", "lt", "displayText", "str", "data", "html", "ext", "comment", "print", "b", "TEXT", "body", "source", "out", "x", "path", "end", "title", "term", "name", "format", "n", "note", "layout", "value", "message", "output", "st", "config", "code", "msg", "cont", "word", "Text", "txt"]}}
{"id1": "20991673", "id2": "14053882", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"generateTopicId": ["generateNodeID", "generatesTopicId", "generateTopicID", "generateTransactionDir", "generateTransactionId", "generateTopicName", "generatesNodeName", "generateThreadID", "generateTopicDir", "generateTransactionName", "generateThreadName", "generatesTopicDir", "generateThreadId", "generateNodeId", "generatesTopicID", "generateThreadDir", "generateTransactionID", "generatesNodeId", "generateNodeName", "generatesTopicName", "generateNodeDir", "generatesNodeDir", "generatesNodeID"], "topicName": ["topicKey", "threadKey", " topicInfo", " topicNames", "TopicFamily", " topicData", "opicName", "TopicInfo", "topicname", "threadName", "opicInfo", "opicData", "topicInfo", "TopicName", "TopicNames", "opicFamily", "threadname", "TopicKey", "topicFamily", "topicNames", "messagename", " topicname", "messageName", "threadData", "TopicData", " topicKey", "messageInfo", " topicFamily", "Topicname", "topicData", "messageNames"], "md": [" Md", "bd", "MD", "dh", "pdf", "det", "cd", "med", "dr", "ng", "sd", "sm", "bf", "mand", "mt", "ind", "mod", "ME", "dd", "hd", "mc", "sha", "dig", "cmd", "hash", "mk", " mc", "mb", "dm", "df", "alg", "mac", "de", "pd", "metadata", "grad", "me", "mp", "M", "d", "ma", "der", "di", "ld", "rm", "mn", "od", "m", "msg", "red", "mm", "mg", "ms"], "digest": ["Digressed", "candested", "digests", "decest", " digEST", "Digests", "hashest", "signested", "signidate", "designgest", "designested", "designest", "candest", " digested", "hashgest", "hashEST", "decidate", "Digidate", "digEST", "digested", "DigEST", "candEST", "digidate", "Diggest", "designEST", "digressed", "candressed", "Digest", "decested", "hashested", " digressed", "decests", "Digested", "signest", "signests", "diggest"], "newId": ["NewMid", "nextId", "nodeId", "newById", "newMid", "NewById", "newid", "newsid", "NewId", "nextid", " newMid", "nextById", "nodeid", "Newid", " newById", "nodeById", "newsMid", "nextMid", "newsById", "nodeMid", "newsId", " newid"]}}
{"id1": "22552318", "id2": "23620712", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadDDL": ["LoadCDDL", "loadCDL", "loadDDl", "loadPDDL", "loadDSL", "loadDDML", "loadDSl", "loadDSDL", "loadCDl", "LoadDDDL", "loadPDL", "LoadCDL", "loadDDDL", "loadPDl", "LoadDDL", "LoadCDl", "LoadCDML", "LoadDDML", "loadPDML", "loadCDML", "LoadDDl", "loadDSML", "loadCDDL"], "stmt": [" stmm", " stmp", "STmt", "STMT", "stmp", "stpt", "stst", "Stmt", "astmt", "stmm", " stMT", "asttm", "frct", " superstm", "StMT", "stm", " stst", "Stmm", "utst", "strmt", "astMT", "Sttm", "frpt", " superstct", "strmm", " sttm", " superstmt", "utmt", "stMT", "STmm", "sttm", " stct", " superstpt", "strm", " stm", "utm", "frmt", "STm", "Stm", "STmp", " stpt", "Stst", "strmp", "utMT", "stct", "astm", "frm"], "qry": [" qRY", "quary", " qri", "qrys", " qrys", "Qry", "qurys", "sqary", "quri", "Qrys", "QRY", "sqrys", "qury", "qary", "sqri", "Qri", "sqry", "qRY", "qri", " qary", "sqRY"], "q": ["qs", "c", "t", "v", "ry", "k", "u", "comment", "sq", "Q", "qu", "e", "qv", "r", "ql", "iq", "n", "qt", "p", "qi", "f", "d", "pkg", "o", "query", "qa", "w", "dq", "j", "z", "m", "g", "h", "i", "s", "qq"]}}
{"id1": "3024987", "id2": "7425022", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStreamWithDecoder"], "in": ["bin", "read", "din", "copy", "ac", "sin", "data", "inc", "isin", "rin", "ind", "mi", "inner", "l", "inf", "inside", "iter", "mc", "r", "as", "is", "input", " IN", "up", "In", "n", "Input", "p", "gin", "init", "info", "ini", "IN", "con", "local", "it", "from", "ins", "inn", "m", "cin", "act", "i", "mm", "cont", "source"], "reader": ["io", "read", "buffer", "dr", "rl", "oe", "mr", "rx", "data", "rot", "file", "inner", "phrase", "loader", "Reader", "ro", "iter", "parser", "r", "ner", "driver", "input", "Larry", "ocker", "rar", "er", "req", "rise", "per", "row", "query", "reading", "rr", "handler", "red", "writer", "iterator"], "baout": ["yaout", "caos", "caout", "BAin", "yaot", "boos", "baot", "yain", "boout", "BAot", "beanout", " baot", " bain", "caOut", "beanouts", "oaout", "oain", "baouts", "yares", "haOut", "hain", "bain", "haout", "cain", "beanOut", "beanin", "boin", "BAout", "oaos", "boOut", "haouts", "caouts", "bares", "baOut", "oaOut", "baos", "BAres", " bares"], "out": ["t", "io", "stable", " output", "copy", " outs", "ne", " bout", "os", "auto", "OU", "batch", "b", "update", "gt", "sys", "cmd", "oss", "client", " OUT", "res", "conv", "n", "ao", "all", "o", "net", "con", "cn", "outs", " Out", "bo", "Out", "output", "ex", "null", "to", "cos", "ou", "OUT", "outer", " os"], "bytes": ["videos", "gs", "terms", "ings", "strings", "ies", "results", "faces", "pdf", "binary", "classes", "es", "bs", "data", "parts", "des", "services", "raw", "frames", "gets", "ones", "bits", "ites", "pages", "versions", "letters", "objects", "reports", "comments", "unks", "bps", "its", "Bytes", "words", "names", "cells", "les", "outs", "lines", "seconds", "blocks", "resources", "users", "values", "files", "latest", "groups", "reads", "pieces", "issues", "vals", "ips", "tes", "units"]}}
{"id1": "3375722", "id2": "8953394", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 1, "substitutes": {"importarSetor": [" importatSelector", " importarSelectero", " importarSelectr", " importarStero", " importarSelectors", " importatSelectors", " importatSetr", " importarDatr", " importarSetors", " importarStors", " importatSetors", " importatSelectr", " importarDatero", " importarSetero", " importarDator", " importarSetr", " importarStr", " importarSelector", " importatSetor", " importarStor", " importarDators", " importatSelectero", " importatSetero"], "pArquivoXLS": ["pArquivoOXML", "pArquarioXML", "pArquarioEXLS", "pArquivoDXls", "pArquarioXls", "pArquivoXXls", "pArquiveXCS", "pArquivoXXML", "pArquivoEXCS", "pArquivoOXLS", "pArquiveXls", "pArquiveXML", "pArquivoXXCS", "pArquarioXCS", "pArquarioEXCS", "pArquarioEXML", "pArquivoXls", "pArquiveEXls", "pArquivoEXLS", "pArquivoTXML", "pArquivoEXML", "pArquiveEXLS", "pArquarioXLS", "pArquivoXCS", "pArquivoEXls", "pArquarioEXls", "pArquivoOXls", "pArquivoOXCS", "pArquiveEXCS", "pArquivoDXML", "pArquivoTXls", "pArquivoXXLS", "pArquiveEXML", "pArquivoTXCS", "pArquivoDXCS", "pArquivoDXLS", "pArquivoXML", "pArquiveXLS", "pArquivoTXLS"], "pCabecalhoSetor": ["pCabecalhoStr", "pCabecalhaSetr", "pCabecalhaSetter", "pCabecalhoSetter", "pCabecalhoStar", "pCabecalhaSetor", "pCabecalhoSetr", "pCabecalhoStter", "pCabecalhoSetar", "pCabecalhoStor", "pCabecalhaSetar"], "pAndamento": ["pAndementos", "pAndimento", "pAndamentos", "pandmento", "pAndimentO", "pandmentos", "pAndemento", "pandamente", "pAndimente", "pAndmentos", "pandamentos", "pandmentO", "pandmente", "pAndamente", "pAndementO", "pAndmente", "pAndamentO", "pAndemente", "pAndimentos", "pAndmentO", "pandamento", "pandamentO", "pAndmento"], "iLinha": ["iLuzo", "aiLin\u00e7a", "iEnva", "iEnha", "iLuva", "aiPlanva", "iPlanva", "iLin\u00e7a", "iEnzo", "iLu\u00e7a", "iLinzo", "iEn\u00e7a", "iPlanzo", "aiLinha", "iPlanha", "iLuha", "iPlan\u00e7a", "aiPlan\u00e7a", "iLinva", "aiLinva", "aiPlanzo", "aiLinzo", "aiPlanha"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestination", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDecinos", "stmtLimpezaInicialDestin", "stmtLimpezaInicialDecino", "stmtLimpezaInicialDestinos", "stmtLimpezaInicioEstination", "stmtLimpezaInicialDestINO", "stmtLimpezaInitalEstinos", "stmtLimpezaIniciodestino", "stmtLimpezaInitalDestinos", "stmtLimpezaInicialdestin", "stmtLimpezaInicialDecione", "stmtLimpezaInitalDestino", "stmtLimpezaInicialEstione", "stmtLimpezaInicialDestione", "stmtLimpezaInicioDestINO", "stmtLimpezaInicioEstin", "stmtLimpezaInitalEstione", "stmtLimpezaInicialdestino", "stmtLimpezaIniciodestinos", "stmtLimpezaInicioEstino", "stmtLimpezaIniciodestination", "stmtLimpezaInicioDestin", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialdestinos", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialDecINO", "stmtLimpezaInicioDestination", "stmtLimpezaInicialEstINO", "stmtLimpezaInitalDestione", "stmtLimpezaInicioEstINO", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialEstination", "stmtLimpezaInitalEstINO", "stmtLimpezaInitalEstino", "stmtLimpezaInicialEstino", "stmtLimpezaInicioDestino", "stmtLimpezaInicialEstin", "stmtLimpezaInicioDestinos", "stmtLimpezaInitalDestINO"], "stmtDestino": ["stmtStination", "stmtdestoin", "stmtOrigination", "stmtdestino", "stmpDestino", "stmtDecino", "stmpOrigino", "stmtdestano", "stmpOriginos", "stmtOrigined", "stmpDestoin", "stmtDescined", "stmpDestinos", "stmtOrigin", "stmpDestination", "stmtStino", "stmDestination", "stmtDestined", "stmtDestinos", "stmtDescin", "stmtDescination", "stmtDestination", "stmtDecination", "stmtDesination", "stmpOrigination", "stmDestined", "stmdestino", "stmtdestin", "stmDestano", "stmDestin", "stmOrigin", "stmOrigino", "stmtDestano", "stmtStinos", "stmtDecin", "stmDestino", "stmdestano", "stmtDesin", "stmdestination", "stmtdestinos", "stmtDestoin", "stmtStoin", "stmOrigination", "stmtDesano", "stmtOriginos", "stmtOrigino", "stmpOrigoin", "stmOrigined", "stmtDestin", "stmtDecano", "stmtOrigoin", "stmtDesino", "stmtdestination", "stmdestin", "stmtDescino"], "arquivo": ["araquario", " araquiva", "arquive", "arqivo", " arquive", "arquario", "rquarius", "arquarius", "rquivo", "arquiva", "arqario", " arqivo", " arQuiva", " araquario", " arQuario", " arquario", "raquivo", "raquario", " arqive", "raquiva", "arquerivo", " arquiva", " araquive", "araquivo", "arqive", " arqiva", "raquarius", " arQuivo", " arqario", "arqiva", " arQuive", "rquiva", " araquivo", "rquario", "araquiva", "araquarius", "arquerario", "arqueriva", "arquerarius", "arqarius"], "plan1": [" plannerOne", " planner0", " planner2", "Plan01", "planOne", "panel01", "panel0", "PlanOne", "panel1", "plan01", " plan0", " plan01", " planOne", " planner1", "panel2", "Plan2", "Plan0", "Plan1", " plan2", "plan2", "plan0"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTRANS_", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTERos__", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRos__", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROs2", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTRAS__", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTROS2", "QUANTIDADE_DE_REGISTROs__", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS__"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTRosON", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTERosON", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTRATIONSON", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRIES2", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTROSON", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTEROSON", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTROS2", "QUANTIDADE_DE_REGISTRATESON", "QUANTIDADE_DE_REGISTRAS_"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTRAS_"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstifated", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstIMada", "quantidadeDeRegistrosEstimated", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstIMados", "quantidadeDeRegistrosEstifados", "quantidadeDeRegistrosEstIMadas", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstipated", "quantidadeDeRegistrosEstIMated", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstipadas"], "vSetor": ["valuesSETor", "vSETor", "vEndar", "valuesSetero", "valuesSETero", "vSETar", "vEndor", "valuesSetor", "valuesSetora", "valuesSETora", "vSelector", "vEndero", "vSETora", "vSetar", "vSelectar", "vSETero", "vEndora", "vSetora", "vSelectero", "vSetero", "valuesSETar", "vSelectora", "valuesSetar"], "vSubsetor": ["vsubsetation", "vsubscripto", "vSubscriptation", "vSubmento", "vSubsetOR", "vSubscriptOR", "vsubscriptOR", "vSubmentOR", "vSubeto", "vSubseto", "vSubetOR", "vsubscriptation", "vSubmentation", "vSubscripto", "vSubsetation", "vSubscriptor", "vSubetor", "vsubseto", "vSubetation", "vsubsetOR", "vsubscriptor", "vsubsetor", "vSubmentor"], "vSegmento": ["vSegmentO", "vSegmentao", "vSegementO", "vIncreementO", "vIncreemento", "vIncrementano", "vSegementano", "vSegMENTao", "vIncrementao", "vSegemento", "vSegMENTO", "vSegementao", "vSegmentano", "vIncreementano", "vIncremento", "vSegMENTo", "vIncreementao", "vSeggmentao", "vSeggmento", "vSeggmentano", "vSegMENTano", "vIncrementO", "vSeggmentO"], "registroAtual": ["RegistroAtual", "RegistrosAtomic", "RegistrosAtUAL", "Registroatuel", "RegistrosAtuel", "RegistroAtuel", "RegistrosActUAL", "RegistrosAtual", "Registroatual", "RegistroATUAL", "RegistroActUAL", "RegistrosActomic", "Registroatomic", "RegistroATomic", "RegistroActual", "RegistroActomic", "RegistroATuel", "RegistrosActual", "RegistroatUAL", "RegistrosActuel", "RegistroAtUAL", "RegistroAtomic", "RegistroActuel", "RegistroATual"], "vPapeisPorSegmento": ["vPapeisPorSegmentao", "vPapeisPorGamentao", "vPapeisPorGamente", "vPapeisPorSegamentO", "vPapeisPorSegamento", "vPapeisPorSegmentO", "vPapeisPorGamento", "vPapeisPorSegmentedo", "vPapeisPorSegmente", "vPapeisPorGmentao", "vPapeisPorGmento", "vPapeisPorSegmentedao", "vPapeisPorGamentO", "vPapeisPorSegementO", "vPapeisPorGmente", "vPapeisPorSegemento", "vPapeisPorGmentO", "vPapeisPorSegementao", "vPapeisPorSegamente", "vPapeisPorSegemente", "vPapeisPorSegmentedO", "vPapeisPorSegmentede", "vPapeisPorSegamentao"], "sql": ["dl", "SQL", "details", "cfg", "spr", "inv", "sd", "nl", "str", "js", "html", "software", "comment", "select", "csv", "log", "orm", "sv", "eps", "sq", "pr", "series", "prefix", "expression", "scl", "pg", "statement", "session", "string", "sys", "cmd", "security", "install", "ls", "ql", "pel", "mail", "email", "spec", "params", "url", "description", "json", "expr", "template", "query", "wal", "rel", "condition", "seed", "socket", "table", "xml", "s", "sp", "sol", "fn", "db"]}}
{"id1": "13783898", "id2": "7499186", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "3401153", "id2": "7296597", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHTML": ["getPDF", " getJS", "getJS", "processHTML", "printJS", " getURL", "processJS", "processURL", "printURL", " getPDF", "printHTML", "getURL", "printPDF", "processPDF"], "pageURL": ["baseURL", " pageURI", "cacheURI", "PageUR", "pageURI", "cacheURL", "PageURI", "PageUrl", "pageUR", " pageurl", "baseUrl", "cacheurl", "baseUR", "cacheUrl", "pageurl", " pageUR", "Pageurl", "baseURI", " pageUrl", "pageUrl", "PageURL"], "encoding": ["decuation", "enoding", "decaching", "enaching", "ecaching", "encoder", "uncoder", "uncoding", "encoded", "Encuation", "Encoding", "uncoded", "decoder", "Encoder", "Encaching", "ecoding", "encuation", "ecoded", "ecoder", "Encoded", "decoding", "uncaching", "encaching", "enoder", "enuation"], "dirPath": ["directoryPath", " dirFile", " dirDir", "viewPath", "directoryName", "dirDirectory", "viewName", "directoryDir", "pathFile", " dirName", "directoryPATH", "pkgPath", "folderFile", "dirFile", "pkgDir", " dirRoot", "dirDir", "viewPATH", "pkgName", "pathRoot", "pathDir", "dirPATH", "dirName", "folderPath", "pkgDirectory", "directoryDirectory", "viewDir", " dirDirectory", "dirRoot", "folderRoot", " dirPATH", "folderDir", "pathPath"], "pageHTML": ["pointJS", "pageWP", "viewMD", "pageJS", "agePUT", "ageMD", "viewJSON", " pageWP", "entryHTTP", "PageHTTP", "pageMD", " pageJS", "pageHTTP", "entryHTML", "displayJS", "displayHTML", "componentWP", "pageSQL", "searchHT", " pageSQL", "ageWP", "ageHT", "displayURL", " pagePUT", "pageJSON", "entryJS", " pageHTTP", "componentSQL", "viewHTML", "componentHTML", "displayHTTP", "ageJSON", " pageJSON", "PageHTML", "PageHT", "searchHTML", "viewPUT", " pageMD", "pageHT", "entryAPI", " pageAPI", "PageURL", "searchJS", "PageJS", "pointHTTP", "ageHTML", "ageSQL", "pageAPI", "componentHT", "pointHTML", "pagePUT", "searchURL", "pointAPI", " pageHT"], "connection": ["c", "generation", "io", "creation", "close", "conn", "operation", "user", "server", "relation", "document", "government", "statement", "web", "still", "uri", "session", "console", "established", "client", "creator", "browser", "reference", "library", "application", "open", "connected", "database", "engine", "communication", "command", "position", "processor", "description", "http", "network", "character", "channel", "directory", "number", "con", "Connection", "link", "response", "bo", "condition", "message", "entry", "internet", "socket", "to", "resource", "nc", "ion", "writer", "remote", "current", "connect"], "url": ["dl", "location", "ul", "conn", "rl", "nl", "str", "base", "atl", "l", "b", "gl", "loader", "google", "uri", "https", "web", "r", "client", "ssl", "path", "ls", "open", "sl", "address", "name", "bel", "ur", "p", "get", "f", "http", "api", "net", "ll", "link", "rel", "URL", "resource", "Url"], "br": ["fr", "bd", "vr", "Br", "sr", "dr", "bh", "shr", "bs", "mr", "str", "bf", "lr", "pr", "b", "bt", "bc", "wr", "ber", "r", "tr", "hr", "bl", "rb", "er", "buf", "bro", "be", "gb", "bp", "ch", "kr", "cr", "sp", "bridge", "BR", "bb"], "line": ["text", "le", "detail", "lin", "inline", "range", "point", "nl", "user", "comment", "log", "liner", "LINE", "print", "l", "phrase", "ln", "continue", "cell", "Line", "eline", "string", "source", "stroke", "section", "entity", "email", "chain", "ine", "online", "frame", "number", "row", "link", "sample", "block", "sequence", "field", "entry", "stay", "label", "style", "code", "word", "page", "quote"], "e": ["le", "ae", "fe", "te", "se", "es", "eeee", "re", "oe", "ite", "ne", "ce", "ode", "en", "ze", "je", "ent", "ge", "xe", "x", "ie", "eb", "ue", "err", "de", "ine", "er", "esome", "p", "f", "pe", "ve", "be", "he", "event", "ke", "E", "ee", "ex", "see", "error", "ed"], "file": ["tile", "et", "le", "io", "buffer", "data", "base", "FILE", "el", "File", "log", "print", "image", "web", "dir", "ile", "out", "path", "work", "mail", "email", "name", "handle", "f", " File", "directory", "fp", "lock", "link", "output", "report", "table", "resource", "page", "parent", "ca", "port", "task", "h", "db"], "bufferedWriter": ["bufferingReader", "bufferedClient", "builteredReader", "bufferedHelper", "builteredMember", "bufferedwriter", "bufferredWrite", "bufferedMember", "buffererMember", " bufferedwriter", "bufferredHelper", " bufferredHelper", "buffaredMember", "bufferingWrite", "bufferingMember", "builteringWriter", " bufferredwriter", "bufferedReader", "builteredWriter", " bufferedStreamer", "bufferingWriter", "bufferingClient", "builteringReader", "buffenedWriter", " bufferredWriter", "buffaredWriter", "bufferredStreamer", "bufferingHelper", "bufferredWriter", "buffererReader", "buffaredWrite", "buffenedHelper", " bufferredWrite", "bufferingwriter", "bufferingStreamer", "bufferredwriter", "buffaredwriter", " bufferredStreamer", "bufferedStreamer", " bufferedHelper", "buffaredStreamer", "builteringMember", "buffenedClient", "bufferredClient", " bufferedClient", " bufferredClient", "buffenedWrite", "bufferedWrite", "buffererWriter", "buffaredReader", " bufferedWrite"]}}
{"id1": "22410173", "id2": "1188100", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferFile", "copyfile", "cpfile", " cpStream", "transferFiles", " cpfile", "cpFile", "cpStream", "cpFiles", "copyStream", "transferfile", " cpFile", "transferStream", " cpFiles"], "source": ["copy", "se", "src", "scene", "scope", "base", "space", "ce", "file", "original", "so", "iter", "origin", "SOURCE", "input", "ource", "spec", "start", "Source", "me", "init", "search", "service", "target", "template", "query", "site", "local", "sample", "from", "subject", "style", "parent", "resource", "s", "sp", "seed"], "dest": ["est", "img", "tmp", "Dest", "trans", "tom", "src", "des", "usr", "nom", "rest", "test", "loc", "them", "temp", "dir", "del", "origin", "way", "de", "nw", "pot", "orig", "exp", "d", "search", "target", "dist", "crit", "it", "desc", "st", "lit", "that", "null", "deg", "master", "pub", "sp", "cont", "good", "home"], "in": ["bin", "can", "din", "read", "conn", "or", "sin", "re", "inc", "isin", "rin", "ind", "mi", "en", "inner", "l", "ln", "inf", "ain", "inside", "iter", "vin", "r", "an", "client", "is", "input", "pin", "ci", "al", " IN", "up", "In", "n", "on", "co", "gin", "init", "ma", "all", "win", "ini", "IN", "net", "con", "local", "it", " input", "ch", "internal", "from", "ar", "ins", "inn", "m", "cin", "doc", "ai", "i", "ca", "and"], "out": ["t", "io", "v", "dis", "can", "write", "off", "ac", "conn", "nl", "rem", "ne", "os", "user", "OU", "log", "en", "inner", "at", "ent", "na", "ot", "gt", "oss", "client", "cmd", "obj", "chain", "nt", "up", "conv", "n", "note", "un", "on", "co", "channel", "o", "net", "con", "cn", "it", "w", "outs", "output", "Out", "sum", "ex", "null", "ch", "ns", "again", "to", "cos", "ion", "not", "ou", "aos", "OUT", "outer"]}}
{"id1": "13757855", "id2": "12490144", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"process": ["parse", "save", "create", "replace", "write", "build", "run", "processing", "add", "render", "transform", "proc", "Process", "step", "format", "loop", "handle", "project", "processor", "execute", "load", "apply", "display", "call", "task", "filter"], "tpl": ["tpg", "otbl", "tplates", "ttopl", "ptbl", "tspr", "itplate", "teruple", "otld", "atpl", "tld", "terld", " turtle", "tembl", "stpg", "atuple", "tmplate", "terpl", "itbl", "ptpl", "turtle", "Tplates", "ttph", "tuple", "tpp", "timplug", "tspl", "Tld", "tbl", "itPL", "Tbl", "otplate", "tmplates", "tsbl", "tplug", "ptld", "typl", "atplate", "stplate", " tplates", "tmPL", "tmpp", "Tph", "tpr", "Tplate", "stbl", "stpl", "ttplug", "terplate", "topl", " tplate", "ttpl", "timopl", "timbl", " tuple", "itpl", "otpl", "tph", "tmpl", "stopl", "timplate", "tempr", "stplug", "TPL", "temPL", "timpg", "tsurtle", " tbl", " tPL", "tsPL", "ptplates", "tyPL", "ttbl", "ttPL", "Tpp", "timspl", "tyurtle", "ttpg", "templ", "Tpr", "Tpl", "timpl", "tplate", " tpp", " tld", "tPL", "tmbl", " tph", "stspl", "Tspl", "atld"], "model": ["content", "object", " Model", "ml", "product", "data", "tree", "base", "md", "html", "el", "file", "log", "document", "Document", "Model", " models", "project", "M", "models", "module", "record", "m", "node", "parent"], "packageName": [" packageFamily", "pkgNames", " packageNames", "pkgVersion", "viewClass", "groupFamily", "PackageName", " packageClass", "viewName", "pkgName", "groupName", "packagename", "PackageRoot", " packagename", "packageFamily", " packageVersion", "groupNames", "PackageClass", "pkgFamily", " packageRoot", "groupVersion", "Packagename", "packageRoot", "packageClass", "packageNames", "packageVersion", "viewRoot", "viewname"], "outFileName": [" outfilename", " outTableSize", "outStreamPath", " outFilename", " outfilePath", "outTableName", "outFPath", "outFilenameTime", "outfileChain", "outDirName", "infilePath", "outFName", "outStreamType", "outFilenameChain", "outStreamNames", " outFilenameSize", " outFilenamePath", "inFileTime", "infileType", "inFileType", "outDirPath", " outFileTime", "outFilenameName", "inFileName", "outfilePath", "outTableChain", " outFileSize", "outFNames", "outfileName", " outTablePath", " outFilenamename", "outFileChain", "outfilename", "outTablename", "outImagename", " outfileNames", "outFilenameNames", "outFilenameSize", "outTableType", "outTablePath", "outTableSize", " outFileType", "outTableTime", "outFilenamename", " outTableName", "outStreamName", "infileNames", "outFilenamePath", "outFilenameType", "outFileNames", " outFilenameChain", "outDirTime", "inFileNames", " outFilenameName", " outFilePath", "outfileType", " outTableTime", " outfileName", " outFileNames", "outFname", "inFilePath", " outFilenameType", "infileName", "outFileType", "outStreamTime", "outFilename", "outfileNames", "outFileTime", "outFileSize", "infileTime", "outDirSize", "outImageSize", "outImageName", "outfileTime", " outFileChain", "outImagePath", "outFilePath"], "xsltParam": ["xsltConf", "xsslParam", "xsslParameter", "xsqlConf", "xsltParameter", "xsmlParam", "xltParameter", "xmlParameter", "xsslConf", "xmlConf", "xsmlConf", "xsqlParameter", "xltConf", "xmlParam", "xsqlParam", "xsmlParameter", "xltParam"], "artifact": ["Artifact", " artifacts", "artificial", "anificate", "arifact", "anifacts", "ardifact", "ardificial", "ardificate", "artificate", "partifacts", "ardifacts", "arifacts", "anifact", "artifacts", " artificial", " artificate", "Artifacts", "anificial", "partifact"], "destinationPath": ["termininationJar", "identinationChain", "destensionPath", "destesticAt", "destigationNow", "destociationpath", "desticationPath", "DestinationDir", "termininationTarget", "descinationHost", "generinateJar", "destinatePath", "destinoHost", "destinateLocation", "destinationPart", "DestensionDir", "destensionHost", "estinoPath", "destinantPath", "destigationPath", "destinateHost", "chaininatedDriver", "destinoPath", "destinatedpath", "destinatedForm", "destigationForm", "destinerJar", "desturationJar", "destventionDisk", "destinerPart", "DestinationTemp", "destinateKey", "delinateForm", "destinoKey", "destinationPATH", "destitutionPATH", "destregationPath", "destinatedNow", "destationDir", "chaininationHome", "chaininationPath", "destensionPoint", "estionPoint", "destociationPath", "destinationChain", "destinationForm", "destositoryHost", "identinateKey", "destinateTime", "descositoryParent", "destationLocation", "destinatedHome", "estionPath", "DestensionPoint", "destinatorParent", "destinatedChain", "identinationKey", "destacementPath", "estinationPoint", "destionPATH", "destinationDisk", "chaininatedHome", "destinerPath", "delinationLog", " destociationpath", "destranceForm", "origininatedNow", "identinateChain", "origininationForm", "origininationPath", "desturationpath", "destinationLocation", "destATIONPort", "destATIONParent", "destinatorChain", "destinationDriver", "destinateUrl", "destitutionPath", "origininatedForm", "destociationHome", "DestinationPath", "destATIONHost", "destinoTime", "destinationHost", " destinationpath", "destinationInfo", "destinationSystem", "destinationHome", "termininationPath", " destinationTarget", "destinationName", "destinatorKey", "destinoName", "destitutionpath", "DestinationPod", "destacementName", "estionPATH", "delinationForm", "destinantDir", "destociationLog", "estinationpath", "delinatePath", "destventionDriver", "estinationTime", "chaininatedPath", "destinatorPort", "destinatedDisk", "generinateAt", "destinatedInfo", "generinationSystem", " destociationTarget", "estationPart", "descinationPort", "destinatedPath", "destinatePoints", "destositoryPort", "destinatorPath", "destesticJar", "destacementTime", "descositoryPath", "destificationPath", "delinatePoints", "estinationDir", "destinatorHost", "destinateForm", "destationHost", "estationDir", "identinateInfo", "estinationName", "destinerSystem", "estinationPATH", "termininerpath", "destinateChain", "destinationPort", "desticationDir", "origininatedChain", "destinationLog", "destinateAt", "destinateName", "delinationPath", "destesticSystem", "destinatedTarget", "destinantTemp", "destinoDir", "destigationChain", "desturationTarget", "estinoTime", "destensionPod", "estinationPart", "destinateLog", "DestificationUrl", "destionPath", "destificationLocation", "destinoPoint", "destationPath", "destinatepath", "destificationUrl", "desturationPath", "destinationPod", "destranceLog", "DestensionHost", "DestinationLocation", "destregationpath", "destinerpath", "destrancePath", "destinationJar", "estinationPath", "destrancePoints", "DestinationUrl", "estationPath", "generinationJar", "destinatedDriver", "generinationAt", "destensionTemp", "destventionPath", "descositoryHost", "destinatedKey", "destinationTarget", "destinationUrl", "destinationNow", "destesticPath", "identinationInfo", "destinatorPATH", "origininationNow", "destinateTarget", "DestensionPath", "identinationPath", "destinateDir", "delinationPoints", "destociationPoints", "estinoName", "destionPoint", "destinationTime", "destensionDir", "DestensionPod", "destinatePart", "termininerTarget", "desticationPod", "destionpath", "destregationDisk", "chaininationDisk", "termininationpath", "destinationPoint", "destociationDriver", "destregationTarget", "DestinationHost", "origininatedPath", "destinatorInfo", "estinationKey", "destinationTemp", "destinationPoints", "destociationForm", "destationUrl", "destinatorPoint", "destinatorpath", "destventionHome", "chaininatedDisk", "chaininationDriver", "descositoryPort", "DestensionTemp", "desticationTemp", "termininerPath", "descinationPath", "DestificationPath", "estionpath", "destationPart", "estinationHost", "destinationAt", "destociationDir", "destinerDir", "destinateJar", "termininerJar", "origininationChain", "destinationDir", " destinationDisk", "destinateNow", "destositoryParent", "descinationParent", "destinantPod", "identinatePath", "generinatePath", "destinationpath", "destociationHost", "destificationDir", "destinationParent", " destociationPath", "destinerAt", "delinateLog", "destociationPoint", "destinerHost", "destociationTarget", " destociationDisk", "destinateInfo", "DestinationPoint", "destitutionPoint", "destATIONPath", "DestificationLocation", "generinateSystem", "DestificationDir", "destinerTarget", "destositoryPath", "estinoKey", "destacementKey", "generinationPath", "destinationKey", "destociationDisk", "destinateSystem", "estationHost"], "in": ["c", "t", "io", "reader", "bin", "din", "id", "file", "l", "inner", "r", "input", " IN", "In", "n", "f", "d", "info", "o", "IN", "w", "ins", "m", "doc", "i"], "out": ["c", "t", "println", "io", "ger", "gr", "dis", "v", "write", "can", "cfg", "conn", "inv", "or", "oe", "nr", "os", "u", "log", "raw", "file", "go", "print", "inner", "l", "b", "ln", "e", "sys", "cmd", "client", "cache", "res", "err", "obj", "screen", "nt", "up", "n", "co", "p", "f", "all", "list", "o", "conf", "net", "gen", "con", "cn", "w", "outs", "it", "Out", "output", "ch", "report", "null", "ex", "ins", "to", "msg", "writer", "s", "ou", "aos", "OUT", "outer"], "root": ["parents", " roots", "println", "ok", "create", "_", "se", "data", "tree", "scope", "id", "dump", "roots", "dir", "r", "child", "impl", "Root", "de", "chain", "name", "Template", "New", "start", "p", "json", "graph", "group", "context", "initial", "m", "config", "node", "parent", "table", "def"]}}
{"id1": "8328527", "id2": "11082670", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "label": 0, "substitutes": {"insertJobLog": [" insertJHistory", "insertJLog", " insertJlog", "insertLogHistory", "insertJlog", " insertJLog", " insertJobConfig", "insertJHistory", "insertJConfig", "insertJobConfig", "insertCheckLog", "insertLogConfig", "insertJobHistory", " insertJoblog", "insertLogLog", "insertChecklog", "insertJoblog", " insertJConfig", "insertCheckHistory", "insertLoglog", " insertJobHistory", "insertCheckConfig"], "userId": ["userDef", "authorID", " userIn", "UserPart", "authorId", "usersName", "UserName", "usernameDef", "userPart", "usernameById", "UserId", "userDir", "checkID", "usaDef", "usernameDir", "usersId", " userName", "UserIn", "userIn", "userName", "usaById", "checkName", "UserById", "authorPart", "checkPart", "authorName", "UserID", "usersById", "usersIn", " userDir", " userDef", "userById", "userID", "usaId", "usernameId", "usaDir", " userById"], "checkId": ["ckID", "testID", "workIdent", "checkid", "objId", "testId", " checkid", "cleanIdent", "checkID", "workid", "workID", "checkInt", "workId", "workById", "checkById", "ckId", " checkInt", "cleanInt", "CheckInfo", " checkInfo", "checkInfo", " checkIdent", "CheckID", "Checkid", "testById", "objInfo", "CheckById", "workInt", "testInfo", "cleanid", "objID", "ckById", "objById", "checkIdent", "cleanId", "ckInfo", "workInfo", " checkID", "CheckId", " checkById"], "checkType": ["defType", "ckID", "testID", "testKind", "CheckType", "checkedTYPE", "ckType", "testTYPE", "okID", "checkID", "ckTYPE", "okId", "defInfo", "checkKey", "checkKind", " checkInfo", "checkedID", "ckKind", "okType", "defTYPE", "CheckID", "checkInfo", "checkedType", "ckTypes", "defTypes", "checkTYPE", " checkTYPE", "CheckKey", "checkTypes", " checkTypes", "testType", "checkedKind", " checkKey", "ckInfo", "okKey", " checkID", "CheckId"], "objType": [" objTYPE", "objVersion", " objName", "objTheme", "cbVersion", "cbName", "tmpTYPE", "rtTypes", "objTYPE", "tmpType", "checkStyle", " objVersion", "cbTYPE", "cbType", "rtStyle", "rtType", "tmpTheme", "ObjName", "cmdTYPE", " objTypes", "ObjType", "objName", "checkTYPE", "cmdTy", "ObjTYPE", "checkTypes", "rtTYPE", "objStyle", "objTy", "bjTy", "tmpTy", "ObjVersion", "bjTYPE", "bjTheme", " objStyle", "objTypes", "bjType", "cmdTheme", "cmdType"], "dbo": ["dtbo", "rdbc", "dobf", "pbo", " dBo", "dBo", "rdpo", "dbf", "dobo", "pBO", "Dbc", " dbc", " dbf", "ppo", "dbc", "dtBo", " dpo", " dBO", "DBO", " dbu", "dtbf", "DBo", "dBO", "doBo", "Dbu", "Dpo", "dpo", "dbu", "rdbu", "rdBO", "dtBO", "doBO", "pBo", "rdBo", "Dbo", "rdbo"], "connection": ["c", "t", "generation", "db", "usage", "close", "manager", "instance", "conn", "cone", "po", "operation", "server", "pen", "pool", "collection", "relation", "document", "computer", "government", "statement", "session", "creator", "client", "pointer", "reference", "library", "application", "connected", "engine", "database", "open", "communication", "command", "position", "network", "directory", "net", "query", "con", "Connection", "link", "response", "bo", "context", "condition", "settings", "output", "subject", "information", "socket", "config", "function", "resource", "ion", "writer", "associated", "handler", "management", "current", "connect", "table"], "preStm": ["preSTarm", " preSTl", " preStn", "preTrm", "presStpm", " preSTmt", "preWr", "prePutr", "prePutM", " preTrm", "preStr", "preSTn", "prestem", "preStpm", "priSTcm", "PreStdm", "priSTr", "PreStmi", " prestmt", "prestarm", "preEstem", "PreStrmt", "preStn", "preStl", "preShmt", " preStmn", "preStmt", "preSTmt", "preStem", "preStM", "prestmt", "preEstpm", "prePuttm", "preSTr", "prefixStm", " preStem", "prePostm", " preSTr", "preStrM", "preStam", "prefixSTmt", " prePutam", "prefixSTm", "Prestm", "presSTem", "preStmn", "prestmi", "preShtm", " preTrem", "preFormmt", "prePostam", " prePutmn", "preSTam", "prePutl", "preSTem", "preFormn", "prePutmi", "PreStrdm", "preRestr", "prestn", "prefixSTem", "prefixStem", "preStrmt", " prePutem", "preStrem", "prePutm", "presSTpm", "prestsm", "PreSttm", "preSttm", "preStrm", "presttm", "presStsm", "preWm", " preTrM", "priStr", " prestm", "preSTcm", "PreStmt", " prePutmt", "presStem", "PreStrn", "preEstsm", " prestn", "PreStn", "preFormm", "Presttm", "preShmi", " preStr", " preTrmt", "prePostmn", "PreStrm", "preShm", "preTrem", "preSTm", "preStcm", "preStarm", "preRestm", "preSTsm", "preEstm", "Prestmt", "presSTsm", " prePutm", "preStmi", "priStcm", "preStsm", "prefixSTarm", "preStrcm", "prePutarm", "prefixStmt", "priStm", "priSTem", " prestr", "preStrdm", "prestr", "prePostem", " preSTm", "priSTm", "preWn", "preTrM", "preWmt", "preRestmt", "presStm", " prePutr", "prePutmn", "priStem", "preStrn", "prestm", "presSTm", " preStam", "prePutam", " prePutl", "preStrr", "preSTmn", " preStM", "preStdm", "preRestl", "prefixStarm", " preStl", "prePutem", "preTrmt", "preFormdm", " preStmt", "preWdm", "Prestmi", "prestl", "preStrl", "preSTl", "preSTpm", "prestpm", "PreStm", "prePutmt"], "sql": ["sb", "dl", "SQL", "conn", "sn", "sd", "spr", "nl", "js", "sk", "csv", "log", "sv", "eps", "sq", "scl", "su", "string", "q", "sys", "cmd", "ssl", "ls", "ql", "setup", "spec", "script", "pkg", "description", "json", "template", "query", "ll", "seed", "xml", "s", "sp", "sol", "fn", "db", "quote", "san"], "cleanSql": ["cleanPq", "removeSQL", "cleanDSq", "emptyStq", "cleanAsmt", "cleanAsql", "cleanInsq", "cleanSml", "removePq", "cleanDSuff", "cleanSuff", "emptySml", "removeSuff", "emptySq", "cleanStql", "cleanInsql", "cleanDSQL", "cleanPQL", "cleanInsQL", "cleanSmt", "emptyStql", "cleanSyml", "cleanInsuff", "cleanSq", "cleanSymt", "removePuff", "emptyStml", "cleanDSql", "emptyStmt", "cleanSyql", "emptySql", "cleanPuff", "cleanPql", "cleanStml", "cleanStmt", "cleanAsml", "removeSq", "emptySmt", "removePql", "cleanSyq", "cleanSQL", "removePQL", "removeSql", "cleanAsq", "cleanStq"], "dCount": ["outCount", "dLimit", "udLimit", "udRes", "udMax", "outLimit", "dlRes", "dlMax", "dMax", "outRes", "udCount", "dRes", "dlCount", "outMax", "dlLimit"], "sHaveIns": ["SHadins", "sHadins", "shaveins", "sSeeIns", "SHaveEls", "sHasIns", "SHaveIns", "SHadEls", "sHavingins", "sHadEls", "sHaveCons", "sHasINS", "sHavingEx", "sSeeins", "sHadIns", "sHadEx", "sHaveINS", "sSeeINS", " shaveIns", "SHadCons", "sHaveins", "shaveINS", "SHaveCons", "sHasEls", "SHaveins", "shaveIns", "sHadCons", " sHaveins", "SHadIns", "sSaveIns", "sHavingIns", " shaveins", "sHasCons", "sHasins", "sSaveEls", "sHaveEls", "sSaveins", " sHaveINS", " shaveINS", "sHasEx", "sHaveEx", "sSaveCons"], "j": ["jj", "ja", "y", "J", "v", "_", "aj", "off", "k", "js", "ind", "bot", "batch", "jc", "left", "b", "oj", "jp", "q", "out", "x", "jump", "index", "jack", "br", "att", "job", "ij", "ji", "n", "exp", "jit", "p", "f", "Ja", "ix", "json", "Journal", "jen", "o", "uj", "ju", "bj", "it", "jl", "Job", "jo", "z", "m", "g", "msg", "i", "dj", "key", "by", "kj"]}}
{"id1": "400275", "id2": "12078471", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"url": ["dl", "cl", "location", "default", "rl", "nl", "mount", "str", "base", "html", "external", "log", "file", "el", "loc", "l", "b", "gl", "web", "uri", "string", "q", "r", "pattern", "ssl", "browser", "impl", "path", "ls", "util", "job", "ref", "sl", "address", "name", "term", "bel", "un", "ur", "get", "pl", "http", "ld", "ll", "link", "domain", "sql", "URL", "char", "config", "xml", "resource", "Url", "page", "key"], "in": ["c", "reader", "bin", "read", "din", "min", " din", "isin", "rin", "mi", "en", "inner", "l", "ln", "serv", "body", "vin", "mc", "update", "out", "is", "line", "input", "check", "nin", "al", "login", "name", "In", "n", "on", "online", "gin", "f", "ma", "init", "o", "IN", "con", "from", "ins", "null", "inn", "m", "cin", "ai", "again", "i", "s", "include", "source", "oin"]}}
{"id1": "5551393", "id2": "18631594", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD3", " getMD2", "getMD4", "getSHA4", "getmd4", "getSHA3", "getmd5", " getMD4", "getMD2", "getmd3", " getMD3", "getSHA2", "getSHA5", "getmd2"], "source": ["content", "text", "object", "src", "data", "base", "space", "file", "image", "now", "body", "string", "SOURCE", "input", "ource", "reason", "name", "spec", "start", "Source", "url", "target", "value", "template", "force", "site", "sample", "sequence", "context", "message", "from", "output", "subject", "style", "config", "resource", "s", "seed", "filename"], "tmp": ["img", "np", "t", "managed", "cv", "lambda", "Temp", "mobi", "src", "cont", "etc", "po", "data", "buff", "rup", " mp", "tt", "test", "jp", "bt", "temp", "result", "snap", "cp", "out", "mk", "nd", "MP", "input", "cache", "cb", "obj", "found", "nt", "tar", "bag", "foo", "buf", "mp", "resp", "p", "pkg", "perm", "gb", "output", "aaa", "pp", "m", "msg", "cmp", "sp", "attr", "tn", "db", "qq", "bb", "txt"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "wd", "dr", "td", "sd", "sm", "sam", "mand", "ind", "mt", "mod", "dd", "hd", "cmd", "df", "mk", "mb", "nd", "dm", "amd", "mac", "de", "pd", "nt", " MD", "mp", "d", "der", "di", "ld", "rm", "mn", "od", "desc", "m", "red", "ad", "mm", "ms", "and"]}}
{"id1": "1180878", "id2": "3024970", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchURLdata", "fetchStringStream", "fectURLdata", "fetchGETFrame", "fectUrlData", "fetchUrlFrame", "fectURLData", "fetchStringdata", "fetchStringFrame", "fetchGETStream", "fetchGETData", "fetchURLFrame", "fectURLStream", "fetchGETdata", "fectURLFrame", "fectUrlFrame", "fectUrlStream", "fetchUrlData", "fetchURLStream", "fectUrldata", "fetchUrldata", "fetchStringData", "fetchUrlStream"], "url": ["dl", "cl", "location", "ul", "default", "host", "nl", "mount", "html", "base", "full", "log", "file", "el", "loc", "print", "l", "b", "gl", "web", "uri", "https", "string", "pattern", "ssl", "path", "ls", "mail", "ref", "sl", "address", "name", "ur", "pl", "http", "ll", "link", "rel", "domain", "sql", "URL", "null", "lim", "xml", "resource", "Url"], "proxyHost": ["proxyUrl", "serverName", "slaveOver", "serverPort", "roxyLabel", "slaveCheck", "slaveAddress", " proxyName", "roxyAddress", "ProxyName", "Proxyhost", "ProxyHost", "roxyhost", "roxyOver", " proxyhost", "ProxyLabel", "serverHost", "ProxyUrl", " proxyAddress", "proxyOver", " proxyOver", "proxyCheck", "serverhost", "slaveUrl", "slavehost", "proxyLabel", "roxyUrl", " proxyCheck", "slaveHost", "ProxyPort", "proxyAddress", "slaveLabel", "roxyCheck", "proxyhost", "proxyName", "roxyHost"], "proxyPort": ["serverport", " proxyPORT", "aliasHost", " proxyport", "proxyport", "serverPort", "ProxyHost", "aliasport", "serverHost", " proxyAddress", "ProxyPORT", "serverPORT", "aliasPort", "serverAddress", "ProxyPort", "proxyAddress", "proxyPORT", "Proxyport", "aliasAddress"], "con": ["c", "xc", "trans", "close", "can", "ocon", "conn", "cone", "cont", "ver", "cal", "Con", "connection", "po", "Conn", "fac", "col", "pen", "en", "go", "func", "sub", "pan", "const", "cs", "bc", "ln", "comm", "cf", "ain", "mc", "cp", "cc", "client", "proc", "cmd", "cgi", "mo", "cons", "CON", "cond", "open", "don", "conv", "cover", "un", "ran", "co", "non", "conf", "cur", "cn", "gate", "pc", "bo", "cat", "fin", "fc", "lock", "dial", "canon", "rec", "syn", "ex", "act", "ctrl", "cos", "call", "com", "nc", "connect"], "is": ["ip", "ains", "ps", "ists", "dis", "iris", "in", "es", "bs", "os", "sis", "isin", "isc", "bis", "isi", "eps", "has", "gets", "cs", "isp", "was", "isf", "im", "bits", "iter", "ist", "sys", "xs", "as", "oss", "iso", "lis", "ys", "ois", "its", "IS", "si", "ris", "init", "are", "fs", "ims", "ais", "rs", "isa", "mis", "iss", "ios", "abs", "isl", "ins", "us", "i", "Is", "s", "ri", "ts", "ms"], "u": ["c", "fu", "uv", "ul", "nu", "eu", "uid", "user", "ui", "ud", "iu", "ut", "su", "uri", " nu", "hu", "uni", "uf", "ue", "cu", "uu", "up", "un", "ur", "o", "pu", "uj", "tu", "au", "U", "yu", "lu", "us", "mu", "i", "ru", "bu", "ou", "g"], "proxy": ["version", "ip", "embed", "echo", "pse", "translation", "cone", "host", "pipe", "po", "connection", "base", "server", "PRO", "py", "prime", "xy", "go", "pool", "jp", "friend", "phone", "web", "roxy", "https", "cp", "client", "Proxy", "profile", "browser", "x", "pointer", "pin", "gp", "library", "ssl", "cache", " proxies", "cas", "alias", "policy", "pi", "address", "map", " prox", "password", "shadow", "project", "pe", "aco", "token", "http", "timeout", "slave", "XY", "ping", "link", "pre", "bo", "domain", "via", "null", "pro", "socket", "port", "zip"], "baos": ["baOS", "BAoss", " baows", "baOs", "vaOS", "BAose", " baOs", "poo", "poos", " baose", "naos", " baoS", "baose", " baoss", "baoss", "vaos", "bais", "BAows", "aoOS", "vaoS", "naows", "aois", " baOS", "poOs", " bais", "aoos", "baows", "nao", "naoss", "BAo", "aooS", "BAos", "bao", "baoS", " bao", "vais", "poose", "BAOs"]}}
{"id1": "2461169", "id2": "4618237", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "11477906", "id2": "21348951", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadDefaultValues", "readDefaultSettings", "loadDefaultSetting", "loadFAULTsettings", "loadFAULTSettings", "readdefaultSetting", "readdefaultsettings", "readDefaultsettings", "loaddefaultSetting", "loadFAULTSetting", "readDefaultValues", "loadFAULTValues", "readdefaultValues", "readDefaultSetting", "loaddefaultSettings", "loadDefaultsettings", "loaddefaultValues", "loaddefaultsettings", "readdefaultSettings"], "configFileName": ["configfileName", "configFileLocation", "confFilenamePath", "confFileNames", "configPageNames", "configStreamLocation", "conffilename", "configFILEname", "confFilenamename", "configStreamName", "conffilePath", "configFilename", "configFILEName", "confFilePath", "confFileName", "configPagename", "confFilename", "configFilenamePath", "configfileNames", "configFILEPath", "conffileName", "configFilenameNames", "configFILELocation", "configFilenameName", "configStreamname", "configPagePath", "confFileLocation", "conffileNames", "configfilePath", "configFilenameLocation", "confFilenameName", "configFileNames", "configFilePath", "confFilenameLocation", "configFilenamename", "configStreamPath", "configPageName", "configfilename"], "in": ["t", "bin", "din", " din", "or", "re", "run", "user", "id", "isin", "rin", "ind", "mi", "en", "inner", "l", "ze", "e", "inf", "ain", "ro", "im", "mc", "is", "input", "ls", "check", "al", "up", "In", "n", "on", "gin", "init", "ma", "info", "ini", "IN", "o", "con", "it", "from", "ar", "ins", "inn", "m", "cin", "doc", "ai", "ad", "i", "source"], "out": ["t", "v", "une", "or", "en", "ot", "up", "conv", "init", "con", "output", "Out", "ins", "null", "ion", "writer", "io", "read", "off", "po", "ne", "server", "auto", "file", "ge", "sys", "oss", "client", "gc", "cache", "de", "ing", "o", "net", "ou", "aos", "can", "copy", "des", "os", "user", "over", "OU", "raw", "at", "ent", "update", "gt", "check", "nt", "are", "cn", "it", "to", "not", "OUT", "ind", "log", "res", "obj", "n", "handle", "co", "all", "outs", "w", "ex", "m", "store", "port"]}}
{"id1": "9275622", "id2": "23452437", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyfile", " copyStream", " cpStream", " cpfile", " duplicateStream", "copyStream", " duplicateFiles", " copyFiles", " cpFile", " duplicateFile", " duplicatefile", " cpFiles"], "_file1": ["_fileOne", "_linkInit", "_ileInit", "_FileOne", "_ileOne", "_ileFirst", "_ile1", "_filesOne", "_linkOne", "_FileFirst", "_link2", "_fileFirst", "_link1", "_fileInit", "_ile2", "_File2", "_FileInit", "_files2", "_File1", "_files1", "_filesFirst"], "_file2": ["_FILE02", "_fileTwo", " _Filetwo", " _FILE1", "_FILE2", "_fileb", " _filetwo", " _FILEb", "_link2", "_file02", "_FILE1", " _fileb", " _fileTwo", "_File02", "_link1", "_image02", "_image1", "_linktwo", " _FileTwo", "_Fileb", "_linkTwo", " _File2", "_File2", " _FILE2", "_Filetwo", "_FILEb", "_filetwo", "_image2", "_FileTwo", "_imageb", " _File1", " _file02", " _FILE02", "_File1"], "fis": ["kios", "Fios", " fi", "kais", "fiss", " fais", "kis", "fios", "fliss", "Fois", " fois", "ufi", "cfris", " fiss", "fois", "ufis", "qiss", "qios", "qis", "qos", "Fos", "fli", " fios", "fais", " fris", "cios", "cais", "Fris", "cfois", "kos", "cfis", "flios", "Fiss", "ufiss", "cfiss", "Fis", "fi", "cos", "ufios", "flis", "cis", "fris"], "fos": ["woes", "foes", "hose", "mos", "ffos", "fows", " fose", "ffoes", "hoes", "hos", "woss", " foss", "foss", "floes", "sfoss", "sfoes", "faos", "sfos", "moes", "maos", "mows", "wis", "flos", "ffis", "floss", "ffoss", "hoss", "waos", "wows", " faos", "sfose", " fows", "fose", "flis", " foes", "wos"], "canalFuente": ["canalFuestro", "canalKuperor", "canalFalent", "canallfueree", "canallFuente", "canallfuperor", "canalTenperor", "canalUtent", "canalKuent", "canallFuenza", "canallFuent", "canalfuestro", "canalFueree", "canallFuperor", "canalFient", "canalFuje", "canallfuje", "canalUteree", "canallFuestro", "canalFaleree", "canallfuestro", "canallFuje", "canalKuente", "canalfuente", "canallfuenza", "canallfuent", "canalFiente", "canalFalestro", "canalUtente", "canalFalente", "canalFienza", "canalTenenza", "canallfuente", "canalTenent", "canallFueree", "canalfuje", "canalTenente", "canalFalperor", "canalFiperor", "canalFalje", "canalKuje", "canalUtestro", "canalfueree", "canalFuent", "canalfuent", "canalFuperor", "canalFuenza", "canalfuenza", "canalfuperor"]}}
{"id1": "21921000", "id2": "21555906", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["scan", "save", " dissect", "fork", "read", "close", "build", " evaluate", "se", "run", " solve", "next", "construct", " parser", "install", "start", "handle", "init", "execute", "apply", "process", " scan", " ingest", " eval", " merge"], "url": ["lb", "dl", "cl", "build", "ul", "conn", "nl", "mount", "log", "loc", "lr", "l", "b", "web", "https", "r", "client", "ssl", "cert", "ls", "open", "job", "mail", "sl", "sur", "bel", "un", "ur", "f", "pl", "http", "hl", "ll", "link", "cm", "abs", "au", "ret", "URL", "Url"], "con": ["c", " Con", "cl", "can", "sc", "conn", "ver", "re", "Con", "connection", "Conn", "pen", " conn", "bc", "ln", "ain", "mc", "cp", "cc", "client", "cons", "CON", "conv", "sur", "connect", "login", "ran", "un", "co", "soc", "conf", "cur", "cn", "cm", "fc", "dial", "com", "cin", "nc", "cf"], "bStream": ["rbStreamer", "rstream", " bRead", "fRead", "vRead", "bstream", " bStreamer", " bChannel", "rbRead", "bStreamer", "rbstream", "vSteam", "rStreamer", "fStreamer", "rStream", "vReader", "rbStream", " bstream", "rSteam", " bReader", "fStream", "bbReader", "bbStream", "vStream", "fChannel", "bbSteam", "bSteam", " bSteam", "rbChannel", "bReader", "bChannel", "bbRead", "rbSteam", "bRead"], "str": ["c", "t", "fr", "ctr", "text", "gr", "Str", "arr", "cont", "comment", "pos", "pr", "print", "l", "b", "cs", "comm", "pt", "e", "string", "console", "r", "out", "line", "dec", "input", "tr", "res", "br", "err", "obj", "spec", "n", "req", "p", "list", "cur", "STR", "it", "vol", "sp", "st", "j", "char", "z", "g", "i", "s", "cr", "msg", "source", "txt"], "tokens": ["stokets", "toksets", "tobkens", "todkens", "tokseds", "tokskens", "tkeds", "tobTokens", "todences", "tkens", "pobTokens", "takets", "todTokens", "tobents", "Tokens", "tokents", "toksents", "tokeds", "Tokets", "pokkens", "pokens", "pokTokens", "todets", "tkets", "todents", "tokets", "stokkens", "toksTokens", "stodets", "tolences", "stodences", "stodkens", "pokents", "toksens", "todens", "takeds", "tolets", "Tokents", "tkents", "Tokeds", "Toksets", "Tokseds", "Toksents", "stokences", "tokkens", "tobens", "pobens", "Toksens", "tolens", "stodens", "takents", "stokens", "pobents", "takens", "tolkens", "pobkens", "tokTokens", "toksences", "tokences"], "charCode": ["characterFore", "characterType", "cellcode", "charFore", "cellName", "CharacterFore", "CharFore", "charName", "CharacterName", "charactercode", "charcode", "cellType", "characterCode", "cellCode", " charcode", "CharacterCode", " charName", "charType", " charType", "characterName", "CharName", "CharCode"], "value": ["version", "scale", "VALUE", "zone", "v", "type", "serial", "score", "instance", "average", "default", "max", "data", "category", "total", "currency", "percent", "language", "result", "price", "Value", "family", "pain", "step", "dollar", "address", "format", "position", "feature", "description", "property", "val", "number", "hello", "sample", "sequence", "sum", "function", "money", "current", "key", "system"], "unit": ["scale", "io", "type", "stable", "nu", "volume", "category", "base", "u", "unknown", "dimension", "relation", "currency", "component", "prefix", "dir", "string", "uni", "nit", "util", "chain", "term", "name", "format", "variable", "un", "note", "command", "layout", "number", "unsigned", "num", "crit", "Unit", "it", "group", "block", "sum", "money", "set", "units", "class"]}}
{"id1": "6260216", "id2": "8490297", "code1": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"send": ["Send", "save", "text", "submit", "request", "read", "write", "printf", "upload", "transfer", "download", "add", "post", "body", "put", "sent", "export", "handle", "get", "execute", "service", "query", "append", "message", "output", "report", "call", "push"], "s": ["gs", "c", "t", "ss", "strings", "ps", "v", "es", "bs", "str", "js", "data", "os", "l", "b", "string", "xs", "r", "is", "ls", "ws", "a", "n", "its", "p", "f", "fs", "rs", "S", "sts", "w", "bytes", "m", "g", "h", "ts", "i", "ms"], "s1": ["qs1", "s0", "qs0", "s2", "rs1", "qs2", "S2", "S01", "rs0", "rs2", " s0", "s01", " s2", "S1", "S0", " s01"], "httpurlconnection": ["httppullapplication", "apacheurlconnected", "httpconsoleconnection", "upperurlposition", " httpurlcontext", "httpcertattribute", "httphttpposition", "apacheurlconnection", "upperurlapplication", "httpbuildconnected", "httpcalconnection", "apachebuildconnected", "upperpullapplication", "httpUrlconnection", "httpUrlposition", "httpgetposition", "hurlopen", "httpdateconnection", " httpusercommunication", " httpurlrelation", "htturlconn", "httppullgeneration", "httpcalclient", "httpruleconnection", "httpsslcontext", " httpsslcontext", "httpmailconnect", "httphttpconnection", "httploggeneration", "httpurlcontext", "httplogconn", "httpUrlapplication", "httplogconnect", "httprelconnection", "hllConnection", "httpbuildconn", "upperdateconnection", " httpwebconnect", "httpdateconn", "upperurlconnection", "highurlconnection", "httpcalconnect", "hllconnect", "httpurlattribute", "httpdatecontext", "httppullconnect", "httpUrlconnected", "httpmailposition", "highurlposition", "httpconsoleattribute", "httplogcommunication", "ttpUrlconnection", "httpuserconn", "httpUrlgeneration", "httpcertconnection", "httppullconnection", "httplogapplication", "httpconsoleconn", "httpwebclient", "httpllConnection", "hllconnection", "httpwebconnect", "httpsslcommunication", "httpsslconnection", "httpbuildconnection", "hurlconnection", "highconsoleconn", "httpUrlcommunication", "httpcalcontext", "apachebuildconn", "hllopen", "httpurlgeneration", "httpurlcommand", "httpllopen", "httphttpconn", " httpuserconnection", "httphttpconnect", "httpmailconn", "httpsslconnected", "httpdateposition", "httprelcontext", "httpcalcommunication", "htturlcommand", "httpurlconnect", "highconsoleconnection", "highconsoleattribute", "httpllconnect", "httmailposition", "httpwebcontext", "httpmailcommand", "httpuserconnect", "httplogrelation", "httpruleconn", "httpurlcommunication", "httpuserposition", "upperpullconnection", "httpmailconnection", "upperurlgeneration", "httpruleposition", "ttpurlposition", "apachebuildconnection", "httpgetcommand", "httphttpopen", "ttpurlconnect", "httprelconn", "upperdateconn", " httpuserconnect", "httmailconn", "hurlConnection", "httpsslconnect", " httpurlconn", "httpcertposition", " httpuserrelation", "httpurlposition", "httpurlconnected", "httpwebconnection", "upperurlcontext", "ttpUrlconnect", " httpsslcommunication", "upperdatecontext", "httmailcommand", "httpcertcontext", "httphttpcontext", "highurlattribute", "ttpUrlposition", "hurlconnect", "httpcertconn", "apacheurlconn", "upperdateposition", "httpdbconnection", "highurlconn", "httpUrlcontext", " httpsslconn", "httmailconnection", "httpurlconn", "httpurlConnection", "httpurlclient", "httpbuildconnect", "highconsoleposition", "httpdbConnection", " httpwebcontext", "httpgetconn", "httpconsoleposition", " httpwebclient", "httpcalconn", "ttpurlconnection", " httpurlconnect", "httpgetconnection", "httpmailconnected", "ttpUrlconnected", "httpusercommand", "httpUrlclient", "httpsslconn", "apachebuildconnect", "httpurlrelation", "httplogconnection", "httprelcommunication", " httpurlcommunication", " httpurlclient", "httpuserrelation", "httpdbconnect", "httpusercommunication", "httpurlapplication", "httpUrlrelation", "htturlconnection", "upperpullgeneration", " httpwebconnection", "httpdbopen", "httpUrlconnect", "httpruleattribute", "upperurlconnect", "htturlposition", "apacheurlconnect", "upperpullconnect", "httpuserconnection", "httpllconnection", "httphttpConnection", " httpsslconnection", "httplogconnected", "httpurlopen", "ttpurlconnected", "upperurlconn"], "datainputstream": ["datrainputstore", "datainoutputlength", "datrainoutputstream", "datrainoutputstore", "datrainputStream", "datainPUTstream", "datainerputStream", "datainputcontrol", "datainerPUTstream", "datainointstream", "datainportStream", "datainportcontrol", "datainputpipe", "datainputbody", "datainputlength", "datainoutputStream", "datainputstore", "datainerputlength", "datrainoutputStream", "datainutpipe", "datainsputStream", "dataincutStream", "datainoutputstore", "datainPUTbody", "datainerPUTbody", "dataincutstream", "datainoutputpipe", "datainerputbody", "datainutstore", "datainerputstream", "datainsputstream", "datainsoutputpipe", "datainutStream", "datainutstream", "datrainputcontrol", "datrainputstream", "datainputStream", "datainointpipe", "dataincutlength", "datainoutputbody", "dataincutbody", "datainportstore", "datainPUTlength", "datainsputpipe", "datrainoutputcontrol", "datainoutputcontrol", "datainerPUTStream", "datainsoutputStream", "datainutcontrol", "datainerPUTlength", "datainsoutputstream", "datainPUTStream", "datainointStream", "datainoutputstream", "datainportstream"], "url": ["t", "dl", "ml", "build", "ul", "rl", "nl", "mount", "str", "base", "u", "el", "l", "b", "gl", "web", "loader", "https", "il", "r", "ssl", "ls", "www", "util", "ref", "sl", "address", "name", "bel", "ur", "f", "pl", "http", "ll", "link", "rel", "abs", "URL", "char", "Url"], "dataoutputstream": ["dataoutputtime", "dataoutputrow", " dataOutputwindow", "dataputstream", "dataconnectionwindow", " dataoutputwindow", " dataOutputstream", "dataoutputwindow", "datasuccesswindow", "dataoutputStream", "datasuccessstream", "dataOutputrow", " dataoutputtime", "dataconnectionrow", " dataOutputStream", " dataOutputrow", "datainputStream", "dataconnectionstream", "dataOutputstream", "datasuccessStream", "dataputwindow", " dataOutputtime", "dataOutputtime", " dataoutputrow", " dataoutputStream", "dataconnectionStream", "datasuccesstime", "dataOutputStream", "datainputwindow", "datainputrow", "dataOutputwindow", "dataputStream", "dataputtime"]}}
{"id1": "12490144", "id2": "13516684", "code1": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 0, "substitutes": {"createJCoPluginProject": ["createJCoDriverPlugin", "createJCoPlugPlugin", "createJCoDriverProject", "createJCoJavaProject", "createJCoDriverApp", "createJCoPlugApp", "createJcoDriverProject", "createJCoDriverFile", "createJCoJavaPlugin", "createJCoPluginFile", "createJCoPluginPlugin", "createJCoPluginApp", "createJcoPluginProject", "createJcoDriverFile", "createJCoJavaApp", "createJCoPlugFile", "createJCoPlugProject", "createJcoDriverPlugin", "createJcoPluginApp", "createJcoPluginFile", "createJCoJavaFile", "createJcoDriverApp", "createJcoPluginPlugin"], "monitor": ["memory", "bm", "state", "batch", "mate", "driver", "program", "hover", "tm", "processor", "timeout", "mean", "meter", "cm", "message", "sim", "mu", "writer", "system", "history", "um", "member", "mr", "rem", "core", "rest", "timer", " Monitor", "menu", "Monitor", "execute", "match", "record", "stats", "monkey", "unit", "buffer", "status", "sm", "mi", "delay", "hist", "pause", "check", "maximum", "alert", "counter", "map", "thread", "block", "minimum", "wait", "tem", "scan", "widget", "method", "manager", "test", "register", "mark", "im", "dm", "activity", "watch", "mem", "mx", "man", "em", "runner", "tim", "report", "stat", "display", "m", "master", "ai", "mm", "mon", "summary"], "sourceFileName": ["sourceResourceName", "SourceFilename", "sourceFileFile", "sourceDirPath", "SourcefileName", "archivefilePath", "SourcefilePath", "sourceDirSize", "sourcefileSize", "Sourcefilename", "archiveFileName", "archiveFilePath", "sourceResourcename", "sourceFileSize", "sourcefilename", "archiveFileSize", "sourcefileFile", "archivefileSize", "sourcefilePath", "SourceFileName", "archiveFileFile", "sourceDirFile", "sourcefileName", "SourceFilePath", "archivefileName", "sourceResourceSize", "SourceFileFile", "sourceResourceFile", "sourceResourcePath", "archivefileFile", "sourceDirName", "sourceFilePath", "sourceFilename", "sourceDirname", "SourcefileFile"], "pluginName": ["PluginName", "pluginType", "workerClass", "PluginKey", "workerKey", " pluginKey", "PluginType", "moduleId", "moduleAgent", "projectAgent", "moduleClass", " pluginType", "pluginname", "moduleName", "projectname", "PluginClass", " pluginClass", "moduleType", "projectId", "projectName", "PluginNAME", "pluginClass", "workerNAME", "pluginAgent", "PluginId", "pluginNAME", "projectClass", "workerName", "modulename", "pluginId", " pluginNAME", "pluginKey", "Pluginname", "projectType", " pluginAgent"], "files": ["modules", "projects", "features", "faces", "locks", "devices", "classes", " Files", "Files", "headers", "forms", "images", "assets", "ports", "books", "scripts", "thumbnails", "items", "versions", "sections", "objects", "ids", "actions", "plates", "bees", "iles", "names", "models", "members", "fs", "sets", "uploads", "users", "resources", "blocks", "values", "bytes", "fields", "boxes", "keys"], "project": ["object", "scope", "archive", "component", "google", "forge", "profile", "job", "primary", "metadata", "init", "service", "directory", "subject", "git", "config", "model", "parent", "apache", "version", "projects", "product", "build", "server", "file", "phone", "section", "path", "index", "application", "database", "java", "root", "record", "site", "group", "context", "zip", "home", "plugin", "app", "create", "type", "tree", "upload", "document", "region", "operator", "item", "setup", "p", "layout", "journal", "pkg", "json", "info", "template", "question", "process", "resource", "set", "instance", "base", "library", "title", "name", "command", "folder", "Project", "target", "module", "report", "task", "port", "form", "class"], "description": ["license", "details", "creation", "usage", "detail", "location", "translation", "escription", "tree", "category", "comment", "attribute", "document", "phrase", "region", "expression", "cription", "profile", "definition", "section", "library", "reference", "video", "application", "database", "title", "address", "name", "metadata", "note", "position", "password", "shadow", "Description", "purpose", "json", "directory", "template", "value", "desc", "message", "display", "about", "information", "function", "resource", "key", "summary"], "javaProject": ["pythonProject", "jProject", " javaPort", "jApplication", "JavaPackage", "JavaProject", "jPackage", "pythonApp", "JavaPort", " javaPackage", " javaApp", "jApp", "javaApplication", "javaApp", "javaPackage", "JavaApplication", "JavaApp", "javaPort", "pythonPort", " javaApplication", "pythonPackage"], "binDir": ["binaryDet", "binDirectory", "libDirectory", "libFolder", " binD", "binD", "sinDirectory", "sinDir", " binUrl", "binFolder", "binaryFolder", "libUrl", "binDet", "sinDet", "libDir", "binaryDir", " binDet", " binDirectory", "binaryD", "binaryUrl", " binFolder", "sinD", "binaryDirectory", "binUrl"], "binPath": ["outputDir", "internalDir", "binpath", "inPath", "bankPod", "internalUrl", "outputPath", "outputPod", "bankPath", "inTh", "inpath", "internalTh", "internalPath", "outputpath", "binaryDir", "binaryPath", "binaryTh", "inUrl", "binTh", "bankDir", "inPod", "binaryUrl", "bankpath", "inDir", "binUrl", "binPod"], "metaInfFolder": ["metaFifolder", "metaInfController", "metadataInffolder", "metadataInfDirectory", "metadataInfofolder", "metaAppfolder", "metadataInfController", "metaFiDirectory", "metaAppDirectory", "metaDeffolder", "metaDefFolder", "metainffolder", "metadataInfoContainer", "metaDefController", "metaAppController", "metaInffolder", "metadataInfContainer", "metadataInfoDirectory", "metaInfContainer", "metainfDirectory", "metaInfoContainer", "metaAppFolder", "metaInfoController", "metaInfoFolder", "metaInfDirectory", "metaDefDirectory", "metadataInfFolder", "metaInfoDirectory", "metaInfofolder", "metaFiFolder", "metainfContainer", "metadataInfoController", "metadataInfoFolder", "metainfFolder", "metaFiContainer"], "manifest": ["manifact", "textifest", "modagine", "manuscript", "modage", "signifest", "generendor", "modiff", "emanually", "manapter", "emanifest", "menuscript", "textendor", "MANifest", "wordifest", "mician", "maniff", "manility", "remifest", "manendor", "wordually", "generistry", "donifest", "mverage", "modverage", "manework", "emanework", "emanifact", "manverage", "manigraph", "donverage", "modigraph", "manually", "mage", "generifest", "managine", "modually", "manffee", "MANffee", "minually", "menffee", "minework", "wordework", "textverage", "remagine", "generverage", "modapter", "mifest", "manician", "emanverage", "manage", "minverage", "signually", " manage", "menifact", "modifest", "donendor", "wordapter", "modility", "donistry", " manician", "modician", "textistry", " manverage", "wordverage", "nonility", "signigraph", "wordiff", "menifest", "nonually", "MANuscript", "signility", "remapter", "MANifact", "minifest", "emanuscript", "nonigraph", "manistry", "wordagine", "emanffee", "nonifest", "remiff"]}}
{"id1": "1180878", "id2": "942693", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchURLdata", "fetchStringStream", "fectURLdata", "fetchGETFrame", "fectUrlData", "fetchUrlFrame", "fectURLData", "fetchStringdata", "fetchStringFrame", "fetchGETStream", "fetchGETData", "fetchURLFrame", "fectURLStream", "fetchGETdata", "fectURLFrame", "fectUrlFrame", "fectUrlStream", "fetchUrlData", "fetchURLStream", "fectUrldata", "fetchUrldata", "fetchStringData", "fetchUrlStream"], "url": ["dl", "cl", "location", "ul", "default", "host", "nl", "mount", "html", "base", "full", "log", "file", "el", "loc", "print", "l", "b", "gl", "web", "uri", "https", "string", "pattern", "ssl", "path", "ls", "mail", "ref", "sl", "address", "name", "ur", "pl", "http", "ll", "link", "rel", "domain", "sql", "URL", "null", "lim", "xml", "resource", "Url"], "proxyHost": ["proxyUrl", "serverName", "slaveOver", "serverPort", "roxyLabel", "slaveCheck", "slaveAddress", " proxyName", "roxyAddress", "ProxyName", "Proxyhost", "ProxyHost", "roxyhost", "roxyOver", " proxyhost", "ProxyLabel", "serverHost", "ProxyUrl", " proxyAddress", "proxyOver", " proxyOver", "proxyCheck", "serverhost", "slaveUrl", "slavehost", "proxyLabel", "roxyUrl", " proxyCheck", "slaveHost", "ProxyPort", "proxyAddress", "slaveLabel", "roxyCheck", "proxyhost", "proxyName", "roxyHost"], "proxyPort": ["serverport", " proxyPORT", "aliasHost", " proxyport", "proxyport", "serverPort", "ProxyHost", "aliasport", "serverHost", " proxyAddress", "ProxyPORT", "serverPORT", "aliasPort", "serverAddress", "ProxyPort", "proxyAddress", "proxyPORT", "Proxyport", "aliasAddress"], "con": ["c", "xc", "trans", "close", "can", "ocon", "conn", "cone", "cont", "ver", "cal", "Con", "connection", "po", "Conn", "fac", "col", "pen", "en", "go", "func", "sub", "pan", "const", "cs", "bc", "ln", "comm", "cf", "ain", "mc", "cp", "cc", "client", "proc", "cmd", "cgi", "mo", "cons", "CON", "cond", "open", "don", "conv", "cover", "un", "ran", "co", "non", "conf", "cur", "cn", "gate", "pc", "bo", "cat", "fin", "fc", "lock", "dial", "canon", "rec", "syn", "ex", "act", "ctrl", "cos", "call", "com", "nc", "connect"], "is": ["ip", "ains", "ps", "ists", "dis", "iris", "in", "es", "bs", "os", "sis", "isin", "isc", "bis", "isi", "eps", "has", "gets", "cs", "isp", "was", "isf", "im", "bits", "iter", "ist", "sys", "xs", "as", "oss", "iso", "lis", "ys", "ois", "its", "IS", "si", "ris", "init", "are", "fs", "ims", "ais", "rs", "isa", "mis", "iss", "ios", "abs", "isl", "ins", "us", "i", "Is", "s", "ri", "ts", "ms"], "u": ["c", "fu", "uv", "ul", "nu", "eu", "uid", "user", "ui", "ud", "iu", "ut", "su", "uri", " nu", "hu", "uni", "uf", "ue", "cu", "uu", "up", "un", "ur", "o", "pu", "uj", "tu", "au", "U", "yu", "lu", "us", "mu", "i", "ru", "bu", "ou", "g"], "proxy": ["version", "ip", "embed", "echo", "pse", "translation", "cone", "host", "pipe", "po", "connection", "base", "server", "PRO", "py", "prime", "xy", "go", "pool", "jp", "friend", "phone", "web", "roxy", "https", "cp", "client", "Proxy", "profile", "browser", "x", "pointer", "pin", "gp", "library", "ssl", "cache", " proxies", "cas", "alias", "policy", "pi", "address", "map", " prox", "password", "shadow", "project", "pe", "aco", "token", "http", "timeout", "slave", "XY", "ping", "link", "pre", "bo", "domain", "via", "null", "pro", "socket", "port", "zip"], "baos": ["baOS", "BAoss", " baows", "baOs", "vaOS", "BAose", " baOs", "poo", "poos", " baose", "naos", " baoS", "baose", " baoss", "baoss", "vaos", "bais", "BAows", "aoOS", "vaoS", "naows", "aois", " baOS", "poOs", " bais", "aoos", "baows", "nao", "naoss", "BAo", "aooS", "BAos", "bao", "baoS", " bao", "vais", "poose", "BAOs"]}}
{"id1": "22708533", "id2": "17817568", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentToURI", " copydocumenttoFile", " copyDocumentAsURL", " copyDocumentToUrl", " copyDocumentToFile", " copyDocumentToURL", " copyDocumenttoFile", " copydocumentToURL", " copyDocumentFromFile", " copyDocumentFromUrl", " copyDocumentAsUrl", " copydocumentToUrl", " copyDocumenttoUrl", " copydocumentToFile", " copydocumenttoURI", " copyDocumentFromURI", " copydocumentToURI", " copyDocumenttoURL", " copyDocumentAsURI", " copyDocumentAsFile", " copyDocumenttoURI", " copydocumenttoURL", " copydocumenttoUrl", " copyDocumentFromURL"], "file": ["le", "where", "default", "data", "base", "fil", "FILE", "full", "attribute", "File", "log", "document", "image", "place", "string", "ile", "origin", "path", "input", "work", "check", "title", "name", "command", "f", "local", "sample", "valid", "from", "message", "doc", "table", "resource", "rule", "source", "filename"], "target": ["location", "home", "replace", "top", "arget", "host", "view", "back", "base", "scope", "this", "select", "dest", "print", "join", "component", "result", "origin", "update", "pattern", "ARGET", "alias", "root", "project", "layout", "template", "arg", "local", "link", "rel", "valid", "to", "table", "remote", "window", "source", "Target"], "is": ["ip", "ains", "est", "tis", "mos", "ists", "dis", "iris", "es", "bs", "\u00eds", "sis", "isin", "vs", "mi", "isc", "bis", "isi", "has", "cs", "isf", "bits", "im", "ics", "oss", "iso", "ms", "lis", "nis", "isal", "ys", "ci", "ois", "its", "IS", "si", "ris", "fs", "ais", "ims", "rs", "isa", "mis", "iss", "it", "ios", "isl", "abs", "vis", "ir", "obs", "ins", "ns", "us", "i", "Is", "ism", "ri", "xs"], "os": ["et", "ori", "dos", "nos", "ss", "io", "ose", "mos", "ps", "Os", "es", "bs", "ros", "des", "OS", "mot", "pos", "bis", "eps", "oS", "ones", "oa", "osa", "ks", "ot", "bos", "sys", "oss", "acs", "ows", "oos", "oses", "out", "none", "ops", "asis", "uts", "ox", "ols", "los", "o", "ost", "ios", "css", "obs", "ins", "osi", "oes", "cos", "us", "mes", "ts", "ns", "aos", "oin", "tes", "ms"], "url": ["t", "location", "ul", "conn", "host", "nl", "re", "str", "mount", "user", "l", "web", "uri", "https", "cp", "r", "client", "ssl", "cert", "ls", "open", "job", "address", "name", "n", "ur", "f", "http", "service", "channel", "net", "con", "ll", "link", "rel", "domain", "URL", "char", "Url"], "connection": ["c", "t", "generation", "closure", "creation", "close", "conn", "cone", "document", "l", "relation", "using", "result", "still", "uri", "session", "established", "client", "pointer", "reference", "application", "open", "database", "communication", "command", "n", "position", "city", "description", "network", "character", "service", "channel", "number", "net", "con", "Connection", "link", "response", "opening", " Connection", "condition", "entry", "resource", "ion", "connect"]}}
{"id1": "19944975", "id2": "18433984", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteConfiguration", "outputContent", "writeConfig", "WriteContent", "writeContent", "WriteSettings", "outputSettings", " writeContent", "WriteConfig", " writeConfig", "writeSettings", " writeSettings", "outputConfig", "outputConfiguration"], "out": ["c", "t", "io", "v", "conn", "help", "over", "this", "OU", "log", "file", "pool", "print", "b", "free", "result", "ent", "at", "client", " OUT", "cmd", "check", "res", "err", "nt", "up", "n", "cast", "p", "pretty", "all", "list", "o", "set", "con", "outs", "w", "ch", "cm", "output", "Out", "group", "report", "null", "to", "table", "msg", "writer", "g", "h", "ou", "aos", "OUT", "outer"], "url": ["dl", "location", "rl", "nl", "mount", "str", "base", "user", "file", "loc", "l", "gl", "uri", "r", "client", "pattern", "cert", "ssl", "path", "mail", "ref", "sl", "address", "name", "bel", "f", "http", "service", "net", "ll", "link", "domain", "rel", "abs", "URL", "char", "ret", "resource", "Url", "rect", "key"], "in": ["io", "reader", "bin", "read", "din", " din", "str", "user", "isin", "rin", "ind", "el", "file", "en", "inner", "l", "serv", "inside", "body", "source", "mc", "r", "none", "is", "input", "al", "up", "In", "on", "gin", "f", "ma", "IN", "con", "it", "sample", "st", "sum", "from", "ins", "null", "inn", "m", "cin", "i", "sin", "and"]}}
{"id1": "20375440", "id2": "12782570", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "copyfile", " copyfile", "moveDirectory", "CopyDirectory", "movefile", "CopyFiles", "CopyFile", "copyDirectory", "moveFiles", " copyFiles", "Copyfile", " copyDirectory", "moveFile"], "srcFile": ["sourceFiles", " srcfile", " srcLine", "subLine", "subPath", "rcWeb", "srcPath", "rcPath", "rcfile", "sourceFile", "srcWeb", "srcLine", " srcFiles", " srcPath", "sourcefile", "rcFiles", "srcfile", "srcFiles", "rcFile", " srcWeb", "subWeb", "sourcePath", "rcLine", "subFile"], "destFile": ["srcMail", "DestDir", "srcPath", "destDir", "DestPath", "potFilename", "destMail", "potFile", "destFilename", "DestFile", "potDir", "DestFiles", "potMail", "srcFiles", "srcFilename", " destFilename", "destPath", " destFiles", "destFiles", " destDir", "srcDir", " destPath", " destMail"], "src": ["sync", "scan", "sb", "ctr", "reader", "sr", "sc", "sin", "rl", "rx", "usr", "sit", "rob", "pri", "rest", "loc", "sq", "sub", "const", "inner", "ln", "sys", "proc", "ssl", "sl", "rc", "rb", "req", "sing", "comp", "iv", "http", "rt", "cur", "rs", "via", "rel", "st", "ins", "syn", "sel", "gob", "sh", "inst", "sf", "ser", "source"], "dest": ["est", "priv", "coord", "Dest", "trans", "bin", "dis", "inv", "pipe", "des", "usr", "nom", "sit", "rest", "pos", "loc", "dc", "them", "self", "temp", "result", "pas", "out", "mk", "nd", "opt", "end", "nt", "dat", "comb", "exp", "news", "pl", "comp", "di", "target", "dist", "gate", "std", "desc", "rel", "st", "sum", "output", "must", "cat", "gd", "master", "doc", "port", "decl", "mm", "pub", "cont", "source"], "buffer": ["object", "text", "Buffer", "memory", "binary", "stack", "stream", "data", "buff", "base", "length", "comment", "attribute", "batch", "available", "document", "print", "phrase", "component", "result", "word", "bar", "button", "limit", "shape", "cache", "variable", "command", "mem", "buf", "password", "frame", "number", "value", "row", "channel", "event", "sample", "block", "sequence", "message", "append", "char", "entry", "initial", "table", "window", "page", "header"], "read": ["sync", "text", "t", "run", "draw", "give", "mix", "iter", "pe", "reading", "valid", "readable", "char", "config", "scale", "build", "READ", "in", "each", "add", "next", "q", "allow", "index", "open", "play", "get", "pass", "height", "record", "last", "parse", "count", "write", "stream", "length", "shape", "no", "shift", "check", "hold", " write", "old", "start", "len", "load", "find", "depth", "Read", "query", "num", "sample", "reads", "have", "wait", "key", "skip", "reader", "current", "tail", "str", "need", "ind", "print", " Read", "input", "fill", "end", "n", "send", "size", "seek", "word"]}}
{"id1": "17083703", "id2": "18211588", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"savaRolePerm": ["sDeleteRoleProms", "sDeleteResourcePerm", "sDeleteRolePERms", "sDeleteResourcePerM", "sDeleteRolePerM", "sDeleteRoleProm", "sDeleteRolePerms", "sDeleteResourceProM", "sDeleteRolePerm", "sDeleteRolePERm", "sDeleteRolePerperm", "sDeleteRoleProperm", "sDeleteResourcePerms", "sDeleteResourcePerperm", "sDeleteRolePERperm", "sDeleteResourceProperm", "sDeleteResourceProm", "sDeleteRoleProM", "sDeleteRolePERM", "sDeleteResourceProms"], "roleid": ["roleId", "roleoid", "relationId", "oleid", "oleoid", "roleids", "relationpid", " rolepid", "relationids", " roleoid", "resourceid", "oleinfo", "relationid", "roinfo", "roid", " roleId", "roname", "rooid", " rolename", " roleids", "rolepid", "resourcepid", "roleinfo", "resourceId", "rolename", "olename", "resourceids", " roleinfo"], "role_perm_collect": ["role_perm2Collect", "role_perm_draw", "role_perm_Collect", "role_perm_collection", "role_compl_collect", "role_permptdraw", "role_per_cont", "role_priv2coll", "role_priv2Collect", "role_per_coll", "role_permptcollect", "role_priv_collection", "role_compl_coll", "role_per_draw", "role_permptcont", "role_priv_Collect", "role_compl_ct", "role_perm_coll", "role_permptcoll", "role_perm_cont", "role_perm2collect", "role_perm2coll", "role_priv_coll", "role_priv2collection", "role_perm_ct", "role_priv2collect", "role_perm2collection", "role_per_collect", "role_priv_collect"], "cp": ["c", "ct", "priv", "tp", "ps", "px", "cd", "cfg", "ctx", " CP", "CP", "Conn", "core", "jp", "cs", "vp", "cc", "cmd", "proc", "cod", "cop", "mk", "cb", "pd", "rc", "ec", "mp", "p", "pkg", "wp", "fp", "con", "cn", "pc", "cm", "cap", "ch", "pp", "ctrl", "cr", "cmp", "cf", "lc"], "conn": ["sync", "dn", " ac", "t", "ctr", "org", "ann", "ctx", " cc", "comm", "ain", " con", "session", "cmd", "cert", "conv", "on", "conf", "con", "j", "act", "addr", "config", "g", "cf", "connect", " cx", "bind", "col", "ait", "trust", "ont", "cc", "out", "client", "gc", "open", "req", " cur", "wp", "gate", "local", "link", "die", "syn", "pg", "rn", "ca", "ct", "tp", "wd", "mt", "pas", "nt", "og", "resp", "p", "pkg", "cur", "mn", "yn", "cn", "sql", "dial", "gn", "call", "msg", "nc", "db", "c", "close", "enc", "cfg", "connection", "Conn", "ce", "pool", "dc", "jp", "dt", "ssl", "cb", "obj", "n", "mem", "handle", "co", "coll", "ch", "bo", "rel", "ns", "fn", "lang"], "rs": ["Rs", "ps", "sr", "rl", "re", "mr", "os", " ss", "cs", "ro", " res", "ds", "ls", "res", "ri", "rc", "RS", " ps", " ra", "ris", "rt", "rm", " cs", "s", "ts", "ns", " rc", " ls"], "pstmt": ["pstmd", "apStmb", "pconstmt", "prestmn", "pstdmb", "pstdmt", "Pstmt", "pctmd", "pstartmt", " pstatm", "pstmk", "pestMT", " prestmt", "pstatmk", "apstbl", " pstm", "pSTMT", "prestlt", "pstatecond", "prestmt", "pstatmn", "Pstmsg", "pstatemk", "postsql", "pstatcond", " pswemb", "pstbl", "pstymb", " pstemb", "pSTmt", " pstatmt", "pputcond", "pputmg", "pctMT", "pconstm", "pstart\t", " pStm", "pstatmb", "Pstmd", "pstartm", " pStmb", "Pstrs", "pstattr", "pstmsg", "pstatstat", "pstrmn", "PstatMT", " prestMT", " pswmt", "Pstlt", "pstdst", "pStst", "pstmn", " pStmt", "Pstatcond", " pswms", "pestm", "postmt", " psttr", "postm", "pctm", "Pstms", "Pstatrs", "pstatMT", "ptrysql", "pstat\t", "pswemb", " pststat", "pstatms", "pconstmb", "pStstat", "apStbl", "Pstat\t", "postmsg", "pstymt", "pstrrs", " pstmb", "pstremb", "pstatm", "Pstcond", "PstMT", "pputm", "pstms", "pstatem", "Pstatlt", "pputmk", "Pstmg", "pstrmt", "pstrmg", " pstMT", "pstm", "pstemb", "prest\t", "pStmt", "pstatemt", "postmd", "pstcond", "pstrmd", "pStbl", "pstyms", "Pstatmd", "pswmb", "pstatmg", "pswmt", "ptrymt", "Pstm", "pstrms", "pputrs", "pstrm", "pstst", " pstatmd", "apstmt", "pestmt", "apstmb", "pstatmt", "pst\t", "Pstatmt", "pstatst", "pSTtr", "ptrym", "Pstatsql", "apStmt", "postmn", " pstatmn", "pStm", "ptrymsg", "Pstatmsg", "pconststat", "pstatlt", "pstatrs", "Pstsql", "prestMT", " presttr", " pstmd", " pStstat", "pstMT", " prestmn", "pctms", " pswmb", "pstatmsg", "apstst", "Pstmk", "pstmb", "pstatmd", "pestms", "prestm", "presttr", "pstyemb", "Pstatm", "pstlt", "Pst\t", "pctmt", "pststat", "pstatbl", "Pstatmk", "pswms", "pstmg", " pstmn", "pstsql", "pstrmb", "pstartlt", "apStst", "Pstatms", " pstms", "pstatsql", "Pstatmg", "pstdbl", "psttr", "pputmt", "pStmb", "pSTmn", "pstrs"], "factory": [" facter", "tacter", "fictionary", "fFactory", "cfFactory", "Factory", "Facter", "Fictionary", " fictionary", "cfictionary", " fFactory", "foo", "Fade", "tade", "FFactory", "cfoo", "Foo", "tactory", "tFactory", "facter", " fade", "fade", "cfactory", " foo"], "op": [" act", " co", " oper", "oe", "operation", "Op", "oper", " operator", " ops", " opt", " ov", " ep", " Op", "ops", "p", " opp", "OP", "Operation", "o", " cop", " dop", " operate", " OP", " ip", " Operation", " pop", " operational", "iop"], "role_perm_ir": ["role_permmmi", "role_perm_et", "role_permobji", "role_perm_yr", "role_priv_ir", "role_perm_ier", "role_permobjir", "role_permmmir", "role_proc_iter", "role_proc_oi", "role_proc_ier", "role_permrenet", "role_perm_IR", "role_permmmoi", "role_priv_iter", "role_proc_yr", "role_perm_iter", "role_priv_i", "role_proc_i", "role_perm_oi", "role_priv_IR", "role_permrenier", "role_proc_ir", "role_permobjoi", "role_permmmyr", "role_perm_i", "role_permobjyr", "role_permreniter", "role_permrenir", "role_proc_et"], "rolePerm": [" rolePerp", "rolePerM", "rolePersmission", "roleParc", "olePerl", " roleParM", " rolePerM", "olePerperm", "roleParp", "rolePerg", " roleParm", "roleperm", "rolePERM", "oleParperm", "rolepermission", "rolePerperm", "oleParr", "roleElemn", "rolePersM", "rolePartperm", "olePerM", "roleElem", "rolePerr", "roleLikeg", "roleLikeM", "rolePERl", "rolePersm", "roleEleg", "rolePm", "rolePartg", "olePERg", "rolePERm", "oleParm", "olePermn", "roleParm", "rolePERg", "rolePermn", "rolePerl", "olePERl", "rolePartr", "rolePERperm", "roleLikem", "roleParr", "roleParg", "olePermission", "olePERM", "oleParg", "olePerr", " roleParc", " rolePerc", "rolePp", " roleParp", "rolePermission", "rolePERr", "rolePERmission", "roleLikemn", "roleperl", "rolePartm", "roleParperm", "olePerm", "rolePERmn", "roleEleM", "rolePERc", "rolePM", "rolePERp", "olePERmn", "rolePersl", "roleParM", "olePERmission", "rolePerp", "rolePc", "olePerg", "roleperM", "olePERm", "rolePerc"]}}
{"id1": "23402240", "id2": "18202328", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 0, "substitutes": {"actualizarNdivisiones": [" actualizarMisiones", " actualizarNdomers", " actualizarNisioners", " actualizarNdivisione", " actualizarNdivisionas", " actualizarNumenters", " actualizarNisione", " actualizarMisionas", " actualizarMdivisione", " actualizarNumentas", " actualizarMdivisiones", " actualizarNdomes", " actualizarNdomas", " actualizarMdivisionas", " actualizarNumente", " actualizarNisiones", " actualizarNdome", " actualizarMisione", " actualizarNdivisioners", " actualizarMdivisioners", " actualizarMisioners", " actualizarNisionas", " actualizarNumentes"], "idTorneo": ["idLTaneon", "idMorneos", "idTorneon", "idTorne", "idMornepo", "idMorne", "idMorneo", "idTornee", "idLTorneO", "idMornee", "idTanei", "idLTornei", "idTrono", "idTeroo", "idMornpo", "idToralon", "idTornei", "idTaneon", "idTronpo", "idMornos", "idTornpo", "idLTaneO", "idTeroi", "idLTanei", "idTaneo", "idTorali", "idTorneos", "idTronos", "idTorno", "idMorno", "idTaleo", "idTaleos", "idToralO", "idTaneO", "idTalee", "idTrone", "idTeroon", "idLTorneon", "idTornos", "idLTaneo", "idTeroO", "idTornepo", "idTorneO", "idTalepo", "idLTorneo", "idToralo"], "nDivisiones": ["nDivisione", "nDividee", "nDivitione", "nDecisione", "nDecisionals", "nDivisionals", "nDecionales", "ndivions", "nDivisionses", "ndiviones", "nDecisiones", "nDivitiones", "ndivisionales", "nDivionales", "nDecisionales", "nDivisions", "nDeciones", "nDivitionales", "ndivisiones", "nDivisionales", "nDivisionsales", "ndivisions", "nDecionals", "nDivisionss", "nDivisionse", "nDecione", "nDivione", "nDivideals", "nDivides", "ndivionales", "nDivions", "ndivisione", "nDivionals", "nDiviones", "nDivideales", "nDividees", "ndivione", "nDivitionals"], "intResult": ["intValue", "floatResult", "strReturn", "uintValue", "IntResult", "uintResult", "IntResults", " intresult", "intRes", "interReturn", "intResults", "strResult", " intResults", "intReturn", "interResults", "uintResults", "INTresult", "INTResult", "uintReturn", "floatResults", "IntRes", "strResults", "INTReturn", "intresult", "interResult", " intRes", "IntReturn", "strValue", "floatresult", " intValue", " intReturn", "floatReturn", "interRes", "INTResults"], "sql": ["qs", "sb", "dl", "SQL", "status", "spr", "sn", "inv", "nl", "select", "csv", "log", "sv", "sq", "expression", "ln", "scl", "string", "q", "cmd", "ls", "ql", "pel", "mail", "spec", "login", "params", "url", "description", "json", "template", "query", "seed", "pp", "sel", "table", "xml", "s", "sp", "sol", "fn", "db"], "connection": ["c", "location", "close", "conn", "po", "user", "server", "pool", "collection", "document", "relation", "computer", "handler", "statement", "session", "creator", "client", "pointer", "platform", "reference", "no", "application", "connected", "engine", "database", "open", "created", "communication", "command", "position", "description", "network", "channel", "directory", "number", "con", "Connection", "link", "response", "bo", "context", "condition", " Connection", "subject", "socket", "to", "page", "ion", "port", "function", "writer", "table", "resource", "current", "connect", "db", "nc", "system"], "ps": ["gs", "aps", "tp", "pse", "pn", "posts", "po", "pos", "mt", "eps", "pr", "jp", "cs", "pg", "pt", "statement", "ports", "cp", "proc", "ds", "res", "pd", "pps", "ptr", "mp", "p", "pe", "processor", "pb", "prep", "fp", "rs", "ping", "stats", "PS", "fps", "pp", "Ps", "ips", "s", "sp", "gres", "ts", "pers"]}}
{"id1": "646016", "id2": "21348951", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 0, "substitutes": {"elimina": ["ellimisa", "eligina", "elimisa", "elitisa", "allimisa", "alimisa", "elimino", "elitine", "eligino", "alimino", "alimina", "ellimine", "ellimino", "elimine", "ellimina", "allimino", "elitino", "elitina", "allimine", "allimina", "eligisa", "eligine", "alimine"], "cli": ["c", "dl", "li", "cl", "Cl", "cfg", "conn", " CLI", "multi", " cl", "ui", "l", "gui", "ln", "e", "cho", "console", "client", "cmd", "cgi", "idi", "clus", "grid", "uci", "aci", "util", "ci", "gil", "cu", "pi", "eric", "cci", "udi", "exe", "ctl", "GUI", "dial", "Client", "ctrl", "lu", "prot", "i", "coni", "lc", "coe"], "id": ["ip", "rid", "mid", "pid", "type", "status", "in", "ida", "sd", "uid", "md", "iden", "with", "wid", "vid", "e", " fid", "ident", "del", "did", "sid", "aid", "out", "hash", "is", "index", "no", "res", "ref", "ids", "mail", "end", "name", "ide", "start", "ID", "url", "f", "d", "info", "value", "num", "it", "rand", "oid", "null", "bid", "code", "h", "kid", "i", "ad", "db", "key", "Id", "and"], "sql": ["sb", "dl", "SQL", "ship", "sal", "details", "ps", "lex", "spr", "inv", "sd", "nl", "js", "html", "software", "sk", "csv", "services", "sv", "eps", "sq", "scl", "ln", "expression", "https", "string", "sys", "xs", "ds", "ssl", "security", "ls", "ql", "pel", "util", "mail", "sl", "lua", "spec", "format", "url", "pkg", "json", "query", " SQL", "wal", "ping", "lock", "ll", "sp", "owl", "ns", "pp", "socket", "shell", "xml", "msg", "s", "what", "sol", "fn", "db", "ips", "ms", "QL"], "stmt": [" stmm", "Stmn", "STmt", "STMT", "Stmt", "stmb", " stMT", "Stmm", "StMT", "stm", "strmb", "strmt", "scm", "Sttm", " stmb", "sctm", " sttm", "scmm", "STmn", "tmm", "Stmb", "tm", "stMT", "strMT", "STmm", "ttm", "sttm", " stmn", "strm", "tmt", "scmt", " stm", "STm", "Stm", "stmm", "stmn"]}}
{"id1": "17716716", "id2": "20208819", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"plainToMD": [" stringAsmd", " stringToDM", " stringAsMD", " convertToMC", " stringFromDM", " stringFrommd", " stringTomd", " convertToDM", " convertAsDM", " stringToMD", " convertTomd", " convertAsMD", " stringToMC", " convertAsMC", " stringAsDM", " stringAsMC", " convertToMD", " stringFromMC", " convertAsmd", " stringFromMD"], "loggerCol": ["logiderCol", "logggerCol", "logiderColumn", "loggerColl", "badinatorCol", " loggerCOL", "logGERCOL", "badgerCl", "logggerCl", "badinatorCl", "logggerColl", "loginatorColl", "badinatorCOL", " logggerCOL", "loggerColumn", "loginatorCol", "loggeCOL", "logggerCOL", " logggerCol", "badinatorColl", "loggeCol", " loggerColumn", "loggeColl", "badgerColl", "loggerCOL", "logiderCOL", "badgerCol", "logGERCol", " logggerColumn", "loginatorCl", "loginatorCOL", "logggerColumn", "logGERColumn", "loggerCl", "loggeCl", "badgerCOL"], "input": ["text", " inputs", "example", "request", "buffer", "in", "active", "str", "data", "base", "this", "raw", "file", "document", "image", "prefix", "result", "string", "q", "out", "pattern", "hash", " Input", "up", "command", "Input", "url", "hello", "value", "it", "context", "output", "from", "subject", "char", "initial", "config", "background", "source", "form"], "byteHash": ["ByteLength", "binaryHash", "byteshash", " byteMap", "binaryhash", "ByteHas", "Bytehash", "bytesHas", "binaryHas", "ueHash", "ueTr", "ByteMap", "ByteHash", " byteHas", "byteHas", " byteTr", "bytehash", "uehash", "ByteTr", "byteTr", " bytehash", "ueLength", "byteMap", "bytesHash", " byteLength", "bytesMap", "byteLength"], "md": ["pm", " Md", "bd", "MD", "ct", "det", "cd", "med", "gr", "dr", "ng", "sd", "sm", "sam", "mt", "ind", "mod", "add", "dd", "hd", "mc", "dig", "cmd", "ds", "df", "mk", " mc", "mb", "dm", "mo", "nd", "mac", "ms", "cond", "de", "pd", "material", " MD", "grad", "mg", "mp", "d", "comp", "der", "di", "ld", "rm", "mn", "od", "hash", "met", "gm", "m", "doc", "msg", "red", "mm", "ded", "def"], "md5result": ["MD5response", "md45comment", "md65Result", "MD2comment", "md5Result", "md7string", "md5response", "md3result", " md5Result", "md8Result", "md8proc", "MD5result", "md64comment", "md5results", "md5comment", "md7result", "md5message", "MD2string", "md2result", "md3string", "md8result", "md2response", "md3message", "md7results", "md45response", "md65result", "md3proc", " md5message", " md5proc", "md8message", "md64response", " md8proc", "md3results", "MD5results", " md8Result", "md2comment", "md2Result", "MD2result", "md5proc", "MD5Result", "md45result", "md2results", "md65message", " md8result", "md3Result", "md45results", "MD2results", "md2string", "md7Result", " md8message", "md64results", "MD5comment", "md5string", "MD5string", "MD2Result", "md64result", "MD2response", "md65proc"], "i": ["ip", "c", "li", "y", "io", "v", "span", "bi", "in", "ii", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "mi", "l", "b", "gu", "gi", "uri", "im", "iter", "q", "cli", "x", "is", "ti", "ie", "index", "ci", "pi", "ji", "a", "n", "me", "qi", "si", "init", "ix", "di", "ims", "ei", "o", "it", "sim", "j", "my", "\u0438", "m", "z", "ai", "fi", "us", "ic"]}}
{"id1": "596993", "id2": "8024375", "code1": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"makeLoginRequest": ["makeSubmitRequest", "makeSubmitMessage", " makeFacebookRequest", "makeLoginMessage", "makeSubmitPost", " makeLoginResponse", "makeSubmitResponse", "makeFacebookMessage", "makeLoginPost", " makeLoginMessage", "makeloginPost", " makeLoginPost", "makeFacebookRequest", "makeFacebookPost", "makeLoginResponse", " makeFacebookResponse", " makeFacebookMessage", " makeFacebookPost", "makeFacebookResponse", "makeloginResponse", "makeloginRequest", "makeloginMessage"], "url": ["dl", "cl", "location", "build", "ul", "k", "re", "nl", "str", "base", "el", "file", "l", "b", "web", "uri", "https", "string", "r", "ssl", "browser", "path", "ls", "open", "job", "ref", "sl", "address", "name", "bel", "un", "ur", "http", "ll", "abs", "URL", "char", "call", "Url"], "urlConnection": [" urlConn", "urlSession", " urlSession", "UrlSession", "sslConnect", "mountClient", "Urlconnection", "urlLink", "urlconnection", "handleConnect", "logConnection", "httpconnection", "loadConn", "loadConnection", "urlConn", "sslStream", "httpLink", "UrlLink", "handleConn", "fileSession", "urlPort", "urlConnect", "fileconnection", "nlLink", "xmlConnection", "consoleConnection", "consoleConn", "browserClient", "loadConnect", "fileConnection", "urlClient", "sslConn", "sslSession", " urlInstance", "httpSession", "handleStream", "loadInstance", "httpConnection", "mountSession", "mountConn", "browserConn", "httpConnect", "consoleSession", "UrlConn", "handleConnection", "httpConn", "logConnect", "xmlPort", "sslPort", "nlConnection", "httpStream", "sslTree", "xmlConnector", " urlConnect", "nlConnect", "logConn", "sslconnection", "consoleConnect", "nlconnection", " urlConnector", "urlStream", "urlConnector", "UrlConnect", "UrlConnection", "sslConnection", "mountconnection", "xmlTree", " urlconnection", "logLink", "sslConnector", "urlTree", " urlPort", "mountConnection", "browserConnection", "UrlInstance", "browserInstance", "browserconnection", " urlTree", "mountConnect", "browserConnect", "fileConnect", " urlClient", "urlInstance"], "content": ["version", "text", "object", "example", "license", "create", "any", "conn", "data", "core", "comment", "raw", "document", "image", "const", "trust", "expression", "continue", "language", "action", "lead", "body", "cmd", "pattern", "mask", "Content", "comments", "cache", "address", "reason", "activity", "metadata", "title", "command", "format", "handle", "script", "layout", "media", "names", "description", "contact", "network", "properties", "search", "json", "template", "value", "control", "size", "cm", "sequence", "context", "message", "settings", "values", "output", "subject", "report", "ontent", "label", "config", "code", "xml", "function", "filter", "node", "cont", "current", "form", "summary"], "outputStream": [" outputstream", " outputBlock", " outputStreamer", "OutputStyle", "outputStreamer", "OutputSteam", "outputstream", "networkSteam", "OutputView", "outputBlock", "inputStyle", "OutputStream", "outputSteam", " outputView", "outputView", "OutputStreamer", "networkStreamer", "OutputForm", "outputForm", "inputBlock", " outputStyle", "OutputBlock", "Outputstream", "inputView", " outputForm", "networkstream", " outputSteam", "inputForm", "networkStream", "inputSteam", "outputStyle"], "responseCode": ["statusType", "statusCount", "sequenceType", " responseChoice", "statusCode", "ResponseCode", "sequenceCode", "responseStatus", "usageCode", "ResponseType", " responseCategory", "usageChoice", "statusStatus", "responseCategory", "ResponseChoice", "responseType", "sequenceCount", "usageCategory", "ResponseCount", "usageCount", "ResponseCategory", "responseChoice", "responseCount", " responseCount", "ResponseStatus", "sequenceStatus"], "inputStream": ["thisStreamer", "errorSteam", "errorForm", "fileQueue", "viewStream", "InputSteam", "actStyle", "inputStyle", "outputSteam", " inputThread", "outputView", " inputStyle", "inputStreamer", "fileStream", "thisSteam", "errorView", " inputQueue", "viewSteam", " inputView", "outputForm", "actStream", "fileSteam", " inputStreamer", "viewView", "actView", "inputView", " inputSteam", "inputThread", "actSteam", "InputStream", "InputView", "fileStreamer", "viewThread", "inputQueue", "inputForm", "thisStream", "InputForm", "inputSteam", "outputThread", "outputStyle", "errorStream", "thisQueue"]}}
{"id1": "17161805", "id2": "18164929", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"encode": ["enscode", "enccode", "enode", "ensode", "encprocess", "unforce", "Encode", "enforce", "ensprocess", "unode", "enprocess", "uncode", "unprocess", "encforce", "ensforce", "Enode", "Enforce"], "plaintext": ["pronth", " plainText", "formtext", "prontext", "plainlat", "aintext", "mainth", "maintext", " plaindata", "plaindata", "plainth", "formmessage", "ainText", "mainlat", " plainlat", "pronlat", "ainmessage", " plainmessage", "formText", " plainth", "formdata", "pronText", "aindata", "mainText", "plainmessage", "plainText"], "md": ["pm", " Md", "managed", "MD", "bd", "dh", "pdf", "det", "cd", "med", "dr", "ng", "sd", "sm", "mand", "mt", "ind", "mod", "add", "dd", "hd", "mc", "sha", "del", "cmd", "df", "mk", "mb", "dm", "mo", "amd", "pd", "nt", " MD", "grad", "mp", "d", "der", "ld", "mn", "od", "m", "red", "msg", "mm", "mg", "ms"], "raw": ["read", "stable", "rendered", "serial", "bound", "strip", "derived", "des", "unknown", "full", " RAW", "inner", "hex", "bare", "cmd", "input", "RAW", " Raw", "aw", "pack", "cooked", "map", "n", "orig", "mem", "buf", "custom", "json", "value", "row", "unsigned", "wrap", "message", "valid", "bytes", "modified", "sh", "clean", "Raw", "def"]}}
{"id1": "21092340", "id2": "2022160", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToZipZip", "addToZipive", "addInArchiver", "addToHarFile", "addToZipiver", "addInHarZip", "addToExiver", "addToArchiver", "addToZipFile", "addToHarZip", "addInArchZip", "addToArchZip", "addInArchFile", "addToHarive", "addToHariver", "addToExive", "addInHarFile", "addToArchFile", "addToExFile", "addInArchive", "addToExZip", "addInHariver", "addInHarive"], "pod": ["ack", "zone", "top", "point", "volume", "pad", "pick", "archive", "disk", "component", "poll", "post", "body", "cp", "proc", "check", "device", "job", "pack", "policy", "spec", "op", "start", "project", "p", "pkg", "wp", "module", "od", "pc", "Pod", "message", "report", "task", "table", "ad", "ods"], "podArchiveOutputStream": ["podArchiveInputPoint", "podArchiveEntrySteam", "podArchiverOutputSync", "podArchiveMainStreamer", "podArchiverOutputForm", "podArchiveEntryStream", "podArchiveResourcestream", "podArchiveOutputPoint", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveInputStreamer", "podArchiveMainStream", "podArchiveOUStream", "podArchiveOutPoint", "podArchiveInputContext", "podArchiveOutputstream", "podArchiveInputSteam", "podArchiveMainForm", "podArchiveInputstream", "podArchiveOutStream", "podArchiverOutputStream", "podArchiveOutputStreamer", "podArchiveResourceSteam", "podArchiveStreamStream", "podArchiveOUSync", "podArchiverInputStream", "podArchiverInputPoint", "podArchiveoutputForm", "podArchiveOutContext", "podArchiveOUMap", "podArchiveoutputSteam", "podArchiveInputForm", "podArchiverOutputSteam", "podArchiverOutputStreamer", "podArchiverInputMap", "podArchiveMainSteam", "podArchiverInputStreamer", "podArchiveStreamForm", "podArchiveOUForm", "podArchiveOutputSync", "podArchiverInputstream", "podArchiveOutstream", "podArchiveResourceContext", "podArchiveInputMap", "podArchiverInputSteam", "podArchiverInputContext", "podArchiverInputSync", "podArchiverOutputContext", "podArchiveStreamMap", "podArchiveOutputContext", "podArchiveStreamSync", "podArchiverInputForm", "podArchiveEntryPoint", "podArchiveResourceStream", "podArchiveOutputForm", "podArchiverOutputstream", "podArchiveoutputStreamer", "podArchiveInputSync", "podArchiveOutputSteam", "podArchiveInputStream", "podArchiveoutputStream", "podArchiveOutSteam", "podArchiverOutputPoint"], "filename": ["version", "println", "jpg", "location", "binary", "key", "release", "fil", "archive", "FILE", "upload", "file", "ame", "username", "original", "prefix", "nil", "uri", "string", "png", "path", "family", "FN", "title", "name", "stem", "url", "NAME", "p", "folder", "description", "names", "directory", "fp", "kl", "Filename", "message", "output", "subject", "latest", "nm", "resource", "ename", "fn", "txt"], "source": ["copy", "src", "view", "stream", "select", "file", "series", "inner", "image", "component", "loader", "body", "proc", "SOURCE", "input", "ource", "address", "spec", "start", "Source", "password", "get", "supp", "use", "info", "service", "template", "force", "sample", "sequence", "context", "sql", "from", "store", "style", "shell", "resource", "seed", "ser", "iterator"], "entry": ["tmp", "ry", "or", "se", "data", "connection", "book", "comment", "archive", "attribute", "ce", "file", "log", "quick", "card", "component", "cell", "ent", "word", "ie", "line", "job", "obj", "enter", "nt", "ace", "Entry", "element", "channel", "row", "query", "record", "link", "cue", "char", "sheet", "task", "resource", "zip", "good", "ment", "key", "set", "system"]}}
{"id1": "20247400", "id2": "12766377", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "label": 0, "substitutes": {"in": ["io", "bin", "din", " din", "inc", "isin", "rin", "ind", "file", "inner", "ze", "inf", "is", "input", "check", "up", "In", "on", "gin", "init", "info", "IN", "net", "con", "it", "from", "ins", "inn", "cin", "ai", "i", "source", "and"], "out": ["t", "println", "io", "exit", "write", "or", "str", "ne", "os", "auto", "OU", "log", "print", "b", "ln", "dir", "at", "sys", "gt", "r", "cmd", "oss", "line", "client", "ot", "check", "err", "obj", "screen", "name", "n", "list", "o", "net", "con", "outs", "w", "it", "output", "Out", "we", "report", "null", "ins", "ex", "to", "msg", "writer", "ou", "OUT", "outer", "other"], "buffer": ["history", "Buffer", "binary", "memory", "se", "view", "stack", "data", "buff", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "b", "component", "temp", "trace", "result", "iter", "source", "flush", "bar", "size", "queue", "limit", "pause", "shape", "library", "index", "cache", "database", "address", "variable", "command", "position", "buf", "clear", "processor", "match", "channel", "template", "event", "sample", "block", "sequence", "output", "message", "display", "append", "table", "function", "filter", "bridge", "window", "db", "key", "header"]}}
{"id1": "20623709", "id2": "17729554", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"split": ["sync", "scan", "parse", "scale", "count", "unit", "read", "write", "copy", "align", "part", "Split", "upload", "transfer", "disk", "batch", "join", "open", "slice", "map", "format", "use", "lock", "append", "seek", "process", "share"], "targetDirectory": ["targetDirect", "testLocation", "Targetdirectory", "testDirect", "TargetFolder", "baseFile", "localDirectory", " targetFolder", "baseFolder", "baseDirectory", "targetMemory", " targetMemory", " targetLocation", "localDir", "targetDir", "targetLocation", "TargetMemory", "TargetLocation", "baseDir", "localFile", "basedirectory", " targetDir", "TargetDirect", " targetDirect", "testDirectory", " targetdirectory", " targetFile", "baseDirect", "targetFolder", "testDir", "baseMemory", "TargetDirectory", "targetdirectory", "targetFile", "localdirectory", "TargetDir"], "prefix": ["version", "pres", "padding", "type", "status", "fixed", "fixes", "Pref", "base", "this", " suffix", "username", "uri", "localhost", "pattern", "path", "division", "index", "zero", "alias", "pi", "title", "name", "format", "command", "PRE", "password", "root", "p", "pkg", "fix", "ix", "directory", "template", "FIX", "tag", "size", "pre", "filename", "key"], "maxUnitBases": ["maxUnitLases", "maxUnitChases", "maxUnitReplounds", "maxUnitLicas", "maxUnitChias", "maxUnitbases", "maxUnitReplages", "maxUnitBades", "maxUnityBases", "maxUnitChades", "maxUnitBias", "maxUnitAliias", "maxUnityBounds", "maxUnitLounds", "maxUnitAliounds", "maxUnityBages", "maxUnitChages", "maxUnitAliases", "maxUnityLases", "maxUnityAliias", "maxUnitChicas", "maxUnitBicas", "maxUnityLicas", "maxUnityAliades", "maxUnityBicas", "maxUnitbades", "maxUnitbounds", "maxUnitBounds", "maxUnityAliases", "maxUnitLages", "maxUnitbias", "maxUnityLages", "maxUnitBages", "maxUnitReplicas", "maxUnitReplases", "maxUnityBias", "maxUnityLounds", "maxUnitChounds", "maxUnityBades", "maxUnitAliades", "maxUnityAliounds"], "maxUnitEntries": ["maxUnitIntegriers", "maxUnitIntegries", "maxUnitentires", "maxUnitentrys", "maxUnitEntires", "maxUnityentries", "maxUnitEntryrys", "maxUnitEntriers", "maxUnitEntryriers", "maxUnitErires", "maxUnityEntries", "maxUnitEntrs", "maxUnitEntrys", "maxUnityEntrs", "maxUnitentries", "maxunitEntries", "maxunitEntires", "maxunitEntrys", "maxUnityentrys", "maxUnityEntires", "maxUnitEntryires", "maxUnityEntrys", "maxunitEntrs", "maxUnitIntegires", "maxUnitErrys", "maxUnitentrs", "maxUnitErries", "maxUnityentires", "maxUnityentrs", "maxUnitEntryries", "maxUnitErrs", "maxUnitIntegrys"], "fis": [" fi", "fiss", "vic", "Fic", "viss", "Fci", "ific", "fic", " fiss", "fii", "ifci", "Fii", "vi", " fic", " fii", "ifii", "Fiss", "vis", "Fis", "ifis", "fi", "Fi"], "fci": [" fini", " fai", "Fic", " fcu", "mii", "Fco", "mcu", "cfini", "fai", "Fci", "fic", "tcu", "fico", "tci", "tco", "Fini", "fii", " fico", "mco", "Fai", "fini", " fic", " fii", "cfai", "cfis", "fcu", "mci", "Fis", "tii", "cfico", "cfco", "cfic", "Fico", "cfci"], "fos": [" fbos", "Faos", "Foss", "flOS", "FOS", "wios", "yos", "fios", "wbos", "ybos", " fOS", "yaos", " foss", "foss", "flaos", "yios", "faos", "Fos", " fios", "fOS", "flos", "floss", "waos", " faos", "fbos", "wos"], "fco": ["fdo", "Fcon", " fdo", "tdo", "cco", " fcos", "Fco", "pco", "pso", "cdo", "Fcos", "Fci", "pci", "Fdo", "fcon", "ccon", "tco", "cso", "tcos", "toco", " fso", " fcon", "Foco", "foco", "fcos", "pcos", " foco", "Fso", "fso"], "buffer": ["Buffer", "binary", "memory", "padding", "read", "stack", "black", "data", "buff", "order", "length", "comment", "batch", "document", "phrase", "print", "complete", "temp", "result", "flush", "iter", "button", "queue", "limit", "pause", "library", "index", "cache", "database", "address", "command", "note", "position", "buf", "timeout", "match", "channel", "row", "template", "event", "record", "sample", "block", "sequence", "message", "append", "char", "entry", "reset", "holder", "callback", "table", "function", "filter", "bridge", "window", "source"], "currentBasesCount": ["currentbaseLength", "currentBasesLength", "currentBasesCode", "currentBaseCode", "currentbasesCode", "currentBadesLength", "currentBadesCode", "currentbaseCount", "currentBasedLength", "currentBasedCount", "currentbasesLength", "currentbaseCode", "currentBaseCount", "currentBadesCount", "currentBasedCode", "currentBaseLength", "currentbasesCount"], "currentEntriesCount": ["currentEntrsCode", "currentEntriesCode", "currentEntrsFlag", "currentEntiesCode", "currentEntrysCount", "currentEntiesCount", "currentEntrysFlag", "currentEntrsCount", "currentEntrysCode", "currentEntriesFlag", "currentEntiesFlag"], "targetCount": ["argetAmount", " targetInfo", "TargetInfo", "TargetNum", "argetCount", "TargetCount", "targetAmount", "argetNum", "targetNum", " targetAmount", "TargetAmount", " targetNum", "argetInfo", "targetInfo"], "fastaChannel": [" fastoChannel", "fastoChan", "fastaQueue", "fastityChannel", "fastoChannel", " fastaStream", "fastaChan", "fastaConnection", "fastityStream", "fastpaChannel", "fastaiChan", "fastaiQueue", " fastaButton", "fastityChan", " fastaConnection", " fastaProvider", "fastaiStream", "fastoButton", "fastaStream", "fastaProvider", "fastaiChannel", " fastaQueue", "fastityQueue", " fastoQueue", "fastoQueue", "fastpaProvider", "fastoProvider", " fastaChan", " fastoChan", "fastaButton", "fastpaConnection", "fastpaButton", "fastoConnection", "fastoStream", " fastoStream"], "totalSeqCount": ["totalSeqCode", "totalSeqsSize", "totalSeqsCode", "totalSeQCount", "totalSegCounter", "totalSeQSize", "totalSegCode", "totalSegSize", "totalSeqsCount", "totalSeqSize", "totalSeqsCounter", "totalSeqCounter", "totalSeQCounter", "totalSegCount", "totalSeQCode"], "totalResiduesCount": ["totalResIdueFlag", "totalResidueFlag", "totalResIduesFlag", "totalResidusFlag", "totalResidusCount", "totalResidueCount", "totalResIdueCode", "totalResiduationsCode", "totalResidusCode", "totalResiduesCode", "totalResiduesFlag", "totalResiduationsCount", "totalResIduesCode", "totalResIdueCount", "totalResIduesCount", "totalResiduationsFlag", "totalResidueCode"], "prevTime": [" previousTime", " previousT", "prevT", " prevThread", "prevThread", " previousThread", "parT", "parTime", "parThread", " prevT"], "fastaFileSize": ["fastaFilesName", "fastoFileSize", "fastaChainSIZE", "fastaReaderLength", "fastaChainOwner", "fastaTableSIZE", "fastaTableSize", "fastaFileHeight", "fastoFileLength", "fastATableHeight", "fastATableSize", "fastaReaderName", "fastaFileName", "fastAFileSize", "fastaTableLength", "fastoTableLength", "fastoTableOwner", "fastafileLength", "fastafileSize", "fastoFileSIZE", "fastAFileHeight", "fastATableLength", "fastoTableSize", "fastafileOwner", "fastoFileOwner", "fastATableName", "fastaTableName", "fastAFileLength", "fastaFilesHeight", "fastaTableOwner", "fastaFilesLength", "fastaReaderHeight", "fastafileSIZE", "fastaTableHeight", "fastaFileLength", "fastaReaderSize", "fastAFileName", "fastaFileOwner", "fastaChainSize", "fastaFilesSize", "fastoTableSIZE", "fastaChainLength", "fastaFileSIZE"], "fastaFileReadOffset": ["fastaFileWriteLength", "fastaFilesReadLength", "fastaPageReadOrder", "fastaFileInputLocation", "fastaChainReadOffset", "fastaFileReadLength", "fastaFileWriteOrder", "fastaFileWriteAmount", "fastaPageLoadOffset", "fastaFileWriteOffset", "fastaFilereadPos", "fastaFileReadPos", "fastaFileInputLength", "fastaFileCurrentLocation", "fastaFileCurrentPosition", "fastaFileInputoffset", "fastaFileInputAmount", "fastaFilereadAmount", "fastaFileReaderOffset", "fastaChainCurrentLocation", "fastaChainCurrentOffset", "fastaFileInputOffset", "fastaFileReadLocation", "fastaPageLoadOrder", "fastaFileReadOrder", "fastaFileReadoffset", "fastaFileViewOrder", "fastaChainReadLocation", "fastaFileCurrentoffset", "fastaPageReadAmount", "fastaFileViewAmount", "fastaFileReadAmount", "fastaFilesReadOffset", "fastaFileViewOffset", "fastaFileLoadAmount", "fastaFilesLoadLength", "fastaChainReadoffset", "fastaFilereadOffset", "fastaFilesReadAmount", "fastaFileInputOrder", "fastaFilesLoadOffset", "fastaChainReadPosition", "fastaFileReaderPosition", "fastaFilesReadOrder", "fastaFileReaderLocation", "fastaFileInputPosition", "fastaFileLoadPos", "fastaPageLoadAmount", "fastaFileLoadOrder", "fastaFileLoadOffset", "fastaFilesLoadOrder", "fastaFilereadOrder", "fastaFileReaderoffset", "fastaFileLoadLength", "fastaFileReadPosition", "fastaChainCurrentPosition", "fastaFileViewPos", "fastaPageReadOffset", "fastaChainCurrentoffset", "fastaFilesLoadAmount", "fastaPageReadPos", "fastaFileCurrentOffset", "fastaPageLoadPos"], "partitionStartOffset": ["partitonStartOff", "partitionDataOff", "partitonStartPoint", "partitonStartPosition", "partitionEndPosition", "partitonStartingPosition", "partitionEndPoint", "partitonStartingOffset", "partitonStartingPoint", "partitionStartingOffset", "partitionStartingPoint", "partitionStartPosition", "partitionStartOff", "partitonStartOffset", "partitionDataPoint", "partitionDataOffset", "partitonStartingOff", "partitionEndOff", "partitionStartingOff", "partitionStartPoint", "partitionDataPosition", "partitionStartingPosition"], "bufferSize": [" bufferSIZE", "sequenceSIZE", "bufCode", " bufferCode", "buffSize", "bufferCode", " bufferLength", "BufferSize", "BufferName", "tableName", "sequenceCode", "sequenceLength", "BufferLength", "bufSIZE", "buffSIZE", "buffName", "bufferSIZE", "sequenceSize", "BufferSIZE", "tableSIZE", "bufSize", "bufferLength", "buffLength", "bufferName", "bufLength", "tableSize", "tableLength"], "fastaBuffer": ["fastasBuffer", " fastaBuff", "fastmaBuilder", "fastanBuff", " fastaCache", " fastoBuffer", "fastcaBuffer", "fastcaRequest", "wildaBuffer", "fastoStore", "fastanBuffer", "fastuBuff", "fasteBuffer", "fastsaBuffer", "FastmaStore", "fastmaBuff", "fastcaBuff", "wildaBuff", "FastaStore", "wildanRequest", "fastasBuilder", "fasteDB", "fastalBuffer", "fastaQueue", " fastoCounter", "fastcaCache", " fastoBuff", "fastaDB", "fastasBuff", " fastaMemory", "fastmaStore", "fasteMemory", "fastoCounter", "FastmaBuff", "wildanBuffer", "fastasStore", " fastaCounter", "fastaMemory", "fastsaChannel", "fastoQueue", " fastaBuilder", "fastoRequest", "fastasCounter", "FastmaBuffer", "wildanCache", "fastmaChannel", "fastalQueue", "fastaBuilder", "fastaBuff", "fastuDB", "fastasRequest", "FastaBuff", "fastuMemory", "fastmaQueue", "fastasCache", "fastoBuff", "fastsaQueue", "FastmaRequest", "fastanCache", "wildaCache", "fastmaCache", "fasteBuff", "fastalCounter", "FastaBuffer", "fastuBuffer", "fastasQueue", "fastalBuff", "fastaCache", "fastoBuffer", "FastaRequest", "wildanBuff", "fastanRequest", "fastmaRequest", "fastaCounter", " fastaDB", " fastaQueue", " fastoQueue", "fastsaBuff", "fastmaBuffer", "fastaRequest", "fastaStore", "wildaRequest"], "fastaReadState": ["fastaLoadType", "fastaReadSTATE", "fastaReaderState", "fastaReaderStatus", "fastaCurrentState", "fastaLoadState", "fastaReaderSTATE", "fastaLoadSTATE", "fastaCurrentType", "fastoReaderState", "fastaLoadStatus", "fastaCurrentSTATE", "fastoReadType", "fastoReaderStatus", "fastoReadState", "fastoReadSTATE", "fastoReadStatus", "fastaReadType", "fastaCurrentStatus", "fastoReaderSTATE", "fastaReaderType", "fastoReaderType", "fastaReadStatus"], "nBytes": ["numBytes", "numBlocks", "NKeys", "nrKeys", "noBytes", "nsParts", "nNs", "numNs", "nWords", " nWords", " nNs", "nBlocks", " nbytes", "NItems", " nParts", "nItems", "Nbytes", "nsWords", "nKeys", "noNs", "NBytes", " nKeys", "nsbytes", "nbytes", "nrbytes", "numbytes", "nobytes", "noBlocks", "nsBytes", "nrBytes", "nParts", " nItems", " nBlocks", "NWords", "nrItems", "NParts"]}}
{"id1": "6963063", "id2": "20602651", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 0, "substitutes": {"mas": ["tis", "vers", "mails", "dal", "pres", "ums", "ias", "mon", "mos", "ists", "aus", "bs", "mad", "phis", "als", "ales", "vs", "bas", "mus", "lists", "phas", "sa", "marks", "alis", "pas", "rums", "mers", "as", "las", "ams", "Mas", "finals", "oos", "cas", "asis", "masters", "stal", "sels", "mont", "ints", "ma", "mast", "ris", "amas", "eas", "ims", "jas", "mons", "mis", "men", "sts", "wal", "asks", "nets", "makes", "MAS", "mares", "stro", "lands", "boxes", "mes", "pse", "ras", "ares", "ames", "aos", "rices", "ms"], "sort": ["save", "scale", "tmp", "trans", "min", "score", "status", "default", "lib", "sup", "order", "lower", "Sort", "ind", "pos", "test", "rol", "l", "orting", "orter", "su", "dir", "ist", "ORT", "orts", "tr", "index", "orted", "start", "late", "weight", "send", "use", "search", "ord", "rm", "val", "first", "lock", "rank", "desc", "it", "sum", "ort", "label", "store", "alpha", "port", "cmp", "s", "share", "alt"], "j": ["jj", "ja", "fr", "J", "v", "aj", "k", "js", "nr", "ind", "jc", "pr", "jp", "oj", "im", "at", "ge", "q", "x", "is", "ie", "jump", "br", "job", "obj", "ji", "ij", "n", "jit", "ia", "json", "jas", "uj", "bj", "lock", "jl", "it", "jo", "z", "m", "adj", "g", "dj", "kj", "other"], "i": ["li", "bi", "ii", "xi", "I", "gu", "iter", "origin", "hi", "cli", "ami", "is", "wi", "ni", "init", "ini", "ei", "sim", "ir", "g", "zi", "iti", "ic", "io", "in", "multi", "ki", "pi", "ij", "iri", "ia", "qi", "di", "ret", "ori", "fire", "status", "asi", "id", "mi", "gi", "uri", "ie", "iso", "iii", "ji", "iq", "me", "si", "ix", "info", "php", "it", "yi", "ish", "fi", "ip", "iy", "phi", "ui", "ind", "iu", "oi", "im", "ti", "ci", "chain", "\u0438", "m", "ai", "port", "ri"]}}
{"id1": "14820302", "id2": "17901739", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"innerProcess": [" inlineWork", "internalHandle", " innerWork", "internalProcess", " doProcess", "internalWork", " innerRun", " inlineHandle", " doRun", " doHandle", " doWork", " inlineProcess", " inlineRun", " innerHandle", "internalRun"], "curi": ["rcui", "Cri", "ctURI", "lcURI", "ctri", "pcumi", "vcuri", "cpurl", "ccuri", "mcri", " cris", "Curl", "ciri", "lciri", " cdu", " cpu", "contdu", "rcdu", "rcuri", "pcdu", "pcuri", "vcumi", " citi", "cpiri", "citi", "gcui", "Ciri", "mcuri", "lcri", " curl", "mciti", "cpuri", " cui", "contumi", "ccui", " cumi", "vcui", "mcURI", "contpu", "cpri", "cri", "ctiti", "gcuri", "CURI", "pcpu", "conturi", "cdu", " ciri", "Curi", "ccris", "cpu", "cturi", "ccumi", "cris", "lcuri", "rcumi", "cURI", "gcdu", " cURI", "curl", "cumi", "cui", "vcris", " cri", "gcumi"], "regexpr": ["Regexpr", "Regexp", "frentaxPR", "revreexpr", "revrepr", "reveloppr", "reroxpr", "fregexpr", "cregexexpr", "frentaxexpr", "rentaxpre", "reactp", "cregexpr", "reactpr", "regexp", "fregexexpr", "remaPR", "cregexp", "revelopexpr", "regexpre", "reroxp", "reactfr", "cregexPr", "reroxfr", "revrep", "regexPr", "rentaxexpr", "regexfr", "frentaxpr", "rentaxpr", "reacep", "regexexpr", "reacePr", "Regexfr", "frentaxpre", "fregexpre", "regexPR", "remapre", "remaexpr", "reveloppre", "revrePr", "Regexexpr", "reaceexpr", "rentaxPR", "revelopPR", "reroxexpr", "fregexPR", "remapr", "reactexpr", "reacepr"], "cs": ["qs", "gs", "c", "ctr", "ss", "cer", "ps", "cd", "sc", "ctx", "bs", "ats", "hs", "js", "vs", "cks", "csv", "CS", "cus", "tc", "ck", "mc", "ks", "cc", "cp", "acs", "ces", "ics", "ls", "gc", "cons", "cas", "res", "Cs", "rc", "ws", "aches", "caps", "fs", "acts", "rs", "sts", "cn", "wcs", "pc", "css", "fc", "cms", "cos", "ts", "nc", "ns", "cf", "ms"], "digest": ["displayse", "signist", "digse", "columnum", " digEST", "Diger", " digester", "hashest", "signested", "hashse", " digse", "columnest", "dest", "digester", "mixse", " digested", "displayer", "diger", "hashEST", "displayester", "digEST", "digested", "columnist", "DigEST", "mixist", "Digist", "signse", "displayEST", "dse", "der", "dist", "displayest", "mixested", " digist", "Digest", " diger", "digist", "Digester", "hashester", " digum", "Digested", "signest", "displayested", "mixest", "Digum", "digum", "Digse"], "s": ["qs", "gs", "c", "t", "sb", "ss", "ps", "es", "bs", "less", "ats", "hs", "js", "str", "space", "sam", "services", "sv", "eps", "gets", "sq", "b", "has", "e", "https", "ds", "prints", "is", "ls", "ws", "n", "its", "p", "fs", "ims", "rs", "S", "sts", "reads", "abs", "sql", "bytes", "ins", "h", "ts", "sol", "ns", "ms"], "m": ["managed", "t", "v", "mr", "sm", "md", "mt", "om", "l", "esm", "b", "mc", "dm", "mo", "mac", "vm", "tm", "n", "mem", "me", "p", "M", "f", "d", "ma", "perm", "rm", "em", " M", "cm", "met", "gm", "nm", "mu", "mm", "i", "ms"], "newDigestValue": ["newDigestedData", "newDigistValue", "newdigestV", "newdigestedValue", "newDigestedValue", "newDigistVal", "newDigseData", "newDigumentValue", "newdigestedVal", "newDigistData", "newdigistData", "newdigestValues", "newDigseValue", "newDigseVal", "newdigestData", "newDigestV", "newdigistVal", "newDigestedValues", "newDigseV", "newdigistValue", "newDigestData", "newDigumentV", "newDigestVal", "newDigumentValues", "newDigseValues", "newDigestedV", "newDigumentVal", "newDigestValues", "newdigestVal", "newDigestedVal", "newdigestedValues", "newdigestedV", "newdigestValue"]}}
{"id1": "5951610", "id2": "350482", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"testNetworkHTTP": ["testApplicationHTML", "TestNetURL", "testNetworkURL", "TestNetHTML", "testApplicationURL", "testNetHTML", "testNetURL", "testNetHTTP", "testApplicationHTTP", "TestNetworkHTTP", "TestNetworkURL", "TestNetworkHTML", "testNetworkHTML", "TestNetHTTP"], "url": ["lb", "t", "dl", "ml", "cl", "ocl", "location", "org", "blog", "ul", "lt", "conn", "rl", "acl", "nl", "mount", "str", "back", "base", "html", "u", "host", "el", "log", "loc", "lr", "print", "l", "b", "norm", "web", "gl", "https", "il", "uri", "console", "r", "ssl", "cert", "impl", "path", "ls", "www", "util", "mail", "ref", "sl", "address", "email", "term", "bl", "obj", "ur", "get", "pl", "github", "http", "all", "channel", "hl", "ll", "link", "rel", "ret", "URL", "fl", "m", "resource", "Url", "pull"], "urlConnection": ["dbConnect", " urlConn", "httpConnector", "utilSet", "sslConnect", "urlMachine", " urlListener", "railHandler", "methodConnection", "urlConn", " urlInfo", "httpHandler", "implConn", "fileDiscussion", "managerInfo", "methodConnect", " urlDiscussion", "emailConnection", "implConnection", "fileConn", " urlPosition", "implConnector", "urlConnect", "railListener", "browserConnector", "nameConnector", "consoleConnection", "urlCon", "managerConnector", "consoleMachine", "httpInfo", "consoleConn", "emailConn", "nameConnect", "lsConnect", " urlMachine", "mlCon", "lrConnector", "railConnect", "implConnect", " urlCon", "urlDiscussion", "urlSet", "fileConnection", "resourceResponse", "utilConnect", "resourceConn", "lrConn", "urlInfo", "urlResponse", "sslConn", " urlHandler", "httpListener", " urlResponse", "methodConnector", "httpConnection", "browserConn", "lsConnector", "httpConnect", "emailConnector", "httpConn", "urlPosition", "methodConn", "urlHandler", "consoleCon", "railConnection", "resourceConnection", "utilConnection", " urlConnect", "lsConn", "sslPosition", "dbConnection", "utilListener", "utilConnector", " urlConnector", "emailConnect", "nameConn", "lrResponse", "urlConnector", "lrConnection", "mlConnection", "sslConnection", "httpSet", "sslDiscussion", "sslConnector", "mlMachine", "resourceConnector", "browserConnection", "urlService", "utilConn", "fileConnect", "browserConnect", "lsConnection", "urlListener", "dbConn", "dbPosition", "utilService", "managerConnect", "mlConn", "nameConnection", " urlSet", " urlService", "httpService", "managerConnection"], "rd": ["ird", "ered", "rid", "RD", "fr", "bd", "rg", "din", "dr", "drm", "rl", "mr", "rx", "rez", "usr", "rown", "rob", "ind", "lr", "wr", "xd", "dd", "dir", "rend", "dra", "nder", "ck", "dig", "erd", "r", "nd", "rer", "adr", "hr", "rus", "ped", "rb", "rc", "art", "ra", "rh", "ptr", "grad", "ined", "fd", "d", "rt", "ld", "ord", "rm", "rs", "rw", "rand", "std", "gd", "rax", "rr", "red", "rn", "ri", "repl", "ded", "rod"], "line": ["le", "where", "cl", "zone", "buffer", "lin", "status", "inline", "range", "point", "nl", "part", "pipe", "column", "length", "comment", "log", "file", "liner", "LINE", "l", " LINE", "next", "continue", "ln", "cell", "iter", "Line", "eline", "string", "lo", "none", "ice", "time", "check", "email", "ine", "loop", "side", "online", "len", "load", "frame", "number", "channel", "row", "edge", "record", "link", "lines", "block", "lock", "message", "entry", "stay", "node", "port", "error", "page", "set", "LIN"]}}
{"id1": "23666973", "id2": "15904772", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openResourceSimple", "openResourceRAW", "openResourceInternal", "openSteamRAW", "loadStreamSimple", "openSteamRaw", "loadStreamRAW", "loadSteamSimple", "openResourceRaw", "openStreamInternal", "openFileRAW", "openFileSimple", "openSteamInternal", "openFileInternal", "loadSteamRaw", "loadStreamInternal", "openFileRaw", "loadStreamRaw", "loadSteamInternal", "openStreamRAW", "openSteamSimple", "openStreamSimple", "loadSteamRAW"], "filename": ["println", "jpg", "river", "location", "mson", "mpeg", "src", "LCS", "fil", "bf", "FILE", "length", "upload", "file", "whatever", "ame", "download", "username", "document", "original", "prefix", "nil", "uri", "word", "string", "ren", "missing", "png", "path", "reference", "java", "title", "lua", "name", "stem", "metadata", "journal", "f", "description", "til", "directory", "fp", "kl", "sequence", "Filename", "sql", "message", "subject", "initial", "nm", "wikipedia", "ename", "fn", "source", "bol", "txt"], "stream": ["sync", "then", "mount", "back", "draw", "trace", "iter", "impl", "engine", "conv", "loop", "Stream", "list", "row", "message", "output", "valid", "socket", "filter", "parent", "history", "read", "pipe", "rest", "file", "collection", "ream", "poll", "next", "temp", "dd", "body", "transform", "proc", "open", "sl", "get", "present", "event", "local", "link", "response", "context", "zip", "window", "where", "buffer", "status", "length", "upload", "download", " Stream", "shape", "check", "old", "export", "wrapper", "load", "find", "channel", "control", "sample", "table", "resource", "cont", "source", "set", "content", "peer", "head", "pod", "reader", "instance", "view", "stack", "log", "test", "pool", "result", "still", "console", "ssl", "input", "chain", "feed", "http", "sw", "store", "port", "clean", "form", "iterator"], "url": ["dl", "build", "ul", "rl", "nl", "cal", "mount", "str", "external", "file", "loc", "lr", "l", "b", "gl", "web", "uri", "r", "ssl", "browser", "impl", "path", "ls", "mb", "job", "mail", "sl", "bel", "ur", "pkg", "pl", "http", "kl", "hl", "ll", "link", "rel", "URL", "fl", "char", "call", "resource", "Url"], "cl": ["c", "lp", "ct", "dl", "ocl", "Cl", "sc", "rl", "ctx", "acl", "log", "el", "cle", "comm", "scl", "gl", "loader", "tc", "ck", "cc", "ssl", "impl", "lf", "dll", "pl", "load", "CL", "kl", "hl", "ll", "cm", "fc", "fl", "com", "ctrl", "sh", "cr", "decl", "cf", "lc", "class"], "cn": ["tun", "tn", "dn", "CNN", "ct", "cv", "can", "cdn", "sen", "atten", "pn", "conn", "ocon", "bean", "csv", "jc", "pan", "cf", "oul", "ern", "nn", "nic", "enn", "aren", "tan", "gc", "uan", "nan", "unn", "hn", "avan", "unc", "non", "wn", "crow", "mn", "yn", "cm", "cap", "osen", "css", "CN", "gn", "cin", "rn", "nc", "ns", "fn", "bn", "san", "arn"]}}
{"id1": "3053403", "id2": "11562165", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"fc": ["fr", "dl", "pic", "xc", "ac", "FC", "ctx", "full", "isc", "func", " con", "las", "icc", "ric", "rc", "conv", "exp", "con", "hl", "cm", "pc", "owl", "act", "ic", "cf", "cv", "raf", "uc", "iac", "fab", "mc", "df", "gc", "soc", "f", "aft", "frac", "fs", "fp", "fps", "fl", "ocl", "tf", "disc", "inc", "fa", "football", "wic", "cs", "fm", "mac", "ec", "RFC", "lc", " dc", "nc", "c", "cl", "ff", "sc", "acl", "abc", "imp", "bf", "fb", "dc", "bc", "tc", "console", "cas", "util", "cond", "irc", "co", "coll", "fd", "unc", "win", "vc", "anc", "fn", "form"], "buff": ["fr", "np", "tmp", "Buffer", "bin", "bound", "kw", "printf", "ctx", "back", "font", "Buff", "FF", "urg", "xy", "func", "batch", "beck", "hex", "cmd", "lf", "alg", "rb", "tm", "exp", "bj", "act", "def", "bb", "bg", "th", "off", "bind", "hz", "norm", "cho", "rend", "cell", "proc", "obb", "interest", "f", "ld", "pb", "important", "fl", "h", "alf", "grow", "txt", "tf", "gz", "pdf", "buffer", "boost", "pred", "bed", "html", "fred", "utf", "butt", "orm", "inf", "aux", "uf", "nd", "ob", "fw", "hold", "fo", "prof", "ref", "zz", "att", "nt", "dat", "buf", "resp", " buffs", "pp", "uff", "sb", "ff", "emb", "vt", "src", "td", "bf", "fb", "ind", "tt", "bis", "b", "hd", "ph", "alph", "xff", "ott", "mb", "cb", "ust", "cond", "obj", " Buff", "gold", "note", "mem", "supp", "comp", "bo", "tab", "qq", "form"], "encoding": ["enryption", "enoded", "escapoded", " encryption", "encusing", "continaching", "enoding", "continoding", "enccode", "encoder", "coding", "coded", "continusing", "convusing", "enending", "encode", "encoded", "convoding", "encending", " enccode", "decoder", "deccode", "escapending", "coder", "decryption", "cending", " encusing", "convaching", "escapoding", " encaching", "escapoder", "convryption", "decoding", "encryption", "encaching", "enoder", "continryption", " encoder"]}}
{"id1": "23532405", "id2": "21488868", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"persist": ["remister", "remain", "remist", "Persister", "insiste", "insain", "Persist", "insister", "remiste", "persister", "Persain", "Persiste", "persiste", "insist", "persain"], "ffConfigurable": ["uffConfigorable", "ffconfigorable", "efConfigural", "effPortutable", "ffConfigural", "ffConfigorable", "ffconfigural", "effConfigured", "ffConfurable", "ffSpecurable", "ffConfigURA", "ffConfigurated", "ffconfigured", "ffCertURA", "ffconfigurated", "uffconfiguring", "ffCerturate", "ffRequesturable", "ffLogurer", "effCertured", "ffCertural", "ffLogurated", "effConfigutable", "uffconfigurable", "efconfigurable", "ffLogurable", "ffSpecural", "ffConfurer", "efConfigurate", "ffSpecuring", "efconfigural", "ffconfiguring", "ffConfutable", "ffConfuring", "ffConfigutable", "uffConfiguring", "ffRequestorable", "ffPortutable", "ffConfigurationURA", "uffconfiguer", "ffRequestuer", "ffconfigURA", "effCertURA", "ffLogutable", "effConfigURA", "ffConfigured", "uffconfigorable", "ffCerturable", "ffconfiguer", "ffconfigurate", "ffRequesturing", "ffConfurated", "ffCerturated", "uffConfigurable", "effPorturer", "ffCertured", "ffPorturer", "ffConfigurer", "effCerturable", "ffConfigurationurable", "ffConfiguer", "ffConfigurationured", "effConfigurer", "ffconfigurable", "effConfigurated", "ffConfiguring", "effCerturated", "ffCerturing", "ffPorturated", "efConfigurable", "efConfiguring", "effPorturable", "efconfiguring", "ffConfigurate", "ffPorturable", "effPorturated", "effConfigurable", "uffConfiguer", "ffConfigurationurated", "efconfigurate", "ffConforable", "ffConfuer", "ffSpecurate"], "relativePath": ["qualifiedPath", "relUrl", "relPath", "qualifiedFile", "relativeFile", "qualifiedDir", " relativeRoot", "absoluteRoot", " relativeUrl", "relativeDir", "absoluteFile", "relativeName", "absoluteDir", "relRoot", "qualifiedName", " relativeName", "relativeUrl", "relativeRoot", " relativeFile", "absoluteUrl", "absolutePath", "absoluteName", "relDir", " relativeDir"], "file": ["le", "create", "memory", "buffer", "view", "stream", "base", "user", "fil", "auto", "FILE", "full", "File", "log", "pool", "document", "image", "e", "dir", "string", "ile", "queue", "out", "path", "work", "rule", "al", "spec", "name", "format", "command", "play", "handle", "project", "url", "f", "issue", "folder", " File", "use", "frame", "list", "template", "fp", "force", "local", "link", "lock", "message", "output", "entry", "store", "to", "page", "port", "resource", "table", "word", "db", "filename", "set", "header", "class"], "is": ["ip", "ists", "iris", "in", "es", "bs", " Is", "js", "sis", "isin", "bis", "isc", "isi", "ib", "bits", "im", "ist", "xs", "iso", "ls", "lis", "nis", "ires", "its", "IS", "ris", "are", "fs", "ais", "isa", "iss", "ios", "isl", "ir", "ins", "us", "i", "Is", "ic", "s", "ms"], "os": ["oz", "io", "ose", "Os", "es", "bs", "des", "ui", "OS", "pos", "mot", "oS", "oa", "bos", "sys", "ot", "oss", "ds", "iso", "oses", "ls", "ops", "ys", "ox", "si", "ols", "los", "fs", "o", "ios", "obs", "osi", "cos", "us", "i", " Os", "oos", "ms"]}}
{"id1": "3558512", "id2": "11562173", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialate", "Serializer", "Serialize", "finalized", " serialate", "finalze", "initialze", "initialized", "serialate", "serialized", "initialize", "Serialization", "Serialized", "erialate", "finalization", "initialization", " serialized", "erializer", "finalize", "Serialze", "serialze", " serializer", "erialize", "erialized", "serializer", "serialization"], "out": ["c", "t", "io", "v", "stream", "os", "OU", "log", "file", "pool", "b", "serv", "result", " OUT", "res", "err", "up", "a", "n", "p", "f", "d", "sw", "o", "outs", "w", "ch", "it", "Out", "output", "sum", "report", "to", "i", "ou", "aos", "OUT"], "parser": ["parse", "lp", "peer", "tp", "reader", "ler", "ger", "manager", "worker", "instance", "part", "aser", "tree", "base", "file", "layer", "bank", "inner", "now", "language", "ker", "loader", "asser", "proc", "rer", "jack", "util", "job", "policy", "magic", "plan", "er", "format", "command", "tar", "builder", "password", "p", "per", "processor", "arser", "token", "pkg", "Parser", "walker", "style", "handler", "xml", "writer"], "on_disk": [" on_file", "On_file", "on_disc", "on2disk", "on2file", "On_disk", " on_download", "on2Disk", "on_dis", "on_volume", "on_Disk", "On2link", "On2file", "On_link", "on_cloud", " on_dis", "on2link", "On2Disk", "on_link", "on_file", " on_Disk", "On2disk", "On_cloud", "On_Disk", " on_disc", "on_download", " on_volume"], "in": ["io", "bin", "din", "min", " din", "id", "inc", "isin", "rin", "ind", "mi", "en", "inner", "inf", "ain", "inside", "body", "vin", "r", "is", "input", " IN", "In", "on", "gin", "IN", "it", "from", "ins", "inn", "cin", "ad", "i", "sin", "and"]}}
{"id1": "13122204", "id2": "16851955", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unarchiveModel", "UnzipModel", "Unarchivemodel", "UnarchiveModel", "UnarchiveImage", "unzipmodel", "UnzipModule", "unzipModule", "unlateImage", "UnzipImage", "unarchiveModule", "uncodeModel", "unarchiveImage", "unlatemodel", "unlateModel", "uncodeImage", "unlateModule", "unzipImage", "uncodemodel", "UnarchiveModule", "unarchivemodel", "Unzipmodel", "uncodeModule"], "filename": ["fle", "println", "river", "jpg", "location", "mson", "nl", "fil", "FILE", "wl", "file", "FIL", "download", "username", "original", "nil", "ln", "dra", "source", "origin", "path", "FN", "title", "name", "stem", "n", "journal", "SourceFile", "til", "directory", "fp", "kl", "Filename", "sql", "output", "subject", "nm", "ivo", "ename", "fn", "txt"], "tempdir": ["testdir", "temppath", " tempDIR", "tempDIR", "temfolder", "temDir", "temDIR", "Tempdirectory", "tmpfolder", " tempdirectory", "temdir", "tmpdirectory", "tmppath", "tmpfile", "Tempdir", "tempath", "Tempfile", "tmpDIR", " tempfile", "temdirectory", "tempdirectory", " tempDir", "tempDir", "tempfolder", "testDir", "testpath", "tmpDir", "TempDir", "testfolder", "tempfile", "tmpdir"], "dest": ["generated", "est", "peer", "tmp", "coord", "ctr", "Dest", "trans", "buffer", "deep", "bin", "write", "default", "inv", "src", "dev", "tail", "pipe", "des", "stream", "usr", "nom", "rest", "pos", "test", "loc", "document", "dc", "foreign", "temp", "result", "origin", "del", "out", "tr", "obj", "nt", "dat", "ptr", "comb", "send", "target", "dist", "slave", "desc", "output", "st", "sum", "display", "null", "master", "store", "table", "port", "decl", "parent", "writer", "cont", "source"], "fis": ["li", "zos", "zjs", "ifos", "ifatis", "lis", "fjs", "zatis", "fli", "ljs", "flos", "los", "fatis", "ifis", "fljs", "fi", "ifi", "zi", "flis", "flatis"], "BUFFER": ["MAXBuffer", "FFERBER", "BABER", "CUBuffer", "BufferBER", "LOCKBER", "BufferMT", " BUBuffer", "BUMT", "BUBER", " BUOUNT", "BLOUNT", "FFERMT", " BUFR", "FFERFFER", "CUBER", " BUULT", " BUBER", "MAXOUNT", "BufferBuffer", "CUFFER", "LOCKBuffer", "CUFR", "BUULT", "FFERBuffer", "BULT", "BOUNT", "LOCKFR", "BLBER", "BAULT", "MAXBER", " BUMT", "BAFFER", "MAXFFER", "BufferFFER", "BFFER", "LOCKFFER", "BUFR", "BBER", "BAOUNT", "BUBuffer", "BLBuffer", "BUOUNT", "BLFFER"], "zis": ["zeis", "zeiss", " zIS", "zies", "xiss", "fiss", "ozip", " zris", " zi", "Ziss", "xi", "ozi", "zos", "oziss", "zios", "zip", "ozis", " zits", "ziss", "zeits", "zeris", "Zi", " zos", "zoneiss", "zeos", "Zis", "zoneis", "zeIS", " zip", "xos", "zees", "Zos", " ziss", "zoneits", "zIS", " zes", "zoneris", "xis", "fip", "ziis", "fi", "zits", "zi", "zes", "ziIS", "zris"], "entry": ["jar", "ry", "or", "se", "member", "part", "connection", "comment", "log", "ce", "inter", "file", "existent", "card", "image", "ze", "e", "je", "result", "cell", "ent", "piece", "ie", "way", "item", "index", "enter", "nt", "chain", "name", "Entry", "escape", "header", "pe", "element", "match", "row", "record", "link", "def", "char", "jo", "zo", "table", "zip", "word", "source", "key", "system"], "count": ["c", "ctr", "ct", "read", "buffer", "max", "OUNT", "acc", "part", "base", "core", "length", "comment", "total", "ce", "batch", "add", "common", "cell", "cc", "child", "index", "cache", "check", "cond", "counter", "nt", "found", "n", "start", "amount", "f", "len", "all", "match", "number", "nb", "force", "num", "size", "sum", "Count", "z", "call", "code", "ount", "cont", "current", "page", "cloud"], "data": ["content", "text", "dl", "mat", "results", "buffer", "DATA", "part", "str", "ata", "raw", "batch", "image", "next", "result", " DATA", "out", "dec", "zero", "cache", "step", "dat", "format", "n", "accept", "p", "d", "all", "value", "size", "sample", "rel", "message", "area", "ATA", "bytes", "output", "done", "valid", "table", "window"], "fos": ["Fios", "foes", "lOS", "Foss", "FOS", "Foses", "fios", " foses", " fOS", " foss", "lios", "voses", "foss", "Foes", "vos", "Fos", "voss", " fios", "foses", "fOS", "los", "voes", " foes", "loss"]}}
{"id1": "2396191", "id2": "8973505", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFormHTTPSafe", "getLinksFromURIFast", "getLinksFromUrlSafe", "getLinksFromURLfast", "getLinksFormHTTPFast", "getLinksFromHTTPfast", "getLinksFormURLfast", "getLinksFromHTTPFast", "getLinksFromUrlfast", "getLinksFromURLSafe", "getLinksFromURISafe", "getLinksFormURLFast", "getLinksFormHTTPfast", "getLinksFromHTTPSafe", "getLinksFromURIfast", "getLinksFromUrlFast", "getLinksFormURLSafe"], "p_url": ["x3lr", "pingYurl", "pYurl", "pYpage", "p___lr", "postonurl", "p_org", "primaryongurl", "admin_uid", "p3uri", "x3dir", "pingYpage", "p___page", "p_page", "ping_url", "adminoymail", "pYlr", "admin_url", "admin_mail", "primary_url", "p_line", "ping_page", "pswlink", "primaryongorg", "p6url", "ping_line", "postonemail", "poreurl", "x3url", "p6browser", "pongURL", "x3uri", "p_uri", "primary_org", "pYline", "vp_url", "private_html", "postonURL", "pongemail", "adminoydir", "ping_lr", "p6dir", "p3url", "p_html", "poymail", "p64url", "private_browser", "private_url", "porehtml", "primaryongemail", "adminoyuid", "p6html", "p_uid", "adminoyurl", "p_browser", "p___line", "porebrowser", "p_mail", "pingYlr", "p_lr", "poydir", "private_dir", "primary_email", "primaryongURL", "pongurl", "poyurl", "pswurl", "p_dir", "p64org", "postonorg", "poredir", "admin_dir", "primary_URL", "x_uri", "p3lr", "p64email", "vp_lr", "p___url", "pswjson", "p3dir", "pingYline", "vp_link", "poyuid", "vp_json", "p64URL", "p_URL", "x_lr", "p_email", "pswlr", "p_link", "pongorg", "p_json"], "x_url": ["xJweb", " x_cn", "xJurl", "x_net", " x_log", "x_web", "x_log", " x_web", "xJnet", "x_ls", " x_net", "x_cn", " x_ls", "xJlog"], "x_conn": ["x3connection", " x_connection", "p_con", "x_ws", " x_nt", "x3client", "x3conn", "p_conn", "p_connection", "x_con", "p_ws", "x3nt", "x_connection", "x_nt", "x_client", " x_client"], "x_is_reader": ["x_ais_reader", "x_ais_parser", "x_isresparser", "x_is_read", "x_is2reader", "x_is_Reader", "x_is2writer", "x_is_rx", "x_is2Reader", "x_ais_writer", "x_ais_rx", "x_is2read", "x_isreswriter", "x_isresreader", "x_isresrx", "x_is_parser", "x_is_writer"], "x_reader": ["rx_buffer", "ex_rr", "x8rot", "ex_stream", "x8reader", "x_rr", "rx_rot", "ex_writer", "x_writer", "x_buffer", "ex_reader", "x_stream", "rx_reader", "x_rot", "rx_writer", "x8buffer", "x8writer"], "x_line": ["xmyline", "x_print", "ex_page", "xLEpage", "ex_line", "xLEline", "xmyiter", "x_____match", "ex_stream", "xmystream", "ex_link", "x_____page", "x_____print", "ex_iter", "xmypage", "x_route", " x_print", "xLEstream", "x_____line", "x_iter", "x_stream", "ex_route", "xLEiter"], "e": ["et", "ye", "c", "t", "ele", "le", "ae", "y", "fe", "ev", "te", "eur", "se", "eu", "es", "re", "oe", "eeee", "ef", "ne", "u", "el", "ce", "en", "eps", "l", "ze", "ent", "ge", "eg", "r", "xe", "x", "ie", "eb", "ue", "de", "err", "ere", "end", "er", "ec", "a", "n", "me", "exp", "pe", "d", "f", "be", "element", "o", "ei", "he", "EEE", "event", "one", "ea", "we", "ee", "E", "m", "g", "h", "ed"], "x_match": ["x__find", "ex_look", "x___match", "rx_tag", "xi_move", "x___move", " x_find", "x__result", "x_tag", "x_mat", "x___fire", "rx_match", "x2match", "x_entry", " x_mat", "x67process", "x67mat", "x10member", "ex_result", "x10result", " x2mat", "x___mat", "x10match", " x_member", "x_look", "x___member", " x2process", " x_process", "ex_match", "x2mat", "xi_match", "x2process", "rx_member", "ex_member", "x_process", "x10entry", "x_fire", "x67match", "x_message", "xi_message", "x_move", "x___message", " x2member", "x67member", " x2match", "x__match", "x__mat", "x___tag", "x_find", "ex_entry", "x_member", "x2member", "xi_fire", "rx_mat"], "x_dir": ["ex_path", "ex_div", "x_div", "x_file", "ex_file", "x_path", "x5path", "ex_dir", "x5dir", "x5div", "x5file"], "x_root": ["inx_parent", "x_parent", "inx7parent", "x7path", "inx_path", "x_target", "inx7root", "x__parent", "x__root", "x7target", "x_path", "inx_target", "x__target", "inx_root", "inx7target", "x7parent", "x__path", "inx7path", "x7root"], "x_links": ["x__pages", "x__lines", "x_lines", "x_relations", "x_pages", "x__links", " x_pages", "x__relations", " x_relations", " x_lines"], "x_texts": ["x_paths", "x_lengthes", "x__logls", "x_textls", "x_logls", "x_pathls", "x_textes", "x__logsets", "x_logsets", "x_lengthsets", "x_pathes", "x_logs", "x__logs", "x_pathsets", "x__textsets", "x__loges", "x__textes", "x__texts", "x__textls", "x_textsets", "x_lengths", "x_loges", "x_lengthls"], "x_buf": ["x___Buff", "ex2buf", "ex_temp", " x_buff", " x_uf", "x7buf", " x_buffer", " x2buff", "x2buf", "x_bag", "x7buff", "x2pool", "x_buff", "x2uf", "ex_bag", "ex_Buff", "ex_buf", "ex2temp", "x64Buff", " x2temp", "ex2bag", " x_pool", "x_pool", "x_Buff", " x2pool", " x2buf", "x2buffer", "x2buff", "x64buf", "x7temp", "x2Buff", "x_buffer", "ex2Buff", "x2bag", "x___temp", " x_temp", "x2temp", "x_uf", "x7pool", "x___bag", "x64bag", "x64temp", "x___buf", "x_temp"], "x_matches": ["x_matists", "x2matters", "x_maaches", "x2patcher", "x__matches", "x__matists", "x2patches", "x2patters", "x_matchchers", "x_attches", "x_machers", "x_memaches", "x_actches", "x_morcher", "x_matqs", "x2patets", "x_formatices", "x_morters", "x_Matqs", "x_masets", "x_patchers", "x__matets", "x_catets", "x_maches", "x_formatchers", "x_matchers", "x2matcher", "x_catters", "x_actices", "x_Mataches", "x_matets", "x_matcher", "x_matchcher", "x__masets", "x_morches", "x_maschers", "x_memches", "x_matices", "x_mataches", "x_masists", "x_catists", "x_actcher", "x_Matcher", "x2matches", "x_memchers", "x_matchets", "x_actchers", "x_Matchers", "x_patcher", "x_memqs", "x_masches", "x__matchers", "x_Matches", "x_attets", "x_Matices", "x_morets", "x__masches", "x_attchers", "x2matets", "x_matters", "x_matchches", "x_patches", "x_patters", "x_catchers", "x_catches", "x_patets", "x__masists", "x_maqs", "x_attists", "x_formatches", "x__maschers", "x_matchters", "x_formatcher"], "x_page": ["x_message", "xhomeport", "x_net", "x_port", "p_net", "x_pp", " x_pp", "p_line", " x_port", "p_page", "xtpage", "xtmessage", "xhomepage", "xhomeline", "xturl", "xtline", " x_message", "xhomepp"], "x_link": ["x_location", "x42page", "x42link", " x_location", "x42path", "x_path", "xe_link", " x_path", "x_ink", "xe_ink", "xe_links", "x42location", "xe_url"], "i": ["ip", "ori", "fire", "li", "io", "y", "v", "bi", "in", "ii", "phi", "multi", "key", "xi", "I", "u", "id", "ui", "this", "mi", "batch", "oi", "PI", "gi", "im", "iter", "origin", "hi", "cli", "ami", "x", "is", "ki", "ti", "ci", "pi", "chain", "ji", "iq", "n", "me", "qi", "si", "init", "ix", "di", "info", "ini", "ims", "it", "sim", "j", "m", "fi", "ai", "us", "ic"]}}
{"id1": "16466743", "id2": "2113444", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "label": 0, "substitutes": {"getmd5": ["getsha5", "getmd6", " getMD6", " getMD2", "getMD5", "getMD4", "getsha2", "getmd4", " getMD5", " getMD4", "getMD6", "getMD2", " getmd6", "getsha4", " getmd4", "getmd2", "getsha6", " getmd2"], "password": ["text", "wd", "secret", "padding", "data", "user", "attribute", "username", "phrase", "prefix", "sword", "string", "pattern", "security", "hash", "path", "email", "database", "address", "name", "login", "wordpress", "shadow", "pass", "Password", "p", "token", "description", "hello", "value", "ew", "w", "message", "entry", " Password", "code", "auth", "word", "key"], "pwHash": ["pwtHas", " pwHas", "pWhash", "pWSum", "pwsHash", "pWHash", "pwsHas", "spwHas", "pwthash", "pwdhash", "pwshash", "pwdHash", "pwtHash", "pwsSum", "pwHas", "pwdSum", "pwhash", "spwhash", "spwdSum", " pwdSum", "spwdHas", "pWHas", "spwHash", "pswSum", "spwSum", " pwdhash", "pswHash", "pswHas", " pwdHas", "pwdHas", " pwdHash", "spwdHash", "pswhash", "pwSum", " pwSum", " pwhash", "pwtSum", "spwdhash"], "md": ["pm", " Md", "bd", "MD", " mo", "det", "cd", " mm", "td", "ng", "sd", "sm", "mt", "ind", "mod", "add", "dd", "hd", "dir", "mc", "dig", "del", "cmd", " dd", "ds", "df", " mc", "mk", "nd", "dm", "mo", "mb", "cond", "mail", "pd", "metadata", "material", "mem", "exec", "grad", "mp", "d", "der", "di", "ld", "rm", "man", "mn", "od", "desc", "def", "m", "doc", "msg", "cmp", "mm", "red", "ad", "mg", "ms"], "b": ["sb", "B", "y", "binary", "v", "bi", "ba", "bh", "bs", "buff", "fb", "bf", "bis", "batch", "bas", "l", "bc", "ib", "bar", "ab", "mb", "eb", "cb", "ob", "br", "obj", "rb", "a", "p", "f", "d", "be", "gb", "nb", "w", "bp", "abs", "bytes", "m", "g", "bu", "db", "bb", "reb"], "i": ["ip", "li", "y", "io", "v", "span", "bi", "in", "ii", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "iu", "mi", "ski", "oi", "l", "gu", "next", "gi", "im", "iter", "q", "hi", "cli", "x", "is", "ki", "ti", "ie", "index", "ci", "pi", "ji", "ij", "a", "n", "p", "qi", "si", "init", "ix", "di", "json", "ini", "ei", "o", "it", "yi", "sim", "j", "my", "\u0438", "m", "ai", "us", "ic", "ri", "ms"]}}
{"id1": "11673907", "id2": "21930714", "code1": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testSpeedyShareUpload() throws Exception {\n        request.setUrl(\"http://www.speedyshare.com/upload.php\");\n        request.setFile(\"fileup0\", file);\n        HttpResponse response = httpClient.execute(request);\n        assertTrue(response.is2xxSuccess());\n        assertTrue(response.getResponseHeaders().size() > 0);\n        String body = IOUtils.toString(response.getResponseBody());\n        assertTrue(body.contains(\"Download link\"));\n        assertTrue(body.contains(\"Delete password\"));\n        response.close();\n    }\n", "label": 0, "substitutes": {"_checkLanguagesFiles": ["_checkAllangsfiles", "_checkAllangsFiles", "_checkLangsFiles", "_checkLuesfiles", "_checkLuesFiles", "_checkLuesFile", "_checkLangsWindows", "_checkAllanguagesfiles", "_checkAllangsFile", "_checkLangsfiles", "_checkLanguagesfiles", "_checkAllangsWindows", "_checkLanguagesFile", "_checkAllanguagesWindows", "_checkLanguagesWindows", "_checkLangsFile", "_checkAllanguagesFiles", "_checkLuesWindows", "_checkAllanguagesFile"], "req": ["fr", "request", "inv", " request", "ctx", "src", "usr", "md", "jp", "comm", " requ", "require", "q", "pas", "cmd", "r", "cgi", "tr", "ux", "ref", "quest", "qt", "Request", "pkg", "http", "conf", "cur", "rs", "required", "wx", "Requ", "ch", "tx", " cir", "xml", "msg", "attr", " fr", "requ"], "res": [" Res", "Resp", "state", "re", "des", "Rep", "data", "os", "next", "result", "Res", "out", "resp", " rs", " gr", " resp", "conf", "rs", "con", "ch", "tx", "doc", "RES", "s", "sp", "sol", "txt"], "config": ["c", "ct", "cfg", "state", "ctx", "etc", "base", "ext", "Configuration", "log", "Conf", " Config", "admin", "rc", "map", "param", " fig", "fig", "params", "conf", "con", " configuration", "context", "Config", "auth", "cont", "cf", "set"], "form": ["fr", "submit", "app", "instance", "state", "view", "base", "sam", "forms", "pool", "flash", "session", " Form", "input", " forms", " app", "map", "FORM", "f", "d", "set", "row", "apply", "fc", "Form", "parent", "owner", "sp"], "list": ["history", "dl", "li", "ml", "cl", "detail", "type", "state", "ul", "status", "range", "alist", "acl", "L", "data", "tree", "LIST", "log", "test", "pool", "batch", "print", "lists", "l", "now", "lat", "ist", "r", "shape", "the", "queue", "out", "listed", "ls", "index", "al", "map", "old", "layout", "names", "all", "load", "info", "local", "sequence", "st", "def", "show", "table", "filter", "cont", "set"], "i": ["ip", "ori", "c", "li", "y", "bi", "in", "k", "eu", "phi", "multi", "ii", "mill", "I", "id", "u", "ui", "ind", "mi", "iu", "batch", "b", "gu", "gi", "im", "q", "hi", "client", "ami", "x", "is", "ki", "ie", "ti", "index", "major", "ci", "pi", "chain", "ji", "name", "me", "qi", "si", "init", "ix", "di", "ini", "ims", "it", "yi", "sim", "j", "my", "m", "ai", "us", "ic"], "langId": ["langInt", "locById", "posID", "convInfo", "angOne", "posId", "wanOne", "langName", "wanId", "angInt", "wanID", "angById", "langInfo", "posById", "locId", "wanById", "langById", "convID", " langInt", "posOne", "convById", " langInfo", "angId", " langName", " langID", "angID", " langById", "convId", "angName", "langOne", "langID", "locInt", "angInfo", "locName"], "filePath": ["sourcepath", " fileName", "fileSet", "FileSocket", "fileSocket", "projectPath", " fileSocket", "FilePath", "FileName", " fileSet", "fileName", "filepath", "projectName", "FilePATH", "projectSet", "sourcePath", "filePATH", " filePATH", "sourcePATH", "sourceName", "Filepath", "FileSet", "projectSocket", " filepath"], "from": ["fr", "create", "bound", "or", "in", "se", "re", "src", "part", "view", "default", "base", "os", "bean", "html", "this", "pos", "with", "self", "l", "original", "add", "before", "so", "still", "origin", "normal", "ie", "path", "name", "a", "old", "From", "start", "false", "simple", "of", "f", "init", "set", "local", "via", "link", "vol", "st", "entry", "reset", "initial", "store", "empty", "source", "by"], "tmpFilePath": ["tmpfileName", "tempFileLocation", "tmpileUrl", "tmpFolderName", "tempfilePath", "tmpFilenameSet", "tmpilePath", "tmpfileLocation", "tmpfileId", "tmpFileSet", "tmpFileName", "tmpFileId", "tmpfilePath", "tempfileUrl", "tmpileName", "tmpFilenameId", "tmpFilenamePath", "tmpFolderLocation", "tempFileUrl", "tempfileId", "tempFileSet", "tempFileId", "tempFilePath", "tmpFolderId", "tmpFileUrl", "tmpFileLocation", "tmpFilenameName", "tmpFolderPath", "tmpileSet", "tmpfileSet", "tempfileSet", "tmpFilenameUrl", "tmpfileUrl", "tempFileName", "tempfileLocation", "tempfileName", "tmpFilenameLocation"], "to": ["et", "t", "io", "create", "TO", "tom", "top", "te", "or", "phi", "etc", "by", "too", "this", "total", "tt", "file", "l", "b", "temp", "at", "eto", "out", "no", "nt", "To", "format", "news", "f", "target", "o", "it", "bo", "toc", "st", "that", "null", "ta", "pro", "table", "into", "set"], "copy": ["sync", "save", "fire", "where", "scale", "create", "same", "replace", "write", "close", "part", "core", "transfer", "download", "image", "trace", "other", "drop", "clip", "clone", "cp", "cop", "split", "fill", "check", "slice", "policy", "title", "map", "cover", "escape", "clear", "opy", "paste", "move", "delete", "match", "repeat", "set", "force", "link", "lock", "apply", "cap", "Copy", "store", "share", "pixel", "ignore", "remote", "source", "quote", "skip", "push", "remove"], "srcChannel": ["srcEntry", "rcChannel", " srcEntry", " srcChan", "rcChan", "srEntry", "srchannel", "srChannel", "srcChain", "rcchannel", "rcEntry", "sourceButton", " srcButton", "sourcechannel", "srcchannel", "sourceCh", "rcChain", "sourceChain", "ctrchannel", "srChan", "srConnection", " srcConnection", " srcchannel", "sourceChan", "srcCh", "srcButton", "srcChan", "rcCh", "srButton", "sourceConnection", "srChain", "sourceChannel", "ctrCh", " srcCh", "ctrChannel", "srcConnection", "ctrChan", "srCh"], "dstChannel": ["dltMethod", "dbrchannel", "dndChannel", " dbrChan", "dstchannel", "ddestChannel", " dotChannel", "dbrCh", "dotCh", "dotChannel", "dltCh", " dblMethod", "dndchannel", " dotVideo", "dblChannel", "ddestVideo", "destCh", " dstCh", " dstChan", "dltChannel", " dblChannel", "dndChan", "destChannel", "destchannel", "ddestMethod", "dotChan", " dbrCh", "dotVideo", "ddestchannel", " dstVideo", "dblCh", "dndVideo", " dstchannel", "dbrChan", "dltChan", " dbrchannel", "dstCh", " dblCh", "ddestChan", "destChan", "ddestCh", "dstChan", "dotchannel", "dstVideo", " dotchannel", " dbrChannel", " dotChan", " dstMethod", "dblChan", "dstMethod", "dbrChannel", "dblMethod", " dblChan"]}}
{"id1": "23370621", "id2": "12883117", "code1": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 0, "substitutes": {"downloadFile": ["Downloadfile", "downloadfile", "loadfile", "downloadFiles", " downloadFiles", " downloadSingle", "loadFile", "DownloadFiles", "loadFiles", " downloadfile", "downloadSingle", "DownloadSingle", "loadSingle", "DownloadFile"], "target": ["txt", "t", "tmp", "tp", "location", "v", "buffer", "type", "top", " targ", "copy", "default", "fixed", "ver", "arget", "tree", "base", "this", "dest", "file", "test", "physical", "result", "dir", "secondary", "localhost", "gt", "out", "pattern", "path", "alias", "format", "tar", "goal", "root", "tif", "tor", "delete", "match", "set", "template", "touch", "local", "it", "rel", "output", "ret", "that", "null", "to", "table", "parent", "remote", "bolt", "source", "filename", "Target"], "s3key": [" s2Key", "s6key", "s4url", "s3Key", "sdkKEY", "sdkkey", "s2KEY", "s2Key", "sdkurl", "s4KEY", "s3KEY", "s3url", "s3secret", "s2secret", " s3secret", " s2KEY", "s6secret", "sdksecret", " s2key", "s6Key", " s2url", "s2url", "sdkKey", "s4Key", " s3KEY", "s4key", " s3Key", "s2key", " s3url", " s2secret"], "in": ["t", "io", "reader", "bin", "read", "din", "copy", "or", " din", "sin", "re", "stream", "data", "asin", "inc", "isin", "rin", "ind", "file", "mi", "en", "raw", "inner", "l", "e", "inf", "ain", "inside", "iter", "vin", "mc", "out", "r", "is", "input", "nin", "up", "In", "n", "on", "req", "gin", "f", "init", "o", "IN", "ini", "con", "local", "it", "from", "sql", "ins", "inn", "m", "cin", "ai", "i", "s", "mm", "source", "oin", "and"], "temp": ["tem", "t", "tmp", "buffer", "Temp", "top", "copy", "part", "base", "mt", "file", "dest", "test", "mod", "prefix", "pt", "tc", "out", "porary", "mk", "tr", " temporary", "EMP", "res", "partial", "tm", "stem", "dat", "tar", "mem", "mp", "p", "template", "local", "emp", "output", "tx", "tim", "my", "tab", "null", "unt", "to", "mm", "fake", "current", " tmp", "txt"], "fout": ["flOut", "ffou", "flowoutput", "vout", "ifout", "flowou", "wto", "vto", "ffOut", " fou", "Fout", "fabout", "foutput", "fabyout", "Fyout", "vouts", "flowout", "FOut", "ffto", " fouts", "fOut", " fOut", "flou", "fyout", "wOut", "wout", "flout", "fabouts", "ifou", "vOut", "fabOut", "ifoutput", "fou", "fto", "wouts", "ffouts", " foutput", "Fouts", "ifOut", " fyout", "ffout", "floutput", "ffoutput", "fouts", "flowOut"]}}
{"id1": "5620792", "id2": "3806532", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["SHA2", " SHAOne", "SHAOne", "sha1", "HSOne", "shaOne", "HS256", "sha2", " SHA2", " SHA256", "HS1", "SHA256", "sha256", "HS2"], "text": ["content", "t", "ct", "read", "translation", "current", "data", "str", "ext", "comment", "select", "test", "document", "print", "prefix", "pt", "TEXT", "string", "source", "q", "out", "pattern", "path", "input", "nt", "name", "term", "password", "url", "value", "template", "event", "message", "output", "tx", "subject", "act", "config", "code", "msg", "cont", "word", "Text", "key", "form", "txt"], "HASH_VALUE_SIZE": ["HASH_VAL_SIZE", "HASH_value_SOURCE", "HASH_VALUE_TYPE", "HASH_VALUE_NAME", "HASH_value_SIZE", "HASH_VAL_NAME", "HASH_value_DIR", "HASH_VAL_Size", "HASH_VALUE_NO", "HASH_VALUE_DIR", "HASH_VALUE_Size", "HASH_VAL_NO", "HASH_VALUE_SOURCE", "HASH_value_TYPE"], "md": [" Md", "bd", "MD", " cmd", "ctr", "dh", " mo", "det", "cd", " mm", "td", " rm", "sd", "sm", "js", "mand", "mt", "ind", "mod", " man", "add", "dd", "hd", "dir", "hm", "mc", "dig", "cmd", " dd", "ds", "df", "mk", " mc", "nd", "dm", "mb", "cond", "pd", "metadata", "grad", "mp", " sd", " cd", "d", "der", "mond", "ld", "rm", "mn", "od", " del", " ms", " ma", "m", "h", "mm", "ad", "mode", "mg", "ms", "and"], "sha1hash": ["sha7hash", "sha2Hash", "SHA2Hash", "sha2sum", "sha31have", " SHA31have", "ha2Hash", "sha1have", "sha31value", "sha31hash", "shaoneresult", " SHA1sum", "ha1hash", " SHA31value", "ha1sum", "sha3hash", " SHA1hash", " SHA1have", " SHA31sum", "sha1result", "sha2hex", "SHA2str", "SHA1hash", "ha2hash", "sha2str", "ha1Hash", "sha3hex", "sha2value", "sha2result", "SHA1str", "sha1Hash", "sha5hash", "shaonesum", "ha1result", " SHA31hash", "sha1str", "sha3Hash", " SHA1value", "sha3str", "sha5value", "ha2sum", "sha7Hash", "SHA2hex", "sha2have", "sha7hex", "sha5sum", "SHA2hash", "sha1hex", "sha1sum", "shaonehash", "ha2result", "sha2hash", "SHA1Hash", "SHA1hex", "sha31sum", "sha1value", "sha7str", "shaoneHash", "sha5have"]}}
{"id1": "15018553", "id2": "8150996", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"encrypt": [" enccrypt", "uncrypt", "unccrypt", "encrypted", "Encrypt", "encode", "Enccrypt", " encrypted", "uncrypted", "uncode", "Encrypted", " encode", "Encode", "enccrypt"], "text": ["content", "t", "ct", "th", "v", "read", "buffer", "translation", "str", "data", "ext", "comment", "select", "test", "ut", "document", "phrase", "print", "now", "pt", "TEXT", "body", "string", "source", "q", "pattern", "x", "path", "input", "title", "nt", "name", "password", "url", "p", "value", "w", "message", "output", "tx", "act", "code", "msg", "cont", "word", "Text", "form", "txt"], "md": ["pm", "c", "bd", "MD", " cmd", "t", "dh", "ct", "det", "cd", "img", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "dig", "del", "cmd", " dd", "sha", "df", "mk", "mb", "nd", "dm", "mo", "hash", "mac", "de", "err", "pd", "metadata", "mem", "grad", "mp", "pkg", "d", " cd", "mond", "der", "ld", "rm", "di", "mn", "od", "m", "doc", "msg", "h", "mm", "cmp", "ad", "mode", "mg", "ms", "and"], "md5hash": ["md3h", "md512h", "md3hash", " md2cloth", " md2hash", "md2sha", " md5Hash", "md2hash", "md5cloth", "md3hex", "md2h", "md5Hash", "md5sha", "md3Hash", "md512Hash", "md5hex", " md5sum", " md3Hash", "md5h", "md2Hash", "md3sha", " md3sha", " md5sha", " md2sum", "md5sum", " md5hex", "md2hex", "md3sum", "md3cloth", " md5h", " md3h", "md2cloth", "md2sum", " md2hex", " md3sum", " md3hash", "md512sum", "md512hash", "md512sha", " md5cloth"]}}
{"id1": "3683344", "id2": "19784131", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandomSID", " genRandomGuid", " genRandomGU", " genRandUID", " genRandGU", " genRandomSUID", " genRandomUU", " genRandUUID", " genRandomRandomUID", " genRandUuid", " genRandomUUID", " genRandGID", " genRandomSuid", " genRandomRandomuid", " genRandomRandomID", " genRandomGID", " genRandUU", " genRandomRandomU", " genRandomUID", " genRandomSU", " genRandGuid", " genRandomUuid", " genRandGUID"], "secure": ["sync", "confirmed", "encrypted", "deep", "sr", "stable", "close", "status", "speed", "nice", "active", "id", "server", "prime", "trust", "free", "google", "https", "sys", "client", "ssl", "security", "ie", " Secure", "check", "Secure", " insecure", "clear", "safe", "pretty", "sensitive", "strong", "sec", "force", "protect", "domain", "weak", "quiet", " securely"], "valueBeforeMD5": ["valueBeforeMOD2", "valueBeforeMT5", "valueAfterDER0", "valueBeforeND5", "valueAfterMD2", "valueAfterMDInvalid", "valueBeforeID3", "valueBeforeMOD0", "valueUnderMM5", "valueBeforeID5", "valueAfterMD3", "valueBeforeRD5", "valueBeforeDERFive", "valueAfterDERFive", "valueAfterMD4", "valueBeforeND3", "valueAfterND3", "valueBeforeMT25", "valueBeforeMD3", "valueBeforeND2", "valueAfterND4", "valueBeforeMDFive", "valueUnderMM25", "valueBeforeSHA523", "valueBeforeMDInvalid", "valueUnderMD0", "valueBeforeRDInvalid", "valueBeforeMM0", "valueBeforeID2", "valueBeforeMD25", "valueBeforeMM5", "valueBeforeDER5", "valueUnderMD25", "valueBeforeSHAInvalid", "valueAfterMD0", "valueBeforeND0", "valueBeforeID4", "valueBeforeMOD5", "valueBeforeSHA2", "valueBeforeND4", "valueBeforeMODFive", "valueBeforeMT0", "valueAfterMDFive", "valueBeforeRD523", "valueBeforeRD2", "valueBeforeMTFive", "valueAfterND5", "valueUnderMD5", "valueAfterDER5", "valueBeforeMD0", "valueAfterDER2", "valueBeforeMD4", "valueBeforeND25", "valueBeforeMD2", "valueBeforeMD523", "valueUnderMM0", "valueBeforeMM25", "valueAfterMD523", "valueBeforeDER0", "valueAfterND2", "valueBeforeSHA5", "valueBeforeMT2", "valueBeforeDER2"], "valueAfterMD5": ["valueAfterMD8", "valueAftermd5", "valueAfterMCdown", "valueAfterMC3", "valueAfterMD55", "valueAftermd2", "valueAfterSDRL", "valueafterMD5", "valueAfterMD2", "valueWithoutMD5", "valueAfterMM5", "valueAfterMD3", "valueafterEM55", "valueAfterMD4", "valueAfterMM3", "valueAfterMT5", "valueafterMDLeft", "valueWithoutMDPE", "valueBeforeMD3", "valueWithoutmdOK", "valueWithoutMD2", "valueAfterMI5", "valueBeforeMM2", "valueAfterMIPE", "valueAfterMM2", "valueBeforeMM4", "valueBeforeMC2", "valueAfterMDODY", "valueAfterMDRL", "valueafterEM2", "valueAfterCDdown", "valueAfterUDRL", "valueAfterUD3", "valueAftermdOK", "valueAfterEMLeft", "valueBeforeMM5", "valueAfterEM55", "valueAfterSD5", "valueAfterEM2", "valueBeforeMDODY", "valueWithoutmd5", "valueAfterMDPE", "valueAfterMTdown", "valueAfterMDOK", "valueAfterMDdown", "valueAfterMC2", "valueAfterUD5", "valueAfterUDODY", "valueAfterSD3", "valueAfterMC4", "valueAfterSDODY", "valueafterEM5", "valueAfterMT8", "valueWithoutmdPE", "valueAfterEM5", "valueBeforeMM3", "valueafterMD2", "valueAfterMIOK", "valueBeforeMD8", "valueAfterMM4", "valueAfterMT2", "valueAfterMT55", "valueAftermdPE", "valueWithoutMDOK", "valueAfterMI2", "valueAfterMT3", "valueWithoutmd2", "valueBeforeMDRL", "valueBeforeMD4", "valueBeforeMDdown", "valueBeforeMCdown", "valueBeforeMD2", "valueafterMD55", "valueAfterMC8", "valueAfterCD2", "valueAfterMDLeft", "valueBeforeMC5", "valueAfterCD5", "valueAfterMTLeft", "valueafterEMLeft", "valueAfterMC5"], "md5": ["MD25", " md3", "metadata2", "metadata25", "md25", "MD7", " MD7", " MD3", "MD3", "md3", "md7", "metadata3", " MD2", " md2", "metadata5", " MD5", "dig2", " md7", "MD2", "dig3", " md25", "MD5", "dig5", "md2"], "sbValueBeforeMD5": ["sbValueBeforeMD20", "sbValueBeforeAMD305", "sbValueDefMD2", "sbValueAfterMS3", "sbValueBeforeMOD5", "sbValueBeforeMOD45", "sbValueAfterMD45", "sbValueBeforePDLE", "sbValueBeforeMDOK", "sbValueBeforeAMD5", "sbValueBeforeMS5", "sbValueBeforeMDLE", "sbValueInsideAMD512", "sbValueBeforeND45", "sbValueFrontMD65", "sbValueDefMD45", "sbValueBeforeLM20", "sbValueBeforeMOD25", "sbValueAfterMD25", "sbValueBeforemd5", "sbValueBeforeAND2", "sbValueBeforeMD65", "sbValueFrontMD5", "sbValueBeforeMD3", "sbValueBeforemdLE", "sbValueBeforeANDFive", "sbValueBeforeLM5", "sbValueBeforeMT5", "sbValueBeforeMD305", "sbValueAfterMD5", "sbValueAfterMD05", "sbValueFrontMD20", "sbValueBeforeAND5", "sbValueBeforeND2", "sbValueInsideMD2", "sbValueBeforeMT20", "sbValueBeforemdOK", "sbValueBeforeMON305", "sbValueAfterMD2", "sbValueAfterMS45", "sbValueBeforeSD5", "sbValueBeforeAMD2", "sbValueBeforeMON512", "sbValueBeforeMD2", "sbValueInsideAMD5", "sbValueAfterMS25", "sbValueAfterMD3", "sbValueBeforeLM65", "sbValueBeforeMD05", "sbValueBeforeMD512", "sbValueBeforemd45", "sbValueBeforeMDFive", "sbValueDefmd2", "sbValueBeforeLM2", "sbValueInsideMD305", "sbValueBeforeAND05", "sbValueAfterMS5", "sbValueBeforeMS45", "sbValueBeforeMT2", "sbValueBeforeMED5", "sbValueBeforeMED25", "sbValueBeforeMS3", "sbValueDefmd45", "sbValueBeforePD2", "sbValueAfterMDOK", "sbValueFrontMD2", "sbValueFrontLM20", "sbValueFrontLM5", "sbValueBeforeMD25", "sbValueBeforeMT05", "sbValueBeforeAMD512", "sbValueBeforeMDNot", "sbValueBeforemd2", "sbValueInsideMD5", "sbValueAfterMDNot", "sbValueBeforeMTFive", "sbValueBeforeMOD3", "sbValueBeforeSDNot", "sbValueBeforeMD45", "sbValueBeforeMED3", "sbValueBeforeMEDNot", "sbValueBeforeSD2", "sbValueDefMD5", "sbValueBeforeMED45", "sbValueBeforeMT65", "sbValueBeforeMON5", "sbValueFrontLM2", "sbValueAfterMDFive", "sbValueInsideMD512", "sbValueBeforePDOK", "sbValueInsideAMD2", "sbValueFrontLM65", "sbValueInsideAMD305", "sbValueBeforePD5", "sbValueBeforeND5", "sbValueAfterMDLE", "sbValueBeforeMS25", "sbValueDefmd5", "sbValueBeforeMON2", "sbValueBeforeMED2"], "time": ["estamp", "t", "Time", "ime", "clock", "age", "order", "TIME", "id", "length", "user", "total", "now", "ty", "year", "timer", "tc", "runtime", "duration", "counter", "hour", "name", "start", "rate", "date", "etime", "frame", "timeout", "value", "event", "size", "lock", "sequence", "tim", "port", "times", "ts", "window", "system", "race"], "rand": ["rid", "mid", "pid", "gz", "rd", "dr", "ng", "range", "max", "inv", "uid", "pick", "rot", "id", "reg", "md", "rest", "with", "trust", "fine", "did", "sys", "gt", "r", "Rand", "sid", "ripp", "hash", "nd", "res", "rc", "nt", "rh", "grad", "rate", "init", "rt", "frac", "dist", "kick", "sample", "rank", "std", "roll", "rss", "random", "z", "round", "cr", "seed", "and"], "array": ["angular", "stage", "save", "app", "binary", "v", "RAY", "instance", "arr", "range", "stack", "data", "rays", "archive", "external", "length", "ash", "batch", "collection", "assets", "at", "string", "storage", "audio", "ami", "hash", "our", "aw", "upper", "map", "var", "amount", "arrow", "atomic", "ray", "list", "value", "row", " Array", "number", "Array", "area", "vector", "ashes", "random", "angle", "share", "aster", "ary"], "strTemp": ["drTemp", "frTem", "txtTemp", "txtTem", "stringTest", "txtTr", "STRtemp", "strUnt", "STRNew", "hexTr", "arrTest", "stringTem", "strMods", "drTem", "stringTemp", "arrTemp", "strTest", "strTem", "frTemplate", " strCmd", "drPtr", "stringPtr", " strPtr", "hexTemp", "stringUnt", "strCmd", "arrTem", " strTr", "brTemp", "strTr", "arrtemp", "brPtr", "arrMods", " strNew", "arrNew", "txtCmd", " strTemplate", "hexCmd", "strPtr", "STRTem", " strTest", " strtemp", "strTemplate", "brTem", "frTemp", " strUnt", "hexTem", " strTem", "drMods", "STRTemp", "frPtr", "brTemplate", "arrUnt", "strNew", "arrPtr", "strtemp", "stringMods"], "i": ["c", "li", "y", "v", "bi", "in", "ii", "phi", "multi", "xi", "I", "u", "id", "ui", "ind", "mi", "b", "gu", "ogi", "gi", "uri", "im", "q", "hi", "cli", "x", "ki", "ti", "index", "ci", "pi", "chain", "ji", "name", "a", "iq", "qi", "si", "init", "ix", "di", "info", "ini", "ei", "num", "it", "yi", "sim", "j", "\u0438", "m", "ai", "us", "ic"]}}
{"id1": "659316", "id2": "19322910", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"argv": ["argvs", " argc", "argV", "argc", "argsc", "Argm", "suppp", "callv", "argsV", "argss", " argm", "Argc", " argvs", "callp", "callV", "Args", "suppvs", " argp", "Argv", "argsm", "suppV", "callvs", "ArgV", "suppv", "argp", " argV", "argsv", "argm"], "sources": ["servors", " sets", "seets", "servures", " sodes", " soots", "slources", "seodes", "sliders", "inults", "tocks", "sloots", "inets", "sors", " sors", "tiders", "soots", "sults", "seults", "servources", "sodes", "inources", "slocks", "seources", "socks", " socks", " sults", "inodes", "tources", "stets", "servets", "stources", "sets", "siders", "sures", "stures", " sures", "stors", "toots", " siders"], "targets": ["targetgers", "toksets", "tankgers", "tokends", "Targets", "tokgers", "Topches", "tassends", "tanges", "targgers", "toolsarggers", " targens", "toolsargsets", "targetens", "topens", "Targends", "topends", "targetsets", "tangens", "toolsargets", "tangches", " targes", "topets", "tokes", "tassets", "targetets", "tassches", "Targches", "tasses", " tangends", "tokens", " targends", "tokets", "targens", "tankets", " tangens", "Topets", "targches", "topches", "tanksets", "targsets", "toolsankgers", "toolsargens", "topes", "toolsankets", "Targes", "toolsankens", " tanges", "Topes", "targends", "toolsanksets", "tangends", "Topends", "tangets", "tankens", "targes", " tangets"], "srclen": ["srklog", " srplade", "srklue", "rsclogn", "srselen", "srselog", "srklogn", "srccue", "rsclog", "srclue", " srpln", "srseln", "srccen", "srselade", "rsccog", "rsclue", " srclength", "srklen", "srCLen", "srpln", "srselue", "srccog", " srcln", "srselogn", " srplen", "srselength", "srplen", "srplade", " srclade", " srplength", "rsccen", "srclogn", "srclength", "srplength", "srCLade", "rsccue", "srcln", "rsccogn", "srccogn", "srclog", "srCLength", "rsclen", "srclade", "srCLn"], "source": ["scan", "scale", "create", "reader", "buffer", "score", "status", "copy", "src", "scope", "select", "this", "file", "inner", "trace", "secure", "iter", "console", "sys", "SOURCE", "input", "ource", "cache", "start", "Source", "root", "me", "get", "escape", "wrapper", "service", "match", "template", "search", "query", "info", "force", "internal", "link", "sequence", "local", "standard", "context", "from", "site", "null", "style", "store", "resource", "parent", "s", "sp", "ser", "set", "system"], "tgt": ["tgn", "tegt", " tht", "tegn", "tpt", "nht", " targ", "warg", "tetarget", "itarg", "Targ", "itht", "ngn", "targ", "tearget", "itgt", "teht", "ngt", "itarget", "tht", "ittarget", "starget", "wtarget", "stgt", "Tht", "tept", "npt", "tearg", "wgt", " tpt", "sttarget", "warget", " ttarget", "ttarget", "starg", " tgn", "Tgt", "Target"], "target": ["peer", "tmp", "buffer", "stable", "top", "manager", "copy", "member", "arget", "base", "dest", "inter", "next", "trace", "secondary", "localhost", "sys", "gt", "out", "child", "ARGET", "pointer", "mask", "path", "goal", "wrapper", "match", "touch", "template", "channel", "proxy", "local", "internal", "rel", "link", "output", "null", "socket", "to", "table", "parent", "resource", "trap", "writer", "owner", "handler", "bolt", "Target"], "deletes": ["Deels", "dulets", "desges", "desleted", "seles", "delves", "delletes", "delets", "duletes", "seletes", "dules", "seels", "seleted", "leletes", "deles", "Deles", "deels", "Deletes", "desets", "desletes", "dellets", "deves", "dleted", "deleted", "dges", "desves", "duges", "duels", "lelets", "duleted", "deets", "leets", "leves", "dletes", "deges", "Deleted", "dlets", "deslets"], "del": ["compl", "dl", "ele", "le", "cl", "dis", "dr", "se", "inv", "let", "re", "nl", "rl", "des", "ne", "rem", "md", "col", "el", "els", "tl", "rol", "l", " dele", "dec", "ls", "tr", "pel", "de", "elt", "err", "bl", "nt", "pl", "len", "delete", "cel", "vet", "kl", "ll", "Del", "rel", "syn", "sel", "dem", "def"]}}
{"id1": "7757297", "id2": "5759961", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["save", "create", "request", "close", "run", "upload", "download", "sub", "print", "post", "update", "input", "edit", "open", "login", "format", "accept", " submission", "send", "execute", "launch", "apply", "Submit", "process", "report", "display", "form"], "uri": ["du", "location", "range", "id", "doi", "ui", "file", "prefix", "course", "wiki", "origin", "path", "pi", "address", "title", "name", "term", " URI", "password", "ur", "iri", "description", "http", "href", "info", "directory", "URI", "campus", "link", "message", "URL", "subject", "report", "resource", "msg", "i", "ri", "source", "filename"], "Exception": ["Exit", "Warning", "T", "Status", "Class", "Application", "ception", "Event", "Document", "Error", "Throw", "API", "Default", "Message", "Connection", "E", "null", "Result", "X", "EX", "Response", "Failure"], "encodedrdf": ["encodedridfc", "encodedridf", "encuredrdf", "encodingrsfs", "encodeddrp", "encodingrsl", "encodingrsf", "encodeddrf", "encuredrl", "encuredrdl", "encodedrsfx", "encodedwsfx", "encodedwsf", "encodedrf", "encodedwsl", "encodedrsfs", "encodedrdp", "encodedrdfx", "encodedrl", "encodedrsf", "encodingrdl", "encodedrtfx", "encodingrdfs", "encodeddrl", "encodedrp", "encodingrdfx", "encodeddrfc", "encodedrtfs", "encodedrdfs", "encodedridl", "encodingrdf", "encodedrfc", "encuredrfc", "encuredrf", "encodedrtf", "encodedwsfs", "encodedrsl", "encuredrp", "encodedridp", "encodedrtl", "encodedrdfc", "encodingrsfx", "encodedrdl", "encuredrdfc", "encuredrdp"], "url": ["sb", "li", "location", "build", "ul", "conn", "nl", "mount", "str", "base", "log", "file", "loc", "l", "b", "web", "https", "r", "client", "ssl", "cert", "browser", "ls", "open", "sl", "address", "name", "ur", "p", "http", "service", "con", "ll", "link", "URL", "m", "socket", "resource", "Url"], "connection": ["c", "generation", "io", "in", "conn", "server", "ticket", "document", "l", "relation", "using", "statement", "result", "still", "web", "https", "session", "creator", "client", "established", "index", "application", "open", "connected", "database", "communication", "command", "n", "position", "description", "network", "channel", "number", "con", "Connection", "link", "response", "context", "condition", "output", "message", "entry", "socket", "handler", "function", "resource", "ion", "writer", "connect"], "lastUser": ["LastUser", "LastCategory", "lastCategory", "latestCategory", "LastAuthor", " lastAuthor", "latestAuthor", "latestDate", " lastDate", "lastDate", "latestUser", "lastAuthor", "LastDate", " lastCategory"], "out": ["io", "v", "gr", "write", "OUT", "in", "inv", "conn", "rem", "help", "server", "raw", "log", "pool", "print", "inner", "serv", "at", "ent", "sys", "client", "cmd", "line", "cache", "check", "res", "err", "obj", "chain", "nt", "up", "format", "conv", "n", "screen", "co", "pretty", "p", "init", "timeout", "json", "all", "o", "list", "net", "query", "con", "conf", "outs", "it", "ch", "output", "Out", "report", "ex", "null", "to", "table", "writer", "cont", "ou", "window", "aos", "set", "txt"]}}
{"id1": "3731077", "id2": "530882", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "downloadfile", "copyfile", "downloadFiles", " cpfile", " cpDirectory", "CopyDirectory", "downloadFile", "CopyFiles", "CopyFile", "copyDirectory", "Copyfile", "downloadDirectory", " cpFile", " cpFiles"], "from": ["fr", "org", "or", "se", "range", "view", "part", "data", "por", "html", "str", "bean", "base", "with", "file", "add", "original", "so", "before", "at", "form", "string", "origin", "as", "input", "path", "term", "a", "rom", "old", "start", "un", "From", "url", "without", "of", "orig", "f", "info", "query", "local", "link", "vol", "ol", "st", "name", "pro", "reset", "star", "config", "db", "s", "what", "source", "by"], "to": ["t", "th", "TO", "org", "tom", "top", "te", "or", "phi", "etc", "po", "tree", "too", "base", "html", "auto", "total", "tt", "full", "this", "dest", "file", "pt", "temp", "eto", "none", "no", "two", "nt", "To", "name", "on", "co", "pretty", "f", "token", "target", "o", "template", "one", "it", "toc", "tu", "bo", "must", "size", "st", "that", "null", "ta", "output", "into", "parent", "oto", "table", "by"], "parentDir": ["masterDirectory", "rootFolder", " parentFolder", " parentdir", " parentDirectory", "ParentDir", "netDir", "ParentFolder", " parentFile", "masterFolder", "masterFile", "Parentdir", "ParentFile", "parentFile", "rootdir", "ParentDirectory", "parentDirectory", "masterDir", "netdir", "rootDir", "parentFolder", "parentdir", "netFolder", "rootFile", "netFile"], "in": ["bin", "din", "min", "sin", "re", "id", "inc", "isin", "rin", "ind", "mi", "raw", "en", "print", "inner", "inf", "ain", "inside", "vin", "mc", "update", "is", "input", "al", " IN", "up", "In", "on", "irc", "get", "gin", "init", "ma", "all", "win", "o", "IN", "ini", "conf", "con", "one", "net", "it", "local", "ir", "ins", "inn", "cin", "doc", "config", "xml", "i", "mm", "ri", "source", "form"], "out": ["c", "t", "io", "v", "can", "write", "or", "ne", "os", "auto", "file", "go", "b", "ln", "ro", "at", "na", "ot", "gt", "oss", "sys", "client", "cmd", "no", "gc", "res", "nin", "err", "obj", "nt", "conv", "op", "n", "on", "co", "all", "list", "o", "net", "con", "one", "cn", "it", "outs", "vol", "output", "Out", "css", "ex", "null", "ns", "again", "cos", "g", "ion", "i", "ou", "aos", "OUT", "outer"], "ic": ["ip", "c", "ico", "pic", "icy", "ac", "iac", "mic", "inc", "iu", "isc", "ik", "arc", "icon", "wic", "bc", "IC", "cus", "tc", "ics", "ot", "cc", "nic", "icc", "ci", "ric", "cu", "rc", "ican", "eric", "irc", "co", "ix", "vc", "it", "pc", "fc", "ins", "sic", "cin", "aic", "i", "tic"], "oc": ["c", "ico", "pic", "oct", "ocon", "OC", "oly", "ocr", "ac", "ict", "oe", "yo", "mic", "mot", "arc", "osc", "cus", "tc", "ot", "roc", "nic", "gc", "oca", "ci", "ric", "oci", "oco", "cu", "og", "ec", "ucc", "irc", "ox", "voc", "co", "soc", "unc", "aco", "o", "vc", "toc", "pc", "anc", "cos", "cot", "nc", "aic", "alloc"]}}
{"id1": "21921000", "id2": "804637", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"parse": ["scan", "save", " dissect", "fork", "read", "close", "build", " evaluate", "se", "run", " solve", "next", "construct", " parser", "install", "start", "handle", "init", "execute", "apply", "process", " scan", " ingest", " eval", " merge"], "url": ["lb", "dl", "cl", "build", "ul", "conn", "nl", "mount", "log", "loc", "lr", "l", "b", "web", "https", "r", "client", "ssl", "cert", "ls", "open", "job", "mail", "sl", "sur", "bel", "un", "ur", "f", "pl", "http", "hl", "ll", "link", "cm", "abs", "au", "ret", "URL", "Url"], "con": ["c", " Con", "cl", "can", "sc", "conn", "ver", "re", "Con", "connection", "Conn", "pen", " conn", "bc", "ln", "ain", "mc", "cp", "cc", "client", "cons", "CON", "conv", "sur", "connect", "login", "ran", "un", "co", "soc", "conf", "cur", "cn", "cm", "fc", "dial", "com", "cin", "nc", "cf"], "bStream": ["rbStreamer", "rstream", " bRead", "fRead", "vRead", "bstream", " bStreamer", " bChannel", "rbRead", "bStreamer", "rbstream", "vSteam", "rStreamer", "fStreamer", "rStream", "vReader", "rbStream", " bstream", "rSteam", " bReader", "fStream", "bbReader", "bbStream", "vStream", "fChannel", "bbSteam", "bSteam", " bSteam", "rbChannel", "bReader", "bChannel", "bbRead", "rbSteam", "bRead"], "str": ["c", "t", "fr", "ctr", "text", "gr", "Str", "arr", "cont", "comment", "pos", "pr", "print", "l", "b", "cs", "comm", "pt", "e", "string", "console", "r", "out", "line", "dec", "input", "tr", "res", "br", "err", "obj", "spec", "n", "req", "p", "list", "cur", "STR", "it", "vol", "sp", "st", "j", "char", "z", "g", "i", "s", "cr", "msg", "source", "txt"], "tokens": ["stokets", "toksets", "tobkens", "todkens", "tokseds", "tokskens", "tkeds", "tobTokens", "todences", "tkens", "pobTokens", "takets", "todTokens", "tobents", "Tokens", "tokents", "toksents", "tokeds", "Tokets", "pokkens", "pokens", "pokTokens", "todets", "tkets", "todents", "tokets", "stokkens", "toksTokens", "stodets", "tolences", "stodences", "stodkens", "pokents", "toksens", "todens", "takeds", "tolets", "Tokents", "tkents", "Tokeds", "Toksets", "Tokseds", "Toksents", "stokences", "tokkens", "tobens", "pobens", "Toksens", "tolens", "stodens", "takents", "stokens", "pobents", "takens", "tolkens", "pobkens", "tokTokens", "toksences", "tokences"], "charCode": ["characterFore", "characterType", "cellcode", "charFore", "cellName", "CharacterFore", "CharFore", "charName", "CharacterName", "charactercode", "charcode", "cellType", "characterCode", "cellCode", " charcode", "CharacterCode", " charName", "charType", " charType", "characterName", "CharName", "CharCode"], "value": ["version", "scale", "VALUE", "zone", "v", "type", "serial", "score", "instance", "average", "default", "max", "data", "category", "total", "currency", "percent", "language", "result", "price", "Value", "family", "pain", "step", "dollar", "address", "format", "position", "feature", "description", "property", "val", "number", "hello", "sample", "sequence", "sum", "function", "money", "current", "key", "system"], "unit": ["scale", "io", "type", "stable", "nu", "volume", "category", "base", "u", "unknown", "dimension", "relation", "currency", "component", "prefix", "dir", "string", "uni", "nit", "util", "chain", "term", "name", "format", "variable", "un", "note", "command", "layout", "number", "unsigned", "num", "crit", "Unit", "it", "group", "block", "sum", "money", "set", "units", "class"]}}
{"id1": "18731843", "id2": "189963", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doBody": [" sendContent", " writeHead", "loadbody", " sendHead", " sendbody", " writebody", " dobody", "loadContent", " doHead", " writeContent", " writeBody", "loadHead", " doContent", " sendBody", "loadBody"], "req": ["fr", "ps", "request", "gr", "aj", "inv", "ctx", "js", "reg", "urg", "quick", "sq", "jp", "express", "q", "cmd", "proc", "hr", "res", "err", "quest", "qt", "exec", "Request", "pkg", "http", "conf", "query", "crit", "wx", "Requ", "tx", "def", "j", "rec", "pro", "qq", "requ"], "resp": ["respond", "cl", "trans", "Resp", "re", "js", "Rep", "respons", "esp", "pos", "comm", "next", "serv", "wr", "result", "Res", " res", "out", "client", "res", "err", "exp", "soc", "http", "wa", "response", "rel", "vol", "output", "ret", "rec", "Response", "RES", "sp", "sol", "rep", "def"], "bis": ["avi", "atis", "sb", "rison", "ads", "iris", "bi", "bh", "lin", "bs", "aus", "os", "phis", "isin", "mi", "oi", "isi", "pins", "webkit", "bt", "bits", "idis", "inet", "oss", "is", "bes", "bat", "pin", "lis", "iso", "nis", "bie", "lbs", "bps", "bil", "ubis", "ris", "ses", "onis", "los", "be", "ais", "mis", "iss", "ios", "fps", "obs", "bid", "cin", "zo"], "bos": ["tis", "gs", "dos", "nos", "zb", "bin", "bh", "bi", "bs", "fits", "os", "BS", "oi", "bas", "vas", "pins", "bits", "ts", "acs", "ows", "oss", "bes", "oos", "is", "asket", "ys", "asis", "its", "uts", "banks", "bil", "eros", "ubis", "stones", "oops", "ols", "los", "fs", "jas", "outs", "bo", "ios", "obs", "ubs", "ods", "mes", "uds", "aos", "tes"]}}
{"id1": "19810820", "id2": "18613870", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFileFile", " copyFileFile", " copyByteStream", "copyByteFile", " copyFilechannel", " copyFileschannel", " copyStreamFile", "copyFileStream", " copyByteChannel", " copyBytechannel", " copyFilesChannel", " copyStreamchannel", " copyByteFile", " copyStreamStream", "copyFilechannel", "copyByteChannel", " copyFilesFile", " copyStreamChannel", " copyFileStream", "copyBytechannel", "copyByteStream", " copyFilesStream"], "src": ["sync", "sb", "img", "ctr", "tmp", "sr", "sc", "in", "rl", "bs", "rx", "usr", "js", "dest", "loc", "sq", "RC", "sys", "usc", "SOURCE", "input", "ls", "sl", "rc", "req", "start", "Source", "SourceFile", "init", "rt", "sec", "cur", "rs", "rel", "st", "from", "obs", "ins", "syn", "sf", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dst": ["dth", "dut", "Dest", "ddest", " dth", "sest", "Dth", "dest", "Dnd", "Dut", "dnd", "Dist", " dnd", "bdest", "sth", " dest", "snd", "sst", "best", "jdest", "bist", "jst", " ddest", " dist", "dist", "Dst", "jut", "jest", "sdest", "bst", "Ddest", "sut"], "preserveModificationTime": ["preserveModifyTime", "preserveModificationTimes", "preserveModificationsTim", "preserveQualificationsLength", "preserveModifyingPoint", "preserveModificationsPoint", "preserveSpecificationTim", "preserveSpecificationsTim", "preserveSpecificationTime", "preserveQualificationsPoint", "preserveModifierTimes", "preserveSpecificationTimes", "preserveQualificationsTimes", "preserveQualificationPoint", "preserveSpecificationsTime", "preserveModificationsTime", "preserveModifyingTimes", "preserveModificationsTimes", "preserveModifyingTime", "preserveModificationPoint", "preserveQualificationsTime", "preserveModifyLength", "preserveQualificationTimes", "preserveModificationsLength", "preserveModifyPoint", "preserveModificationLength", "preserveQualificationTime", "preserveModifierTim", "preserveModifiedTim", "preserveSpecificationsTimes", "preserveModifierTime", "preserveModificationTim", "preserveModifiedTimes", "preserveModifyingLength", "preserveQualificationLength", "preserveModifiedTime", "preserveModifyTimes"], "inputChannel": ["inputGray", "Inputchannel", "evalChannel", "InputBuffer", "evalChan", "outputStream", "hiddenCategory", "entityChannel", "InputChan", "openChan", "inputChuck", "outputchannel", "innerChannel", "openChannel", " inputBuffer", "hiddenChannel", "hiddenListener", "innerchannel", " inputCategory", "interfaceChannel", " inputStream", "interfaceCategory", "openGray", "infoChannel", " inputGray", "outputBuffer", "inputCategory", "InputChannel", "inputStream", "outputChan", "innerStream", "openConnection", "inputBuffer", "inputConnection", "inputChan", "entityChan", "clientGray", "infoChan", "innerChan", "infochannel", "interfaceListener", " inputChan", "inputchannel", "InputStream", "infoChuck", " inputConnection", "clientConnection", "clientChannel", "clientChan", " inputChuck", "outputChuck", " inputchannel", "inputListener", " inputListener"], "outputChannel": ["displayChan", "doubleChan", "outputStream", "displayChannel", "outputButton", " outputchannel", " outputConnection", "OutputManager", "putchannel", "displayButton", "putButton", "outputchannel", " outputStream", "inputField", "OutputStream", "doubleField", "webchannel", "OutputChannel", "writeChannel", "writeStream", "doubleInstance", "coinField", "webManager", " outputChan", "doubleChannel", " outputButton", "writeChan", "outputChan", "inputInstance", "inputConnection", "putChan", " outputManager", "outputConnection", "inputChan", "outputManager", "OutputChan", "outputField", "coinChannel", "coinInstance", "OutputConnection", "coinChan", "putChannel", "writeManager", "writechannel", "Outputchannel", "displaychannel", "webChannel", "outputInstance", "inputManager"], "length": ["history", "text", "then", "count", "details", "buffer", "ENGTH", "padding", "Length", "type", "needed", "max", "volume", "data", "base", "full", "available", "l", "left", "join", "component", "HH", "limit", "shape", "library", "duration", "family", "time", "end", "partial", "term", "loop", "capacity", "amount", "position", "width", "start", "present", "len", "load", "height", "json", "number", "required", "list", "value", "expected", "all", "size", "sequence", "bytes", "offset", "ength", "to"], "total": ["meta", "t", "checked", "scale", "count", "stable", "translation", "max", " Total", "quant", "active", "human", "base", "unknown", "this", "Total", "full", "raw", "used", "available", "complete", "free", "bar", "no", "equal", "zero", "index", "good", "successful", "title", "created", "note", "amount", "description", "all", "info", "number", "eta", "otal", "required", "num", "local", "size", "sequence", "valid", "sum", "ta", "done", "offset", "last", "to", "unique", "less", "current", "summary"]}}
{"id1": "22993368", "id2": "5441579", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "22135199", "id2": "4118412", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCodingSizeFile", " testCodingemptyFile", " testCachingEmptyFile", " testCachingEmptyfile", " testCodingSizefile", " testCachingEmptyStream", " testCodingemptyfile", " testCodingEmptyfile", " testCodingFullFile", " testCachingemptyFile", " testCodingSizeStream", " testCachingEmptyFiles", " testCodingFullStream", " testCodingFullFiles", " testCodingEmptyFiles", " testCachingemptyFiles", " testCodingEmptyStream", " testCodingFullfile", " testCachingemptyStream", " testCachingemptyfile", " testCodingemptyStream", " testCodingemptyFiles", " testCodingSizeFiles"], "baos": ["boOs", "taOs", "caos", "baOS", "caOs", "boos", "baOs", "Baoss", "BaOs", " baOs", " baoS", " baoss", "baoss", "Baos", "boo", "aoo", "taoS", "Bao", "aoOS", "cao", "booss", " baOS", "aoOs", "caoS", "aoos", "tao", "boOS", "baoS", "taos", "bao", " bao"], "channel": ["c", "io", "buffer", "can", "chan", "stream", "Channel", "connection", "server", "controller", "file", "batch", "component", "session", "console", "client", "out", "queue", "input", "cache", "application", "chain", "command", "password", "room", "caster", "network", "service", "container", "con", "ch", "cm", "block", "message", "context", "socket", "handler", "resource", "window", "system"], "params": ["ps", "details", "tags", "Parameters", "ctx", "data", "parts", "headers", "services", "pool", "pins", "options", "sys", "radius", "ams", "proc", "ops", "par", "AMS", "Par", "pi", "phys", "spec", "name", "param", "pps", "password", "p", "pretty", "names", "caps", "properties", "json", "conf", " parameters", "rs", "types", "settings", "fps", "cms", "config", "cmp", "mm", "limits", "units"], "outbuf": ["inbuf", "outbuffer", "outBuffer", "outputbuff", " outBuffer", " outbuff", "outbuff", " outrb", "OutBuffer", "outputbuf", "inBuffer", "Outbuf", "inbuff", " outbuffer", "inbuffer", "Outbuffer", "Outbuff", "inrb", "outputrb", "outrb", "outputbuffer"], "metrics": ["mutrices", "monrors", "mutrics", "matric", "metric", "metths", "monric", "Metrors", "monrix", "mtcs", "Metrix", "matrics", "metrors", "matrix", "mtrices", "metrix", "metrices", "Metrics", "mtrics", " metcs", "metcs", "mtths", "mutcs", " metths", "monrics", "Metric", "mutths", " metrices", "matrors"], "encoder": ["enoded", "execrier", "enoding", "ecramer", "execoding", "encoded", " encoding", "enressor", " encramer", "eciever", "Encramer", "Encoding", " encuter", "encrier", "encressor", "enramer", "Encrier", " encoded", "Encuter", "Encoder", "enciever", "enrier", "ecressor", "ecoding", "encramer", " encrier", " encressor", "ecoded", "ecoder", "executer", "encoding", "ecrier", "encuter", "enoder", "Enciever", "eniever", "execoder"], "tmpFile": ["fakefile", "tempFilename", "imgKey", " tmpfile", "txtfile", "tmpPath", "tmpKey", "fakeFilename", "mpName", "tempFile", "testfile", "testFile", " tmpKey", "imgfile", "imgFILE", " tmpFiles", "imgFile", "mpFile", "tmpfile", "txtPath", "tmpFiles", "tempFILE", "tempFiles", "tmpName", " tmpPath", "mpFilename", "testName", "fakeFiles", " tmpFILE", "tmpFILE", "testFilename", "txtFile", " tmpFilename", "fakeFile", "tmpFilename", "tempPath", "tempKey", "mpfile", " tmpName", "tempfile"], "fout": ["sfOut", "vout", "sfouts", "fullbal", "fOUT", "foutput", "vouts", "lout", "fOut", "dfoutput", "fbal", "wOut", "fao", "vao", "fullout", "wout", "fullOUT", "loutput", "vOut", "fulloutput", "wouts", "dfOUT", "dfout", "sfout", "lbal", "wao", "dfbal", "fouts", "lOUT", "sfao"], "wrtout": ["wrdn", "wrtwriter", "Wrtout", "wRTwriter", "wrcwriter", "wwtex", "hwrtex", "hwrtw", "hwrtout", "Wrdwriter", "wltgen", "wrdgen", "wrtin", "wgtout", "wrtgen", "hwrcwriter", "wRTout", "ewltgen", "wwtout", "hwrcw", "wrcex", "wrdio", "hwrtwriter", "wttout", "ewrtgen", "ewrtwriter", "ewltin", "wltin", "wrtex", "wdrout", "hwrcout", "ewltwriter", "ewrtout", "Wrtn", "wttio", "wrdout", "Wrtio", "wgtw", "wRTn", "wrtw", "wgtex", "wrcout", "wltout", "wdrin", "Wrtwriter", "wRTio", "Wrdout", "wwtw", "ewrtin", "wltwriter", "wrdwriter", "wwtwriter", "wdrgen", "ewltout", "Wrdn", "wgtwriter", "wttn", "wrtio", "hwrcex", "wdrwriter", "wttwriter", "wrdin", "wrtn", "Wrdio", "wrcw"], "fchannel": ["wchannel", "flconsole", "Fconsole", " fconsole", "fcontroller", "flnet", "wconnection", "Fchannel", "flchannel", " fchan", "fcchannel", "fchan", "fconnection", "wchan", "fChannel", " fconnection", " fChannel", "FChannel", " fcontroller", "fnet", "wcontroller", "fcchan", "fccontroller", "flChannel", "fcconnection", "fconsole", " fnet", "Fnet"], "s": ["qs", "gs", "c", "t", "sg", "ss", "v", "js", "str", "csv", "sv", "sq", "gets", "b", "e", "string", "r", "ds", "is", "ls", "ws", "a", "n", "p", "f", "rs", "S", "w", "j", "m", "g", "h", "ts", "i", "ns"]}}
{"id1": "6457199", "id2": "300397", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doRequest": ["doQuery", "dorequest", "handlerequest", "processRequest", "doResponse", " doResponse", "handleResponse", "processrequest", " doQuery", " dorequest", "handleQuery", "handleRequest", "processResponse", "processQuery"], "request": ["create", "view", "each", "re", "user", "select", "QUEST", "document", "complete", "transform", "input", "reference", "application", "open", "setup", "address", "command", "quest", "position", "req", "get", "project", "Request", "http", "frame", "search", "first", "hello", "query", "question", "context", "message", "seek", "report", "reset", "initial", "call", "xml", "forward"], "response": ["reply", "respond", "content", "onse", "fire", "exit", "write", "status", "view", "re", "connection", "respons", "release", "server", "document", "image", "print", "relation", "next", "continue", "e", "result", "console", "render", "out", "application", "res", "format", "position", "resp", "send", "feed", "http", "frame", "json", "channel", "service", "block", "context", "output", "message", "display", "report", "reset", "socket", "xml", "Response", "writer", "page", "header"], "path": ["text", "where", "binding", "location", "kind", "type", "method", "near", "patch", "PATH", "mount", "host", "base", "core", "key", "parts", "select", "full", "raw", "log", "prop", "test", "length", "ath", "print", "physical", "prefix", "trace", "route", "dir", "uri", "string", "transform", "pattern", "pointer", "input", "index", "right", "alias", "policy", "primary", "partial", "Path", "chain", "name", "format", "root", "url", "p", "pkg", "relative", "qualified", "json", "href", "template", "api", "local", "context", "message", "ex", "parent", "port", "clean", "error", "filename"], "internal": ["managed", "binary", "bin", "inline", "in", "uid", "central", "back", "id", "invoke", "external", "this", "inter", "inner", "original", "skin", "common", "identified", "inside", "ident", "console", "origin", "virtual", "normal", "impl", "index", "alias", "primary", "generic", "name", "orig", " external", "url", "Internal", "init", "relative", "regular", "template", "api", "local", "standard", "rel", "context", "ret", "valid", "entry", "real", "initial", "intern", "san"], "resource": ["object", "create", "binary", "buffer", "instance", "range", "re", "stream", "connection", "release", "core", "controller", "file", "region", "component", "image", "print", "result", "uri", "console", "pointer", "reference", "library", "res", "address", "resolution", "handle", "url", "media", "network", "channel", "directory", "service", "record", "resources", "Resource", "context", "local", "process", "entry", "socket", "store", "exclusive", "model", "remote", "source", "system"], "mimeType": ["mimeName", "mimesStyle", " mimesType", " meshType", " mimesTypes", "MimeTypes", "Mimetype", "mimeStyle", "mimeTypes", "miscTypes", "mtimeName", "mtimeType", " meshtype", "mimesType", "mimesPolicy", "miscType", "MetyType", "metytype", "metyName", "Metytype", "meshStyle", "misctype", "mimesTypes", "meshtype", "mIMEName", "MimeType", " mimetype", " meshName", " mimeName", "MetyName", "maxType", "metyPolicy", "mIMEtype", "meshType", "metyTypes", "MimeName", " meshStyle", " mimesStyle", "miscName", "mIMEType", " mimePolicy", "mimePolicy", "mtimeStyle", "meshName", "metyStyle", "MetyTypes", "maxPolicy", "mIMETypes", " mimeTypes", "maxStyle", "mIMEStyle", "mimetype", "metyType", "mtimetype", " mimeStyle", " mimesPolicy", "maxTypes"], "is": ["ains", "iris", "in", "es", "sis", "isin", "bis", "isc", "isi", "mus", "gets", "has", "cs", "isf", "ics", "as", "iso", "ls", "nis", "ys", "ri", "res", "its", "IS", "ris", "si", "are", "fs", "ais", "rs", "isa", "iss", "ios", "isl", "obs", "ins", "icks", "i", "s", "ic", "ism", "Is"], "os": ["et", "nos", "oz", "ss", " Os", "ps", "Os", "es", "bs", "ros", "des", "OS", "oS", "cs", "aos", "ks", "bos", "sys", "ot", "oss", "ds", "as", "oses", "ls", "ys", "res", "er", "ox", "ols", "los", "fs", "o", "ios", "css", "obs", "osi", "oes", "us", "s", "ts", "oos", "ms"]}}
{"id1": "18891988", "id2": "3184073", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["selectfile", "GetFile", "getString", "createfile", "Getfile", "selectString", "getfile", "createFile", "getFilename", "selectFilename", "GetString", "GetFilename", "createFilename", "selectFile", "createString"], "serviceName": ["libraryFamily", "serviceNames", "serverName", "ServiceNames", "serviceCode", " serviceNames", "serverType", "serviceType", "ServiceName", "serviceFamily", "serverCode", " serviceType", "libraryName", "ServiceCode", " serviceCode", "ServiceType", "libraryNames", "ServiceFamily", "libraryType", " serviceFamily"], "wsdlLocation": ["wslPath", "awsolLocation", "wsDLLoc", "wslLocation", "wsDLLocation", "wssdPath", "wsolLocation", "wsollocation", "wsDLFolder", "awsdLoc", "wlFolder", "wdlLocation", "wssdlocation", "awsdlLocation", "wsdllocation", "awsolLoc", "awsdlURL", "wsdlURL", "wsolLoc", "wsDLPath", "wsDLURL", "wsdlPath", "wdlLoc", "awsolURL", "wssdLocation", "wslLoc", "awsollocation", "wsdlocation", "wssdLoc", "wssdURL", "wslFolder", "wsdlFolder", "wsdLoc", "wlLocation", "awsdllocation", "wsdURL", "wssdFolder", "wdlPath", "wlLoc", "awsdLocation", "awsdlocation", "wsDLlocation", "awsdURL", "awsdlLoc", "wlPath", "wsdlLoc", "wsdLocation", "wsolURL", "wdlFolder"], "endpoint": ["idpoint", "startpoint", "startpoints", "startPoint", "beginpoints", " endport", "startword", "endpoints", "beginPoint", " endPoint", "Endpoint", "endline", "idPoint", "startline", "bindPoint", "beginpoint", "endword", " endpoints", "Endpoints", " endline", "bindport", "idline", "Endport", "bindpoint", "idpoints", "endPoint", "endport", "bindpoints", "EndPoint", "beginword", "Endword"], "fileLocation": ["filelocation", "FileLoc", "documentPosition", " filePosition", "FileLocation", "documentlocation", "fileLoc", "documentLocation", "documentLoc", " filelocation", "filePosition", " fileLoc", "Filelocation", "FilePosition"], "tempDir": ["tmpPath", " tempPath", "tmpFolder", "tempFolder", " tempUrl", "tempdir", "tmpDirectory", "TempDirectory", " tempFolder", "tempDirectory", "Tempdir", " tempDirectory", "TempPath", "TempFolder", "TempUrl", "tmpUrl", " tempdir", "tempPath", "tmpDir", "tempUrl", "TempDir", "tmpdir"], "url": ["dl", "li", "location", "build", "ul", "conn", "re", "nl", "mount", "str", "base", "loc", "l", "web", "gl", "uri", "il", "https", "cp", "r", "ssl", "browser", "cert", "ls", "open", "job", "mail", "sl", "up", "sur", "bel", "un", "ur", "f", "pl", "github", "http", "service", "ll", "link", "rel", "ret", "URL", "char", "m", "socket", "ctrl", "cr", "Url", "window"], "WSDLFile": ["WSDLFilename", "WSDLLFile", "WIDDLfile", "WSDLLString", "WNDLfile", "WSDELFile", "WSDELFilename", "WIDDLType", "WSDLSType", "WHDLfile", "WNDDLFile", "WSDMLfile", "WHDLFILE", "WSDLLFILE", "WIDLfile", "WSDLSFile", "WIDDLString", "WIDDLFile", "WHDDLFILE", "WSDDLType", "WIDLType", "WHDLFile", "WNDDLFILE", "WSDLSfile", "WSDLType", "WIDLFile", "WNDDLfile", "WSDLFILE", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDQLfile", "WSDMLFILE", "WSDDLFilename", "WSDDLfile", "WIDLString", "WSDLLType", "WHDDLFile", "WSDQLFile", "WSDQLFILE", "WSDLString", "WSDMLFile", "WSDELFILE", "WHDDLfile", "WNDLFILE", "WNDLFile", "WSDLSString", "WSDLLFilename", "WSDELfile", "WSDDLString", "WSDLfile", "WNDLFilename", "WSDDLFILE"], "tmpWSDLFile": ["tmpWSDLLFILE", "tmpWSDLDFile", "tmpWSDLFILE", "tmpWSDlfile", "tmpWSDDLFile", "tmpWSDLLFilename", "tmpWSDlFile", "tmpWIDDLFilename", "tmpWSDLFiles", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWSDDLfile", "tmpWNDLFiles", "tmpWNDLfile", "tmpWSDDLFiles", "tmpWSDLDFilename", "tmpWSDLLFile", "tmpWNDLFilename", "tmpWSDlFilename", "tmpWSDLDFILE", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWNDDLFiles", "tmpWNDDLFile", "tmpWIDDLfile", "tmpWSDLfile", "tmpWNDDLFilename", "tmpWIDLfile", "tmpWSDDLFILE", "tmpWSDLLfile", "tmpWSDLLFiles", "tmpWSDDLFilename", "tmpWNDDLfile", "tmpWSDLFilename", "tmpWIDLFile", "tmpWIDLFilename", "tmpWIDLFILE", "tmpWSDlFiles"], "inputFile": ["InputFILE", "InputPath", "outputStream", "clientFile", "InputDo", "inputPlace", "inputFILE", "inputfile", "errorfile", "inputDo", "infile", "errorFILE", "tmpStream", "intFile", "InputFiles", "indexfile", "interfaceFile", "Inputfile", "inPath", " inputDo", "interfacePlace", " inputfile", " inputSourceFile", "tmpfile", "intFiles", "outputfile", "indexFile", "outputFILE", "errorFile", "inputStream", "inputPath", "inputSourceFile", "outputFile", "interfacefile", "intfile", "inDo", "intFILE", "tmpFILE", "clientFILE", "InputStream", " inputFiles", "InputFile", " inputFILE", "inputFiles", "clientPath", "inFile", "tmpPlace", "tmpSourceFile", "errorStream", "clientFiles", " inputPath", "interfaceSourceFile", "indexFILE", "indexStream", " inputPlace"], "tmpFile": ["tempFilename", " tmpfile", "tmpPath", "mpPath", "inputFILE", "tempFile", "inputfile", "empFile", " tmpFiles", "empFILE", "mpFile", "empFilename", "tmpfile", "tmpFiles", "tempFILE", "tempFiles", " tmpPath", "tmpFILE", "empfile", "tmpFilename", "tempPath", "mpFiles", "mpfile", "tempfile", "inputFilename"], "in": ["c", "t", "io", "bin", "din", "inv", "conn", "stream", "id", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "ln", "inf", "ain", "source", "r", "client", "is", "ic", "input", "In", "n", "init", "o", "IN", "ini", "it", "ch", "from", "ar", "ins", "inn", "cin", "ai", "cont", "ri", "sin"], "out": ["c", "t", "tmp", "io", "buffer", "can", "write", "inv", "conn", "connection", "ne", "by", "os", "auto", "OU", "log", "file", "this", "en", "pool", "at", "sys", "client", "oss", "cache", "obj", "conv", "n", "on", "ao", "co", "all", "o", "conf", "net", "w", "outs", "ch", "group", "Out", "output", "we", "ex", "cm", "null", "to", "lock", "writer", "ou", "aos", "OUT", "outer"], "con": ["c", "can", "conn", "cone", "re", "cal", "Con", "connection", "Conn", "func", "const", "ln", "ain", "tc", "mc", "cp", "cons", "CON", "ws", "conv", "connect", "login", "un", "ran", "co", "soc", "exc", "win", "sec", "cur", "conf", "num", "cn", "cm", "ch", "fc", "com", "cin", "cos", "nc", "fn", "cf", "acon"], "fileLength": ["FILELength", "ileDuration", "fileLen", "fileSize", "objectLength", "channelDuration", "channelLength", "FILESize", "FILEDuration", "ileLen", "objectDuration", "ileSize", "fileFontSize", "channelFontSize", "objectFontSize", "channelSize", "fileDuration", "FILELen", " fileFontSize", " fileDuration", " fileLen", "objectSize", "ileLength", " fileSize"], "channelIn": [" channeledIn", "channelIN", "chanIn", "ChannelOut", "consoleedIn", "chanOut", "ChannelIN", "consoleIN", "clientin", "clientIn", "channeledIn", "clientSet", "clientOut", "channelin", "ChannelSet", "consoleIn", "chanIN", "ChannelIn", "chanSet", "channelSet", "ChanneledIn", "clientIN", "consoleOut", " channelin", " channelIN", "Channelin"], "channelOut": ["chanIn", "ChannelOut", "chanOut", "channelout", "courseout", " channelConn", "courseOUT", "chanConn", "Channelout", "ChannelConn", "channelConn", "consoleIn", "chanout", "ChannelIn", "consoleOUT", "ChannelOUT", "courseIn", " channelOUT", "courseOut", "consoleOut", "consoleout", " channelout", "channelOUT"], "tmpDocument": ["npDocuments", "tmDoc", "tpMedia", "tpDocument", " tmpDocuments", "tmpdocument", "tempDocument", "mkDoc", "tmpDocuments", "tmDocument", "tpFile", " tmpDoc", "tempDoc", "cpDoc", "mpdocument", " tmpdocument", "mkdocument", "tmdocument", "npDocument", "tpDocuments", " tmpMedia", "mpDocument", "cpDocument", "mpDoc", "cpdocument", "tmpDoc", "npFile", "mkDocument", "tmpMedia", "npMedia", "tempdocument"], "nl1": ["nlOne", "NL2", "nel3", "ln2", "pel1", "lnOne", "nl9", "nl0", "NL0", "nl01", "nr1", "sol9", "rn6", "nr01", "rn1", "rn3", "rnOne", "nrOne", "nl2", "sol0", "pelOne", "NL1", "nl3", "ln1", "nl6", "nel6", "pel01", "nel1", "ln0", "sol2", "NL9", "ln01", "nelOne", "ln6", "ln3", "sol1", "ln9"], "i": ["ip", "ori", "li", "y", "io", "v", "span", "bi", "ii", "k", "multi", "key", "xi", "I", "u", "id", "ui", "mi", "gi", "hi", "cli", "ami", "x", "is", "ie", "ti", "index", "ci", "pi", "ij", "ji", "a", "n", "me", "qi", "si", "ix", "init", "di", "info", "ini", "ims", "o", "it", "sim", "j", "\u0438", "m", "ai", "mu", "us", "ic", "ri", "ms"], "node1": ["layer0", "component2", "component1", "NodeOne", "component0", "Node001", "n0", "node0", "node2", "Node2", "layer91", "node91", "layer1", "Node0", " node91", "node001", "nodeOne", "n1", " node0", " node001", "n91", "layerOne", " node2", "ode001", "ode0", " nodeOne", "ode1", "ode2", "nOne", "componentOne", "Node1"], "tmpOut": ["tempIn", " tmpObj", "TempOUT", "npIn", "TempIn", "cmpout", "tempObj", "tmpIs", "mpOut", "mpObj", "cmpOut", "empOut", "tempout", "npOut", "tempOUT", "npObj", "tmpIn", "cmpIn", " tmpIs", "TempObj", "TempOut", " tmpout", "empIs", "npout", "tempIs", " tmpOUT", "tmpout", "mpIn", " tmpIn", "tmpObj", "tmpOUT", "tempOut", "empout", "mpout"], "retVal": ["RetVal", " retTrue", " retValue", "retTrue", "retValue", "RetValue", "RetTrue", "returnval", " retval", "retval", "returnVal", "Retval", "returnTrue", "returnValue"]}}
{"id1": "3024970", "id2": "539195", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToInputstream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamTooutputFile", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoInputSteam"], "in": ["scan", "c", "io", "bin", "read", "din", "copy", " din", "sin", "inv", "ac", "isin", "rin", "ind", "log", "el", "en", "this", "mi", "inner", "l", "inf", "ain", "inside", "iter", "im", "mc", "q", "r", "is", "input", "nin", "al", "up", "In", "n", "on", "p", "gin", "init", "ini", "IN", "con", "it", "sql", "from", "ins", "inn", "cin", "doc", "ai", "xml", "h", "i", "mm", "ic", "source"], "baout": ["baend", "caio", "caout", "BAin", "BAOut", "boio", "kain", "balog", "baot", "boout", "BAot", "kaout", "Baouts", "calog", " baot", " bain", "caOut", "oaout", "oain", "baouts", "baio", " balog", "Balog", "bain", "BaOut", "Baout", "cain", "abain", "kaend", "boin", "abaout", " baOut", "BAout", "abaot", "boOut", "kaOut", "caouts", "abaOut", "baOut", "oaOut", " baend", "caend", "oaio", " baouts"], "out": ["t", "io", "gr", "OUT", "copy", "OU", "log", "b", "serv", "at", "gt", "sys", "cmd", "client", "oss", "ot", "check", "res", "obj", "up", "conv", "n", "co", "all", "list", "o", "net", "con", " Out", "it", "outs", "Out", "output", "sum", "ex", "null", "to", "g", "ou", "aos", "set"], "count": ["c", "ct", "ctr", "read", "id", "length", "total", "index", "counter", "found", "nt", "start", "amount", "resp", "N", "number", "nb", "num", "size", "sum", "Count", "z", "code", "ount", "current", "skip"]}}
{"id1": "22235113", "id2": "16760971", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallYsl", "unmarshallYplex", "unmarshalXxml", "unmarshallAsml", "unmarshallXplex", "unmarshalYplex", "unmarshalYxml", "unmarshalXml", "unmarshallAsplex", "unmarshallAssl", "unmarshallExml", "unmarshalXsl", "unmarshalYsl", "unmarshallXxml", "unmarshallXsl", "unmarshallAsxml", "unmarshallYxml", "unmarshallEsl", "unmarshallYml", "unmarshallEplex", "unmarshalXplex", "unmarshalYml", "unmarshallEml"], "unmarshaller": ["unmarshilloser", "unmachailer", "unmarshailer", "unmachallers", "unmarshCallable", "unmarshalling", "unmMarshcallier", "unmarshailing", "unmMarshcaller", "unmarshiller", "unmarshallier", "unmarshcalloser", "unmachaller", "unmarshallers", "unmarshCalling", "unmarshailable", "unmMarshallers", "unmMarshcallers", "unmarshalloser", "unmachailing", "unmachailable", "unmachallable", "unmachailers", "unmachalling", "unmarsheller", "unmMarshallier", "unmarshellers", "unmarshelloser", "unmarshCaller", "unmarshcallier", "unmarshcalling", "unmMarshcalloser", "unmarshillier", "unmarshCallers", "unmMarshaller", "unmarshcaller", "unmarshallable", "unmarshailers", "unmarshellier", "unmarshcallers", "unmarshcallable", "unmarshillers", "unmMarshalloser"], "accessUrl": [" accessUr", "AccessPage", "axUrl", "axUr", "ccessurl", "accessurl", "AccessUrl", "AccessDb", "accessPath", "axURL", "ccessUr", "accessibleDb", "accessPage", " accessurl", " accessURL", "execUrl", "accessUr", "aceUrl", "aceURL", "ccessUrl", "AccessURL", "axDb", "accessDb", "accessibleUr", "ccessURL", "acePage", "ccessPage", "accessibleUrl", " accessPath", "uploadUrl", "accessibleURL", "uploadurl", "uploadURL", "aceurl", "uploadUr", "AccessPath", "Accessurl", "AccessUr", "accessURL", "execUr", "execPath", "execURL"], "nameSpace": ["whiteSp", "NameSpace", "namespace", "nameAccount", "wordspace", "linkType", "nameType", "wordSpace", " nameSp", "Namespace", " nameBox", "NameType", "resourceSpace", "linkSp", "whiteAccount", "wordBox", " nameType", "resourceBox", "NameAccount", "nameBox", "nameSp", "whiteSpace", "whitespace", "resourcespace", " nameAccount", "linkspace", "NameSp", " namespace", "linkSpace"], "replace": ["save", "places", "same", "write", "close", "look", "strip", "re", "align", "each", "over", "insert", "sub", "join", "add", "prefix", "register", "place", "string", "update", "transform", "hash", "fill", "map", "format", "cover", "after", "escape", "alter", "old", "wrapper", "use", "pair", "fix", "delete", "match", "repeat", "search", "template", "find", "force", "record", "apply", "group", "change", "tool", "store", "share", "filter", "include", "repl", "gre", "remove"], "with": ["then", "where", "default", "spr", "With", "by", "id", "which", "self", "now", "using", "join", "add", "form", "require", "x", "path", "work", "title", "spec", "format", "without", "handle", "after", "repeat", "value", " WITH", "php", "ith", "via", "apply", "cap", "sql", "context", "tx", "color", "xml", " without", "here", "set"], "url": ["sb", "dl", "ul", "rl", "nl", "mount", "str", "base", "user", "u", "external", "this", "l", "web", "uri", "https", "r", "ssl", "browser", "cert", "impl", "ls", "open", "mail", "ref", "sl", "address", "bel", "ur", "http", "service", "channel", "ll", "link", "URL", "char", "xml", "resource", "Url"], "inputStream": ["outputStream", " Inputstream", "outputstream", "imageSteam", "inSteam", "outputSteam", " inputThread", " InputStream", "inStream", "imageStream", "imagestream", " InputThread", "instream", "activeStream", "inputstream", "activeSteam", " inputSteam", "inputThread", "imageThread", "activestream", " InputSteam", "inputSteam", " inputstream"], "xmlContent": ["textcontent", " xmlcontent", "textContents", "xaValue", "xfName", "mlRaw", "xmlText", "formRaw", " xmlContents", "jsonContents", " xmlName", "textName", "mlcontent", "xmlcontent", "jsonText", "xfContent", "xfContents", "xmlRaw", "mlContent", "mlContents", "xfcontent", "phpText", "mlValue", "mlAccept", "xaContent", "xmlContents", "phpcontent", " xmlValue", "xmlValue", "formContent", "phpContents", "xaText", " xmlText", "mlText", "formText", " xmlRaw", "jsonContent", "formContents", "textText", "phpContent", "jsoncontent", " xmlAccept", "xaAccept", "xmlAccept", "xmlName", "textContent"], "out": ["t", "io", "write", "copy", "in", "conn", "extra", "user", "os", "comment", "external", "auto", "log", "file", "inner", "ent", "flush", "at", "sys", "client", "cmd", "check", "nt", "up", "conv", "n", "co", "init", "list", "o", "conf", "net", "con", "cn", "outs", "Out", "output", "ex", "null", "to", "cos", "writer", "ou", "aos", "OUT", "outer"], "xmlRequestNumber": ["xmlResponseNo", " xmlResponseNo", "xmlEventNo", "xmlResponseNumber", " xmlResponseNumber", "xmlCounterNo", "xmlRequestCounter", " xmlRequestNo", "xmlCounterNumber", "xmlCounterCount", "xmlResponseCount", "xmlEventNumber", "xmlEventCount", "xmlCounterCounter", " xmlResponseCounter", " xmlResponseCount", "xmlResponseCounter", "xmlEventCounter", "xmlRequestNo", " xmlRequestCount", " xmlRequestCounter", "xmlRequestCount"], "byteArrayInputStream": ["byteStreamInputForm", "byteArrayOutputStream", "byteStringInputSocket", "byteArrayOutputSet", "byteArrayIntSet", "byteArrayinputSteam", "byteArrayInputSteam", "byteArrayIntStream", "byteOrderInputSource", "byteArrayInputForm", "byteOrderReadSteam", "byteStreamInputStream", "byteArrayIntSteam", "byteStringInputStream", "byteOrderReadSource", "byteArrayInputSet", "byteArrayinputForm", "byteArrayinputSocket", "byteStringInputForm", "byteOrderInputStream", "byteArrayStorageStream", "byteOrderReadStream", "byteArrayStorageSteam", "byteOrderReadForm", "byteArrayHttpForm", "byteArrayHttpSteam", "byteStringOutputSocket", "byteArrayHttpStream", "byteStreamInputSet", "byteStringOutputForm", "byteStreamOutputStream", "byteStreamOutputForm", "byteArrayReadForm", "byteArrayRawStream", "byteArrayOutputSteam", "byteStreamOutputSteam", "byteArrayinputStream", "byteArrayOutputSocket", "byteStreamInputSteam", "byteArrayOutputForm", "byteArrayReadSource", "byteArrayStorageForm", "byteStreamOutputSet", "byteArrayHttpSource", "byteStringInputSteam", "byteArrayRawSteam", "byteArrayStorageSet", "byteOrderInputForm", "byteStringOutputSteam", "byteStringOutputStream", "byteArrayReadStream", "byteArrayRawForm", "byteArrayOutputSource", "byteArrayIntForm", "byteArrayInputSource", "byteArrayInputSocket", "byteArrayRawSocket", "byteArrayReadSteam", "byteOrderInputSteam"], "source": ["content", "object", "parse", "where", "unit", "details", "instance", "state", "status", "copy", "se", "src", "in", "stream", "cause", "scope", "comment", "select", "file", "relation", "component", "join", "inner", "expression", "trace", "body", "ident", "console", "SOURCE", "input", "ource", "reason", "position", "Source", "params", "handle", "layout", "json", "service", "target", "template", "proxy", "site", "sequence", "context", "from", "subject", "report", "store", "config", "table", "resource", "xml", "parent", "style", "ser"]}}
{"id1": "14773780", "id2": "12172485", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"testImageInfo": ["checkPhotoData", "checkImageData", "checkPhotoInfo", " testPhotoFile", " testImageFile", " testPhotoList", "checkImageFile", " testImageData", " testImagesList", "checkImageList", " testPhotoData", " testImageList", "checkPhotoList", " testImagesInfo", "checkImageInfo", "checkPhotoFile", " testImagesFile", " testPhotoInfo", " testImagesData"], "IOException": ["APIEx", "IOProblem", "APIProblem", "IOEx", "APIException", "AudioEx", "AudioException", " IOProblem", "AudioProblem", " IOEx"], "start": ["starting", "parse", "t", "started", "create", "Start", "trans", "read", "base", "id", "begin", " Start", "rest", "print", "now", "before", "time", "check", "open", "step", "end", "art", "birth", "get", "send", "init", "first", "wind", "it", "size", "enable", "st", "from", " started", "wait", "reset", "offset", "seed", "set"], "i": ["li", "y", "bi", "in", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "mi", "go", "batch", "b", "gu", "gi", "im", "q", "out", "x", "is", "ti", "ic", "index", "major", "ci", "pi", "uu", "name", "iq", "conv", "n", "me", "p", "qi", "f", "init", "si", "ix", "di", "info", "o", "it", "yi", "sim", "j", "my", "ex", "m", "ai", "to", "g", "s", "us"], "url": ["dl", "location", "ul", "host", "nl", "mount", "str", "base", "id", "u", "external", "log", "el", "lr", "l", "gl", "web", "uri", "string", "q", "r", "pattern", "path", "ls", "res", "mail", "ref", "ur", "gif", "http", "ll", "link", "rel", "URL", "null", "resource", "xml", "Url", "key"], "istream": ["intable", "ISTorage", "astorage", "itiver", "intream", "istable", "iptorage", "istiver", "istroy", "astream", "itream", "astroy", "istorage", "itrace", "aststream", "iptstream", "istrace", "ISTroy", "ISTstream", "itable", "intrace", "ositable", "iststream", "intiver", "iptroy", "ositrace", "iptream", "ositiver", "ISTream", "ositream"], "ii": ["jj", "li", "ista", "imi", "iy", "xi", "nai", "II", "sci", "mi", "iu", "ati", "gi", "iov", "hi", "cli", "ami", "cgi", "iso", "ti", "ki", "iii", "ice", "ci", "oci", "pi", "ij", "irm", "ji", "vi", "iri", "qi", "ia", "ni", "cci", "si", "di", "ini", "ei", "chi", "obi", "yi", "ushi", "fi", "ai", "zi", "iti", "ri"], "width": ["text", "scale", "widget", "cale", "px", "write", "min", "data", "Width", "length", "idth", "left", "wid", "draw", "const", "body", "shape", "x", "path", "crop", "fw", "step", "format", "dim", "foo", "position", "weight", "layout", "cut", "dx", "tall", "wn", "frame", "len", "value", "wa", "size", "w", "area", "wy", "window"], "height": ["history", "gravity", "sky", "buffer", "kw", "padding", "volume", "length", "div", "dimension", "Height", "hang", "shape", "radius", "stroke", "above", "family", "green", "chip", "density", "capacity", "resolution", "amount", "rise", "frame", "acity", "depth", "size", "rank", "cue", "angle", "style", "alpha", "h", "window", "grow", "def"], "stop": ["est", "close", "quit", " Stop", "id", "rest", "delay", "next", "result", "pop", "shape", "pause", "jump", "no", "gc", "duration", "ops", "wake", "success", "step", "end", "counter", "obj", "term", "peak", "loop", "disable", "Stop", "termination", "hop", "delete", "set", "fin", "it", "enable", "st", "period", " STOP", "null", "wait", "trip", "skip"]}}
{"id1": "2521141", "id2": "6501291", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "save", "io", "create", "replace", "write", "close", "archive", "transfer", "select", "file", "upload", "download", "insert", "ate", "drop", "clip", "clone", "cp", "cop", "edit", "crop", "slice", "export", "get", "opy", "cut", "move", "paste", "load", "delete", "link", "Copy", "share", "zip", "source", "set", "remove"], "from_name": [" from_case", "from_Name", "from_no", " from_Name", "from_names", "fromamekey", " from_resource", "fromamefilename", "from_case", " from_info", " from_names", "from_filename", "fromkname", " from_part", " from_filename", " from_no", "fromameName", "fromkName", "fromkcase", " from_key", "from_resource", "from_part", "from_key", "fromkpart", "from_info", "fromamename"], "to_name": ["tolyfile", "to7get", "tolynumber", "eto_name", "to_new", "to_get", "tolynm", "toNamefile", "toNameget", "to7new", "to_Name", "eto_word", "toNamename", " to_number", "to_word", "to7file", "from_new", "from_get", "toNamenew", "to_number", " to_nm", "to_nm", "eto_Name", "tolyname", "to7name"], "from_file": ["fromsdir", "from_port", "or_name", " from_resource", "fromlyresource", "from_dir", "fromlyfile", " from_type", "from_node", "from_type", " from_time", " from_do", "fromlynode", "to_dir", " from_port", "or_run", " from_node", "from_do", "from_resource", "fromlyFile", "from_time", "fromsfile", "from_File", "or_File", "from_run", "or_file", " from_File", "fromsname"], "to_file": ["to_create", "that_File", "TO_element", "TO_port", "to_link", " to_create", "toJFile", "TO_file", "TO_name", "toJdrop", "to_files", "from_dir", "to_tree", "toJfile", "from_type", "to_element", " to_File", "to_drop", "to_base", "that_tree", "to_port", "to_dir", "that_link", "to_run", "TO_FILE", "to_type", " to_dir", " to_base", " to_run", " to_local", "to_FILE", "toJblock", "to_local", "to_block", "that_file", " to_drop", "to_File", " to_block", "TO_files"], "parent": ["parents", "ip", "peer", "pid", "unit", "where", "pa", "top", "instance", "default", "point", "mother", "part", "tree", "base", "id", "remote", "comment", "server", "user", "prop", "file", "test", "pool", "percent", "prefix", "temp", "form", "shape", "client", "child", "path", "paren", "family", "par", "chain", "spec", "name", "up", "global", "tar", "position", "params", "root", "p", "per", "folder", "ma", "timeout", "relative", "directory", "man", "event", "desc", "block", "def", "my", "null", "master", "holder", "page", "owner", "port", "sp", "cmp", "pixel", "rule", "source", "home", "Parent"], "dir": ["dep", "det", "cd", "wd", "dr", "dict", "part", "str", "md", "ind", "file", "div", "loc", "self", "mod", "dd", "iter", "del", "cmd", "path", "tr", "Dir", "cond", "DIR", "dim", "coll", "fd", "d", "folder", "init", "di", "directory", "dist", "module", "cur", "local", "rel", "vol", "ir", "rec", "addr", "red", "sp", "cont", "good", "db", "def"], "from": ["fr", "io", "bound", "or", "in", "se", "re", "stream", "back", "base", "user", "pos", "file", "with", "en", "func", "inner", "left", "error", "before", "so", "ent", "form", "out", "normal", "client", "ie", "no", "check", "term", "ra", "old", "From", "on", "start", "orig", "false", "init", "set", "query", "con", "local", "link", "vol", "fun", "st", "entry", "reset", "com", "style", "empty", "store", "window", "source", "by", "and"], "to": ["t", "TO", "stable", "top", "te", "can", "or", "tty", "po", "ne", "too", "base", "auto", "total", "tt", "please", "go", "b", "ato", "so", "e", "eto", "sys", "out", "client", "no", "two", "will", "pi", "nt", "To", "op", "on", "co", "pretty", "token", "ma", "target", "o", "tto", "toc", "output", "must", "that", "null", "ta", "table", "ts", "into", "by"], "buffer": ["binary", "memory", "Buffer", "stack", "buff", "base", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "word", "button", "bar", "queue", "stroke", "cache", "database", "command", "variable", "buf", "password", "paste", "frame", "character", "template", "row", "event", "sample", "block", "sequence", "message", "append", "char", "entry", "table", "function", "window", "page"], "bytes_read": ["bytes_range", "bytesyncread", " bytes_Read", "bytes2range", "words_write", "Bytes_read", "Bytes_write", "wordsyncread", " bytes2read", "wordsynclen", " bytes2write", "bytesynclen", "bytes2Read", "bytes__range", "words_len", "wordsyncwrite", "bytes2write", "bytes__Read", " bytes_write", "words_report", "bytes_run", "bytes2read", " bytes2Read", "bytes__read", "bytesyncreport", "bytes_Read", "bytes__write", "words_read", "Bytes_run", " bytes_range", "wordsyncreport", "bytes_write", "bytes_len", "bytesyncwrite", "bytes_report", " bytes2range"]}}
{"id1": "442381", "id2": "742465", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", "doFeatureInfo", " doVersioncheck", "doApplicationQuery", "doImageQuery", "doApplicationInfo", " doApplicationQuery", " doVersionsTest", "doVersionsTest", "doImageInfo", "doVersionQuery", "doBuildUpdate", " doApplicationCheck", "doVersionsCheck", " doApplicationTest", "doBuildTest", "doApplicationTest", "doImageTest", "doVersionInfo", "doFeatureQuery", "doVersioncheck", " doVersionInfo", "doVersionTest", " doVersionsUpdate", " doVersionTest", "doFeatureCheck", " doApplicationInfo", " doVersionscheck", "doApplicationCheck", " doVersionQuery", "doBuildCheck", "doImageCheck", "doBuildcheck", "doFeatureUpdate", "doFeatureTest", "doVersionsUpdate", "doFeaturecheck", "doVersionscheck", " doVersionsCheck"], "view": ["version", "VIEW", "ml", "widget", "cv", "v", "buffer", "manager", "View", "views", "tree", "html", "server", "controller", "this", "eye", "file", "pool", "document", "image", "print", "review", "self", "component", "cell", "q", "update", "virtual", "client", "browser", "iew", "input", "index", "check", "engine", "vm", "layout", "project", "http", "row", "query", "lock", "tv", "block", "context", "display", "report", "subject", "show", "see", "call", "model", "h", "port", "box", "window", "page", "form"], "url": ["lb", "dl", "v", "build", "ul", "rl", "host", "nl", "str", "mount", "html", "log", "file", "loc", "l", "b", "gl", "uri", "oul", "r", "client", "ssl", "browser", "job", "mail", "ref", "sl", "address", "bel", "ur", "get", "f", "pl", "http", "hl", "ll", "link", "rel", "domain", "URL", "char", "Url"], "in": ["reader", "mat", "can", "din", " din", "stream", "asin", "inc", "isin", "rin", "l", "inner", "ln", "inf", "ain", "body", "vin", "source", "out", "is", "input", " IN", "In", "n", "on", "gin", "f", "init", "info", "IN", "mn", "from", "ins", "inn", "cin", "i", "sin"], "bin": ["bg", "binary", "reader", "buffer", "din", "bi", " din", "sin", "bed", "lib", "re", "by", "buff", "sam", "rin", "file", "inner", "b", "brain", "ln", "stock", "spin", "body", "session", "jin", "out", "abin", "cb", "cache", "bl", "rb", "bur", "conv", "ran", "thin", "gin", "init", "len", "all", " bins", "win", "nb", "con", "local", "ins", "ebin", "inn", "cin", "db", "cos", " Bin", "bn", "obin", "mon"], "line": ["tile", "parse", "le", "zone", "detail", "lin", "lane", "status", "inline", "range", "point", "stream", "part", "base", "column", "comment", "log", "file", "LINE", "liner", "print", "l", "ln", "trace", "next", "cell", "iter", "Line", "string", "eline", "lo", "cmd", "section", "ice", "job", "err", "rule", "chain", "ine", " block", "frame", "channel", "row", "record", "link", "lines", "block", "sample", "message", "sequence", "char", "field", "cat", "entry", "stay", "style", "code", "port", "word", "page", "key"], "develBuild": ["Develbuild", "depoBuild", "deVELBuilt", "deVELLoad", "desVELRelease", "deployBoot", "DevelBuild", "desVELBuild", "deeltaLoad", "deployLoad", "DeVELBuilt", "deffBuild", "develBuilt", "duffBuilt", "depobuild", "devBuilt", "develBuilder", "deffBuilt", "devBoot", "duVELBuilder", "DeVELbuild", "develbuild", "deVELLog", "devbuild", "deffBuilder", "deVELBuild", "desvelbuild", "desVELLoad", "duffbuild", "deployBuilt", "depoLog", "deeltaRelease", "depoBuilt", "DevelLog", "DeVELLog", "develLog", "develLoad", "duvelBuild", "desvelLoad", "deVELRelease", "deeltaBuild", "duVELBoot", "devLog", "deployRelease", "deeltabuild", "deVELBuilder", "desVELbuild", "deffbuild", "duvelBuilt", "deployBuild", "develBoot", "DeVELBuild", "desvelBuild", "duffBuild", "devBuild", "duvelBuilder", "deVELBoot", "develRelease", "deploybuild", "deVELbuild", "duvelBoot", "duVELbuild", "DevelBuilt", "duVELBuild", "deployBuilder", "desvelRelease", "duffBuilder", "duvelbuild", "devBuilder"], "stableBuild": [" stableBoot", "stableBoot", "activeBuild", " unstableBind", "confirmedbuild", "confirmedBoot", "stableBind", "stableCraft", "confirmedBuild", "stableBuilder", "secureCraft", "devBind", " stableCraft", " unstableLong", "stableMake", "devbuild", "activebuild", " stablebuild", " unstableCraft", " stableBind", "devMake", "stableLong", " unstablebuild", " stableBuilder", " stableMake", "secureBuilder", " unstableBuild", "activeBuilder", "secureBuild", "confirmedLong", " stableLong", " unstableBuilder", "activeMake", "securebuild", "devBuild", " unstableBoot", "stablebuild", "devBuilder"]}}
{"id1": "7103223", "id2": "14464131", "code1": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"testPost": ["testRequest", "TestRequest", " testPosts", "testPosts", " testRequest", "echoPost", "echoRequest", "TestPost", "echoPosts", "TestPosts"], "request": ["ip", "object", "claim", "create", "instance", "copy", "begin", "upload", "insert", "batch", "QUEST", "document", "complete", "print", "register", "join", "post", "reference", "application", "job", "enter", "command", "req", "quest", "position", "root", "project", "get", "url", "Request", "http", "load", "execute", "search", "service", "first", "template", "query", "list", "question", "record", "message", "report", "reset", "initial", "call", "resource", "trip", "key", "remove"], "response": ["version", "reply", "respond", "object", "onse", "exit", "status", "social", "view", "data", "respons", "tree", "connection", "answer", "user", "server", "pos", "document", "relation", "next", "trace", "result", "still", "body", "client", "line", "cache", "application", "res", "de", "command", "resp", "soc", "ve", "description", "http", "network", "json", "service", "channel", "one", "sample", "sequence", "output", "message", "block", "report", "entry", "that", "see", "Response", "remote"]}}
{"id1": "19652200", "id2": "19549577", "code1": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"init": ["save", "create", "read", "run", "release", "construct", " intern", "update", " initiate", "index", " constructor", "start", " Init", "get", "load", "info", "launch", " relocate", " initialization", "reset", "initial", "store", "config", "empty", "connect", "Init"], "file": ["le", "io", "create", "binary", "buffer", "current", "data", "tree", "base", "user", "fil", "FILE", "this", "attribute", "File", "log", "upload", "full", "document", "image", "disk", "dir", "uri", "body", "il", "ile", "line", "path", "open", "name", "format", "handle", "f", "http", "load", "be", "info", "local", "link", "output", "message", "report", "null", "real", "page", "resource", "table", "port", "rule", "source", "filename", "form"], "url": ["cl", "location", "host", "nl", "str", "mount", "base", "u", "loc", "l", "b", "gl", "web", "uri", "string", "q", "r", "browser", "ssl", "path", "util", "open", "mail", "sl", "address", "name", "ur", "get", "f", "http", "api", "ll", "link", "rel", "abs", "URL", "char", "resource", "i", "Url"], "stream": ["buffer", "status", "view", "stack", "download", "pool", "ream", "session", "console", "input", "path", "open", "engine", "chain", "handle", "channel", "Stream", "link", "context", "message", "socket", "page", "port", "resource", "source", "form"], "byteArray": ["charList", "ByteArray", "ByteList", " byteString", "byteString", "charString", " byteList", "charArray", "ByteString", "byteList"], "content": ["version", "text", "status", "data", "comment", "raw", "action", "body", "section", "hash", "path", "Content", "comments", "title", "format", "media", "json", "value", "template", "size", "message", "config", "code", "page", "cont", "source", "header", "summary"]}}
{"id1": "189963", "id2": "8754809", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "11865906", "id2": "19206412", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"testIdentification": ["testIDENTification", "testIdication", "testIdify", "testidentify", "TestIdentication", "Testidentication", "testIdentication", "TestIdentify", "testIdentifier", "Testidentify", "TestIdentifier", "testIdentify", "testIDENTify", "Testidentification", "testIDENTication", "testIdifier", "testidentication", "testIdification", "testIDENTifier", "TestIdentification", "testidentification", "testidentifier", "Testidentifier"], "username": ["twitter", "dn", "blood", "taker", "stab", "otype", "pty", "account", "instance", "rue", "john", "uid", "displayText", "human", "connection", "key", "unknown", "attribute", "author", "component", "prefix", "impact", "phone", "language", "assuming", "lead", "uri", "uno", "ubuntu", "string", "sword", "localhost", "profile", "operator", "sudo", "admin", "ername", "\u4eba", "email", "title", "login", "name", "metadata", "term", "position", "wordpress", "project", "url", "NAME", "token", "albeit", "character", "hello", "approximately", "seat", "person", "subject", "latest", "about", "knife", "initial", "information", "USER", "minimum", "filename", "owner", "pai", "source", "your"], "password": ["confirmed", "padding", "secret", "account", "PASS", "comment", "power", "attribute", "python", "phrase", "language", "picture", "sword", "string", "profile", "definition", "crypt", "hash", "pattern", "application", "device", "email", "database", "address", "remember", "login", "REDACTED", "command", "shadow", "pass", "words", "description", "height", "token", "hello", "number", "value", "message", "entry", "reset", " Password", "auth", "word", "Password"], "md5": [" md3", " Md5", " md512", "digol", "sha7", "MD3", "md512", "sha4", "md3", "mdol", "md7", "sha3", "MDol", "sha512", " mdol", " md2", " md4", " Md7", " Md512", "sha5", "dig2", " md7", "MD4", "MD2", "dig3", " Md3", "MD5", "dig5", "md2", "md4"], "logServiceMock": ["logServiceMOCK", "logServicePox", "logServiceJMocked", "logStorePocker", "logServicemock", "logServiceDex", "logServicemocks", "logServiceMXock", "logServicemocked", "logServiceMocked", "logServiceMMOCK", "logServiceMTlock", "logServiceMox", "logServicemOCK", "logServiceMXocked", "logServMTocked", "logServiceMulock", "logServicemex", "logServiceMMocker", "logServiceDocker", "logServicePocker", "logServMTock", "logStorePox", "logServMlock", "logServiceMTock", "logServicemlock", "logServiceMMox", "logServiceVock", "logServiceMlock", "logServiceMuocked", "logStoreMOCK", "logServicemocker", "logServicePOCK", "logServiceVocked", "logServiceMMock", "logStoreMocker", "logServMock", "logServiceMex", "logServiceMocker", "logStorePock", "logServiceMck", "logServMTlock", "logServiceManocks", "logServMTck", "logServiceManocked", "logStoreMock", "logServiceJMock", "logServiceMTck", "logServiceDocked", "logServiceVocker", "logServiceMuock", "logServiceVocks", "logServMck", "logStoreMox", "logServMocked", "logServicemox", "logServiceMocks", "logServiceMTocked", "logServicemck", "logServicePock", "logServiceJMocker", "logServiceVex", "logServiceMXocker", "logServiceManocker", "logServiceDock", "logServiceManock", "logServiceMuck", "logStorePOCK"], "dbServiceMock": ["dbStoremock", "dbServiceSaj", "dbServiceTrap", "dbServiceMXocks", "dbServiceJMock", "dbServiceSick", "dbServicesmock", "dbServicesMock", "dbServiceVox", "dbServiceMonock", "dbServiceMonocked", "dbServiceVocks", "dbServicemock", "dbServiceMoness", "dbServiceMonick", "dbServicemike", "dbServiceMXock", "dbServiceJMocked", "dbServiceJMike", "dbServiceMick", "dbServiceTocked", "dbServiceVrap", "dbStoreMrap", "dbServicesMike", "dbServiceVck", "dbServiceHMox", "dbFactoryMocked", "dbServiceMess", "dbServiceMocks", "dbServiceTock", "dbServiceMocker", "dbServiceMocked", "dbFactoryMock", "dbServiceVock", "dbServicemck", "dbServiceSocked", "dbServicemocked", "dbStoreMox", "dbFactoryMXocks", "dbServicemess", "dbServiceSocker", "dbServicesMocked", "dbServiceHMocked", "dbServiceSike", "dbServiceMrap", "dbFactoryMXock", "dbServiceMXocked", "dbFactoryMck", "dbStoreMocked", "dbServicesmaj", "dbServiceHMess", "dbServicemrap", "dbFactoryMXocked", "dbServicemick", "dbServiceMonocker", "dbServiceSock", "dbServiceMaj", "dbServiceVocked", "dbStoremox", "dbServicesmike", "dbFactoryMocks", "dbStoreMock", "dbFactoryMXck", "dbStoremocked", "dbServiceMike", "dbStoremrap", "dbServiceMonox", "dbServiceJMaj", "dbServiceMox", "dbServicemocks", "dbServicemocker", "dbServiceMXck", "dbServiceHMock", "dbServiceTox", "dbServicesMaj", "dbServicemaj", "dbServicesmocked", "dbServicemox", "dbServiceMck"], "user": ["reply", "object", "responsible", "plugin", "usage", "read", "write", "account", "instance", "actor", "uid", "human", "usr", "core", "comment", "u", "used", "author", "usa", "component", "temp", "result", "body", "form", "creator", "client", "profile", "menu", "rule", "prof", "entity", "name", "student", "per", "use", "contact", "json", "User", "list", "record", "response", "message", "output", "person", "char", "report", "null", "role", "entry", "USER", "to", "owner", "auth", "word", "key", "by", "system", "other"]}}
{"id1": "1421557", "id2": "17874479", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "21488518", "id2": "6421904", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["getNext", "dataFresh", "createFresh", "CreateNext", "dataResource", "getFresh", "createResource", "CreateFresh", "dataNew", "CreateResource", "dataNext", "createNext", "getNew", "CreateNew", "getResource"], "name": ["version", "create", "named", "type", "current", "Name", "part", "data", "key", "base", "id", "file", "ame", "now", "prefix", "lat", "action", "common", "body", "string", "missing", "normal", "none", "client", "path", "index", "no", "time", "alias", "end", "title", "address", "format", "n", "old", "password", "handle", "NAME", "names", "description", "use", "value", "template", "one", "local", "size", "event", "only", "null", "nm", "code", "resource", "ename", "word", "source", "filename"], "in": ["c", "t", "reader", "mat", "bin", "din", "data", "asin", "isin", "rin", "ind", "file", "en", "inner", "b", "body", "vin", "mc", "r", "is", "input", "err", "al", "In", "get", "p", "gin", "ma", "IN", "con", "it", "from", "ins", "inn", "cin", "xml", "i", "mm", "s", "source"], "length": ["content", "text", "count", "buffer", "padding", "read", "Length", "enc", "max", "stream", "data", "total", "body", "shape", "input", "path", "duration", "position", "password", "amount", "description", "len", "height", "value", "size", "sequence", "message", "bytes"], "contentType": ["mediaLength", "contentLength", "mediatype", "Contenttype", "contenttype", "ContentType", "mediaType", "mediaTypes", " contenttype", "ContentTypes", "ContentLength", "contentTypes", " contentLength", " contentTypes"], "dest": [" dst", "tmp", " Dest", "coord", "Dest", "trans", "wb", "copy", "src", "oe", "nom", "this", "prop", "rest", "disk", "loc", "self", "temp", "result", "dir", "iter", "origin", " destination", "path", "obj", "dat", "orig", "mem", "comb", "resp", "d", "folder", "there", "target", "cat", "lit", "table", "parent", "cont", "source", "home"], "out": ["t", "io", "write", "OUT", "can", "off", "copy", "conn", "po", "col", "os", "OU", "external", "log", "file", "go", "en", "serv", "ent", "sys", "client", "oss", "res", "obj", "end", "conv", "op", "up", "n", "co", "o", "net", "con", "outs", "w", "it", "output", "Out", "ex", "null", "to", "cos", "ion", "port", "s", "ou", "aos", "set", "outer"], "request": ["claim", "create", "ire", "re", "user", "begin", "select", "QUEST", "result", "require", "child", "input", "reference", "library", "open", "enter", "quest", "req", "requ", "params", "url", "Request", "move", "pair", "relative", "search", "query", "response", "message", "ask", "report", "reset", "current", "forward", "push", "remove"]}}
{"id1": "12055086", "id2": "732800", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeeleing", " copyDeeleting", " copyDeeleging", " copyDelingging", " copyDelinging", " copydeleging", " copyDeleging", " copydeleing", " copydeleving", " copydeletging", " copyDeletting", " copyDeleing", " copyDeletging", " copyDelingting", " copyDelingving", " copyDeleving", " copyDeeleving", " copydeletving", " copydeleting", " copydeletting", " copyDeletving"], "source": ["se", "src", "scope", "back", "base", "ce", "image", "original", "body", "origin", "oss", "SOURCE", "input", "ource", "ace", "spec", "start", "Source", "init", "search", "target", "service", "template", "query", "site", "local", "sample", "sql", "from", "store", "style", "parent", "resource", "sp", "seed", "form"], "dest": ["est", "img", "th", "Dest", "trans", "bin", "tom", "src", "nom", "rest", "loc", "them", "temp", "dir", "https", "pas", "del", "origin", "way", "cas", "end", "orig", "exp", "comb", "d", "target", "dist", "it", "w", "cat", "st", "lit", "null", "master", "port", "decl", "pub", "sp", "mm"], "buf": ["img", "capt", "cv", "Buffer", "meg", "buffer", "bh", "arr", "bs", "str", "data", "buff", "Buff", "fb", "prop", "batch", "b", "bus", "bc", "cf", "vec", "cp", "cmd", "alph", "pause", "uf", "eb", "cb", "br", "ref", "bl", "rb", "conv", "aka", "bag", "comb", "cast", "seq", "pkg", "cur", "block", "cap", "cat", "tx", "fg", "bytes", "tab", "box", "db"], "in": ["bin", "read", "din", "or", "user", "inc", "isin", "rin", "ind", "el", "en", "inner", "ze", "inf", "inside", "iter", "is", "input", "al", "In", "on", "un", "gin", "per", "init", "info", "ini", "IN", "con", "it", "from", "ins", "inn", "cin", "ai", "mm", "i", "ic", "ri", "by"], "out": ["t", "io", "v", "dis", "can", "OUT", "write", "conn", "ne", "os", "auto", "log", "en", "inner", "at", "flush", "sys", "oss", "client", "res", "end", "obj", "nt", "conv", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "Out", "output", "sum", "to", "page", "ion", "writer", "i", "ou", "aos", "by", "outer"], "count": ["c", "t", "ct", "ctr", "deep", "read", "span", "acc", "max", "core", "length", "comment", "total", "ind", "batch", "now", "add", "common", "q", "cc", "index", "check", "cond", "counter", "nt", "found", "n", "start", "amount", "coll", "len", "number", "nb", "conf", "num", "size", "ch", "cap", "sum", "char", "Count", "z", "code", "ount", "cont", "current", "cloud"]}}
{"id1": "12128591", "id2": "932225", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"hash": [" Hash", " text", " sum", " check", "id", "Hash", "print", " body", "dump", "hex", " key", "update", " hashing", " id", " equals", " message", " h", " fingerprint", " address", " code", " version", "code", "h", " signature", " mac", " salt"], "data": ["content", "text", "buffer", "any", "secret", "padding", "DATA", "html", "ata", "this", "raw", "batch", "image", "result", "action", "string", "out", "input", "dat", "command", "accept", "a", "password", "json", "hello", "value", "info", "block", "sequence", "message", "output", "rel", "bytes", "mu", "table", "what", "window"], "digest": ["mailgest", "displayse", "mailest", "initested", "digests", "digse", "deest", "equse", " digEST", "mdest", " digester", "Digests", " digave", " digse", "mdests", "redgest", "initEST", "mdse", "digester", "digly", "mdgest", "mdester", " digested", "displayests", "mailly", "digEST", "digested", " digit", "DigEST", "redest", "equit", "Digist", "mdave", "digave", "initester", "deested", "equest", "initest", "dese", "redester", "mdly", "displayest", "mdit", " digist", "Digest", "redly", "digist", "Digester", "diggest", "mailester", "Digested", "equave", "displayested", "digit", "mdested", "deist", "Digse"]}}
{"id1": "12782570", "id2": "13516684", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"logging": ["logifying", "logger", "Logifying", " logifying", " logged", "debugifying", "logged", "debugging", "debugger", "Logged", "debugged", "Logger", " logger", "Logging"], "wrap": ["embed", "wra", "parse", "create", "rap", "read", "build", "W", "wire", "pad", "core", "inter", "pool", "python", "add", "web", "xf", " wrapper", "word", "form", "transform", "shape", " wrapped", "x", "ow", "work", "aw", "pack", "ws", "chain", "format", "nw", "start", "handle", "me", "root", "safe", "wrapper", "use", "sw", "find", "wind", "wa", "ew", "gate", "wx", "w", "sp", "message", "we", "link", "force", "reset", "store", "ad", "zip", "box", "window", "grow"], "buffer": ["reply", "where", "Buffer", "binary", "memory", "view", "buff", "base", "comment", "attribute", "batch", "document", "flash", "print", "phrase", "complete", "flag", "body", "iter", "console", "word", "bar", "queue", "profile", "line", "cache", "ob", "database", "command", "note", "position", "face", "buf", "builder", "ve", "wrapper", "frame", "template", "row", "pb", "size", "block", "append", "message", "output", "display", "sequence", "report", "bo", "store", "table", "writer", "bridge", "window", "quote", "header"], "encoding": ["enryption", "enoded", "octoding", "enoding", "presoder", "encoder", "coding", "coded", "Encryption", "encoded", "presryption", "Encoding", "caling", "octging", "enaling", "Encoder", "Encaling", "encging", "presoding", "octoder", "cryption", "encaling", "octoded", "cging", "encryption", "enoder", "presoded", "enging", "coder"], "getEncoding": ["getencryption", "GetEncryption", "getEncocol", "getEnling", "getUrlling", "getContinoding", " getEnocol", "GetEncName", " getEnoding", "getEncoded", "getContinryption", "getContinoded", "GetEnryption", "getUrloding", "getUrlName", "getContinocol", "getEncling", "GetEnling", "GetEncoding", "getencoding", "getUrlryption", " getEncocol", "GetEnName", "GetEncling", "getEncName", "getEnoded", "getencling", " getEncoded", " getEnoded", " getEncryption", " getEnryption", "getEncryption", "getEnryption", "getEnoding", "getEnName", "getencName", "getEnocol", "GetEnoding"], "headers": ["pres", "codes", "terms", "head", "modules", "tags", "images", "ers", "frames", "holders", "pins", "relations", "ports", "limits", "ilers", "ctors", "objects", "heads", "comments", "reports", "styles", "ids", "drivers", "actions", "checks", "params", "ppers", "chains", "builders", "names", "properties", "members", "rs", "users", "blocks", "writers", "values", "authors", "fields", "groups", "ters", "boxes", "keys", "weights", "caps", "header"], "is": ["isd", "tis", "ip", "ists", "dis", "iris", "or", "in", "bs", "\u00eds", "does", "os", "sis", "isin", "ui", "isc", "bis", "isi", "has", "was", "isf", "bits", "ist", "sys", "as", "iso", "lis", "nis", "ys", "ois", "its", "IS", "ris", "si", "fs", "ais", "ims", "isa", "mis", "iss", "ios", "isl", "obs", "ins", "us", "i", "Is", "ic", "ri", "ms"], "bos": ["oids", "tis", "dos", "nos", "pod", "bones", "bin", "ots", "bi", "bh", "bs", "fits", "js", "des", "os", "ui", "bot", "bis", "bas", "isi", "cs", "ones", "bits", "ts", "sys", "ows", "oss", "bes", "oos", "ys", "windows", "tops", "uts", "banks", "eros", "soc", "boards", "ubis", "lets", "ses", "edes", "ols", "los", "fs", "jas", "stats", "bo", "ios", "obs", "bytes", "cos", "ods", "uds", "vals", "aos", "tes"], "e": ["c", "t", "le", "ae", "v", "ev", "se", "es", "eeee", "re", "oe", "ne", "ate", "en", "ent", "ge", "r", "x", "ie", "err", "de", "er", "a", "n", "me", "p", "f", "d", "exc", "o", "E", "ex", "ee", "m", "g", "i", "error", "ed"]}}
{"id1": "19652200", "id2": "23467091", "code1": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"init": ["save", "create", "read", "run", "release", "construct", " intern", "update", " initiate", "index", " constructor", "start", " Init", "get", "load", "info", "launch", " relocate", " initialization", "reset", "initial", "store", "config", "empty", "connect", "Init"], "file": ["le", "io", "create", "binary", "buffer", "current", "data", "tree", "base", "user", "fil", "FILE", "this", "attribute", "File", "log", "upload", "full", "document", "image", "disk", "dir", "uri", "body", "il", "ile", "line", "path", "open", "name", "format", "handle", "f", "http", "load", "be", "info", "local", "link", "output", "message", "report", "null", "real", "page", "resource", "table", "port", "rule", "source", "filename", "form"], "url": ["cl", "location", "host", "nl", "str", "mount", "base", "u", "loc", "l", "b", "gl", "web", "uri", "string", "q", "r", "browser", "ssl", "path", "util", "open", "mail", "sl", "address", "name", "ur", "get", "f", "http", "api", "ll", "link", "rel", "abs", "URL", "char", "resource", "i", "Url"], "stream": ["buffer", "status", "view", "stack", "download", "pool", "ream", "session", "console", "input", "path", "open", "engine", "chain", "handle", "channel", "Stream", "link", "context", "message", "socket", "page", "port", "resource", "source", "form"], "byteArray": ["charList", "ByteArray", "ByteList", " byteString", "byteString", "charString", " byteList", "charArray", "ByteString", "byteList"], "content": ["version", "text", "status", "data", "comment", "raw", "action", "body", "section", "hash", "path", "Content", "comments", "title", "format", "media", "json", "value", "template", "size", "message", "config", "code", "page", "cont", "source", "header", "summary"]}}
{"id1": "20181656", "id2": "15822137", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"sortRows": ["sortDrows", "sortRecrows", "sortRecords", " sortLows", " sortLues", " sortLords", "sortRues", "sortRecues", "sortDords", "sortDows", " sortRords", "sortLords", " sortRues", "sortDues", " sortLrows", "sortLows", " sortRrows", "sortRrows", "sortRords", "sortRecows", "sortLrows", "sortLues"], "rows": ["posts", "bs", "views", "data", "vs", "series", "errors", "months", "names", "ris", "list", "row", "lines", "ins", "ues", "events", "history", "projects", "ries", "links", "arr", "relations", "orts", "changes", "tracks", "reports", "ls", "models", "cells", "rs", "runs", "stats", "docs", "rules", "values", "keys", "ms", "modules", "maps", "workers", "forms", "images", "raw", "frames", "roots", "ows", "pages", "checks", "rooms", "ints", "rates", "fields", "groups", "ods", "uds", "sheets", "cases", "ards", "terms", "results", "ros", "rown", "headers", "ports", "ges", "items", "heads", "res", "dates", "ids", "members", "packages", "resources", "users", "blocks", "outs", "tests", "abs", "types", "files", "orders", "issues", "rices", "xs"], "i": ["ori", "ip", "li", "io", "v", "bi", "in", "ii", "phi", "xi", "id", "u", "ui", "mi", "iu", "e", "gi", "q", "hi", "out", "ie", "is", "ti", "ki", "ci", "pi", "ji", "p", "ia", "si", "init", "ix", "di", "ini", "ei", "it", "ar", "m", "ai", "g", "zi", "us", "ic", "ri"], "j": ["jj", "ja", "fr", "y", "J", "v", "aj", "state", "jet", "k", "js", "rem", "user", "u", "bot", "jc", "pr", "l", "jp", "oj", "b", "next", "e", "je", "im", "q", "uni", "out", "x", "jump", "job", "err", "br", "obj", "ji", "ij", "og", "er", "son", "req", "note", "jit", "si", "ix", "json", "di", "o", "jac", "uj", "bj", "it", "jl", "rel", "ret", "sim", "my", "jo", "z", "m", "adj", "g", "last", "s", "kid", "dj", "by", "kj", "other"], "temp": ["tem", "level", "t", "tmp", "mint", "buffer", "kw", "Temp", "status", "vt", "fac", "base", "tt", "test", "mod", "const", "result", "cell", "cum", "tc", "clean", "porary", "tr", "EMP", "term", "dat", "variable", "mem", "orig", "mp", "perm", "template", "local", "pre", "emp", "tim", "null", "fake", "current", " tmp", "alt", "txt"]}}
{"id1": "19113613", "id2": "19134229", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "ip", "save", "create", "same", "replace", "write", "Cop", "core", "py", "transfer", "download", "cross", "clip", "clone", "cp", "cop", "split", "gc", "crop", "slice", "map", "opy", "co", "move", "init", "paste", "delete", "proxy", "php", "link", "cat", "Copy", "to", "share", "cos", "pixel", "zip"], "in": ["y", "bin", "din", "inv", "sin", "re", "id", "inc", "isin", "rin", "ind", "el", "en", "mi", "inner", "l", "inf", "inside", "iter", "ie", "is", "input", "check", "up", "In", "on", "old", "gin", "init", "all", "info", "o", "IN", "net", "ini", "con", "local", "it", "from", "ir", "ins", "ar", "inn", "cin", "act", "ai", "i", "ic", "by"], "out": ["t", "tmp", "io", "y", "v", "write", "can", "conn", "ver", "base", "os", "over", "OU", "this", "log", "en", "l", "b", "inner", "result", "at", "ent", "ot", "gt", "client", "oss", "sys", "cache", "res", "err", "end", "obj", "nt", "op", "n", "on", "co", "p", "all", "o", "set", "net", "con", "one", "local", "w", "it", "outs", "output", "Out", "ch", "ex", "null", "store", "to", "not", "ion", "port", "ou", "aos", "OUT", "outer"], "source": ["scan", "unit", "status", "se", "src", "sin", "range", "cause", "scope", "base", "space", "lower", "select", "this", "attribute", "ce", "relation", "inner", "prefix", "language", "string", "origin", "ie", "SOURCE", "input", "index", "ource", "title", "format", "position", "start", "Source", "use", "si", "search", "service", "template", "query", "finder", "local", "site", "sequence", "sql", "from", "subject", "style", "store", "shell", "resource", "parent", "s", "sp", "key", "system"], "target": ["t", "location", "top", "translation", "arget", "point", "scope", "base", "tree", "dest", "test", "print", "join", "other", "origin", "gt", "pattern", "ARGET", "alias", "step", "term", "goal", "tif", "url", "root", "token", "match", "arg", "template", "query", "module", "local", "link", "rel", "output", "that", "null", "style", "to", "table", "parent", "resource", "bolt", "key", "Target"], "files": ["states", "features", "modules", "facts", "details", "faces", "parts", "headers", "services", "workers", "images", "assets", "ports", "books", "balls", "thumbnails", "items", "tools", "pages", "reports", "ls", "objects", "styles", "actions", "plates", "banks", "iles", "lets", "models", "members", "fs", "les", "jobs", "uploads", "users", "lines", "resources", "packages", "values", "pieces", "issues", "events"], "file": ["tile", "le", "fe", "data", "key", "tree", "base", "user", "FILE", "full", "el", "File", "document", "image", "print", "relation", "e", "dir", "word", "ile", "child", "line", "path", "item", "library", "work", "job", "rule", "name", "foo", "play", "feature", "f", "ve", "pe", "folder", "be", "row", "fp", "event", "local", "block", "field", "entry", "label", "table", "model", "resource", "page", "node", "parent", "port", "current", "filename"], "inCh": ["inch", "cinch", "cinCor", "rinCl", "incCor", "InCh", " inch", "cinSam", "inChan", "cinChan", "inCr", "InCl", "rinChan", "incCr", "cinCod", "InCod", "dinSam", " inChan", "inCor", "inCl", "rinCh", "dinCh", "cinCr", "incSam", "cinCh", " inCl", "rinCod", "dinCor", "inSam", "dinCr", "InChan", "inCod", "outCod", "outChan", "incCh", "outch", " inCod"], "outCh": ["inch", "outputCod", "inChan", "outGr", "outputCh", "outputGr", "newch", "newGr", "newCod", "newChan", "inCol", " outch", " outChan", "outputChan", " outCod", " outGr", " outCol", "outCod", "outCol", "outChan", "newCh", "outch", "newCol"]}}
{"id1": "416857", "id2": "4056444", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 0, "substitutes": {"process": ["scan", "parse", "create", "read", "run", "processing", "walk", "update", "proc", "Process", "input", "check", "work", "program", "step", "accept", "loop", "exec", "handle", "processor", "load", "execute", "output", "display", " ingest", "task", "filter"], "dir": ["dl", "tmp", "det", "cd", "wd", "org", "dr", "orig", "src", "lib", "host", "str", "data", "html", "md", "id", "rot", "this", "log", "file", "disk", "ind", "loc", "div", "mod", "prefix", "dd", "del", "out", "mk", "Dir", "www", "DIR", "name", "dat", "tar", "old", "start", "handle", "root", "url", "direction", "grad", "pkg", "d", "folder", "http", "fd", "directory", "cur", "dist", "local", "desc", "rect", "rel", "vol", "ir", "direct", "deg", "doc", "lim", "addr", "window", "db", "filename", "home", "def", "txt"], "list": ["dl", "li", "tmp", "v", "detail", "state", "data", "select", "batch", "left", "spec", "names", "pre", "null", "config", "filter", "def", "other", "history", "details", "dict", "L", "this", "LIST", "file", "collection", "l", "lists", "now", "add", "lat", "sort", "ist", "out", "single", "listed", "ls", "index", "cache", "get", "delete", "match", "record", "local", "link", "see", "write", "status", "copy", "range", "tree", "length", "ln", "string", "line", "map", "old", "block", "table", "cont", "source", "set", "re", "str", "log", "test", "print", "dump", "result", "queue", "split", "chain", "name", "note", "array", "all", "number", "rm", "sequence", "st", "display", "stat", "show", "code", "word", "form"], "n": ["c", "np", "t", "count", "v", "ng", "sn", "nu", "nl", "nr", "ne", "total", "norm", "l", "ln", "na", "nn", "no", "pi", "nt", "name", "nan", "nw", " N", "un", "N", "p", "d", "ni", "len", "names", "network", "number", "nb", "net", "num", "w", "nor", "j", "m", "nm", "z", "g", "nc", "ns"], "bubblesort": ["bubblingORT", "gobblingorter", "bubbledorter", "bubbsORT", "bubbsorter", "robbledist", "bubblort", "robbledorts", "bubblingorts", "gobbsORT", "robbledorter", "robblesorter", "bubblesorter", "gobblesord", "bubblerv", "gobblingerv", "robbledort", "bubblingort", "gobbleorter", "bubblingorter", "gobblessort", "bubbsord", "bubblersort", "bubbledord", "bubbledorts", "bubbsort", "bubblingord", "bubblorter", "bubbleserv", "bubbleorter", "robblesorts", "bubblessort", "gobblingort", "bubblesist", "bubbledORT", "bubbsist", "gobbleort", "gobbleserv", "bubbledsort", "gobblingsort", "gobblesorter", "bubbleorts", "gobbsort", "bubbledort", "robbledord", "robblesist", "gobblesist", "gobbsorter", "bubbsorts", "robblessort", "bubblerord", "bubblerort", "gobbsord", "bubblerorter", "bubblingerv", "robbledsort", "gobblesort", "robblesord", "gobbleist", "bubbleord", "bubbleist", "bubbledist", "bubblsort", "bubblesORT", "bubblesord", "bubblingsort", "bubblederv", "bubbleort", "robblesort", "gobblesORT", "bubblesorts", "bubbssort"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "batch", "iter", "hi", "cli", "ami", "is", "err", "exp", "init", "ini", "ei", "ims", "sim", "j", "my", "g", "zi", "us", "parent", "ic", "io", "in", "multi", "u", "this", "l", "e", "q", "x", "ki", "index", "pi", "ij", "iri", "qi", "di", "record", "s", "fire", "ity", "eu", "point", "id", "mi", "gi", "uri", "ji", "iq", "me", "p", "si", "ix", "it", "to", "key", "set", "c", "phi", "ui", "ind", "iu", "go", "oi", "im", "ti", "ci", "chain", "ex", "m", "z", "ai", "ri"], "f": ["t", "fr", "tf", "c", "aff", "v", "fe", "fac", "bf", "fb", "file", "l", "b", "fab", "af", "df", "lf", "fm", "fw", "p", "d", "fd", "fs", "fp", "w", "fc", "elf", "fi", "m", "F", "sf", "h", "cf"], "img": ["imgur", "tmp", "pic", " im", "jpg", "org", "aj", "shr", "src", "amp", "medium", "html", "md", "fb", "raw", "aug", "images", "orm", "image", "now", "jp", "Image", "inf", "picture", "im", "png", "imag", "uf", "mb", "impl", "dm", "fm", "util", "anim", "ref", "obj", "conv", "og", "small", "fig", "buf", "url", "gif", "mp", "tif", "gb", "it", "j", "gm", "m", "h", "good", "window"], "whichcase": ["whocase", " whichstring", "whostring", "whosetest", "whotest", " whichmatch", "howchar", "whosepath", "whetherrule", "wheretest", "whatspace", "whichrule", "whichcatch", "howtest", "whichspace", "whatmatch", "whatrule", "whoCase", "howrule", "whoseCase", "whethercatch", "whichpath", "whatCase", "whopath", " whichpath", "whichCase", " whichspace", " whichrule", "whichtest", "whattest", "howcase", "whichmatch", "howspace", " whichtest", "whethercase", "whatcase", "whorule", "wherecase", "whereCase", "whatstring", " whichchar", "whatchar", "whethertest", "whichchar", "whererule", "howCase", "whatcatch", "howmatch", "wherematch", "wherecatch", " whichCase", "whosematch", "whichstring", "howstring", "whosecase"], "lastDigit": [" lastDigita", "lastDbit", "lastPosit", "lastHourita", "lastDigbit", "lastdigit", "maxDigbit", "maxdigit", "firstdiguster", "firstdigbit", "firstdigiter", "lastDiguster", "firstdigi", "firstdigit", "firstDigot", "maxdigbit", "firstDiguster", "lastDiget", "firstDigiter", "lastDigot", "lastdiguster", "lastPosbit", "lastdigiter", " lastDigbit", "lastDigi", "lastDiter", "firstdigot", "lastdigot", "firstDigit", " lastDigot", "lastDet", "lastDoublebit", "lastValit", "lastDit", "firstDigbit", "lastPositer", "lastHourit", " lastdigit", "maxdigiter", "lastDoubleit", "lastHourot", "lastdigita", "lastDoublei", "lastValbit", "lastPosot", "maxdigot", " lastdigiter", "lastdigbit", "lastHourbit", "firstDigi", "lastdiget", "lastDigita", " lastDigiter", " lastDiget", "lastDoubleuster", "maxDigiter", "lastdigi", "lastPosuster", " lastdiget", "lastValet", " lastdigbit", "lastPosi", "maxDigot", "lastDigiter", "maxDigit", "lastValiter"], "sorted": ["unsorted", "Sorted", "insort", "sorting", "unsorter", "Sort", "isorting", "sorter", "sort", "Sorter", "Sorting", " sort", "unsorting", "unsort", "insorting", "insorted", " sorter", " sorting", "isorter", "isort", "insorter", "isorted"], "temp": [" temperature", "tem", "level", "t", "tmp", "v", "buffer", "Temp", " total", " v", " w", "base", "test", "porary", " t", " temporary", "stem", "orig", "mp", "local", "w", "pre", "emp", "tim", "m", "fake", " tmp", "txt"], "tempp": ["compl", "comple", "compp", "temple", "typle", "timpps", "typl", "typp", "tempps", "timpp", "compps", "typps", "templ", "timple", "timpl"]}}
{"id1": "19549489", "id2": "3252116", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "save", "create", "read", "write", "replace", "Cop", " mirror", "upload", " duplicate", "transfer", "csv", "download", " cp", "add", "clone", "cp", " Copy", "slice", "map", "export", "paste", "move", "load", "delete", "rm", "cat", "Copy"], "sourceFile": ["SourceFilename", "inputPage", " sourceFilename", "inputfile", "ourcefile", "ourcePage", "ourceFile", "ourceLine", " sourcefile", "sourcePage", "inputLine", "sourcefile", " sourceLine", "sourceLine", "SourceFile", "inputFile", " sourcePage", "SourcePage", "ourceFilename", "sourceFilename", "SourceLine", "Sourcefile"], "destinationFile": ["estinatedPlace", "destinoFilename", "declinatorPlace", "destinoFile", "destinationsfile", "destinatorPlace", "destinofile", "declinationPath", "destinatePath", "declinationFilename", "declinationFile", "estinationFilename", "destinoPlace", "destinationPath", "estinationFile", "destinationFilename", "destinationfile", "estinatedFile", "estinatedfile", "destinatorFilename", "destrativePlace", "destinatedPlace", "destinationsPlace", "destrativePath", "destinationsFile", "estinationPlace", "destinateFile", "destinationsFilename", "destrativeFile", "destinatePlace", "destinatedfile", "estinatedFilename", "declinationPlace", "destinationPlace", "destinatedFilename", "destinatorPath", "destinatedFile", "destinateFilename", "declinatorFile", "declinatorFilename", "destrativeFilename", "destinatorFile", "declinatorPath", "estinationfile"], "sourceFileChannel": ["sourceByteEntry", "srcFileEntry", "sourceStreamApplication", "srcFilechannel", "sourceFileEntry", "sourceLineChannel", "sourceEntryConnection", "sourceEntryChan", "sourceBlockConnection", "srcBlockEntry", "sourceBaseApplication", "sourceFileConnection", "sourceBaseHandler", "sourceStreamChan", "ourceFileChan", "sourceLineConnection", "sourceLineChan", "srcBlockConnection", "sourceStreamchannel", "srcBlockchannel", "sourceStreamChuck", "srcBlockChannel", "sourceByteConnection", " sourceFileApplication", "sourceLineEntry", " sourceFileChuck", "sourceByteChannel", "sourceFileApplication", "ourceFileChannel", "sourceEntrychannel", "sourceFileChan", "sourceFileHandler", "ourceEntrychannel", "ourceEntryChan", "sourceBytechannel", " sourceFileHandler", "sourceFileChuck", "ourceFilechannel", "sourceLinechannel", "sourceBlockChannel", "sourceBaseChannel", "ourceFileConnection", "sourceEntryChannel", "sourceBlockEntry", "ourceEntryConnection", "srcFileConnection", "sourceFilechannel", "sourceBlockchannel", "srcFileChannel", "sourceStreamChannel", "sourceStreamHandler", "sourceStreamConnection", "sourceBaseChuck", "ourceEntryChannel"], "destinationFileChannel": ["destinationfileManager", "destmentResourceChannel", "destmentPageChannel", "destinationFilesConnection", "destinationfileEntry", "destinatorFilesChannel", "destinationChannelEntry", "destinationFileManager", "destmentFilechannel", "destinationResourcechannel", "destinationFilesChannel", "destinationChannelCh", "destinationPageChannel", "destinatorFileCh", "destinationResourceManager", "destinationPageEntry", "destmentPageContext", "destinationfileConnection", "destmentPageEntry", "destinationResourceChan", "destmentResourcechannel", "destmentFileChannel", "destinationfilechannel", "destinationFileConnection", "destinationDirectoryChannel", "destinationDirectorychannel", "destinationfileCh", "destinatorFilesConnection", "destinationfileChannel", "destmentResourceManager", "destinationChannelChannel", "destinationPageContext", "destmentPageChan", "destinationFileContext", "destinationFilechannel", "destinationPageChan", "destinationChannelChan", "destinationFileEntry", "destinationDirectoryManager", "destinationChannelConnection", "destinationChannelContext", "destinationfileChan", "destinationfileContext", "destinationFileChan", "destinatorFilesCh", "destinationResourceChannel", "destmentFileChan", "destinationFilesChan", "destinationFileCh", "destmentResourceChan", "destinationFilesCh", "destinatorFileConnection", "destmentFileContext", "destinatorFileChannel", "destmentFileEntry", "destinatorFilesChan", "destmentFileManager", "destinatorFileChan", "destinationDirectoryChan"]}}
{"id1": "300397", "id2": "8069594", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "14168494", "id2": "19096138", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyfile", "CopyByte", "CopyStream", " copyStream", " cpfile", " cpStream", " CopyStream", " Copyfile", "CopyFile", " cpByte", "Copyfile", " CopyByte", " copyByte", " cpFile"], "dest": ["img", "np", "tmp", "Dest", "v", "trans", "etc", "des", "usr", "nom", "rest", "loc", "them", "temp", "result", "dir", "del", "origin", "gt", "out", "way", "www", "nt", "nw", "orig", "d", "target", "dist", "w", "st", "master", "to", "doc", "pub", "cont", "good", "source"], "src": ["sb", "img", "sr", "sc", "rx", "usr", "upload", "file", "loc", "sub", "sq", "sys", "input", "ls", "sl", "rc", "req", "start", "Source", "iv", "init", "sec", "cur", "rs", "rel", "desc", "st", "from", "ins", "sel", "inst", "cont", "ser", "source"], "srcChannel": ["rcMessage", "srcCommand", "rcChannel", "rcChan", " srcChan", "instChan", "srcChain", "rcchannel", "instCh", "sysChannel", "bgChain", "srcchannel", "sourceCh", "rcChain", "sysCommand", "syschannel", "destChannel", "instPanel", "bgChannel", " srcChain", "destChain", " srcchannel", "sqChain", "sourceChan", " srcCommand", "sysChan", "srcCh", "srcMessage", "sqCan", "instChannel", "instChain", "destChan", "sqPanel", "srcChan", "bgPanel", "srcCan", "instCan", "srcPanel", "destMessage", "sourceChannel", " srcCh", "rcCommand", "bgCan", "sqChannel", " srcMessage"], "dstChannel": ["dndClient", "dndChannel", " dotCh", "ddestChannel", " dotChannel", "dbrCh", "dotCh", "dotChannel", "dndCh", " dstButton", "pdestChannel", "pstClient", "pdestButton", " dotHandler", "dndButton", "dndChan", " dstChan", " dstCh", "pdestClient", "destChannel", "dotChan", "destCommand", "dotHandler", " dotButton", "ddestClient", "pdestCommand", "dndCommand", "ddestHandler", "dbrHandler", "dstButton", "dstClient", "dbrChan", "dstCh", "ddestChan", "dbrChannel", "pstButton", "dotButton", "ddestCh", "dstChan", "ddestCommand", "destClient", "pstChannel", " dstHandler", " dotChan", "dstHandler", "dstCommand", "destButton", "ddestButton", "pstCommand"]}}
{"id1": "18504192", "id2": "17996547", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " transferFile", "copyfile", "CopyStream", "copyFiles", " transferfile", " CopyStream", " Copyfile", "CopyFiles", "CopyFile", "copyStream", " CopyFiles", " transferStream", "Copyfile", " transferFiles"], "in": ["din", "or", "id", "inc", "isin", "rin", "ind", "el", "en", "l", "b", "inf", "vin", "as", "is", "input", "up", "In", "n", "on", "old", "gin", "edIn", "o", "IN", "it", "from", "ins", "inn", "cin", "i", "mm", "ic"], "out": ["t", "io", "v", "k", "po", "ne", "help", "os", "log", "l", "b", "serv", "at", "gt", "ot", "oss", "err", "nt", "n", "o", "net", "w", "outs", "it", "output", "Out", "ex", "to", "g", "i", "s", "ou", "OUT"], "source": ["scan", "parse", "ources", "create", "reader", "secret", "instance", "copy", "se", "src", "volume", "scope", "back", "space", "comment", "file", "inner", "before", "inside", "origin", "ie", "SOURCE", "input", "ource", "open", "spec", "position", "start", "Source", "me", "use", "init", "search", "match", "service", "template", "query", "info", "force", "local", "sample", "sequence", "from", "subject", "style", "store", "shell", "resource", "pse", "seed", "sin", "access", "system", "iterator"], "destination": ["restinated", "destinated", "comregation", "destification", " destension", "restation", "destregation", " destation", "destinator", "restination", "seeinator", "destation", "Destinated", " destato", "Destation", "coordification", "seeension", "Destinator", " destinator", "coordato", "comination", "comification", "seeinated", " destregation", " destification", "coordination", "destato", "Destination", " destinated", "Destension", "comato", "destension", "coordregation", "seeination", "restinator"]}}
{"id1": "8093133", "id2": "7143591", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlFormWeb", "loadXmlAsWeb", "loadXMLFormFile", "loadXMLFromURL", "loadXmlFromWeb", "loadXmlFormURL", "loadXmlFromURL", "loadXmlFromFile", "loadXmlWithUrl", "loadXmlAsURL", "loadXmlWithFile", "loadXMLFormUrl", "loadXmlAsFile", "loadXmlFormFile", "loadXMLFromFile", "loadXmlWithWeb", "loadXmlAsUrl", "loadXMLFromWeb", "loadXMLFromUrl", "loadXMLFormURL", "loadXMLFormWeb", "loadXmlWithURL", "loadXmlFormUrl"], "url": ["location", "request", "build", "in", "host", "nl", "str", "base", "html", "user", "id", "u", "log", "file", "loc", "document", "l", "b", "web", "uri", "ssl", "path", "input", "res", "open", "job", "sl", "address", "name", "n", "bel", "ur", "get", "http", "ll", "link", "domain", "abs", "URL", "char", "xml", "Url", "page"], "timeout": ["version", "t", "io", "unit", "buffer", "frequency", "type", "monitor", "padding", "max", "server", "length", "total", "delay", "course", "blocking", "limit", "sleep", "out", "client", "duration", "time", "policy", "term", "resolution", "amount", "Timeout", "password", "capacity", "height", "network", "number", "directory", "until", "size", "seconds", "it", "period", "latest", "wait", "exclusive", "to", "mode", "window", "OUT"], "xmlType": ["fileType", "xmlStyle", "xmlUnit", "complexUnit", "xmltype", " xmlTypes", "xmlTypes", " xmlUnit", "xmlTyp", "complextype", "fileBlock", "xmlBlock", " xmltype", "imageStyle", "mlUnit", "imageTypes", "complexType", "imageBlock", "imageType", "mltype", "mlType", " xmlTyp", "fileStyle", " xmlStyle", "complexTyp", "mlTyp", " xmlBlock", "fileTypes"], "connection": ["c", "generation", "io", "creation", "usage", "close", "manager", "conn", "cone", "user", "relation", "computer", "statement", "still", "uri", "session", "creator", "client", "established", "pointer", "reference", "application", "connected", "open", "database", "communication", "command", "position", "city", "builder", "description", "network", "character", "channel", "directory", "number", "con", "Connection", "link", "response", "opening", "condition", "subject", "entry", "internet", "socket", "config", "to", "resource", "ion", "nc", "current", "connect", "system"], "buffInputStream": ["BuffInputStream", "buffEarField", "buffIOForm", "buffInputChannel", "buffEarSteam", "buffEarForm", "buffEntityChannel", "buffInputForm", "BuffInputChannel", "buffIOSteam", "buffIOStream", "buffOutputStream", "buffEntityForm", "BuffOutputField", "BuffInputField", "BuffOutputForm", "buffOutputSteam", "BuffInputSteam", "buffIOField", "buffEarStream", "BuffOutputChannel", "BuffOutputSteam", "buffOutputChannel", "BuffInputForm", "buffEntityStream", "buffOutputField", "BuffOutputStream", "buffInputField", "buffOutputForm", "buffInputSteam"]}}
{"id1": "18891988", "id2": "15971794", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"getFile": ["selectfile", "GetFile", "getString", "createfile", "Getfile", "selectString", "getfile", "createFile", "getFilename", "selectFilename", "GetString", "GetFilename", "createFilename", "selectFile", "createString"], "serviceName": ["libraryFamily", "serviceNames", "serverName", "ServiceNames", "serviceCode", " serviceNames", "serverType", "serviceType", "ServiceName", "serviceFamily", "serverCode", " serviceType", "libraryName", "ServiceCode", " serviceCode", "ServiceType", "libraryNames", "ServiceFamily", "libraryType", " serviceFamily"], "wsdlLocation": ["wslPath", "awsolLocation", "wsDLLoc", "wslLocation", "wsDLLocation", "wssdPath", "wsolLocation", "wsollocation", "wsDLFolder", "awsdLoc", "wlFolder", "wdlLocation", "wssdlocation", "awsdlLocation", "wsdllocation", "awsolLoc", "awsdlURL", "wsdlURL", "wsolLoc", "wsDLPath", "wsDLURL", "wsdlPath", "wdlLoc", "awsolURL", "wssdLocation", "wslLoc", "awsollocation", "wsdlocation", "wssdLoc", "wssdURL", "wslFolder", "wsdlFolder", "wsdLoc", "wlLocation", "awsdllocation", "wsdURL", "wssdFolder", "wdlPath", "wlLoc", "awsdLocation", "awsdlocation", "wsDLlocation", "awsdURL", "awsdlLoc", "wlPath", "wsdlLoc", "wsdLocation", "wsolURL", "wdlFolder"], "endpoint": ["idpoint", "startpoint", "startpoints", "startPoint", "beginpoints", " endport", "startword", "endpoints", "beginPoint", " endPoint", "Endpoint", "endline", "idPoint", "startline", "bindPoint", "beginpoint", "endword", " endpoints", "Endpoints", " endline", "bindport", "idline", "Endport", "bindpoint", "idpoints", "endPoint", "endport", "bindpoints", "EndPoint", "beginword", "Endword"], "fileLocation": ["filelocation", "FileLoc", "documentPosition", " filePosition", "FileLocation", "documentlocation", "fileLoc", "documentLocation", "documentLoc", " filelocation", "filePosition", " fileLoc", "Filelocation", "FilePosition"], "tempDir": ["tmpPath", " tempPath", "tmpFolder", "tempFolder", " tempUrl", "tempdir", "tmpDirectory", "TempDirectory", " tempFolder", "tempDirectory", "Tempdir", " tempDirectory", "TempPath", "TempFolder", "TempUrl", "tmpUrl", " tempdir", "tempPath", "tmpDir", "tempUrl", "TempDir", "tmpdir"], "url": ["dl", "li", "location", "build", "ul", "conn", "re", "nl", "mount", "str", "base", "loc", "l", "web", "gl", "uri", "il", "https", "cp", "r", "ssl", "browser", "cert", "ls", "open", "job", "mail", "sl", "up", "sur", "bel", "un", "ur", "f", "pl", "github", "http", "service", "ll", "link", "rel", "ret", "URL", "char", "m", "socket", "ctrl", "cr", "Url", "window"], "WSDLFile": ["WSDLFilename", "WSDLLFile", "WIDDLfile", "WSDLLString", "WNDLfile", "WSDELFile", "WSDELFilename", "WIDDLType", "WSDLSType", "WHDLfile", "WNDDLFile", "WSDMLfile", "WHDLFILE", "WSDLLFILE", "WIDLfile", "WSDLSFile", "WIDDLString", "WIDDLFile", "WHDDLFILE", "WSDDLType", "WIDLType", "WHDLFile", "WNDDLFILE", "WSDLSfile", "WSDLType", "WIDLFile", "WNDDLfile", "WSDLFILE", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDQLfile", "WSDMLFILE", "WSDDLFilename", "WSDDLfile", "WIDLString", "WSDLLType", "WHDDLFile", "WSDQLFile", "WSDQLFILE", "WSDLString", "WSDMLFile", "WSDELFILE", "WHDDLfile", "WNDLFILE", "WNDLFile", "WSDLSString", "WSDLLFilename", "WSDELfile", "WSDDLString", "WSDLfile", "WNDLFilename", "WSDDLFILE"], "tmpWSDLFile": ["tmpWSDLLFILE", "tmpWSDLDFile", "tmpWSDLFILE", "tmpWSDlfile", "tmpWSDDLFile", "tmpWSDLLFilename", "tmpWSDlFile", "tmpWIDDLFilename", "tmpWSDLFiles", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWSDDLfile", "tmpWNDLFiles", "tmpWNDLfile", "tmpWSDDLFiles", "tmpWSDLDFilename", "tmpWSDLLFile", "tmpWNDLFilename", "tmpWSDlFilename", "tmpWSDLDFILE", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWNDDLFiles", "tmpWNDDLFile", "tmpWIDDLfile", "tmpWSDLfile", "tmpWNDDLFilename", "tmpWIDLfile", "tmpWSDDLFILE", "tmpWSDLLfile", "tmpWSDLLFiles", "tmpWSDDLFilename", "tmpWNDDLfile", "tmpWSDLFilename", "tmpWIDLFile", "tmpWIDLFilename", "tmpWIDLFILE", "tmpWSDlFiles"], "inputFile": ["InputFILE", "InputPath", "outputStream", "clientFile", "InputDo", "inputPlace", "inputFILE", "inputfile", "errorfile", "inputDo", "infile", "errorFILE", "tmpStream", "intFile", "InputFiles", "indexfile", "interfaceFile", "Inputfile", "inPath", " inputDo", "interfacePlace", " inputfile", " inputSourceFile", "tmpfile", "intFiles", "outputfile", "indexFile", "outputFILE", "errorFile", "inputStream", "inputPath", "inputSourceFile", "outputFile", "interfacefile", "intfile", "inDo", "intFILE", "tmpFILE", "clientFILE", "InputStream", " inputFiles", "InputFile", " inputFILE", "inputFiles", "clientPath", "inFile", "tmpPlace", "tmpSourceFile", "errorStream", "clientFiles", " inputPath", "interfaceSourceFile", "indexFILE", "indexStream", " inputPlace"], "tmpFile": ["tempFilename", " tmpfile", "tmpPath", "mpPath", "inputFILE", "tempFile", "inputfile", "empFile", " tmpFiles", "empFILE", "mpFile", "empFilename", "tmpfile", "tmpFiles", "tempFILE", "tempFiles", " tmpPath", "tmpFILE", "empfile", "tmpFilename", "tempPath", "mpFiles", "mpfile", "tempfile", "inputFilename"], "in": ["c", "t", "io", "bin", "din", "inv", "conn", "stream", "id", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "ln", "inf", "ain", "source", "r", "client", "is", "ic", "input", "In", "n", "init", "o", "IN", "ini", "it", "ch", "from", "ar", "ins", "inn", "cin", "ai", "cont", "ri", "sin"], "out": ["c", "t", "tmp", "io", "buffer", "can", "write", "inv", "conn", "connection", "ne", "by", "os", "auto", "OU", "log", "file", "this", "en", "pool", "at", "sys", "client", "oss", "cache", "obj", "conv", "n", "on", "ao", "co", "all", "o", "conf", "net", "w", "outs", "ch", "group", "Out", "output", "we", "ex", "cm", "null", "to", "lock", "writer", "ou", "aos", "OUT", "outer"], "con": ["c", "can", "conn", "cone", "re", "cal", "Con", "connection", "Conn", "func", "const", "ln", "ain", "tc", "mc", "cp", "cons", "CON", "ws", "conv", "connect", "login", "un", "ran", "co", "soc", "exc", "win", "sec", "cur", "conf", "num", "cn", "cm", "ch", "fc", "com", "cin", "cos", "nc", "fn", "cf", "acon"], "fileLength": ["FILELength", "ileDuration", "fileLen", "fileSize", "objectLength", "channelDuration", "channelLength", "FILESize", "FILEDuration", "ileLen", "objectDuration", "ileSize", "fileFontSize", "channelFontSize", "objectFontSize", "channelSize", "fileDuration", "FILELen", " fileFontSize", " fileDuration", " fileLen", "objectSize", "ileLength", " fileSize"], "channelIn": [" channeledIn", "channelIN", "chanIn", "ChannelOut", "consoleedIn", "chanOut", "ChannelIN", "consoleIN", "clientin", "clientIn", "channeledIn", "clientSet", "clientOut", "channelin", "ChannelSet", "consoleIn", "chanIN", "ChannelIn", "chanSet", "channelSet", "ChanneledIn", "clientIN", "consoleOut", " channelin", " channelIN", "Channelin"], "channelOut": ["chanIn", "ChannelOut", "chanOut", "channelout", "courseout", " channelConn", "courseOUT", "chanConn", "Channelout", "ChannelConn", "channelConn", "consoleIn", "chanout", "ChannelIn", "consoleOUT", "ChannelOUT", "courseIn", " channelOUT", "courseOut", "consoleOut", "consoleout", " channelout", "channelOUT"], "tmpDocument": ["npDocuments", "tmDoc", "tpMedia", "tpDocument", " tmpDocuments", "tmpdocument", "tempDocument", "mkDoc", "tmpDocuments", "tmDocument", "tpFile", " tmpDoc", "tempDoc", "cpDoc", "mpdocument", " tmpdocument", "mkdocument", "tmdocument", "npDocument", "tpDocuments", " tmpMedia", "mpDocument", "cpDocument", "mpDoc", "cpdocument", "tmpDoc", "npFile", "mkDocument", "tmpMedia", "npMedia", "tempdocument"], "nl1": ["nlOne", "NL2", "nel3", "ln2", "pel1", "lnOne", "nl9", "nl0", "NL0", "nl01", "nr1", "sol9", "rn6", "nr01", "rn1", "rn3", "rnOne", "nrOne", "nl2", "sol0", "pelOne", "NL1", "nl3", "ln1", "nl6", "nel6", "pel01", "nel1", "ln0", "sol2", "NL9", "ln01", "nelOne", "ln6", "ln3", "sol1", "ln9"], "i": ["ip", "ori", "li", "y", "io", "v", "span", "bi", "ii", "k", "multi", "key", "xi", "I", "u", "id", "ui", "mi", "gi", "hi", "cli", "ami", "x", "is", "ie", "ti", "index", "ci", "pi", "ij", "ji", "a", "n", "me", "qi", "si", "ix", "init", "di", "info", "ini", "ims", "o", "it", "sim", "j", "\u0438", "m", "ai", "mu", "us", "ic", "ri", "ms"], "node1": ["layer0", "component2", "component1", "NodeOne", "component0", "Node001", "n0", "node0", "node2", "Node2", "layer91", "node91", "layer1", "Node0", " node91", "node001", "nodeOne", "n1", " node0", " node001", "n91", "layerOne", " node2", "ode001", "ode0", " nodeOne", "ode1", "ode2", "nOne", "componentOne", "Node1"], "tmpOut": ["tempIn", " tmpObj", "TempOUT", "npIn", "TempIn", "cmpout", "tempObj", "tmpIs", "mpOut", "mpObj", "cmpOut", "empOut", "tempout", "npOut", "tempOUT", "npObj", "tmpIn", "cmpIn", " tmpIs", "TempObj", "TempOut", " tmpout", "empIs", "npout", "tempIs", " tmpOUT", "tmpout", "mpIn", " tmpIn", "tmpObj", "tmpOUT", "tempOut", "empout", "mpout"], "retVal": ["RetVal", " retTrue", " retValue", "retTrue", "retValue", "RetValue", "RetTrue", "returnval", " retval", "retval", "returnVal", "Retval", "returnTrue", "returnValue"]}}
{"id1": "10361370", "id2": "19322910", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"hash": ["version", "html", "attribute", "ash", "test", "Hash", "print", "update", "render", "profile", "sign", "crypt", "index", "check", "handle", "password", "array", "match", "tag", "message", "sum", "ashes", "code", "filter", "h", "key", "header"], "saltBefore": ["sALTStart", "sadeAfter", " sALTStart", "sALTAfter", "saveAfter", "SaltPrevious", "SaltBefore", "sadePrevious", "sALTPrevious", "sadeBefore", " sALTBefore", "SALTPrevious", " sALTAfter", "sashStart", "SaltAfter", "sashBefore", "sashAfter", "sadeStart", "sALTBefore", "savePrevious", "saveBefore", "SALTBefore", "SALTAfter", "saltPrevious", "saltStart", " saltStart"], "content": ["text", "object", "c", "example", "license", "any", "translation", "data", "str", "html", "comment", "raw", "file", "document", "image", "expression", "body", "word", "string", "input", "Content", "path", "time", "entity", "title", "reason", "format", "password", "url", "media", "present", "description", "json", "value", "record", "sequence", "message", "output", "subject", "null", "initial", "config", "code", "xml", "cont", "current", "source", "txt"], "saltAfter": ["sadeAfter", "saltPost", "soltResult", "saltafter", "sALTAfter", "saveAfter", "soltAfter", "sALTResult", "SaltBefore", "sintBody", "sadeBefore", "valtafter", "soltBefore", "SALTResult", "saveafter", "sALTafter", "saveBody", "sALTBody", "valtBody", "vintBefore", "SALTPost", "sintBefore", "SaltAfter", "vintafter", "valtBefore", "saltResult", "sadePost", "sALTPost", "sALTBefore", "saltBody", "SaltPost", "sintafter", "SALTBefore", "SaltResult", "SALTAfter", "sadeResult", "saveBefore", "vintBody", "vintAfter", "valtAfter", "sintAfter", "soltPost"], "repeatedHashingCount": ["repeatedHashCode", "repeatedHashingCode", "repeatedHashescount", "repeatedHashCC", "repeatedRashLength", "repeatedHachingCC", "repeatedRashCC", "repeatedHashCount", "repeatedHashingCC", "repeatedRashingCounter", "repeatedHashesCount", "repeatedHashesCode", "repeatedHashingcount", "repeatedRashCount", "repeatedHashesCounter", "repeatedRashescount", "repeatedHASHCount", "repeatedHashLength", "repeatedRashingCount", "repeatedHASHLength", "repeatedRashingCode", "repeatedHashingCounter", "repeatedRashesLength", "repeatedRashesCounter", "repeatedRashingcount", "repeatedHashCounter", "repeatedRashingCC", "repeatedHashcount", "repeatedHASHCounter", "repeatedHachingLength", "repeatedHASHcount", "repeatedRashingLength", "repeatedRashesCount", "repeatedHashingLength", "repeatedHashesCC", "repeatedHachingCount", "repeatedRashCode", "repeatedHashesLength", "repeatedHachingCode"], "digest": ["descity", " digse", "algest", "designest", "mdse", "printest", " digested", "extester", "fingerest", "digesting", "debugest", "digEST", "fifest", "Digist", "Digest", "digum", "digitude", "digests", "fifitude", "Digests", "digute", "argest", "descse", "debugency", " Digested", "digester", "digity", "diagnests", "fingerhest", "algested", " digests", "descest", "debugitude", "fingeresting", " Digest", "printhest", "dighest", "fifency", "fingerEST", " digist", " digency", "designester", "mdested", "Digse", "commse", "digency", "dested", " digEST", " digester", "designested", "dfest", " digert", "compest", "digert", "dighash", " digity", "commity", "hashhash", "compute", "diagnest", "digested", "dfesting", "printEST", "fifEST", " dighest", "dse", " Digester", "diagnist", "designesting", "debugEST", "commested", "extested", " digitude", "algester", " digum", "comphash", "Digum", "Dighash", "dfested", "digse", "mdest", "hashest", " Digert", "argEST", "commest", "dest", "mdester", "Digute", "hashEST", "dert", "argested", "dfester", "argester", "dester", "DigEST", "diagnum", " digesting", "hashute", "algEST", "extse", "printesting", "compEST", "extest", "descested", "digist", "Digester", "Digested"], "digestLength": ["descestlength", "digesterlength", "digestedLength", "digselength", "digestType", " digestLen", "digestedlength", "descestLen", "descesterLen", "digesterLength", "digistData", "descesterOffset", "digistLength", "digesterData", "digestData", " digesterLength", "descesterlength", "digistType", "digistLen", "digseLen", "digestLen", "digesterOffset", " digesterData", "digestedType", " digestData", " digesterType", "digestedOffset", "digestOffset", "digseLength", "digesterLen", " digestType", "descestOffset", "digesterType", " digesterLen", "digestedLen", "descesterLength", "digseOffset", "digestedData", "digestlength", "descestLength"], "i": ["ip", "li", "y", "v", "bi", "in", "ii", "phi", "multi", "mill", "I", "xi", "u", "ui", "ind", "mi", "iu", "ski", "batch", "print", "gu", "gi", "uri", "im", "iter", "q", "client", "cli", "x", "is", "ti", "index", "ci", "err", "pi", "uu", "iq", "n", "me", "qi", "init", "si", "ix", "di", "ini", "ei", "it", "sim", "j", "sql", "my", "ex", "m", "z", "ai", "ic", "ms"]}}
{"id1": "8047989", "id2": "15166511", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getHashedID": ["getHackedHash", "getShashedId", "getHashedId", "getHashingString", "getHashingID", "getHashedHash", "getHackedId", "getHackedID", "getHASHID", "getShashingHash", "getShashedHash", "getShashedID", "getHashingHash", "getHASHString", "getHASHHash", "getShashedString", "getShashingString", "getHashedString", "getShashingId", "getHackedString", "getHashingId", "getHASHId", "getShashingID"], "ID": ["Id", "MD", "IDENT", "Name", "MAC", "DATA", "JS", "TYPE", "id", "FILE", " PID", " fid", "Key", "BY", "DS", "UID", "NULL", "DB", "P", " id", "AND", "TAG", "SHA", "name", "ASH", "NOTE", "ACK", "END", "PK", "NAME", "INT", "EL", "REF", "URI", "AD", "STR", "URL", "DER", "IDs", "KEY", "IDA", " NAME"], "md5": [" md3", "md6", " md512", "sha2", "sha7", "MD7", " MD7", "MD512", " MD6", " MD3", " MD4", "md75", " md75", "MD3", "md512", "md3", " md6", "hash75", "md7", "hash8", " md8", " md4", " md2", " MD8", " MD5", "sha5", "hash7", "dig2", "dig512", "MD4", "MD2", " md7", "hash5", "dig3", "MD5", "md8", " MD75", "sha6", "dig5", "MD6", "md2", "md4"], "digest": ["digast", "digests", " digEST", "mdest", "Digests", "mdment", "mdests", "Digment", "Digate", " digested", " digests", "digEST", "mdist", "digested", "DigEST", "Digast", " digast", "Digist", "mdEST", "mdate", "digate", " digate", " digment", " digist", "Digest", "digist", "digment", "Digested", "mdested", "mdast"], "bytes": ["gs", "terms", "tmp", "strings", "results", "faces", "binary", "tags", "details", "classes", "es", "bs", "fixes", "data", "parts", "flags", "this", "services", "raw", "images", "bis", "frames", "errors", "options", "https", "bits", "ces", "items", "pages", "rows", "ds", "bes", "xs", "some", "gc", "windows", "bps", "buf", "Bytes", "banks", "gb", "cells", "jobs", "lines", "blocks", "seconds", "nets", "ios", "values", "files", "fields", "groups", "types", "steps", "pieces", "boxes", "keys", "times", "s", "ips", "tes", "units"], "i": ["ip", "t", "fire", "li", "y", "io", "v", "span", "bi", "ii", "phi", "multi", "key", "I", "xi", "u", "ui", "ind", "mi", "batch", "ski", "inner", "b", "gu", "gi", "uri", "im", "q", "client", "cli", "x", "is", "ti", "ie", "ki", "index", "ci", "pi", "ij", "uu", "ji", "a", "n", "qi", "si", "init", "ix", "di", "ini", "ei", "o", "it", "sim", "j", "m", "ai", "us", "zi", "ic", "ri", "set", "ms"]}}
{"id1": "17996547", "id2": "18211588", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyDir", "copyFiles", "copyfile", " copyfile", "deletefile", "deleteDir", " copyDir", "CopyFiles", "CopyFile", "deleteFile", " copyFiles", "Copyfile", "deleteFiles", "CopyDir"], "fileToCopy": ["filetoWrite", "fileTOCop", "FILEToCop", "fileToSave", "FILETOCopy", "fileFromCopy", "fileFromDelete", "fileTomRemove", "fileToCop", "filetoRemove", "file2Cop", "FILEToSave", "filetoCopy", "fileFromWrite", "fileTOCopy", " filetoWrite", " fileToWrite", "FILETOCop", "fileTomDelete", "fileToDelete", "FILEToApply", "FILETOApply", "file2Apply", "filetoDelete", "fileToRemove", "fileFromRemove", "FILETOSave", "fileToWrite", "fileToApply", " fileToDelete", " filetoCopy", " filetoDelete", "fileTOSave", " filetoRemove", " fileToRemove", "fileTOApply", "file2Save", "file2Copy", "fileTomWrite", "fileTomCopy", "FILEToCopy"], "copiedFile": ["callediedPlace", "copyingFilename", "calledyingDir", " copriedDirectory", "coriedFILE", "copyingDir", "copyingDirectory", "coponeFILE", " copcedFilename", "copanedDir", "partriedLog", "copifiedDir", "partiedLog", " copiedFilename", "copiatedFile", "copriedFile", "copiatedPath", "copIEDFilename", "copyingPath", "copiedLog", "copifiedPlace", "partiedFilename", "copifiedFile", "copriedDirectory", "copanedPlace", "copiedFILE", "copicedfile", "copanedFILE", "coriedfile", "copriedFolder", "callediedFILE", "copiedPath", "copIEDFile", "copicedFILE", "copiedFilename", "coriedFile", "copriedPath", " copcedfile", "coricedfile", "callediedFile", "callediedDir", "coricedFile", "coponefile", "coricedFilename", "copyingFile", "coriedFilename", "copiedDirectory", "copicedFile", "copiatedDirectory", " copriedFile", "partiedFile", "copyingFolder", "copcedFilename", " copiedFolder", "copyingFILE", "copyingPlace", "copyingLog", "copIEDLog", " copiedDirectory", "coponeFilename", "copicedFilename", "coricedFILE", "copifiedfile", "calledyingFILE", "partriedFilename", "calledyingPlace", " copiedfile", "copifiedFILE", " copiedPath", "copiedFolder", "copifiedFilename", "copiatedFolder", "copriedLog", " copcedFile", " copriedPath", "copriedFilename", "copcedfile", "copriedfile", "coponeFile", "calledyingFile", " copriedFolder", "copriedFILE", "partriedFile", "copiedfile", "copcedFile", "copiedDir", "copanedFile", "copiedPlace"], "in": ["ains", "io", "bin", "read", "din", " din", "inv", "re", "inc", "isin", "rin", "ind", "file", "en", "inner", "inf", "ain", "inside", "iter", "vin", "im", "out", "r", "is", "input", "irm", "al", "up", "In", "on", "get", "gin", "f", "per", "ma", "init", "ini", "IN", "conf", "con", "it", "from", "ar", "ins", "inn", "cin", "doc", "ai", "i", "source", "oin", "form"], "outWriter": ["outputWrit", "outWrite", " outWriting", "outwriter", " outWrit", "outputStream", "outputStreamer", "outputwriter", " outwriter", "OutWriter", "OutWriting", "OUTWriting", "outWrit", " outStreamer", " outReader", "OUTReader", "outputWrite", "outStream", "outStreamer", "outHandler", "backWriter", "OUTWriter", "backStreamer", " outWrite", "outputHandler", "innerWrite", "outputWriter", "innerStream", "backReader", "outReader", "outWriting", "outputReader", "innerWriter", "innerHandler", " outStream", "OutReader", "outputWriting", "backwriter", "OUTwriter", "OutWrit", " outHandler"], "c": ["t", "ct", "count", "cl", "v", "cd", "k", "ac", "sc", "uc", "col", "u", "ce", "dc", "l", "cs", "bc", "e", "mc", "cp", "cc", "out", "r", "q", "gc", "cache", "cb", "rc", "chain", "ec", "n", "unc", "cut", "f", "d", "character", "ch", "cm", "pc", "cap", "char", "m", "code", "cr", "cos", "C", "i", "cont", "cmp", "nc", "cf", "lc"]}}
{"id1": "21395184", "id2": "5632808", "code1": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"test30_passwordAging": [" t30_passwordAged", " t30_PasswordAgent", " t30_passwordAlgent", " t30_password_ger", " t30_passwordLoggent", " t30_password_ged", " t30_PasswordAlgent", " t30_PasswordAlged", " t30_passwordAlger", " t30_passwordAgent", " t30_passwordLogging", " t30_passwordAlging", " t30_passwordAging", " t30_passwordLogger", " t30_password_ging", " t30_PasswordAlging", " t30_PasswordAger", " t30_PasswordAlger", " t30_passwordAlged", " t30_PasswordAged", " t30_passwordLogged", " t30_passwordAger", " t30_PasswordAging", " t30_password_gent"], "db": ["sb", "bd", "dl", "ct", "app", "Db", "cd", "cfg", "td", "or", "conn", "bs", "lib", "sd", "src", "data", "back", "html", "base", "fb", "mt", "log", "pr", "b", "bt", "bc", "dd", "dt", "cp", "sys", "storage", "ds", "mb", "eb", "dm", "cb", "gc", "DB", "database", "ref", "bl", "rb", "obj", "bur", "dat", "pd", "og", "always", "pkg", "d", "fd", "http", "gb", "di", "ld", "nb", "cur", "con", "internal", "rel", "sql", "display", "gd", "m", "store", "cr", "table", "pg", "quote", "bb"], "pst": ["dth", "prese", "pstat", "psse", "peste", "spstat", "pnd", "prsp", "pSt", "cpST", "cpst", "psp", "apnd", "lstat", "apSt", "pest", "preSt", "spst", "psSt", "pend", "apse", "lnd", "pestat", "dst", "dST", "pST", "cpsp", "psnd", "prst", "prth", "dsp", "prest", "lst", "psst", "lste", "cpth", "pste", "spste", "pth", "prend", "prST", "spnd", "pse", "apst"], "me": ["meta", "le", "pa", "spe", "gone", "md", "Me", "ome", "mia", "mail", "ste", "pe", "my", "true", "mu", " Me", "life", "ml", "ae", "ne", "eme", "this", "e", "body", "ge", "na", "mc", "de", "ma", "mage", "di", "match", "he", "made", "gate", "see", "mes", "ware", "ms", "mos", "te", "se", "eu", "mi", "them", "self", "mer", "study", "fo", "men", "be", "mph", "mn", "km", "msg", "pse", "mite", "meg", "med", "mic", "go", "ME", "queue", "mo", "email", "mem", "ve", "mx", "got", "em", "we", "hem", "she", "here", "gre"]}}
{"id1": "2668853", "id2": "17116123", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileTOPage", "decodeFilesToString", "decodeFileAsPage", "decodeFileAsFiles", "decodeFilesToFile", "decodeFileTOFile", "decodeFiles2Files", "decodeFileTOString", "decodeFileTOFiles", "decodeFiles2File", "decodeFileToFiles", "decodeFileAsFile", "decodeFile2Files", "decodeFileToString", "decodeFilesToFiles", "decodeFileToPage", "decodeFile2Page", "decodeFileAsString", "decodeFilesToPage", "decodeFiles2Page", "decodeFiles2String", "decodeFile2String", "decodeFile2File"], "infile": ["inputbase", "outFile", "inputpath", "inputwhere", "inputfile", "inputfilename", "inwhere", "InFile", "outpath", "Infile", "inpath", " inbase", "innwhere", " infilename", "innfilename", "inbase", "infilename", "inputFile", "outbase", "innbase", "inFile", "innfile", "Inbase", " inwhere", "Inpath"], "outfile": ["listfile", "listfp", "listFile", " outfilename", "tofile", "outFile", "tofp", "outfp", " outpath", "Outfilename", "tofilename", "OutFile", "Outpath", "outfilename", "outpath", "toFile", "infp", "inpath", " outFile", "listfilename", "infilename", "inFile", "Outfile"], "in": ["io", "bin", "din", "conn", " din", "re", "user", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ro", "ain", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "In", "n", "on", "get", "gin", "per", "init", "info", "o", "IN", "ini", "con", "it", "from", "amin", "ins", "inn", "cin", "ai", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "OU", "file", "en", "print", "inner", "b", "ln", "ent", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "w", "it", "outs", "output", "Out", "ex", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "tree", "buff", "base", "pad", "comment", "total", "attribute", "column", "length", "batch", "available", "document", "phrase", "temp", "bar", "queue", "zero", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "template", "row", "sample", "block", "sequence", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "data", "need", "stream", "length", "select", "raw", "print", "add", "before", "give", "iter", "q", " Read", "input", "index", "shift", "check", "open", "hold", "end", "start", "get", "pe", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "close", "photo", "top", " succ", "status", "commit", "successfully", "release", "democracy", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "security", "sufficient", "ceed", "ratulations", "green", "successful", "primary", "exist", "cess", "setup", "accept", " Success", "city", "warning", "safe", "danger", " convergence", "first", "unity", " successfully", "crit", " succeeded", "response", "town", "valid", "done", "master", "second", "support", "cont", "good", "error", "summary"]}}
{"id1": "22441244", "id2": "5683576", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"send": ["reply", "Send", "parse", "save", "submit", "create", "write", "build", "transfer", "print", "add", "post", "security", "sent", "mail", "end", "export", "get", "init", "execute", "apply", "message", "report", "msg", "set", "push"], "hsession": [" HSsession", "rsession", "rssession", " HSess", "HSession", "HSsession", "hhhip", "HShip", "hship", "hsess", "rsess", "hhip", " HSpace", "hspace", "hsessions", "HSess", "hhessions", "hsettings", " HSession", "hessions", "hhettings", "hettings", "HSessions", "HSettings", "HSpace", "hhession", "hession", "rspace", "hhsession", "hssession"], "session": ["ip", "content", "object", "manager", "account", "instance", "state", "view", "connection", "document", "sid", "client", "ess", "driver", "cache", "job", "name", "Session", "password", "event", "ession", "lock", "context", "message", "store", "parent", "set"], "repositoryName": ["repositoryname", "reposoryNAME", "repositionNAME", "repositoryData", "repositorPath", "repoitoryTitle", "repoositoryName", "repositorName", "repositorNAME", "reposositoryTitle", "repositorTitle", "repositionName", "repositionPath", "reposoryName", "reposositoryname", "repositoryNAME", "repoitoryNAME", "repositableName", "repositableData", "repositionTitle", "reposositoryName", "repoositoryPath", "repositableNAME", "repoositoryData", "reposositoryPath", "repoitoryData", "repoitoryName", "repositablename", "repositoryTitle", "repoitoryPath", "reposositoryData", "reposositoryNAME", "reposoryData", "repositoryPath", "reposoryname", "repoositoryname", "repoositoryTitle", "repoositoryNAME", "repoitoryname"], "ideIdint": ["ideIDind", "ideDINT", "ideIdline", "IDEidint", "IDEIdINT", "ideIdst", " ideThno", "IDEidINT", "IDEidst", "ideIdno", " ideIdind", "ideIdINT", "ideInfoint", "ideidINT", "ideIDint", "ideIdentint", "IDEIdst", "ideIdentno", "ideDst", "ideThno", "ideInfost", " ideThint", "ideidst", "ideThint", "ideIdind", "ideInfoINT", "ideThind", " ideThind", "ideThline", " ideIdline", "ideidint", "ideIDline", "ideIdentline", "IDEIdint", "ideIDno", " ideThline", "ideIdentind", "ideDint", " ideIdno"], "to": ["t", "tp", "TO", "top", "range", "po", "too", "os", "auto", "tt", "pos", "company", "phone", "ato", "route", "eto", "client", "topic", "no", "tr", "address", "To", "co", "token", "contact", "target", "o", "tel", "site", "toc", "st", "pro", "ta", "about", "addr", "by"], "cc": ["ct", "ico", "cl", "cv", "cd", "cy", "ac", "sc", "ce", "dc", "company", "CC", "cs", "tc", "ck", "mc", "cp", "cmd", "cb", "ci", "rc", "ec", "co", "cci", "control", "cca", "cn", "cm", "toc", "fc", "cin", "ctrl", "cr", "cmp", "ca", "ic", "cf", "cloud"], "bcc": ["sbcy", "vce", "vcc", "cbcm", "vcy", "bCC", "cbcc", "sbcc", "bck", " bCC", "rbce", "vck", "rbcc", "cbCC", "cbck", "bcy", "rbck", "rbcm", "sbck", " bcm", " bck", "bcm", "rbCC", "bce", "rbcy", "sbce"], "subject": ["content", "text", "head", "heading", "host", "html", "id", "comment", "author", "prefix", "uri", "security", "topic", "mail", "title", "name", "metadata", "note", "face", "description", "template", "message", "Subject", "source", "filename", "form", "header"], "body": ["content", "text", "object", "head", "binary", "any", "ODY", "padding", "bh", "buffer", "bill", "top", "inline", "default", "part", "data", "parts", "Body", "base", "html", "comment", "back", "inner", "b", "hex", "post", "other", "line", "no", "mail", "title", "name", "business", "note", "params", "handle", "url", "layout", "news", "description", "json", "template", "query", "response", "message", "output", "bytes", "files", "null", "report", "ody", "code", "shell", "h", "zip", "background", "source", "summary"], "attachments": ["achmentresses", "achmenttypes", "atttypes", "attachachment", "achmentachment", "Attachments", "attachresses", "attresses", "attachtypes", "Attachachment", "achmentments", "Attachtypes", "attments", "Attachresses"], "isHtml": [" isHHTML", "isJap", "isWhip", "IsHttp", "isJtml", "isChtml", "isChHTML", "isVtml", "isHHTML", " isWhip", " isHip", "isHhtml", "ishhtml", "isHttp", "isVHTML", "ishttp", "isJttp", " isWhhtml", "IsHap", "isWhtml", "isVip", "isJhtml", "isWhHTML", "ishap", "ishtml", "isChip", " isHhtml", " isWhtml", " isWhHTML", "isChhtml", "isHap", "IsHtml", "IsHhtml", "isWhhtml", "isHip", "isVhtml"], "charset": ["cherset", "charsetic", "charpets", "ChARSetter", "charpett", "CHarset", "chableset", "chippale", "ChARSET", "Charsetic", "Charset", "charpetter", "CHippet", "CHarsets", "quatset", "chacterspace", "charsET", "charpet", "cherspace", "CHippET", "charsetter", "charspace", "chactersetter", "chatsetter", "chippec", "chacterset", "quarsetter", "chARSets", "clersets", "chARSetic", "CHippets", "clerspace", "charsec", "chippets", "chatset", "channelset", "chippett", "chippet", "quatsetter", "chARSetter", "charpET", "chARSET", "Charsetter", "chatsale", "charpetic", "CHarsET", "CHippett", "clerset", "channelsetter", "channelsET", "clersetter", "ChARSet", "chersetter", "chactersets", "quatsec", "CHarsett", "quarsale", "quarset", "clarsetter", "chablesec", "clarset", "chersets", "CharsET", "chippetter", "chARSet", "charsale", "quatsale", "ChARSetic", "chablesetter", "charsett", "quarsec", "channelsetic", "chippET", "chatsec", "chARSpace", "chablesale", "charsets", "clarsets", "clarspace"], "headers": ["codes", "head", "details", "dr", "ors", "ers", "relations", "ilers", "comments", "heads", "metadata", " heads", "params", "ppers", "names", "members", " trailers", "users", "lines", "types", "authors", "files", "fields", "ters", "keys", "limits", "header"], "priority": ["level", " severity", "serial", "status", "state", "due", "flags", "order", "id", "pos", "company", "prefix", "phone", " urgency", "origin", "profile", "security", "grade", "comments", "policy", "primary", "title", "position", "password", "description", "properties", "context"], "email": ["et", "object", "example", "license", "echo", "detail", "instance", "view", "oe", "ne", "html", "server", "comment", "external", "el", "log", "test", "liner", "print", "document", "company", "e", "result", "il", "console", "ome", "ssl", "line", "mail", "database", "address", "enter", "er", "note", "password", "url", "Email", "description", "http", "gmail", "contact", "element", "ell", "all", "em", "template", "delete", "office", "event", "search", "die", "response", "domain", "sample", "message", "output", "link", "voice", "ee", "entry", "ilo", "report", "initial", "reset", "call", "shell", "xml", "model", "msg", "fax", "label"], "user": ["ip", "usage", "manager", "account", "actor", "uid", "human", "connection", "usr", "id", "used", "usa", "author", "username", "result", "ident", "creator", "client", "profile", "browser", "admin", "util", "entity", "login", "name", "me", "student", "use", "match", "User", "users", "person", "from", "output", "USER", "owner", "auth", "by", "system"], "identity": ["ethnicularity", "solidality", "IDENTance", "personificate", "idularity", "IDENTentity", "IDENTator", "primance", "identance", "idiciary", "primicate", "idITY", "primentity", "ententity", "personicate", "entifier", "solidentity", "IDENTularity", "identifier", "personentity", "instifier", "primity", "entularity", "ethnicity", "instity", "identularity", "solidularity", "IDENTitate", "IDENTality", "ethnicitate", "identITY", "recognicate", "idity", "identiciary", "IDENTicate", "presentitate", "personity", "recognance", "IDENTiciary", "recognentity", "presententity", "equalty", "identicate", "instator", "IDENTity", "entity", "presentularity", "IDENTITY", "IDENTificate", "identator", "solidity", "primificate", "identalty", "IDENTalty", "instentity", "instalty", "personITY", "presentity", "recognity", "equator", "idententity", "equentity", "idality", "identificate", "IDENTifier", "personiciary", "identality", "equity", "identitate", "ethnicentity", "instularity"], "_returnPath": ["_resultTo", "_ReturnAddress", "_returnAddress", " _errorPath", "_errorPoint", "_savePath", " _errorAddress", "_retCode", "_getDir", " _errorPoint", "_replyPath", "_retUrl", "_getTo", " _returnPoint", "_requestPoint", "_retPath", "_errorUrl", "_saveTo", "_retpath", "_ReturnPoint", "setsaveTo", "_requestName", "_getPath", "_returnTo", "_requestAddress", "_replyDir", "_errorpath", "_ReturnName", "_returnLocation", "_retPoint", "_errorName", "_returnDir", "setsavepath", "_errorAddress", "_savepath", "setsavePath", "_requestPath", " _returnName", "_retDir", "_deletePath", "_returnName", "_errorTo", "_resultPath", " _returnAddress", "_retTo", "_deletePoint", "_errorLocation", "_resultPoint", "_saveUrl", "_returnpath", "_replyCode", " _errorName", "setreturnpath", "_returnPoint", "_getCode", "setreturnUrl", "_returnCode", "_returnUrl", "_retLocation", "setreturnPath", "_errorPath", "_ReturnPath", "_resultLocation", "setsaveUrl", "_deletepath", "_deleteTo", "setreturnTo"], "_from": ["_actor", "longsource", " _author", "letabout", "remlocal", "_reset", "_form", "longto", " _about", "\tfrom", "longfrom", "letsource", "remowner", " _reset", " _form", "remaddr", "_owner", "letfrom", "_local", "\tauthor", "_source", "_addr", "_author", "remfrom", "\tform", "longreset", "_about", "letto", " _actor", "\tactor", " _source"], "_replyTo": ["_responseFrom", "_respondOnly", "_responseLine", "_replyLine", "_replyOnly", "_commentLine", "_ReplyFrom", "_replyTO", "_ReplyTo", "_returnTo", "_backTO", "_responseTo", "_respondTO", "_returnTO", "_responseTO", "_closeLine", "_closeTO", "_responseOf", "_backPath", "_commentTO", "_respondTo", "_returnFrom", "_returnOnly", "_replyOf", "_commentOf", "_ReplyOnly", "_ReplyTO", "_ReplyPath", "_responsePath", "_commentTo", "_replyPath", "_backFrom", "_backTo", "_closeTo", "_replyFrom", "_respondFrom", "_closeOf"], "_to": ["_site", "successtopic", "successta", "pritopic", "_ta", "successsite", "prita", "successto", "prito", "prisite", "_topic"], "_cc": [" _cs", " _cca", "_cca", "_subject", " _subject", "_cs"], "_bcc": ["_rck", "_rbcc", "_wca", "_bca", "_racc", "_rbck", "_wcc", "_bck", "_rbca", "_bacc", "_rbacc", "_rcc", "_wacc", "_rca", "_wck"]}}
{"id1": "16851955", "id2": "20886320", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"testTrainingBackprop": ["testTestingBackend", "testTrainingBprop", "testTestingBackprop", "testTrainingBProp", "testTrainingBackward", "testTrainingBward", "testTestingBackward", "testTrainingBend", "testTrainingBackend", "testTestingbackprop", "testTestingbackward", "testTrainingbackprop", "testTrainingbackward", "testTestingbackProp", "testTestingbackend", "testTrainingBackProp", "testTestingBackProp", "testTrainingbackend", "testTrainingbackProp"], "temp": ["tem", "t", "tmp", "create", "v", "Temp", "copy", "por", "this", "full", "mt", "file", "dest", "remove", "test", "loc", "mod", "complete", "prefix", "pt", "tc", "cp", "out", "mk", "porary", " temporary", "cache", "EMP", "partial", "created", "stem", "dat", "tm", "tar", "orig", "mp", "p", "relative", "template", "local", "w", "emp", "Tem", "output", "unt", "tab", "null", "empty", "zip", "fake", "make", " tmp", " Temp", "txt"], "layers": [" lasks", "lsayers", "listayers", "lpackages", " Lensions", "listanes", "lanes", "lsenses", " lumers", "lays", "liights", "llays", "slenses", "flayers", "lacks", "llacks", "flanguages", "llowers", " lensions", "liients", "lsanes", " lights", " lenges", "vlenses", "languages", "leenges", "flenses", "listenses", "slays", "vlpackages", "slights", "llients", "llanguages", " lanes", "lsasks", "lenses", "vlumers", " lowers", " Lights", "slensions", " Layers", "lowers", "listasks", "lepackages", "lenges", "leayers", "lumers", " lacks", "slayers", "vlayers", "liowers", "liumers", "lensions", "slanguages", " languages", " lenses", "liacks", " Languages", "leights", "flays", "lights", "lienges", "lients", "llayers", " lients", "llenses", "lipackages", "lasks", "liayers", " lpackages", "lienses"], "fann": ["FANN", "farn", "cannot", "fmanana", "ffain", " fannot", "fANN", "Fana", "Fannis", "flann", "fmanannis", "ffann", "fannis", "flana", "fmanANN", "fannot", "Fann", "cain", "fain", "ffannot", "carn", "ffarn", " farn", "flANN", "cann", "flannis", "fmanann", " fain", "fana"], "trainer": ["bracy", "tracy", "formayer", "Trayer", " trayer", " tracer", "triner", "stracer", "Tracer", "trayer", "truner", "Tracy", "runer", "formacer", "striner", "Trainer", "trrain", "strainer", "riner", "Triner", "bracer", "racer", "formainer", "rainer", "Trrain", "Truner", "tracer", "rrain", "brainer", "bruner", "racy", "strrain"], "desiredError": ["desiredException", "demireError", "desiringEvent", "demuredEr", "desiredEr", "desiredERROR", "desireEvent", "DesiredException", "demiredEvent", "deseedERROR", "deseedError", "desireError", "desuredEr", "desiringError", "desuredError", "DesiredValue", "demiredEr", "deseedException", "desIREDERROR", "desIREDException", "desuredEvent", "demireEr", "desiredEvent", "demiredError", "desIREDError", "demuredError", "DesiredError", "DesuredException", "DesuredValue", "DesuredERROR", "desuredException", "desuredValue", "demireEvent", "DesuredError", "DesiredERROR", "desiredValue", "desiringEr", "desuredERROR", "desireEr", "deseedValue", "desIREDValue", "demuredEvent"], "mse": ["mmpe", " mpe", " mso", "mpe", "mSE", "MSE", "dsem", "mroe", " mSE", "cmse", " mte", " msem", "dte", "Mte", "mrse", "mte", "mrpe", "mmese", "mmSE", "Mso", "cmese", "moe", "mso", "Moe", " moe", "dse", "mmse", "cmSE", "Mse", "mrso", "mese", " mese", "msem", "Msem", "cmpe", "Mpe", "dSE"]}}
{"id1": "1508930", "id2": "23335922", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"httpRequestByPOST": ["httpGetbypost", "httpRequestBypost", "httpRequestViapost", "httpGetbyPOST", "httpRequestWithPOST", "httpRequestbyPOST", "httpRequestbyGET", "httpRequestbyPost", "httpRequestWithGET", "httpGetByGET", "httpRequestWithPost", "httpRequestbypost", "httpGetByPost", "httpRequestViaPost", "httpGetBypost", "httpGetbyGET", "httpGetByPOST", "httpRequestViaGET", "httpRequestWithpost", "httpRequestByPost", "httpRequestByGET", "httpRequestViaPOST", "httpGetbyPost"], "url": ["dl", "location", "request", "method", "k", "host", "str", "base", "id", "loc", "l", "join", "web", "uri", "string", "pattern", "ssl", "path", "ls", "ref", "address", "name", "format", "ur", "pl", "http", "href", "api", "ll", "domain", "ret", "URL", "call", "Url", "remote", "key"], "timeout": ["version", "padding", "type", "method", "max", "length", "delay", "pool", "batch", "blocking", "body", "sleep", "ssl", "duration", "time", "format", "amount", "Timeout", "password", "number", "size", "seconds", "period", "wait", "port", "mode"], "params": ["terms", "ps", "details", "padding", "tags", "Parameters", "posts", "data", "parts", "forms", "pos", "images", "pins", "photos", "changes", "ams", "objects", "AMS", "styles", "pi", "Par", "spec", "param", "mas", "actions", "pps", "p", "media", "names", "properties", "list", " parameters", "query", "packages", "settings", "values", "keys", "mm"], "response": ["version", "reply", "content", "object", "respond", "onse", "example", "text", "request", "status", "view", "connection", "respons", "data", "answer", "document", "relation", "complete", "next", "result", "body", "string", "application", "success", "address", "format", "command", "resp", "description", "all", "frame", "relative", "network", "value", "template", "service", "json", "sequence", "block", "output", "message", "report", "null", "reset", "yes", "xml", "Response", "remote"], "httpClient": ["httpCase", "httpProxy", " httpclient", "httpConnect", " httpDo", "HttpConnect", "htmlDo", "HttpClient", "sslCo", "HttpProxy", "htmlCo", " httpConnect", "httpCo", " httpProxy", "httpDo", "sslCase", "ttpclient", "htmlClient", " httpCo", "htmlCase", "httpclient", " httpCase", "ttpConnect", "ttpProxy", "sslClient", "sslDo", "Httpclient", "ttpClient"], "httpPost": [" httppost", " httpPut", "HTTPPost", "httpPOST", "httppost", "HttpPut", "thisPost", "statusPos", " httpPOST", "thisPOST", "statusPost", "statusPut", "HttpPost", "HttpRequest", "ttpPOST", "HTTPRequest", "httpRequest", "httpPos", "thisPut", "HttpPos", "thispost", "HTTPPut", "HTTPPOST", "HTTPPos", "httpPut", "ttpPut", "ttpPost", "statusRequest", "HTTPpost", "HttpPOST"], "serverResponse": ["descriptionResponse", "descriptionDescription", " serverPage", "erverBody", "verResponse", "ServerAnswer", "serverEntity", " serverStream", "verCall", "serverCall", "verLine", "serverBody", "statusPage", "erverCall", "ServerEntity", " serverEx", "httpResponse", "serverPage", "descriptionStream", "statusEx", "ServerResponse", "httpBody", "ServerPage", "verBody", "serverStream", "erverResponse", "ServerStream", "statusResponse", "ServerDescription", " serverDescription", " serverEntity", "serverDescription", "descriptionAnswer", "erverLine", "statusEntity", "serverLine", "ServerEx", "httpCall", "httpLine", "serverAnswer", "serverEx", " serverAnswer"], "statusLine": ["serviceLine", "statusLink", "responseline", "StatusCode", "checkLine", "servicePage", "Statusline", "statusline", "specline", " statusLink", "statCode", "statusPage", "StatusPage", "statusCode", "serviceCode", " statusCode", " statusline", "checkline", " statusPage", "specCode", "serverPage", "serverCode", "checkPage", " statusResponse", "specLink", "statPage", "checkCode", "responseCode", "statusResponse", "StatusLine", "responsePage", "statLine", "statline", "serverLine", "serviceResponse", "specLine", "statLink", "responseLine"], "inputStream": ["contentThread", "InputPath", "outputStream", "InputSteam", "inputSource", "imageSteam", "outputSource", "inSteam", " inputThread", "outputPath", " inputSource", "inStream", "InputThread", "contentSteam", "imageStream", "imagestream", "inputPath", "instream", "imageReader", "InputReader", "inputstream", "contentSource", " inputSteam", "InputStream", "inputThread", "outputReader", "InputSource", "contentStream", "inReader", "inputSteam", " inputPath", " inputstream"], "inputReader": ["inputLibrary", "errorEditor", "errorReader", "serviceReader", "errorLibrary", "uploadStream", "imageStreamer", " inputEditor", "inputStreamer", "imageStream", "serviceEditor", "imageReader", "inputreader", "uploadStreamer", "InputReader", "InputStreamer", "serviceLibrary", "InputStream", "inputEditor", "imagereader", "uploadreader", "serviceStream", "Inputreader", "errorStream", " inputLibrary", "uploadReader"], "bufferedReader": ["buffenedReader", "buffinedWriter", "buffererStream", "buffinedReader", "buffenedLoader", "bufferedRunner", "buffedWriter", "bufferredRunner", "buffereredRunner", "bufferedWriter", "buffererredStream", "buffinedStream", "buffenedWriter", "buffererredWriter", "bufferredWriter", "buffererReader", "bedenedParser", "buffererredRunner", "bedenedLoader", "buffereredStream", "bederedReader", "buffereredReader", "buffedLoader", "buffererredReader", "bufferredStream", "buffedReader", "buffereredWriter", "bufferedParser", "bufferredParser", "bufferedLoader", "bufferredLoader", "buffererRunner", "buffedParser", "bufferredReader", "buffinedRunner", "bederedWriter", "buffenedParser", "buffererWriter", "bedenedWriter", "bufferedStream", "bederedParser", "bederedLoader", "bedenedReader"], "buffer": ["Buffer", "binary", "memory", "bound", "background", "stack", "black", "buff", "comment", "total", "layer", "batch", "document", "print", "phrase", "temp", "trace", "console", "button", "bar", "queue", "profile", "mb", "library", "cache", "database", "note", "escape", "buf", "builder", "absolute", "bone", "template", "append", "sequence", "message", "block", "display", "null", "change", "table", "filter", "bridge", "window"], "line": ["text", "le", "lin", "lane", "inline", "point", "nl", "user", "column", "comment", "log", "file", "liner", "LINE", "print", "l", "phrase", "ln", "e", "cell", "word", "Line", "eline", "string", "stroke", "email", "rule", "chain", "ine", "name", "n", "online", "frame", "row", "query", "link", "block", "sequence", "message", "entry", "code", "model", "error", "page", "header"], "lastErrorCode": ["lastStatusCount", "firstErrorCount", "lastStateClass", "lastStatusClass", "lastErrorClass", " lastErClass", "lastErClass", "lastStatusMessage", "lastStateMessage", "lastErrorCount", " lastErrorClass", " lastErrorCount", " lastErCount", "lastStatusCode", " lastErMessage", "lastEventMessage", "firstErrorMessage", "lastErMessage", "lastErCount", "firstStatusCode", "firstErrorCode", "lastErCode", "lastStateCode", "firstStatusClass", "lastEventClass", "firstErrorClass", "lastEventCount", " lastErCode", "lastStateCount", "firstStatusMessage", "firstStatusCount", "lastEventCode"], "lastErrorMessage": ["lastEventDescription", "lastStatusString", "lastErrorDetails", "lastErrorDescription", "lastIssueDetails", " lastStatusDescription", " lastErrorDetails", "lastEventString", "lastErrorMsg", "lasterrorMessage", " lastErrorMsg", "lastStatusMessage", " lastEventDescription", " lastErrorString", " lastEventString", "lastIssueDescription", "lasterrorLine", "lastIssueMsg", "lastStatusDetails", "lasterrorString", "lastEventMessage", "lastIssueMessage", "lasterrorDescription", " lastErrorDescription", "lastWarningDescription", " lastEventMessage", " lastEventLine", "lastStatusLine", " lastStatusMsg", "lastEventLine", " lastStatusDetails", "lastErrorString", "lastStatusDescription", "lastWarningMessage", " lastStatusMessage", " lastErrorLine", "lastErrorLine", "lastStatusMsg", "lastWarningDetails", "lastWarningMsg"]}}
{"id1": "22734545", "id2": "19322910", "code1": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"generate": ["generator", "decate", " generateiate", " generateate", "deciate", "validate", "generiate", " generateator", "decce", "decator", "generce", "validiate", "validce", " generatece", "validator"], "urlString": [" urlSource", "UrlRest", "urlRest", "uriSource", "lString", "UrlStr", "lInterface", "lStr", " urlRest", "urlInterface", " urlInterface", "UrlInterface", "urlStr", "uriRest", "lSource", "UrlString", "urlSource", "UrlSource", "uriString", " urlStr"], "target": ["t", "tmp", "location", "pdf", "top", "src", "arget", "host", "base", "file", "dest", "test", "temp", "trace", "result", "dir", "localhost", "origin", "gt", "png", "path", "title", "address", "name", "tif", "root", "project", "layout", "p", "template", "local", "link", "output", "to", "Target", "table", "bolt", "source", "filename", "summary"], "url": ["dl", "ml", "build", "ul", "rl", "nl", "mount", "str", "base", "user", "u", "l", "gl", "web", "loader", "uri", "https", "q", "r", "ssl", "browser", "ls", "www", "ref", "sl", "bel", "ur", "get", "f", "pl", "http", "hl", "ll", "link", "rel", "URL", "char", "Url"], "urlConnection": ["UrlConnect", "UrlConnection", "urlSession", "httpConnect", "urlConnect", "UrlSession", " urlconnection", "UrlConn", "handleConnection", "Urlconnection", "urlconnection", "handleConnect", "httpConn", "httpconnection", "webConnect", "browserConnection", "httpNode", "handleconnection", "urlConn", "browserconnection", "webconnection", "browserConnect", "urlNode", " urlConnect", "browserSession", "handleConn", "webConnection", "httpSession", "httpConnection", "webNode", " urlNode"], "inputStream": ["acceptStream", "InputSteam", "innerSteam", "inputSource", "readStream", "acceptSteam", "inputStyle", "outputSteam", " inputThread", " inputStyle", "readSteam", " inputSource", "acceptStyle", "InputThread", "readThread", " inputView", "activeStream", "innerStream", "innerstream", "readView", "inputstream", "activeSteam", " inputSteam", "acceptThread", "inputThread", "innerSource", "InputStream", "InputView", "inputView", "activeSource", "activestream", "inputSteam", "outputThread", "outputStyle", " inputstream"], "outputStream": ["outputStack", " outputStreamer", "displayStreamer", "displaySteam", "outputStreamer", "OutputSteam", " outputStack", "applicationStream", "OutputStream", "outputSteam", "writeStream", "writeStreamer", "applicationWindow", "displayContext", "outputForm", "writeForm", "OutputStack", "inputLink", "displayStream", "outputContext", "outputLink", "writeLink", "writeContext", " outputLink", " outputContext", "writeSteam", " outputForm", "OutputWindow", " outputSteam", "inputForm", "applicationSteam", "inputSteam", "outputWindow", "applicationStack", " outputWindow"], "buf": ["img", "cv", "Buffer", "buffer", "bin", "box", "arr", "bs", "buff", "Buff", "fb", "prop", "batch", "loc", "b", "bc", "vec", "bar", "cmd", "alph", "proc", "uf", "rev", "cb", "ob", "br", "bl", "rb", "fam", "conv", "dat", "var", "bag", "seq", "pkg", "cur", "nb", "cap", "block", "cat", "tx", "bytes", "tab", "db", "msg", "bu", "good", "bn"], "len": ["t", "dl", "li", "le", "ler", "v", "lon", "lib", "mil", "nl", "str", "L", "length", "el", "pos", "ind", "en", "l", "ln", "gl", "il", "vec", "del", "lan", "ls", "no", "lf", "El", "elt", "bl", "end", "nt", "n", "coll", "seq", "all", "BL", "val", "ld", "ll", "fin", "lic", "fun", "cap", "rel", "lit", "syn", "z", "cmp", "Len"]}}
{"id1": "20724937", "id2": "4562786", "code1": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"getTopicMap": ["getEventMap", "getTopicsMap", "getTopicTree", " getThreadTree", "getEventTree", "getThreadInfo", "getTopicList", "getMessageList", "getMessageTree", "getThreadList", "getMessageInfo", " getThreadMap", " getThreadList", " getTopicList", " getTopicsTree", "getTopicInfo", "getEventList", " getTopicsInfo", "getEventInfo", "getTopicsTree", " getTopicTree", " getTopicsMap", "getTopicsInfo", " getTopicsList", "getMessageMap", " getThreadInfo", " getTopicInfo", "getThreadTree", "getTopicsList", "getThreadMap"], "url": ["parse", "dl", "cl", "location", "request", "build", "host", "nl", "mount", "str", "base", "id", "server", "u", "html", "log", "file", "loc", "lr", "document", "l", "b", "gl", "web", "uri", "string", "pattern", "ssl", "browser", "item", "ls", "job", "mail", "ref", "address", "name", "ur", "pl", "http", "ll", "link", "domain", "URL", "char", "null", "resource", "xml", "Url", "page"], "baseURI": ["baseURL", "baseU", "basedURL", "BaseUR", "BaseURI", " baseU", "BaseU", "basedUR", "BaseURL", " baseUR", "baseUR", " baseURL", "basedURI", "basedU"], "inputStream": ["InputSteam", "openStack", "unsignedSteam", "openStream", "inputPort", "inputStreamer", "Inputstream", "unsignedStream", " inputView", "openSteam", " inputStreamer", " inputPort", "inputFile", "inputstream", "InputStreamer", "openView", " inputSteam", "InputView", "InputStream", "openFile", "inputView", "InputPort", "InputFile", "InputStack", " inputFile", "inputSteam", "openPort", "unsignedStreamer", " inputStack", " inputstream", "unsignedstream", "inputStack"]}}
{"id1": "23370621", "id2": "21016435", "code1": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"downloadFile": ["Downloadfile", "downloadfile", "loadfile", "downloadFiles", " downloadFiles", " downloadSingle", "loadFile", "DownloadFiles", "loadFiles", " downloadfile", "downloadSingle", "DownloadSingle", "loadSingle", "DownloadFile"], "target": ["txt", "t", "tmp", "tp", "location", "v", "buffer", "type", "top", " targ", "copy", "default", "fixed", "ver", "arget", "tree", "base", "this", "dest", "file", "test", "physical", "result", "dir", "secondary", "localhost", "gt", "out", "pattern", "path", "alias", "format", "tar", "goal", "root", "tif", "tor", "delete", "match", "set", "template", "touch", "local", "it", "rel", "output", "ret", "that", "null", "to", "table", "parent", "remote", "bolt", "source", "filename", "Target"], "s3key": [" s2Key", "s6key", "s4url", "s3Key", "sdkKEY", "sdkkey", "s2KEY", "s2Key", "sdkurl", "s4KEY", "s3KEY", "s3url", "s3secret", "s2secret", " s3secret", " s2KEY", "s6secret", "sdksecret", " s2key", "s6Key", " s2url", "s2url", "sdkKey", "s4Key", " s3KEY", "s4key", " s3Key", "s2key", " s3url", " s2secret"], "in": ["t", "io", "reader", "bin", "read", "din", "copy", "or", " din", "sin", "re", "stream", "data", "asin", "inc", "isin", "rin", "ind", "file", "mi", "en", "raw", "inner", "l", "e", "inf", "ain", "inside", "iter", "vin", "mc", "out", "r", "is", "input", "nin", "up", "In", "n", "on", "req", "gin", "f", "init", "o", "IN", "ini", "con", "local", "it", "from", "sql", "ins", "inn", "m", "cin", "ai", "i", "s", "mm", "source", "oin", "and"], "temp": ["tem", "t", "tmp", "buffer", "Temp", "top", "copy", "part", "base", "mt", "file", "dest", "test", "mod", "prefix", "pt", "tc", "out", "porary", "mk", "tr", " temporary", "EMP", "res", "partial", "tm", "stem", "dat", "tar", "mem", "mp", "p", "template", "local", "emp", "output", "tx", "tim", "my", "tab", "null", "unt", "to", "mm", "fake", "current", " tmp", "txt"], "fout": ["flOut", "ffou", "flowoutput", "vout", "ifout", "flowou", "wto", "vto", "ffOut", " fou", "Fout", "fabout", "foutput", "fabyout", "Fyout", "vouts", "flowout", "FOut", "ffto", " fouts", "fOut", " fOut", "flou", "fyout", "wOut", "wout", "flout", "fabouts", "ifou", "vOut", "fabOut", "ifoutput", "fou", "fto", "wouts", "ffouts", " foutput", "Fouts", "ifOut", " fyout", "ffout", "floutput", "ffoutput", "fouts", "flowOut"]}}
{"id1": "22441244", "id2": "14502142", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"send": ["reply", "Send", "parse", "save", "submit", "create", "write", "build", "transfer", "print", "add", "post", "security", "sent", "mail", "end", "export", "get", "init", "execute", "apply", "message", "report", "msg", "set", "push"], "hsession": [" HSsession", "rsession", "rssession", " HSess", "HSession", "HSsession", "hhhip", "HShip", "hship", "hsess", "rsess", "hhip", " HSpace", "hspace", "hsessions", "HSess", "hhessions", "hsettings", " HSession", "hessions", "hhettings", "hettings", "HSessions", "HSettings", "HSpace", "hhession", "hession", "rspace", "hhsession", "hssession"], "session": ["ip", "content", "object", "manager", "account", "instance", "state", "view", "connection", "document", "sid", "client", "ess", "driver", "cache", "job", "name", "Session", "password", "event", "ession", "lock", "context", "message", "store", "parent", "set"], "repositoryName": ["repositoryname", "reposoryNAME", "repositionNAME", "repositoryData", "repositorPath", "repoitoryTitle", "repoositoryName", "repositorName", "repositorNAME", "reposositoryTitle", "repositorTitle", "repositionName", "repositionPath", "reposoryName", "reposositoryname", "repositoryNAME", "repoitoryNAME", "repositableName", "repositableData", "repositionTitle", "reposositoryName", "repoositoryPath", "repositableNAME", "repoositoryData", "reposositoryPath", "repoitoryData", "repoitoryName", "repositablename", "repositoryTitle", "repoitoryPath", "reposositoryData", "reposositoryNAME", "reposoryData", "repositoryPath", "reposoryname", "repoositoryname", "repoositoryTitle", "repoositoryNAME", "repoitoryname"], "ideIdint": ["ideIDind", "ideDINT", "ideIdline", "IDEidint", "IDEIdINT", "ideIdst", " ideThno", "IDEidINT", "IDEidst", "ideIdno", " ideIdind", "ideIdINT", "ideInfoint", "ideidINT", "ideIDint", "ideIdentint", "IDEIdst", "ideIdentno", "ideDst", "ideThno", "ideInfost", " ideThint", "ideidst", "ideThint", "ideIdind", "ideInfoINT", "ideThind", " ideThind", "ideThline", " ideIdline", "ideidint", "ideIDline", "ideIdentline", "IDEIdint", "ideIDno", " ideThline", "ideIdentind", "ideDint", " ideIdno"], "to": ["t", "tp", "TO", "top", "range", "po", "too", "os", "auto", "tt", "pos", "company", "phone", "ato", "route", "eto", "client", "topic", "no", "tr", "address", "To", "co", "token", "contact", "target", "o", "tel", "site", "toc", "st", "pro", "ta", "about", "addr", "by"], "cc": ["ct", "ico", "cl", "cv", "cd", "cy", "ac", "sc", "ce", "dc", "company", "CC", "cs", "tc", "ck", "mc", "cp", "cmd", "cb", "ci", "rc", "ec", "co", "cci", "control", "cca", "cn", "cm", "toc", "fc", "cin", "ctrl", "cr", "cmp", "ca", "ic", "cf", "cloud"], "bcc": ["sbcy", "vce", "vcc", "cbcm", "vcy", "bCC", "cbcc", "sbcc", "bck", " bCC", "rbce", "vck", "rbcc", "cbCC", "cbck", "bcy", "rbck", "rbcm", "sbck", " bcm", " bck", "bcm", "rbCC", "bce", "rbcy", "sbce"], "subject": ["content", "text", "head", "heading", "host", "html", "id", "comment", "author", "prefix", "uri", "security", "topic", "mail", "title", "name", "metadata", "note", "face", "description", "template", "message", "Subject", "source", "filename", "form", "header"], "body": ["content", "text", "object", "head", "binary", "any", "ODY", "padding", "bh", "buffer", "bill", "top", "inline", "default", "part", "data", "parts", "Body", "base", "html", "comment", "back", "inner", "b", "hex", "post", "other", "line", "no", "mail", "title", "name", "business", "note", "params", "handle", "url", "layout", "news", "description", "json", "template", "query", "response", "message", "output", "bytes", "files", "null", "report", "ody", "code", "shell", "h", "zip", "background", "source", "summary"], "attachments": ["achmentresses", "achmenttypes", "atttypes", "attachachment", "achmentachment", "Attachments", "attachresses", "attresses", "attachtypes", "Attachachment", "achmentments", "Attachtypes", "attments", "Attachresses"], "isHtml": [" isHHTML", "isJap", "isWhip", "IsHttp", "isJtml", "isChtml", "isChHTML", "isVtml", "isHHTML", " isWhip", " isHip", "isHhtml", "ishhtml", "isHttp", "isVHTML", "ishttp", "isJttp", " isWhhtml", "IsHap", "isWhtml", "isVip", "isJhtml", "isWhHTML", "ishap", "ishtml", "isChip", " isHhtml", " isWhtml", " isWhHTML", "isChhtml", "isHap", "IsHtml", "IsHhtml", "isWhhtml", "isHip", "isVhtml"], "charset": ["cherset", "charsetic", "charpets", "ChARSetter", "charpett", "CHarset", "chableset", "chippale", "ChARSET", "Charsetic", "Charset", "charpetter", "CHippet", "CHarsets", "quatset", "chacterspace", "charsET", "charpet", "cherspace", "CHippET", "charsetter", "charspace", "chactersetter", "chatsetter", "chippec", "chacterset", "quarsetter", "chARSets", "clersets", "chARSetic", "CHippets", "clerspace", "charsec", "chippets", "chatset", "channelset", "chippett", "chippet", "quatsetter", "chARSetter", "charpET", "chARSET", "Charsetter", "chatsale", "charpetic", "CHarsET", "CHippett", "clerset", "channelsetter", "channelsET", "clersetter", "ChARSet", "chersetter", "chactersets", "quatsec", "CHarsett", "quarsale", "quarset", "clarsetter", "chablesec", "clarset", "chersets", "CharsET", "chippetter", "chARSet", "charsale", "quatsale", "ChARSetic", "chablesetter", "charsett", "quarsec", "channelsetic", "chippET", "chatsec", "chARSpace", "chablesale", "charsets", "clarsets", "clarspace"], "headers": ["codes", "head", "details", "dr", "ors", "ers", "relations", "ilers", "comments", "heads", "metadata", " heads", "params", "ppers", "names", "members", " trailers", "users", "lines", "types", "authors", "files", "fields", "ters", "keys", "limits", "header"], "priority": ["level", " severity", "serial", "status", "state", "due", "flags", "order", "id", "pos", "company", "prefix", "phone", " urgency", "origin", "profile", "security", "grade", "comments", "policy", "primary", "title", "position", "password", "description", "properties", "context"], "email": ["et", "object", "example", "license", "echo", "detail", "instance", "view", "oe", "ne", "html", "server", "comment", "external", "el", "log", "test", "liner", "print", "document", "company", "e", "result", "il", "console", "ome", "ssl", "line", "mail", "database", "address", "enter", "er", "note", "password", "url", "Email", "description", "http", "gmail", "contact", "element", "ell", "all", "em", "template", "delete", "office", "event", "search", "die", "response", "domain", "sample", "message", "output", "link", "voice", "ee", "entry", "ilo", "report", "initial", "reset", "call", "shell", "xml", "model", "msg", "fax", "label"], "user": ["ip", "usage", "manager", "account", "actor", "uid", "human", "connection", "usr", "id", "used", "usa", "author", "username", "result", "ident", "creator", "client", "profile", "browser", "admin", "util", "entity", "login", "name", "me", "student", "use", "match", "User", "users", "person", "from", "output", "USER", "owner", "auth", "by", "system"], "identity": ["ethnicularity", "solidality", "IDENTance", "personificate", "idularity", "IDENTentity", "IDENTator", "primance", "identance", "idiciary", "primicate", "idITY", "primentity", "ententity", "personicate", "entifier", "solidentity", "IDENTularity", "identifier", "personentity", "instifier", "primity", "entularity", "ethnicity", "instity", "identularity", "solidularity", "IDENTitate", "IDENTality", "ethnicitate", "identITY", "recognicate", "idity", "identiciary", "IDENTicate", "presentitate", "personity", "recognance", "IDENTiciary", "recognentity", "presententity", "equalty", "identicate", "instator", "IDENTity", "entity", "presentularity", "IDENTITY", "IDENTificate", "identator", "solidity", "primificate", "identalty", "IDENTalty", "instentity", "instalty", "personITY", "presentity", "recognity", "equator", "idententity", "equentity", "idality", "identificate", "IDENTifier", "personiciary", "identality", "equity", "identitate", "ethnicentity", "instularity"], "_returnPath": ["_resultTo", "_ReturnAddress", "_returnAddress", " _errorPath", "_errorPoint", "_savePath", " _errorAddress", "_retCode", "_getDir", " _errorPoint", "_replyPath", "_retUrl", "_getTo", " _returnPoint", "_requestPoint", "_retPath", "_errorUrl", "_saveTo", "_retpath", "_ReturnPoint", "setsaveTo", "_requestName", "_getPath", "_returnTo", "_requestAddress", "_replyDir", "_errorpath", "_ReturnName", "_returnLocation", "_retPoint", "_errorName", "_returnDir", "setsavepath", "_errorAddress", "_savepath", "setsavePath", "_requestPath", " _returnName", "_retDir", "_deletePath", "_returnName", "_errorTo", "_resultPath", " _returnAddress", "_retTo", "_deletePoint", "_errorLocation", "_resultPoint", "_saveUrl", "_returnpath", "_replyCode", " _errorName", "setreturnpath", "_returnPoint", "_getCode", "setreturnUrl", "_returnCode", "_returnUrl", "_retLocation", "setreturnPath", "_errorPath", "_ReturnPath", "_resultLocation", "setsaveUrl", "_deletepath", "_deleteTo", "setreturnTo"], "_from": ["_actor", "longsource", " _author", "letabout", "remlocal", "_reset", "_form", "longto", " _about", "\tfrom", "longfrom", "letsource", "remowner", " _reset", " _form", "remaddr", "_owner", "letfrom", "_local", "\tauthor", "_source", "_addr", "_author", "remfrom", "\tform", "longreset", "_about", "letto", " _actor", "\tactor", " _source"], "_replyTo": ["_responseFrom", "_respondOnly", "_responseLine", "_replyLine", "_replyOnly", "_commentLine", "_ReplyFrom", "_replyTO", "_ReplyTo", "_returnTo", "_backTO", "_responseTo", "_respondTO", "_returnTO", "_responseTO", "_closeLine", "_closeTO", "_responseOf", "_backPath", "_commentTO", "_respondTo", "_returnFrom", "_returnOnly", "_replyOf", "_commentOf", "_ReplyOnly", "_ReplyTO", "_ReplyPath", "_responsePath", "_commentTo", "_replyPath", "_backFrom", "_backTo", "_closeTo", "_replyFrom", "_respondFrom", "_closeOf"], "_to": ["_site", "successtopic", "successta", "pritopic", "_ta", "successsite", "prita", "successto", "prito", "prisite", "_topic"], "_cc": [" _cs", " _cca", "_cca", "_subject", " _subject", "_cs"], "_bcc": ["_rck", "_rbcc", "_wca", "_bca", "_racc", "_rbck", "_wcc", "_bck", "_rbca", "_bacc", "_rbacc", "_rcc", "_wacc", "_rca", "_wck"]}}
{"id1": "15580610", "id2": "23611770", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainClassifer", " trainModifier", " trainclassizer", " trainclassifier", " runClassifier", " runclassification", " trainModizer", " runclassifier", " runclassifer", " runclassizer", " trainModifer", " trainObjectizer", " runClassizer", " trainModification", " runClassifer", " trainObjectifer", " trainObjectification", " trainClassification", " trainClassizer", " trainclassifer", " trainclassification", " runClassification", " trainObjectifier"], "dir": ["dl", "tmp", "io", "wd", "dr", "lib", "src", "data", "base", "md", "this", "log", "pos", "disk", "loc", "div", "prefix", "dd", " directory", "path", "dm", "Dir", "rad", "DIR", "grad", "root", "url", "pkg", "folder", "d", "dist", "directory", "module", "local", "output", "ir", "direct", "report", "files", "done", "null", "doc", "config", "addr", "db"], "command": ["content", "text", "history", "binary", "Command", "request", "method", "buffer", "mpeg", "volume", "operation", "connection", "base", "column", "comment", "archive", "power", "attribute", "document", "component", "expression", "statement", "string", "button", "cmd", "pattern", "menu", "sudo", "shift", "application", "mac", "program", "chain", "multiple", "requisite", "position", "password", "three", "clear", "script", "pretty", "send", "paste", "description", "execute", "relative", "option", "search", "directory", "template", "query", "control", "delete", "event", "set", "link", "response", "sequence", "group", "message", "condition", "force", "display", "argument", "initial", "config", "function", "shell", "call", "key", "form", "and"], "length": ["level", "count", "deep", "ENGTH", "Length", "build", "max", "strip", "volume", "pad", "space", "total", "full", "fleet", "power", "loc", "collection", "available", "now", "bus", "dump", "prototype", "transform", "shape", "creator", "needs", "limit", "distance", "ctors", "duration", "shift", "upper", "end", "position", "capacity", "diff", "len", "load", "depth", "number", "value", "height", "character", "size", "append", "factor", "sequence", "SIZE", "ength", "pieces", "last", "given", "form"], "process": ["parse", "object", "pid", "request", "method", "worker", "status", "mpeg", "in", "view", "run", "processing", "component", "post", "result", "session", "console", "cp", "cmd", "proc", "Process", "flow", "check", "program", "thread", "term", "position", "start", "complex", "script", "exec", "handle", "p", "processor", "use", "load", "network", "search", "service", "channel", "event", "record", "link", "output", "message", "display", "pp", "call", "task", "node", "function", "connect", "system", "class"]}}
{"id1": "23291583", "id2": "310182", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["fectURL", "faultURL", "fectString", "FetchString", "FetchURL", "fetchString", "fectUrl", "faulturl", "faultUrl", "fecturl", "FetchUrl", "fetchURL", "Fetchurl", "faultString", "fetchurl"], "urlString": ["UrlRest", " urlSeries", "urlRest", "sslStr", "sslString", "lSeries", "Urlstring", " urlstring", "lString", "urlName", "sslSeries", "lStr", " urlRest", " urlName", "sslName", "uristring", "urlStr", "lName", "uriRest", "UrlString", "uriString", "urlstring", "urlSeries", " urlStr"], "outException": [" outCondition", "outTransaction", "outExample", "OUTTransaction", "cnEvent", "inExample", "inError", "inCondition", " outAddress", " outExample", " outEvent", "inException", "cnExample", "OutEvent", "OutCondition", " OUTException", "cnError", "OUTError", "outCondition", " OUTExample", "inAddress", "OutAddress", "OUTEvent", "outError", "inEvent", "OUTException", " outTransaction", "OUTExample", "OutException", "cnException", "outEvent", " OUTEvent", "outAddress", " OUTTransaction"], "url": ["dl", "ml", "org", "build", "ul", "lt", "rl", "host", "nl", "mount", "str", "base", "u", "el", "log", "download", "l", "b", "gl", "web", "uri", "https", "il", "r", "ssl", "impl", "cert", "ls", "www", "job", "mail", "email", "sl", "address", "bl", "dll", "bel", "ur", "get", "pkg", "pl", "github", "http", "channel", "hub", "ll", "hl", "link", "rel", "URL", "char", "xml", "Url"], "is": ["ip", "tis", "ists", "mos", "dis", "in", "es", "bs", "js", "os", "sis", "ils", "isin", "isc", "bis", "isi", "eps", "has", "ib", "serv", "was", "still", "isf", "im", "bits", "sys", "xs", "oss", "iso", "ls", "lis", "ys", "ires", "res", "ois", "its", "IS", "ris", "init", "fs", "ais", "ims", "isa", "iss", "ios", "isl", "vis", "sim", "ir", "abs", "inst", "i", "Is", "s", "ism", "ri", "ms"], "inc": ["c", "ctr", "count", "min", "ipl", "enc", "sc", "INC", "in", "acc", "ac", "pad", "incre", "ind", "isc", "dc", "const", "add", "ln", "inf", "iter", "cc", "dec", "index", "zero", "err", "step", "rc", "ec", "width", "exp", "exc", "init", "frac", "Inc", "num", "ch", "asc", "rec", "ins", "pp", "inn", "integ", "occ", "include"], "curr": ["rcr", "Currs", "curp", " curp", "currs", "rcrs", "corp", "catrid", "Curl", "constrid", "currd", " currd", " currb", "contl", "chn", "contr", "currb", "urr", "Curr", "chR", "urrc", "contp", " curl", "catr", "Curmr", " currid", "rcl", "catrs", "chp", " curn", "curR", "Currid", "grr", "constr", "corrd", "grrc", " currc", "curn", "Currb", " curmr", "corrb", "contn", " currs", "grp", "corn", "contrd", "currc", "corl", "Currc", "Curp", "currid", "rcmr", "curmr", "CurR", "curl", "Curn", "corr", "grrs", "contrc", "constrs", " curR", "chr"], "result": ["text", "tmp", "results", "memory", "buffer", "rendered", "status", "rue", "data", "answer", "length", "this", "total", "csv", "test", "batch", "collection", "complete", "phrase", "currency", "prefix", "next", "r", "proc", "cache", "res", "RESULTS", "success", "repl", "successful", "term", "block", "command", "buf", "false", "description", "all", "search", "match", "cur", "value", "list", "row", "record", "response", "sequence", "pre", "output", "ret", "message", "report", "valid", "true", "null", "master", "Result", "table", "current", "page", "summary"], "n": ["c", "t", "np", "le", "y", "v", "nu", "ng", "sn", "nl", "nr", "ne", "el", "en", "l", "ln", "e", "na", "nn", "r", "an", "no", "nt", "name", "nan", "un", "N", "p", "f", "d", "len", "number", "o", "num", "ll", "yn", "cn", "nor", "j", "m", "z", "nm", "gn", "g", "i", "s", "nc", "ns", "fn", "ren"], "temp": ["tem", "t", "tmp", "create", "v", "buffer", "Temp", "copy", "current", "tty", "buff", "tt", "test", "mod", "pt", "tc", "ph", "porary", "tr", " temporary", "EMP", "partial", "created", "tm", "term", "dat", "variable", "ptr", "mem", "orig", "mp", "perm", "template", "em", "local", "tv", "emp", "pre", "met", "tab", "unt", "mm", "fake", "make", " tmp", "alt", " Temp", "txt"]}}
{"id1": "20924119", "id2": "18613870", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"gzip": [" gZip", "mZip", "GZip", "marchive", "Gdef", "garchive", "Gzip", "mdef", "gZip", " gdef", "Garchive", " garchive", "mzip", "gdef"], "zipout": ["gzop", "gzOut", "gzin", "pipenet", "zipnet", "gzout", "zin", " zipo", " zipin", " zipnet", "zipouts", "lockop", "zipin", "zipop", "gzo", "zipconn", "pipeou", "pipeout", "pipein", "zouts", "zipou", " zipop", "login", "gzouts", " zipou", "gzconn", "logouts", "lockconn", "zOut", "lockout", "zout", "logOut", "zipo", "logout", "zipOut", "znet", "zou", " zipconn", "locko"], "buffer": ["history", "Buffer", "binary", "memory", "stack", "stream", "data", "pad", "buff", "comment", "attribute", "batch", "document", "phrase", "result", "word", "string", "button", "limit", "queue", "line", "cache", "device", "database", "command", "variable", "mem", "buf", "password", "paste", "frame", "number", "row", "size", "sample", "block", "sequence", "message", "append", "bytes", "char", "code", "table", "seed", "window", "header"], "dir": ["dl", "tmp", "det", "cd", "wd", "dr", "part", "tree", "md", "ind", "file", "pos", "div", "loc", "self", "add", "draw", "dd", "dra", " directory", "del", "iter", "out", "df", "mk", "path", "Dir", "cond", "DIR", "dat", "req", "root", "fd", "d", "folder", "pkg", " director", "ord", "dist", "directory", "cur", " Dir", "fin", "rel", "desc", "vol", "ir", "direct", "doc", "db", "parent", "ory", "rect", "def"], "in": ["reader", "bin", "read", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "inf", "ain", "inside", "iter", "source", "im", "out", "is", "input", "check", "al", "up", "In", "on", "gin", "init", "win", "ini", "IN", "like", "it", "from", "ins", "ex", "inn", "cin", "act", "i", "ic", "ri", "sin", "oin", "form", "and"], "length": ["history", "text", "count", "ENGTH", "type", "Length", "read", "frequency", "needed", "padding", "volume", "tail", "data", "total", "ind", "full", "available", "l", "component", "join", "before", "body", "shape", "impl", "distance", "index", "duration", "time", "family", "database", "end", "position", "capacity", "start", "len", "load", "height", "match", "number", "hello", "row", "character", "size", "sequence", "message", "char", "SIZE", "angle", "ength", "port"]}}
{"id1": "12066447", "id2": "8747840", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["extuncicate", "extvalidation", "trvalidation", "truncation", "extuncate", "trunize", "trunate", "trunation", "trculize", "extuncize", "trculicate", "trculation", "truncicate", "extvalidize", "trvalidate", "trvalidize", "trunicate", "trculate", "extvalidate", "extuncation", "extvalidicate", "trvalidicate", "truncize"], "file": ["object", "le", "io", "create", "type", "or", "range", "current", "run", "data", "tree", "base", "user", "FILE", "full", "log", "File", "attribute", "this", "image", "zip", "e", "dir", "source", "ile", "out", "line", "path", "time", "work", "spec", "name", "format", "foo", "handle", "get", "f", "use", "frame", "be", "channel", "info", "template", "module", "fp", "event", "local", "link", "lock", "block", "size", "message", "from", "report", "null", "files", "to", "resource", "model", "port", "table", "parent", "word", "page", "filename", "class"], "backupRoot": ["workupidHome", "backuproot", "backupsBox", "backflowRoot", " backupidDir", "workuproot", "workupHome", "workupidBoot", "backupidRoot", "backupidFolder", "backuperroot", "backmpDir", "backuperHome", "backupBoot", "BackupidRoot", " backupDir", "backumpBox", " backuproot", "BackupFolder", "BackupDir", "backuperRoot", "backumproot", "backupidDir", "backdownFolder", "workupRoot", "workupDir", "backupHome", "backupBox", "backupsRoot", "BackupidFolder", "backflowFolder", "backmpRoot", "backdownDir", " backupBox", "backupidroot", "backureroot", "workupidDir", "backupFolder", "backupidBox", "backuperDir", "backflowDir", "backureHome", "backmproot", "backureRoot", "backureBoot", "backupDir", "backureDir", "workupidRoot", "backupidHome", "backmpBoot", " backupidRoot", "backumpRoot", " backupidBox", "backupsroot", " backupidroot", "backupidBoot", "backupsDir", "BackupRoot", "workupidroot", "backdownRoot", "BackupidDir", "backumpDir", "workupBoot"], "df": ["dl", "tf", "raf", "pdf", "du", "dep", "cd", "dr", "sd", "md", "bf", "dp", "dc", "cf", "dd", "hd", "dt", " pdf", "ds", "deb", "uf", "lf", "dm", "pd", "format", "dim", "tif", "Def", "dx", "fd", "f", "d", "di", "DF", "fun", "NF", "gd", "sf", "mm", "db", "def"], "date": ["version", "save", "day", "content", "create", "zone", " day", "default", "range", "age", "down", "run", "data", "due", "cal", "future", "ate", "Date", "now", "year", " Date", "dt", "string", "update", "grade", "days", "time", "dated", "dates", "duration", "name", "dat", "format", "today", "note", "start", "late", "get", "month", "daily", "frame", "match", "number", "value", "module", "tag", "event", "standard", "message", "output", "sum", "resource", "when"], "zipFile": ["logfile", "pdfStream", "zFile", "zipPath", "zipStore", "ZipFile", "pdfFile", "logFile", "zipfile", "Zipfile", "ZipStream", "jsonfile", "zFilename", "ZipPath", "zStore", "logFilename", "zfile", "logPath", "jsonFile", "zipStream", "logStream", "logStore", "jsonFilename", "jsonStore", "zipFilename", "pdffile", "pdfPath"], "zos": ["zb", "ozo", "ss", "zar", "zan", "asar", "Sax", "asio", "bs", "ros", "zin", "js", "rez", "sbm", "sis", " sands", "hz", "os", "hs", "nz", "cz", "south", "zen", "esm", "ze", "webkit", "ones", "zer", "sch", "zona", "hess", "oss", "bes", "oses", "zag", "zzle", "eros", "enos", "ses", "estro", "los", "ez", "jas", "stice", "css", "za", "zers", "enz", "zon", "z", "zo", "tz", "zi", "zes", "zik", "sol", "cos", "shed"], "fis": ["foia", "dfIs", "fiiss", "fiois", "li", "sfisc", "dfis", "sfIs", "dfiss", "ofis", "fiss", "ofib", "ofits", "fits", "lia", "sfis", " fib", "ef\u00eds", "fiib", "foIs", "Fia", "foi", " fois", "Fisc", "F\u00eds", "fois", "efIs", "Fier", " fiss", "cfisc", "fier", "lis", "ofiss", "efisc", "FIs", "f\u00eds", "fia", "fiis", "lIs", "cfits", "ifisc", "sfier", "sfiss", "Fiss", "fib", "ofois", "ofisc", "cfis", "fIs", "efis", "dfier", "cfiss", "Fis", "ifis", "fi", "fisc", "sfits", "ifIs", "Fi", "if\u00eds"], "entry": ["object", "deep", "ry", "or", "member", "se", "connection", "data", "comment", "attribute", "ce", "tex", "insert", "add", "e", "cell", "ent", "word", "section", "ie", "entity", "de", "obj", "ace", "command", "Entry", "escape", "description", "delete", "element", "ary", "search", "row", "option", "rance", "office", "event", "record", "internal", "cue", "char", "sheet", "zo", "resource", "xml", "ion", "zip", "ment", "key", "set", "def", "and"], "buffer": ["binary", "memory", "Buffer", "padding", "view", "stack", "volume", "buff", "category", "base", "length", "comment", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "word", "button", "bar", "queue", "library", "zero", "cache", "screen", "command", "variable", "buf", "paste", "frame", "template", "sample", "block", "sequence", "message", "append", "char", "table", "code", "window", "page", "letter", "header"], "readed": ["READd", "ReadED", "reader", "readableied", "READer", "READED", "readd", "redented", "readared", " readED", "Readared", "findared", "indexeded", "reded", "readented", "counted", "Reader", "Readied", "rededed", "readED", "indexed", "indexED", "readableED", "readeded", "readableared", " readeded", "findied", "counter", "finded", "redED", "Readd", "READed", " readented", "readied", "countED", "Readed", "readableed", "findED", "countd", "indexented"]}}
{"id1": "16825994", "id2": "11673907", "code1": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"run": ["version", "unit", " Run", "spawn", "test", "su", "Run", "cmd", "running", "work", "check", "name", "un", "exec", "thin", "after", "execute", "con", "runs", "runner", "exe", "process", "call", "sun", "fn"], "out": ["t", "io", "v", "write", "conn", "os", "auto", "OU", "log", "file", "print", "b", "result", "gt", "sys", "r", "client", " OUT", "cb", "cache", "res", "err", "obj", "end", "up", "n", "all", "o", "net", "con", " Out", "w", "outs", "ch", "Out", "output", "we", "sum", "ex", "null", "to", "writer", "ou", "aos", "OUT", "outer"], "srcDir": ["socDiv", "sbDir", "distDIR", "sbD", "distD", "rcdir", "sbdir", "socDir", "srcPath", "sourceDir", "socdir", "rcDir", "sourceD", "sceneD", "sceneDir", "srcdir", " srcdir", "srcD", "rcDIR", " srcPath", "sourceDiv", "sceneDIR", "srcDiv", "sourcePath", "sourcedir", "srcDIR", "socPath", "distDir", " srcDiv", "rcD"], "conf": ["c", "cfg", "state", "default", "conn", "acc", "inv", "ctx", "Con", "etc", "Conf", "log", "func", "pool", "const", "sch", "cc", "cb", "cache", "job", "err", "ref", "obj", "conv", "map", " Conf", "f", "gb", "fs", "info", "con", "cn", "local", "cm", "ch", "context", "com", "config", "share", "cr", "auth", "ca", "Config", "cf", "lang", "def"], "srcFS": ["srcKS", " srcFs", "reqCS", "newKS", "sourceFS", " srcTS", "rcfs", "rcFs", "reqfs", "sourceLS", "sysFs", "newFs", "reqFs", "srcCS", "sourcefs", " srcOS", "srcfs", "srcTS", " srcfs", "sysLS", "rcFS", "sourceCS", "reqFS", "rcOS", " srcLS", "sysFS", "sourceTS", "sysOS", "sysKS", "newFS", "newTS", "sysTS", "sourceFs", "srcOS", "srcLS", " srcKS", " srcCS", "srcFs", "sysfs"], "contents": ["consents", "content", "CONTenses", "continains", "Contents", " content", "CONTensions", "CONTent", "contensions", "contENT", "Contens", "CONTENTS", "continENTS", "condains", "continent", "stENTS", "consENT", "condensions", "contacts", "constacts", "Content", "Contensions", "CONTens", " contenses", "consent", "contens", "contenses", "constents", "contENTS", "constent", "condENT", "condENTS", "contains", "CONTacts", "CONTains", "Contacts", "continents", "constensions", "stENT", "stent", "CONTents", "ContENTS", " contens", "Contenses", "condents", "consENTS", "condent", "stents"], "i": ["ori", "li", "y", "v", "bi", "ii", "phi", "multi", "key", "I", "xi", "u", "id", "ui", "base", "ind", "iu", "mi", "remote", "batch", "ski", "oi", "gi", "uri", "im", "q", "hi", "cli", "ami", "x", "is", "ki", "ti", "cgi", "index", "ci", "pi", "ij", "ji", "me", "qi", "si", "ix", "ma", "di", "ini", "ei", "o", "it", "sim", "j", "my", "\u0438", "m", "ai", "g", "ic", "ri"], "in": ["io", "bin", "read", "din", "min", " din", "re", "inc", "isin", "rin", "ind", "mi", "file", "en", "inner", "l", "ze", "inside", "body", "source", "r", "is", "input", "pi", "up", "In", "on", "gin", "ma", "ini", "IN", "con", "one", "it", "from", "ins", "inn", "m", "cin", "mm", "sin", "oin"]}}
{"id1": "14878593", "id2": "2834524", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": ["hyperloadUpdated", "hyperlinkupdate", "hyperlineClick", "hyperlineUpdated", " hyperlinkUpdated", "hyperLinkupdate", " hyperLinkUpdate", " hyperlinkupdate", "hyperLinkClick", "hyperLinkUpdated", "hyperlinkUpdated", "hyperLinkUpdate", "hyperloadClick", "hyperloadupdate", "hyperlinkClick", " hyperLinkClick", " hyperLinkUpdated", "hyperlineupdate", "hyperlineUpdate", " hyperLinkupdate", "hyperloadUpdate", " hyperlinkClick"], "e": ["et", "c", "t", "ae", "v", "fe", "ev", "te", "eur", "se", "es", "ef", "re", "oe", "eeee", "eu", "esc", "u", "el", "ce", "ame", "en", "Event", "l", "b", "ent", "ge", "eg", "r", "ie", "ue", "de", "err", "a", "er", "n", "ec", "p", "f", "d", "ve", "o", "event", "one", "ea", "w", "it", "E", "ee", "ex", "m", "h", "s", "ed"], "url": ["location", "buffer", "rl", "host", "nl", "mount", "str", "re", "html", "id", "base", "this", "el", "log", "loc", "lr", "l", "gl", "web", "uri", "string", "r", "ssl", "browser", "path", "ls", "ob", "job", "mail", "sl", "address", "term", "bel", "ur", "f", "pl", "http", "json", "hl", "ll", "link", "rel", "sql", "URL", "char", "addr", "resource", "Url", "filename", "form"], "stream": ["sync", "reader", "buffer", "read", "enc", "in", "view", "stack", "data", "str", "pipe", "mount", "down", "user", "upload", "file", "download", "pool", "image", "ream", "secure", "body", "iter", "console", "transform", "out", "REAM", "path", "our", "input", "res", "open", "sl", "present", "feed", "http", "sw", "Stream", "channel", "row", "sample", "context", "message", "steam", "resource", "zip", "clean", "window", "source", "form", "iterator"], "writer": ["written", "widget", "io", "reader", "buffer", "write", "worker", "manager", "wire", "file", "liner", "document", "draw", "loader", "word", "console", "string", "creator", "storage", "client", "white", "player", "browser", "ner", "riter", "writing", "er", "builder", "maker", "caster", "writ", "Writer", "wright", "unsigned", "local", "w", "output", "writers", "null", "master", "WR", "to", "wrote", "window"], "editor": ["license", "cer", "widget", "reader", "buffer", "instance", "paper", "actor", "translation", "or", "core", "view", "order", "over", "answer", "server", "auto", "external", "Editor", "upload", "insert", "liner", "author", "ui", "document", "edited", "language", "loader", "options", "action", "older", "oder", "button", "creator", "storage", "definition", "browser", "player", "edit", "video", "offer", "application", "enter", "er", "accept", "term", "EDIT", "builder", "maker", "media", "folder", "description", "init", "option", "finder", "settings", "vector", "area", "entry", "article", "code", "owner", "key"], "name": ["version", "text", "named", "type", "Name", "nl", "key", "tree", "base", "id", "str", "length", "comment", "part", "order", "file", "ame", "lower", "prefix", "string", "normal", "path", "no", "family", "title", "term", "format", "n", "position", "me", "root", "NAME", "names", "description", "all", "init", "info", "one", "local", "size", "null", "label", "nm", "code", "resource", "alpha", "word", "source", "filename", "system"], "dialog": ["compog", "dlag", "Dialch", "dog", "dializ", "dlop", "Dialogs", "dlogs", "Dialoder", "dlogue", "tdg", "conresh", "dialag", "dialch", "conog", "dlose", "initialog", "tdect", "redg", "initialag", "dialect", "doog", "conoder", "compoder", "redog", "choop", "dialop", "Dialag", "tdog", "dialose", "conch", "Dialose", "dlOG", "doect", "dlog", "compch", "Dialresh", "choogs", "dialogue", "Dialogue", "dialOG", "dialresh", "choogue", "initialose", "Dialog", "dialg", "dialogs", "redect", "doiz", "Dialop", "initialOG", "compresh", "DialOG", "dialoder", "choog", "rediz", "tdiz"]}}
{"id1": "8000624", "id2": "5237257", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyInt", " copyFrom", " copiesInt", " copyTo", "CopyFrom", " copiesFrom", " copiesTo", " CopyFrom", "CopyInt", " CopyInt"], "dest": ["img", "est", "tmp", "th", "Dest", "v", "copy", "src", "pipe", "usr", "nom", "rest", "loc", "them", "image", "temp", "result", "dir", "origin", "path", "opt", "name", "orig", "mem", "p", "d", "target", "w", "it", "cat", "output", "st", "null", "sp", "cont", "fn", "source", "filename", "txt"], "in": ["t", "reader", "bin", "ire", "din", "min", "read", " din", "ac", "re", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "image", "l", "inf", "ain", "inside", "iter", "source", "r", "client", "is", "input", "nin", "al", "up", "login", "In", "on", "thin", "gin", "per", "init", "win", "o", "IN", "ini", "net", "con", "one", "local", " input", "it", "internal", "from", "ir", "ar", "ins", "inn", "m", "cin", "ai", "i", "sin", "by"], "out": ["t", "io", "v", "dis", "write", "can", "boot", "oe", "ne", "by", "os", "user", "full", "en", "batch", "inner", "b", "ln", "e", "at", "flush", "na", "ot", "gt", "oss", "client", "res", "end", "obj", "nt", "up", "op", "conv", "n", "note", "co", "all", "list", "o", "net", "con", "one", "cn", "w", "outs", "it", "output", "Out", "ex", "null", "ns", "to", "cos", "not", "writer", "ou", "fn", "aos", "loss", "OUT", "outer", "other"], "c": ["t", "ct", "count", "cl", "v", "cd", "ac", "k", "sc", "uc", "ca", "u", "ce", "arc", "l", "cs", "bc", "e", "cp", "cod", "cc", "cb", "gc", "rc", "ec", "n", "unc", "cut", "f", "d", "character", "conf", "con", "ch", "cm", "cap", "cat", "char", "z", "code", "cr", "C", "i", "cont", "nc", "current", "cf", "g", "lc"]}}
{"id1": "3024970", "id2": "5414088", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToInputstream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamTooutputFile", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoInputSteam"], "in": ["scan", "c", "io", "bin", "read", "din", "copy", " din", "sin", "inv", "ac", "isin", "rin", "ind", "log", "el", "en", "this", "mi", "inner", "l", "inf", "ain", "inside", "iter", "im", "mc", "q", "r", "is", "input", "nin", "al", "up", "In", "n", "on", "p", "gin", "init", "ini", "IN", "con", "it", "sql", "from", "ins", "inn", "cin", "doc", "ai", "xml", "h", "i", "mm", "ic", "source"], "baout": ["baend", "caio", "caout", "BAin", "BAOut", "boio", "kain", "balog", "baot", "boout", "BAot", "kaout", "Baouts", "calog", " baot", " bain", "caOut", "oaout", "oain", "baouts", "baio", " balog", "Balog", "bain", "BaOut", "Baout", "cain", "abain", "kaend", "boin", "abaout", " baOut", "BAout", "abaot", "boOut", "kaOut", "caouts", "abaOut", "baOut", "oaOut", " baend", "caend", "oaio", " baouts"], "out": ["t", "io", "gr", "OUT", "copy", "OU", "log", "b", "serv", "at", "gt", "sys", "cmd", "client", "oss", "ot", "check", "res", "obj", "up", "conv", "n", "co", "all", "list", "o", "net", "con", " Out", "it", "outs", "Out", "output", "sum", "ex", "null", "to", "g", "ou", "aos", "set"], "count": ["c", "ct", "ctr", "read", "id", "length", "total", "index", "counter", "found", "nt", "start", "amount", "resp", "N", "number", "nb", "num", "size", "sum", "Count", "z", "code", "ount", "current", "skip"]}}
{"id1": "8515891", "id2": "19494842", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "label": 0, "substitutes": {"readUrl": ["getUrl", "readUr", "READUr", "loadURL", "getUr", "loadurl", "loadUrl", "geturl", "readURL", "readurl", "READUrl", "getURL", "READurl", "READURL", "loadUr"], "svnUrl": ["svnsServer", " svNServer", "svgUr", "svnURL", "svnsUrl", "svneStr", "svgURL", "svNUrl", "svnsURL", "servicenUr", "svNUr", "servicensURL", "svneServer", "svcUrl", "svNStr", "svnServer", "servicenurl", " svNUrl", "svgurl", "servicensUrl", " svNStr", "svcUr", "svgUrl", "svnsurl", "servicenUrl", "svnsUr", "svnurl", "svcURL", "svcurl", "servicensurl", "svNServer", " svNUr", "servicenURL", "svnUr", " svnServer", "svneUr", " svnUr", "servicensUr", " svnStr", "svnStr", "svneUrl", "svnsStr"], "url": ["lb", "ml", "dl", "cl", "location", "org", "build", "ul", "conn", "acl", "nl", "mount", "str", "base", "html", "host", "raw", "lr", "loc", "l", "gl", "google", "uri", "https", "r", "ssl", "browser", "uf", "impl", "ls", "mail", "ref", "sl", "uu", "bel", "ur", "pl", "github", "http", "ld", "hl", "ll", "link", "abs", "URL", "char", "call", "Url"], "uc": ["c", "cl", "ul", "sc", "ac", "eu", "oc", "conn", "ub", "u", "ui", "ud", "loc", "dc", "bc", "cus", "tc", "mc", "cc", "roc", "nic", "usc", "uf", "uci", "ux", "ci", "orc", "cu", "rc", "uu", "userc", "UC", "ucc", "ec", "uh", "co", "unc", "soc", "unic", "cur", "con", "auc", "fc", "anc", "lu", "cr", "us", "nc", "lc"], "userPassword": ["userGrant", "userpassword", "managerAuth", "userData", "managerPassword", "userPass", "browserPass", "UserPass", " userGrant", " userpassword", " userData", "Userpassword", "managerGrant", "browserData", "browserPassword", " userAuth", "UserAuth", "userAuth", " userPass", "browserpassword", "managerPass", "UserData", "UserPassword", "UserGrant"], "encoding": ["enryption", "enasing", "enoding", "encoder", "coding", "Encryption", "Encoding", "ecryption", "caling", "Encoder", "Encaling", "encasing", "ecaling", "ecoding", "cryption", "ecasing", "Encasing", "encaling", "ecoder", "encryption", "enoder", "coder"], "is": ["ip", "tis", "ists", "iris", "es", "\u00eds", "os", "sis", "imp", "isin", "mi", "isc", "bis", "isi", "isf", "im", "ows", "oss", "as", "iso", "lis", "ys", "ois", "its", "IS", "si", "ris", "fs", "ims", "ais", "isa", "mis", "iss", "it", "ios", "isl", "vis", "abs", "ir", "obs", "ins", "us", "i", "Is", "ic", "ism", "ri", "s", "ms"], "in": ["text", "t", "v", "bin", "read", "din", "k", "str", "inc", "isin", "rin", "file", "en", "print", "inner", "l", "ln", "e", "vin", "out", "r", "pin", "input", "nin", "login", "In", "n", "on", "password", "gin", "f", "edIn", "IN", "con", "it", "sum", "lit", "ins", "report", "inn", "m", "cin", "oin", "i", "kin"]}}
{"id1": "2910383", "id2": "16719805", "code1": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"downloadAndOpen": [" downloadButUpdate", " downloadandShow", " downloadAndUpdate", " downloadAndShow", " downloadButOpen", " downloadandOpen", "downloadandUpdate", "downloadAndClose", "downloadandShow", "downloadAndUpdate", "downloadandClose", " downloadandClose", "downloadandOpen", " downloadandUpdate", "downloadAndShow", " downloadAndClose", " downloadButClose", " downloadButShow"], "bar": [" math", "car", "bench", "widget", "coord", "worker", "status", "ba", "cal", "pad", " meter", "log", "batch", "camera", "cart", "percent", "b", " toolbar", "access", "print", "trace", " boredom", " toast", "progress", "browser", "mb", "board", "cb", "tr", "bars", "br", "par", "job", "step", "watch", "var", "foo", "buf", "chart", "per", "pair", "ray", " badge", "gb", "row", "hub", "Bar", "meter", "cam", "bo", "cor", " batch", "ar", "display", "tab", "ex", "report", " sidebar", "char", "store", "gob", "ca", "box", "page", "bart"], "size": ["scroll", " Size", "scale", "count", "zone", "fee", "max", "sn", "space", "length", "file", "sized", "dimension", "ze", "body", "shape", "out", "limit", "storage", "zero", "equal", "pi", "name", "small", "dim", "width", "amount", "city", "capacity", "news", "send", "height", "number", "IZE", " sizes", "sample", "message", "sum", "SIZE", "large", "null", "bytes", "see", "ize", "empty", "Size", "set"], "image": ["save", "img", "managed", "jpg", "example", "memory", "photo", "instance", "age", "view", "tree", "archive", "auto", "upload", "attribute", "file", "images", "document", "Image", "error", "picture", "still", "im", "source", "update", "png", "audio", "ami", "path", "item", "video", "cache", "application", "email", "entity", "policy", "address", "up", "name", "format", "cover", "position", "safe", "gif", "media", "album", "frame", "mage", "directory", "one", "internal", "link", "local", "sample", "message", "output", "large", "m", "empty", "to", "xml", "associated", "pixel", "window", "page", "figure"], "url": ["img", "t", "ul", "rl", "re", "nl", "mount", "str", "u", "loc", "l", "b", "web", "uri", "https", "il", "r", "ssl", "browser", "hash", "www", "util", "mail", "email", "sl", "address", "ref", "att", "bel", "ur", "handle", "gif", "get", "f", "github", "http", "val", "api", "hub", "hl", "ll", "link", "force", "rel", "URL", "char", "git", "m", "xml", "h", "Url"], "fOut": ["eIn", "sfOut", "fbout", "yIn", " fIn", "vOutput", "vout", "yBody", "fBody", "fOutput", "yOut", "sfOutput", "fbDef", "yOutput", "fout", "fbObj", "fDest", " fDef", "eBody", "eOutput", " fBody", "fObj", "eOut", " fout", "vOut", "fIn", "cfDest", " fObj", " fDest", "sfout", "fbDest", "cfOutput", "fbOut", " fOutput", "fbOutput", "cfOut", "cfObj", "vDef", "fDef"], "html": ["embed", "history", "img", "t", "details", "v", "rendered", "yt", "wh", "data", "md", "more", "live", "raw", "htm", "flash", " HTML", "web", "hd", "https", "body", "browser", "hash", "HTML", "util", "hr", "plain", "title", "format", "p", "get", "f", "wrapper", "http", "tml", "frame", "json", "strong", "height", "api", "all", "wrap", "link", "nav", "we", "git", "doc", "page", "sh", "h", "i", "sp", "xml", "msg", "ht", "summary"], "buffer": ["scroll", "history", "memory", "binary", "Buffer", "detail", "padding", "view", "stack", "tree", "buff", "length", "comment", "attribute", "batch", "document", "phrase", "cell", "word", "iter", "queue", "library", "cache", "check", "database", "command", "variable", "note", "buf", "absolute", "password", "bone", "paste", "frame", "number", "directory", "template", "sample", "sequence", "block", "message", "append", "char", "display", "initial", "table", "code", "window"], "bytesRead": ["codesRead", "stepsWrite", "codesREAD", "unitsBuild", " bytesReader", "stepsReader", "blocksReader", "blocksRead", "bytesNeed", "codesWrite", "keysReader", "tesWritten", "rowsReader", " bytesNeed", "rowsWritten", "tesread", "keysRead", "usersread", "rowsRead", "bytesread", "bytesReader", " bytesread", "codesReader", "usersWritten", "rowsread", "unitsRead", " bytesWrite", "bytesWritten", "rowsWrite", "stepsRead", "usersBuild", " bytesREAD", "bytesBuild", "unitsWritten", "keysWritten", "rowsNeed", "blocksREAD", " bytesWritten", "unitsread", "bytesWrite", "stepsNeed", "blocksWrite", " bytesBuild", "keysread", "tesRead", "bytesREAD", "tesReader", "usersRead"], "in": ["t", "count", "um", "din", "min", "k", "id", "inc", "ind", "el", "pos", "en", "inner", "add", "e", "body", "out", "r", "an", "x", "is", "line", "input", "dec", "no", "index", "time", "pi", "In", "n", "un", "old", "p", "f", "d", "gin", "IN", "row", "con", "num", "it", "from", "sum", "ins", "inn", "cin", "ai", "i", "oin"]}}
{"id1": "23510383", "id2": "6421904", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": [" SaveApp", "createPackage", "createApp", " SaveProject", " SaveFile", "createFile", " SavePackage", "savePackage", " saveFile", "saveFile", " saveApp", "createProject", "saveApp", " savePackage"], "file": ["io", "create", "in", "data", "base", "id", "FILE", "full", "log", "File", "ame", "complete", "image", "e", "dir", "ile", "path", "open", "foo", "handle", "project", "get", "use", "info", "local", "link", "files", "report", "real", "db", "parent", "table", "resource", "port", "filename"], "types": ["Types", "features", "projects", "codes", "strings", "otypes", " Types", "tags", "classes", "posts", "views", "parts", "plugins", "services", "assets", "ports", "scripts", "options", "thumbnails", "items", "versions", "pages", "objects", "ids", "styles", "actions", "sites", "names", "models", "sets", "packages", "resources", "tests", "ties", "values", "files", "pes", "packs", "groups", "keys", "issues", "times", "apps", "events", "ypes", "ts"], "images": ["videos", "faces", "tags", "links", "classes", "views", "frames", "image", "assets", "Image", "photos", "picture", "scripts", "thumbnails", "versions", "pages", "styles", "icons", "media", "models", "uploads", "blocks", "files", "groups", "Images", "boxes", "events"], "trajectories": ["tractables", "Trajory", "trajectory", "trajables", "traceptories", "tractories", "traceptables", "Trajories", "tractory", "Trajectory", "Trajectors", "traceptory", "traceptors", "Trajectables", "trajory", "trajectors", "Trajectories", "Trajables", "trajors", "tractors", "Trajors", "trajectables", "trajories"], "databasesIncluded": ["daturesInlisted", "daturesIncluded", "databasesedInified", "databasesInclusions", "datadesInsjected", "datadesIncluded", "datadesInsclusion", "datadesInified", "databasesInsified", "databasesInified", "databasesINjected", "databasesInclusion", "daturesInslisted", "datadesInscluded", "databasesInglisted", "databasesINclusion", "daturesInscluded", "databasesINcluded", "databasesedIncluded", "databasesedInjected", "databasesInscluded", "databasesIngclusions", "datadesInclusion", "databasesedInclusions", "daturesInclusions", "databasesInlisted", "databasesInsclusion", "databasesINified", "databasesInsclusions", "datadesInjected", "databasesedInclusion", "databasesInslisted", "daturesInsclusions", "databasesInjected", "databasesIngcluded", "databasesInsjected", "databasesedInlisted", "datadesInsified"], "onlyLinks": ["Onlylinks", "onlylinks", "forceLinks", "alsoRelations", "onlyLink", "alsoLink", " onlyLink", "forceLink", "OnlyLinks", "OnlyRelations", " onlylinks", "onlyRelations", " onlyRelations", "OnlyLink", "forcelinks", "alsoLinks"], "index": ["Index", "max", "inc", "length", "ind", "pos", "loc", "add", " Index", "update", "nn", "x", "zero", "no", "check", "open", "end", "address", "n", "position", "amount", "all", "match", "find", "first", "info", "number", "num", "sequence", "ex", "offset", "initial", "second", "ion", "fail", "i", " sidx", "connect", "set"], "name": ["create", "named", "default", "Name", "run", "data", "base", "id", "full", "ame", "image", "prefix", "string", "none", "path", "primary", "title", "n", "me", "root", "NAME", "names", "man", "local", "about", "m", "nm", "table", "parent", "word", "filename", "system"], "format": ["parse", "scale", "unit", "v", "default", "printf", "cal", "data", "base", "mt", "Format", "print", "percent", "prefix", "language", "MAT", " Format", "pattern", "fm", "util", "term", "get", "layout", "pretty", "use", "init", "list", "value", "set", "it", "style", "color", "table", "form"], "count": ["c", "order", "length", "total", "add", "mark", "flag", "err", "counter", "found", "start", "amount", "depth", "set", "num", "size", "sum", "process", "reset", "Count", "z", "code", "ount", "table", "error", "skip"], "version": ["vers", "mint", "v", "build", "translation", "ver", "VER", "connection", "release", "tree", "server", "python", "document", "result", "versions", "virtual", "section", "video", "major", "database", "java", "draft", "Version", "root", "journal", "description", "json", "number", "alone", "record", "j", "latest", "VERSION", "about", "information", "parent", "xml", "current", "page", "header", "summary"], "writer": ["written", "reader", "buffer", "write", "stream", "data", "connection", "order", "server", "comment", "external", "author", "document", "inner", "print", "language", "flush", "console", "creator", "client", "driver", "operator", "browser", "writing", "counter", "er", "iterator", "variable", "builder", "maker", "journal", "caster", "writ", "wrapper", "woman", "description", "Writer", "sw", "wright", "service", "w", "output", "writers", "report", "walker", "entry", "handler", "to", "function", "wrote", "window", "access", "outer", "editor"], "xmlDir": ["mlFolder", " xmldir", "logFolder", "imageDirectory", "imageFolder", "xmlFile", "logFile", "mlDirectory", "mlDir", "imageDir", "logDir", "imagedir", "logdir", " xmlFile", "xmlDirectory", "mlFile", "xmlFolder", "xmldir", " xmlFolder", " xmlDirectory", "logDirectory"], "databases": ["mutabases", " datases", "basables", "basabases", "datates", " datates", "datelines", "basures", "Datures", "generabases", "datases", " datasha", "Datases", " datables", "Datasha", "generates", "datasha", "generas", "Datas", "datas", "mutasha", "notabases", "database", " datas", "mutables", " database", "datables", "datures", "generabase", "notures", "mutases", "Databases", "Datates", "notelines", "Database", "Datelines", "Datables", "notables", "baselines"], "t": ["T", "c", "ct", "y", "v", "te", "k", "str", "id", "tt", "mt", "temp", "pt", "e", "tc", "q", "ot", "x", "tr", "tm", "term", "n", "typ", "p", "o", "template", "w", "it", "j", "h", "i", "ts", "s", "txt"], "type": ["parse", "object", "y", "unit", "kind", "instance", "Type", "top", "te", "ime", "ver", "TYPE", "base", "id", "this", "test", "relation", "ty", "error", "language", "result", "action", "other", "shape", "single", "time", "check", "rule", "title", "address", "typ", "root", "p", "pe", "match", "ype", "info", "template", "module", "tag", "ping", "site", "link", "role", "null", "tool", "to", "config", "resource", "style", "key", "class"], "currentName": ["currentlyPath", "reportedName", "reportedDir", " currentParent", "completeSet", "basePort", "currentlyKey", "currentlyName", " currentOrder", "updateFace", " currentNames", "currentKey", "thisYear", "reportedTime", "reportedNames", "CurrentNames", "currentPath", "CurrentPath", "currentPort", "baseFace", "thisName", "currentlyYear", "reportedParent", "completeKey", "reportedPath", "CurrentLock", "currentOrder", "currentYear", "reportedLock", "CurrentDir", "completeName", "thisKey", "baseName", "currentLock", "updatePort", "baseOrder", "updateName", "currentSet", "currentParent", "currentDir", " currentDir", " currentPort", "currentFace", " currentFace", "completeYear", "currentlyTime", "currentTime", "CurrentParent", "CurrentTime", "currentlySet", "currentNames", "currentlyLock", "updateOrder", "thisSet", "CurrentName"], "baseCopy": ["basecopy", "basiccopy", "bufferCopy", "BaseStore", "baseStore", "BaseName", "parentName", "basicCopy", " basecopy", "bufferCop", "baseName", "baseCop", "basicStore", "BaseCop", "Basecopy", "basicCop", "parentCop", " baseCop", "buffercopy", "parentcopy", " baseName", "BaseCopy", "parentCopy", " baseStore"], "source": ["scan", "ources", "create", "reader", "se", "src", "stream", "data", "scope", "base", "connection", "space", "select", "join", "original", "inner", "before", "console", "origin", "SOURCE", "input", "ource", "start", "Source", "init", "target", "service", "search", "channel", "site", "size", "sample", "sequence", "local", "from", "subject", "initial", "master", "store", "shell", "resource", "parent", "owner", "system", "iterator"], "destination": ["datination", "messinated", "destinated", " destuation", "declination", "declinations", "messuation", "messructure", "destregation", "destinator", "Destinated", "datregation", "Destructure", "declinator", "Destinator", "destructure", "destinations", "datinations", "Destinations", "destuation", "datinator", "declregation", "messination", "Destination", " destinated", " destinations", " destructure", "Destuation", "Destregation", "messinations"], "clefs": ["CLEfs", " CleFs", "CLEfits", "Clefits", "clecs", " Clecs", "clefits", "Clebs", " Clebs", " clebs", "cleFS", "CleFS", "Clecs", "clebs", "Clefs", " cleFs", " CleFS", "cleFs", "CleFs", " Clefs", " cleFS", " Clefits", "CLEFs", "CLEcs"], "st": ["sb", "est", "fr", "ct", "cl", "sc", "se", "sn", "sm", "str", "mt", "tt", "rest", "bt", "statement", "pt", "dd", "ts", "ist", "storage", "sth", "St", "sy", "sl", "bl", "irst", "ste", "start", "stra", "sw", "query", "ost", "sts", "it", "std", "stat", " ST", "cr", "h", "sp", "inst", "ST"], "rs": ["Rs", "ps", "rd", "mr", "os", " sr", "ers", "cs", "ks", " pts", "as", "ds", "ls", "res", "rc", "RS", " ps", " iss", "ris", "rt", "sts", " ins", " cs", " ms", "ins", "rys", "ts", " RS"]}}
{"id1": "8216539", "id2": "19687456", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasString", "getFileContentasStr", "getFileContentAsText", "getFileTextAsText", "getFileContentAsStr", "getFileTextAsString", "getFileTextAsStr", "getFileContentasText"], "filePath": ["baseString", "basePath", "FileString", " fileName", " fileInfo", "fileDef", "entryName", "ileDef", "FILEPath", "FILEpath", "FilePath", "FileName", "ilePath", "FileDef", "ileInfo", "FILEName", "fileName", "filepath", "baseName", "FILEPATH", " filepath", "ileName", "entrypath", " fileString", "FileInfo", "FilePATH", "fileInfo", "entryPath", "filePATH", " fileDef", "Filepath", "basepath", "fileString", "entryPATH"], "encoding": ["enoding", "enaching", "unicode", "encuing", "ENCaching", "enode", "unicuing", "characteraching", "Encging", "encode", "enuing", "Encordering", "Encuing", "Encode", "Encoding", "unicaching", "encging", "Encaching", "characterging", "characterordering", "encordering", "unicoding", "characteroding", "encaching", "ENCging", "ENCoding", "ENCordering"], "testURL": ["testingUR", " testUR", "TestSR", " testRE", "checkURL", "testRE", "TestUR", "testUrl", " testUrl", "testedUrl", "checkUrl", "TestURL", "testedRE", "testingUrl", "testUR", "checkSR", "testedUR", "testingSR", "testingRE", "checkUR", "testedURL", "TestUrl", " testSR", "testSR", "testingURL"], "input": ["tmp", "data", "quick", "batch", "has", "iter", "focus", "address", "exist", "up", "Input", "PUT", "init", "list", "output", "act", "config", "xml", "pull", "read", "in", "file", "inner", "add", "lat", "q", "client", "missing", "hidden", "audio", "open", "eval", "get", "qa", "context", "can", "quit", "stream", "comment", "upload", "raw", "image", "op", "exec", "start", "url", "json", "channel", "cur", "it", "sample", "cont", "source", "ip", "submit", "reader", "view", "acl", "active", "accept", "command", "feed", "hello", "unsigned", "from", "empty", "current", "form", "iterator"], "sw": ["wra", "sb", "igm", "kw", "SW", "enc", "sc", "sn", "wh", "sm", "sk", "wl", "sv", "hw", "was", "wr", "su", "sa", "ows", "tw", "ow", "wo", "fw", "aw", "sem", "rew", "sl", "ws", "sur", "iw", "nw", "ews", "wn", "wa", "ew", "Sw", "w", "we", " Sw", "sh", "sf", "sp"]}}
{"id1": "8000624", "id2": "88047", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyInt", " copyFrom", " copiesInt", " copyTo", "CopyFrom", " copiesFrom", " copiesTo", " CopyFrom", "CopyInt", " CopyInt"], "dest": ["img", "est", "tmp", "th", "Dest", "v", "copy", "src", "pipe", "usr", "nom", "rest", "loc", "them", "image", "temp", "result", "dir", "origin", "path", "opt", "name", "orig", "mem", "p", "d", "target", "w", "it", "cat", "output", "st", "null", "sp", "cont", "fn", "source", "filename", "txt"], "in": ["t", "reader", "bin", "ire", "din", "min", "read", " din", "ac", "re", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "image", "l", "inf", "ain", "inside", "iter", "source", "r", "client", "is", "input", "nin", "al", "up", "login", "In", "on", "thin", "gin", "per", "init", "win", "o", "IN", "ini", "net", "con", "one", "local", " input", "it", "internal", "from", "ir", "ar", "ins", "inn", "m", "cin", "ai", "i", "sin", "by"], "out": ["t", "io", "v", "dis", "write", "can", "boot", "oe", "ne", "by", "os", "user", "full", "en", "batch", "inner", "b", "ln", "e", "at", "flush", "na", "ot", "gt", "oss", "client", "res", "end", "obj", "nt", "up", "op", "conv", "n", "note", "co", "all", "list", "o", "net", "con", "one", "cn", "w", "outs", "it", "output", "Out", "ex", "null", "ns", "to", "cos", "not", "writer", "ou", "fn", "aos", "loss", "OUT", "outer", "other"], "c": ["t", "ct", "count", "cl", "v", "cd", "ac", "k", "sc", "uc", "ca", "u", "ce", "arc", "l", "cs", "bc", "e", "cp", "cod", "cc", "cb", "gc", "rc", "ec", "n", "unc", "cut", "f", "d", "character", "conf", "con", "ch", "cm", "cap", "cat", "char", "z", "code", "cr", "C", "i", "cont", "nc", "current", "cf", "g", "lc"]}}
{"id1": "804637", "id2": "19687456", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "21754659", "id2": "8490297", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getButtonSonico", "getButtonDonida", "getButtonSonida", "getButtonDonido", "getbuttonSonida", "getbuttonSonico", "getbuttonSonilo", "getButtonLeonido", "getbuttonSonido", "getButtonDonico", "getButtonLeonico", "getButtonLeonida", "getButtonDonilo", "getButtonLeonilo", "getButtonSonilo"], "buttonSonido": ["positionSonido", "labelSONphp", "fieldsoningo", "buttonSonano", "buttonHonilo", "buttonSunao", "ButtonSonao", "buttonSONilo", "ButtonSunico", "buttonSonicho", "buttonNorthingo", "buttonsonilo", "buttonSunata", "labelSONido", "buttonJonphp", "buttonDenicho", "buttonSynido", "buttonSunido", "ButtonSunao", "buttonBoningo", "keySonardo", "secondSonicho", "buttonJonida", "fieldSonida", "secondSynido", "buttonNorthano", "labelSonido", "buttonSonao", "keysonilo", "buttonJonidable", "buttonSonata", "secondSynidable", "buttonJonito", "buttonSynicho", "buttonSynphp", "keyson\u00ed", "fieldsonano", "buttonJonao", "fieldSoningo", "ButtonSonico", "buttonSonito", "positionSonito", "buttonJonilo", "buttonsonardo", "buttonBonida", "buttonSunilo", "buttonSonardo", "keySonido", "positionJonico", "buttonsonano", "buttonSONico", "buttonsoningo", "buttonHonardo", "fieldSonido", "buttonBonata", "labelSonida", "buttonBon\u00ed", "buttonDenidable", "buttonBonilo", "ButtonSonata", "labelSONida", "buttonSONida", "buttonSynidable", "buttonSONila", "buttonHon\u00ed", "fieldSonano", "buttonNorthida", "buttonJonicho", "buttonNorthido", "keysonido", "buttonSunito", "buttonsonido", "buttonBonao", "buttonJonico", "secondSynito", "buttonJonido", "buttonSONphp", "buttonsonida", "buttonDenito", "labelSonila", "buttonSonidable", "fieldsonido", "buttonSonilo", "buttonJonata", "ButtonSunata", "keySon\u00ed", "positionJonito", "buttonSonida", "buttonBonido", "buttonSoningo", "buttonSynito", "secondSynicho", "buttonSunico", "buttonSonphp", "labelSonphp", "positionJonilo", "ButtonSunido", "buttonBonano", "keysonardo", "secondSonido", "positionSonico", "buttonSONido", "positionJonido", "buttonBonardo", "buttonJonila", "positionSonilo", "buttonSynida", "labelSONila", "secondSonidable", "buttonDenido", "fieldsonida", "buttonSon\u00ed", "buttonBonico", "buttonHonido", "secondSonito", "buttonSONito", "buttonSonico", "buttonSynila", "keySonilo", "buttonSonila", "ButtonSonido", "buttonson\u00ed"], "e": ["t", "ese", "ae", " ie", "ev", "te", "es", " ate", "AE", " ke", " pe", "ie", "ED", " ge", " ve", "a", "er", "ing", "me", "pe", " fe", "event", "E", "ee", "act", " sent", " who", "ed"], "fc": ["c", "tf", "cv", "FC", "rl", "abc", "WC", "etc", "uc", "bf", "fb", "inc", "fa", "isc", "dc", "bc", "fab", "tc", "mc", "cc", "ic", "icc", "lf", "fm", "gc", "mac", "rc", "conv", "ec", "RFC", "irc", "coll", "soc", "f", "fd", "fs", "fp", "con", "vc", "pc", "fl", "anc", "ifa", "fi", "ctrl", "nc", "fn", "cf", "lc"], "returnVal": ["retValue", "retval", "ReturnVal", " returnValue", "ReturnVAL", "resultVAL", "retVal", "ReturnValue", "Returnval", "resultValue", "resultval", "resultVal", "returnValue", " returnval", " returnVAL", "returnVAL", "returnval", "retVAL"], "file": ["io", "create", "buffer", "type", "fe", "data", "tree", "base", "user", "this", "FILE", "full", "File", "disk", "document", "image", "dir", "uri", "ile", "single", "input", "path", "time", "spec", "name", "format", "handle", "url", "get", "f", "http", "info", "channel", "template", "fp", "local", "link", "block", "output", "message", "valid", "files", "null", "stat", "show", "to", "table", "resource", "page", "parent", "word", "source", "form"], "rutaGlobal": ["RutoLocal", "rutanGlobal", "rutaglobal", "redutaGeneral", "RutoGlobal", "rutoStatic", "redutaLocal", "RutaGlobal", "RutoRemote", "redutaDefault", "rutenGlobal", "Rutaglobal", "RutaLocal", "rutiDefault", "rutaStatic", "rutiFile", "rontoLocal", "rutoLocal", "rutoRemote", "rutoglobal", "rutiRemote", "rutiStatic", "rutoGlobal", "rutenRemote", "rutaRemote", "rutenStatic", "redutanDefault", "RutaRemote", "rutiglobal", "rutanLocal", "rutaGeneral", "rutoFile", "RutoFile", "redutaGlobal", "rutenglobal", "redutanGeneral", "rontoGlobal", "rutiGlobal", "rontoDefault", "rutanDefault", "rutenLocal", "RutoStatic", "rutiGeneral", "rutanGeneral", "redutanLocal", "rontoGeneral", "rutaLocal", "redutanGlobal", "RutaFile", "rutenFile", "rutaFile", "rutaDefault", "rutiLocal", "Rutoglobal", "RutaStatic"], "rutaRelativa": ["rutaRELativa", "rutaRELATiva", "rutaRelantiv", "rutaRelATivo", "rutaRELATiv", "rutaRelativ", "rutaRELitiva", "rutaRelantiva", "rutaRELitivo", "rutaRelitiv", "rutaRelatiiva", "rutaRelatiivo", "rutaRelativo", "rutaRELATivas", "rutaRelATiv", "rutaRelantivo", "rutaRelatiiv", "rutaRELATivo", "rutaRELitivas", "rutaRelantivas", "rutaRelitivas", "rutaRelATiva", "rutaRELitiv", "rutaRelitivo", "rutaRELativo", "rutaRelativas", "rutaRelATivas", "rutaRELativ", "rutaRelitiva", "rutaRelatiivas", "rutaRELativas"], "fis": ["flis", "dfois", "vois", "dfis", "dfiss", "fiss", " fais", "ros", "df\u00eds", "dfisa", "viss", "dfais", "lfisa", " fois", " fiss", "fois", "lfiss", "flys", "fais", "flisc", "f\u00eds", " fisa", "ris", "flos", "fisa", "fys", "lf\u00eds", " fisc", "vis", " fys", "rys", " f\u00eds", "vais", "risc", "fisc", "lfis"], "fos": ["ioses", "woes", "foes", "mos", "mops", "wios", "fows", "fops", "woses", "fios", "iios", "hos", "fdoss", "woss", " foss", "fdaos", "foss", "hios", "vos", "faos", "vows", " fops", "vops", "fdos", "foses", "moes", "mows", "fdoes", "hoss", "waos", "ios", " faos", " fows", "ioss", "voes", " foes", "hoses", "wos"], "canalFuente": ["canallfucer", "canalFuestro", "canallFuper", "canalfuelia", "canallFuente", "canalFUent", "canelFaelia", "canelFuante", "canalfumelon", "canalFaent", "canalFaante", "canalFaestro", "canalPotper", "canallFuent", "canalFuencia", "canalfuestro", "canelFaent", "canallFuencia", "canalFient", "canalFaelia", "canelFuent", "canallFuestro", "canallfumelon", "canalFraencia", "canallfuestro", "canalFramelon", "canalFUelia", "canelFaente", "canalFucer", "canalfuente", "canelFuelia", "canalFuante", "canallfuent", "canalFiente", "canalFaente", "canalFuper", "canalPotmelon", "canallfuper", "canelFuente", "canalFuelia", "canalFacer", "canalPotente", "canallFucer", "canallfuente", "canalFUente", "canallFumelon", "canalfuencia", "canelFaante", "canalfucer", "canalfuper", "canalfuante", "canalFiestro", "canalFUante", "canalFicer", "canallfuencia", "canalFraper", "canalFuent", "canalfuent", "canalFraente", "canalFumelon", "canalPotencia"], "canalDestino": ["canaldOrigine", "canalNegina", "canalsDestina", "canaldDestina", "canaldOrigination", "canalsDestinian", "canalDescina", "canalDescination", "canalOrigination", "canalNegination", "canalDestine", "canaldestinian", "canalOrigine", "canalNegino", "canalDescine", "canalsdestina", "canalDestinian", "canalsdestination", "canalsDestination", "canaldestination", "canalsdestino", "canalsDestino", "canalDestination", "canaldDestino", "canalOrigino", "canaldestina", "canalOrigina", "canalDescino", "canaldDestination", "canaldOrigina", "canalsdestinian", "canalDestina", "canaldestino", "canalNeginian", "canaldOrigino", "canaldDestine"]}}
{"id1": "8667872", "id2": "310182", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"hash": [" Hash", " text", " sum", "id", "Hash", "print", " body", "dump", "hex", " key", "string", "update", " hashing", "sign", " id", " equals", " message", " identity", " h", " fingerprint", " address", "sum", " code", "code", "h", " signature", " mac"], "data": ["content", "text", "any", "buffer", "secret", "serial", "padding", "DATA", "html", "space", "ata", "this", "raw", "batch", "image", "result", "action", "string", "input", "name", "dat", "format", "foo", "json", "hello", "value", "info", "size", "sample", "sequence", "message", "output", "area", "bytes", "mu", "what"], "digest": ["hashge", "deEST", "digse", "deest", " digEST", "modist", "mdest", "Digit", " digester", "hashest", "modest", " digse", "Digge", "cdment", "mdse", "Digment", "digester", "hashit", "cdse", "mdester", " digge", " digested", "mdge", "cdested", "hashEST", "cdest", "digge", "digEST", "mdist", "digested", "DigEST", "equge", "equit", "Digist", "mdEST", "modge", "equEST", "equest", "dese", "modester", " digment", " digist", "Digest", "digist", "Digester", "digment", "digit", "Digested", "deist", "Digse"]}}
{"id1": "20019847", "id2": "755203", "code1": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", "copyFiles", "copyfile", "CopyStream", " cpStream", " cpfile", " CopyStream", " Copyfile", "CopyFiles", "CopyFile", "copyStream", " CopyFiles", "Copyfile", " cpFile", " cpFiles"], "source": ["details", "copy", "se", "src", "scene", "view", "scope", "base", "space", "archive", "ce", "file", "series", "string", "origin", "SOURCE", "input", "ource", "check", "ace", "spec", "name", "format", "start", "Source", "init", "search", "service", "template", "query", "site", "size", "sample", "sequence", "it", "sql", "from", "subject", "style", "config", "store", "parent", "resource", "seed", "filename"], "target": ["t", "replace", "top", "copy", "arget", "base", "stop", "dest", "test", "file", "print", "join", "next", "result", "gt", "pattern", "mac", "check", "alias", "tif", "goal", "project", "get", "delete", "match", "touch", "arg", "template", "it", "link", "output", "that", "to", "table", "parent", "resource", "bolt", "Target"], "in": ["bin", "din", " din", "sin", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "im", "inside", "iter", "client", "is", "input", "al", "up", "In", "gin", "init", "info", "IN", "con", "internal", "it", "from", "ar", "ins", "inn", "cin", "ai", "i", "ic"], "out": ["c", "t", "io", "v", "can", "OUT", "or", "conn", "ne", "user", "auto", "en", "l", "b", "result", "at", "gt", "sys", "cmd", "client", "ot", "nt", "up", "n", "on", "co", "channel", "o", "net", "con", "cn", "it", "outs", "ch", "Out", "output", "ex", "to", "g", "msg", "i", "ou", "aos", "by", "and"]}}
{"id1": "411595", "id2": "23335922", "code1": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"displayDiffResults": ["displayDiffresults", "displaydiffStats", " displaydiffStats", " displayDiffResult", " displayChangeStats", "displayDiffResult", "displaydiffResult", "displayDiffStats", "displaydiffResults", " displayChangeresults", " displaydiffresults", " displayChangeResult", "displaydiffresults", " displayChangeResults", " displayDiffStats", " displaydiffResult", " displayDiffresults", " displaydiffResults"], "outFile": ["outputDir", "targetPath", "outDisk", "outputStream", "outFILE", "OUTSet", " outSet", "nfile", "outPath", "nFile", "OUTfile", "outDir", "outputPath", " outDisk", " outfile", "outputSet", "targetFILE", "nDir", "outputfile", "OUTFile", "outputFILE", "nDisk", "outfile", "OUTPath", "outputFile", "outSet", "targetStream", " outDir", " outFILE", "outputDisk", "targetFile", " outPath"], "outStream": ["outView", "reportFile", "outputStream", "outputStreamer", "outstream", "outputstream", " outstream", " outStreamer", "outSteam", "outputSteam", "writeStream", "outputView", "writeStreamer", "outStreamer", "reportSteam", " outSteam", "outputFile", "writeView", "writeSteam", "reportStream", " outView", "reportstream"], "out": ["t", "v", "batch", "cmd", "hit", "err", "up", "conv", "on", "init", "timeout", "list", "conf", "con", "Out", "output", "g", "writer", "io", "in", "conn", "auto", "external", "file", "inner", "l", "sys", "client", "oss", "cache", "o", "net", "entry", "ou", "error", "aos", "by", "write", "can", "copy", "os", "over", "user", "raw", "at", "ent", "update", "check", "nt", "screen", "op", "pretty", "it", "to", "table", "page", "OUT", "log", "go", "print", "b", "flush", "console", "put", "obj", "format", "n", "co", "all", "one", "outs", "w", "ch", "sum", "ex", "again", "empty"], "bgcolor": ["bgcol", "backgroundcol", " backgroundcolor", "fontcolor", "bgColor", " backgroundname", "backgroundColor", " backgroundColor", "fontColor", "fontcol", "backgroundname", "fontname", "bgname", " backgroundcol", "backgroundcolor"], "onMouseOver": [" onmouseDown", " onmouseover", "onMouseover", "onmouseOut", " onmouseOut", " onmouseOver", "onmouseOver", "onMouseOut", "onMouseDown", "onmouseDown", " onMouseover", " onMouseOut", "onmouseover", " onMouseDown"]}}
{"id1": "4618237", "id2": "21395184", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFile2Stream", "writeFiles2File", "writeFileAndFiles", "writeFileAndDisk", "writeFiles2Stream", "writeFileAsFiles", "writeFile2File", "writeFileAsStream", "writeFileToFiles", "writeFileAsFile", "writeFilesToFile", "writeFiles2Files", "writeFiles2Disk", "writeFileToDisk", "writeFileAsDisk", "writeFileAndFile", "writeFileAndStream", "writeFilesToDisk", "writeFilesToFiles", "writeFile2Disk", "writeFile2Files", "writeFilesToStream", "writeFileToStream"], "fin": ["fr", "mid", "raf", "details", "FIN", "rf", "lin", "din", "Fin", "inv", "in", "mil", "fil", "rin", "fa", "en", "ln", "fur", "lo", "normal", "han", "focus", "lf", "fw", "irm", "n", "ran", "fd", "f", "init", "jen", "ini", "mn", "fp", "fre", "fc", "fl", "syn", "fi", "ic", "fn", "kin"], "fout": ["fbout", "ffou", "Fin", " fpo", "ffOut", "ffin", "Fout", "foutput", "fbpo", "FOut", "kout", "kpo", "fOut", " fOut", "fboutput", "fpo", "fou", "tou", "fbOut", " foutput", "tout", "kOut", "tin", "Fou", "ffout", "tOut", "koutput"], "append": ["app", "animate", "replace", "printf", "flat", "buff", "ext", "ind", "insert", "csv", "batch", "join", "ended", "add", "express", "string", "update", "allow", "pend", "vert", "equal", "end", "command", "note", "bold", "absolute", "send", "folder", "ends", "force", "apply", "fail", "seed", "include", "grow", "push"], "inChannel": ["sinButton", "intClient", "pinCategory", "inMachine", "pinMachine", "inButton", "inChan", "innMachine", "iCommand", "inputChannel", "innButton", "innChannel", "InChannel", "rinListener", "InStream", "rinChan", "outchannel", " inchannel", "sinMachine", " inChan", "outStream", "insideSession", "sinChannel", "inchannel", "inStream", "InConnection", "inClient", "iChan", " inCommand", " inConnection", "inputCategory", "insideClient", "pinChannel", "rinChannel", "insideChan", "inSession", "innCategory", "inListener", " inCategory", "rinCategory", "inputChan", "iChannel", "intSession", "outCommand", "inCommand", "inConnection", " inSession", "iStream", " inStream", "sinCategory", "outChan", " inClient", "insideChannel", "Inchannel", "inCategory", "intChannel", "intChan", "inputListener", " inListener", "outConnection", "pinButton"], "outChannel": ["netController", "inChan", "outputCh", "outputchannel", "netCh", "outScope", "outchannel", " outScope", "OUTChannel", "netchannel", "outputScope", "nameScope", "outConnection", "netChannel", "userMember", "nameChannel", "OUTChan", "invMember", "inchannel", "invChannel", " outController", "outMember", " outChan", "OUTController", "outputChan", "outController", "outCh", "outputConnection", "outputChannel", "nameChan", "inCh", "invCh", "OUTchannel", "outChan", " outchannel", "netChan", "userCh", "nameConnection", " outConnection", " outCh", "userChannel", "netMember"]}}
{"id1": "22536033", "id2": "4118412", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["SetPayment", "setMessageload", "setHeadLoad", "setpayload", "setPayment", "setPayLoad", "setMessagement", "getPayline", "Setpayload", "getPayload", "Setpayment", "setShipment", "setHeadline", "setpayloads", "SetPayments", "setPayloads", "setpayLoad", "setpayment", "Setpayments", "SetPayload", "setShipLoad", "getPayLoad", "SetPayLoad", "getPayloads", "SetpayLoad", "setPayline", "setMessagements", "setShipments", "setPayments", "setMessageLoad", "setpayline", "setHeadloads", "setpayments", "setHeadload", "setShipload"], "fos": ["fooss", "haos", "sfis", "hos", "woss", " foss", "fois", "foss", "sfoss", "faos", "sfos", "foic", "wis", "his", "hoss", "waos", "foos", "sfic", " faos", "wos"], "fis": ["xfis", "xfsis", "fiss", "Fic", "xfics", "sfis", "xfic", " fiss", "Fos", "sfos", "flics", "fsis", " fics", "sfiss", "Fiss", "flic", " fsis", "flsis", "sfic", "fics", "Fis", "flis"], "fic": ["sfric", "ficc", "affics", "fci", "Foc", "bfic", " ftic", " fci", "Fic", "sfico", "cficc", "ufico", " ficc", "uficc", "ftic", "fico", "cfoc", "sfics", "bfci", " fico", "Ftic", "ufic", "affic", "afftic", "bfico", "ufci", "ufics", "cfics", "bfics", " fics", "ufoc", "sfic", "fics", "ufric", "fric", "affoc", " fric", "cfic", "Fics"], "foc": ["Fot", "sfoc", "flot", " fot", "cfoco", "Foc", "floco", "Fic", "fot", "fac", "floc", "cfot", "sfoca", "Froc", "cfoc", " froc", "froc", "flac", "flic", "foco", " foca", "sfic", "foca", " fac", "cfic", " foco", "flroc", "floca", "sfac"], "Index": ["Unique", "Label", "Time", "Now", "Length", "Max", "Name", "Series", "Port", "I", "Foot", "Ind", "Mass", "Update", "Found", "Counter", "Offset", "Instance", "Fix", "Loc", "Key", "Exp", "Weight", "Info", "Prime", "Socket", "Next", "Value", "index", "Left", "Column", "Current", "Handle", "Section", "Location", "In", "Version", "Thread", "Se", "Position", "Zero", "Request", "Limit", "Num", "Connection", "Other", "Lock", "Delta", "Out", "Present", "State", "Link", "Count", "Loop", "Row", "Insert", "Size", "Is", "Rank", "Pos", "Id", "Iter"]}}
{"id1": "13122204", "id2": "11334468", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"unzipModel": ["unarchiveModel", "UnzipModel", "Unarchivemodel", "UnarchiveModel", "UnarchiveImage", "unzipmodel", "UnzipModule", "unzipModule", "unlateImage", "UnzipImage", "unarchiveModule", "uncodeModel", "unarchiveImage", "unlatemodel", "unlateModel", "uncodeImage", "unlateModule", "unzipImage", "uncodemodel", "UnarchiveModule", "unarchivemodel", "Unzipmodel", "uncodeModule"], "filename": ["fle", "println", "river", "jpg", "location", "mson", "nl", "fil", "FILE", "wl", "file", "FIL", "download", "username", "original", "nil", "ln", "dra", "source", "origin", "path", "FN", "title", "name", "stem", "n", "journal", "SourceFile", "til", "directory", "fp", "kl", "Filename", "sql", "output", "subject", "nm", "ivo", "ename", "fn", "txt"], "tempdir": ["testdir", "temppath", " tempDIR", "tempDIR", "temfolder", "temDir", "temDIR", "Tempdirectory", "tmpfolder", " tempdirectory", "temdir", "tmpdirectory", "tmppath", "tmpfile", "Tempdir", "tempath", "Tempfile", "tmpDIR", " tempfile", "temdirectory", "tempdirectory", " tempDir", "tempDir", "tempfolder", "testDir", "testpath", "tmpDir", "TempDir", "testfolder", "tempfile", "tmpdir"], "dest": ["generated", "est", "peer", "tmp", "coord", "ctr", "Dest", "trans", "buffer", "deep", "bin", "write", "default", "inv", "src", "dev", "tail", "pipe", "des", "stream", "usr", "nom", "rest", "pos", "test", "loc", "document", "dc", "foreign", "temp", "result", "origin", "del", "out", "tr", "obj", "nt", "dat", "ptr", "comb", "send", "target", "dist", "slave", "desc", "output", "st", "sum", "display", "null", "master", "store", "table", "port", "decl", "parent", "writer", "cont", "source"], "fis": ["li", "zos", "zjs", "ifos", "ifatis", "lis", "fjs", "zatis", "fli", "ljs", "flos", "los", "fatis", "ifis", "fljs", "fi", "ifi", "zi", "flis", "flatis"], "BUFFER": ["MAXBuffer", "FFERBER", "BABER", "CUBuffer", "BufferBER", "LOCKBER", "BufferMT", " BUBuffer", "BUMT", "BUBER", " BUOUNT", "BLOUNT", "FFERMT", " BUFR", "FFERFFER", "CUBER", " BUULT", " BUBER", "MAXOUNT", "BufferBuffer", "CUFFER", "LOCKBuffer", "CUFR", "BUULT", "FFERBuffer", "BULT", "BOUNT", "LOCKFR", "BLBER", "BAULT", "MAXBER", " BUMT", "BAFFER", "MAXFFER", "BufferFFER", "BFFER", "LOCKFFER", "BUFR", "BBER", "BAOUNT", "BUBuffer", "BLBuffer", "BUOUNT", "BLFFER"], "zis": ["zeis", "zeiss", " zIS", "zies", "xiss", "fiss", "ozip", " zris", " zi", "Ziss", "xi", "ozi", "zos", "oziss", "zios", "zip", "ozis", " zits", "ziss", "zeits", "zeris", "Zi", " zos", "zoneiss", "zeos", "Zis", "zoneis", "zeIS", " zip", "xos", "zees", "Zos", " ziss", "zoneits", "zIS", " zes", "zoneris", "xis", "fip", "ziis", "fi", "zits", "zi", "zes", "ziIS", "zris"], "entry": ["jar", "ry", "or", "se", "member", "part", "connection", "comment", "log", "ce", "inter", "file", "existent", "card", "image", "ze", "e", "je", "result", "cell", "ent", "piece", "ie", "way", "item", "index", "enter", "nt", "chain", "name", "Entry", "escape", "header", "pe", "element", "match", "row", "record", "link", "def", "char", "jo", "zo", "table", "zip", "word", "source", "key", "system"], "count": ["c", "ctr", "ct", "read", "buffer", "max", "OUNT", "acc", "part", "base", "core", "length", "comment", "total", "ce", "batch", "add", "common", "cell", "cc", "child", "index", "cache", "check", "cond", "counter", "nt", "found", "n", "start", "amount", "f", "len", "all", "match", "number", "nb", "force", "num", "size", "sum", "Count", "z", "call", "code", "ount", "cont", "current", "page", "cloud"], "data": ["content", "text", "dl", "mat", "results", "buffer", "DATA", "part", "str", "ata", "raw", "batch", "image", "next", "result", " DATA", "out", "dec", "zero", "cache", "step", "dat", "format", "n", "accept", "p", "d", "all", "value", "size", "sample", "rel", "message", "area", "ATA", "bytes", "output", "done", "valid", "table", "window"], "fos": ["Fios", "foes", "lOS", "Foss", "FOS", "Foses", "fios", " foses", " fOS", " foss", "lios", "voses", "foss", "Foes", "vos", "Fos", "voss", " fios", "foses", "fOS", "los", "voes", " foes", "loss"]}}
{"id1": "18891988", "id2": "17729554", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"getFile": ["selectfile", "GetFile", "getString", "createfile", "Getfile", "selectString", "getfile", "createFile", "getFilename", "selectFilename", "GetString", "GetFilename", "createFilename", "selectFile", "createString"], "serviceName": ["libraryFamily", "serviceNames", "serverName", "ServiceNames", "serviceCode", " serviceNames", "serverType", "serviceType", "ServiceName", "serviceFamily", "serverCode", " serviceType", "libraryName", "ServiceCode", " serviceCode", "ServiceType", "libraryNames", "ServiceFamily", "libraryType", " serviceFamily"], "wsdlLocation": ["wslPath", "awsolLocation", "wsDLLoc", "wslLocation", "wsDLLocation", "wssdPath", "wsolLocation", "wsollocation", "wsDLFolder", "awsdLoc", "wlFolder", "wdlLocation", "wssdlocation", "awsdlLocation", "wsdllocation", "awsolLoc", "awsdlURL", "wsdlURL", "wsolLoc", "wsDLPath", "wsDLURL", "wsdlPath", "wdlLoc", "awsolURL", "wssdLocation", "wslLoc", "awsollocation", "wsdlocation", "wssdLoc", "wssdURL", "wslFolder", "wsdlFolder", "wsdLoc", "wlLocation", "awsdllocation", "wsdURL", "wssdFolder", "wdlPath", "wlLoc", "awsdLocation", "awsdlocation", "wsDLlocation", "awsdURL", "awsdlLoc", "wlPath", "wsdlLoc", "wsdLocation", "wsolURL", "wdlFolder"], "endpoint": ["idpoint", "startpoint", "startpoints", "startPoint", "beginpoints", " endport", "startword", "endpoints", "beginPoint", " endPoint", "Endpoint", "endline", "idPoint", "startline", "bindPoint", "beginpoint", "endword", " endpoints", "Endpoints", " endline", "bindport", "idline", "Endport", "bindpoint", "idpoints", "endPoint", "endport", "bindpoints", "EndPoint", "beginword", "Endword"], "fileLocation": ["filelocation", "FileLoc", "documentPosition", " filePosition", "FileLocation", "documentlocation", "fileLoc", "documentLocation", "documentLoc", " filelocation", "filePosition", " fileLoc", "Filelocation", "FilePosition"], "tempDir": ["tmpPath", " tempPath", "tmpFolder", "tempFolder", " tempUrl", "tempdir", "tmpDirectory", "TempDirectory", " tempFolder", "tempDirectory", "Tempdir", " tempDirectory", "TempPath", "TempFolder", "TempUrl", "tmpUrl", " tempdir", "tempPath", "tmpDir", "tempUrl", "TempDir", "tmpdir"], "url": ["dl", "li", "location", "build", "ul", "conn", "re", "nl", "mount", "str", "base", "loc", "l", "web", "gl", "uri", "il", "https", "cp", "r", "ssl", "browser", "cert", "ls", "open", "job", "mail", "sl", "up", "sur", "bel", "un", "ur", "f", "pl", "github", "http", "service", "ll", "link", "rel", "ret", "URL", "char", "m", "socket", "ctrl", "cr", "Url", "window"], "WSDLFile": ["WSDLFilename", "WSDLLFile", "WIDDLfile", "WSDLLString", "WNDLfile", "WSDELFile", "WSDELFilename", "WIDDLType", "WSDLSType", "WHDLfile", "WNDDLFile", "WSDMLfile", "WHDLFILE", "WSDLLFILE", "WIDLfile", "WSDLSFile", "WIDDLString", "WIDDLFile", "WHDDLFILE", "WSDDLType", "WIDLType", "WHDLFile", "WNDDLFILE", "WSDLSfile", "WSDLType", "WIDLFile", "WNDDLfile", "WSDLFILE", "WSDDLFile", "WNDDLFilename", "WSDLLfile", "WSDQLfile", "WSDMLFILE", "WSDDLFilename", "WSDDLfile", "WIDLString", "WSDLLType", "WHDDLFile", "WSDQLFile", "WSDQLFILE", "WSDLString", "WSDMLFile", "WSDELFILE", "WHDDLfile", "WNDLFILE", "WNDLFile", "WSDLSString", "WSDLLFilename", "WSDELfile", "WSDDLString", "WSDLfile", "WNDLFilename", "WSDDLFILE"], "tmpWSDLFile": ["tmpWSDLLFILE", "tmpWSDLDFile", "tmpWSDLFILE", "tmpWSDlfile", "tmpWSDDLFile", "tmpWSDLLFilename", "tmpWSDlFile", "tmpWIDDLFilename", "tmpWSDLFiles", "tmpWIDDLFILE", "tmpWNDLFile", "tmpWSDDLfile", "tmpWNDLFiles", "tmpWNDLfile", "tmpWSDDLFiles", "tmpWSDLDFilename", "tmpWSDLLFile", "tmpWNDLFilename", "tmpWSDlFilename", "tmpWSDLDFILE", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWNDDLFiles", "tmpWNDDLFile", "tmpWIDDLfile", "tmpWSDLfile", "tmpWNDDLFilename", "tmpWIDLfile", "tmpWSDDLFILE", "tmpWSDLLfile", "tmpWSDLLFiles", "tmpWSDDLFilename", "tmpWNDDLfile", "tmpWSDLFilename", "tmpWIDLFile", "tmpWIDLFilename", "tmpWIDLFILE", "tmpWSDlFiles"], "inputFile": ["InputFILE", "InputPath", "outputStream", "clientFile", "InputDo", "inputPlace", "inputFILE", "inputfile", "errorfile", "inputDo", "infile", "errorFILE", "tmpStream", "intFile", "InputFiles", "indexfile", "interfaceFile", "Inputfile", "inPath", " inputDo", "interfacePlace", " inputfile", " inputSourceFile", "tmpfile", "intFiles", "outputfile", "indexFile", "outputFILE", "errorFile", "inputStream", "inputPath", "inputSourceFile", "outputFile", "interfacefile", "intfile", "inDo", "intFILE", "tmpFILE", "clientFILE", "InputStream", " inputFiles", "InputFile", " inputFILE", "inputFiles", "clientPath", "inFile", "tmpPlace", "tmpSourceFile", "errorStream", "clientFiles", " inputPath", "interfaceSourceFile", "indexFILE", "indexStream", " inputPlace"], "tmpFile": ["tempFilename", " tmpfile", "tmpPath", "mpPath", "inputFILE", "tempFile", "inputfile", "empFile", " tmpFiles", "empFILE", "mpFile", "empFilename", "tmpfile", "tmpFiles", "tempFILE", "tempFiles", " tmpPath", "tmpFILE", "empfile", "tmpFilename", "tempPath", "mpFiles", "mpfile", "tempfile", "inputFilename"], "in": ["c", "t", "io", "bin", "din", "inv", "conn", "stream", "id", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "ln", "inf", "ain", "source", "r", "client", "is", "ic", "input", "In", "n", "init", "o", "IN", "ini", "it", "ch", "from", "ar", "ins", "inn", "cin", "ai", "cont", "ri", "sin"], "out": ["c", "t", "tmp", "io", "buffer", "can", "write", "inv", "conn", "connection", "ne", "by", "os", "auto", "OU", "log", "file", "this", "en", "pool", "at", "sys", "client", "oss", "cache", "obj", "conv", "n", "on", "ao", "co", "all", "o", "conf", "net", "w", "outs", "ch", "group", "Out", "output", "we", "ex", "cm", "null", "to", "lock", "writer", "ou", "aos", "OUT", "outer"], "con": ["c", "can", "conn", "cone", "re", "cal", "Con", "connection", "Conn", "func", "const", "ln", "ain", "tc", "mc", "cp", "cons", "CON", "ws", "conv", "connect", "login", "un", "ran", "co", "soc", "exc", "win", "sec", "cur", "conf", "num", "cn", "cm", "ch", "fc", "com", "cin", "cos", "nc", "fn", "cf", "acon"], "fileLength": ["FILELength", "ileDuration", "fileLen", "fileSize", "objectLength", "channelDuration", "channelLength", "FILESize", "FILEDuration", "ileLen", "objectDuration", "ileSize", "fileFontSize", "channelFontSize", "objectFontSize", "channelSize", "fileDuration", "FILELen", " fileFontSize", " fileDuration", " fileLen", "objectSize", "ileLength", " fileSize"], "channelIn": [" channeledIn", "channelIN", "chanIn", "ChannelOut", "consoleedIn", "chanOut", "ChannelIN", "consoleIN", "clientin", "clientIn", "channeledIn", "clientSet", "clientOut", "channelin", "ChannelSet", "consoleIn", "chanIN", "ChannelIn", "chanSet", "channelSet", "ChanneledIn", "clientIN", "consoleOut", " channelin", " channelIN", "Channelin"], "channelOut": ["chanIn", "ChannelOut", "chanOut", "channelout", "courseout", " channelConn", "courseOUT", "chanConn", "Channelout", "ChannelConn", "channelConn", "consoleIn", "chanout", "ChannelIn", "consoleOUT", "ChannelOUT", "courseIn", " channelOUT", "courseOut", "consoleOut", "consoleout", " channelout", "channelOUT"], "tmpDocument": ["npDocuments", "tmDoc", "tpMedia", "tpDocument", " tmpDocuments", "tmpdocument", "tempDocument", "mkDoc", "tmpDocuments", "tmDocument", "tpFile", " tmpDoc", "tempDoc", "cpDoc", "mpdocument", " tmpdocument", "mkdocument", "tmdocument", "npDocument", "tpDocuments", " tmpMedia", "mpDocument", "cpDocument", "mpDoc", "cpdocument", "tmpDoc", "npFile", "mkDocument", "tmpMedia", "npMedia", "tempdocument"], "nl1": ["nlOne", "NL2", "nel3", "ln2", "pel1", "lnOne", "nl9", "nl0", "NL0", "nl01", "nr1", "sol9", "rn6", "nr01", "rn1", "rn3", "rnOne", "nrOne", "nl2", "sol0", "pelOne", "NL1", "nl3", "ln1", "nl6", "nel6", "pel01", "nel1", "ln0", "sol2", "NL9", "ln01", "nelOne", "ln6", "ln3", "sol1", "ln9"], "i": ["ip", "ori", "li", "y", "io", "v", "span", "bi", "ii", "k", "multi", "key", "xi", "I", "u", "id", "ui", "mi", "gi", "hi", "cli", "ami", "x", "is", "ie", "ti", "index", "ci", "pi", "ij", "ji", "a", "n", "me", "qi", "si", "ix", "init", "di", "info", "ini", "ims", "o", "it", "sim", "j", "\u0438", "m", "ai", "mu", "us", "ic", "ri", "ms"], "node1": ["layer0", "component2", "component1", "NodeOne", "component0", "Node001", "n0", "node0", "node2", "Node2", "layer91", "node91", "layer1", "Node0", " node91", "node001", "nodeOne", "n1", " node0", " node001", "n91", "layerOne", " node2", "ode001", "ode0", " nodeOne", "ode1", "ode2", "nOne", "componentOne", "Node1"], "tmpOut": ["tempIn", " tmpObj", "TempOUT", "npIn", "TempIn", "cmpout", "tempObj", "tmpIs", "mpOut", "mpObj", "cmpOut", "empOut", "tempout", "npOut", "tempOUT", "npObj", "tmpIn", "cmpIn", " tmpIs", "TempObj", "TempOut", " tmpout", "empIs", "npout", "tempIs", " tmpOUT", "tmpout", "mpIn", " tmpIn", "tmpObj", "tmpOUT", "tempOut", "empout", "mpout"], "retVal": ["RetVal", " retTrue", " retValue", "retTrue", "retValue", "RetValue", "RetTrue", "returnval", " retval", "retval", "returnVal", "Retval", "returnTrue", "returnValue"]}}
{"id1": "12766394", "id2": "17792212", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": [" testReadHelloWorldItXT", " testReadHelloWorldTtxt", " testReadHelloWorldTText", " testReadHelloWorldTXT", " testReadHelloWorldIttxt", " testReadHelloWorldItText", " testReadHelloWorldItxt"], "helloWorldIS": ["helloWorldISS", "helloLifeISS", "helloLifeIs", "helloWorldI", "helloWestIs", " helloWorldIC", " helloWorldI", "helloWestIC", "helloLifeI", "helloWorldIC", " helloWorldIs", "helloWestIS", " helloWorldISS", "helloLifeIS", "helloWorldIs"], "helloWorldPath": ["helloWorldCh", " HelloWestPos", "helloWorldName", "helloWireName", " helloWonderCh", "helloWestPos", "helloWirePath", "helloWestPath", " HelloWestPath", " HelloWestName", " HelloWorldPos", " helloWorldCh", " helloWorldTemp", "helloWorldTemp", " helloWonderPos", " HelloWorldPath", "helloWonderPath", "helloWebPath", " helloWonderPath", "helloWorldPos", "helloWonderName", "helloWebName", " HelloWestP", "helloWestP", "helloWonderCh", "helloWonderPos", " HelloWorldP", "helloWireTemp", " HelloWorldName", "helloWorldP", "helloWebTemp", "helloWestName", " helloWorldName", " helloWorldPos", " helloWonderName", "helloWestCh"], "fileOutputStream": ["fileOUSt", " fileOutputSteam", "fileOutputStyle", "fileInputstream", "fileInputSteam", "fileWriteStyle", " fileOutputPoint", "fileoutputstream", "fileoutputSt", "fileOutputSt", "fileInputStream", " fileOutputSt", " fileInputstream", "fileInputPoint", " fileInputSt", "fileOUstream", " fileInputStyle", " fileoutputSteam", "fileOutSteam", "fileOutputPoint", "fileOutPoint", " fileInputPoint", " fileOutputStyle", "fileOUSteam", "fileoutputSteam", "fileOutputstream", " fileoutputStream", "fileoutputStream", "fileoutputStyle", " fileInputSteam", "fileWriteStream", "fileWritePoint", "fileOutStream", "fileWriteSteam", "fileInputStyle", "fileOutputSteam", "fileoutputPoint", " fileOutputstream", "fileInputSt", " fileInputStream", " fileoutputPoint", "fileOutStyle", "fileOUStream", " fileoutputStyle"], "contentResolver": ["commentPoserver", "contentresolution", "imageRESurer", "contentPaloser", "contentrespter", "contentresolving", "contentSererver", "contentPoserver", "contentResolved", "contentRESistor", "entityResolution", "contentRESander", "contentPalolution", "contentJsolver", "contentPosinter", " contentResistor", "contentReserver", "contentResourceolver", "ContentResolve", "commentPosolver", " contentResoser", "entityRESolution", "contentSeriper", "contentPalurer", "contentSander", "imageRESolver", "contentParolution", "contentResistor", "contentPosiper", "commentResolution", "contentJsoser", "contentRespter", " contentResolution", "contentResinter", "contentParreader", "contentResiper", "contentResoser", "contentResol", "commentPosolution", "contentResander", "ContentResolver", "contentSolution", "contentJspter", "contentresol", " contentresolution", "contentPosolver", "imageRESolution", "contentResreader", "imageResolver", " contentresolver", "contentRightolved", "contentParinter", "contentParolver", " contentResinter", "contentRightinter", "contentRightolution", "ContentResol", "contentResourceolution", "contentResurer", "entityResreader", "Contentresolver", "contentSolver", "imageRESistor", "contentRESolver", "commentReserver", "contentRESurer", " contentresinter", "contentPalolver", "Contentresolve", " contentresolved", "contentSistor", "contentresolve", " contentrespter", "contentRESreader", "imageResurer", "contentresolved", "contentSerolver", "Contentresolving", "contentRESiper", "contentPosolution", "Contentresol", "contentREServer", "entityRESinter", " contentResander", "contentRightolver", "entityResolver", "contentPosolved", "contentResourceurer", "commentResolver", " contentresoser", "contentResourceistor", "commentPosiper", "contentJsolution", "contentresolver", "contentresinter", "entityResinter", "contentSerolution", "entityRESreader", "contentRESolution", " contentResolved", " contentRespter", "commentResiper", "contentresreader", "contentResolving", "contentResolve", "contentRESinter", "contentPalistor", "contentResolution", "contentPalpter", "imageResistor", "ContentResolving", "imageResolution", "contentresoser", "entityRESolver"], "content": ["data", "ext", "full", "cmd", "never", "address", "reason", "metadata", "media", "search", "ez", "message", "output", "condition", "valid", "null", "act", "config", "xml", "filter", "parent", "version", "history", "example", "read", "any", "core", "inner", "temp", "cell", "body", "section", "Content", "mask", "time", "cache", "magic", "context", "tx", "good", "txt", "twitter", "padding", "status", "html", "comment", "controller", "raw", "document", "image", "expression", "continue", "lead", "edit", "entity", "quest", "layout", "wrapper", "load", "contact", "info", "value", "template", "query", "ontent", "resource", "cont", "page", "c", "ce", "result", "zero", "right", "draft", "activity", "format", "command", "handle", "description", "sequence", "report", "empty", "code", "article", "current", "here"]}}
{"id1": "10281203", "id2": "12847055", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "        public MobileAgentProperties(Class declaringClass, String propertyFile) throws IOException {\n            this.defaults = (MobileAgent) AnnotationElement.getAnyAnnotation(declaringClass, MobileAgent.class);\n            URL url = getClass().getClassLoader().getResource(propertyFile);\n            if (url != null) {\n                props.load(url.openStream());\n                log.info(\"MobileAgent parameters loaded from file \" + url);\n            }\n        }\n", "label": 0, "substitutes": {"makeRead": ["makeread", " makeReading", "makeReading", "recordread", " doPrint", " doReading", " makeread", "recordReading", "makePrint", " doread", "recordRead", " makePrint", " doRead", "recordPrint"], "user": ["usage", "uid", "host", "human", "connection", "server", "id", "file", "author", "username", "post", "string", "creator", "client", "database", "rule", "name", "command", "password", "url", "project", "date", "student", "use", "User", "users", "field", "message", "person", "USER", "table", "owner", "auth", "word", "by"], "databaseID": ["directoryId", "databaseSet", " databaseSet", "connectionId", "connectionSet", "databaseType", " databaseType", "connectionID", "directoryType", "directoryID", "directorySet", "connectionIDs", "databaseId", " databaseIDs", "directoryIDs", "databaseIDs", " databaseId", "connectionType"], "time": ["estamp", "version", "text", "t", "create", "Time", "type", "frequency", "ime", "age", "clock", "TIME", "id", "tt", " Time", "delay", "now", "ty", "timer", "year", "string", "runtime", "duration", "end", "tm", "start", "rate", "date", "etime", "timeout", "info", "value", "sequence", "message", "tim", "m", "second", "port", "times", "window"], "query": ["text", "then", "create", "request", "view", "comment", "select", "sq", "join", "qu", "body", "string", "q", "update", "transform", "cmd", "menu", "ql", "check", "title", "term", "Query", "command", "quest", "script", "description", "search", "template", "qa", "question", "sequence", "sql", "condition", "message", "ask", "entry", "call", "task", "code", "what", "quote"], "statement": ["confirmed", "fr", "le", "memory", "binary", "state", "batch", "relation", "yahoo", "session", "cmd", "communication", "position", "processor", "init", "list", "cm", "condition", "sp", "rule", "usage", "frequency", "volume", "bind", "Statement", "application", "database", "policy", "execute", "response", "entry", "function", "ts", "ment", "ct", "buffer", "status", "copy", "commit", "se", "comment", "mt", "document", "phrase", "expression", "continue", "language", "storage", "journal", "pretty", "template", "ements", "sql", "that", "call", "table", "shell", "minute", "sn", "connection", "print", "library", "command", "description", "number", "sequence", "st", "report", "stat", "article", "word", "quote"], "count": ["c", "any", "status", "state", "OUNT", "ctx", "parts", "length", "total", "ind", "batch", "loc", "complete", "now", "index", "check", "cond", "counter", "found", "nt", "n", "amount", "handle", "contact", "all", "find", "number", "list", "nb", "num", "size", "message", "sum", "report", "Count", "call", "code", "ount", "table", "current"]}}
{"id1": "10759917", "id2": "7296597", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["save", "create", "replace", "write", "lete", "select", "insert", "download", "dump", "Delete", "del", "update", "put", "destroy", "de", "command", "clear", "get", "move", "execute", "load", "touch", "query", "link", "reset", "drop", "set", "remove"], "name": ["version", "c", "create", "type", "lon", "Name", "part", "key", "str", "base", "id", "data", "comment", "connection", "file", "ame", "l", "prefix", "error", "e", "common", "string", "path", "item", "time", "family", "alias", "title", "chain", "term", "format", "n", "old", "me", "url", "NAME", "names", "ma", "description", "search", "value", "o", "local", "link", "size", "w", "message", "null", "label", "m", "nm", "code", "parent", "resource", "word", "source", "filename"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemLinkWarning", "CannotDeleteSystemPageStatus", "CannotDeleteSystemLinksEx", "CannotDeleteSystemTypeEx", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemLinkEx", "CannotDeleteSystemPageEx", "CannotDeleteSystemPageException", "CannotDeleteSysLinkError", "CannotDeleteSystemLinkError", "CannotDeleteSystemDataStatus", "CannotDeleteSysLinksEx", "CannotDeleteSystemTypeException", "CannotDeleteSystemTypeError", "CannotDeleteSysLinksStatus", "CannotDeleteSysLinksException", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinksException", "CannotDeleteSysLinkStatus", "CannotDeleteSystemLinksStatus", "CannotDeleteSysLinkException", "CannotDeleteSysLinksError", "CannotDeleteSystemLinksError", "CannotDeleteSystemDataException", "CannotDeleteSystemDataError", "CannotDeleteSystemDataEx", "CannotDeleteSystemPageError", "CannotDeleteSystemLinkStatus"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotFoundOver", "ClassLinkTypeIsFindEx", "ClassLinkTypeNotUsedException", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotUsedEx", "ClassLinkTypeNotFoundEx", "ClassLinkTypeNotFindException", "ClassLinkTypeIsFind ", "ClassLinkTypeIsFindException", "ClassLinkTypeNotFindEx", "ClassLinkTypeNotFound ", "ClassLinkTypeNotUsedOver", "ClassLinkTypeIsFound ", "ClassLinkTypeNotUsed ", "ClassLinkTypeIsFoundException", "ClassLinkTypeIsFindOver", "ClassLinkTypeNotFind ", "ClassLinkTypeNotFindOver", "ClassLinkTypeIsFoundEx"], "conn": ["dn", "t", "org", "oc", "ctx", "en", "comm", "cp", "cmd", "cert", "err", "conv", "on", "conf", "con", "canon", "yes", "socket", "act", "addr", "connect", "col", "pt", "mc", "sys", "cc", "client", "gc", "open", "req", "rt", "gate", "die", "pg", "ca", "ct", "priv", "pen", "mt", "https", "pas", "ws", "nt", "ec", "exec", "resp", "pkg", "cur", "cn", "yn", "ens", "nc", "db", "ang", "c", "close", "enc", "connection", "Conn", "ce", "loc", "pool", "jp", "cb", "obj", "iw", "co", "coll", "win", "sec", "ch", "bo", "rel", "port", "ns"], "stmt": [" stmm", "Sttx", "STmt", "STMT", "stmp", "stpt", "Str", "stattm", "Stmp", "startMT", "Stmt", "Stpr", "str", "stmb", " stMT", "StMT", "Stmm", "stm", " sttx", "snMT", "strmt", "Sttm", "strpr", "snmt", "STtx", "strmm", " stmb", "consttm", " sttm", "startmt", "constmt", "Stmb", "statm", "stMT", "strMT", "constmb", "STmm", "stpr", "sttm", " stpr", "statMT", "startmp", "strm", "startmm", " stm", "snpt", "Stpt", "STm", "strr", "Stm", "constm", " stpt", "statmt", "sttx", " str", "strmp", "STtm", "STmb", "stmm", "snm"], "prepTable": ["ppTable", "pptable", "summaryTable", " prepTier", "ppTab", "preptable", "summarytable", "summaryTier", " prepTab", " preptable", "Preptable", "prepTab", "prepTier", "ppTree", "prepTree", " prepTree", "PrepTab", "PrepTree", "PrepTable", "PrepTier"], "objectLinkTable": ["objectLinkList", "objectlinkTab", "objectTypeTable", "objectLinkController", "objLinkController", "objectLinksList", "objectLinkTab", "objectLinksTable", "objectlinkTable", "objectlinkType", "objLinksList", "objectLinkstable", "objectLinktable", " objectLinkType", "objLinksController", "objectTypeTab", "objectLinkType", "objectLinksController", "objLinkTable", "objectlinktable", "objectTypeType", " objectLinkTab", "objLinktable", "objLinksTable", "objectTypetable", "objLinkList", "objLinkstable", " objectLinktable"], "sql": ["qs", "dl", "SQL", "spr", "inv", "sd", "nl", "str", "js", "html", "select", "csv", "sv", "sq", "join", "expression", "scl", "result", "string", "q", "ql", "sl", "spec", "format", "url", "description", "json", "expr", "template", "query", "rel", "ns", "fields", "quote", "xml", "sf", "s", "sp", "fn", "ips", "form"]}}
{"id1": "12586404", "id2": "11673907", "code1": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["parse", "submit", "create", "invoke", "select", "test", "action", "Run", "render", "profile", "running", "check", "work", "program", "play", "exec", "pass", "use", "execute", "load", "runs", "sample", "apply", "runner", "process", "call"], "prova": ["roba", " provo", "revo", "rega", "rovo", "Prova", "provo", "Proba", "rova", "Provo", "roga", "reva", "Proga", " proba", "proga", "reba", "proba", " proga"], "agent": ["cer", "ua", "manager", "worker", "actor", "ity", "host", "active", "server", "bot", "test", "ant", "agency", "action", "ain", "client", "player", "driver", "operator", "ie", "admin", "Agent", "ace", "name", "command", "password", "gent", "script", "pet", "issue", "service", "agents", "man", "net", "tag", "sim", "ad", "access"], "key": ["version", "y", "type", "secret", "state", "k", "ver", "host", "user", "id", "server", "py", "power", "Key", "client", "cert", "mk", "policy", "chain", "name", "export", "password", "root", "pass", "token", "info", "service", "value", "conf", "net", "link", "sum", "my", "keys", "resource", "KEY", " Key", "access"], "src": ["sync", "sb", "text", "img", "sr", "sc", "sn", "rl", "bs", "stream", "str", "cont", "sit", "rob", "rest", "dest", "loc", "sq", "sub", "secure", "dir", "uri", "https", "RC", "sys", "proc", "SOURCE", "path", "input", "res", "rc", "rb", "typ", "supp", "sing", "script", "its", "buster", "iv", "href", "sec", "cur", "rs", "std", "desc", "rel", "st", "from", "ins", "null", "syn", "addr", "config", "resource", "inst", "s", "seed", "ser", "source", "filename", "txt"], "file": ["le", "io", "create", "binary", "fe", "type", "data", "base", "FILE", "full", "log", "File", "disk", "pool", "document", "image", "e", "il", "body", "source", "ile", "out", "path", "input", "library", "check", "open", "work", "rule", "name", "play", "handle", "f", " File", "be", "channel", "fp", "local", "link", "lock", "block", "from", "files", "null", "table", "resource", "port", "ca", "sol", "word", "db", "filename", "class"], "in": ["reader", "bin", "can", "din", "lin", "inv", " din", "mr", "data", "inc", "isin", "rin", "ind", "el", "mi", "en", "rest", "ill", "inner", "raw", "ln", "serv", "inf", "ain", "im", "iter", "vin", "mc", "out", "as", "r", "cgi", "input", "pin", "nin", "In", "gin", "init", "ma", "all", "info", "ini", "IN", "mn", "con", "it", "cm", "from", "ins", "inn", "cin", "i", "form", "and"], "is": ["ip", "tis", "est", "ists", "ire", "dis", "iris", "es", "bs", "does", "os", "ils", "sis", "isin", "sit", "mi", "isc", "bis", "isi", "has", "isf", "im", "ist", "sys", "ics", "as", "oss", "iso", "lis", "nis", "ys", "ires", "ois", "its", "IS", "si", "ris", "init", "fs", "ims", "ais", "isa", "mis", "iss", "ends", "it", "ios", "isl", "sim", "abs", "ir", "vis", "ins", "rys", "us", "i", "Is", "ic", "s", "ri", "ts", "ms"], "url": ["sb", "dl", "ml", "io", "ul", "rl", "nl", "mount", "str", "id", "user", "log", "l", "b", "gl", "web", "uri", "r", "ssl", "cert", "path", "ls", "dll", "ref", "sl", "mail", "bel", "ur", "http", "net", "kl", "ll", "link", "rel", "sql", "URL", "fl", "char", "null", "resource", "Url"], "fr": ["tf", "raf", "vr", "gr", "fer", "sr", "dr", "ry", "rl", "re", "mr", "str", "bf", "lr", "pr", "cf", "r", "fm", "tr", "fw", "hr", "br", "f", "fd", "FR", "rt", "fp", "ll", "fin", "fc", "fl", "ir", "fi", "rr", "cr", "Fr", "fy", "fn", "kr"], "results": ["features", "terms", "aps", "details", "maps", "products", "forms", "images", "them", "ults", "pins", "result", "errors", "options", "ces", "changes", "rows", "items", "prints", "reports", "objects", "comments", "res", "RESULTS", "actions", "its", "chains", "params", "names", "models", "Results", "runs", "docs", "outs", "resources", "blocks", "lines", "rules", "tests", "values", "output", "types", "vals", "cases"]}}
{"id1": "8132219", "id2": "23310397", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"copyFile": [" CopyFile", "copyFiles", "copyfile", "CopyStream", " copyfile", " copyStream", " CopyStream", " Copyfile", "CopyFiles", "CopyFile", "copyStream", " CopyFiles", " copyFiles", "Copyfile"], "inFile": [" inPath", "ninTemplate", "inputName", " inRow", "dinFile", "inName", "dinPath", "innRow", "ninFilename", "inTemplate", "inPath", "outTemplate", "innFile", "outFilename", "inEmail", "inputTemplate", "innPath", "ninFile", "innEmail", "dinEmail", "inputFile", "inRow", " inEmail", "inFilename", "dinRow", "outName", "ninName", "inputFilename"], "outFile": ["ouFILE", "destFormat", "outFILE", " outFormat", "ouTable", "outFilename", "destFILE", " outfile", "outFormat", "outputfile", "outputTable", "outputFILE", "destfile", "outfile", "ouFilename", "outputFile", "outputFilename", "outTable", "inFILE", "inTable", " outFILE", "destFile", "outputFormat", "inFilename", "ouFile"], "in": ["bin", "din", " din", "id", "inc", "isin", "rin", "ind", "el", "en", "inner", "ze", "inf", "ain", "source", "is", "input", "irm", "up", "In", "old", "on", "gin", "init", "info", "ini", "IN", "o", "it", " input", "ir", "from", "ins", "inn", "cin", "ai", "i", "s", "ic", "sin"], "out": ["c", "t", "io", "v", "can", "ne", "by", "os", "file", "en", "b", "e", "at", "ot", "gt", "client", "res", "name", "n", "p", "co", "all", "o", "net", "one", "w", "outs", "it", "Out", "output", "ex", "to", "g", "ou", "aos", "OUT"], "inChannel": ["cinColumn", "sinCase", "cinHandler", "newPanel", "ginPanel", "inButton", "inChan", "cinChannel", "newCase", "isinCase", "sinSlot", "innChannel", "inComponent", "outColumn", "isinChannel", " inHandler", "innerChannel", "outchannel", "outBlock", "inBlock", "innSlot", " inchannel", "innerConnection", "ginCategory", "innerchannel", "inSlot", " inChan", "cinButton", "outStream", "isinSlot", "newCategory", "ginChannel", "sinChannel", "sinBlock", "inchannel", "inStream", " inConnection", "isinCategory", "vinPanel", " inButton", "inCase", "vinCategory", "innCategory", "insideButton", "inHandler", "vinChannel", "inConnection", "innerChan", " inComponent", "cinBlock", "insideHandler", "insideComponent", "inPanel", "sinStream", "cinComponent", "outChan", "sinCategory", "inColumn", "vinCase", "insideChannel", "inCategory", "newChannel", "innCase", "ginCase", "cinStream", "sinColumn", "outConnection"], "outChannel": ["outClient", "inChan", "oChan", "outputCh", " outChain", " outPassword", "inPassword", "exChain", "outchannel", "outBlock", "exBlock", "OutChan", "OutChannel", " outClient", "nChannel", "outStream", "oPassword", "inchannel", "inStream", "inClient", " outChan", "outputChan", "nStream", "nChan", "outCh", "exChan", "outputConnection", "outputChannel", "nchannel", "oChannel", " outBlock", "outChan", " outchannel", "OutCh", "OutConnection", "oClient", "outChain", "exChannel", " outStream", " outConnection", " outCh", "outConnection", "outPassword"]}}
{"id1": "11475527", "id2": "14882263", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDataFromLocation", "addTextFromurl", "addTextFromURL", "addDatafromUrl", "addDatafromurl", "addDataFormUrl", "addTextFormUrl", "addDataFormLocation", "addDataFromurl", "addTextFormLocation", "addDataFromUrl", "addTextFormurl", "addDatafromLocation", "addTextFormURL", "addDataFormurl", "addTextFromLocation", "addDataToUrl", "addDataTourl", "addDataToURL", "addDataToLocation", "addTextFromUrl", "addDataFormURL", "addDatafromURL"], "theurl": ["teurl", "theloader", "hefile", "theuri", " thefile", "thurl", "heloader", " theUrl", "heuri", "teuri", "teUrl", "heUrl", "thefile", "TheUrl", "heurl", "thfile", "Theuri", " theuri", " theloader", " theURL", "teURL", "theURL", "heURL", "thloader", "theUrl", "thUrl", "TheURL", "Theurl"], "line": ["text", "day", "le", "zone", "lin", "lane", "status", "inline", "point", "comment", " inline", "LINE", "liner", "print", "l", "ln", "cell", "Line", "source", "string", "eline", "ner", "stroke", "ice", "email", "chain", "ine", "name", "online", "lined", "frame", "row", "record", "link", "sample", "block", "sequence", "message", "valid", "char", "entry", "code", "node", "rule", "page", "header"], "in": ["t", "reader", "bin", "read", "din", "conn", "or", "ac", "id", "inc", "isin", "rin", "mi", "en", "inner", "l", "serv", "inf", "ain", "lo", "mc", "out", "r", "proc", "is", "ic", "input", "pin", "open", "phys", "al", "In", "n", "old", "gin", "f", "ma", "init", "win", "o", "IN", "con", "it", "st", "from", "ins", "inn", "cin", "ai", "again", "i", "include", "source", "oin"], "data": ["content", "text", "io", "reader", "read", "buffer", "DATA", "stream", "pipe", "user", "ata", "this", "raw", "file", "join", "da", "bus", "next", "result", "body", "client", "out", "dec", "input", "cache", "dat", "a", "d", "feed", "info", "query", "size", "ad", "writer", "window", "def", "iterator"], "e": ["c", "t", "le", "ele", "y", "ae", "v", "te", "or", "se", "es", "eeee", "re", "oe", "eu", "ne", "ce", "b", "ze", "ge", "r", "x", "ie", "ue", "err", "de", "ine", "er", "a", "ec", "n", "me", "p", "ve", "pe", "d", "f", "be", "element", "o", "event", "E", "ee", "entry", "ex", "m", "g", "h", "i", "error", "ed"]}}
{"id1": "20685385", "id2": "17773263", "code1": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 1, "substitutes": {"getNextPkValueForEntityIncreaseBy": ["getNextPkValueForentityIncreaseby", "getNextPkValueForEntityIncreasesby", "getNextPkValueForEntityIncreaseby", "getNextPkValueForentityIncreasesWith", "getNextPkValueForentityIncreaseBy", "getNextPkValueForEntityIncreaseWith", "getNextPkValueForentityIncreaseWith", "getNextPkValueForEntityUpgradeBy", "getNextPkValueForentityIncreasesBy", "getNextPkValueForEntityIncreasesBy", "getNextPkValueForEntityIncreWith", "getNextPkValueForEntityUpgradeWith", "getNextPkValueForEntityIncreBy", "getNextPkValueForentityIncreasesby", "getNextPkValueForEntityUpgradeby", "getNextPkValueForEntityIncreasesWith", "getNextPkValueForEntityIncreby"], "entityName": ["activityNAME", "entityNames", "EntityName", "fromNAME", "fromName", " entityNAME", "EntityNAME", "entityBase", "activityName", "entityNAME", "EntityBase", "fromNames", "EntityType", "fromBase", "componentName", "activityType", "componentNAME", " entityNames", " entityType", "EntityNames", " entityBase", " entityPath", "entName", "templateType", "entNames", "activityNames", "templateNAME", "EntityPath", "entityPath", "eventName", "componentType", "componentNames", "eventType", "entityType", "eventNAME", "entType", "entPath", "templateName"], "count": ["history", "c", "ctr", "ct", "frequency", "OUNT", "range", "max", "ctx", "core", "more", "length", "total", "batch", "continue", "NB", "cc", "limit", "counter", "nt", "found", "n", "amount", "of", "all", "depth", "number", "find", "nb", "first", "force", "size", "context", "Count", "call", "code", "ount", "table", "C", "current"], "increasePkBy": ["increaseHkkMin", "increaseHkkMy", "increaseDkById", "increaseDkWhen", "increasePkeyBy", "increasePckMin", "increasePKeyStyle", "increaseCkBy", "increasePnWhen", "increaseDkeyById", "increasePidFrom", "increaseDkeyWhen", "increasePkById", "increasePkMy", "increasePnTo", "increaseHkMin", "increasePkPretty", "increaseDkeyCount", "increaseDkeyTo", "increasePkeyFrom", "increasePkMin", "increaseHkMy", "increasePqFrom", "increasePkTo", "increasePkValue", "increasePKeyBy", "increasePcby", "increasePckBy", "increasePkkBy", "increaseDkCount", "increasePcBy", "increaseCnTo", "increasePqValue", "increaseCkTo", "increaseDkStyle", "increasePksMin", "increaseDkeyBy", "increasePkWhen", "increasePkkMin", "increasePkeyCount", "increaseCnby", "increasePkeyById", "increaseDkBy", "increaseHkPretty", "increasePpTo", "increasePpBy", "increasePkeyTo", "increasePpById", "increasePkkPretty", "increasePidby", "increasePidValue", "increasePkeyWhen", "increasePpCount", "increasePkeyValue", "increasePKeyById", "increasePkby", "increaseCnBy", "increasePkCount", "increasePckMy", "increasePcTo", "increasePksBy", "increasePkeyStyle", "increaseHkkBy", "increasePkkMy", "increaseCkby", "increasePidTo", "increasePidBy", "increasePkFrom", "increasePnby", "increasePksPretty", "increasePksMy", "increasePpStyle", "increaseDkeyStyle", "increasePkStyle", "increasePckPretty", "increaseHkBy", "increaseHkkPretty", "increasePKeyCount", "increasePpWhen", "increasePnBy", "increasePqBy", "increaseDkTo"], "where": ["then", "who", "location", "wh", "html", "which", "select", "with", "test", "when", "WHERE", "join", " whe", "place", "uri", "body", "q", "hi", "whe", "way", "ql", "hold", "mail", "Where", "delete", "search", "find", "template", "query", "w", "sample", "eth", "how", "sql", "message", "condition", "show", "style", "handler", "holder", "what", "here", "set"], "ec": ["et", "c", "xc", "ev", "enc", "oc", "conn", "eu", "ctx", "ect", "ac", "sc", "esc", "uc", "eco", "ce", "isc", "arc", "bec", "dc", "cs", "bc", "e", "tc", "mc", "eg", "erc", "cc", "eh", "roc", "dec", "eb", "gc", "Ec", "rc", "exec", "ox", "ep", "co", "soc", "sec", "EC", "ew", "peg", "pc", "eth", "fc", "anc", "ek", "ee", "ctrl", "eca", "lc"], "dbc": [" dbcc", "adec", "dbC", "sdc", "sdci", "dbcc", "dbca", "dedcache", "debmc", " dbC", "dbcs", "debc", "debci", "dedC", "cdc", "dbdc", " dbdc", "bdcc", "debcc", "sdmc", "cdcs", "libC", "dedcc", "debC", "bdC", " dbcs", " dbcache", "dbmc", " dbci", " dbca", "sdcache", "debcs", "bdc", "dbd", "libd", "debd", "cddc", "dbci", "dedc", " dbd", "debca", "cdcc", "adeC", "debcache", "adecache", "libca", "libc", " dbmc", "debdc", "dbcache", "adecc", "bdcache"], "entity": ["object", "peer", "ITY", "type", "instance", "ENT", "oe", "data", "connection", "eme", "el", "ce", "existent", "document", "image", "component", "e", "ent", "ident", "security", "alias", "email", "activity", "name", "pe", "ell", "event", "ee", "entry", "Entity", "oid", "node", "model", "table", "resource", "unique", "owner", "equ"], "channel": ["c", "annels", "peer", "type", "chan", "conn", "member", "Channel", "connection", "scope", "col", "server", "controller", "attribute", "collection", "component", "relation", "axis", "course", "console", "client", "queue", "database", "chain", "name", "chart", "caster", "woman", "all", "row", "container", "event", "ch", "context", "group", "area", "entry", "handler", "table", "resource", "system"], "result": ["closure", "results", "details", "product", "buffer", "data", "answer", "total", "currency", "join", "profile", "cache", "res", "RESULTS", "success", "primary", "successful", "found", "created", "direction", "diff", "description", "match", "search", "cur", "event", "response", "sequence", "group", "output", "message", "true", "Result", "current", "cup"], "broker": ["burbo", "brolder", "roukers", "brobo", "rouker", "roubro", "Broker", "brlder", "Brobo", "brokers", "brken", "brbo", "rouken", "Brolder", "brger", "broger", "broken", "Broger", "Brobro", "burlder", "burger", "Broken", "brobro", "brkers", "brker", "Brokers", "burker", "brbro"], "con": ["c", "ct", "can", "enc", "conn", "re", "cal", "Con", "connection", "po", "Conn", "col", "bean", "pen", "en", "go", "ln", "ain", "mc", "cp", "cc", "cmd", "clean", "client", "cons", "res", "CON", "open", "cond", "rc", "conv", "connect", "ran", "un", "exec", "co", "coll", "soc", "conf", "cur", "cn", "cm", "fc", "anc", "dial", "com", "act", "ctrl", "ca", "nc", "fn", "cf"], "tries": ["pails", "itried", "tails", "retails", " tried", " trys", "itails", "tsried", "trys", "tsrys", "retrys", "Trys", "tried", "prys", "Tries", "pries", "tsails", "Ties", "itries", "retries", "pried", "Tails", "tsries", "ties", "tsies", "itrys", " tails", "reties", "Tried"], "resultSet": ["resultRow", "Resultset", "responseMap", "ResultTime", "resultTime", "rowList", "resultSpec", " resultStream", " resultList", "ResultMap", " resultRow", " resultTime", "rowRow", "resultset", " resultset", "resultList", "rowTime", "resultMap", " resultMap", "responseSet", "ResultSet", "rowSet", "tableSet", "valueSpec", "responseStream", "resultStream", "valueMap", "tableMap", "valueSet", "valueStream", "ResultList", "responseSpec", "ResultRow", " resultSpec", "tableset", "tableList"], "hasNext": [" hasBottom", "HasNext", "HasNew", "hadPrev", "HasBottom", "showsNext", "hasPrevious", " hasNew", "showsBottom", "hasPrev", "hasNew", "HasPrevious", " hasPrev", "hasBottom", "HasPrev", "hadNew", "hadNext", "showsPrevious", " hasPrevious"], "pk": ["dck", "pck", "npkid", "jpkt", "jpj", " apek", "fpk", "dk", "dke", "pkt", " pck", " pkt", "pkey", " pek", " pke", "npk", "tpkt", "prkid", "npck", "jpk", "pke", "tpk", "tpj", "tpkey", " pki", "pj", "prki", "prk", " pak", "npke", " apk", " pj", "npak", "pek", "pak", "pkid", "fpkid", "jpkey", "prek", "dak", " apkid", " apak", "fpki", "fpek", "pki", " pkey", "npek", " pkid"]}}
{"id1": "397240", "id2": "14733078", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "9371421", "id2": "8588992", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"eventHash": ["EventName", "EventRender", " eventhash", " eventRender", " eventName", "eventRender", "textName", "textHash", "EventHash", "textRender", "Eventhash", "eventName", "texthash", "eventhash"], "eventstr": ["msgstr", " eventStr", "Eventname", "msgStr", "eventstring", "msgname", "msgstring", "ventStr", "Eventstr", " eventenc", "eventenc", " eventstring", "ventenc", "Eventenc", "eventStr", "eventname", "ventstr", "Eventstring", "ventname", " eventname", "EventStr"], "md": ["pm", "bd", "MD", "dh", "det", "cd", "dr", "td", "sd", "down", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "dig", "del", "cmd", "df", "mk", "mb", "nd", "mo", "dm", "pd", "nt", "metadata", "dat", "grad", "mem", "mp", "d", "ma", "der", "di", "ld", "rm", "mn", "od", "met", "m", "red", "ad", "mm", "mg", "ms"], "theDigest": [" theDEST", "theDecest", "theDFEST", "THEDigEST", "theDEST", "theDigEST", "theMDested", "THEMDested", "THEDigest", "theDigests", "theDested", " theDested", " theDigested", "thedigested", "theDecested", "theDFesting", "theDFest", "theDesting", "theDecEST", "theMDest", "THEDigested", " theDesting", "THEMDEST", "theDest", "theDigested", "theDests", "THEDigests", " theDigesting", "theMDEST", "thedigest", "theDigesting", "THEMDest", "THEMDests", "theMDests", "theDFested", " theDigEST", "thedigesting", "theDecests", " theDest", "thedigEST"]}}
{"id1": "9805906", "id2": "15580610", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"dump": ["save", " dumped", "println", "read", "write", "copy", "debug", "download", "print", " debug", " describe", "flush", "update", "export", "diff", "send", "init", "load", "info", " println", " show", "link", " dumps", "display", "stat", "show", "store", "zip"], "source": ["text", "copy", "se", "src", "view", "scope", "select", "file", "image", "iter", "origin", "sys", "ie", "SOURCE", "input", "ource", "check", "java", "spec", "ink", "start", "Source", "script", "init", "search", "service", "template", "info", "local", "sample", "sequence", "site", "sql", "from", "style", "config", "shell", "resource", "parent", "store", "remote", "form"], "target": ["t", "replace", "top", "copy", "current", "arget", "host", "compatible", "base", "file", "test", "dest", "next", "gt", "pattern", "mac", "term", "goal", "tif", "project", "delete", "match", "arg", "template", "proxy", "local", "it", "link", "output", "that", "null", "style", "to", "table", "bolt", "Target"], "is": ["tis", "ip", "mos", "ists", "iris", "in", "ii", "es", "sis", "isin", "isc", "bis", "isi", "has", "ib", "isf", "im", "bits", "ics", "ist", "sys", "oss", "iso", "ms", "lis", "ls", "nis", "ys", "ois", "its", "IS", "ris", "are", "si", "init", "ais", "ims", "isa", "iss", "it", "ios", "isl", "abs", "ir", "ar", "ins", "act", "ai", "i", "Is", "ic", "s", "ri", "xs"], "os": ["dos", "nos", "ss", "io", "ps", "mos", "ose", "Os", "or", "es", "bs", "ros", "js", "OS", "pos", "oS", "cs", "bos", "sys", "ot", "oss", "ows", "ds", "oos", "oses", "ls", "ants", "uts", "ox", "ols", "los", "fs", "o", "ost", "outs", "ios", "css", "obs", "osi", "oes", "cos", "s", "ts", "ns", "aos"], "done": ["checked", "shown", "started", "Done", "du", "disabled", "led", "needed", "des", "gone", "seen", "enabled", "complete", "continue", "flag", "did", " continued", " Done", "ished", "progress", "pleted", "de", "found", "created", "later", "d", "di", "loaded", "set", "expected", "made", "die", "finished", "desc", "only", "failed", "valid", "dirty", "given", "filled", "ded"]}}
{"id1": "14688886", "id2": "5299276", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["popureResources", "popureResource", "populatesResources", "populatedResources", "PopureFiles", "PopulateResources", "popureReferences", "PopulateResource", "PopulateFiles", "PopulateReferences", "populateFiles", "populatedReferences", "populatesResource", "populatedFiles", "populatesFiles", "populateResource", "PopureReferences", "populateReferences", "popureFiles", "populatedResource", "PopureResource", "PopureResources", "populatesReferences"], "templates": ["sequporary", "tenplates", "tplates", "typlates", "tmports", "temiles", "timeters", "timporary", "sequples", "sequplates", "Temples", "timples", "filmen", "temmen", "tenables", "memables", "temporary", "tctions", "typles", "temables", "Temmen", "timplates", "temports", "temctions", "tmeters", "tmples", "tmmen", "temples", "tples", "tiles", "memplates", "filplates", "Templates", " temiles", "temeters", "tyables", "teniles", "tyeters", "filports", "tmplates", "sequeters", "teters", " temctions", "tmporary", "tables", "memples", "memeters", "Temports", "filples", "tenctions", " temables"], "url": ["dl", "li", "ml", "location", "rl", "nl", "mount", "html", "base", "u", "file", "l", "b", "e", "gl", "web", "uri", "string", "r", "pattern", "ssl", "browser", "mb", "item", "path", "res", "mail", "ref", "sl", "address", "name", "a", "term", "n", "ur", "handle", "get", "p", "f", "pl", "http", "row", "ll", "link", "rel", "URL", "char", "entry", "m", "resource", "Url", "rect", "key"], "fileName": ["fileType", " filePart", "tileCopy", "fileLoad", "fileParent", "moduleKey", "FilePath", "FileName", "ilePath", "FILECopy", "ileCopy", "familyName", "urlFamily", " fileBody", "FileKey", "blockTime", " fileLoad", "fileTitle", "Filename", "familyLoad", "familyTime", "blockName", "FILEname", "templateString", "namename", "fileString", "templateName", "nameName", "nameParent", "fBody", "FILELine", "fileKey", "filenamePart", "urlName", " fileTime", "moduleName", "fileLine", "FilePart", "urlPath", " filePath", "ileLine", "familyname", "tileLine", "filenamename", "FileBody", "tileName", "filename", "FileFull", " fileKey", "fileCopy", "ilePart", "ileFull", "ilename", "fileBody", "fileFull", "fileFamily", "moduleType", "fPath", " fileString", "resourceType", "blockLoad", "fname", "resourceName", "templatename", "templatePath", "FileString", "resourceKey", "urlKey", "fName", "FileFamily", "filenameParent", "filenameName", "resourceTitle", " fileTitle", "FILEName", " fileParent", " fileFamily", "filePath", "filePart", " fileFull", "ileName", "tilename", "fileTime", "namePart", " fileType", "blockname", "moduleTitle", " filename"], "templateResource": [" templateEntry", "resourceRole", "TemplateResources", "resourceEntry", "componentReference", "componentResources", "TemplateRes", "templateResources", " templateProperty", "documentRes", "templateProperty", "resourceRes", " templateReference", "componentRes", "templateReference", "componentResource", "TemplateEntry", "TemplateProperty", "documentResource", "templateRes", " templateRes", "templateRole", "resourceProperty", "TemplateReference", " templateRole", "TemplateResource", "templateEntry", "documentRole", "resourceResource", " templateResources"], "is": ["fr", "iris", "in", "es", "bs", "\u00eds", "os", "sis", "isc", "bis", "isi", "isf", "im", "sys", "as", "iso", "lis", "nis", "its", "IS", "sels", "ris", "are", "fs", "ais", "rs", "isa", "iss", "ios", "isl", "ir", "ins", "rys", "us", "Is", "ic", "ri"], "strBuff": ["drBu", "strBuffer", "StrBuffer", "brComp", "arrBas", " strFac", " strComb", "arrBuffer", "arrBuff", "stringBuffer", "drBuffer", "brBuff", "strBas", "strComb", "strbuff", "drComp", "stringBuff", " strComp", "StrFac", "strComp", "strFac", "strBu", "stringBas", "brBuffer", "StrBuff", "arrbuff", "arrComb", " strBuffer", " strBas", "brBu", " strBu", "arrFac", "drBuff", "stringComb", " strbuff", "Strbuff"], "br": ["bg", "fr", "bd", "ctr", "vr", "gr", "Br", "sr", "bm", "dr", "bh", "bi", "shr", "bs", "mr", "bf", "lr", "pr", "b", "bt", "bc", "wr", "ber", "next", "yr", "r", "tr", "hr", "bl", "rb", "er", "buf", "bro", "bp", "ch", "cr", "BR", "bn", "kr"], "str": ["text", "fr", "t", "ctr", "gr", "stable", "dr", "Str", "arr", "ocr", "cont", "pr", "print", "cs", "draw", "pt", "string", "del", "r", "cert", "tr", "St", "res", "ust", "err", "obj", "bl", "chain", "name", "spec", "sl", "n", "p", "coll", "seq", "list", "STR", "sts", "st", "cr", "sp", "s", "g", "msg", "set", "txt"], "images": ["videos", "modules", "faces", "raphics", "views", "amps", "vs", " Images", " photos", "frames", "eps", "image", "pins", "assets", "photos", "scripts", "games", "thumbnails", "items", "versions", "pages", "xs", "reports", "styles", "ids", "ages", "actions", "media", "rooms", "names", "atts", "ims", "arms", "ups", "uploads", "eds", " pictures", "resources", "types", "blocks", "files", "Textures", "ins", "Images", "boxes", "times", "apps", "ms"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "gu", "hi", "cli", "ami", "ini", "ei", "sim", "j", "my", "mu", "us", "def", "io", "_", "multi", "u", "this", "x", "ki", "index", "pi", "ij", "get", "qi", "di", "Exception", "status", "id", "mi", "gi", "ie", "me", "p", "si", "ix", "info", "it", "key", "ip", "phi", "ui", "im", "ti", "ci", "name", "n", "http", "m", "ai"], "img": ["bg", "tmp", "pic", "li", "jpg", "iam", "medium", "src", "amp", "html", "md", "imp", "file", "aug", "div", "image", "Image", "im", "r", "png", "ami", "mk", "fm", "att", "anim", "obj", "bl", "ij", "a", "small", "fig", "mp", "buf", "gif", "p", "f", "pkg", "av", "j", "gm", "gd", "m", "g", "pg", "mg"], "imgProperty": ["imageImage", "imagePro", "imgProp", " tmpProp", " tmpPro", "imageProperty", "imageProp", " tmpProperty", " imgPro", " imgProp", "imgPro", " tmpImage", " imgImage", "imgImage"]}}
{"id1": "19322910", "id2": "4164833", "code1": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"test_blueprintTypeByTypeID": ["test_blueprintTypeByTypeType", "test_blueprintTypebyTypeName", "test_blueprintTypeByTypesType", "test_blueprintTypeByTypesName", "test_blueprintTypeByTypesId", "test_blueprintTypebytypeName", "test_blueprintTypebytypeId", "test_blueprintTypeByNameId", "test_blueprintTypeByNameName", "test_blueprintTypeByNameID", "test_blueprintTypebyTypeID", "test_blueprintTypeBytypeType", "test_blueprintTypeByTypeName", "test_blueprintTypeBytypeID", "test_blueprintTypeBytypeId", "test_blueprintTypeBytypeName", "test_blueprintTypebyTypeType", "test_blueprintTypeByTypesID", "test_blueprintTypebytypeID", "test_blueprintTypebytypeType", "test_blueprintTypeByTypeId", "test_blueprintTypeByNameType", "test_blueprintTypebyTypeId"], "url": ["sb", "dl", "ml", "location", "org", "ul", "conn", "rl", "nl", "mount", "str", "base", "user", "u", "atl", "this", "log", "document", "l", "b", "relation", "language", "loader", "web", "uri", "https", "string", "ssl", "impl", "browser", "ls", "util", "open", "mail", "ref", "sl", "email", "bel", "builder", "ur", "get", "http", "service", "channel", "row", "module", "ll", "link", "domain", "context", "URL", "resource", "Url"], "connection": ["object", "generation", "location", "creation", "close", "instance", "translation", "conn", "volume", "operation", "user", "server", "controller", "attribute", "collection", "relation", "computer", "using", "government", "statement", "expression", "language", "still", "uri", "session", "console", "machine", "client", "section", "pointer", "reference", "library", "division", "application", "open", "engine", "database", "created", "communication", "command", "position", "description", "network", "character", "number", "directory", "channel", "row", "container", "termination", "Connection", "record", "link", "response", "office", "condition", "settings", "sql", "message", "entry", "internet", "initial", "information", "subject", "handler", "function", "resource", "ion", "current", "connect", "system"]}}
{"id1": "16466743", "id2": "18164929", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getmd5": ["getsha5", "getmd6", " getMD6", " getMD2", "getMD5", "getMD4", "getsha2", "getmd4", " getMD5", " getMD4", "getMD6", "getMD2", " getmd6", "getsha4", " getmd4", "getmd2", "getsha6", " getmd2"], "password": ["text", "wd", "secret", "padding", "data", "user", "attribute", "username", "phrase", "prefix", "sword", "string", "pattern", "security", "hash", "path", "email", "database", "address", "name", "login", "wordpress", "shadow", "pass", "Password", "p", "token", "description", "hello", "value", "ew", "w", "message", "entry", " Password", "code", "auth", "word", "key"], "pwHash": ["pwtHas", " pwHas", "pWhash", "pWSum", "pwsHash", "pWHash", "pwsHas", "spwHas", "pwthash", "pwdhash", "pwshash", "pwdHash", "pwtHash", "pwsSum", "pwHas", "pwdSum", "pwhash", "spwhash", "spwdSum", " pwdSum", "spwdHas", "pWHas", "spwHash", "pswSum", "spwSum", " pwdhash", "pswHash", "pswHas", " pwdHas", "pwdHas", " pwdHash", "spwdHash", "pswhash", "pwSum", " pwSum", " pwhash", "pwtSum", "spwdhash"], "md": ["pm", " Md", "bd", "MD", " mo", "det", "cd", " mm", "td", "ng", "sd", "sm", "mt", "ind", "mod", "add", "dd", "hd", "dir", "mc", "dig", "del", "cmd", " dd", "ds", "df", " mc", "mk", "nd", "dm", "mo", "mb", "cond", "mail", "pd", "metadata", "material", "mem", "exec", "grad", "mp", "d", "der", "di", "ld", "rm", "man", "mn", "od", "desc", "def", "m", "doc", "msg", "cmp", "mm", "red", "ad", "mg", "ms"], "b": ["sb", "B", "y", "binary", "v", "bi", "ba", "bh", "bs", "buff", "fb", "bf", "bis", "batch", "bas", "l", "bc", "ib", "bar", "ab", "mb", "eb", "cb", "ob", "br", "obj", "rb", "a", "p", "f", "d", "be", "gb", "nb", "w", "bp", "abs", "bytes", "m", "g", "bu", "db", "bb", "reb"], "i": ["ip", "li", "y", "io", "v", "span", "bi", "in", "ii", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "iu", "mi", "ski", "oi", "l", "gu", "next", "gi", "im", "iter", "q", "hi", "cli", "x", "is", "ki", "ti", "ie", "index", "ci", "pi", "ji", "ij", "a", "n", "p", "qi", "si", "init", "ix", "di", "json", "ini", "ei", "o", "it", "yi", "sim", "j", "my", "\u0438", "m", "ai", "us", "ic", "ri", "ms"]}}
{"id1": "23585985", "id2": "8046691", "code1": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"getStreamSource": ["getFormSources", "getStreamerIterator", "getRawStream", "getStreamSources", "getStreamerSources", " getFormIterator", "getRawSources", " getStreamSources", "getRawIterator", "getFormStream", "getFormIterator", "getStreamIterator", " getFormStream", "getStreamStream", " getStreamStream", "getRawSource", " getFormSources", "getStreamerSource", " getFormSource", " getStreamIterator", "getStreamerStream", "getFormSource"], "item": ["object", "claim", "detail", "oc", "original", "anything", "iter", "mix", "jack", "hit", "job", "spec", "up", "term", "related", "on", "exp", "element", "list", "val", "row", "sim", "initial", "addr", "xml", "remote", "rule", "other", "this", "el", "Item", "attribute", "now", "add", "cell", "menu", "stuff", "event", "local", "record", "link", "entry", "atom", "good", "app", "unit", "type", "status", "tree", "raw", "document", "om", "image", "edit", "check", "att", "ref", "op", "p", "pkg", "json", "info", "value", "it", "that", "msg", "owner", "attr", "source", "key", "content", "instance", "re", "abc", "test", "result", "tk", "items", "input", "device", "name", "mem", "handle", "module", "container", "area", "m", "store", "article", "com", "empty", "word"], "context": ["content", "object", "text", "c", "location", "instance", "state", "ctx", "view", "connection", "collection", "document", "component", "construct", "options", "mc", "cc", "operator", "input", "index", "cache", "check", "runtime", "application", "Context", "chain", "environment", "kernel", "command", "metadata", "wrapper", "network", "search", "info", "template", "event", "sequence", "condition", "tx", "subject", "information", "config", "parent", "resource", "current", "set", "system"], "streamSource": ["acceptScan", "consoleStore", "feedSourceFile", "peerSourceFile", "signScope", "constSourceFile", "streamSourceFile", "peerSource", "StreamSource", "followSpec", "acceptSourceFile", "acceptSource", "streamScope", " streamSite", "signSource", "StreamProvider", "hostType", "streamType", "streamScan", "socketSite", "streamSources", "socketSource", "runtimeScope", "peerScan", "feedSite", "signSOURCE", "streamManager", "hostSourceFile", "acceptSite", "streamSOURCE", " streamSources", "runtimeSOURCE", "constScan", "consoleSources", "constSource", "feedSource", "streamStore", "constSite", "hostSource", "streamSite", "feedStore", "runtimeSource", "consoleSource", "consoleProvider", "designSOURCE", "designSource", "peerSite", " streamType", "followSOURCE", "feedSources", " streamManager", "socketStore", "consoleType", " streamStore", "StreamSources", "streamProvider", " streamScope", "hostStore", "followSource", "streamSpec", "designSpec", " streamSourceFile", "StreamSOURCE", "StreamManager", "socketSourceFile", "consoleManager", " streamSpec", "followStore", "designStore", " streamProvider", "consoleSourceFile", "feedSOURCE", " streamSOURCE"], "obj": ["jj", "object", "t", "ct", "tmp", "y", "sky", "app", "org", "obo", "bh", "oc", "js", "Obj", "os", "xy", "oj", "aos", "tk", "ck", "ot", "cod", "cmd", "aux", "x", "mk", "mo", "cb", "ob", "ref", "nt", "pot", "ox", "resp", "co", "pkg", "json", "stuff", "o", "bj", "bo", "abs", "j", "obs", "ex", "act", "msg", "cmp", "attr", "ht", "def", "txt"], "inputFile": ["InputFILE", "InputPath", "importFiles", "sequenceSet", "importObject", "inputFILE", "inputfile", "mediaObject", "textFile", " inputSet", " inputObject", "InputFiles", "textFILE", "mediaFILE", "importFile", "Inputfile", " InputObject", "inputObject", " Inputfile", " inputfile", " InputFile", "mediafile", "textObject", "mediaFile", "inputPath", "inputSet", "sequenceObject", "textfile", "sequencefile", "sequenceFile", " InputSet", " inputFiles", "InputFile", "inputFiles", "InputObject", "importPath", " inputPath"], "is": ["tis", "ains", "atis", "ists", "dis", "iris", "es", "bs", "js", "os", "ils", "sis", "isin", "bis", "isc", "isi", "has", "cs", "was", "isf", "im", "ics", "sys", "xs", "as", "iso", "ls", "lis", "nis", "ys", "res", "ires", "its", "IS", "ris", "init", "info", "fs", "ais", "ims", "mis", "isa", "iss", "stats", "ios", "isl", "abs", "sim", "obs", "ins", "Is", "i", "cont", "s", "set", "ms"], "url": ["dl", "ml", "org", "ul", "rl", "host", "nl", "mount", "str", "run", "html", "id", "user", "external", "full", "el", "log", "lr", "loc", "print", "l", "norm", "prefix", "gl", "web", "dir", "uri", "https", "string", "q", "console", "r", "pattern", "ssl", "impl", "browser", "path", "ls", "cert", "util", "mail", "ref", "sl", "email", "address", "term", "format", "tm", "ur", "handle", "f", "pkg", "http", "len", "href", "ll", "hl", "link", "rel", "domain", "sql", "URL", "char", "label", "addr", "xml", "Url", "attr", "db"], "np": ["dn", "lp", "tp", "dh", "rpm", "pn", "nu", "nl", "nr", "dp", "jp", "vp", "ph", "nn", "nv", "nit", "hp", "pd", "nw", "n", "mp", "pkg", "wp", "nb", "mn", "fp", "NP", "num", "bp", "gov", "nm", "rn", "nc", "kr"], "serializer": ["serialifier", " serialer", "erialiser", "initialer", " serialization", "virtualisation", "virtualizer", "initialifier", "erialization", "initialization", " serialiser", " serialifier", "virtualization", "serialisation", "erializer", "initialiser", "erialer", " serialisation", "virtualifier", "serialiser", "initializer", "serialer", "serialization", "initialisation"], "node": ["content", "object", "nu", "src", "view", "tree", "remote", "mor", "document", "component", "image", "nn", "Node", "entity", "nt", "name", "n", "root", "token", "json", "value", "row", "nb", "od", "num", "event", "entry", "oid", "m", "nm", "article", "resource", "xml", "doc", "msg", "seed", "source"], "binary": ["_", "instance", "Store", "Ex", "New", "n", "Entry", "Source", "get", "of", "ex", "null", "xml", "Raw"]}}
{"id1": "416857", "id2": "5682569", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"process": ["scan", "parse", "create", "read", "run", "processing", "walk", "update", "proc", "Process", "input", "check", "work", "program", "step", "accept", "loop", "exec", "handle", "processor", "load", "execute", "output", "display", " ingest", "task", "filter"], "dir": ["dl", "tmp", "det", "cd", "wd", "org", "dr", "orig", "src", "lib", "host", "str", "data", "html", "md", "id", "rot", "this", "log", "file", "disk", "ind", "loc", "div", "mod", "prefix", "dd", "del", "out", "mk", "Dir", "www", "DIR", "name", "dat", "tar", "old", "start", "handle", "root", "url", "direction", "grad", "pkg", "d", "folder", "http", "fd", "directory", "cur", "dist", "local", "desc", "rect", "rel", "vol", "ir", "direct", "deg", "doc", "lim", "addr", "window", "db", "filename", "home", "def", "txt"], "list": ["dl", "li", "tmp", "v", "detail", "state", "data", "select", "batch", "left", "spec", "names", "pre", "null", "config", "filter", "def", "other", "history", "details", "dict", "L", "this", "LIST", "file", "collection", "l", "lists", "now", "add", "lat", "sort", "ist", "out", "single", "listed", "ls", "index", "cache", "get", "delete", "match", "record", "local", "link", "see", "write", "status", "copy", "range", "tree", "length", "ln", "string", "line", "map", "old", "block", "table", "cont", "source", "set", "re", "str", "log", "test", "print", "dump", "result", "queue", "split", "chain", "name", "note", "array", "all", "number", "rm", "sequence", "st", "display", "stat", "show", "code", "word", "form"], "n": ["c", "np", "t", "count", "v", "ng", "sn", "nu", "nl", "nr", "ne", "total", "norm", "l", "ln", "na", "nn", "no", "pi", "nt", "name", "nan", "nw", " N", "un", "N", "p", "d", "ni", "len", "names", "network", "number", "nb", "net", "num", "w", "nor", "j", "m", "nm", "z", "g", "nc", "ns"], "bubblesort": ["bubblingORT", "gobblingorter", "bubbledorter", "bubbsORT", "bubbsorter", "robbledist", "bubblort", "robbledorts", "bubblingorts", "gobbsORT", "robbledorter", "robblesorter", "bubblesorter", "gobblesord", "bubblerv", "gobblingerv", "robbledort", "bubblingort", "gobbleorter", "bubblingorter", "gobblessort", "bubbsord", "bubblersort", "bubbledord", "bubbledorts", "bubbsort", "bubblingord", "bubblorter", "bubbleserv", "bubbleorter", "robblesorts", "bubblessort", "gobblingort", "bubblesist", "bubbledORT", "bubbsist", "gobbleort", "gobbleserv", "bubbledsort", "gobblingsort", "gobblesorter", "bubbleorts", "gobbsort", "bubbledort", "robbledord", "robblesist", "gobblesist", "gobbsorter", "bubbsorts", "robblessort", "bubblerord", "bubblerort", "gobbsord", "bubblerorter", "bubblingerv", "robbledsort", "gobblesort", "robblesord", "gobbleist", "bubbleord", "bubbleist", "bubbledist", "bubblsort", "bubblesORT", "bubblesord", "bubblingsort", "bubblederv", "bubbleort", "robblesort", "gobblesORT", "bubblesorts", "bubbssort"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "batch", "iter", "hi", "cli", "ami", "is", "err", "exp", "init", "ini", "ei", "ims", "sim", "j", "my", "g", "zi", "us", "parent", "ic", "io", "in", "multi", "u", "this", "l", "e", "q", "x", "ki", "index", "pi", "ij", "iri", "qi", "di", "record", "s", "fire", "ity", "eu", "point", "id", "mi", "gi", "uri", "ji", "iq", "me", "p", "si", "ix", "it", "to", "key", "set", "c", "phi", "ui", "ind", "iu", "go", "oi", "im", "ti", "ci", "chain", "ex", "m", "z", "ai", "ri"], "f": ["t", "fr", "tf", "c", "aff", "v", "fe", "fac", "bf", "fb", "file", "l", "b", "fab", "af", "df", "lf", "fm", "fw", "p", "d", "fd", "fs", "fp", "w", "fc", "elf", "fi", "m", "F", "sf", "h", "cf"], "img": ["imgur", "tmp", "pic", " im", "jpg", "org", "aj", "shr", "src", "amp", "medium", "html", "md", "fb", "raw", "aug", "images", "orm", "image", "now", "jp", "Image", "inf", "picture", "im", "png", "imag", "uf", "mb", "impl", "dm", "fm", "util", "anim", "ref", "obj", "conv", "og", "small", "fig", "buf", "url", "gif", "mp", "tif", "gb", "it", "j", "gm", "m", "h", "good", "window"], "whichcase": ["whocase", " whichstring", "whostring", "whosetest", "whotest", " whichmatch", "howchar", "whosepath", "whetherrule", "wheretest", "whatspace", "whichrule", "whichcatch", "howtest", "whichspace", "whatmatch", "whatrule", "whoCase", "howrule", "whoseCase", "whethercatch", "whichpath", "whatCase", "whopath", " whichpath", "whichCase", " whichspace", " whichrule", "whichtest", "whattest", "howcase", "whichmatch", "howspace", " whichtest", "whethercase", "whatcase", "whorule", "wherecase", "whereCase", "whatstring", " whichchar", "whatchar", "whethertest", "whichchar", "whererule", "howCase", "whatcatch", "howmatch", "wherematch", "wherecatch", " whichCase", "whosematch", "whichstring", "howstring", "whosecase"], "lastDigit": [" lastDigita", "lastDbit", "lastPosit", "lastHourita", "lastDigbit", "lastdigit", "maxDigbit", "maxdigit", "firstdiguster", "firstdigbit", "firstdigiter", "lastDiguster", "firstdigi", "firstdigit", "firstDigot", "maxdigbit", "firstDiguster", "lastDiget", "firstDigiter", "lastDigot", "lastdiguster", "lastPosbit", "lastdigiter", " lastDigbit", "lastDigi", "lastDiter", "firstdigot", "lastdigot", "firstDigit", " lastDigot", "lastDet", "lastDoublebit", "lastValit", "lastDit", "firstDigbit", "lastPositer", "lastHourit", " lastdigit", "maxdigiter", "lastDoubleit", "lastHourot", "lastdigita", "lastDoublei", "lastValbit", "lastPosot", "maxdigot", " lastdigiter", "lastdigbit", "lastHourbit", "firstDigi", "lastdiget", "lastDigita", " lastDigiter", " lastDiget", "lastDoubleuster", "maxDigiter", "lastdigi", "lastPosuster", " lastdiget", "lastValet", " lastdigbit", "lastPosi", "maxDigot", "lastDigiter", "maxDigit", "lastValiter"], "sorted": ["unsorted", "Sorted", "insort", "sorting", "unsorter", "Sort", "isorting", "sorter", "sort", "Sorter", "Sorting", " sort", "unsorting", "unsort", "insorting", "insorted", " sorter", " sorting", "isorter", "isort", "insorter", "isorted"], "temp": [" temperature", "tem", "level", "t", "tmp", "v", "buffer", "Temp", " total", " v", " w", "base", "test", "porary", " t", " temporary", "stem", "orig", "mp", "local", "w", "pre", "emp", "tim", "m", "fake", " tmp", "txt"], "tempp": ["compl", "comple", "compp", "temple", "typle", "timpps", "typl", "typp", "tempps", "timpp", "compps", "typps", "templ", "timple", "timpl"]}}
{"id1": "16820041", "id2": "20588811", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "label": 0, "substitutes": {"encodePassword": ["enccodePass", "enodePass", "enodepassword", "enccodePassword", "enodePassword", "enotePassword", "encodePass", "enotepassword", "enotePass", "encodedPass", "encodedpassword", "encodepassword", "enccodepassword"], "_originalPassword": ["_modifiedString", " _modifiedString", "_OriginalToken", "_OriginalText", "_modifiedWord", " _OriginalUser", "_modifiedPassword", "_modifiedText", "_encryptedUser", " _modifiedPassword", " _OriginalString", "_encryptedToken", " _originalToken", "_encryptedPassword", "_originalUser", "_encryptedString", " _modifiedText", " _modifiedWord", "_OriginalPassword", "_originalText", " _originalString", "_OriginalUser", "_modifiedToken", " _originalUser", " _OriginalToken", "_encryptedWord", "_originalWord", "_OriginalString", "_OriginalWord", "_modifiedUser", " _OriginalPassword", " _originalWord", " _originalText", "_originalString", "_originalToken", "_encryptedText"], "md": ["pm", " Md", "bd", "MD", "managed", " mo", "dh", "det", "cd", "dr", "ng", "sd", "sm", "mand", "mt", "ind", "mod", "add", "dd", "hd", "mc", "dig", "sha", "cmd", "ds", "df", "mk", " mc", "mb", "dm", "mo", "nd", "magic", "de", "pd", "nt", "metadata", "material", "grad", "mg", "mp", "d", "ma", "der", "di", "ld", "mn", "od", "def", "m", "red", "mm", " m", "ms"], "encodedPassword": ["encryptedString", "encatedConnection", "acodedpassword", "encressedPassword", "encodedSecret", "encryptedpassword", "encryptedText", "acratedpassword", "EncodedUser", "encryptedSecret", "encodedEmail", "encodedString", "encoderPassword", "encachedPassword", "EncodedText", "EncodingText", "EncodingPassword", "encratedPassword", "ecryptedPassword", "encodedUser", "enccodedSecret", "encodingEmail", "encryptedPassword", "acratedPassword", "encachedString", "enccodedpassword", "encatedPassword", "encachedSecret", "encodedText", "EncodedEmail", "EncodedPassword", "encatedpassword", "ecodedPassword", "ecryptedString", "ecryptedSecret", "enccodedString", "encodedpassword", "encodingText", "encoderEmail", "encressedConnection", "EncodingEmail", "encratedpassword", "encodingPassword", "ecodedpassword", "encratedConnection", "ecryptedpassword", "encachedpassword", "encryptedEmail", "encoderUser", "encodingUser", "enccodedPassword", "ecodedSecret", "encressedpassword", "acodedConnection", "encoderText", "encryptedUser", "ecodedString", "EncodingUser", "acratedConnection", "encodedConnection", "acodedPassword"]}}
{"id1": "20995534", "id2": "22625683", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesfromclasspath", "loadPropertiesFromFilePath", "loadPropertiesfromclassname", "loadPropertiesFromFileloader", "loadPropertiesfromClasspath", "loadPropertiesfromClassPath", "loadPropertiesFromClassloader", "loadPropertiesfromClassloader", "loadPropertiesfromClassname", "loadPropertiesfromclassPath", "loadPropertiesFromclassloader", "loadPropertiesFromclasspath", "loadPropertiesfromclassloader", "loadPropertiesFromclassPath", "loadPropertiesFromClassname", "loadPropertiesFromFilename", "loadPropertiesFromclassname", "loadPropertiesFromFilepath", "loadPropertiesFromClassPath"], "path": ["text", "location", "type", "PATH", "data", "str", "base", "mount", "prop", "full", "log", "file", "test", "ath", "prefix", "hex", "pt", "dir", "string", "transform", "pattern", "item", "program", "policy", "Path", "chain", "name", "format", "root", "p", "directory", "template", "module", "w", "context", "entry", "config", "empty", "filename", "resource", "xml", "zip", "key", "txt"], "locations": [" locATION", " locATIONS", "Locates", "LOCators", "locates", "LOCates", " locifications", "locATION", "localATION", "Locations", "locators", "equations", "LOCifications", "plations", " lococations", "LocATION", "Lococations", " locates", "LOCATIONS", "localations", "plates", "localates", " locators", "lococations", "LOCocations", "localifications", "equators", "plocations", "equifications", "locifications", "Locifications", "equATIONS", "locATIONS", "plATIONS", "LOCations", "Locators"], "props": ["privperties", "propports", "prodates", "pegs", "propgs", "pebs", "Prodates", "Properties", "Probs", "rops", "Proports", "prors", " prors", "propperties", " properties", "roperties", "progs", "pregs", "Prors", "preps", "robs", "peperties", " prodates", "proports", "rogs", "properties", "privrs", "probs", "preports", "Progs", "preperties", "Props", "propps", "peps", "privdates", "privps"], "url": ["dl", "location", "org", "rl", "nl", "mount", "str", "html", "user", "server", "log", "file", "el", "loc", "l", "gl", "web", "uri", "string", "r", "pattern", "browser", "ls", "mb", "ob", "mail", "ref", "sl", "address", "name", "term", "bel", "ur", "f", "http", "element", "row", "ll", "link", "rel", "URL", "char", "config", "resource", "xml", "Url", "page", "key"], "in": ["io", "mat", "reader", "bin", "read", "din", "mr", "stream", "data", "inc", "isin", "ind", "mi", "file", "en", "inner", "ln", "body", "vin", "mc", "out", "as", "is", "input", "In", "on", "gin", "media", "ma", "init", "info", "IN", "mn", "con", "cn", "sample", "cm", "sql", "from", "sum", "ins", "inn", "cin", "i", "source", "and"]}}
{"id1": "2324868", "id2": "6171406", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"actionPerformed": ["actionExecform", "actionPerform", " actionPeruted", "actionExecuted", " actionTransform", " actionOccformed", " actionExecformed", " actionPerform", " actionExecuted", "actionPeruted", " actionExecform", " actionPerceived", "actionExecceived", " actionTransuted", " actionOccform", " actionOccceived", " actionOccuted", " actionExecceived", " actionTransformed", " actionTransceived", "actionPerceived", "actionExecformed"], "e": ["t", "v", "ev", "te", "or", "se", "es", "ef", "re", "ce", "Event", " event", "b", "ie", "cb", "a", "er", "n", "ec", "o", "event", "w", "ea", "E", "ee", "m", "events", "ed"], "delim": ["drimm", "dlif", "separif", "dlimeter", "drib", "delif", "deliter", " deliter", "Delib", "Delimm", "separim", "separiter", "Delim", "drim", "dliter", "delimeter", "dram", "Delam", " delimm", "delam", " delib", " delif", "delimm", "dlim", "separimeter", "delib", " delimeter", " delam"], "r": ["c", "fr", "R", "vr", "reader", "rd", "rg", "sr", "dr", "rl", "re", "mr", "rx", "nr", "usr", "lr", "pr", "l", "tr", "hr", "res", "br", "rb", "rc", "rar", "er", "n", "ur", "rate", "p", "d", "rt", "rs", "w", "rw", "it", "m", "rr", "cr", "rn", "kr"], "line": ["text", "le", "detail", "lin", "inline", "range", "point", "run", "nl", "stream", "base", "user", "comment", "log", "file", "ode", "LINE", "liner", "raw", "l", "ln", "cell", "Line", "lo", "eline", "string", "normal", "stroke", "out", "ice", "ole", "check", "mail", "chain", "ine", "ste", "handle", "online", "pass", "frame", "row", "record", "link", "lines", "block", "sample", "sequence", "entry", "node", "word", "page"], "url": ["lb", "dl", "org", "blog", "ul", "build", "rl", "nl", "str", "base", "log", "loc", "l", "web", "gl", "uri", "https", "client", "ssl", "cert", "browser", "ls", "open", "ref", "sl", "bel", "ur", "f", "http", "gb", "api", "net", "hub", "hl", "ll", "link", "rel", "abs", "ret", "URL", "addr", "Url"], "conn": ["sync", "c", "ct", "dl", "cl", "org", "close", "ann", "write", "enc", "ctx", "inv", "nl", "connection", "Conn", "loc", "ait", "jp", "comm", "ln", "secure", "https", "pas", "cp", "cmd", "client", "ssl", "cert", "nec", "cb", "res", "open", "obj", "ws", "nt", "conv", "connect", "nw", "n", "resp", "cur", "net", "con", "Connection", "cn", "fin", "ch", "rel", "yn", "dial", "canon", "syn", "socket", "addr", "ctrl", "rn", "nc", "ns", "db"], "wr": ["RW", "fr", "vr", "write", "wb", "dr", "ev", "wire", "spr", "mr", "pipe", "mt", "wl", "pr", "ln", "rex", "fn", "tw", "fw", "rew", "ws", "nw", "iw", "wi", "resp", "writ", "wn", "sw", "Writer", "ell", "wp", "vet", "wa", "kl", "wer", "rw", "wx", "w", "we", "writers", "wy", "wt", "WR", "wk", "Wr", "writer", "wm", "rn", "wrote", "tn", "kr", "mg"], "tokens": ["Toksers", " tokENS", "toksets", "stokets", "tikens", "tikents", "todkens", "tOKeds", "stodonds", " tokents", "todonds", "tokskens", "Tokwords", "tokswords", "todENS", "tikeds", " tOKens", "tokwords", "tokonds", "tookens", "toksonds", "Tokens", "tokents", "tokeds", "Tokets", "toksers", "todeds", "todets", "todents", "takawords", "tokENS", "tokets", "tocwords", "stokkens", "tookonds", " tOKeds", " tOKents", "stodets", "stodkens", "tocets", "toksens", "todens", "tokers", "Tokswords", "Toksets", "tikENS", "takaers", "takaets", "Toksens", "tocers", " tOKENS", "tokkens", "tOKents", "stodens", "stokens", "Tokers", "tOKENS", "tocens", "stokonds", "takaens", "tOKens", " tokeds", "tookets", "tookkens"], "in": ["io", "reader", "bin", "read", "din", " din", "inc", "rin", "ind", "en", "ill", "inner", "l", "inf", "body", "iter", "mc", "out", "is", "input", "err", "irm", "In", "on", "gin", "ma", "all", "win", "ini", "IN", "mn", "con", "it", "from", "ar", "ins", "null", "inn", "cin", "i", "mm", "ic"]}}
{"id1": "22479286", "id2": "14691829", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"md5": ["MD4", "MD2", " md3", " MD2", " MD3", " MD4", "MD5", "MD3", " md4", " md2", " MD5", "md3", "md2", "md4"], "plainText": ["plainString", "richString", "ainDelete", "plainTrans", "positionString", "ainPrint", " plainDelete", "plainTEXT", "mainString", "fulltext", "longString", "flatForm", "mainTEXT", "externalText", "plainTerm", " plainTrans", "plainSync", "plainDelete", " plainTEXT", "batText", "longTEXT", " plainMessage", "fullText", "flatMessage", "alttext", "aintext", "richText", "ainString", "positionTEXT", "richTEXT", "batString", "flatText", "maintext", "altString", " plainTerm", "batSync", "flatTEXT", "fullString", "richPrint", "plainForm", "ainText", "altText", "externalTEXT", "externalDelete", "altPrint", " plainString", "positionText", "longPrint", "plainPrint", " plaintext", " plainForm", "ainTerm", "initialText", "plaintext", "ainMessage", "plainMessage", "ainTEXT", "batTerm", " plainSync", "altTEXT", "externalString", "longText", "initialtext", "ainForm", "ainTrans", "initialTrans", "ainSync", "fullPrint", "mainText", "positiontext", "initialString"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "dr", "ng", "sd", "down", "sm", "mand", "ind", "mt", "mod", "add", "dd", "hd", "dir", "mc", "cmd", "df", "mk", "mb", "dm", "mac", "de", "pd", "nt", " MD", "grad", "mp", "d", "der", "di", "ld", "man", "mn", "od", "desc", "m", "red", "h", "mm", "ad", "mg", "ms"], "digest": ["candute", "digests", "digse", "compidate", " digEST", "mdest", "presentest", "presentute", "Digests", "digute", " digse", "defse", "compum", "Digity", "mdse", "presentested", "digity", "Digum", "compest", "candest", "defested", " digested", "Digute", " digity", " digests", "candum", "compute", "Digidate", "presentEST", "digEST", "digested", "DigEST", "digidate", " digute", "mdEST", "presentity", "candidate", "defest", "defEST", "Digest", "presentests", "Digested", "mdested", "digum"], "hexString": [" Hexstring", "exSingle", "rexBuffer", " hexstring", "hexText", "hexArray", " HexString", " hexSingle", "exString", " HexBuffer", " hexArray", "rexString", " hexText", "rexSingle", "hexBuffer", "hexstring", "hexSingle", "expString", "exBuffer", " HexText", "rexArray", "expText", "charBuffer", "charText", "charString", "charArray", " hexBuffer", "exText", "exArray", "expstring", "expBuffer"], "i": ["ip", "c", "li", "y", "io", "v", "bi", "in", "ii", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "iu", "mi", "ski", "batch", "b", "gu", "gi", "uri", "im", "q", "hi", "x", "is", "ti", "ie", "index", "ci", "err", "pi", "chain", "ji", "conv", "a", "iq", "n", "me", "qi", "si", "init", "ix", "di", "info", "it", "yi", "sim", "j", "ex", "my", "\u0438", "m", "z", "ai", "to", "g", "ic", "set"]}}
{"id1": "12097948", "id2": "18613870", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"systemID": ["SystemIDs", "privateName", "SystemId", "systemVD", "privateID", " systemName", "SystemID", "privateVD", "systemId", "sysId", "systemName", " systemIDs", "sysID", "privateId", " systemVD", "SystemName", "sysIDs", "sysVD", "systemIDs", " systemId", "sysName"], "id": ["ip", "rid", "mid", "pid", "create", "in", "wire", "uid", "part", "data", "str", "bind", "md", "iden", "base", "test", "post", "hd", "uri", "form", "ident", "q", "sid", "aid", "shape", "hash", "path", "mask", "no", "edit", "res", "ids", "end", "ref", "name", "ide", "ID", "hide", "layout", "p", "f", "d", "description", "init", "delete", "json", "query", "one", "internal", "it", "link", "message", "oid", "null", "gd", "show", "bid", "db", "i", "kid", "source", "key", "Id", "def"], "loader": ["lp", "where", "cl", "framework", "reader", "location", "manager", "cdn", "rl", "acl", "nl", "user", "layer", "Loader", "pool", "lr", "l", "language", "older", "parser", "loading", "library", "kernel", "er", "builder", "pkg", "load", "loads", "qualified", "loaded", "finder", "module", "container", "hl", "context", "label", "handler", "owner", "lc", "system", "class"], "url": ["lb", "ml", "dl", "location", "org", "ul", "or", "rl", "nl", "mount", "str", "html", "user", "el", "file", "loc", "lr", "l", "norm", "web", "uri", "il", "r", "ssl", "impl", "browser", "mb", "ls", "path", "util", "job", "mail", "ref", "sl", "address", "name", "bel", "ur", "builder", "f", "http", "load", "ll", "link", "rel", "abs", "ret", "URL", "tool", "resource", "xml", "Url"], "inStream": ["INView", "intSocket", " inSteam", "Instream", "inSocket", " inFile", "INStream", "InStream", "inSteam", "inBlock", " inView", "onSteam", "InFile", "innSocket", "onStream", "innBlock", " instream", "intBlock", "INstream", "onView", "INSteam", "inputStream", "innSteam", "instream", "intSteam", "intStream", " inSocket", "inputFile", "inputstream", "onstream", " inBlock", "inFile", "innStream", "inputSteam", "InSteam", "inView"], "constraints": ["constains", "constats", "conStrats", "costains", "constsaint", "costaints", "constrats", "constaint", "costrats", "constsaints", "costaint", "constaints", "constrains", "constsains", "conStrains", "conStraint", "conStraints", "costraint", "constraint", "costraints", "costats", "constsats", "costrains"]}}
{"id1": "755203", "id2": "11952735", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "693636", "id2": "1586662", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"createEmptyCart": ["createZeroOrder", "createEmptyProduct", " createNewTransaction", "createEmptyOrder", "createNewTransaction", "createZeroProduct", " createEmptyOrder", "createThisOrder", " createEmptyTransaction", "createNewProduct", "createThisCart", " createNewProduct", "createNewCart", "createThisProduct", "createEmptyTransaction", "createZeroCart", " createNewCart", "createThisTransaction", " createEmptyProduct", "createNewOrder", "createZeroTransaction", " createNewOrder"], "SHOPPING_ID": ["SHOPPOTINGUID", "SHOPPTINGIDURL", "SHOPPIP_id", "SHOPPING_IDS", "SHOPPTING_VID", "SHOPPING_UID", "SHOPPIP_UID", "SHOPPINGIDUID", "SHOPPOTINGNUM", "SHOPPING_URL", "SHOPPOTINGIDs", "SHOPPINGVALUID", "SHOPPINGIdNAME", "SHOPPINGPID", "SHOPPTINGIDID", "SHOPPINGIdID", "SHOPPINGITIDs", "SHOPPINGIDNAME", "SHOPPTINGIDNAME", "SHOPPTING_NAME", "SHOPPINGIdVID", "SHOPPOT_IDs", "SHOPPING_VID", "SHOPPAP_ID", "SHOPPIP_ID", "SHOPPING_Id", "SHOPPINGITUID", "SHOPPAP_Id", "SHOPPINGPUID", "SHOPPINGIDVID", "SHOPPOT_UID", "SHOPPINGINGUID", "SHOPPINGINGIDs", "SHOPPOTINGID", "SHOPPTINGIDVID", "SHOPPINGINGId", "SHOPPINGINGIDS", "SHOPPAP_UID", "SHOPPINGVALid", "SHOPPING_NAME", "SHOPPTING_ID", "SHOPPINGITNUM", "SHOPPINGIDIDS", "SHOPPAP_IDS", "SHOPPINGITID", "SHOPPINGIdURL", "SHOPPING_IDs", "SHOPPINGINGNUM", "SHOPPINGPIDs", "SHOPPINGINGID", "SHOPPINGIDID", "SHOPPINGIDURL", "SHOPPINGPNUM", "SHOPPOT_ID", "SHOPPOT_NUM", "SHOPPING_NUM", "SHOPPTING_URL", "SHOPPING_id", "SHOPPINGIDId", "SHOPPINGVALID"], "con": ["c", "ct", "xc", "can", "conn", "ctx", "cont", "re", "cal", "Con", "connection", "po", "Conn", "col", "pen", " conn", "en", "pool", "const", "cf", "ln", "pg", "ain", "mc", "cp", "cc", "bon", "client", "gc", "cons", "CON", "open", "rc", "conv", "cover", "un", "ran", "co", "coll", "soc", "win", "conf", "cur", "cn", "ch", "bo", "cat", "pc", "fc", "ex", "dial", "com", "ctrl", "cos", "db", "ca", "nc", "connect", "ren"], "insert_cart": ["import_pot", "insertingart", "insertptcod", " insert2cod", "import___cart", "import___pt", " insert2quant", "import_controller", " insert_quant", "insert_Cart", " insert_cod", "insert2controller", "insert2pot", "insert_controller", "insertThearticle", "entry_cart", "insertPcontroller", "insert_pt", "insertPart", "insertPpt", "insertThecart", "entry_article", "import___controller", "insertingpt", "import_cart", "insertMemarticle", "insert_pot", "insert2cod", "insertTheart", " insert2art", "insert2Cart", "insert2quant", "import_art", "entryMemprogress", "entryMemarticle", "insertingstart", "insertPcart", "insertptquant", "insert_article", "insert2start", "insertptcart", "insert_quant", "insertptart", "insert___cart", "insertPTquant", "import_Cart", "insert2art", "insertMemprogress", "insertMemart", "insert2article", "entryMemcart", " insert_start", " insert_art", " insert2cart", "insertPTart", " insert_pt", "insert_start", "insert___art", "insert_art", "insert2progress", "insertMemcart", "insertPTcart", "import___art", "entry_art", "entryMemart", "insert___pt", "insert_progress", "insert2pt", "insertingcart", " insert2pt", "insert_cod", "insertPTcod", " insert2start", "insertTheprogress", "insert___controller", "import_pt", "insert2cart", "entry_progress"]}}
{"id1": "17716716", "id2": "1235538", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"plainToMD": [" stringAsmd", " stringToDM", " stringAsMD", " convertToMC", " stringFromDM", " stringFrommd", " stringTomd", " convertToDM", " convertAsDM", " stringToMD", " convertTomd", " convertAsMD", " stringToMC", " convertAsMC", " stringAsDM", " stringAsMC", " convertToMD", " stringFromMC", " convertAsmd", " stringFromMD"], "loggerCol": ["logiderCol", "logggerCol", "logiderColumn", "loggerColl", "badinatorCol", " loggerCOL", "logGERCOL", "badgerCl", "logggerCl", "badinatorCl", "logggerColl", "loginatorColl", "badinatorCOL", " logggerCOL", "loggerColumn", "loginatorCol", "loggeCOL", "logggerCOL", " logggerCol", "badinatorColl", "loggeCol", " loggerColumn", "loggeColl", "badgerColl", "loggerCOL", "logiderCOL", "badgerCol", "logGERCol", " logggerColumn", "loginatorCl", "loginatorCOL", "logggerColumn", "logGERColumn", "loggerCl", "loggeCl", "badgerCOL"], "input": ["text", " inputs", "example", "request", "buffer", "in", "active", "str", "data", "base", "this", "raw", "file", "document", "image", "prefix", "result", "string", "q", "out", "pattern", "hash", " Input", "up", "command", "Input", "url", "hello", "value", "it", "context", "output", "from", "subject", "char", "initial", "config", "background", "source", "form"], "byteHash": ["ByteLength", "binaryHash", "byteshash", " byteMap", "binaryhash", "ByteHas", "Bytehash", "bytesHas", "binaryHas", "ueHash", "ueTr", "ByteMap", "ByteHash", " byteHas", "byteHas", " byteTr", "bytehash", "uehash", "ByteTr", "byteTr", " bytehash", "ueLength", "byteMap", "bytesHash", " byteLength", "bytesMap", "byteLength"], "md": ["pm", " Md", "bd", "MD", "ct", "det", "cd", "med", "gr", "dr", "ng", "sd", "sm", "sam", "mt", "ind", "mod", "add", "dd", "hd", "mc", "dig", "cmd", "ds", "df", "mk", " mc", "mb", "dm", "mo", "nd", "mac", "ms", "cond", "de", "pd", "material", " MD", "grad", "mg", "mp", "d", "comp", "der", "di", "ld", "rm", "mn", "od", "hash", "met", "gm", "m", "doc", "msg", "red", "mm", "ded", "def"], "md5result": ["MD5response", "md45comment", "md65Result", "MD2comment", "md5Result", "md7string", "md5response", "md3result", " md5Result", "md8Result", "md8proc", "MD5result", "md64comment", "md5results", "md5comment", "md7result", "md5message", "MD2string", "md2result", "md3string", "md8result", "md2response", "md3message", "md7results", "md45response", "md65result", "md3proc", " md5message", " md5proc", "md8message", "md64response", " md8proc", "md3results", "MD5results", " md8Result", "md2comment", "md2Result", "MD2result", "md5proc", "MD5Result", "md45result", "md2results", "md65message", " md8result", "md3Result", "md45results", "MD2results", "md2string", "md7Result", " md8message", "md64results", "MD5comment", "md5string", "MD5string", "MD2Result", "md64result", "MD2response", "md65proc"], "i": ["ip", "c", "li", "y", "io", "v", "span", "bi", "in", "ii", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "mi", "l", "b", "gu", "gi", "uri", "im", "iter", "q", "cli", "x", "is", "ti", "ie", "index", "ci", "pi", "ji", "a", "n", "me", "qi", "si", "init", "ix", "di", "ims", "ei", "o", "it", "sim", "j", "my", "\u0438", "m", "z", "ai", "fi", "us", "ic"]}}
{"id1": "3945236", "id2": "11562165", "code1": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"hash": [" Hash", " challenge", " crypt", "write", " sum", "run", " combine", " check", " inline", " hex", "Hash", "print", " calc", "update", " hashing", "sign", " clear", " digest", " insert", " equals", " password", " h", " fingerprint", " hashes", " push", " fill", " merge"], "plainTexts": ["plainMessls", "fullText_", "plainText_", "plaintextes", "plainObjectls", "plaintext_", " plainTextic", "plainTEXTls", "plainContext_", " plainTextls", " plainMessic", "plaintexts", "plainTextls", "plaintextls", "fullTextList", "plainTEXTs", "fullTEXTls", "plainTEXT_", "fullTEXT_", " plainMesses", "fullTEXTList", " plainMesss", "fullTexts", "plainTEXTList", "plainMesss", "plainContextls", " plainTextes", "plainObjectes", "plainObjectic", "fullTextls", "plainMessic", "plainTextic", "plainObjects", " plainMessls", "plaintextic", "plainTextes", "fullTEXTs", "plainTextList", "plainContexts", "plainContextList", "plainMesses", "plaintextList"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "wd", "sd", "sm", "mand", "mt", "ind", "mod", "dd", "hd", "dir", "mc", "del", "cmd", "deb", "df", "mk", "mb", "nd", "dm", "mo", "lf", "amd", "de", "pd", "grad", "me", "mp", "pkg", "d", "der", "di", "ld", "mn", "od", "cm", "desc", "def", "m", "red", "ad", "mm", "db", "mg", "ms"], "plainText": ["plainString", "plainNet", "plainTEXT", "publictext", "singleText", "ainNet", " plainTEXT", "publicTEXT", "aintext", "ainString", "binaryNet", "ainText", "binarytext", " plainString", "publicText", "binaryString", " plaintext", "plaintext", "singleTEXT", "binaryText", "singletext", " plainNet"], "b": ["sb", "c", "B", "bd", "binary", "v", "bin", "buffer", "wb", "bh", "ba", "bi", "emb", "bs", "buff", "bf", "fb", "bis", "bc", "bt", "ib", "ab", "mb", "eb", "cb", "ob", "br", "bl", "rb", "a", " B", "f", "d", "be", "gb", " eb", "nb", "bo", "bytes", "m", "s", "bu", "db", "bb"], "i": ["ip", "t", "li", "y", "io", "v", "bi", "status", "ii", "phi", "point", "multi", "I", "xi", "u", "id", "ui", "ind", "mi", "iu", "oi", "abi", "e", "gi", "uri", "iter", "clip", "q", "hi", "x", "ie", "ti", "is", "ci", "pi", "ij", "ji", "conv", "name", "chain", "iat", "me", "p", "ia", "f", "qi", "si", "ix", "init", "di", "info", "o", "one", "it", "j", "pp", "m", "angle", "ai", "zi", "ic", "source"], "buf": ["agg", "sb", "bg", "img", "np", "uv", "cv", "tmp", "Buffer", "buffer", "bound", "wb", "bh", "emb", "printf", "bed", "etc", "buff", "bf", "Buff", "fb", "log", "batch", "func", "loc", "norm", "bc", "brace", "result", "vec", "aux", "bar", "alph", "cmd", "proc", "queue", "uf", "eb", "cb", "ob", "br", "err", "rb", "conv", "bag", "mem", "grad", "pkg", "plug", "cur", "pb", "nb", "rw", "bp", "bo", "block", "runner", "def", "nm", "db", "mu", "msg", "bu", "bridge", "bn", "bb"], "offset": ["et", "scroll", "coord", "location", "zone", "acet", "bound", "padding", "instance", "off", "inline", "oot", "align", "point", "unk", "pad", "ET", "stop", "length", "auto", "total", "attribute", "pos", "batch", "loc", "left", "oo", "original", "Offset", "trace", "OFF", "at", "origin", "client", "pointer", "mask", "index", "zero", "shift", "no", "open", "alias", "slice", "address", "loop", "start", "position", "layout", "atomic", "offs", "slot", "o", "row", "sequence", "seek", "output", "reset", "store", "to", "remote", "error", "key", "set", "outer", "iterator"], "str": ["c", "text", "status", "enc", "Str", "arr", "data", "div", "print", "string", "r", "out", "res", "br", "err", "obj", "name", "n", "p", "cur", "STR", "st", "msg", " st", "s", "sp", "set"]}}
{"id1": "8667872", "id2": "8330057", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"hash": [" Hash", " text", " sum", "id", "Hash", "print", " body", "dump", "hex", " key", "string", "update", " hashing", "sign", " id", " equals", " message", " identity", " h", " fingerprint", " address", "sum", " code", "code", "h", " signature", " mac"], "data": ["content", "text", "any", "buffer", "secret", "serial", "padding", "DATA", "html", "space", "ata", "this", "raw", "batch", "image", "result", "action", "string", "input", "name", "dat", "format", "foo", "json", "hello", "value", "info", "size", "sample", "sequence", "message", "output", "area", "bytes", "mu", "what"], "digest": ["hashge", "deEST", "digse", "deest", " digEST", "modist", "mdest", "Digit", " digester", "hashest", "modest", " digse", "Digge", "cdment", "mdse", "Digment", "digester", "hashit", "cdse", "mdester", " digge", " digested", "mdge", "cdested", "hashEST", "cdest", "digge", "digEST", "mdist", "digested", "DigEST", "equge", "equit", "Digist", "mdEST", "modge", "equEST", "equest", "dese", "modester", " digment", " digist", "Digest", "digist", "Digester", "digment", "digit", "Digested", "deist", "Digse"]}}
{"id1": "4852691", "id2": "4531653", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": [" Hash", " text", " sum", "run", " check", "id", "Hash", "print", "dump", "hex", " encoding", " key", "string", "update", " hashing", "sign", " equals", " message", " h", " fingerprint", "sum", "code", " salt", "h", " signature", " mac"], "data": ["content", "text", "any", "buffer", "secret", "state", "padding", "DATA", "space", "ata", "this", "raw", "batch", "image", "dump", "result", "action", "string", "input", "name", "dat", "command", "password", "d", "json", "hello", "value", "info", "sample", "sequence", "message", "output", "area", "bytes", "what", "form"], "digest": ["duist", "deEST", " hexests", "digests", "digse", "deest", " digEST", "redist", "mdest", " digger", "duest", " digester", "signested", "Digests", "digute", " hexute", " digse", "redger", "signEST", "redose", "mdse", "digester", " hexested", "mdester", "duger", " digested", " digose", "Digute", " digests", "digEST", "digested", "DigEST", "digger", "redest", " digute", "Digist", "signse", "mdEST", "digose", "duose", "dese", " digist", "Digest", "digist", "Digester", "Digested", "signest", "mdested", " hexest", "deist", "Digse"]}}
{"id1": "13666876", "id2": "6188784", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformOnefile", "TransformSimplePage", "TransformSimpleModel", "processSingleSourceFile", "transformSimpleRecord", "transformsinglefile", "processSingleFiles", "transformMultiPage", "transformMultifile", "transformsingleFiles", "transformSinglePage", "transformMultiRecord", "transformMultiFiles", "processsinglefile", "processsingleFile", "transformsingleSourceFile", "transformOneFile", "processSingleFile", "transformOneFiles", "TransformSimpleFile", "TransformSingleRecord", "TransformSingleFile", "transformSingleModel", "TransformSimpleRecord", "TransformSingleModel", "transformOneSourceFile", "transformSimplePage", "transformsingleFile", "transformsinglePage", "transformsingleRecord", "transformMultiSourceFile", "transformsingleModel", "transformSingleSourceFile", "transformSingleFiles", "transformSimpleFile", "transformSingleRecord", "processsingleFiles", "processsingleSourceFile", "transformMultiModel", "processSinglefile", "transformSinglefile", "transformMultiFile", "transformSimpleModel", "TransformSinglePage"], "xed": [" xEd", "passed", "uxed", "txed", "exed", "exED", " xied", "passED", "xred", "wxEd", " xED", "xied", "pxeds", "xED", "uxied", "wxented", "xented", "rxED", "exeds", "rxeds", "txeds", " xred", "wxred", "passred", "wxED", "wxied", "Xeded", "rxed", " xented", "txED", "uxented", "xeds", "wxed", "Xed", "Xer", "xer", "exeded", "pxED", "xeded", "uxED", "xEd", "Xeds", "txer", "passEd", "XED", "rxer", "pxeded", "pxed"], "node": ["stage", "object", "day", "create", "range", "scene", "view", "station", "tree", "remote", "ode", "image", "component", "post", "line", "Node", "our", "index", "no", "right", "job", "entity", "de", "map", "name", "n", "hand", "note", "feature", "array", "load", "channel", "directory", "row", "edge", "one", "event", "link", "process", "entry", "resource", "parent", "seed", "word", "set", "and"], "dob": ["diobb", "drob", "dobar", "Dab", " dod", "diab", "diod", " dobb", "drab", "Dob", " dab", "adobar", "dab", "adab", "drod", " doy", "dobb", "Dobar", "Doy", "diob", "dod", "adoy", "doy", "adob", " dobar", "drobb"], "mySrc": ["mySRC", "myInsRC", "mySource", " mySRC", "mySsrc", "myInsrc", "myInsfc", " mySfc", " mySsrc", "MySrc", "mySelources", "myDesRC", "myAsRC", "MySources", "mySelrc", "mySingfc", "mySourceource", "mySfc", "MySource", "mySingrc", "myDesources", "myDessrc", "myDesrc", "mySources", "mySourceRC", "myAsrc", "myAsource", "mySingRC", "MySRC", "mySourcesrc", "myInssrc", "mySingsrc", "mySelRC", "myAssrc", "mySourcerc", "mySelsrc", "MySsrc"], "mySrcF": ["myMourceO", "mySrcC", "mySourceV", "mySRCP", "mySsrcP", "mySsrcV", "myMourceF", "mySufV", "mySRCC", "mySrtF", "mySrtP", "mySsrcI", "mySrcP", "myMrcO", "mySourceF", "mySourceFP", "myMrcF", "mySrcFP", "myMourceFP", "mySufO", "myMourceV", "mySrcI", "mySrcV", "myMrcV", "mySourceO", "mySsrcFP", "mySrcO", "myMrcFP", "mySufF", "mySrtI", "mySsrcO", "mySrtC", "mySRCI", "mySRCF", "mySsrcF", "mySufFP", "mySsrcC"], "myOutF": ["myArtFL", "myOffFile", "myOutputDF", "myInFile", "myObjFs", " myOutC", "myArtF", "myOutDF", "myOutputF", "myInC", "MyInFs", "mysNetFL", "mysOutFL", "mysOutF", "myOutFL", "myArtL", "mysOutW", " myOutE", "myoutV", "myOffF", "myOutputE", "myNetF", "myNetL", "myOutW", "myInL", "myOffE", "myNetFL", "myOutputL", " myOutFile", "myOutputC", "myoutL", " myoutC", "MyInF", "MyOutFile", " myOutL", "myoutF", "myOutputFs", "myObjV", "myOutFile", "myInF", " myNetE", "myCoL", "myCoFL", "mysNetL", "MyOutFs", "myNetW", "myNetDF", "myNetFile", "MyInFile", " myoutF", "mysNetW", "myoutC", "MyOutV", "mysOutL", " myNetFile", "myCoF", "myOffDF", "myOutputV", "mysNetF", "myOutputFile", "myOutFs", " myNetF", "myOutV", "myCoW", "myInFs", "myObjFile", "myInV", "myOutC", "myObjF", "myNetE", "myOutL", "MyInV", "myArtW", " myOutV", " myOutDF", "MyOutF", "myOutE", " myoutV", " myNetDF", " myoutL"], "co": ["c", "ico", "coord", "xc", "cv", "io", "can", " Co", "cl", "copy", "oc", "cal", "po", "col", "ce", "go", "loc", "cs", "ho", "so", "cho", "ro", "flo", "ck", "lo", "cod", "cc", "roc", "ror", "cop", "mo", "wo", "gc", "no", "ci", "cache", "fo", "cu", "ace", "obj", "cover", "coll", "soc", "aco", "Co", "o", "con", "cm", "CO", "fc", "yes", "com", "ctrl", "cos", "nc", "ca", "ko", "lc"], "x3dvFile": ["x3dbfile", "x3cdVFile", "x3dVPath", "x3davPath", "x3dbFilename", "x3dvFilename", "x3dtString", "x3dtFile", "x3pdvString", "x3dvsPath", "x3pdbfile", "x3dVFilename", "x3dVString", "x3dVFile", "x3dtFilename", "x3dbFile", "x3pdbFilename", "x3cdvPath", "x3dvsFilename", "x3dvString", "x3dvPath", "x3dbString", "x3cdvFile", "x3dvfile", "x3dtfile", "x3cdvFilename", "x3cdVFilename", "x3pdbString", "x3pdvfile", "x3dvsFile", "x3cdVPath", "x3pdvFilename", "x3dVfile", "x3pdvFile", "x3davFilename", "x3davFile", "x3pdbFile"], "fis": ["fileiss", "frie", "fileiz", "fiss", " fiz", "frisi", "fires", "fliss", "bis", " fires", "bisi", " fiss", "fisi", "fileis", " fisi", "fiz", "fileires", "bie", "friss", "flires", " fie", "fie", "biss", "fliz", "flis", "fris"], "gzos": ["sslo", "zies", "zaos", "gzies", "gtoss", "go", "goss", "gtops", "zipnos", "ggoes", "zos", "ggops", "gaos", "gsoss", "gzo", "gzops", "gtnos", "ggies", "ziposs", "gzoes", "gties", "gtoes", "gsnos", "sslaos", "gsops", "ssloss", "zipos", "sslos", "zoss", "gzoss", "gos", "gznos", "gsos", "zops", "zo", "gtos", "zipops", "ggos", "zoes", "gzaos"], "buf": ["img", "cv", "Buffer", "buffer", "wb", "emb", "arr", "max", "buff", "font", "Buff", "fb", "raw", "batch", "b", "bus", "vec", "bar", "cmd", "uf", "cb", "br", "good", "ref", "rb", "conv", "aka", "bag", "mem", "orig", "var", "cast", "pkg", "seq", "cur", "cam", "block", "cap", "cat", "bytes", "tab", "mu", "box", "cf"], "ret": ["et", "ctr", "v", "ry", "re", "RET", "back", "ext", "mt", "test", "inter", "print", "Ret", "rets", "continue", "iter", "aux", "gt", "r", "out", "cmd", "cert", "tr", "res", "elt", "ref", "err", "obj", "nt", "att", "end", "ptr", "ft", "len", "rt", "val", " Ret", "arg", "deg", "pret", "red", "ter", "cont", "repl", "alt", "def"]}}
{"id1": "17083703", "id2": "20128728", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"savaRolePerm": ["sDeleteRoleProms", "sDeleteResourcePerm", "sDeleteRolePERms", "sDeleteResourcePerM", "sDeleteRolePerM", "sDeleteRoleProm", "sDeleteRolePerms", "sDeleteResourceProM", "sDeleteRolePerm", "sDeleteRolePERm", "sDeleteRolePerperm", "sDeleteRoleProperm", "sDeleteResourcePerms", "sDeleteResourcePerperm", "sDeleteRolePERperm", "sDeleteResourceProperm", "sDeleteResourceProm", "sDeleteRoleProM", "sDeleteRolePERM", "sDeleteResourceProms"], "roleid": ["roleId", "roleoid", "relationId", "oleid", "oleoid", "roleids", "relationpid", " rolepid", "relationids", " roleoid", "resourceid", "oleinfo", "relationid", "roinfo", "roid", " roleId", "roname", "rooid", " rolename", " roleids", "rolepid", "resourcepid", "roleinfo", "resourceId", "rolename", "olename", "resourceids", " roleinfo"], "role_perm_collect": ["role_perm2Collect", "role_perm_draw", "role_perm_Collect", "role_perm_collection", "role_compl_collect", "role_permptdraw", "role_per_cont", "role_priv2coll", "role_priv2Collect", "role_per_coll", "role_permptcollect", "role_priv_collection", "role_compl_coll", "role_per_draw", "role_permptcont", "role_priv_Collect", "role_compl_ct", "role_perm_coll", "role_permptcoll", "role_perm_cont", "role_perm2collect", "role_perm2coll", "role_priv_coll", "role_priv2collection", "role_perm_ct", "role_priv2collect", "role_perm2collection", "role_per_collect", "role_priv_collect"], "cp": ["c", "ct", "priv", "tp", "ps", "px", "cd", "cfg", "ctx", " CP", "CP", "Conn", "core", "jp", "cs", "vp", "cc", "cmd", "proc", "cod", "cop", "mk", "cb", "pd", "rc", "ec", "mp", "p", "pkg", "wp", "fp", "con", "cn", "pc", "cm", "cap", "ch", "pp", "ctrl", "cr", "cmp", "cf", "lc"], "conn": ["sync", "dn", " ac", "t", "ctr", "org", "ann", "ctx", " cc", "comm", "ain", " con", "session", "cmd", "cert", "conv", "on", "conf", "con", "j", "act", "addr", "config", "g", "cf", "connect", " cx", "bind", "col", "ait", "trust", "ont", "cc", "out", "client", "gc", "open", "req", " cur", "wp", "gate", "local", "link", "die", "syn", "pg", "rn", "ca", "ct", "tp", "wd", "mt", "pas", "nt", "og", "resp", "p", "pkg", "cur", "mn", "yn", "cn", "sql", "dial", "gn", "call", "msg", "nc", "db", "c", "close", "enc", "cfg", "connection", "Conn", "ce", "pool", "dc", "jp", "dt", "ssl", "cb", "obj", "n", "mem", "handle", "co", "coll", "ch", "bo", "rel", "ns", "fn", "lang"], "rs": ["Rs", "ps", "sr", "rl", "re", "mr", "os", " ss", "cs", "ro", " res", "ds", "ls", "res", "ri", "rc", "RS", " ps", " ra", "ris", "rt", "rm", " cs", "s", "ts", "ns", " rc", " ls"], "pstmt": ["pstmd", "apStmb", "pconstmt", "prestmn", "pstdmb", "pstdmt", "Pstmt", "pctmd", "pstartmt", " pstatm", "pstmk", "pestMT", " prestmt", "pstatmk", "apstbl", " pstm", "pSTMT", "prestlt", "pstatecond", "prestmt", "pstatmn", "Pstmsg", "pstatemk", "postsql", "pstatcond", " pswemb", "pstbl", "pstymb", " pstemb", "pSTmt", " pstatmt", "pputcond", "pputmg", "pctMT", "pconstm", "pstart\t", " pStm", "pstatmb", "Pstmd", "pstartm", " pStmb", "Pstrs", "pstattr", "pstmsg", "pstatstat", "pstrmn", "PstatMT", " prestMT", " pswmt", "Pstlt", "pstdst", "pStst", "pstmn", " pStmt", "Pstatcond", " pswms", "pestm", "postmt", " psttr", "postm", "pctm", "Pstms", "Pstatrs", "pstatMT", "ptrysql", "pstat\t", "pswemb", " pststat", "pstatms", "pconstmb", "pStstat", "apStbl", "Pstat\t", "postmsg", "pstymt", "pstrrs", " pstmb", "pstremb", "pstatm", "Pstcond", "PstMT", "pputm", "pstms", "pstatem", "Pstatlt", "pputmk", "Pstmg", "pstrmt", "pstrmg", " pstMT", "pstm", "pstemb", "prest\t", "pStmt", "pstatemt", "postmd", "pstcond", "pstrmd", "pStbl", "pstyms", "Pstatmd", "pswmb", "pstatmg", "pswmt", "ptrymt", "Pstm", "pstrms", "pputrs", "pstrm", "pstst", " pstatmd", "apstmt", "pestmt", "apstmb", "pstatmt", "pst\t", "Pstatmt", "pstatst", "pSTtr", "ptrym", "Pstatsql", "apStmt", "postmn", " pstatmn", "pStm", "ptrymsg", "Pstatmsg", "pconststat", "pstatlt", "pstatrs", "Pstsql", "prestMT", " presttr", " pstmd", " pStstat", "pstMT", " prestmn", "pctms", " pswmb", "pstatmsg", "apstst", "Pstmk", "pstmb", "pstatmd", "pestms", "prestm", "presttr", "pstyemb", "Pstatm", "pstlt", "Pst\t", "pctmt", "pststat", "pstatbl", "Pstatmk", "pswms", "pstmg", " pstmn", "pstsql", "pstrmb", "pstartlt", "apStst", "Pstatms", " pstms", "pstatsql", "Pstatmg", "pstdbl", "psttr", "pputmt", "pStmb", "pSTmn", "pstrs"], "factory": [" facter", "tacter", "fictionary", "fFactory", "cfFactory", "Factory", "Facter", "Fictionary", " fictionary", "cfictionary", " fFactory", "foo", "Fade", "tade", "FFactory", "cfoo", "Foo", "tactory", "tFactory", "facter", " fade", "fade", "cfactory", " foo"], "op": [" act", " co", " oper", "oe", "operation", "Op", "oper", " operator", " ops", " opt", " ov", " ep", " Op", "ops", "p", " opp", "OP", "Operation", "o", " cop", " dop", " operate", " OP", " ip", " Operation", " pop", " operational", "iop"], "role_perm_ir": ["role_permmmi", "role_perm_et", "role_permobji", "role_perm_yr", "role_priv_ir", "role_perm_ier", "role_permobjir", "role_permmmir", "role_proc_iter", "role_proc_oi", "role_proc_ier", "role_permrenet", "role_perm_IR", "role_permmmoi", "role_priv_iter", "role_proc_yr", "role_perm_iter", "role_priv_i", "role_proc_i", "role_perm_oi", "role_priv_IR", "role_permrenier", "role_proc_ir", "role_permobjoi", "role_permmmyr", "role_perm_i", "role_permobjyr", "role_permreniter", "role_permrenir", "role_proc_et"], "rolePerm": [" rolePerp", "rolePerM", "rolePersmission", "roleParc", "olePerl", " roleParM", " rolePerM", "olePerperm", "roleParp", "rolePerg", " roleParm", "roleperm", "rolePERM", "oleParperm", "rolepermission", "rolePerperm", "oleParr", "roleElemn", "rolePersM", "rolePartperm", "olePerM", "roleElem", "rolePerr", "roleLikeg", "roleLikeM", "rolePERl", "rolePersm", "roleEleg", "rolePm", "rolePartg", "olePERg", "rolePERm", "oleParm", "olePermn", "roleParm", "rolePERg", "rolePermn", "rolePerl", "olePERl", "rolePartr", "rolePERperm", "roleLikem", "roleParr", "roleParg", "olePermission", "olePERM", "oleParg", "olePerr", " roleParc", " rolePerc", "rolePp", " roleParp", "rolePermission", "rolePERr", "rolePERmission", "roleLikemn", "roleperl", "rolePartm", "roleParperm", "olePerm", "rolePERmn", "roleEleM", "rolePERc", "rolePM", "rolePERp", "olePERmn", "rolePersl", "roleParM", "olePERmission", "rolePerp", "rolePc", "olePerg", "roleperM", "olePERm", "rolePerc"]}}
{"id1": "5125848", "id2": "18891988", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "label": 1, "substitutes": {"combineJs": ["combinateLink", "Combosejs", "ComboseJS", "CombineJs", "combineJS", "combinateJS", "combinatejs", "combinateJs", "CombineJS", "ComboseJs", "comboseJS", "combINEjs", "comboseJs", "combinejs", "combosejs", "combINELink", "ComboseLink", "comboseLink", "Combinejs", "combineLink", "combINEJS", "CombineLink", "combINEJs"], "base": ["buffer", "bound", "ase", "based", "re", "host", "data", "id", "server", " bases", "file", "bottom", "bas", "b", "prefix", " basis", "uri", "source", "origin", "address", " Base", "start", "root", "absolute", "relative", " based", "Base", "api", "template", "site", "local", "domain", "from", "reset", "bid", "page", "db"], "linkJs": ["linkTags", "inkScript", "linkJS", "inkLinks", "LinkJS", "linkjs", "Linkjs", "linkLinks", " linkJS", " linkjs", "LinkJs", "inkJS", " linkScript", "inkJs", "LinkTags", "inkTags", "linkedJS", "linkScript", " linkLinks", "linkedLinks", "inkjs", " linkTags", "linkedJs", "linkedScript"], "newFiles": [" newLinks", "newLinks", "newDocuments", "linkfiles", "newfiles", "linkLinks", "nextLinks", "nextDocuments", "nextfiles", " newfiles", "linkDocuments", "nextFiles", " newDocuments", "linkFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "manager", "dr", "lib", "md", "id", "auto", "file", "disk", "div", "loc", "mod", "temp", "dd", " directory", "sys", "out", "mk", "dm", "Dir", "DB", "ref", "created", "DIR", "tar", "root", "diff", "fd", "folder", "d", "pkg", "di", "fs", "directory", "module", " Dir", "lock", " d", "desc", "rel", "area", "ir", "local", "vol", "done", "doc", "addr", "zip", "good", "db", "def"], "name": [" rebuild", " dummy", " self", " db", " vm", " log", " info", " prefix", " manager", " b", " scanner", " browser", " loader", " res", " parser", " logger", " start", " karma", " msg", " names", " err", " cleaner", " report", " bar", " str", " foo", " filename", " tmp", " os"], "minDir": ["smallDir", "minPref", "minRel", "minuteDar", "MinNet", "minutePref", "miniTrans", "mindir", "skindir", "skinDir", "minTrans", "maindir", "minJar", " minJar", "minDb", " minPref", "smallNet", "minuteDir", "minDar", "minFile", " minTier", " minRel", "minTier", "sortDir", "sortRel", " minDar", " minFile", "thinJar", " minTrans", "smallDb", " minNet", "thinTier", "minLoc", "smallLoc", "mainDb", "skinDb", "minuteRel", "smalldir", "sortDar", "miniTier", "sortPref", "smallFile", "skinLoc", "minNet", "mainDir", "thinDir", "miniDir", "thinTrans", "MinFile", "miniJar", "mainLoc", "MinDir"], "combineFile": ["cominatefile", "cominateMessage", "coordINEFile", "coordINESet", "combinateFile", "combINEWriter", "comboseWriter", "combinSet", "combinerfile", "cominateFile", "comboseSet", "comineFile", "coordineFile", "comineMessage", "comboiceFile", "combINESet", "comboseFile", "coordineSet", "combinerFile", "cominefile", "combinerMessage", "combinefile", "combinFile", "combinateMessage", "coordinefile", "combosefile", "comineEmail", "combineMessage", "comboiceEmail", "combINEfile", "coordINEWriter", "coordineWriter", "comboiceMessage", "comboicefile", "coordINEfile", "combinateEmail", "combineEmail", "cominateEmail", "combinWriter", "combinatefile", "combinerEmail", "combinfile", "combineSet", "combINEFile"], "concatFile": ["comcFile", "concDir", "concatfile", "concapFiles", "concFile", "comcDir", "conatFile", "conatFiles", "concatFiles", "covertTable", "comcatDir", "conCatFilename", "convertfile", "convertFiles", "cocatFiles", "cocatTable", "concFilename", "concapfile", "conCatDir", "covertfile", "covertFile", "comcatFilename", "conatTable", "conatfile", "concatFilename", "comcFilename", "concapTable", "cocatfile", "convertTable", "concatDir", "covertFiles", "concapFile", "convertFilename", "convertFile", "conCatFile", "concatTable", "comcatFile", "cocatFile", "convertDir"], "combineWriter": ["declineFile", "declinateReader", "declinateWriter", "combineReader", "combinateFile", "declinateFile", "combinateWrite", "combenwriter", "combinateWriter", "combinewriter", "Combosewriter", "comboseWriter", "ComboseCounter", "comboseReader", "combenWrite", "combinatewriter", "declineReader", "declineWrite", "comboseFile", "comboseWrite", "declinateWrite", "ComboseWrite", "combieWriter", "CombineWrite", "combosewriter", "combieWrite", "combineCounter", "combinateCounter", "combieReader", "combinateReader", "combineWrite", "CombineCounter", "declineWriter", "combieFile", "CombineWriter", "combenCounter", "Combinewriter", "combenWriter", "ComboseWriter", "comboseCounter"], "concatWriter": ["concatWrite", "concatsReader", "cocatWriter", "conatReader", "conatFile", "coatWriter", "comvertWriter", "cocatReader", "cocatWrite", "comcatWrite", "comvertReader", "coatWrite", "conatWriter", "concatsWrite", "convertReader", "coatFile", "comcatReader", "convertWrite", "comvertFile", "coatReader", "comvertWrite", "concatReader", "concatsWriter", "conatWrite", "convertWriter", "convertFile", "comcatWriter", "comcatFile", "cocatFile", "concatsFile"], "fails": ["mails", " failed", "facocks", "ifails", "lalls", "facails", "frailed", "ifocks", "mailed", "lails", "falls", "failing", "malls", "frails", "fils", "mocks", "Fils", "lailing", "focks", "ifailed", " focks", "ifailing", "facailing", "facailed", "failed", "frailing", "Failing", "frils", "mailing", "Fails", "lailed", " falls", "Failed", " failing", "lils"], "link": ["embed", "c", "li", "follow", "close", "inline", "links", "log", "loc", "self", "l", "add", "mark", "relation", "ln", "linked", "child", "line", "check", "open", "address", "ink", "map", "script", "load", "match", "set", "display", "Link", "task", "node", "code", "share", "remote", "source", "skip", "push"], "path": ["text", "location", "kind", "src", "PATH", "data", "str", "id", "prop", "full", "file", "loc", "ath", "image", "join", "prefix", "hex", "route", "uri", "string", "pattern", "input", "alias", "ref", "Path", "format", "root", "p", "relative", "href", "match", "template", "entry", "style", "resource", "source", "key"], "url": ["li", "location", "request", "build", "ul", "host", "nl", "mount", "str", "id", "html", "this", "loc", "lr", "l", "gl", "web", "uri", "il", "string", "r", "browser", "ssl", "ls", "mail", "ref", "sl", "address", "ur", "get", "http", "href", "hl", "ll", "rel", "abs", "URL", "char", "null", "addr", "resource", "Url", "source"], "inputStream": ["InputTime", "InputSteam", "outputstream", " inputSet", "inputTime", "inSet", "inputStyle", "outputSteam", "inTime", " inputStyle", "Inputstream", " inputTime", "inStream", "instream", "inputSet", "InputStyle", "inputstream", " inputSteam", "InputStream", "inputSteam", "outputStyle", "InputSet", " inputstream"], "jsFile": ["javascriptName", "javascriptFilename", "jsTable", "cssPath", "jsFilename", " jsFilename", "JsFilename", " jsfile", "cssFilename", "Jsfile", "JsPath", "javascriptPath", "jsfile", " jsPath", " jsTable", "JsFile", "javascriptTable", " jsName", "cssTable", "javascriptFile", "javascriptfile", "cssfile", "jsPath", "jFilename", "jsName", "jName", "jFile", "jPath", "cssFile"], "fileName": ["getPath", "FileHash", "filePath", "Filename", "getName", " fileHash", " filePath", "FilePath", "FileName", "getHash", "getname", " filename", "filename", "fileHash"], "outputStream": [" outputstream", "OutputSet", "OutputStyle", "OutputSteam", "outputstream", "inputStyle", "OutputStream", "outputSteam", "writeStream", "outputSet", "writeSet", "OutputForm", "outputForm", " outputStyle", "inputstream", "Outputstream", "writeSteam", " outputForm", " outputSet", " outputSteam", "inputForm", "inputSteam", "outputStyle", "writestream"], "first": ["prev", "then", "same", "top", "default", "each", "stack", "ind", "quick", "self", "now", "next", "continue", "sort", "index", "open", "third", "success", "primary", "fourth", "start", "false", "send", "all", "natural", "important", "only", "seconds", "valid", "must", "st", "latest", "fast", "First", "initial", "true", "real", "last", "second", "master", "unique", "front", "current"], "reader": ["io", "read", "buffer", "rator", "ocr", "rl", "mr", "stream", "data", "core", "this", "file", "layer", "inner", "loader", "Reader", "ro", "parser", "r", "ner", "driver", "rer", "input", "rar", "rc", "er", "builder", "wrapper", "http", "row", "context", "runner", "handler", "rr", "resource", "writer", "iterator"], "jsCompressor": ["jscomposer", "jsCompression", "cssComposer", "jsBuffression", "cssCompressor", "jscompressor", "jsReposer", "jsComposer", "jscompression", "cssRepression", "jscompiler", "jsRepression", "cssRepressor", "cssRepiler", "cssReposer", "jsBuffiler", "jsRepressor", "jsCompiler", "jsBuffoser", "cssCompiler", "jsBuffressor", "jsRepiler", "cssCompression"], "s": ["qs", "ings", "gs", "t", "ss", "y", "ies", "ps", "details", "tags", "ats", "es", "less", "hs", "parts", "os", "full", "ers", "l", "cs", "ds", "is", "ls", "ms", "ids", "words", "fs", "eds", "S", "ens", "lines", "ts", "ns", "pers", "tes", "xs"], "s1": ["s3", "ys1", "esFirst", "ls0", "ls3", "es9", "s0", "id1", "s9", "s81", "ys81", "ps1", " s3", "es2", "ys0", "ls81", "es1", "ls1", "pers1", "sFirst", "ys3", " s0", "id2", "id9", "idFirst", "ps0", " s81", "pers0"], "i": ["ori", "ip", "li", "io", "y", "um", "v", "bi", "ii", "ity", "I", "id", "ui", "mi", "iu", "ati", "oi", "ig", "im", "iti", "ie", "is", "ifier", "ci", "pi", "iat", "p", "ia", "di", "o", "it", "ch", "j", "ai", "us", "ion", "ic", "ri"], "s2": ["msTwo", "s02", "tes2", "ztwo", "zSecond", "ss02", "gs2", "gstwo", "gsSecond", "SSecond", "ms2", "z02", "es2", "tes1", "sTwo", "S2", "es1", "tes02", "Stwo", "ss22", "ms02", "es02", "sSecond", "ss2", "gs02", "S02", "tesTwo", "esTwo", "stwo", "s22", "z2", "ssTwo", "ms22"], "i1": ["p4", "o1", "it0", "o0", "it1", "it01", "iOne", "aOne", "e1", "it2", "i0", "eOne", "a2", "e4", "p1", "e2", "a1", "p2", "p0", "i2", "oOne", "it4", "a01", "pOne", "o4", "itOne", "p01", "i01", "i4"]}}
{"id1": "6470716", "id2": "5148212", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"st": ["est", "t", "th", "stable", "se", "sn", "stream", "sm", "str", "rest", "tt", "sty", "stri", "ist", "sta", "nd", "sth", "St", "www", "ust", "step", "ste", "start", "ft", "stra", "d", "sw", "rt", "service", "ld", "ost", "sts", "ast", "std", "store", "sh", "inst", "sp", "ST", "set"], "url": ["dl", "li", "cl", "location", "build", "ul", "host", "nl", "mount", "str", "html", "base", "el", "rest", "file", "loc", "l", "gl", "web", "uri", "il", "string", "r", "client", "ssl", "cert", "browser", "impl", "ls", "www", "mail", "ref", "sl", "address", "bel", "ur", "f", "pl", "github", "http", "hl", "ll", "link", "ch", "rel", "domain", "URL", "fl", "char", "ret", "abs", "null", "addr", "shell", "Url", "rect"], "fis": ["tis", "xfis", " fi", "fiss", " fais", "Fais", "fei", "xfi", "ef\u00eds", "fliss", "xfois", "Fois", "feier", "ufi", "feois", " fiss", "fois", "Fier", "ufis", "fier", "flisl", "ufisl", "uf\u00eds", "Fos", "fais", "efiss", "fli", "f\u00eds", "fisl", " fisl", "feis", "xfier", "Fiss", "efi", "efis", "ufiss", "tos", "tais", "fi", "Fis", " f\u00eds", "flis", "Fi", "tiss"], "zis": ["ozits", "zhes", "zenisi", "czis", "fiss", "zipisin", " zris", "fits", " zisi", "zhis", "ozisa", "zisi", "zhIs", "zos", "ozis", "ozIs", " zits", "ziss", "ozisin", "zipis", "fisi", "zisa", "zipits", " zos", " zisa", "zenris", "zeniss", "zris", "czIs", "czits", " ziss", "zipIs", "zisin", "ozes", "zIs", "zipos", "czisa", "zenis", "zipes", "zits", "zes", " zIs", "zhisin", "fris"], "entry": ["fr", "tmp", "jar", "system", "ry", "or", "member", "se", "comment", "log", "ce", "attribute", "inter", "existent", "card", "e", "result", "cell", "ent", "out", "pattern", "ie", "way", "line", "item", "index", "entity", "de", "obj", "enter", "nt", "name", "chain", "Entry", "be", "info", "list", "element", "row", "match", "office", "event", "record", "link", "field", "valid", "char", "sp", "null", "jo", "zo", "zip", "word", "source", "key", "form", "def"], "count": ["c", "t", "ct", "ctr", "read", "buffer", "max", "acc", "base", "core", "length", "comment", "total", "ind", "batch", "add", "cell", "iter", "cc", "child", "index", "check", "err", "counter", "nt", "name", "found", "end", "n", "start", "amount", "len", "depth", "number", "nb", "match", "force", "num", "size", "ch", "sum", "char", "Count", "call", "code", "ount", "last", "cont", "current", "page"], "data": ["text", "buffer", "bin", "DATA", "part", "ata", "length", "raw", "batch", "image", "next", "result", " DATA", "string", "out", "zero", "cache", "step", "chain", "reason", "name", "dat", "format", "n", "mem", "buf", "d", "all", "json", "number", "value", "size", "sample", "block", "message", "output", "bytes", "area", "done", "mu", "table", "good", "source", "def"], "fos": ["Foss", "Fol", "fooss", "fol", "hOS", "fops", "fios", "hos", " fOS", "woss", "fool", " foss", "foss", "Fos", "wOS", "foops", "fioss", "fiops", "wis", "fOS", "his", "hoss", "foos", "Fops", "fiol", "wos"], "dest": ["est", "coord", "Dest", "det", "trans", "bin", "member", "src", "pipe", "des", "usr", "nom", "transfer", "rest", "test", "loc", "dc", "them", "foreign", "temp", "result", "pas", "origin", "out", "way", "nd", "nt", "dat", "ptr", "mem", "comb", "exp", "send", "comp", "target", "dist", "gest", "gate", "crit", "std", "desc", "cat", "output", "sum", "done", "master", "parent", "decl", "writer", "cont", "source"]}}
{"id1": "22479286", "id2": "8064604", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"md5": ["MD4", "MD2", " md3", " MD2", " MD3", " MD4", "MD5", "MD3", " md4", " md2", " MD5", "md3", "md2", "md4"], "plainText": ["plainString", "richString", "ainDelete", "plainTrans", "positionString", "ainPrint", " plainDelete", "plainTEXT", "mainString", "fulltext", "longString", "flatForm", "mainTEXT", "externalText", "plainTerm", " plainTrans", "plainSync", "plainDelete", " plainTEXT", "batText", "longTEXT", " plainMessage", "fullText", "flatMessage", "alttext", "aintext", "richText", "ainString", "positionTEXT", "richTEXT", "batString", "flatText", "maintext", "altString", " plainTerm", "batSync", "flatTEXT", "fullString", "richPrint", "plainForm", "ainText", "altText", "externalTEXT", "externalDelete", "altPrint", " plainString", "positionText", "longPrint", "plainPrint", " plaintext", " plainForm", "ainTerm", "initialText", "plaintext", "ainMessage", "plainMessage", "ainTEXT", "batTerm", " plainSync", "altTEXT", "externalString", "longText", "initialtext", "ainForm", "ainTrans", "initialTrans", "ainSync", "fullPrint", "mainText", "positiontext", "initialString"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "dr", "ng", "sd", "down", "sm", "mand", "ind", "mt", "mod", "add", "dd", "hd", "dir", "mc", "cmd", "df", "mk", "mb", "dm", "mac", "de", "pd", "nt", " MD", "grad", "mp", "d", "der", "di", "ld", "man", "mn", "od", "desc", "m", "red", "h", "mm", "ad", "mg", "ms"], "digest": ["candute", "digests", "digse", "compidate", " digEST", "mdest", "presentest", "presentute", "Digests", "digute", " digse", "defse", "compum", "Digity", "mdse", "presentested", "digity", "Digum", "compest", "candest", "defested", " digested", "Digute", " digity", " digests", "candum", "compute", "Digidate", "presentEST", "digEST", "digested", "DigEST", "digidate", " digute", "mdEST", "presentity", "candidate", "defest", "defEST", "Digest", "presentests", "Digested", "mdested", "digum"], "hexString": [" Hexstring", "exSingle", "rexBuffer", " hexstring", "hexText", "hexArray", " HexString", " hexSingle", "exString", " HexBuffer", " hexArray", "rexString", " hexText", "rexSingle", "hexBuffer", "hexstring", "hexSingle", "expString", "exBuffer", " HexText", "rexArray", "expText", "charBuffer", "charText", "charString", "charArray", " hexBuffer", "exText", "exArray", "expstring", "expBuffer"], "i": ["ip", "c", "li", "y", "io", "v", "bi", "in", "ii", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "iu", "mi", "ski", "batch", "b", "gu", "gi", "uri", "im", "q", "hi", "x", "is", "ti", "ie", "index", "ci", "err", "pi", "chain", "ji", "conv", "a", "iq", "n", "me", "qi", "si", "init", "ix", "di", "info", "it", "yi", "sim", "j", "ex", "my", "\u0438", "m", "z", "ai", "to", "g", "ic", "set"]}}
{"id1": "1798720", "id2": "3187685", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"save": ["version", "data", "release", "archive", "upload", "download", "register", "dump", "update", "install", "aw", "pack", "accept", "export", "send", "folder", "pkg", "init", "delete", "Save", " seal", " Save", "store", "saving", "zip", "filename"], "packageName": ["packageId", "pkgNames", " packageNames", "PackageId", " packageKey", "PackageType", "packageType", "pkgCode", "PackageName", " packageCode", "moduleKey", "pkgName", "moduleCode", "pkgId", "packagename", " packagename", "moduleName", " packageId", "pkgname", "PackageNames", " packageType", "packageCode", "modulename", "packageNames", "moduleNames", "packageKey", "pkgType", "pkgKey", "moduleId"], "fileContents": ["pageContents", " fileValues", "fileValues", "FileIngredients", "pageNames", "byteNames", "pageItems", "pageBytes", "fileItems", "FileContent", "fileContent", "fileBytes", " fileContent", "packageContents", "FileContents", "FileBytes", "FileItems", "FileValues", "FileNames", "fileIngredients", " fileItems", "packageIngredients", "packageContent", "byteContents", "packageNames", " fileIngredients", "byteContent", " fileBytes", "byteValues"], "fileNames": [" fileLeaks", "dirNames", " fileValues", "fieldNames", "resourceContents", "issueVaults", "moduleContents", "fieldTypes", "fileLeaks", "FileLeaks", " fileName", "fileValues", "resourceValues", "fieldContents", "issueName", "FileTypes", " fileNumbers", "issueNames", "messageValues", "dirLeaks", "resourceNames", "resourceTypes", "FileKeys", "FileName", "fileVaults", "messageKeys", "moduleName", "fieldNumbers", "fileName", "dirKeys", "moduleVaults", "FileContents", " fileTypes", "messageName", "FileNames", "FileValues", " fileKeys", "fileKeys", " fileVaults", "fileNumbers", "moduleNames", "dirTypes", "messageNames", "fileTypes", "resourceNumbers", "issueContents"], "dirBase": ["directoryBasic", "pkgSet", "dirbase", " directoryBase", "pathBas", "DIRBase", "directorybase", "irBas", "pkgBase", "pkgBas", "dirBas", "DirBottom", " directoryBas", "dirBottom", "pkgbase", "directoryBas", "dirBuilder", "DirBuilder", "directoryBase", "dirSet", "pathbase", "folderBasic", "DIRBas", "DIRBottom", "folderBase", "dirBasic", "folderbase", "folderBas", "pathBasic", " directoryBottom", "DIRBuilder", "irBase", "directorySet", "irSet", "irbase", "DirBase", " directoryBuilder", "DirBas", "pathBase"], "packageDir": ["podDir", " packageDist", "packageDef", "installDef", " packageD", "pkgFolder", "installDir", "moduleRel", "packageFolder", "pkgPath", " packageDef", " packagePath", "pkgDir", "moduleFolder", " packageRel", "podD", "installD", "modulePath", " packageFolder", "packageDist", "installDist", "podDef", "pkgDef", "packageRel", "moduleDef", "pkgRel", "packagePath", "moduleDir", "packageD", "podDist"], "created": ["confirmed", "generated", "checked", "started", "create", "creation", "registered", "called", "defined", "mounted", "arted", "raised", "produced", "existent", "creat", "recorded", "developed", "creator", "reported", "printed", "founded", "allowed", "successful", "Created", "present", "TED", "loaded", "ced", "made", "forced", "added", "joined", " started", "provided", " generated", "activated", "given", "associated", "released", "installed", "filled", "locked", "ready"], "currentPath": ["currentlyPath", " currentName", " currentParent", "currentPoint", "currentFile", "currentlyName", " currentFile", "CurrentPath", "currentCh", " currentCh", "CurrentFile", "currentParent", "currentName", " currentPoint", "CurrentCh", "recentParent", "currentlyFile", "CurrentPoint", "recentPoint", "CurrentParent", "recentPath", "currentlyCh", "recentName", "CurrentName"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "batch", "hi", "cli", "ami", "exp", "init", "ini", "ei", "sim", "j", "my", "mu", "g", "zi", "ic", "in", "multi", "u", "this", "q", "ki", "index", "pi", "ij", "qi", "f", "di", "o", "jj", "status", "ity", "id", "os", "mi", "them", "gi", "uri", "ie", "iii", "slice", "ji", "iq", "me", "p", "si", "ix", "info", "it", "yi", "key", "ip", "iy", "phi", "ui", "ind", "iu", "go", "ski", "oi", "im", "cgi", "ti", "major", "ci", "chain", "ex", "m", "ai", "ri"], "file": ["et", "le", "io", "buffer", "type", "base", "comment", "FILE", "log", "File", "disk", "pool", "l", "dir", "body", "ile", "child", "path", "fo", "name", "format", "play", "handle", "p", "f", "info", "row", "template", "local", "link", "handler", "page", "port", "sf", "resource", "table", "parent", "db", "rule", "source", "h", "set", "header"], "fos": ["woes", "foes", " foes", "Faos", "Foss", "ffos", "FOS", "woses", " fow", "ffoes", " foses", " fOS", "oo", "oow", "woss", "sfaos", " foss", "flo", "foss", "floes", "fbow", "flaos", "Foes", "sfoss", "oos", "faos", "Fos", "sfos", "fo", "fbaos", "sfOS", "fOS", "flos", "floses", "floss", "oaos", "ffo", "ffaos", "fow", "fbo", " faos", " fo", "Fo", "foses", "fbos", "wos"], "fileSrc": [" fileInsRC", "fileDsrc", " fileInsource", "fileInRC", "fileInssrc", "fileEci", " fileInsrc", " fileSsrc", "jobNrc", " fileSource", "fileErc", "fileNci", "fileDci", "fileInsrc", "fileSri", "jobNci", " fileInssrc", "fileSRC", "jobSri", "fileInource", "fileSource", "fileSci", "fileNrc", "jobNri", "fileErl", "fileEri", "fileInsource", "jobSrl", "fileInrc", "fileNrl", "jobSrc", "fileDRC", "jobNrl", " fileSRC", "fileDri", "fileDrc", "fileSsrc", "fileDource", "jobSci", "fileSrl", "fileNri", "fileDrl", "fileInsRC"], "fileDst": ["filedld", "FileSld", "fileNld", "fileDot", "FileDst", "fileNst", "filednd", "fileSpl", "FileDld", "fileDnd", "fileDld", "FileSst", "fileDpl", "FileDpl", "fileWst", "fileDcr", "fileSst", "FileSpl", "fileScr", "FileSnd", "FileDlt", "filedcr", "fileSlt", "FileSlt", "fileWlt", "FileDot", "FileSot", "fileNnd", "fileNlt", "fileWot", "FileDnd", "FileDcr", "fileSld", "fileWpl", "fileNot", "FileScr", "fileNcr", "fileSnd", "fileNpl", "fileSot", "filedst", "fileDlt"], "reader": ["ler", "read", "buffer", "dr", "ader", "actor", "rl", "stream", "rx", "rot", "book", "controller", "author", "review", "inner", "loader", "Reader", "ro", "iter", "oder", "parser", "ner", "r", "driver", "rer", "Larry", "upper", "ocker", "rar", "rc", "er", "row", "query", "roller", "reading", "context", "runner", "readable", "entry", "rr", "handler", "resource", "ri", "iterator"], "writer": ["println", "buffer", "write", "worker", "read", "manager", "wire", "stream", "order", "user", "server", "test", "liner", "document", "print", "draw", "loader", "Reader", "adder", "flush", "console", "word", "parser", "creator", "storage", "client", "iter", "driver", "player", "operator", "browser", "riter", "writing", "later", "format", "iterator", "variable", "builder", "maker", "caster", "wrapper", "Writer", "wright", "service", "query", "w", "runner", "writers", "report", "walker", "entry", "store", "handler", "table", "function", "ter", "window", "outer", "editor"], "line": ["text", "le", "detail", "lin", "inline", "range", "point", "nl", "user", "column", "comment", "liner", "LINE", "print", "l", "continue", "ln", "cell", "word", "Line", "eline", "source", "string", "stroke", "ole", "entity", "chain", "ine", "date", "pe", "lined", "frame", "number", "row", "edge", "record", "link", "sample", "block", "sequence", "message", "valid", "entry", "label", "style", "code", "port", "node", "rule", "page", "kin", "header"]}}
{"id1": "19549489", "id2": "13666876", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "save", "create", "read", "write", "replace", "Cop", " mirror", "upload", " duplicate", "transfer", "csv", "download", " cp", "add", "clone", "cp", " Copy", "slice", "map", "export", "paste", "move", "load", "delete", "rm", "cat", "Copy"], "sourceFile": ["SourceFilename", "inputPage", " sourceFilename", "inputfile", "ourcefile", "ourcePage", "ourceFile", "ourceLine", " sourcefile", "sourcePage", "inputLine", "sourcefile", " sourceLine", "sourceLine", "SourceFile", "inputFile", " sourcePage", "SourcePage", "ourceFilename", "sourceFilename", "SourceLine", "Sourcefile"], "destinationFile": ["estinatedPlace", "destinoFilename", "declinatorPlace", "destinoFile", "destinationsfile", "destinatorPlace", "destinofile", "declinationPath", "destinatePath", "declinationFilename", "declinationFile", "estinationFilename", "destinoPlace", "destinationPath", "estinationFile", "destinationFilename", "destinationfile", "estinatedFile", "estinatedfile", "destinatorFilename", "destrativePlace", "destinatedPlace", "destinationsPlace", "destrativePath", "destinationsFile", "estinationPlace", "destinateFile", "destinationsFilename", "destrativeFile", "destinatePlace", "destinatedfile", "estinatedFilename", "declinationPlace", "destinationPlace", "destinatedFilename", "destinatorPath", "destinatedFile", "destinateFilename", "declinatorFile", "declinatorFilename", "destrativeFilename", "destinatorFile", "declinatorPath", "estinationfile"], "sourceFileChannel": ["sourceByteEntry", "srcFileEntry", "sourceStreamApplication", "srcFilechannel", "sourceFileEntry", "sourceLineChannel", "sourceEntryConnection", "sourceEntryChan", "sourceBlockConnection", "srcBlockEntry", "sourceBaseApplication", "sourceFileConnection", "sourceBaseHandler", "sourceStreamChan", "ourceFileChan", "sourceLineConnection", "sourceLineChan", "srcBlockConnection", "sourceStreamchannel", "srcBlockchannel", "sourceStreamChuck", "srcBlockChannel", "sourceByteConnection", " sourceFileApplication", "sourceLineEntry", " sourceFileChuck", "sourceByteChannel", "sourceFileApplication", "ourceFileChannel", "sourceEntrychannel", "sourceFileChan", "sourceFileHandler", "ourceEntrychannel", "ourceEntryChan", "sourceBytechannel", " sourceFileHandler", "sourceFileChuck", "ourceFilechannel", "sourceLinechannel", "sourceBlockChannel", "sourceBaseChannel", "ourceFileConnection", "sourceEntryChannel", "sourceBlockEntry", "ourceEntryConnection", "srcFileConnection", "sourceFilechannel", "sourceBlockchannel", "srcFileChannel", "sourceStreamChannel", "sourceStreamHandler", "sourceStreamConnection", "sourceBaseChuck", "ourceEntryChannel"], "destinationFileChannel": ["destinationfileManager", "destmentResourceChannel", "destmentPageChannel", "destinationFilesConnection", "destinationfileEntry", "destinatorFilesChannel", "destinationChannelEntry", "destinationFileManager", "destmentFilechannel", "destinationResourcechannel", "destinationFilesChannel", "destinationChannelCh", "destinationPageChannel", "destinatorFileCh", "destinationResourceManager", "destinationPageEntry", "destmentPageContext", "destinationfileConnection", "destmentPageEntry", "destinationResourceChan", "destmentResourcechannel", "destmentFileChannel", "destinationfilechannel", "destinationFileConnection", "destinationDirectoryChannel", "destinationDirectorychannel", "destinationfileCh", "destinatorFilesConnection", "destinationfileChannel", "destmentResourceManager", "destinationChannelChannel", "destinationPageContext", "destmentPageChan", "destinationFileContext", "destinationFilechannel", "destinationPageChan", "destinationChannelChan", "destinationFileEntry", "destinationDirectoryManager", "destinationChannelConnection", "destinationChannelContext", "destinationfileChan", "destinationfileContext", "destinationFileChan", "destinatorFilesCh", "destinationResourceChannel", "destmentFileChan", "destinationFilesChan", "destinationFileCh", "destmentResourceChan", "destinationFilesCh", "destinatorFileConnection", "destmentFileContext", "destinatorFileChannel", "destmentFileEntry", "destinatorFilesChan", "destmentFileManager", "destinatorFileChan", "destinationDirectoryChan"]}}
{"id1": "5125848", "id2": "1357662", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"combineJs": ["combinateLink", "Combosejs", "ComboseJS", "CombineJs", "combineJS", "combinateJS", "combinatejs", "combinateJs", "CombineJS", "ComboseJs", "comboseJS", "combINEjs", "comboseJs", "combinejs", "combosejs", "combINELink", "ComboseLink", "comboseLink", "Combinejs", "combineLink", "combINEJS", "CombineLink", "combINEJs"], "base": ["buffer", "bound", "ase", "based", "re", "host", "data", "id", "server", " bases", "file", "bottom", "bas", "b", "prefix", " basis", "uri", "source", "origin", "address", " Base", "start", "root", "absolute", "relative", " based", "Base", "api", "template", "site", "local", "domain", "from", "reset", "bid", "page", "db"], "linkJs": ["linkTags", "inkScript", "linkJS", "inkLinks", "LinkJS", "linkjs", "Linkjs", "linkLinks", " linkJS", " linkjs", "LinkJs", "inkJS", " linkScript", "inkJs", "LinkTags", "inkTags", "linkedJS", "linkScript", " linkLinks", "linkedLinks", "inkjs", " linkTags", "linkedJs", "linkedScript"], "newFiles": [" newLinks", "newLinks", "newDocuments", "linkfiles", "newfiles", "linkLinks", "nextLinks", "nextDocuments", "nextfiles", " newfiles", "linkDocuments", "nextFiles", " newDocuments", "linkFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "manager", "dr", "lib", "md", "id", "auto", "file", "disk", "div", "loc", "mod", "temp", "dd", " directory", "sys", "out", "mk", "dm", "Dir", "DB", "ref", "created", "DIR", "tar", "root", "diff", "fd", "folder", "d", "pkg", "di", "fs", "directory", "module", " Dir", "lock", " d", "desc", "rel", "area", "ir", "local", "vol", "done", "doc", "addr", "zip", "good", "db", "def"], "name": [" rebuild", " dummy", " self", " db", " vm", " log", " info", " prefix", " manager", " b", " scanner", " browser", " loader", " res", " parser", " logger", " start", " karma", " msg", " names", " err", " cleaner", " report", " bar", " str", " foo", " filename", " tmp", " os"], "minDir": ["smallDir", "minPref", "minRel", "minuteDar", "MinNet", "minutePref", "miniTrans", "mindir", "skindir", "skinDir", "minTrans", "maindir", "minJar", " minJar", "minDb", " minPref", "smallNet", "minuteDir", "minDar", "minFile", " minTier", " minRel", "minTier", "sortDir", "sortRel", " minDar", " minFile", "thinJar", " minTrans", "smallDb", " minNet", "thinTier", "minLoc", "smallLoc", "mainDb", "skinDb", "minuteRel", "smalldir", "sortDar", "miniTier", "sortPref", "smallFile", "skinLoc", "minNet", "mainDir", "thinDir", "miniDir", "thinTrans", "MinFile", "miniJar", "mainLoc", "MinDir"], "combineFile": ["cominatefile", "cominateMessage", "coordINEFile", "coordINESet", "combinateFile", "combINEWriter", "comboseWriter", "combinSet", "combinerfile", "cominateFile", "comboseSet", "comineFile", "coordineFile", "comineMessage", "comboiceFile", "combINESet", "comboseFile", "coordineSet", "combinerFile", "cominefile", "combinerMessage", "combinefile", "combinFile", "combinateMessage", "coordinefile", "combosefile", "comineEmail", "combineMessage", "comboiceEmail", "combINEfile", "coordINEWriter", "coordineWriter", "comboiceMessage", "comboicefile", "coordINEfile", "combinateEmail", "combineEmail", "cominateEmail", "combinWriter", "combinatefile", "combinerEmail", "combinfile", "combineSet", "combINEFile"], "concatFile": ["comcFile", "concDir", "concatfile", "concapFiles", "concFile", "comcDir", "conatFile", "conatFiles", "concatFiles", "covertTable", "comcatDir", "conCatFilename", "convertfile", "convertFiles", "cocatFiles", "cocatTable", "concFilename", "concapfile", "conCatDir", "covertfile", "covertFile", "comcatFilename", "conatTable", "conatfile", "concatFilename", "comcFilename", "concapTable", "cocatfile", "convertTable", "concatDir", "covertFiles", "concapFile", "convertFilename", "convertFile", "conCatFile", "concatTable", "comcatFile", "cocatFile", "convertDir"], "combineWriter": ["declineFile", "declinateReader", "declinateWriter", "combineReader", "combinateFile", "declinateFile", "combinateWrite", "combenwriter", "combinateWriter", "combinewriter", "Combosewriter", "comboseWriter", "ComboseCounter", "comboseReader", "combenWrite", "combinatewriter", "declineReader", "declineWrite", "comboseFile", "comboseWrite", "declinateWrite", "ComboseWrite", "combieWriter", "CombineWrite", "combosewriter", "combieWrite", "combineCounter", "combinateCounter", "combieReader", "combinateReader", "combineWrite", "CombineCounter", "declineWriter", "combieFile", "CombineWriter", "combenCounter", "Combinewriter", "combenWriter", "ComboseWriter", "comboseCounter"], "concatWriter": ["concatWrite", "concatsReader", "cocatWriter", "conatReader", "conatFile", "coatWriter", "comvertWriter", "cocatReader", "cocatWrite", "comcatWrite", "comvertReader", "coatWrite", "conatWriter", "concatsWrite", "convertReader", "coatFile", "comcatReader", "convertWrite", "comvertFile", "coatReader", "comvertWrite", "concatReader", "concatsWriter", "conatWrite", "convertWriter", "convertFile", "comcatWriter", "comcatFile", "cocatFile", "concatsFile"], "fails": ["mails", " failed", "facocks", "ifails", "lalls", "facails", "frailed", "ifocks", "mailed", "lails", "falls", "failing", "malls", "frails", "fils", "mocks", "Fils", "lailing", "focks", "ifailed", " focks", "ifailing", "facailing", "facailed", "failed", "frailing", "Failing", "frils", "mailing", "Fails", "lailed", " falls", "Failed", " failing", "lils"], "link": ["embed", "c", "li", "follow", "close", "inline", "links", "log", "loc", "self", "l", "add", "mark", "relation", "ln", "linked", "child", "line", "check", "open", "address", "ink", "map", "script", "load", "match", "set", "display", "Link", "task", "node", "code", "share", "remote", "source", "skip", "push"], "path": ["text", "location", "kind", "src", "PATH", "data", "str", "id", "prop", "full", "file", "loc", "ath", "image", "join", "prefix", "hex", "route", "uri", "string", "pattern", "input", "alias", "ref", "Path", "format", "root", "p", "relative", "href", "match", "template", "entry", "style", "resource", "source", "key"], "url": ["li", "location", "request", "build", "ul", "host", "nl", "mount", "str", "id", "html", "this", "loc", "lr", "l", "gl", "web", "uri", "il", "string", "r", "browser", "ssl", "ls", "mail", "ref", "sl", "address", "ur", "get", "http", "href", "hl", "ll", "rel", "abs", "URL", "char", "null", "addr", "resource", "Url", "source"], "inputStream": ["InputTime", "InputSteam", "outputstream", " inputSet", "inputTime", "inSet", "inputStyle", "outputSteam", "inTime", " inputStyle", "Inputstream", " inputTime", "inStream", "instream", "inputSet", "InputStyle", "inputstream", " inputSteam", "InputStream", "inputSteam", "outputStyle", "InputSet", " inputstream"], "jsFile": ["javascriptName", "javascriptFilename", "jsTable", "cssPath", "jsFilename", " jsFilename", "JsFilename", " jsfile", "cssFilename", "Jsfile", "JsPath", "javascriptPath", "jsfile", " jsPath", " jsTable", "JsFile", "javascriptTable", " jsName", "cssTable", "javascriptFile", "javascriptfile", "cssfile", "jsPath", "jFilename", "jsName", "jName", "jFile", "jPath", "cssFile"], "fileName": ["getPath", "FileHash", "filePath", "Filename", "getName", " fileHash", " filePath", "FilePath", "FileName", "getHash", "getname", " filename", "filename", "fileHash"], "outputStream": [" outputstream", "OutputSet", "OutputStyle", "OutputSteam", "outputstream", "inputStyle", "OutputStream", "outputSteam", "writeStream", "outputSet", "writeSet", "OutputForm", "outputForm", " outputStyle", "inputstream", "Outputstream", "writeSteam", " outputForm", " outputSet", " outputSteam", "inputForm", "inputSteam", "outputStyle", "writestream"], "first": ["prev", "then", "same", "top", "default", "each", "stack", "ind", "quick", "self", "now", "next", "continue", "sort", "index", "open", "third", "success", "primary", "fourth", "start", "false", "send", "all", "natural", "important", "only", "seconds", "valid", "must", "st", "latest", "fast", "First", "initial", "true", "real", "last", "second", "master", "unique", "front", "current"], "reader": ["io", "read", "buffer", "rator", "ocr", "rl", "mr", "stream", "data", "core", "this", "file", "layer", "inner", "loader", "Reader", "ro", "parser", "r", "ner", "driver", "rer", "input", "rar", "rc", "er", "builder", "wrapper", "http", "row", "context", "runner", "handler", "rr", "resource", "writer", "iterator"], "jsCompressor": ["jscomposer", "jsCompression", "cssComposer", "jsBuffression", "cssCompressor", "jscompressor", "jsReposer", "jsComposer", "jscompression", "cssRepression", "jscompiler", "jsRepression", "cssRepressor", "cssRepiler", "cssReposer", "jsBuffiler", "jsRepressor", "jsCompiler", "jsBuffoser", "cssCompiler", "jsBuffressor", "jsRepiler", "cssCompression"], "s": ["qs", "ings", "gs", "t", "ss", "y", "ies", "ps", "details", "tags", "ats", "es", "less", "hs", "parts", "os", "full", "ers", "l", "cs", "ds", "is", "ls", "ms", "ids", "words", "fs", "eds", "S", "ens", "lines", "ts", "ns", "pers", "tes", "xs"], "s1": ["s3", "ys1", "esFirst", "ls0", "ls3", "es9", "s0", "id1", "s9", "s81", "ys81", "ps1", " s3", "es2", "ys0", "ls81", "es1", "ls1", "pers1", "sFirst", "ys3", " s0", "id2", "id9", "idFirst", "ps0", " s81", "pers0"], "i": ["ori", "ip", "li", "io", "y", "um", "v", "bi", "ii", "ity", "I", "id", "ui", "mi", "iu", "ati", "oi", "ig", "im", "iti", "ie", "is", "ifier", "ci", "pi", "iat", "p", "ia", "di", "o", "it", "ch", "j", "ai", "us", "ion", "ic", "ri"], "s2": ["msTwo", "s02", "tes2", "ztwo", "zSecond", "ss02", "gs2", "gstwo", "gsSecond", "SSecond", "ms2", "z02", "es2", "tes1", "sTwo", "S2", "es1", "tes02", "Stwo", "ss22", "ms02", "es02", "sSecond", "ss2", "gs02", "S02", "tesTwo", "esTwo", "stwo", "s22", "z2", "ssTwo", "ms22"], "i1": ["p4", "o1", "it0", "o0", "it1", "it01", "iOne", "aOne", "e1", "it2", "i0", "eOne", "a2", "e4", "p1", "e2", "a1", "p2", "p0", "i2", "oOne", "it4", "a01", "pOne", "o4", "itOne", "p01", "i01", "i4"]}}
{"id1": "18731843", "id2": "19134229", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" sendContent", " writeHead", "loadbody", " sendHead", " sendbody", " writebody", " dobody", "loadContent", " doHead", " writeContent", " writeBody", "loadHead", " doContent", " sendBody", "loadBody"], "req": ["fr", "ps", "request", "gr", "aj", "inv", "ctx", "js", "reg", "urg", "quick", "sq", "jp", "express", "q", "cmd", "proc", "hr", "res", "err", "quest", "qt", "exec", "Request", "pkg", "http", "conf", "query", "crit", "wx", "Requ", "tx", "def", "j", "rec", "pro", "qq", "requ"], "resp": ["respond", "cl", "trans", "Resp", "re", "js", "Rep", "respons", "esp", "pos", "comm", "next", "serv", "wr", "result", "Res", " res", "out", "client", "res", "err", "exp", "soc", "http", "wa", "response", "rel", "vol", "output", "ret", "rec", "Response", "RES", "sp", "sol", "rep", "def"], "bis": ["avi", "atis", "sb", "rison", "ads", "iris", "bi", "bh", "lin", "bs", "aus", "os", "phis", "isin", "mi", "oi", "isi", "pins", "webkit", "bt", "bits", "idis", "inet", "oss", "is", "bes", "bat", "pin", "lis", "iso", "nis", "bie", "lbs", "bps", "bil", "ubis", "ris", "ses", "onis", "los", "be", "ais", "mis", "iss", "ios", "fps", "obs", "bid", "cin", "zo"], "bos": ["tis", "gs", "dos", "nos", "zb", "bin", "bh", "bi", "bs", "fits", "os", "BS", "oi", "bas", "vas", "pins", "bits", "ts", "acs", "ows", "oss", "bes", "oos", "is", "asket", "ys", "asis", "its", "uts", "banks", "bil", "eros", "ubis", "stones", "oops", "ols", "los", "fs", "jas", "outs", "bo", "ios", "obs", "ubs", "ods", "mes", "uds", "aos", "tes"]}}
{"id1": "1769771", "id2": "15797402", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", "copyLine", "copyFiles", "CopyStream", " copyStream", " CopyLine", " copyLine", " CopyStream", "CopyFiles", "CopyFile", "copyStream", "CopyLine", " CopyFiles", " copyFiles"], "in": ["io", "bin", "din", "inc", "isin", "rin", "ind", "el", "en", "l", "b", "inner", "inf", "r", "is", "input", "up", "In", "old", "on", "gin", "init", "ini", "IN", " input", "from", "ins", "inn", "cin", "i", "mm", "ic", "source"], "out": ["c", "t", "io", "v", "po", "help", "os", "log", "file", "l", "b", "serv", "at", "update", "gt", "ot", "res", "err", "nt", "up", "op", "n", "p", "o", "net", "it", "w", "outs", "output", "Out", "ex", "to", "msg", "s", "ou", "OUT"], "inChannel": ["sinButton", "sinCase", "innClient", "ainCategory", "dinConnection", "cinRoom", "inButton", " inCase", "cinCommand", "inChan", "ainClient", "insideScope", "cinChannel", "insideCategory", "innButton", "innChannel", "InChannel", " inRoom", "outchannel", " inchannel", "dinChan", "sinClient", " inChan", "sinChannel", "intchannel", "inchannel", "inClient", "intCommand", " inCommand", " inConnection", "insideClient", " inButton", "inCase", " inCategory", "dinChannel", "inRoom", "inConnection", "inCommand", "InChan", "dinchannel", "sinRoom", "outChan", " inClient", "insideChannel", "Inchannel", "intChannel", "inCategory", "intChan", " inScope", "ainScope", "innCase", "InCommand", "ainChannel", "outConnection", "sinCommand", "inScope"], "outChannel": ["outSection", " outManager", "inChan", "outputCh", "parentGate", "cnChan", "outputchannel", "blockChannel", "parentChannel", "outchannel", "cnManager", "cnChannel", "parentChan", "neMember", "aosChannel", "inchannel", "outMember", " outChan", "inSection", "aosChan", "aosSection", "outputChan", "neChannel", "outMany", "outCh", "outManager", "blockGate", "blockChan", "outputChannel", "inCh", "neChan", "outputManager", " outMany", "neSection", "inMember", "outGate", " outGate", "outChan", " outchannel", " outCh", "blockMany", "aosMember", "parentMany"]}}
{"id1": "17817568", "id2": "16572931", "code1": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 0, "substitutes": {"getGETReader_bak": ["getGETReader_buak", "getGETReader_gak", "getGETReader2baz", "getGETReader_baz", "getGETReader_buaz", "getGETReader_brief", "getGETReader2brief", "getGETReader2crief", "getGETReader2cak", "getGETReader2cundle", "getGETReader_bundle", "getGETReader2caz", "getGETReader_grief", "getGETReader_gundle", "getGETReader_gaz", "getGETReader_crief", "getGETReader_cundle", "getGETReader_buundle", "getGETReader2bundle", "getGETReader_burief", "getGETReader_cak", "getGETReader_caz", "getGETReader2bak"], "url": ["dl", "location", "org", "request", "build", "ul", "rl", "host", "re", "mount", "str", "nl", "base", "user", "u", "el", "loc", "l", "b", "web", "gl", "uri", "il", "string", "r", "ssl", "browser", "uf", "path", "ls", "ob", "util", "job", "err", "ref", "sl", "address", "name", "ur", "http", "ll", "link", "URL", "call", "resource", "Url", "rect", "key", "bb"], "reader": ["ler", "read", "buffer", "ocr", "rl", "mr", " read", "rot", "test", "liner", "lr", "relation", "inner", "loader", "Reader", "ro", "iter", "parser", " parser", "ner", "r", "driver", "rer", " cursor", "rar", " builder", "rc", "er", " writer", "builder", "wrapper", "service", "row", "rank", "runner", "holder", "handler", "rr", "writer", " readers"], "contentLength": [" contentPosition", "Contentlength", " contentLanguage", "ontentDescription", " contentLine", "loadLen", "readableDescription", "sequenceLen", "readableLen", " contentLocation", "contentDescription", "readableType", "codePosition", "ContentType", "readableLength", "sequenceLength", " contentlength", "connectionLong", " contentType", "ContentLength", " contentLen", "codeLength", "ontentType", "ontentLine", "contentPosition", "codeType", "translationDuration", " contentDelivery", "contentLong", "contentType", "ContentDelivery", "contentSize", "loadLocation", "connectionLength", "contentDuration", "loadLength", " contentLong", "contentDelivery", "contentLanguage", "connectionLanguage", "sequenceSize", " contentSize", "ontentLength", "ontentlength", "readablelength", "contentLine", "translationLong", "ContentSize", "contentLocation", "ontentPosition", "readableLocation", " contentDescription", "ContentDescription", "contentlength", "connectionDuration", "contentLen", " contentDuration", "ontentDelivery", "translationLength", "translationLanguage", "ContentLen", "sequencelength", "codeLine"], "urlc": ["urldc", "jsoncon", "voidC", "llC", "voidcm", " urllc", "Urlcon", "urlcity", "implh", "logcs", "urlcur", "implci", "mailco", " urlcur", "elci", "methodl", "sslci", "managerdc", "sslc", " urlcs", "urlcon", "mountco", "browsercu", "Urldc", "urlC", " urlcm", "urll", " urldc", "jobcm", "strc", "logci", " urlh", "Urlco", "jobcur", "sslcur", "voidc", " urlcall", "implcon", "jsonC", "httpc", "nelci", "jobcb", " urlC", "elf", "logcall", "mailC", "browserlc", "urllc", "Urllc", " urlci", "llci", " urlcu", "httpci", "implc", "jsonci", "Urlc", "implC", "managerc", "methodc", "elc", "urlcu", "jobc", "urlcm", "nelc", "methodci", "strf", "urlci", "urlcs", "UrlC", "httpcur", " urlcb", "ssll", " urlf", "urlf", "urlco", "elcu", "mountc", "urlcall", " urlcity", "httpl", "managercity", "strcu", "urlh", "browserh", "voidci", "urlcb", "logc", "methodcur", "mountC", "llcur", "nelcs", "jsonc", "mountlc", "impllc", "mailc", "implcu", "voidcur", "browserc", "Urlci", "maillc", "Urlcity", "voidcb", "nelcall", "managerC", "strci", "llc"], "content_type": ["Content_link", " content_tool", "contentTypeTYPE", "contentprostring", "content_info", " content_TYPE", "Content_type", " contentTypeType", "Content_string", "content_language", "content_ty", "key_id", "contentTypeinfo", "contentTypeType", " content_ty", "Content_language", "Content_Type", "contentTypetype", "contentprolanguage", " contentTypetype", "key_Type", "content_name", "contentTheType", "key_type", " contentTypeinfo", "content_TYPE", " content_name", " contentTypetool", "content_string", "content_Type", "content_link", " contentTypety", "contentTypety", "content_id", " content_info", "contentTheinfo", "contentprotype", "contentTypetool", " content_Type", "contentThetype", "contentproType", "content_tool", " contentTypeTYPE", "contentThetool"], "is": ["isd", "tis", "mos", "ists", "dis", "iris", "in", "ii", "es", "bs", "\u00eds", "js", "os", "sis", "isin", "isc", "isi", "has", "was", "im", "bits", "ist", "sys", "ics", "xs", "ds", "iso", "ls", "lis", "nis", "ys", "ires", "ids", "its", "IS", "ris", "are", "si", "info", "ses", "ais", "eds", "isa", "iss", "mis", "ios", "ish", "isl", "ir", "ar", "ins", "ai", "i", "s", "Is", "ri", "ms"], "d": ["dn", "dal", "bd", "dl", "dh", "du", "dis", "rd", "cd", "dr", "dict", "sd", "des", "md", "dc", "da", "dd", "dir", "dt", "dra", "did", "del", "D", "ds", "df", "dec", "nd", "dm", "de", "pd", "dat", "dx", "fd", "dom", "der", "di", "ld", "od", "dL", "gd", "done", "ad", "db", "ded"], "content": ["text", "scroll", "example", "buffer", "copy", "data", "html", "core", "ext", "comment", "full", "raw", "image", "temp", "result", "body", "normal", "path", "Content", "cache", "draft", "address", "reason", "accept", "mem", "media", "description", "array", "load", "json", "search", "value", "info", "cm", "sequence", "message", "output", "values", "bytes", "ontent", "config", "code", "xml", "node", "empty", "cont", "good", "current", "source", "txt"], "bais": ["baliu", "Bai", "BAis", "baes", "BAi", " baIs", "Baiu", "bai", "boes", "balis", "bois", "balIS", "Bais", "BaIS", "baiu", "BAIS", "boIs", "BAIs", "BAes", "bali", " baes", "BAiu", "baIs", " bai", "boi", "baIS"], "bis": ["tis", "atis", "rison", "mos", "iris", "bi", "bh", "bs", "fits", "sis", "isin", " Bis", "pins", "bits", "idis", "bos", "bes", "lis", "nis", "its", "bil", "ubis", "ints", "ses", "ris", "onis", "los", "ais", "mis", "ios", "fps", "obs", "bid", "cin", "mes"], "gis": ["Gis", "gmisi", "gzates", "guis", "guiss", "gisi", "gzis", "giss", " gris", "GIs", " gIs", " gates", " gisi", "gIs", "gris", "gzisi", "Giss", " giss", "gates", "Gris", "gmis", "guIs", "gmIs", "guris", "gmates", "gzIs"], "sb": ["lb", "lp", "zb", "sg", "bg", "stab", "wb", "bh", "bs", "bf", "rob", "sv", "b", "bt", "ib", "sa", "ssl", "sth", "eb", "cb", "SB", "rb", "bps", "ses", "gb", "erb", "nb", "pb", "CB", "kb", "xb", "sp", "sf", " SB", "bsp", "bb"], "zipReader": ["zipLoader", " zipParser", "ZipRead", "ZipReader", "pipeWriter", "serialBuffer", "zipRead", "ZipWriter", "jsonreader", "serialReader", "ZipParser", "pipeBuffer", " zipLoader", "ZipLoader", "jsonReader", "zipreader", "zipParser", "jsonParser", "Zipreader", "pipeRead", "zipWriter", " zipreader", "zipBuffer", "serialWriter", "jsonLoader", "serialRead", "ZipBuffer", "pipeReader"], "chars": ["contarters", " chrs", "charas", "contacters", " chnew", " ChARS", "charnew", "Chrs", "charters", "charts", " champs", "achacters", "acharters", "CHars", "contats", " Chars", " chcs", "achas", "achamps", "CHARS", "chats", "charrs", "ChARS", "chas", "chcs", "achrs", "CHcs", "CHamps", "chnew", "Chats", "achcs", "chacters", "achARS", "achats", " Chats", "Chas", "achars", " chacters", "charars", "chARS", "chararts", "Chnew", " chARS", "Chars", "acharts", "Charts", " charters", "chrs", "champs", " chats", "contars", " Chrs"], "len": ["compl", "t", "li", "count", "min", "lon", "Length", "lib", "nl", "L", "rot", "col", "ail", "length", "full", "el", "pos", "els", "en", " el", "l", "wid", "mun", "left", "ln", "il", "vec", "del", "lan", "ls", "lf", "elt", "n", "mem", "un", "exp", "late", "coll", "seq", "all", "ld", "val", "gen", "ll", "fin", "size", "num", "lic", "fun", "lit", "lim", "cmp", "Len", "span"]}}
{"id1": "19549577", "id2": "14691829", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"callApiPost": ["callAiPost", "callActionsPost", "callUapiPOST", "callAiPut", "callAiPOST", "callUpiPut", "callUapiPut", "callActionsPOST", "callUapiPost", "callApiPut", "callApiPOST", "callUpiPost", "callApiDelete", "callAapiPOST", "callUpiPOST", "callAiDelete", "callActionsDelete", "callAapiPut", "callUapiDelete", "callAapiDelete", "callActionsPut", "callAapiPost", "callUpiDelete"], "apiUrl": ["baseURL", "baseUr", "basePath", "apUr", "piUr", "resourceURL", "apURL", "apiURL", "apiUr", "resourceUrl", "baseUrl", "piUrl", "apiPath", "piPath", "apiName", "piName", "resourceUr", " apiUr", " apiURL", "apPath", "apUrl", "resourceName", " apiName", "piURL"], "parameters": ["authorants", "queters", "pions", "qutons", "pperties", "paramels", "mions", "paramperties", "paramions", "authorels", "authortons", "pParameters", "peters", "paytons", "questperties", "paramtons", "paramants", "questeters", "authoreters", "questions", "payants", "quants", "meters", "payels", "payeters", "mperties", "paramParameters", "mParameters", "questParameters", "quels"], "expected": ["checked", "example", "encrypted", "count", "type", "needed", "default", "seen", "future", "pect", "test", "sex", " expectation", "actual", "odd", "error", "e", "reported", " unexpected", "allowed", "ped", "sent", "received", "foo", "pects", "pected", " expecting", " expect", "safe", "json", "hello", "required", "value", "event", "posted", "size", "finished", "failed", "force", "done", "empty", "code", " expects", "current", "set"], "url": ["dl", "ml", "build", "ul", "rl", "re", "nl", "mount", "str", "base", "log", "loc", "l", "loader", "gl", "uri", "https", "arl", "q", "oul", "r", "ssl", "impl", "ls", "www", "gc", "mail", "sl", "address", "bel", "ur", "get", "f", "pl", "http", "service", "hl", "ll", "link", "abs", "URL", "Url"], "request": ["object", "exit", "memory", "run", "release", "begin", "web", "session", "reference", "position", "media", "pair", "search", "first", "message", "condition", "change", "initial", "socket", "parent", "xml", "remote", "connect", "pull", "version", "worker", "volume", "order", "require", "q", "client", "application", "open", "java", "reverse", "req", "root", "get", "project", "record", "response", "access", "requ", "remove", "header", "parse", "create", "buffer", "over", "user", "QUEST", "document", "friend", "setup", "quest", "rate", "use", "query", "question", "process", "reset", "call", "resource", "forward", "close", "re", "complete", "register", "enter", "name", "command", "accept", "Request", "send", "report", "store"], "headerName": ["authorname", "headingHandle", "profileHandle", "methodHandle", "propertyname", "profileSpec", "headingName", "authorNAME", "profileName", "headerLetter", "componentFamily", "propertyName", "componentName", "propertySet", "authorSet", "componentNAME", " headerFamily", "headerHandle", "headername", "methodSpec", "profileLetter", "headerFamily", "authorName", "headingNAME", "methodLetter", "headerSet", "attributeName", "attributeSet", "headingSpec", "propertyNAME", "attributeNAME", "attributename", "methodName", "headerNAME", "headingFamily", "headerSpec", " headerNAME", "headingLetter"], "out": ["t", "tmp", "io", "can", "write", "in", "stream", "help", "os", "server", "comment", "auto", "log", "print", "inner", "aos", "ent", "flush", "console", "at", "sys", "client", "check", "res", "conv", "up", "n", "co", "pretty", "init", "timeout", "all", "o", "set", "net", "cn", "outs", "Out", "output", "ex", "null", "to", "table", "writer", "s", "ou", "source", "OUT", "outer"]}}
{"id1": "14865947", "id2": "3756429", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"execute": [" command", "Command", " Run", " evaluate", "Exec", "run", "invoke", " executable", " executions", " resume", " Exec", " interpret", " execution", " manage", " Execution", "Action", "command", "exec", " parse", " dispatch", " executed", " operate", " executing", " executes", "process", " query", " proceed", " eval"], "event": [" command", "t", "ae", "ev", "te", "se", "ce", "Event", " Event", "Ev", "xe", " invocation", " frame", "de", " events", "command", " EVENT", "pe", "exc", "frame", "w", "context", " environment", "ex", "ee", "E", "EE", "ed"], "shell": ["sb", "scroll", "history", "ja", "widget", "fr", "buffer", "pty", "detail", "range", "nl", "quit", "js", "tree", "html", "scope", "help", "stack", "base", "bot", "ssh", "pool", "l", "b", "cell", "body", "session", "console", "Shell", "tools", "sys", "cli", "grid", "line", "theme", "kernel", "screen", "windows", "handle", "root", "layout", "search", "template", "query", "hl", "lock", "message", "sql", "tab", "hell", "microsoft", "tool", "round", "sh", "h", "style", "sol", "window", "system"], "view": ["version", "VIEW", "widget", "cv", "v", "buffer", "View", "views", "tree", "html", "ui", "eye", "document", "image", "review", "vp", "web", "browser", "iew", "vm", "screen", "layout", "ve", "list", "template", "query", "row", "w", "tv", "block", "display", "report", "show", "see", "ou", "window"], "rootFolder": ["rootLibrary", "parentDir", " rootEntry", "bottomFolder", "parentEntry", "coverLibrary", "bottomDisk", "RootDir", "rootDirectory", "coverDirectory", "rootDisk", " rootDirectory", "rootArea", " rootDir", "RootDirectory", " rootCategory", "RootEntry", "rootCategory", " rootDisk", "rootEntry", "RootFolder", "parentDirectory", "bottomLibrary", "rootDir", " rootLibrary", "coverFolder", "parentArea", " rootArea", "parentFolder", "coverDisk", "RootArea", "bottomDirectory", "RootCategory", "parentCategory"], "dialog": ["dialj", "choDialog", "closer", "dializ", "Dialogs", "Dializ", "logDialog", " Dialj", "dialDialog", "selectDialog", "selectoser", " Dialoc", "callog", "callDialog", "clDialog", "selectig", "dialoser", " Dializ", "dliz", "selectog", "logoser", "logog", "callogs", "Dialoc", "dlog", "logig", "callOG", "clog", "choogs", "dialOG", "Dialj", "Dialog", "dialogs", "dialig", "clig", " Dialog", "dlj", "choog", "DialOG", "DialDialog", "dloc", "choOG", "dialoc"], "password": ["encrypted", "request", "buffer", "padding", "secret", "wd", "PASS", "data", "key", "user", "comment", "attribute", "raw", "username", "phrase", "prefix", "expression", "language", "picture", "sword", "string", "pattern", "definition", "hash", "path", "device", "database", "address", "login", "command", "shadow", "pass", "clear", "p", "paste", "description", "words", "hello", "directory", "query", "response", "message", "entry", "reset", "table", "word", "source", "Password"], "md5": ["mb2", "md6", " md512", "mm6", " md64", "MD64", "ma2", "MD7", "mm5", "MD512", "mt5", "ma64", "md512", "mt4", "md64", "mt2", "MD3", "mb512", "m4", "md3", "mt3", " md6", "md7", "m5", "mm7", "mb4", "m3", " md4", " md2", "mb5", "mm2", "ma7", " md7", "MD4", "MD2", "m2", "MD5", "ma5", "MD6", "md2", "md4"], "md": ["pm", " Md", "bd", "MD", "ct", "dh", "pdf", "det", "cd", "dr", "sd", "sm", "mt", "ind", "mod", "pt", "dd", "hd", "mc", "dig", "cmd", " dd", "df", "mk", "mb", "nd", "dm", "hash", "mac", "de", "magic", "pd", "nt", "metadata", "d", "ld", "rm", "mn", "od", "m", "red", "msg", "mm", "mg", "ms"]}}
{"id1": "15797402", "id2": "838844", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"parse": ["save", "scale", "create", "read", "write", "close", "build", "se", "patch", "interpret", "print", "add", "dump", "parser", "render", "transform", "shape", "split", "slice", "map", "format", "handle", "p", "pe", "use", "load", "execute", "tag", "php", "ping", "apply", "process", "filter", "xml", "resource"], "stream": ["sync", "content", "reader", "buffer", "read", "instance", "in", "cont", "stack", "data", "archive", "upload", "length", "file", "test", "download", "document", "image", "ream", "zip", "console", "input", "open", "chain", "handle", "url", "http", "Stream", "channel", "event", "sample", "sequence", "response", "output", "message", "resource", "clean", "window", "source", "form", "iterator"], "handler": ["reader", "worker", "ctx", "host", "connection", "server", "controller", "pool", "loader", "parser", "storage", "shape", "application", "policy", "address", "hand", "handle", "password", "wrapper", "processor", "service", "event", "hander", "message", "Handler", "function", "resource", "writer", "callback", "h", "management"], "metadata": ["meta", "content", "managed", "MD", "pdf", "details", "detail", "memory", "general", "manager", "td", "ctx", "data", "parts", "unknown", "md", "mt", "document", "image", "dd", "google", "common", "still", "definition", "hold", "policy", "java", "adata", "material", "tar", "mem", "handle", "property", "json", "properties", "info", "template", "module", "basic", "message", "met", "dirty", "m", "config", "xml", "management", "header", "iterator"], "context": ["content", "location", "usage", "instance", "state", "translation", "dict", "sc", "ctx", "stack", "connection", "ce", "collection", "document", "component", "options", "cc", "Context", "environment", "chain", "command", "reason", "network", "frame", "template", "module", "event", "local", "response", "sequence", "condition", "null", "config", "resource", "current", "set", "system"], "name": ["version", "create", "named", "type", "default", "Name", "nl", "key", "data", "part", "id", "lower", "comment", "base", "file", "ame", "image", "l", "prefix", "common", "body", "string", "client", "none", "path", "no", "time", "family", "alias", "title", "reason", "term", "n", "old", "on", "url", "NAME", "pass", "description", "names", "all", "len", "service", "value", "channel", "local", "size", "null", "label", "nm", "resource", "current", "source", "filename", "system"], "out": ["io", "v", "in", "po", "user", "col", "auto", "external", "OU", "file", "print", "serv", "flush", "sys", "cmd", "oss", "res", "obj", "conv", "up", "n", "url", "co", "all", "list", "o", "conf", "net", "gen", "con", "one", "cn", "outs", "it", "Out", "output", "sum", "lay", "ex", "null", "to", "cos", "us", "writer", "table", "ou", "aos", "OUT", "outer"]}}
{"id1": "4056444", "id2": "18358467", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": [" hashUser", "updatePassword", "HashPassword", " hashpassword", "HashUser", " hashText", "Hashpassword", "updatepassword", "hashpassword", "updateUser", "hashText", "HashText", "hashUser", "updateText"], "password": ["text", "wd", "secret", "padding", "PASS", "account", "default", "data", "key", "user", "attribute", "username", "phrase", "prefix", "expression", "sword", "string", "pattern", "input", "email", "database", "address", "name", "login", "command", "shadow", "pass", "p", "present", "description", "token", "hello", "value", "required", "w", "message", "report", "reset", "random", " Password", "word", "Password"], "md": ["pm", " Md", "bd", "MD", "dh", "det", "cd", "med", "dr", "sd", "sm", "sam", "mand", "mt", "ind", "mod", "add", "dd", "hd", "del", "sha", "mc", "cmd", "df", "mk", "mb", "dm", "mo", "pd", "grad", "d", "hed", "der", "di", "ld", "mn", "od", "cm", "desc", "m", "sh", "red", "ad", "mm", "db", "mg", "ms"], "hash": ["version", "secret", "bh", "build", "score", "state", "html", "id", "user", "full", "ash", "test", "file", "print", "has", "mod", "Hash", "hex", "username", "string", "dig", "sha", " hashing", "crypt", "mask", "index", "cache", "check", "mac", "address", "map", "name", "format", "handle", "shadow", "array", "hed", "all", "token", "search", "value", "row", "block", "message", "sum", "char", "sh", "filter", "h", "code", "auth", "key"]}}
{"id1": "20024612", "id2": "14619453", "code1": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"parse": ["save", "fork", "request", "read", "build", "se", "data", " parsing", "file", "print", "construct", "parser", " parser", "open", "format", "handle", "start", "feed", "init", "execute", "load", "search", "Parser", "launch", "process", "reset", "handler"], "br": ["fr", "bd", "ctr", "vr", "reader", "gr", "Br", "ger", "bm", "bh", "dr", "shr", "arr", "bs", "mr", "nr", "bf", "lr", "pr", "bre", "b", "bt", "bc", "wr", "ber", "brace", "yr", "r", "browser", "eb", "tr", "adr", "hr", "bl", "rb", "buf", "bridge", "bro", "be", "bp", "rel", "shell", "cr", "sp", "bsp", "BR", "bn", "ren", "kr"], "httpStream": ["upperBody", " httpSteam", "upperStream", "ttpStream", "ttpSteam", "feedSocket", "httpsStreamer", "feedSteam", "feedStreamer", "xmlConnection", "upperConnection", "httpSteam", "httpsSocket", " httpContext", "upperSteam", "hrSteam", "feedStream", "httpsStream", "xmlSteam", "ttpData", "xmlContext", " httpData", "hrStream", "httpBody", "httpContext", "hrSocket", "hrStreamer", "httpStreamer", "upperData", "ttpBody", "xmlStream", "upperContext", "httpData", "httpsSteam", " httpConnection", "httpConnection", " httpBody", "httpSocket"], "fileURL": [" fileLocation", " fileUrl", "fileLocation", "urlSSL", "FileUrl", "FileSSL", "fileUrl", "FileLocation", "fileSSL", "fileSR", "FileSR", "FileURL", "urlSR", " fileSR", "urlLocation", "urlUrl", " fileSSL", "urlURL"], "urlConnection": ["httpConnect", "urlConnect", "fileconnection", " urlconnection", "urlconnection", "httpconnection", "webConnect", "fileClient", "httpClient", "URLConfiguration", "fileConnection", "URLConnect", "URLConnection", "fileConnect", " urlConnect", "urlClient", "webConnector", "URLConnector", " urlConnector", "webConfiguration", " urlClient", "webConnection", "urlConfiguration", " urlConfiguration", "httpConnection", "urlConnector"], "ligne": ["slenge", "liorde", "lysis", "slotto", "liiner", "jlanguage", "llien", "sladr", " ladr", "gligne", "liotto", "liesson", "lwine", "llade", "lige", "liene", "lubric", " lesson", "lligation", "liigne", "laxy", " lorde", "llazy", "rladr", "giner", "ylourse", "clagen", "elligation", "ladr", "gigne", "jligne", "liounge", "vysis", " longe", "alounge", " lien", "jlene", " liven", "iladr", "gesson", " lene", "lazy", "llounge", "lladr", "jlagen", " lenge", "cligne", "lien", "alonge", "alige", "yladr", "aliner", "llonge", " lade", "liner", "bligne", "ligation", "lade", "liwine", "lounge", "clubric", "liroit", " ligation", "rliner", " lubric", " lardi", "jlonge", "liysis", "gourse", "elligne", "ylroit", "vigne", "lliner", "slaxy", " lourse", "ellourse", "lenge", " line", "lionge", "iliner", "jlige", "liven", "liubric", " lige", "lorde", "liige", "language", "liardi", "viner", "line", "lesson", "ylige", "longe", "vonge", "glounge", "lene", "ylazy", "slubric", "blounge", "aligne", "sligne", "blige", "llenge", "lotto", "bliner", "ilien", "sline", "jligation", " lotto", "lroit", "glien", "jliner", " laxy", "lligne", "liadr", "liiven", "llaxy", "jlubric", "slige", "rligne", "lagen", " language", " lounge", "slardi", "liade", " lroit", "yliner", "liourse", "yligne", "slourse", " lagen", "rlorde", "lardi", " lwine", "slounge", "slonge", "bline", "sliven", "gligation", "llourse", "llubric", "llige", "bladr", "iligne", "ellwine", "clanguage", " lazy", "liigation", "llysis", " liner", "lourse"], "post": ["ip", "save", "text", "pres", "pid", "ps", "type", "posts", "patch", "data", "po", "back", "id", "col", "comment", "tt", "pos", "log", "mod", "add", "prefix", "draw", "pg", "pt", "body", "proc", "put", "index", "zero", "time", "POST", "Post", "title", "op", "name", "son", "url", "p", "pass", "pl", "wp", "row", "ost", "pre", "tim", "pp", "code", "port", "parent", "zip", "hot", "page", "key", "form"], "date": ["day", "create", "zone", "type", "week", "te", "state", "debug", "age", "no", "due", "cal", "data", "md", "comment", "ate", "log", "file", "Date", "now", "add", "mate", "draw", "year", "result", "dt", "string", "update", "dig", "bon", "oday", "grade", "index", "days", "time", "dated", "duration", "dates", "end", "mail", "title", "today", "dat", "name", "note", "reason", "late", "me", "month", "get", "pe", "notice", "diff", "json", "number", "set", "tag", "event", "pose", "local", "trade", "change", "code", "page", "when", "night"], "titre": ["ptittbre", "Tittbre", " titere", "Tittrie", "ptitre", "totr", "tittbre", "nitre", "tipRE", "tistrie", "tuitere", "titr", "nittrev", " tolitbre", "titsre", "titerrie", "titerrate", "nitRE", "ltitre", "nittre", "tuitre", "titsres", "totr\u00e9", "titar\u00e9", "ltitere", " tolitre", "ptittrie", "tolitrer", "titarer", "titare", "tolitbre", "tuitrev", "tipres", "ltittr", "tittr\u00e9", "ptittrate", "Tittres", "tiprer", "tittere", "titbre", "tuitRE", "tistbre", "tittRE", " tolitrer", "nitrev", "Tittre", "tittre", "tolitre", "titerie", "titerbre", "titere", "ltitr\u00e9", "totere", "titar", "tolitere", "titerre", "tITre", "ltitr", "TittRE", "tITbre", " titbre", "titrate", "TitRE", "titr\u00e9", "titrer", "tittrate", "titsbre", "tITere", "titabre", "Titre", "tittr", "tipere", "ptitrate", "ltittr\u00e9", " tolitere", "nittRE", "titeres", "tipbre", "ltittere", "titsrie", "titrev", "ltittre", " titrer", "tistrate", "tittres", "tipre", "tittrev", "Titrie", "nittere", "Titbre", "ptittre", "Titres", "tITRE", "titebre", "tittrie", "titaere", "ptitrie", "nitere", "titrie", "tITres", "ptitbre", "titRE", "totre", "tistre", "titres", "tITrev"], "resume": ["REServe", "RESume", "preserve", "Reserve", "Resolve", "RESumption", "presume", "resumption", "presolve", "Resume", "resolve", "RESolve", "presumption", "Resumption", "reserve"], "url2DL": ["url2FL", "url5FL", "url2DR", "Url4DD", "url2DM", "url7DS", "url12DB", "url22DR", "url12DS", "url5TL", "url5DB", " url2FL", "url5DR", "url1DL", "url4DD", "Url2DD", " url5FL", "url4DM", " url5DD", " url1dl", "url02dl", " url5DB", "url3LL", "Url2DR", "url5DL", "url7DB", "url02LL", " url5DM", " url5DL", "url4TL", "url2LL", " url2DB", " url2TL", "url2DS", "url2dl", "url4DR", "url22LL", "url2URL", " url1DL", "url5DD", " url2URL", " url2dl", "Url2LL", " url2DS", "url02DL", " url2DD", "url1URL", "url4LL", "url12DL", "url4DL", "url2DB", "url2DD", "url5DM", "Url2DL", "url22DL", "Url4LL", "url1LL", "url3dl", "url5LL", "url7DL", " url2LL", "url2TL", "url02URL", "url3URL", " url2DM", " url5TL", "url3DL", "url5DS", "url1dl", "url7DD", "url4FL", "Url4DR", "url12DD", "url22DD", " url5DS", " url1LL", "Url4DL", " url1URL"]}}
{"id1": "2518655", "id2": "15500892", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"fnOut": ["bfOut", "bfNet", "bfIn", " fnNet", "synOut", "synIn", "pdfOs", "pdfNet", "pdfOut", "fnNet", "dnOutput", "synOr", "fnOr", "dnIn", " fnOs", "fnOutput", " fnOutput", "fnOs", " fnOr", "synOutput", "pdfIn", "fnIn", "bfOs", "dnOut", "dnOr", " fnIn"], "writer": ["written", "println", "widget", "reader", "window", "buffer", "write", "rator", "worker", "close", "commit", "comment", "auto", "external", "file", "print", "inner", "and", "loader", "flush", "console", "parser", "creator", "client", "white", "driver", "operator", "zero", "riter", "writing", "format", "variable", "builder", "width", "maker", "journal", "caster", "send", "her", "wrapper", "writ", "Writer", "wright", "service", "w", "runner", "writers", "report", "walker", "master", "handler", "table", "aster", "fn", "outer", "editor"], "i": ["ip", "c", "li", "y", "v", "bi", "ii", "phi", "multi", "key", "xi", "I", "u", "id", "ui", "ind", "mi", "iu", "ski", "batch", "gu", "ogi", "gi", "uri", "im", "q", "hi", "client", "x", "is", "ki", "ti", "ie", "ci", "pi", "chain", "ij", "me", "qi", "si", "init", "ix", "di", "ma", "ini", "ims", "ei", "it", "sim", "j", "my", "\u0438", "m", "ai", "g", "us", "ic", "ri"], "fInput": [" fIn", "linput", "sfInput", "cfNew", "fOutput", "sfOutput", " finput", "fileIn", "cfinput", "fileinput", "sfIn", "cfInput", "fileOutput", "sfinput", "finput", "lNew", "lInput", "lOutput", "fIn", "cfOutput", "fNew", " fOutput", "fileInput", " fNew"], "in": ["t", "bin", "din", " din", "or", "re", "inc", "isin", "rin", "ind", "en", "inner", "ln", "serv", "inf", "inside", "vin", "out", "r", "client", "is", "pin", "input", "check", "al", "conv", "In", "n", "thin", "gin", "ma", "all", "info", "ini", "IN", "conf", "con", "it", "ins", "inn", "cin", "again", "sin", "kin"]}}
{"id1": "884867", "id2": "7499186", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"zipname": ["polyName", "zipsize", "gzroot", "zeName", "downloadname", "archiveout", " zipbase", "tarroot", "tarsize", " zipnamed", "zename", "polyfilename", "downloadfilename", "tarname", "znamed", "tarnamed", " zipsize", " ziproot", "gzname", "archiveName", "zipbase", "zfilename", "downloadName", "archivebase", "archivename", "polyname", "downloadnamed", "zipnamed", "zname", "ziproot", "gznamed", "zipName", "gzsize", "zName", "polynamed", "zebase", " zipName", "zeout", "zipfilename"], "zipout": [" zipgen", "zall", "Zipin", " zipclient", "gzOut", "zipclient", "gzin", "gzobj", "gzout", "Zipoutput", "zin", "zn", "zipion", " zipin", "zobj", "gzion", "Zipname", "zipn", "zipin", "zipoutput", "gzall", " zipobj", " zipion", "sendoutput", "zipall", "gzgen", " zipoutput", "sendclient", "sendn", "sendin", "zOut", " zipall", "zion", "sendname", "zipobj", "zout", "zname", "zipOut", " zipOut", "sendout", "zgen", "Zipn", "Zipclient", "zipgen", "Zipout"], "out": ["t", " output", "ac", " outs", "en", " abort", " manager", " OUT", "cmd", "up", "on", "init", "list", "conf", " say", "con", "output", "Out", "ins", "null", "g", "writer", "io", "conn", "auto", "inner", "sys", "client", "oss", "o", "gen", "net", "group", "ou", "aos", "by", "can", "os", "ln", "inf", "at", "ent", "gt", "opt", "screen", "nt", "p", "pretty", " sys", "cn", "gov", "to", "msg", "set", "OUT", "cfg", "inv", "str", " bout", "log", " fmt", "go", "print", "dt", "res", "obj", "name", "n", "co", "all", "one", " Out", "w", "ch", "desc", "outs", "ex", "cos"], "buffer": ["history", "memory", "binary", "Buffer", "stack", "pad", "tree", "buff", "comment", "total", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "button", "bar", "queue", "line", "library", "cache", "database", "command", "variable", "mem", "buf", "paste", "frame", "template", "row", "sequence", "block", "message", "append", "output", "table", "filter", "window", "page"], "in": ["reader", "bin", "read", "din", "bi", "or", "ac", "by", "inc", "isin", "rin", "ind", "en", "inner", "inf", "im", "iter", "mc", "is", "input", "check", "nin", "pi", "up", "In", "on", "get", "gin", "per", "ma", "init", "info", "ini", "IN", "query", "like", "con", "it", "from", "ins", "ex", "inn", "cin", "ai", "i", "mm", "ic", "oin", "form", "and"], "length": ["version", "history", "count", "ENGTH", "type", "Length", "bow", "read", "needed", "frequency", "padding", "phi", "point", "volume", "tail", "space", "total", "full", "loc", "collection", "available", "component", "print", "join", "integer", "language", "string", "shape", "impl", "distance", "no", "library", "shift", "duration", "family", "database", "maximum", "position", "capacity", "amount", "present", "len", "load", "height", "depth", "number", "value", "match", "hello", "character", "size", "reading", "sequence", "message", "vector", "display", "angle", "ength", "code", "class"]}}
{"id1": "10131427", "id2": "16572931", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyfile", "CopyStream", " copyStream", " cpStream", " cpfile", "CopyImage", " CopyStream", " Copyfile", " cpImage", "CopyFile", "Copyfile", " CopyImage", " cpFile", " copyImage"], "in": ["din", "inc", "isin", "rin", "ind", "el", "en", "l", "b", "inf", "vin", "r", "is", "input", "up", "In", "n", "on", "old", "gin", "edIn", "o", "IN", "it", "st", "from", "ar", "ins", "inn", "cin", "i", "mm", "ic", "s", "source"], "out": ["t", "io", "v", "po", "ne", "help", "os", "str", "log", "file", "l", "b", "serv", "gt", "ot", "oss", "check", "err", "nt", "n", "o", "net", "w", "outs", "it", "ch", "output", "Out", "ex", "to", "i", "s", "ou", "OUT"], "sourceChannel": ["SourceStream", "matchButton", "matchChannel", "ourceChannel", " sourceConnection", "seedApplication", "Sourcechannel", "inputChannel", "SourceChannel", "sourceButton", "sourcechannel", "srcchannel", "srcStream", "ourceStream", "sourceStream", "SourceConnection", "sourceChain", "ourceChan", "resourceChannel", "resourceStream", " sourceButton", "seedChannel", "seedChuck", "sourceChan", " sourceChain", "resourceConnection", "srcButton", "inputConnection", "inputChan", "seedButton", "singleChuck", " sourceStream", " sourcechannel", "singleApplication", "srcChannel", "singleChannel", "singleButton", "ourceChain", "matchApplication", "sourceConnection", "inputChain", "sourceApplication", " sourceChan", "ourceButton", "sourceChuck", "resourcechannel", "ourcechannel", "ourceConnection", "matchChuck"], "destinationChannel": ["DestinationConnection", "DestinationContext", "desticationBlock", "destinatoryBlock", "DestationConnection", "destroyChan", "destationCow", "destensionChan", "desticationChan", "DestationChan", "destationBlock", "destinationChan", "DestinationCow", "destinatoryCow", "destroyConnection", "DestensionClient", "destationContext", "destroyClient", "DestationContext", "destinationsConnection", "destinationContext", "destinationsChan", "DestinationChan", "destinatoryChan", "DestinationClient", "destensionChannel", "destinationConnection", "DestationCow", "destationConnection", "DestensionConnection", "destationChannel", "destensionConnection", "destinationsChannel", "DestensionChan", "DestationChannel", "destinatedContext", "DestensionChannel", "destinatedChannel", "DestinationBlock", "destensionClient", "DestationBlock", "destinatoryChannel", "destinationBlock", "destinationCow", "destinationClient", "desticationCow", "DestinationChannel", "destinatedChan", "destinationsContext", "destationChan", "destroyChannel", "destationClient", "destinatedConnection", "desticationChannel"]}}
{"id1": "21979462", "id2": "7809093", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURL2JSON", " downloadURL2String", " downloadurltoString", " downloadurloJSON", " downloadURLToText", " downloadURLtoJSON", " downloadurloBytes", " downloadurloText", " downloadurltoBytes", " downloadURLToBytes", " downloadurloString", " downloadURLoBytes", " downloadurltoText", " downloadURLoJSON", " downloadURLToJSON", " downloadurltoJSON", " downloadURLtoText", " downloadURLToString", " downloadURLtoBytes", " downloadURL2Bytes", " downloadURLoText", " downloadURL2Text", " downloadURLoString"], "url": ["dl", "location", "ul", "run", "mount", "base", "id", "log", "file", "l", "gl", "web", "uri", "ssl", "browser", "ls", "job", "mail", "ref", "sl", "address", "uu", "name", "bel", "un", "ur", "http", "all", "ll", "link", "domain", "ret", "URL", "char", "resource", "Url", "rect"], "in": ["io", "reader", "bin", "read", "din", "copy", "or", "re", "inc", "isin", "ind", "ill", "inner", "inf", "mc", "out", "is", "input", "check", "al", "up", "er", "In", "on", "thin", "gin", "ma", "all", "info", "conf", "IN", "mn", "con", "it", "sum", "from", "ins", "inn", "cin", "ai", "again", "i", "ic", "oin", "by", "and"], "sb": ["lb", "zb", "lp", "bg", "bd", "sg", "pa", "wb", "bh", "bs", "sd", "bf", "sk", "sam", "rob", "bis", "sq", "b", "bt", "ib", "sa", "ab", "ssl", "mb", "eb", "gc", "cb", "SB", "rb", "gb", "erb", "pb", "nb", "bj", "kb", "xb", "bp", "db", "gob", "sf", "sp", "bsp", "bn", "ub", "bb"], "str": ["text", "fr", "t", "gr", "dr", "Str", "arr", "re", "part", "comment", "div", "print", "l", "b", "comm", "bc", "pt", "next", "iter", "string", "del", "r", "ls", "tr", "br", "err", "obj", "sl", "bl", "chain", "dat", "n", "req", "exec", "p", "comp", "expr", "cur", "list", "STR", "sts", "ch", "vol", "sp", "st", "char", "j", "block", "cat", "syn", "m", "msg", "i", "s", "cont", "source", "set", "def", "txt"]}}
{"id1": "3683344", "id2": "17190057", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandomSID", " genRandomGuid", " genRandomGU", " genRandUID", " genRandGU", " genRandomSUID", " genRandomUU", " genRandUUID", " genRandomRandomUID", " genRandUuid", " genRandomUUID", " genRandGID", " genRandomSuid", " genRandomRandomuid", " genRandomRandomID", " genRandomGID", " genRandUU", " genRandomRandomU", " genRandomUID", " genRandomSU", " genRandGuid", " genRandomUuid", " genRandGUID"], "secure": ["sync", "confirmed", "encrypted", "deep", "sr", "stable", "close", "status", "speed", "nice", "active", "id", "server", "prime", "trust", "free", "google", "https", "sys", "client", "ssl", "security", "ie", " Secure", "check", "Secure", " insecure", "clear", "safe", "pretty", "sensitive", "strong", "sec", "force", "protect", "domain", "weak", "quiet", " securely"], "valueBeforeMD5": ["valueBeforeMOD2", "valueBeforeMT5", "valueAfterDER0", "valueBeforeND5", "valueAfterMD2", "valueAfterMDInvalid", "valueBeforeID3", "valueBeforeMOD0", "valueUnderMM5", "valueBeforeID5", "valueAfterMD3", "valueBeforeRD5", "valueBeforeDERFive", "valueAfterDERFive", "valueAfterMD4", "valueBeforeND3", "valueAfterND3", "valueBeforeMT25", "valueBeforeMD3", "valueBeforeND2", "valueAfterND4", "valueBeforeMDFive", "valueUnderMM25", "valueBeforeSHA523", "valueBeforeMDInvalid", "valueUnderMD0", "valueBeforeRDInvalid", "valueBeforeMM0", "valueBeforeID2", "valueBeforeMD25", "valueBeforeMM5", "valueBeforeDER5", "valueUnderMD25", "valueBeforeSHAInvalid", "valueAfterMD0", "valueBeforeND0", "valueBeforeID4", "valueBeforeMOD5", "valueBeforeSHA2", "valueBeforeND4", "valueBeforeMODFive", "valueBeforeMT0", "valueAfterMDFive", "valueBeforeRD523", "valueBeforeRD2", "valueBeforeMTFive", "valueAfterND5", "valueUnderMD5", "valueAfterDER5", "valueBeforeMD0", "valueAfterDER2", "valueBeforeMD4", "valueBeforeND25", "valueBeforeMD2", "valueBeforeMD523", "valueUnderMM0", "valueBeforeMM25", "valueAfterMD523", "valueBeforeDER0", "valueAfterND2", "valueBeforeSHA5", "valueBeforeMT2", "valueBeforeDER2"], "valueAfterMD5": ["valueAfterMD8", "valueAftermd5", "valueAfterMCdown", "valueAfterMC3", "valueAfterMD55", "valueAftermd2", "valueAfterSDRL", "valueafterMD5", "valueAfterMD2", "valueWithoutMD5", "valueAfterMM5", "valueAfterMD3", "valueafterEM55", "valueAfterMD4", "valueAfterMM3", "valueAfterMT5", "valueafterMDLeft", "valueWithoutMDPE", "valueBeforeMD3", "valueWithoutmdOK", "valueWithoutMD2", "valueAfterMI5", "valueBeforeMM2", "valueAfterMIPE", "valueAfterMM2", "valueBeforeMM4", "valueBeforeMC2", "valueAfterMDODY", "valueAfterMDRL", "valueafterEM2", "valueAfterCDdown", "valueAfterUDRL", "valueAfterUD3", "valueAftermdOK", "valueAfterEMLeft", "valueBeforeMM5", "valueAfterEM55", "valueAfterSD5", "valueAfterEM2", "valueBeforeMDODY", "valueWithoutmd5", "valueAfterMDPE", "valueAfterMTdown", "valueAfterMDOK", "valueAfterMDdown", "valueAfterMC2", "valueAfterUD5", "valueAfterUDODY", "valueAfterSD3", "valueAfterMC4", "valueAfterSDODY", "valueafterEM5", "valueAfterMT8", "valueWithoutmdPE", "valueAfterEM5", "valueBeforeMM3", "valueafterMD2", "valueAfterMIOK", "valueBeforeMD8", "valueAfterMM4", "valueAfterMT2", "valueAfterMT55", "valueAftermdPE", "valueWithoutMDOK", "valueAfterMI2", "valueAfterMT3", "valueWithoutmd2", "valueBeforeMDRL", "valueBeforeMD4", "valueBeforeMDdown", "valueBeforeMCdown", "valueBeforeMD2", "valueafterMD55", "valueAfterMC8", "valueAfterCD2", "valueAfterMDLeft", "valueBeforeMC5", "valueAfterCD5", "valueAfterMTLeft", "valueafterEMLeft", "valueAfterMC5"], "md5": ["MD25", " md3", "metadata2", "metadata25", "md25", "MD7", " MD7", " MD3", "MD3", "md3", "md7", "metadata3", " MD2", " md2", "metadata5", " MD5", "dig2", " md7", "MD2", "dig3", " md25", "MD5", "dig5", "md2"], "sbValueBeforeMD5": ["sbValueBeforeMD20", "sbValueBeforeAMD305", "sbValueDefMD2", "sbValueAfterMS3", "sbValueBeforeMOD5", "sbValueBeforeMOD45", "sbValueAfterMD45", "sbValueBeforePDLE", "sbValueBeforeMDOK", "sbValueBeforeAMD5", "sbValueBeforeMS5", "sbValueBeforeMDLE", "sbValueInsideAMD512", "sbValueBeforeND45", "sbValueFrontMD65", "sbValueDefMD45", "sbValueBeforeLM20", "sbValueBeforeMOD25", "sbValueAfterMD25", "sbValueBeforemd5", "sbValueBeforeAND2", "sbValueBeforeMD65", "sbValueFrontMD5", "sbValueBeforeMD3", "sbValueBeforemdLE", "sbValueBeforeANDFive", "sbValueBeforeLM5", "sbValueBeforeMT5", "sbValueBeforeMD305", "sbValueAfterMD5", "sbValueAfterMD05", "sbValueFrontMD20", "sbValueBeforeAND5", "sbValueBeforeND2", "sbValueInsideMD2", "sbValueBeforeMT20", "sbValueBeforemdOK", "sbValueBeforeMON305", "sbValueAfterMD2", "sbValueAfterMS45", "sbValueBeforeSD5", "sbValueBeforeAMD2", "sbValueBeforeMON512", "sbValueBeforeMD2", "sbValueInsideAMD5", "sbValueAfterMS25", "sbValueAfterMD3", "sbValueBeforeLM65", "sbValueBeforeMD05", "sbValueBeforeMD512", "sbValueBeforemd45", "sbValueBeforeMDFive", "sbValueDefmd2", "sbValueBeforeLM2", "sbValueInsideMD305", "sbValueBeforeAND05", "sbValueAfterMS5", "sbValueBeforeMS45", "sbValueBeforeMT2", "sbValueBeforeMED5", "sbValueBeforeMED25", "sbValueBeforeMS3", "sbValueDefmd45", "sbValueBeforePD2", "sbValueAfterMDOK", "sbValueFrontMD2", "sbValueFrontLM20", "sbValueFrontLM5", "sbValueBeforeMD25", "sbValueBeforeMT05", "sbValueBeforeAMD512", "sbValueBeforeMDNot", "sbValueBeforemd2", "sbValueInsideMD5", "sbValueAfterMDNot", "sbValueBeforeMTFive", "sbValueBeforeMOD3", "sbValueBeforeSDNot", "sbValueBeforeMD45", "sbValueBeforeMED3", "sbValueBeforeMEDNot", "sbValueBeforeSD2", "sbValueDefMD5", "sbValueBeforeMED45", "sbValueBeforeMT65", "sbValueBeforeMON5", "sbValueFrontLM2", "sbValueAfterMDFive", "sbValueInsideMD512", "sbValueBeforePDOK", "sbValueInsideAMD2", "sbValueFrontLM65", "sbValueInsideAMD305", "sbValueBeforePD5", "sbValueBeforeND5", "sbValueAfterMDLE", "sbValueBeforeMS25", "sbValueDefmd5", "sbValueBeforeMON2", "sbValueBeforeMED2"], "time": ["estamp", "t", "Time", "ime", "clock", "age", "order", "TIME", "id", "length", "user", "total", "now", "ty", "year", "timer", "tc", "runtime", "duration", "counter", "hour", "name", "start", "rate", "date", "etime", "frame", "timeout", "value", "event", "size", "lock", "sequence", "tim", "port", "times", "ts", "window", "system", "race"], "rand": ["rid", "mid", "pid", "gz", "rd", "dr", "ng", "range", "max", "inv", "uid", "pick", "rot", "id", "reg", "md", "rest", "with", "trust", "fine", "did", "sys", "gt", "r", "Rand", "sid", "ripp", "hash", "nd", "res", "rc", "nt", "rh", "grad", "rate", "init", "rt", "frac", "dist", "kick", "sample", "rank", "std", "roll", "rss", "random", "z", "round", "cr", "seed", "and"], "array": ["angular", "stage", "save", "app", "binary", "v", "RAY", "instance", "arr", "range", "stack", "data", "rays", "archive", "external", "length", "ash", "batch", "collection", "assets", "at", "string", "storage", "audio", "ami", "hash", "our", "aw", "upper", "map", "var", "amount", "arrow", "atomic", "ray", "list", "value", "row", " Array", "number", "Array", "area", "vector", "ashes", "random", "angle", "share", "aster", "ary"], "strTemp": ["drTemp", "frTem", "txtTemp", "txtTem", "stringTest", "txtTr", "STRtemp", "strUnt", "STRNew", "hexTr", "arrTest", "stringTem", "strMods", "drTem", "stringTemp", "arrTemp", "strTest", "strTem", "frTemplate", " strCmd", "drPtr", "stringPtr", " strPtr", "hexTemp", "stringUnt", "strCmd", "arrTem", " strTr", "brTemp", "strTr", "arrtemp", "brPtr", "arrMods", " strNew", "arrNew", "txtCmd", " strTemplate", "hexCmd", "strPtr", "STRTem", " strTest", " strtemp", "strTemplate", "brTem", "frTemp", " strUnt", "hexTem", " strTem", "drMods", "STRTemp", "frPtr", "brTemplate", "arrUnt", "strNew", "arrPtr", "strtemp", "stringMods"], "i": ["c", "li", "y", "v", "bi", "in", "ii", "phi", "multi", "xi", "I", "u", "id", "ui", "ind", "mi", "b", "gu", "ogi", "gi", "uri", "im", "q", "hi", "cli", "x", "ki", "ti", "index", "ci", "pi", "chain", "ji", "name", "a", "iq", "qi", "si", "init", "ix", "di", "info", "ini", "ei", "num", "it", "yi", "sim", "j", "\u0438", "m", "ai", "us", "ic"]}}
{"id1": "3756429", "id2": "3184073", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"scramble": ["scambles", "scrambled", "screambled", "screamble", "scrimbling", " unscramble", "scamble", "scrimbled", "scrambles", " unscrambles", "scrimbles", " unscrambling", "scambling", " unscreamble", "scrambling", "screambles", "screambling", "scrimble", "scambled", " unscreambling", " unscreambles", " unscrambled", " unscreambled"], "text": ["aut", "content", "t", "object", "th", "buffer", "read", "str", "data", "html", "ext", "log", "tt", "test", "document", "print", "now", "TEXT", "body", "string", "source", "pattern", "input", "path", "title", "nt", "name", "command", "value", "template", "message", "output", "char", "act", "config", "code", "msg", "cont", "word", "Text", "txt"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "dr", "sd", "sm", "mand", "ind", "mt", "mod", "add", "dd", "hd", "mc", "sha", "cmd", "df", "mk", "mb", "dm", "mo", "pd", "nt", "material", "grad", " MD", "me", "mp", "d", "ma", "der", "ld", "rm", "mn", "od", "def", "met", "m", "sh", "red", "mm", "mg", "ms"], "sb": ["lb", "zb", "bg", "lp", "sg", "bd", "bh", "bs", "bf", "bis", "sq", "bt", "ib", "sa", "ab", "ssl", "mb", "eb", "sth", "cb", "ob", "obb", "SB", "sl", "rb", "soc", "gb", "erb", "nb", "pb", "bj", "kb", "xb", "abs", "bp", "obs", "gob", "shell", "sf", "sp", "bsp", "db", "ub", "bb"], "b": ["c", "B", "t", "v", "wb", "bi", "k", "bs", "u", "fb", "bc", "ib", "bt", "ab", "r", "eb", "cb", "br", "obj", "rb", "a", "n", "f", "d", "be", "gb", "o", "nb", "bp", "kb", "j", "m", "z", "code", "bit", "g", "s", "i", "bu", "db", "bb"]}}
{"id1": "1421557", "id2": "9846843", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "13946197", "id2": "5808579", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"transformByMD5": [" encryptByMCTime", " encryptbyMD5", " encryptBySMTime", " encryptBySM4", " encryptbymd5", " encryptByMDTime", " encryptByMD4", " encryptBymd7", " encryptbymdTime", " encryptBymd4", " encryptbymd7", " encryptByMD7", " encryptByMC7", " encryptbyMD7", " encryptBySM5", " encryptByMC5", " encryptBymd5", " encryptByMD5", " encryptByMC4", " encryptbyMDTime", " encryptbyMD4", " encryptBymdTime", " encryptbymd4", " encryptBySM7"], "password": ["text", "wd", "secret", "PASS", "padding", "account", "data", "user", "username", "phrase", "prefix", "sword", "pattern", "security", "hash", "path", "email", "database", "address", "name", "login", "command", "pass", "Password", "token", "description", "hello", "value", "w", " passwords", "message", "entry", " Password", "filename", "auth", "word", "key"], "md5": [" md3", "mdnt", " md10", "mand5", "MD7", "mdle", " MDle", " MD7", "mag2", " MD3", " MDnt", "MD3", "MDle", "mag3", "md3", "md7", "mand10", "MDhed", " MD2", " mdhed", " mdnt", "mdhed", "mag5", " md2", " MD5", "MD10", "dig2", " md7", "MD2", "mand2", " mdle", "md10", "maghed", "dig3", "MD5", "MDnt", "dig5", "mand3", "md2"], "output": ["respond", "text", "four", "exit", "results", "buffer", "write", "echo", "current", "view", "data", "answer", "column", "OU", "csv", "log", "file", "batch", "collection", "document", "print", "result", "web", "console", "out", "hidden", "STDOUT", "line", "input", "put", "Output", "successful", "accept", "export", " outputs", "PUT", "all", "list", "response", "block", "message", "display", " Output", "remote", "ou", "source", "outer"], "bufferPass": ["bufferAdd", "memorySe", " bufferSe", "bufPASS", "screenAss", "bufPass", " bufferCat", "BufferPASS", "batchPassword", "screenPassword", "bufCat", "bufDe", " bufferDe", "screenAdd", "sequenceAss", "sequencePassword", "memoryDe", "sequenceAdd", "BufferPass", " bufferAss", "sequencePass", "memoryEn", "batchpass", "bufferCat", "bufferDe", " bufferpass", "bufpass", "bufferSe", "memoryPass", "screenPass", "BufferPassword", "BufferCat", "bufferpass", " bufferEn", " bufferAdd", "batchPass", " bufferPassword", "Bufferpass", "bufferAss", "bufEn", "bufferEn", " bufferPASS", "bufferPASS", "bufferPassword", "bufSe"], "b": ["sb", "c", "B", "bg", "y", "v", "buffer", "bound", "wb", "bi", "emb", "k", "bs", "blue", "base", "u", "fb", "bis", "batch", "l", "bt", "ib", "bc", "e", "bar", "r", "mb", "cb", "ob", "rb", "a", "n", "p", "d", "be", "gb", "o", "nb", "w", "bp", "block", "j", "z", "m", "bit", "g", "h", "i", "bool", "db", "bb"]}}
{"id1": "14773780", "id2": "12883117", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 0, "substitutes": {"testImageInfo": ["checkPhotoData", "checkImageData", "checkPhotoInfo", " testPhotoFile", " testImageFile", " testPhotoList", "checkImageFile", " testImageData", " testImagesList", "checkImageList", " testPhotoData", " testImageList", "checkPhotoList", " testImagesInfo", "checkImageInfo", "checkPhotoFile", " testImagesFile", " testPhotoInfo", " testImagesData"], "IOException": ["APIEx", "IOProblem", "APIProblem", "IOEx", "APIException", "AudioEx", "AudioException", " IOProblem", "AudioProblem", " IOEx"], "start": ["starting", "parse", "t", "started", "create", "Start", "trans", "read", "base", "id", "begin", " Start", "rest", "print", "now", "before", "time", "check", "open", "step", "end", "art", "birth", "get", "send", "init", "first", "wind", "it", "size", "enable", "st", "from", " started", "wait", "reset", "offset", "seed", "set"], "i": ["li", "y", "bi", "in", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "mi", "go", "batch", "b", "gu", "gi", "im", "q", "out", "x", "is", "ti", "ic", "index", "major", "ci", "pi", "uu", "name", "iq", "conv", "n", "me", "p", "qi", "f", "init", "si", "ix", "di", "info", "o", "it", "yi", "sim", "j", "my", "ex", "m", "ai", "to", "g", "s", "us"], "url": ["dl", "location", "ul", "host", "nl", "mount", "str", "base", "id", "u", "external", "log", "el", "lr", "l", "gl", "web", "uri", "string", "q", "r", "pattern", "path", "ls", "res", "mail", "ref", "ur", "gif", "http", "ll", "link", "rel", "URL", "null", "resource", "xml", "Url", "key"], "istream": ["intable", "ISTorage", "astorage", "itiver", "intream", "istable", "iptorage", "istiver", "istroy", "astream", "itream", "astroy", "istorage", "itrace", "aststream", "iptstream", "istrace", "ISTroy", "ISTstream", "itable", "intrace", "ositable", "iststream", "intiver", "iptroy", "ositrace", "iptream", "ositiver", "ISTream", "ositream"], "ii": ["jj", "li", "ista", "imi", "iy", "xi", "nai", "II", "sci", "mi", "iu", "ati", "gi", "iov", "hi", "cli", "ami", "cgi", "iso", "ti", "ki", "iii", "ice", "ci", "oci", "pi", "ij", "irm", "ji", "vi", "iri", "qi", "ia", "ni", "cci", "si", "di", "ini", "ei", "chi", "obi", "yi", "ushi", "fi", "ai", "zi", "iti", "ri"], "width": ["text", "scale", "widget", "cale", "px", "write", "min", "data", "Width", "length", "idth", "left", "wid", "draw", "const", "body", "shape", "x", "path", "crop", "fw", "step", "format", "dim", "foo", "position", "weight", "layout", "cut", "dx", "tall", "wn", "frame", "len", "value", "wa", "size", "w", "area", "wy", "window"], "height": ["history", "gravity", "sky", "buffer", "kw", "padding", "volume", "length", "div", "dimension", "Height", "hang", "shape", "radius", "stroke", "above", "family", "green", "chip", "density", "capacity", "resolution", "amount", "rise", "frame", "acity", "depth", "size", "rank", "cue", "angle", "style", "alpha", "h", "window", "grow", "def"], "stop": ["est", "close", "quit", " Stop", "id", "rest", "delay", "next", "result", "pop", "shape", "pause", "jump", "no", "gc", "duration", "ops", "wake", "success", "step", "end", "counter", "obj", "term", "peak", "loop", "disable", "Stop", "termination", "hop", "delete", "set", "fin", "it", "enable", "st", "period", " STOP", "null", "wait", "trip", "skip"]}}
{"id1": "20210699", "id2": "15465293", "code1": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"getTicketsForQueue": ["getTicketsAllQuery", "getTicketsAllQueue", "getTicketsForqueue", "getTokensForqueue", "getTokensFromqueue", "getTokensForStore", "getTicketsFromQuery", "getTicketsAllqueue", "getTicketsFromQueue", "getTokensFromQuery", "getTicketsAllStore", "getTicketsWithStore", "getTicketsWithQueue", "getTicketsWithQuery", "getTokensFromStore", "getTokensForQueue", "getTicketsForQuery", "getTicketsFromqueue", "getTokensForQuery", "getTicketsForStore", "getTicketsWithqueue", "getTokensFromQueue", "getTicketsFromStore"], "queueName": ["QueueName", "tubeNames", "queueStart", " queuename", "queueNames", "poolNames", "queuename", "QueueStart", "QueueNames", "queueNAME", "poolNAME", " queueNames", "poolname", "QueueNAME", " queueNAME", "tubeName", "Queuename", " queueStart", "tubeStart", "poolName"], "limit": ["count", "top", "take", "max", "length", " Limit", "total", "batch", "l", "iter", "duration", "limited", "end", "n", "capacity", "start", "len", "Limit", "timeout", "size", "it", "lock", "wait", "offset", "filter", "limits", "page", "skip"], "params": ["pres", "terms", "gs", "np", "ps", "request", "details", "padding", "requires", "Parameters", "posts", "ctx", "multi", "parts", "points", "prop", "pos", "pins", "ports", "photos", "options", "marks", "pas", "changes", "as", "ams", "ops", "par", "AMS", "styles", "pi", "Par", "spec", "param", "pps", "mas", "actions", "pass", "p", "pretty", "media", "names", "caps", "helps", "pkg", "properties", "members", "conf", "packages", "settings", "fields", "orders", "groups", "keys", "limits", "pers"], "get": ["parse", "create", "request", "GET", "connection", "base", "this", "gets", "next", "post", "give", "body", "ge", "update", "put", "check", "open", "util", "name", "handle", "send", "http", "init", "delete", "find", "search", "service", "got", "query", "like", "execute", "force", "pre", "gm", "show", "call", "g", "Get", "resource", "see", "current", "set"], "tickets": ["tables", " tants", "ttants", "nickets", " tables", "ttents", " tents", "nants", "nables", "nents", "tants", "ttables", "ttickets", "tents"], "ticketIds": ["ticketByIdls", "ticketLogids", "ticketByIds", " ticketIdxs", "ticketCountids", "ticketCounts", "ticketIDids", "ticketIDsxs", "ticketLogls", "ticketLogxs", "ticketIDss", " ticketByIdings", "ticketIdls", "ticketByIdids", "ticketIdids", " ticketIdls", "ticketByIdxs", "ticketCountings", " ticketByIdids", " ticketByIdls", "ticketCountls", " ticketIdids", "ticketIdings", "ticketIDsls", " ticketByIds", "ticketIDls", " ticketByIdxs", "ticketLogs", "ticketByIdings", "ticketIDings", "ticketIDs", "ticketIDsids", " ticketIdings", "ticketIdxs"], "response": ["version", "reply", "respond", "content", "onse", "exit", "request", "close", "status", "re", "connection", "tree", "respons", "esp", "answer", "data", "server", "raw", "ception", "collection", "document", "image", "next", "trace", "result", "still", "body", "client", "out", "profile", "definition", "hash", "application", "res", "success", "successful", "resp", "description", "http", "frame", "json", "channel", "network", "block", "sequence", "output", "message", "report", "reset", "yes", "initial", "see", "Response", "remote", "error", "page", "summary"], "responseCode": ["responseNum", "responseChange", "replyActionCode", "replyNum", "responsecode", "statuscode", "answerChain", "answerActionCode", "entryCode", "replyChain", "statusCode", "statusC", "versioncode", "responseC", "entryChain", "answerNum", "answerChange", "answerLength", " responseLength", "answerCode", " responsecode", "responseLength", "entryActionCode", " responseChange", "responseChain", "answercode", " responseC", "versionCode", "responseActionCode", "versionC", "statusLength", "versionChange", "versionLength", "replyCode", "entryNum"], "isr": ["itsrc", "imsr", "itsr", "Ispr", " isrs", " iser", "iosrer", " isrer", "itsra", "oiser", "isrer", "itser", "isra", "imsrc", "israr", "oisr", "Israr", "ispr", "oisra", "risr", "imspr", "iosr", "issrs", "isp", "rispr", " isra", " isp", "isrc", "isor", "risrar", "risrer", "risp", "ioser", " isrc", "oisrc", "iser", "imsrar", "isrs", "iospr", "riser", "risrs", "risrc", "issr", "issor", "issp", "Isrc", " isor", "risor", " ispr", "Isr"], "br": ["sb", "fr", "bd", "ctr", "vr", "ger", "gr", "Br", "sr", "bm", "dr", "bh", "shr", "bs", "mr", "nr", "str", "bf", "lr", "pr", "bre", "b", "bt", "bc", "wr", "brace", "ber", "yr", "r", "browser", "tr", "adr", "hr", "rus", "bl", "rb", "buf", "bridge", "bro", "nah", "bp", "rel", "block", "cr", "Fr", "bsp", "BR", "bn", "kr"], "line": ["ip", "le", "detail", "lin", "lane", "inline", "point", "nl", "part", "data", "column", "comment", "log", "file", "liner", "LINE", "batch", "print", "l", "phrase", "ln", "continue", "e", "trace", "cell", "body", "iter", "Line", "eline", "lo", "string", "cmd", "out", "no", "job", "entity", "rule", "err", "chain", "ine", "name", "n", "note", "online", "train", "frame", "row", "query", "edge", "record", "link", "sample", "block", "sequence", "message", "valid", "lines", "entry", "stay", "label", "store", "port", "word", "page", "header"]}}
{"id1": "886783", "id2": "10176678", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"doGet": ["handleget", " doGET", "Doget", "DoPut", "DoGet", "doPut", "handleGET", "handleGet", "handlePut", "doget", "doGET", "DoGET", " doget", " doPut"], "lni": ["rne", " lti", "lti", "lne", "Lnis", "rni", "rnis", " lne", "slini", "Lne", " lnis", "slti", "slni", "Lti", "lini", "lnis", "rti", "Lni", "Lini", "slne", " lini"], "itemHandle": ["Itemhandle", "issueHandle", "ItemH", "ithandle", "itemhandle", " itemH", " itemHand", "issueH", "itID", "itemID", "itHand", " itemhandle", "ItemHand", "itHandle", "itemHand", "issuehandle", "ItemID", "ItemHandle", "issueID", "itemH", " itemID"], "packager": [" packenger", "packsager", "facager", "packsagers", "packaler", "packageagger", "packagger", "packageaging", "packsaler", "packaging", "packsagger", " packagger", "facenger", " packaler", "packenger", "packsenger", "packagers", " packaging", " packagers", "packageager", "packageagers", "facaler", "packsaging", "facagger"], "output": ["generated", "written", "text", "unit", "location", "buffer", "write", "current", "data", "key", "connection", "column", "OU", "log", "file", "print", "username", "region", "prefix", "temp", "string", "hidden", "client", "path", "input", "Output", "put", "name", "format", "handle", "absolute", "PUT", "target", "o", "directory", "value", "response", "message", "display", "ilo", "label", "page", "xml", "port", "resource", "ou", "error", "source", "filename", "outer"], "endpoint": ["beginpt", "beginpoints", "ndpoint", "endpoints", "beginPoint", "endspoints", "Endpoint", "beginpoint", "endpt", "Endpoints", "endspt", "ndpoints", "ndPoint", "endspoint", "Endpt", "endsPoint", "endPoint", "ndpt", "EndPoint"], "ProtocolException": ["proticationError", "ProtilingWarning", "protocolException", "protocolWarning", "ProticationException", "ProtocolError", "protocolError", "PrototypeError", "PrototypeException", "PrototypeWarning", "proticationException", "ProtilingError", "proticationWarning", "ProtocolWarning", "ProticationWarning", "ProtilingException", "ProticationError"], "IOException": ["NetworkException", "RuntimeOver", "RuntimeException", "NetworkOver", " IOGroup", " IOOver", "RuntimeGroup", "IOOver", "IOGroup", "NetworkGroup"], "FileNotFoundException": ["FileNotPresentWarning", "FileNotFound ", "FileAlreadyPresent ", "FileNotPresentError", "FileAlreadyFoundException", "FileAlreadyPresentWarning", "FileAlreadyFoundWarning", "FileNotFoundWarning", "FileAlreadyFound ", "FileNotPresentException", "FileAlreadyPresentException", "FileNotFoundError", "FileNotPresent ", "FileAlreadyPresentError", "FileAlreadyFoundError"], "itemURI": ["resourceURI", "storeURI", " itemURL", "storeuri", "resourceURL", "itemuri", "storeURL", "Itemuri", "resourceuri", "itemID", " itemuri", "ItemRI", "itemURL", "itemRI", "ItemURL", "storeRI", "ItemURI", " itemRI", "ItemID", "resourceID", " itemID"], "url": ["sb", "dl", "location", "org", "build", "ul", "rl", "re", "nl", "host", "str", "mount", "base", "html", "server", "this", "el", "log", "loc", "l", "web", "uri", "il", "parser", "q", "r", "cmd", "client", "ssl", "impl", "browser", "path", "ls", "gc", "res", "ref", "sl", "name", "term", "bel", "un", "ur", "handle", "get", "f", "pl", "http", "kl", "ll", "con", "domain", "abs", "sql", "URL", "char", "fl", "null", "xml", "Url", "key"], "conn": ["sync", "compl", "c", "ct", "org", "ann", "close", "enc", "cfg", "ctx", "cont", "connection", "Conn", "en", "jp", "comm", "pg", "cell", "pas", "cp", "sys", "client", "cmd", "ssl", "cert", "cb", "res", "open", "att", "err", "obj", "ws", "nt", "conv", "iw", "req", "exec", "typ", "resp", "init", "cur", "conf", "net", "gen", "con", "wp", "cn", "yn", "ch", "fin", "desc", "subject", "canon", "stat", "that", "syn", "socket", "act", "addr", "call", "ctrl", "msg", "auth", "db", "nc", "ns", "connect"], "status": ["version", "compl", "pres", "Status", "uses", "score", "state", "sc", " Status", "es", "re", "str", "html", "esp", "id", "server", "compliance", "sex", "access", "prefix", "result", "e", "ssl", "iso", "progress", "cgi", "is", "index", "x", "sem", "res", "atus", "success", "magic", "spec", "login", "name", "format", "resp", "d", "use", "http", "sw", "json", "number", "service", "fs", "wa", "stats", "size", "response", "st", "ret", "STAT", "ex", "stat", "wait", "z", "US", "code", "xml", "msg", "s", "ser", "current", "source"], "in": ["bin", "read", "din", "min", "dr", " din", "re", "str", "id", "inc", "isin", "rin", "ind", "en", "inner", "ln", "inf", "inside", "body", "source", "iter", "im", "r", "is", "input", "irm", "up", "In", "on", "old", "gin", "init", "ini", "IN", "mn", "it", "st", "from", "ins", "inn", "cin", "ai", "xml", "i", "mm", "cont", "sin"], "out": ["t", "io", "v", "inv", "ne", "os", "OU", "en", "inner", "at", "ent", "sys", "gt", "cmd", "oss", "check", "res", "good", "err", "nt", "conv", "n", "co", "all", "list", "o", "set", "net", "it", "cn", "outs", "vol", "ch", "Out", "sum", "ex", "null", "to", "cos", "g", "writer", "cont", "ou", "aos", "OUT", "outer"]}}
{"id1": "22235113", "id2": "13563706", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallYsl", "unmarshallYplex", "unmarshalXxml", "unmarshallAsml", "unmarshallXplex", "unmarshalYplex", "unmarshalYxml", "unmarshalXml", "unmarshallAsplex", "unmarshallAssl", "unmarshallExml", "unmarshalXsl", "unmarshalYsl", "unmarshallXxml", "unmarshallXsl", "unmarshallAsxml", "unmarshallYxml", "unmarshallEsl", "unmarshallYml", "unmarshallEplex", "unmarshalXplex", "unmarshalYml", "unmarshallEml"], "unmarshaller": ["unmarshilloser", "unmachailer", "unmarshailer", "unmachallers", "unmarshCallable", "unmarshalling", "unmMarshcallier", "unmarshailing", "unmMarshcaller", "unmarshiller", "unmarshallier", "unmarshcalloser", "unmachaller", "unmarshallers", "unmarshCalling", "unmarshailable", "unmMarshallers", "unmMarshcallers", "unmarshalloser", "unmachailing", "unmachailable", "unmachallable", "unmachailers", "unmachalling", "unmarsheller", "unmMarshallier", "unmarshellers", "unmarshelloser", "unmarshCaller", "unmarshcallier", "unmarshcalling", "unmMarshcalloser", "unmarshillier", "unmarshCallers", "unmMarshaller", "unmarshcaller", "unmarshallable", "unmarshailers", "unmarshellier", "unmarshcallers", "unmarshcallable", "unmarshillers", "unmMarshalloser"], "accessUrl": [" accessUr", "AccessPage", "axUrl", "axUr", "ccessurl", "accessurl", "AccessUrl", "AccessDb", "accessPath", "axURL", "ccessUr", "accessibleDb", "accessPage", " accessurl", " accessURL", "execUrl", "accessUr", "aceUrl", "aceURL", "ccessUrl", "AccessURL", "axDb", "accessDb", "accessibleUr", "ccessURL", "acePage", "ccessPage", "accessibleUrl", " accessPath", "uploadUrl", "accessibleURL", "uploadurl", "uploadURL", "aceurl", "uploadUr", "AccessPath", "Accessurl", "AccessUr", "accessURL", "execUr", "execPath", "execURL"], "nameSpace": ["whiteSp", "NameSpace", "namespace", "nameAccount", "wordspace", "linkType", "nameType", "wordSpace", " nameSp", "Namespace", " nameBox", "NameType", "resourceSpace", "linkSp", "whiteAccount", "wordBox", " nameType", "resourceBox", "NameAccount", "nameBox", "nameSp", "whiteSpace", "whitespace", "resourcespace", " nameAccount", "linkspace", "NameSp", " namespace", "linkSpace"], "replace": ["save", "places", "same", "write", "close", "look", "strip", "re", "align", "each", "over", "insert", "sub", "join", "add", "prefix", "register", "place", "string", "update", "transform", "hash", "fill", "map", "format", "cover", "after", "escape", "alter", "old", "wrapper", "use", "pair", "fix", "delete", "match", "repeat", "search", "template", "find", "force", "record", "apply", "group", "change", "tool", "store", "share", "filter", "include", "repl", "gre", "remove"], "with": ["then", "where", "default", "spr", "With", "by", "id", "which", "self", "now", "using", "join", "add", "form", "require", "x", "path", "work", "title", "spec", "format", "without", "handle", "after", "repeat", "value", " WITH", "php", "ith", "via", "apply", "cap", "sql", "context", "tx", "color", "xml", " without", "here", "set"], "url": ["sb", "dl", "ul", "rl", "nl", "mount", "str", "base", "user", "u", "external", "this", "l", "web", "uri", "https", "r", "ssl", "browser", "cert", "impl", "ls", "open", "mail", "ref", "sl", "address", "bel", "ur", "http", "service", "channel", "ll", "link", "URL", "char", "xml", "resource", "Url"], "inputStream": ["outputStream", " Inputstream", "outputstream", "imageSteam", "inSteam", "outputSteam", " inputThread", " InputStream", "inStream", "imageStream", "imagestream", " InputThread", "instream", "activeStream", "inputstream", "activeSteam", " inputSteam", "inputThread", "imageThread", "activestream", " InputSteam", "inputSteam", " inputstream"], "xmlContent": ["textcontent", " xmlcontent", "textContents", "xaValue", "xfName", "mlRaw", "xmlText", "formRaw", " xmlContents", "jsonContents", " xmlName", "textName", "mlcontent", "xmlcontent", "jsonText", "xfContent", "xfContents", "xmlRaw", "mlContent", "mlContents", "xfcontent", "phpText", "mlValue", "mlAccept", "xaContent", "xmlContents", "phpcontent", " xmlValue", "xmlValue", "formContent", "phpContents", "xaText", " xmlText", "mlText", "formText", " xmlRaw", "jsonContent", "formContents", "textText", "phpContent", "jsoncontent", " xmlAccept", "xaAccept", "xmlAccept", "xmlName", "textContent"], "out": ["t", "io", "write", "copy", "in", "conn", "extra", "user", "os", "comment", "external", "auto", "log", "file", "inner", "ent", "flush", "at", "sys", "client", "cmd", "check", "nt", "up", "conv", "n", "co", "init", "list", "o", "conf", "net", "con", "cn", "outs", "Out", "output", "ex", "null", "to", "cos", "writer", "ou", "aos", "OUT", "outer"], "xmlRequestNumber": ["xmlResponseNo", " xmlResponseNo", "xmlEventNo", "xmlResponseNumber", " xmlResponseNumber", "xmlCounterNo", "xmlRequestCounter", " xmlRequestNo", "xmlCounterNumber", "xmlCounterCount", "xmlResponseCount", "xmlEventNumber", "xmlEventCount", "xmlCounterCounter", " xmlResponseCounter", " xmlResponseCount", "xmlResponseCounter", "xmlEventCounter", "xmlRequestNo", " xmlRequestCount", " xmlRequestCounter", "xmlRequestCount"], "byteArrayInputStream": ["byteStreamInputForm", "byteArrayOutputStream", "byteStringInputSocket", "byteArrayOutputSet", "byteArrayIntSet", "byteArrayinputSteam", "byteArrayInputSteam", "byteArrayIntStream", "byteOrderInputSource", "byteArrayInputForm", "byteOrderReadSteam", "byteStreamInputStream", "byteArrayIntSteam", "byteStringInputStream", "byteOrderReadSource", "byteArrayInputSet", "byteArrayinputForm", "byteArrayinputSocket", "byteStringInputForm", "byteOrderInputStream", "byteArrayStorageStream", "byteOrderReadStream", "byteArrayStorageSteam", "byteOrderReadForm", "byteArrayHttpForm", "byteArrayHttpSteam", "byteStringOutputSocket", "byteArrayHttpStream", "byteStreamInputSet", "byteStringOutputForm", "byteStreamOutputStream", "byteStreamOutputForm", "byteArrayReadForm", "byteArrayRawStream", "byteArrayOutputSteam", "byteStreamOutputSteam", "byteArrayinputStream", "byteArrayOutputSocket", "byteStreamInputSteam", "byteArrayOutputForm", "byteArrayReadSource", "byteArrayStorageForm", "byteStreamOutputSet", "byteArrayHttpSource", "byteStringInputSteam", "byteArrayRawSteam", "byteArrayStorageSet", "byteOrderInputForm", "byteStringOutputSteam", "byteStringOutputStream", "byteArrayReadStream", "byteArrayRawForm", "byteArrayOutputSource", "byteArrayIntForm", "byteArrayInputSource", "byteArrayInputSocket", "byteArrayRawSocket", "byteArrayReadSteam", "byteOrderInputSteam"], "source": ["content", "object", "parse", "where", "unit", "details", "instance", "state", "status", "copy", "se", "src", "in", "stream", "cause", "scope", "comment", "select", "file", "relation", "component", "join", "inner", "expression", "trace", "body", "ident", "console", "SOURCE", "input", "ource", "reason", "position", "Source", "params", "handle", "layout", "json", "service", "target", "template", "proxy", "site", "sequence", "context", "from", "subject", "report", "store", "config", "table", "resource", "xml", "parent", "style", "ser"]}}
{"id1": "11377441", "id2": "18613870", "code1": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"resolvePlugins": ["resolvePensions", "resolveLogins", "resolvePluginIn", "resolvePluginIns", "resolvePlugIn", "resolveLogIn", "resolvePluginensions", "resolvingPluginins", "resolvePins", "resolvePIns", "resolvingPlugIns", "resolvingPluginensions", "resolvingPlugins", "resolvePIn", "resolvePluginins", "resolvePlugs", "resolvePlugIns", "resolvePs", "resolvingPlugs", "resolvingPlugIn", "resolveLogensions", "resolvePlugensions", "resolvingPlugensions", "resolvingPluginIn", "resolveLogIns", "resolvingPluginIns"], "cacheDir": ["cachedir", "usedir", "useDirectory", "cacheSet", "CacheDir", " cacheUrl", "matchSet", "cacheDirectory", "matchDir", "matchDr", "Cachedir", "coverDr", " CacheSet", "coverDir", "useDir", "CacheUrl", "cacheUrl", "useUrl", "coverAl", "cacheAl", "matchAl", "coverSet", " cacheDirectory", "cacheDr", " CacheDr", " CacheAl", " CacheDir", "CacheDirectory", " cachedir"], "pluginsFile": [" pluginsPath", "bitsFine", "cssLe", "pluginPath", "pinsFile", " pluginsLe", "modulesFiles", "pinsClass", "cssFine", "pinsfile", "reportsFile", "pluginsClass", "pluginsString", "pluginfile", "pluginsLe", "bitsLe", "pluginsFiles", "pinsFILE", "pluginsPath", " pluginsFiles", "pinsString", "pinsFiles", "pluginFile", "reportsClass", "bitsfile", " pluginsFine", "pluginsfile", "modulesPath", "pluginsFILE", "cssfile", "insFile", "pluginsFine", "insPath", "modulesFile", " pluginsfile", " pluginsFILE", " pluginsString", " pluginsClass", "cssFile", "pinsPath", "reportsFILE", "modulesFILE", "insfile", "bitsFile", "reportsString"], "pluginURL": [" pluginURI", " pluginUR", "pluginsUR", " pluginCL", "prefixREL", "prefixURL", "pluginsCL", "pluginREL", "plugURL", "pluginCL", "pluginsURI", "pluginUrl", "plugUR", " pluginREL", " pluginUrl", "PluginUrl", "plugURI", "prefixUrl", "PluginUR", "PluginURL", "pluginURI", "plugCL", "PluginREL", "prefixUR", "pluginUR", "pluginsURL"], "is": ["tis", "ip", "ists", "iris", "in", "ii", "es", "bs", "\u00eds", "se", "sis", "isin", "iu", "isc", "bis", "isi", "has", "ics", "sys", "iso", "ls", "lis", "ms", "nis", "ires", "its", "IS", "ris", "are", "fs", "ais", "ini", "mis", "isa", "iss", "it", "ios", "isl", "ir", "ins", "rys", "us", "i", "Is", "s", "ri", "xs"], "os": ["et", "dos", "io", "ps", "mos", " Os", "ose", "Os", "es", "bs", "des", "ui", "OS", "mot", "pos", "oS", "oa", "osa", "sys", "ot", "out", "oss", "as", "bos", "iso", "oses", "res", "er", "ox", "si", "ols", "los", "o", "ost", "ios", "css", "ol", "obs", "osi", "oes", "socket", "cos", "us", "zo", "i", "s", "oos", "ms"]}}
{"id1": "4417943", "id2": "3809087", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"test": ["example", "status", "Test", "debug", "evaluate", " check", "base", "server", "full", "install", " testing", "index", " benchmark", " Test", " sample", "foo", " tests", "init", "execute", " TEST", "hello", "launch", "testing", "ping", "sample", "tests", "Example"], "query": ["qs", "text", "type", "view", "comment", "select", "Q", "prefix", "qu", "poll", "body", "string", "q", "pattern", "menu", "input", "ql", "index", "spec", "term", "Query", "command", "quest", "params", "password", "search", "qa", "question", "sequence", "field", "condition", "sql", "random", "code", "filter", "page", "quote", "form"], "url": ["dl", "location", "build", "ul", "nl", "mount", "str", "base", "html", "u", "id", "raw", "log", "pr", "print", "l", "web", "result", "uri", "https", "string", "q", "r", "out", "pattern", "path", "ls", "www", "ref", "sl", "address", "title", "term", "name", "format", "ur", "pl", "http", "api", "ll", "link", "sql", "URL", "xml", "Url"], "urlObj": ["urlOb", " urlobj", "nlOb", " urlOb", "nlIt", "lOb", " urlIt", "UrlObj", "nlobj", "httpObj", "urlIt", "lobj", "httpOb", "urlobj", "nlObj", "lObj", "Urlobj", "httpobj", "lIt", "UrlOb"], "con": ["compl", "c", "cl", "can", "in", "conn", "cone", "cont", "sin", "ver", "Con", "connection", "Conn", "pen", "pos", "const", "bc", "ln", "ain", "mc", "cons", "CON", "cond", "open", "obj", "don", "conv", "connect", "un", "ran", "co", "soc", "len", "win", "cur", "conf", "num", "cn", "fin", "fc", "canon", "dial", "syn", "com", "ctrl", "cos", "nc", "fn", "cf"], "model": ["save", "object", "dl", "le", "buffer", "state", "re", "sm", "data", "base", "tree", "controller", "el", "mi", "mod", "fine", "cell", "body", "Model", "transform", "impl", "gp", "dm", "job", "de", "vm", "map", "me", "models", "frame", "value", "man", "module", "record", "link", "response", "cm", "message", "sim", "m", "table", "xml", "zip", "set"]}}
{"id1": "5620792", "id2": "9796161", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"SHA1": ["SHA2", " SHAOne", "SHAOne", "sha1", "HSOne", "shaOne", "HS256", "sha2", " SHA2", " SHA256", "HS1", "SHA256", "sha256", "HS2"], "text": ["content", "t", "ct", "read", "translation", "current", "data", "str", "ext", "comment", "select", "test", "document", "print", "prefix", "pt", "TEXT", "string", "source", "q", "out", "pattern", "path", "input", "nt", "name", "term", "password", "url", "value", "template", "event", "message", "output", "tx", "subject", "act", "config", "code", "msg", "cont", "word", "Text", "key", "form", "txt"], "HASH_VALUE_SIZE": ["HASH_VAL_SIZE", "HASH_value_SOURCE", "HASH_VALUE_TYPE", "HASH_VALUE_NAME", "HASH_value_SIZE", "HASH_VAL_NAME", "HASH_value_DIR", "HASH_VAL_Size", "HASH_VALUE_NO", "HASH_VALUE_DIR", "HASH_VALUE_Size", "HASH_VAL_NO", "HASH_VALUE_SOURCE", "HASH_value_TYPE"], "md": [" Md", "bd", "MD", " cmd", "ctr", "dh", " mo", "det", "cd", " mm", "td", " rm", "sd", "sm", "js", "mand", "mt", "ind", "mod", " man", "add", "dd", "hd", "dir", "hm", "mc", "dig", "cmd", " dd", "ds", "df", "mk", " mc", "nd", "dm", "mb", "cond", "pd", "metadata", "grad", "mp", " sd", " cd", "d", "der", "mond", "ld", "rm", "mn", "od", " del", " ms", " ma", "m", "h", "mm", "ad", "mode", "mg", "ms", "and"], "sha1hash": ["sha7hash", "sha2Hash", "SHA2Hash", "sha2sum", "sha31have", " SHA31have", "ha2Hash", "sha1have", "sha31value", "sha31hash", "shaoneresult", " SHA1sum", "ha1hash", " SHA31value", "ha1sum", "sha3hash", " SHA1hash", " SHA1have", " SHA31sum", "sha1result", "sha2hex", "SHA2str", "SHA1hash", "ha2hash", "sha2str", "ha1Hash", "sha3hex", "sha2value", "sha2result", "SHA1str", "sha1Hash", "sha5hash", "shaonesum", "ha1result", " SHA31hash", "sha1str", "sha3Hash", " SHA1value", "sha3str", "sha5value", "ha2sum", "sha7Hash", "SHA2hex", "sha2have", "sha7hex", "sha5sum", "SHA2hash", "sha1hex", "sha1sum", "shaonehash", "ha2result", "sha2hash", "SHA1Hash", "SHA1hex", "sha31sum", "sha1value", "sha7str", "shaoneHash", "sha5have"]}}
{"id1": "19849797", "id2": "10385815", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferFile", "copyfile", " copyfile", " copyStream", "transferFiles", " cpfile", " cpStream", "copyStream", "transferfile", " copyFiles", " cpFile", "transferStream", " cpFiles"], "sourceFile": ["sourceField", "ourcePath", "ourcefile", "ourcePage", "ourceFile", "srcPath", "ourceLine", " sourcefile", " sourceField", "srcLine", "sourcePage", "srcTable", "sourcefile", "sourceTable", "srcfile", " sourceLine", "srcPage", "ourceField", "sourceLine", "srcField", " sourcePage", "sourcePath", "srcFile", "ourceTable", " sourceTable", " sourcePath"], "destFile": ["datPlace", "optPath", "DestDir", "destEntity", "optEntity", "declFile", "declFolder", "restFilename", "srcPath", "restFile", "optFile", "DestFilename", "destDir", "DestPath", "destFolder", " destPlace", "destFilename", "DestFile", "restFiles", "datFiles", "datFilename", "restPlace", "DestFiles", "srcFiles", " destFilename", "destPlace", "destPath", " destFiles", "srcEntity", "declDir", "optFolder", "destFiles", "srcFile", "optDir", " destDir", "optFilename", "srcDir", "datFile", "declEntity", "srcFolder", " destPath"], "source": ["parse", "scale", "create", "reader", "score", "copy", "in", "se", "src", "stream", "cause", "scope", "back", "comment", "attribute", "ce", "series", "component", "image", "inner", "before", "result", "body", "iter", "console", "origin", "update", "missing", "ie", "none", "SOURCE", "input", "index", "ource", "check", "spec", "note", "start", "Source", "OURCE", "send", "use", "init", "load", "target", "service", "match", "search", "slave", "query", "proxy", "channel", "pose", "sample", "sequence", "force", "standard", "from", "char", "subject", "local", "style", "store", "shell", "resource", "parent", "table", "show", "owner", "iterator"], "destination": ["destinated", "destment", "Destment", " destificate", "restinated", "termininated", "terminined", "destined", "verificate", "noninate", "terminination", "separination", "decinated", " destation", "descation", "destinator", "restination", "destation", "restinate", "Destinated", "descinate", "separation", "Destation", "destinate", "decined", "Destinator", "verination", "noninated", " destinator", "verinated", "descinator", "termininate", "separinated", "noninator", "nonination", " destment", "descination", "decination", "veration", "Destinate", "destificate", " destined", "Destination", " destinated", "restinator", "decinate", " destinate", "separment", "Destificate"]}}
{"id1": "15409512", "id2": "20128728", "code1": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"inFileName": [" inFileSize", " infileSource", "infileSource", "inPageSource", "inFilenameFace", "intModelName", "infileName", "intModelNames", "infileNames", " infileSize", " infilePath", "inPagename", "inStreamNames", "inFilenameNames", "inPageNames", "infileSize", "infilePath", "inFilenameName", "intFileName", "inFilenamePath", "intFilename", "infileFace", "inModelNames", " infileFace", "inFILEPath", " inFileFace", " inFileNames", "inModelSource", "inFILEName", "inFilenameSize", "intFileSource", " infileName", "inFileNames", "inModelname", " inFileSource", "inFILEFace", "intFileNames", " infileNames", "infilename", "inFileFace", "inStreamPath", "inFileSource", "inStreamSize", "inFILESource", "inFilenameSource", "intModelSource", " inFilePath", "inFilename", "inPageName", "intModelname", "inModelName", "inStreamName", "inFileSize", "inFilePath"], "outFileName": ["outfileDir", "outPathNames", "outPathPath", "outFILENames", "outFILEPath", "infileName", "outPathName", "outfileFile", "infileNames", "inFilenameDir", "outFilenamePath", "inFileDef", "infileDef", "inFilenameNames", "outfileName", "outPathDir", "outFILEParent", "inFilenameName", "outTileNames", "outfileDef", "inFilenamePath", "infileFile", "outFileFile", "outfileNames", "outfileParent", "outFilenameFile", "outFileNames", " outFileParent", "outFileDir", "outfilePath", "outFileDef", "inFileNames", "outFileParent", " outFilenameName", "outFilenameNames", "outTileDef", " outFilenamePath", "outFilenameDir", " outFilenameNames", "inFileFile", " outFilePath", "outTileName", "inFileDir", "outFILEName", "outFilenameParent", " outFileNames", " outFilenameParent", "outTileFile", "outFilenameDef", "outFilenameName", "outFilePath", "inFilePath"], "position": ["location", "request", "usage", "padding", "memory", "buffer", "type", "point", "volume", "connection", "operation", "order", "length", "total", "pos", "POS", "document", "relation", "now", "expression", "portion", "limit", "pointer", "reference", "index", "zero", "no", "application", "start", "address", "command", "capacity", "direction", "amount", "Position", "layout", "journal", "resolution", "present", "move", "description", "slot", "p", "option", "number", "character", "value", "size", "sequence", "block", "condition", "from", "seek", "osition", "minimum", "offset", "initial", "see", "to", "ion", "port", "ment", "source"], "bis": ["avi", "dos", "rison", "ads", "iris", "bi", "bh", "bs", "js", "phis", "BS", "isin", "oi", "pins", "obos", "bits", "idis", "oss", "cgi", "oris", "bes", "abin", "ls", "lis", "bat", "nis", "is", "obb", "lbs", "bps", "conv", "its", "bil", "ubis", "ints", "ris", "opus", "onis", "los", "ais", "irs", "rots", "ios", "fps", "obs", "ubs", "bid", "uds", "bb"], "bos": ["oids", "tis", "dos", "nos", "bones", "oks", "bi", "ots", "bh", "ats", "bs", "aus", "fits", "os", "BS", "ippers", "pins", "webkit", "aos", "bits", "ts", "ows", "oss", "bes", "asket", "bys", "eros", "boards", "ubis", "oops", "ols", "los", "fs", "jas", "rots", "ios", "bo", "obs", "ubs", "cos", "ths", "ods", "uds", "ns", "oos", "tes"], "b": ["sb", "bg", "t", "c", "B", "v", "bin", "bh", "bs", "back", "base", "fb", "batch", "l", "bc", "ib", "body", "q", "ab", "bar", "mb", "eb", "cb", "ob", "br", "rb", "a", "buf", "p", "f", "d", "be", "gb", "pb", "nb", "ch", "bp", "j", "m", "bit", "g", "h", "i", "db", "bb"]}}
{"id1": "22625683", "id2": "17116123", "code1": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"downloadModel": ["getExample", "readFile", "downloadmodel", "readModel", "loadFile", "downloadFile", "loadExample", "getFile", "readExample", "loadmodel", "readmodel", "downloadExample", "getmodel", "getModel", "loadModel"], "url": ["version", "history", "dl", "cl", "location", "ul", "host", "nl", "mount", "str", "html", "id", "base", "u", "log", "file", "el", "loc", "lr", "document", "l", "now", "language", "web", "uri", "https", "string", "q", "pattern", "impl", "path", "ls", "util", "job", "mail", "ref", "email", "address", "title", "name", "format", "term", "ur", "pl", "http", "json", "channel", "ll", "link", "it", "domain", "context", "rel", "URL", "ret", "null", "addr", "lim", "xml", "i", "Url", "resource"], "model": ["save", "object", "problem", "example", "create", "detail", "method", "instance", "state", "age", "re", "view", "data", "tree", "base", "controller", "el", "file", "mi", "layer", "batch", "document", "image", "relation", "mod", "result", "cell", "form", "Model", "transform", "grid", "gp", "library", "job", "de", "database", "obj", "map", "format", "command", "term", "me", "project", "models", "frame", "json", "search", "template", "module", "row", "man", "record", "link", "response", "sample", "domain", "message", "sql", "report", "jo", "m", "table", "xml", "parent", "resource", "error", "db", "set"], "connection": ["c", "generation", "io", "creation", "usage", "bound", "conn", "cone", "collection", "relation", "computer", "statement", "result", "still", "uri", "session", "established", "client", "pointer", "application", "connected", "open", "database", "engine", "created", "communication", "command", "position", "present", "description", "http", "network", "character", "channel", "directory", "number", "con", "Connection", "link", "response", "context", " Connection", "condition", "message", "entry", "sql", "socket", "resource", "ion", "associated", "nc", "connect"], "httpConnection": ["httpConnect", "httpConnector", "httpsConnection", "HttpConnection", "httpsClient", "HttpConnect", "HttpConnector", "hoverConnect", "httpsChannel", "HttpClient", "httpconnection", "httpsConnect", " httpConnect", "httpClient", "httpChannel", "ttpConnection", " httpconnection", "HTTPConnection", "ttpChannel", "hoverConnection", "hoverconnection", "httpsConnector", "httpsconnection", "HTTPClient", "HTTPConnect", " httpChannel", "ttpConnect", "HTTPconnection", "hoverConnector", "ttpconnection", "Httpconnection"], "in": ["io", "reader", "bin", "read", "din", "or", "re", "stream", "data", "isin", "ind", "raw", "mi", "en", "file", "inner", "body", "out", "as", "is", "input", "In", "on", "get", "gin", "f", "ini", "IN", "con", "sample", "sql", "from", "sum", "ins", "inn", "cin", "i", "mm", "s", "source", "and"]}}
{"id1": "20091126", "id2": "13207437", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "save", "io", "create", "y", "write", "Transfer", "Cop", "upload", "transfer", "file", "download", "clone", "cp", " Copy", "open", "map", "get", "paste", "move", "load", "delete", "cat", "Copy", "store", "call", "to", "system"], "in": ["io", "din", " din", "id", "inc", "isin", "rin", "ind", "file", "el", "en", "inner", "b", "l", "inf", "ain", "ck", "r", "input", "up", "In", "n", "old", "gin", "init", "info", "ini", "IN", " input", "from", "ins", "inn", "cin", "i", "mm", "source"], "out": ["c", "t", "tmp", "io", "y", "v", "_", "write", " output", "or", "os", "log", "file", "self", "l", "b", "e", "result", "at", "gt", "ot", "as", "x", "res", "err", "end", "nt", "n", "co", "p", " it", "channel", "o", "net", "one", "it", "w", "outs", "output", "Out", "ch", "ex", "null", "bytes", "to", "msg", "s", "ou", "OUT", " os"], "inChannel": ["cinCommand", "ginPanel", "inChan", " inRow", "cinChannel", "incChuck", "incChannel", "innChannel", "binCommand", "InChannel", "inChain", "outchannel", "outBlock", "inBlock", "conConnection", " inchannel", "cinchannel", "INChan", " inChan", "innConnection", "conChan", "ginChain", "ginChannel", "conListener", "insideCommand", "inchannel", "InConnection", "incChain", "incPanel", " inCommand", " inConnection", "innChan", "INChannel", "conChannel", "inSection", "inChuck", "inListener", " inSection", "binRow", "outCommand", "inCommand", "inConnection", "InChan", "inRow", "INListener", "cinBlock", "binSection", "binChain", "inPanel", "binPanel", "innchannel", "INConnection", "insideChannel", "Inchannel", "insideRow", "binChuck", " inBlock", "insideSection", " inListener", "ginChuck", "binChannel"], "outChannel": ["moduleChannel", " outManager", "inChan", " outPassword", "outputPassword", "cosChan", "outUser", "moduleManager", "outchannel", "modulePassword", "OUTChannel", "OutChan", "OutChannel", "inSlot", "OUTSlot", "cmdGate", "cosUser", "OUTChan", "cmdMany", "inchannel", "skyChannel", " outChan", "cosSlot", "OUTUser", "outputChan", "outMany", "outCh", "outManager", "moduleChan", "outSlot", "skyGate", "outputManager", "inCh", "outputChannel", " outMany", "cmdChannel", "inUser", "skyChan", "outGate", " outGate", "outChan", " outchannel", "OutCh", "cmdChan", "cosChannel", "Outchannel", " outCh", "outPassword", "skyMany"]}}
{"id1": "8490710", "id2": "22366505", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"actualizar": [" actualisar", "ualizer", " actualiser", " actualizaer", " actualizAR", "ualizaar", "ualiziar", " actualisAR", " actualizear", " actualiziar", " actualizaiar", "ualizaAR", "ualizar", "ualizaer", "ualizaiar", " actualizer", " actualizeiar", " actualizeer", "ualizAR", " actualisiar", " actualizaAR", " actualizeAR", " actualizaar"], "ClassNotFoundException": ["ClassNotPresentException", "ClassNotFoundError", "ClassNotPresentError", "ClassNotfoundError", "ClassNotfoundException"], "Exception": ["Exit", "Warning", "T", "Status", "Index", "Time", "Class", "Type", "Application", "Ex", "I", "Configuration", "Null", "ception", "File", "Event", "Interface", "Instance", "End", "Error", "Throw", "Transaction", "Context", "None", "Exc", " exception", "Operation", "Option", "Message", "Connection", "Example", "Handler", "E", "ION", "Result", "EX", "Response", "Un"], "conn": ["c", "ct", "org", "ann", "close", "enc", "sc", "ctx", "Con", "js", "connection", "Conn", "pen", "mt", "en", "pool", "jp", "comm", "ln", "ont", " con", "session", "pas", "mc", "cp", "cc", "cmd", "ks", "oss", "cert", "client", "sys", "cb", "open", "obj", "ws", "nt", "rc", "ec", "n", "exec", "Connect", "init", "conf", "rs", "con", "Connection", "cn", "yn", "ch", "gate", "die", "ens", "sql", "yes", "socket", "act", "config", "db", "ctrl", "pg", "nc", "ns", "connect"], "ms": ["qs", "pm", "terms", "Ms", "ml", "ps", "mos", "ies", "inv", "posts", "bs", "mill", "ats", "js", "sm", "mys", "mic", "md", "os", "vs", "mt", "mi", "eps", "mod", "cs", "ems", "cus", "mc", "ks", "ces", "xs", "sys", "is", "ys", "ants", "res", "pers", "ws", "windows", "MS", "uts", "mp", "ma", "uns", "mx", "fs", "ims", "arms", "rs", "mn", "eds", "ocks", "ins", "m", "cms", "mm", "mes", "s", "ns", "ts", "ents"], "fechaSystem": ["fechisystem", "fechaesystem", "fechaeSys", "fetaesystem", "feshoSystem", "fechlaSystem", "fechlaSys", "fetiSystem", "fechoSTEM", "fechaeServer", "feshasystem", "fechoasystem", "fochtaServer", "fechoaSys", "fechaSys", "fechiSys", "fochtaSTEM", "fochtaSystem", "feshaServer", "feshaSystem", "fetaeSystem", "feshosystem", "fechtaServer", "fechoSys", "fechaeSystem", "fechoServer", "fechtaSTEM", "fochaSystem", "fechtaSystem", "fechaSTEM", "fechoaSystem", "fetaeSys", "fechiSystem", "fechoaServer", "fochaSTEM", "fechoSystem", "fetasystem", "fetiSys", "fechasystem", "fechosystem", "fechaServer", "fechlasystem", "fechaeSTEM", "fetisystem", "fochaServer", "feshoServer", "fetaSys", "fetaSystem"], "aaaammdd": ["aaammmm", "aaaamlmm", "aaammds", "aaaaamdd", "aaaamldd", "aaaaumdd", "aaaamd", "aaaaammd", "aammdd", "aaaammds", "aaaamld", "aaaammm", "aaaammmm", "aammds", "aaammdd", "aaaaamd", "aammd", "aaaaammmm", "aammmd", "aaaamds", "aaaaumd", "aaaaumds", "aaaaummd", "aaaamdd", "aaammmd", "aaaammd", "aaaammmd", "aaaaammm", "aaammd", "aaaaammdd"], "fzafsis": ["fzeajsis", "fzajsi", "fzahesi", "fzafses", "fzahses", "fzeafsi", "fzamsi", "fzafesi", "fzeafses", "fzahsi", "fzajesi", "fzamsis", "fzeajsi", "fzafsi", "fzamses", "fzeajesi", "fzeajses", "fzajses", "fzeafesi", "fzeafsis", "fzajsis", "fzamesi"], "hhmmss": ["hhMMs", "hhmmmps", "hhmms", "hhmps", "hmmbess", "HHMMss", "HHmmms", "hhmmms", "hhmss", "hmmmse", "HHmmss", "hhmmse", "hmmbse", "hhmmmss", "hmmmess", "hmmms", "HHMMms", "hhmmess", "hmmbs", "HHMMps", "hhMMess", "hhmmmms", "hhmmmess", "hhmbs", "hhmbess", "HHMMs", "hhMMps", "hmmmss", "HHmmps", "HHmms", "hhMMss", "hmmbss", "hhmbss", "hhmbse", "hhMMms", "hhMMse", "hhms", "hhmmps", "hhmmmse"], "sss": [" ssjs", " ssn", "sses", "issl", "esss", "issss", "essjs", "ssjs", "ossss", "ssn", "ssl", "ossjs", "isses", "ssss", "rsss", "essn", "essss", " ssss", "esses", "rssl", "rssss", "rsses", "ossn", "isss", "osss", "essl"], "ss": ["sb", "pres", "ius", "ps", "pse", "se", "sd", "less", "bs", "hs", "str", "js", "lower", "tt", "sv", "sq", "cs", "ass", "\u00df", "su", "https", "string", "sys", "ds", "hess", "ess", "ssl", "oss", "ys", "styles", "good", "sl", "ws", "pps", "xx", "pass", "si", "ses", "rs", "iss", "SS", "stats", "css", "sql", "tx", "ress", "rss", "sh", "tz", "sf", "s", "ts", "ns", "txt"], "fzahsis": ["fizahsis", "fzafses", "fzahses", "fzabses", "fizahorus", "fzahsi", "fizafsi", "fzabsi", "fzaqsis", "fzaqorus", "fzafsi", "fizahsi", "fzaborus", "fizahses", "fizafsis", "fizafses", "fzaforus", "fzaqses", "fzaqsi", "fzahorus", "fzabsis", "fizaforus"], "afectados": ["afectionados", "afitectado", "afECTurated", "affECTados", "afECTarians", "afittadas", "affettators", "affettadas", "afectadas", "afectionurated", "afittados", "afelectadas", "afectionado", "afittulas", "affECTurated", "affectado", "afectado", "affECTado", "afecturated", "affECTarians", "afectators", "affettulas", "affectulas", "afECTado", "afelectados", "affectators", "afettators", "affecturated", "afittators", "afettados", "affettados", "afitectados", "afitecturated", "afettulas", "afelectulas", "afettadas", "affectados", "afectulas", "affectadas", "afectarians", "afECTados", "afelectators", "affectarians", "afectionarians", "afitectarians"]}}
{"id1": "11840277", "id2": "5998352", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"clearTables": ["cleanTiles", "cleanLiles", "clearSTable", "resetTates", "clearDiles", "clearSashes", "cleanTates", "cleanLates", "clearTTable", "clearTells", "cleartates", "clearSates", "clearDables", "clearTableTable", "resetTableates", "cleartTable", "cleartables", "clearDates", "clearTiles", "clearLables", "clearTableates", "clearContiles", "resetTashes", "cleanLables", "clearContells", "cleartashes", "clearContates", "resetTTable", "cleanTells", "clearContables", "resetTables", "clearLells", "clearTashes", "clearLiles", "clearTableables", "cleanLells", "resetTableTable", "resetTableashes", "resetTableables", "clearTableashes", "clearDells", "clearSables", "clearLates", "cleanTables", "clearTates"], "conn": ["dn", "org", "oc", "ctx", "en", "comm", "forge", "cp", "cmd", "cert", "cons", "conv", "on", "conf", "con", "canon", "yes", "act", "addr", "cf", "connect", "col", "ont", "pt", "mc", "sys", "cc", "client", "oss", "out", "gc", "open", "req", "rt", "gen", "Connection", "gate", "die", "link", "h", "pg", "ca", "ct", "priv", "tp", "wd", "user", "mt", "pas", "ds", "ws", "nt", "exec", "resp", "cur", "cn", "yn", "gn", "nc", "db", "ang", "c", "close", "enc", "cfg", "connection", "Conn", "ce", "pool", "cb", "obj", "iw", "n", "note", "co", "coll", "ch", "bo", "rel", "com", "ns", "lang"], "stmt": ["stymm", "contmt", " sttry", "stdpt", "usemt", "stlamm", "astmt", "stmr", "kllamm", "StMT", " stgr", "ostmm", "astMT", "statgt", "stmsg", "statm", "ustmg", "restmt", "Stlt", "strm", "putmg", "stdmt", "Stm", "Stmr", "statmt", "stlt", "klgr", "putmt", "Stgr", " stmm", "STmt", "estmt", "estmg", "restMT", "Stmt", "stgr", "stmg", "putmsg", "usetry", "Stgt", "stdlamm", "strmm", "ustmsg", "strpt", "klmt", "usemm", "esttry", "stMT", "statMT", "STpt", "restmr", " stmr", "astm", "stmm", "sttry", "ostmt", " stmp", "putMT", "stpt", "contlt", "Stmm", "stm", " stgt", "Stmsg", "useMT", "estmsg", "strmt", "restmm", "estMT", "startmg", " stmsg", "ustmt", "stgt", " superstlamm", "STmm", "STlt", " stmg", "klMT", "STm", "STmp", " stpt", "styMT", "ustm", "startgr", "STMT", "stmp", "Stmp", " stMT", "stymr", "ostmr", "contMT", "Stmg", "startmt", "startmr", " stlamm", " superstmt", "restgr", "estmm", "ostMT", "astmr", "stymt", "restlamm", " superstpt", " stm"]}}
{"id1": "9275622", "id2": "18164929", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyfile", " copyStream", " cpStream", " cpfile", " duplicateStream", "copyStream", " duplicateFiles", " copyFiles", " cpFile", " duplicateFile", " duplicatefile", " cpFiles"], "_file1": ["_fileOne", "_linkInit", "_ileInit", "_FileOne", "_ileOne", "_ileFirst", "_ile1", "_filesOne", "_linkOne", "_FileFirst", "_link2", "_fileFirst", "_link1", "_fileInit", "_ile2", "_File2", "_FileInit", "_files2", "_File1", "_files1", "_filesFirst"], "_file2": ["_FILE02", "_fileTwo", " _Filetwo", " _FILE1", "_FILE2", "_fileb", " _filetwo", " _FILEb", "_link2", "_file02", "_FILE1", " _fileb", " _fileTwo", "_File02", "_link1", "_image02", "_image1", "_linktwo", " _FileTwo", "_Fileb", "_linkTwo", " _File2", "_File2", " _FILE2", "_Filetwo", "_FILEb", "_filetwo", "_image2", "_FileTwo", "_imageb", " _File1", " _file02", " _FILE02", "_File1"], "fis": ["kios", "Fios", " fi", "kais", "fiss", " fais", "kis", "fios", "fliss", "Fois", " fois", "ufi", "cfris", " fiss", "fois", "ufis", "qiss", "qios", "qis", "qos", "Fos", "fli", " fios", "fais", " fris", "cios", "cais", "Fris", "cfois", "kos", "cfis", "flios", "Fiss", "ufiss", "cfiss", "Fis", "fi", "cos", "ufios", "flis", "cis", "fris"], "fos": ["woes", "foes", "hose", "mos", "ffos", "fows", " fose", "ffoes", "hoes", "hos", "woss", " foss", "foss", "floes", "sfoss", "sfoes", "faos", "sfos", "moes", "maos", "mows", "wis", "flos", "ffis", "floss", "ffoss", "hoss", "waos", "wows", " faos", "sfose", " fows", "fose", "flis", " foes", "wos"], "canalFuente": ["canalFuestro", "canalKuperor", "canalFalent", "canallfueree", "canallFuente", "canallfuperor", "canalTenperor", "canalUtent", "canalKuent", "canallFuenza", "canallFuent", "canalfuestro", "canalFueree", "canallFuperor", "canalFient", "canalFuje", "canallfuje", "canalUteree", "canallFuestro", "canalFaleree", "canallfuestro", "canallFuje", "canalKuente", "canalfuente", "canallfuenza", "canallfuent", "canalFiente", "canalFalestro", "canalUtente", "canalFalente", "canalFienza", "canalTenenza", "canallfuente", "canalTenent", "canallFueree", "canalfuje", "canalTenente", "canalFalperor", "canalFiperor", "canalFalje", "canalKuje", "canalUtestro", "canalfueree", "canalFuent", "canalfuent", "canalFuperor", "canalFuenza", "canalfuenza", "canalfuperor"]}}
{"id1": "20929570", "id2": "88047", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"toMd5": ["toMMD5", "toDd512", "toMMD512", "toMmHash", "toDd5", "toDm5", "toMm5", "toMMDHash", "toMmdHash", "toDm4", "toMMD4", "toDd4", "toMd512", "toMmd512", "toMm512", "toMmd5", "toDm512", "toDdHash", "toMmd4", "toMm4", "toMd4", "toDmHash", "toMdHash"], "str": ["text", "t", "c", "ctr", "v", "enc", "Str", "in", "arr", "data", "this", "print", "b", "wr", "e", "string", "r", "out", "input", "br", "obj", "name", "a", "n", "p", "utt", "STR", "w", "it", "ch", "st", "char", "msg", "cr", "s", "sp", "txt"], "messageDigest": ["Messagedigse", "messageDigester", "messageDigse", "messagedigEST", "messageDefEST", "applicationdigester", "messageDse", "messageDefist", "MessageDigse", "messageDesignester", " messageDiger", " messageDigse", " messageDest", "applicationdigest", "applicationDigest", "messagedigse", "messageDefester", "messagemdse", "MessageDigests", "messageDecester", "applicationDigse", "MessageDigester", "applicationDigester", "messagedigist", "Messagediger", "messageDigist", "applicationDigested", "messageDecest", "messageDest", "messageDert", "messagedigests", "messagedigested", "Messagedigests", "messageDigert", "messagemdest", " messageDse", "messagemdester", "Messagedigester", "messageDecse", "messageDecested", "messageDecests", "messageDigested", "MessageDigEST", "MessagedigEST", "MessageDigest", "messageDesignest", " messageDigester", "messageDesignse", "messageDigEST", "applicationdigse", "messagedigest", "MessageDiger", "applicationdigested", "messagemdert", "messagedigert", " messageDert", "messageDefer", "messagediger", "messageDiger", "messageDester", "Messagedigest", "messageDesignested", " messageDigist", " messageDigert", "messageDigests", " messageDester", "messageDesignests", "messagedigester", "messageDefest"], "byteArray": ["bytearray", "byteString", "viewStream", "fieldRAY", "entityArray", "basicList", " byteList", " bytearray", "entityList", "seArray", "byteBuffer", "viewBuffer", "bytesString", "helloBuffer", "entityarray", "bytesArray", "fieldLength", "resourceStream", "bytesAddress", "resourceArray", "helloArray", "basicarray", "basicString", "seBuffer", "basicArray", "viewArray", " byteRAY", "fieldArray", "resourceBuffer", "byteRAY", " byteBuffer", " byteAddress", "byteStream", "entityBuffer", "byteAddress", " byteString", " byteStream", "bytesLength", "bytesRAY", "basicAddress", "basicBuffer", " byteLength", "byteLength", "byteList"], "md5StrBuff": ["md65TextBuffer", "md5StringDb", "md8StrBuff", "md5StPref", "md65StrBuffer", "md7StrPref", "md5StringCop", "md4StrDb", "md5ObjVert", "md5StrVert", "md5strComp", "md5RatComp", "md65TextCop", "md5StringBu", "md5TextBuffer", "md5ObjComp", "md5StComp", "md7StrBu", "md5TextBuff", "md5Strbuff", "md5TextComp", "md5Stbuff", "md5RatBuff", "md5strBu", "md5strDb", "md5strVert", "md5strbuff", "md4StrBuff", "md5StringPref", "md5Stringbuff", "md65StrComp", "md5ObjBuff", "md65StrBuff", "md5StrPref", "md4Strbuff", "md5StrComp", "md5BuffDb", "md5ObjBuffer", "md8RatBuff", "md5StBuffer", "md4StrPref", "md7StringPref", "md4StringBuff", "md4StringPref", "md65StrCop", "md5strPref", "md5TextCop", "md7StrBuff", "md4Stringbuff", "md5StBuff", "md5StrDb", "md8RatComp", "md65TextBuff", "md5StringBuff", "md5StringComp", "md5StrBu", "md5RatBuffer", "md4StringDb", "md7Stringbuff", "md5StrCop", "md5Buffbuff", "md7Strbuff", "md8StrBuffer", "md8StrVert", "md5RatVert", "md7StringBu", "md5StBu", "md5StrBuffer", "md5strBuffer", "md7StringBuff", "md5strBuff", "md5StCop", "md5StringBuffer", "md5BuffBuff", "md65TextComp", "md8RatVert", "md8RatBuffer", "md8StrComp", "md5BuffPref"], "i": ["ip", "c", "t", "li", "y", "io", "gravity", "v", "bi", "status", "in", "ii", "phi", "multi", "xi", "I", "u", "ui", "ind", "mi", "iu", "go", "batch", "l", "gu", "e", "gi", "uri", "im", "q", "hi", "cli", "x", "cgi", "ki", "ti", "is", "index", "major", "ci", "slice", "pi", "chain", "ji", "conv", "a", "n", "me", "si", "ix", "di", "info", "ini", "ei", "o", "list", "json", "it", "j", "ex", "my", "m", "ai", "us", "h", "s", "ic"]}}
{"id1": "15018553", "id2": "7948308", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" enccrypt", "uncrypt", "unccrypt", "encrypted", "Encrypt", "encode", "Enccrypt", " encrypted", "uncrypted", "uncode", "Encrypted", " encode", "Encode", "enccrypt"], "text": ["content", "t", "ct", "th", "v", "read", "buffer", "translation", "str", "data", "ext", "comment", "select", "test", "ut", "document", "phrase", "print", "now", "pt", "TEXT", "body", "string", "source", "q", "pattern", "x", "path", "input", "title", "nt", "name", "password", "url", "p", "value", "w", "message", "output", "tx", "act", "code", "msg", "cont", "word", "Text", "form", "txt"], "md": ["pm", "c", "bd", "MD", " cmd", "t", "dh", "ct", "det", "cd", "img", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "dig", "del", "cmd", " dd", "sha", "df", "mk", "mb", "nd", "dm", "mo", "hash", "mac", "de", "err", "pd", "metadata", "mem", "grad", "mp", "pkg", "d", " cd", "mond", "der", "ld", "rm", "di", "mn", "od", "m", "doc", "msg", "h", "mm", "cmp", "ad", "mode", "mg", "ms", "and"], "md5hash": ["md3h", "md512h", "md3hash", " md2cloth", " md2hash", "md2sha", " md5Hash", "md2hash", "md5cloth", "md3hex", "md2h", "md5Hash", "md5sha", "md3Hash", "md512Hash", "md5hex", " md5sum", " md3Hash", "md5h", "md2Hash", "md3sha", " md3sha", " md5sha", " md2sum", "md5sum", " md5hex", "md2hex", "md3sum", "md3cloth", " md5h", " md3h", "md2cloth", "md2sum", " md2hex", " md3sum", " md3hash", "md512sum", "md512hash", "md512sha", " md5cloth"]}}
{"id1": "19147279", "id2": "693636", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 1, "substitutes": {"actualizarDatosFinal": [" actualizarDatoFinal", " actualizarDatosFinancial", " actualizarDatoFinancial", " actualizarDatasFinal", " actualizarDataasFinal", " actualizarDataosFinal", " actualizarDatrosFinal", " actualizarDatosBasic", " actualizarDatrosBasic", " actualizarDatoBasic", " actualizarDataasFinancial", " actualizarDatasBasic", " actualizarDatosfinal", " actualizarDataosBasic", " actualizarDataasfinal", " actualizarDatasFinancial", " actualizarDatofinal", " actualizarDatasfinal", " actualizarDataosFinancial", " actualizarDatrosFinancial", " actualizarDataosfinal", " actualizarDatrosfinal", " actualizarDataasBasic"], "idJugadorDiv": ["idJugadierDef", "idJuggadorDef", "idJugadierApp", "idJogadorDef", "idJugadorDec", "idJugadorDef", "idJugordDef", "idJugordDiv", "idJugordDec", "idJogadeDev", "idJugadierDiv", "idJuggadorDiv", "idJogadeDec", "idJuggadorDev", "idJugadorApp", "idJuggadoApp", "idJuggadoDef", "idJugadorDev", "idJugordDev", "idJugadeDev", "idJugadoDev", "idJugadierDev", "idJugadeDec", "idJogadorDiv", "idJugadeDiv", "idJuggadoDev", "idJuggadorApp", "idJugadoDef", "idJogadeDef", "idJugadoDiv", "idJugadoDec", "idJuggadoDiv", "idJugordApp", "idJogadorDev", "idJugadoApp", "idJugadeDef", "idJogadorDec", "idJogadeDiv"], "idRonda": ["IDRona", "IDDosa", "idCona", "idCoda", "idDoda", "idRunnerondo", "idRata", "idRunneronda", "idCorata", "idRosa", "IDRoda", "IDDoda", "idConda", "idRondo", "IDRonda", "IdRata", "idDosa", "idDonda", "idRunnerora", "idCoronda", "IDDona", "idCorondo", "IDDonda", "IdRondo", "idTosa", "idDona", "IdRonda", "idCosa", "IDRosa", "IdRora", "idCorora", "idTona", "idRunnerata", "idTonda", "idRona", "idRoda", "idToda", "idRora"], "unjxdxr": ["unjdxxe", "unjdxxhr", "unjxdexe", "unjdxxte", "unjdxxtR", "unjxdxdr", "unjdxxrs", "unjxdtxR", "unjdxxr", "unjdxtxer", "unjxdXr", "unjxdxde", "unjdxxtrs", "unjxddxR", "unjxdxR", "unjxddxhr", "unjxdXhr", "unjxddxr", "unjdxtxR", "unjxdxtr", "unjxdtxhr", "unjxdtxer", "unjxdxtR", "unjdxxR", "unjxdexrs", "unjxdxte", "unjdxtxhr", "unjxdXer", "unjxdxer", "unjxdxhr", "unjdxxer", "unjxdexR", "unjxdxdrs", "unjxdXR", "unjxdtxr", "unjxdxtrs", "unjdxtxr", "unjxdxe", "unjxdxrs", "unjxdexr", "unjxddxer", "unjxdxdR", "unjdxxtr"], "intResult": ["strReturn", "IntResult", "strresult", "IntResults", " intresult", "intRes", "interReturn", "intResults", "INTRes", "strResult", " intResults", "intReturn", "interResults", "INTresult", "INTResult", "IntRes", "strResults", "INTResults", "IntSuccess", "intresult", "interResult", " intRes", "IntReturn", "intSuccess", " intSuccess", " intReturn", "interRes", "INTReturn", "INTSuccess"], "sql": ["qs", "sb", "dl", "SQL", "status", "spr", "select", "csv", "log", "sv", "pr", "sq", "statement", "expression", "scl", "serv", "string", "q", "cp", "cmd", "ls", "ql", "pel", "setup", "command", "params", "script", "url", "description", "template", "query", "condition", "settings", "seed", "what", "xml", "s", "sp", "sol", "fn", "db"], "connection": ["c", "close", "conn", "server", "external", "pool", "collection", "relation", "document", "computer", "statement", "session", "creator", "client", "pointer", "platform", "reference", "library", "application", "connected", "engine", "database", "open", "created", "communication", "command", "connect", "position", "city", "description", "network", "character", "channel", "directory", "number", "con", "Connection", "link", "response", "bo", "context", "condition", " Connection", "subject", "socket", "function", "ion", "port", "associated", "writer", "table", "resource", "current", "db", "nc"], "ps": ["pm", "aps", "tp", "pa", "conn", "posts", "po", "pos", "eps", "pr", "jp", "cs", "pt", "statement", "pg", "ports", "cp", "proc", "ds", "res", "pd", "pps", "ptr", "mp", "script", "p", "processor", "prep", "fp", "rs", "ping", "proxy", "PS", "sp", "fps", "process", "pp", "Ps", "socket", "s", "pse", "gres", "pers"]}}
{"id1": "5977352", "id2": "17111859", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyFiles", "cpfile", " copyfile", "copyfile", "copyFolder", "cpFolder", " cpfile", "cpFile", "cpFiles", " copyFiles", " cpFolder", " copyFolder", " cpFile", " cpFiles"], "src": ["sb", "img", "ctr", "sr", "ipl", "sc", "rl", "usr", "sit", "rest", "loc", "sq", "sys", "SOURCE", "input", "rc", "req", "start", "Source", "orig", "pkg", "init", "sec", "cur", "rs", "via", "rel", "st", "from", "ins", "sf", "inst", "cont", "ser", "source"], "dest": ["est", " dst", "th", "coord", "tmp", "Dest", "trans", "tom", "copy", "etc", "usr", "nom", "sit", "rest", "test", "loc", "self", "them", "foreign", "temp", "result", "dir", "del", "origin", "gt", "cp", "none", "mk", "opt", "de", "end", "nt", "name", "dat", "nw", "spec", "orig", "tif", "comb", "comp", "target", "dist", "desc", "cat", "st", "lit", "null", "master", "port", "parent", "decl", "sp", "cont", "good", "source", "txt"], "bufSize": ["fontSize", " bufSIZE", " bufferSIZE", "bcLen", "ufNum", "ufSIZE", "fontNum", "bcNum", " bufferNum", "ufLen", "bcSIZE", " bufferSize", "fontSIZE", "ufSize", "bufLen", "bufSIZE", " bufNum", "bcSize", " bufLen", "bufNum"], "force": ["kill", " Force", "replace", "write", "close", "default", "base", "auto", "stall", "ce", "raise", "print", "draw", "error", "forcing", "flag", "forge", "require", "allow", "cmd", "fill", "forces", "check", "command", "always", "Force", "co", "send", "f", "use", "safe", "frame", "only", "forced", "enable", "apply", "fast", "reset", "remote", "rule", "quote", "form"], "buffer": ["history", "text", "binary", "memory", "Buffer", "view", "stack", "tree", "buff", "base", "length", "comment", "total", "attribute", "batch", "document", "phrase", "print", "temp", "word", "queue", "shape", "limit", "library", "cache", "device", "command", "variable", "mem", "buf", "paste", "frame", "number", "template", "row", "sample", "sequence", "block", "message", "display", "table", "window", "quote"], "read": ["scan", "text", "t", "parse", "count", "reader", "request", "write", "range", "READ", "run", "stream", "str", "bind", "need", "length", "ind", "raw", "print", "add", "next", "before", "give", "im", "iter", "word", "q", "allow", "shape", "r", " Read", "input", "index", "fill", "check", "open", "hold", "end", "req", "start", "get", "pass", "pe", "send", "feed", "len", "load", "height", "find", "hello", "Read", "row", "query", "record", "w", "size", "reading", "reads", "valid", "readable", "wait", "i", "through", "connect", "set", "push"], "in": ["t", "bin", "din", "or", "inc", "isin", "rin", "ind", "mi", "en", "inner", "l", "ln", "inf", "ain", "inside", "iter", "im", "source", "ie", "is", "input", "check", "irm", "al", "up", "In", "n", "on", "get", "co", "gin", "per", "ma", "init", "all", "info", "o", "IN", "ini", "con", "local", "it", "internal", "cn", "ar", "from", "ins", "inn", "m", "cin", "doc", "i", "mm", "ic", "include", "sin"], "out": ["t", "io", "v", "write", "can", "conn", "or", "oe", "ne", "os", "file", "om", "inner", "b", "l", "ln", "at", "ent", "flush", "ot", "sys", "oss", "gt", "client", "cmd", "cache", "br", "end", "obj", "nt", "up", "op", "conv", "n", "on", "co", "all", "list", "o", "net", "con", "one", "cn", "it", "mit", "ch", "output", "Out", "sum", "outs", "ex", "ns", "again", "to", "cos", "g", "writer", "not", "ou", "aos", "OUT", "outer"]}}
{"id1": "5682569", "id2": "6517139", "code1": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 0, "substitutes": {"metodo1": ["\u00e9todo1", "\u00e9tulo6", " metoaOne", " metoa6", " metodo01", " metulo1", "\u00e9tuloOne", " metosa6", "\u00e9todoOne", " metoa1", " metulo6", "\u00e9tulo01", " metulo01", " metodo6", " metoa01", "\u00e9todo6", " metosa01", "\u00e9tulo1", " metosa1", "\u00e9todo01", " metosaOne", " metodoOne", " metuloOne"], "temp": ["tem", "t", "tmp", "count", "unit", "mint", "v", "buffer", "coord", "Temp", "status", "max", "vt", "cont", "data", "str", "fac", "dest", "test", "mod", "pt", "result", "timer", "cum", "tc", "iter", "porary", "tr", "index", "EMP", "Temperature", "partial", "cu", "dat", "ptr", "orig", "mp", "p", "cel", "template", "texture", "emp", "pre", "sum", "tim", "unt", "null", "deg", "fake", "current", "alt", "txt"], "flagDesordenado": ["flagDesordennada", "flagDesorensada", "flagDesorenados", "flagDesordinato", "flagDesordennadic", "flagDesordennato", "flagDesordunano", "flagDesorenada", "flagDesordinnada", "flagDesordanated", "flagDesordinnano", "flagDesordenados", "flagDesordanadic", "flagDesordunable", "flagDesendanano", "flagDesordanado", "flagDesordentados", "flagDesordenato", "flagDesorensados", "flagDesordenable", "flagDesorenadic", "flagDesordentado", "flagDesordinnado", "flagDesorensado", "flagDesordinada", "flagDesrunenada", "flagDesendanable", "flagDesendenado", "flagDesordensados", "flagDesordinado", "flagDesrunenados", "flagDesordentada", "flagDesordinated", "flagDesrunenado", "flagDesrunenato", "flagDesordunado", "flagDesordanano", "flagDesorenado", "flagDesrunennados", "flagDesordenano", "flagDesordensada", "flagDesordentato", "flagDesordunada", "flagDesordensated", "flagDesordanable", "flagDesendenano", "flagDesendenada", "flagDesordensadic", "flagDesordennado", "flagDesordinados", "flagDesendanada", "flagDesordenadic", "flagDesrunennato", "flagDesendenable", "flagDesrunennada", "flagDesordenada", "flagDesordennados", "flagDesordensado", "flagDesordinnable", "flagDesrunennado", "flagDesordanados", "flagDesendanado", "flagDesorensadic", "flagDesordanada", "flagDesordenated"], "i": ["ip", "ori", "t", "li", "io", "y", "bi", "status", "in", "ii", "phi", "multi", "xi", "I", "ui", "mi", "iu", "ski", "oi", "batch", "gi", "uri", "im", "iter", "q", "uni", "hi", "cli", "ami", "is", "ki", "ti", "index", "ri", "ci", "pi", "ij", "ji", "chain", "vi", "me", "iri", "qi", "f", "si", "ix", "init", "di", "info", "ini", "ei", "list", "it", "sim", "j", "my", "\u0438", "m", "ai", "zi", "iti", "ic", "us", "s", "g", "by"], "tabla": [" tabelo", "tabelo", " tablo", "tableela", "softlar", "tabela", "celllo", "tablela", "Tablas", "lablla", " tablla", "labla", "bedlar", "celllar", "Tabula", "softela", "tablas", " tabela", "bedela", "tablar", "cellelo", "cellela", "tabula", "Tablo", "softla", "tablelo", "cellla", " tabda", "tablla", "tablo", " tabula", "celllas", "Tablar", "tabda", "Tabelo", "Tablla", "bedla", "labula", "labela", "softula", "Tabela", "Tabla", "bedda", " tablas", "cellda", " tablar", "tableula"]}}
{"id1": "22879400", "id2": "22411381", "code1": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"loadAllProperties": ["loadAllPrperties", "loadAllPrPro", "loadAllPropertyperties", "loadAllPropps", "loadallPropertyPro", "loadallProperties", "loadAllProPro", "loadAllPrps", "loadAllPropertyps", "loadAllProps", "loadAllPropertyPro", "loadallProps", "loadallPropertyperties", "loadallProPro", "loadAllPropperties", "loadAllPropPro", "loadallPropertyps"], "resourceName": ["resourceString", " resourcename", "templatename", "propertyString", "ResourceFull", "ResourceNames", "propertyname", "uriName", "resourceNames", "propertyNames", "propertyName", " resourceNames", "resourceLength", "ResourceName", " resourceFull", "resourceFull", " resourceLength", "resourcePath", " resourcePath", "fileFull", "fileName", "fileNames", "uriPath", "ResourcePath", "ResourceString", "ResourceLength", "templateName", "templateNames", "resourcename", "Resourcename", "templateString", "filename", "uriLength"], "classLoader": ["classPath", "Classloader", "classloader", "classReader", "resourceReader", "fileLoader", "fileloader", "clloader", "clLess", "ClassLoader", "resourceLoader", "clReader", "resourceLess", "ClassReader", "filePath", "fileName", "ClassName", " classloader", "resourceloader", "classLess", "className", "clLoader", "ClassPath", "ClassLess", " classPath", " className"], "clToUse": ["CltoUSE", "clToBe", "clDouse", "sclTouse", "clReUsing", "clTOUse", "clDoApply", "clTOBe", "cltouse", "Cltouse", "sclToUse", "CltoApply", "cltoUse", "ClToUs", "sclTOuse", "clDoUse", "clToUsing", "ClToUSE", "clReUse", "cltoBe", "clLoUSE", "cl2Use", "clAsUs", "clToUs", "sclTOBe", " plToUsing", "CltoUs", "sclToBe", "clAsUse", "sclTOUse", "ClToApply", "cltoUSE", "CltoUse", " plToLoad", "clLoUse", "clTouse", "clReLoad", "cl2Load", "clAsUSE", "clTOLoad", "clTargetLoad", "sclToLoad", "cl2Read", " plTOUse", "cl2Using", "ClToUse", "sclTOLoad", "clTargetuse", " plToRead", "clTOUsing", "ClTouse", "cltoUs", "clReRead", "clLouse", "clToLoad", " plToUse", "clTargetUse", " plTORead", "clAsuse", "clTORead", " plTOLoad", "clToRead", " plTOUsing", "clTargetBe", "cltoApply", "clToUSE", "cltoLoad", "clTOuse", "clLoUs", "clToApply"], "properties": ["states", "features", "projects", "terms", "perties", "ps", "pdf", "results", "details", "articles", "state", "classes", "posts", "parts", "prop", "services", "frames", "ports", "trace", "options", "items", "changes", "rows", "prints", "reports", "objects", "comments", "policy", "metadata", "its", "params", "p", "property", "members", "json", "info", "packages", "resources", "types", "beans", "settings", "values", "pro", "fields", "current", "units"], "urls": [" urlers", "Urlals", "urlits", "llers", "urlps", "URLps", "URLb", "urlls", "Urlb", "pathals", " urlls", "URLt", "paths", "pathb", " urlt", "limls", "llits", "nlt", "urlals", "Urls", "nlps", "lls", "limers", "llls", " urlps", "nls", " urlits", "urlt", "urlers", "lims", "limits", "urlb", "URLs", "URLals"], "url": ["dl", "li", "ul", "rl", "nl", "mount", "str", "base", "loc", "l", "gl", "uri", "il", "r", "ssl", "path", "ls", "mb", "open", "job", "att", "ref", "sl", "address", "name", "bel", "ur", "f", "pl", "http", "row", "ll", "link", "rel", "ol", "URL", "char", "resource", "Url", "key"], "is": ["ip", "tis", "ists", "dis", "iris", "in", "es", "bs", "js", "os", "sis", "isin", "mi", "bis", "isc", "isi", "gets", "has", "cs", "isp", "was", "still", "isf", "bits", "as", "oss", "iso", "ms", "lis", "ls", "nis", "ois", "its", "IS", "si", "ris", "info", "fs", "ais", "ims", "isa", "mis", "iss", "ios", "isl", "vis", "us", "i", "Is", "s", "xs"], "con": ["c", "ct", "conn", "cone", "cont", "re", "cal", "Con", "connection", "ver", "Conn", "fac", "pen", "pos", "const", "bc", "cf", "ln", "ain", "cons", "open", "CON", "cond", "conv", "bur", "cover", "un", "ran", "co", "win", "conf", "cur", "cn", "cm", "fc", "canon", "dial", "syn", "com", "ctrl", "cos", "nc", "connect"]}}
{"id1": "23035537", "id2": "1097147", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["updateMedia", " getContents", " getMedia", "getcontent", "getMedia", "updateContent", "updateContents", "checkContents", "checkcontent", "updatecontent", "checkMedia", "checkContent", " getcontent", "getContents"], "userId": ["USERName", "authorID", "authorId", "humanID", "UserName", "jobById", "UserId", "humanId", " userName", " userID", "userName", "humanName", "USERID", "UserById", "authorName", "UserID", "jobName", "humanById", "authorById", "jobId", "USERId", "USERById", "jobID", "userID", "userById", " userById"], "latestMsgId": ["latestMessageid", "latestMsgid", "LatestMsgId", "latestMessageById", "LatestMsgIn", "lastMsgById", "lastmsgById", "latestMsgById", "lastmsgid", "latestMessageId", "latestMsgID", "latestmsgIn", "latestmsgById", "lastMsgID", "lastmsgId", "latestStrId", "latestmsgid", "latestStrById", "lastMsgid", "latestMessageID", "LatestMessageId", "latestmsgId", "LatestMessageById", "latestMsgIn", "lastmsgID", "LatestMsgID", "lastMsgId", "latestMessageIn", "LatestMessageID", "latestStrIn", "latestStrID", "LatestMsgById", "LatestMessageIn", "latestmsgID"], "targetUrl": ["baseURL", "baseUr", "sourceStr", " targetName", "TargetURL", "TargetUr", "targetUr", "baseStr", "sourceUrl", "TargetUrl", "templateUrl", "baseUrl", "argetURL", "targetURL", "targetStr", "argetUrl", " targetDest", "argetDest", "sourceURL", "TargetStr", "argetName", " targetURL", "templateDest", "sourceUr", "targetName", "templateURL", "targetDest", "templateName"], "url": ["t", "dl", "location", "ul", "nl", "mount", "str", "base", "id", "u", "el", "file", "l", "b", "gl", "web", "uri", "r", "ssl", "browser", "ls", "open", "err", "ref", "sl", "name", "bel", "ur", "p", "pl", "http", "ll", "link", "rel", "ol", "URL", "char", "null", "call", "xml", "resource", "Url", "key"], "in": ["t", "io", "bin", "din", "or", "stream", "data", "str", "isin", "rin", "el", "file", "en", "inner", "l", "serv", "inf", "body", "inside", "mc", "out", "is", "input", "al", "er", "In", "n", "p", "gin", "all", "o", "IN", "con", "it", "st", "from", "sql", "ins", "null", "inn", "cin", "xml", "i", "s", "source"], "list": ["lp", "t", "ml", "li", "count", "dl", "v", "detail", "top", "ul", "status", "dict", "alist", "lt", "data", "tree", "base", "log", "LIST", "batch", "collection", "pool", "l", "add", "lists", "lat", "result", "ist", "out", "queue", "single", "listed", "ls", "item", "chain", "format", "layout", "p", "array", "load", "all", "info", "record", "sequence", "block", "st", "group", "null", "table", "filter", "set", "summary"], "parser": ["parse", "lp", "peer", "reader", "worker", "mr", "layer", "bank", "pool", "document", "now", "asser", "language", "loader", "proc", "driver", "magic", "policy", "name", "format", "er", "password", "maker", "student", "per", "processor", "arser", "music", "service", "Parser", "ars", "basic", "php", "penter", "walker", "handler", "xml", "system"], "dao": ["dai", "dataos", "oai", "datpo", " dosa", "ddao", "oosa", "dnpo", " dta", "ddai", "datowa", " dpo", "dnao", "ddosa", "dowa", "ota", "dnowa", "daos", "dnaos", "dosa", "dta", "ddta", "dpo", " dai", " daos", "datao", "oao", " dowa"]}}
{"id1": "530882", "id2": "1985677", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "14390569", "id2": "88047", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"title": ["content", "text", "t", "details", "tip", "Title", "type", "padding", "heading", "parts", "html", "help", "prefix", "holiday", "lead", "hd", "string", "hash", "theme", "setup", "name", "term", "metadata", "start", "password", "notice", "layout", "description", "template", "question", " Title", "size", "message", "subject", "label", "msg", "TIT", "filename", "itle", "header", "summary"], "imageURL": ["fileURI", "ImageUrl", "mediaURL", "imageUrl", "photoUrl", "photoURL", "imageString", "ImageURI", "fileURL", "fileUrl", "ImageURL", " imageString", "mediaID", "ImageID", "mediaUrl", "mediaURI", "imageURI", "photoID", " imageURI", "photoUR", "imageID", " imageUrl", " imageUR", "imageUR", "photoURI", "photoString", "fileString", "ImageUR"], "jd": ["ajdm", "jsD", "jjD", " jad", "jbd", "ijd", "qds", "djc", "qD", "jdt", "jc", "jsd", " jc", "JD", "javadm", "simmd", "zd", "Jds", "Jd", "Jbd", " jds", "Jc", "jdm", "ijD", "djd", "ajd", "zad", "ujD", "simD", "ujad", "jmd", "jobd", "ujd", "ajpd", "qbd", "Jad", "jpd", "jobdt", "gbd", "jjd", "javapd", "Jdt", "jobdo", "jD", "zsd", " jdt", "simdt", "jspd", "gdo", "jad", "ijds", "jsdm", "djad", "javads", "Jp", "ujmd", "kds", "jdo", "Jmd", "simd", "kdo", " jsd", " jD", "jds", "ajds", "djsd", "kd", "qp", "gds", "Jdo", "djds", "kdt", "kbd", "jsds", "jjp", "jjbd", "djdo", "ujdt", "qd", "gd", "javad", "qdo", " jdo"], "jl": ["jj", "ja", "lp", "dl", "li", "Label", "J", "jet", "yl", " li", "rl", "mil", "nl", "js", "dyl", "elle", "jc", "ln", "il", "jin", "kel", "ijk", "kn", "dll", "elt", "bol", "ji", "ij", "abl", "ibl", "elly", "ell", "jac", "uj", "kl", " ol", "bj", "isl", "j", "syn", "gn", "lu", "lv", "jah", "igl", "dj", "kj", "txt"], "icon": ["ico", "pic", "iban", "ocon", " tip", "conn", "chron", " fruit", "font", "ICO", "pen", " lang", "fa", " conn", "\u4e2d", "jc", "iao", "image", " intent", " ion", "png", "nic", "cil", "gc", "conv", "icol", "eric", "icons", "Icon", " ancestor", "con", "cn", "lock", " widget", "ex", " canvas", "syn", "label", " captcha", "ion", "addon", "ic", "fn", " screen", " Icon"], "chooser": [" choicer", "choicer", "compose", "poicer", "choose", "CHOicer", "booser", "boosen", " choose", "Chooser", "comperer", " choosen", "chooder", "Choose", "Choosen", "composen", "Chooder", "Choicer", " chooder", "pooder", "boose", "CHOoser", "choosen", "pooser", "CHOosen", "CHOose", "choerer", "composer", " choerer", "compicer", "poose", "boerer"], "jp": [" np", " sip", "ja", "np", "JP", "pic", "js", " mp", " joint", "jc", " cp", " ap", "jin", "ij", " sp", "p", "btn", " ja", " dj", "bj", "bp", "j", " gp", " pl", " ip", " je", " pic", "sp", "kj"], "jb": ["qcb", "jbd", "qb", "qbd", "kjbd", "Jbd", "jcb", "Jb", "kjb", " jcb", "Jcb", "kjcb", " jbd"], "e": ["c", "t", "v", "ev", "te", "or", "es", "re", "u", "en", "Event", "ie", "a", "er", "n", "p", "f", "d", "o", "event", "w", "it", "E", "ee", "m", "g", "s", "ed"], "returnVal": ["getVol", "retValue", "retval", "ReturnVal", "returnValid", " returnValue", "responseVal", " returnValid", "responseVol", "ReturnVAL", "responseVAL", "Returnval", "ReturnValue", "retVal", "returnVol", "getVAL", "getValid", "returnValue", " returnVol", " returnval", " returnVAL", "returnVAL", "returnval", "retVAL", "responseValid", "getVal"], "file": ["le", "io", "create", "buffer", "fe", "type", "status", "or", "run", "tree", "base", "core", "user", "FILE", "full", "File", "document", "image", "relation", "dir", "place", "drop", "body", "il", "source", "ile", "path", "library", "work", "open", "rule", "name", "format", "foo", "handle", "get", "f", "http", "be", "target", "channel", "info", "fs", "fp", "local", "link", "valid", "report", "null", "real", "angle", "stat", "to", "table", "resource", "port", "h", "db", "model", "word", "page", "filename", "class"], "fileName": ["FileSystem", "FileSet", "taskName", "fileExt", "entitySet", "FILESet", "fileSet", "FileFace", "ileClass", "handleNAME", "handlename", "imagename", "ileNAME", "imageNAME", "fileFace", "fileSystem", "entityNAME", " fileExt", "FILESystem", "handleClass", " fileClass", "ilename", "FILEPath", "handleName", "FilePath", "imageName", "FileName", "FileNAME", "FILEExt", "FILEName", "fileNAME", "imagePath", "filePath", "fileNames", "ileName", " filePath", " fileSystem", "entityPath", "FILENames", "FileNames", " fileNames", "entityName", "fileClass", "taskname", "Filename", " fileNAME", "FileExt", "imageFace", "taskFace", "taskPath", " filename", "filename", "FILENAME"], "ext": ["t", "ct", "fr", "enc", "Ext", "off", "lex", "lib", "eur", "part", "EXT", "external", "ind", "test", "xt", "hex", "dir", "aux", "cod", "cmd", "sem", "vert", "end", "ec", "typ", "req", "exp", "xp", "exc", "len", "ix", "pat", "ord", "desc", "ag", "exe", "ex", "prot", "cont", "word", "def", "txt"], "i": ["ori", "li", "y", "bi", "status", "ii", "phi", "I", "id", "xi", "ui", "mi", "iu", "print", "gi", "hi", "cli", "is", "ti", "index", "ci", "pi", "qi", "si", "init", "info", "di", "ini", "ei", "it", "j", "fi", "m", "ai"], "doIt": [" doWhich", "waIt", " doIs", "doneit", "doneIT", " doHe", "diIt", "donIT", "didYou", "diHe", " doit", "doWhich", "donit", " doIT", "odoit", "odoHe", "odoWhich", "waIs", "donIt", "diit", "donIs", "doYou", "donYou", "doneIt", "odoIt", "didit", "waIT", "doIs", "doIT", "didIt", "doit", "didIs", "odoIT", " doYou", "diWhich", "doHe"], "src": ["lb", "gs", "sb", "ources", "ctr", "tmp", "trans", "sr", "copy", "sc", "rl", "rx", "usr", "rob", "rest", "loc", "sq", "inner", "sub", "https", "sys", "r", "proc", "ssl", "impl", "input", "crop", "ource", "sl", "rc", "rb", "conv", "ptr", "start", "url", "comp", "http", "init", "rt", "sec", "rs", "rel", "st", "from", "ins", "syn", "sh", "inst", "cont", "ser", "source"], "dest": ["est", "tmp", "coord", "Dest", "trans", "can", "pipe", "des", "usr", "nom", "rest", "loc", "foreign", "temp", "dir", "https", "pas", "iter", "origin", "sys", "cp", "out", "proc", "way", "dat", "nw", "pot", "orig", "mem", "comb", "target", "dist", "slave", "gest", "local", "desc", "cat", "output", "st", "rel", "master", "port", "decl", "sp", "cont", "source"]}}
{"id1": "5399593", "id2": "14590676", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["enrypt", "ecode", "decrypt", "decrypted", "encrypted", "decode", "encode", "eccode", "enrypted", "ecrypt", "ecrypted", "enccode", "enode", "deccode"], "plaintext": [" plainpassword", "plaincontext", " Plainth", "preword", " plainText", "plainText", "plaininput", "ainth", " plaincontext", "aininput", "pretext", "preText", "aintext", "maintext", "plainth", " Plaintext", "precontext", " plainword", "plainword", " Plaininput", " plainth", " Plainpassword", "mainword", "plainpassword", "mainText", "ainpassword", "maincontext", " plaininput"], "UnsupportedEncodingException": ["UnsupportedEncoderException", "UnsupportedEncryptionError", "UnsupportedEncodingError", "UnsupportedCompoderException", "UnsupportedEncoderError", "UnsupportedEncryptionException", "UnsupportedCompoderError", "UnsupportedEncodedException", "UnsupportedCompodingException", "UnsupportedEncodingEx", "UnsupportedEncodedError", "UnsupportedCompoderEx", "UnsupportedEncoderEx", "UnsupportedCompodingError", "UnsupportedEncryptionEx", "UnsupportedEncodedEx", "UnsupportedCompodingEx"], "md": ["pm", " Md", "bd", "MD", " cmd", " mo", "det", "cd", "med", " mm", "dr", "sd", "sm", "mand", "mt", "ind", "mod", "add", "dd", "hd", "mc", "sha", "del", "cmd", " dd", " mc", "mk", "nd", "dm", "mb", "df", "mo", "pd", "nt", " MD", "grad", "exec", "mg", "mp", "d", "der", "ld", "mn", "od", " ma", "def", "gm", "m", "red", "ad", "mm", " m", "ms"], "raw": ["read", "serial", "rendered", "strip", "data", "des", "core", "full", "available", " RAW", "draw", "hex", "bare", "hook", "was", "out", "input", "RAW", " Raw", "aw", "pack", "cooked", "known", "n", "orig", "mem", "buf", "clear", "custom", "load", "all", "json", "row", "unsigned", "message", "valid", "bytes", "empty", "sh", "clean", "Raw"], "hash": ["ashed", "proof", "bh", "html", "id", "unknown", "total", "ash", "ssh", "Hash", "has", "component", "dump", "hex", "result", "sha", "zh", "hidden", "mask", "tr", "hat", "check", "mac", "cloth", "ASH", "name", "password", "shadow", "hed", "height", "search", "tag", "message", "sum", "ashes", "sh", "code", "h", "key"]}}
{"id1": "19810820", "id2": "22801734", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFileFile", " copyFileFile", " copyByteStream", "copyByteFile", " copyFilechannel", " copyFileschannel", " copyStreamFile", "copyFileStream", " copyByteChannel", " copyBytechannel", " copyFilesChannel", " copyStreamchannel", " copyByteFile", " copyStreamStream", "copyFilechannel", "copyByteChannel", " copyFilesFile", " copyStreamChannel", " copyFileStream", "copyBytechannel", "copyByteStream", " copyFilesStream"], "src": ["sync", "sb", "img", "ctr", "tmp", "sr", "sc", "in", "rl", "bs", "rx", "usr", "js", "dest", "loc", "sq", "RC", "sys", "usc", "SOURCE", "input", "ls", "sl", "rc", "req", "start", "Source", "SourceFile", "init", "rt", "sec", "cur", "rs", "rel", "st", "from", "obs", "ins", "syn", "sf", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dst": ["dth", "dut", "Dest", "ddest", " dth", "sest", "Dth", "dest", "Dnd", "Dut", "dnd", "Dist", " dnd", "bdest", "sth", " dest", "snd", "sst", "best", "jdest", "bist", "jst", " ddest", " dist", "dist", "Dst", "jut", "jest", "sdest", "bst", "Ddest", "sut"], "preserveModificationTime": ["preserveModifyTime", "preserveModificationTimes", "preserveModificationsTim", "preserveQualificationsLength", "preserveModifyingPoint", "preserveModificationsPoint", "preserveSpecificationTim", "preserveSpecificationsTim", "preserveSpecificationTime", "preserveQualificationsPoint", "preserveModifierTimes", "preserveSpecificationTimes", "preserveQualificationsTimes", "preserveQualificationPoint", "preserveSpecificationsTime", "preserveModificationsTime", "preserveModifyingTimes", "preserveModificationsTimes", "preserveModifyingTime", "preserveModificationPoint", "preserveQualificationsTime", "preserveModifyLength", "preserveQualificationTimes", "preserveModificationsLength", "preserveModifyPoint", "preserveModificationLength", "preserveQualificationTime", "preserveModifierTim", "preserveModifiedTim", "preserveSpecificationsTimes", "preserveModifierTime", "preserveModificationTim", "preserveModifiedTimes", "preserveModifyingLength", "preserveQualificationLength", "preserveModifiedTime", "preserveModifyTimes"], "inputChannel": ["inputGray", "Inputchannel", "evalChannel", "InputBuffer", "evalChan", "outputStream", "hiddenCategory", "entityChannel", "InputChan", "openChan", "inputChuck", "outputchannel", "innerChannel", "openChannel", " inputBuffer", "hiddenChannel", "hiddenListener", "innerchannel", " inputCategory", "interfaceChannel", " inputStream", "interfaceCategory", "openGray", "infoChannel", " inputGray", "outputBuffer", "inputCategory", "InputChannel", "inputStream", "outputChan", "innerStream", "openConnection", "inputBuffer", "inputConnection", "inputChan", "entityChan", "clientGray", "infoChan", "innerChan", "infochannel", "interfaceListener", " inputChan", "inputchannel", "InputStream", "infoChuck", " inputConnection", "clientConnection", "clientChannel", "clientChan", " inputChuck", "outputChuck", " inputchannel", "inputListener", " inputListener"], "outputChannel": ["displayChan", "doubleChan", "outputStream", "displayChannel", "outputButton", " outputchannel", " outputConnection", "OutputManager", "putchannel", "displayButton", "putButton", "outputchannel", " outputStream", "inputField", "OutputStream", "doubleField", "webchannel", "OutputChannel", "writeChannel", "writeStream", "doubleInstance", "coinField", "webManager", " outputChan", "doubleChannel", " outputButton", "writeChan", "outputChan", "inputInstance", "inputConnection", "putChan", " outputManager", "outputConnection", "inputChan", "outputManager", "OutputChan", "outputField", "coinChannel", "coinInstance", "OutputConnection", "coinChan", "putChannel", "writeManager", "writechannel", "Outputchannel", "displaychannel", "webChannel", "outputInstance", "inputManager"], "length": ["history", "text", "then", "count", "details", "buffer", "ENGTH", "padding", "Length", "type", "needed", "max", "volume", "data", "base", "full", "available", "l", "left", "join", "component", "HH", "limit", "shape", "library", "duration", "family", "time", "end", "partial", "term", "loop", "capacity", "amount", "position", "width", "start", "present", "len", "load", "height", "json", "number", "required", "list", "value", "expected", "all", "size", "sequence", "bytes", "offset", "ength", "to"], "total": ["meta", "t", "checked", "scale", "count", "stable", "translation", "max", " Total", "quant", "active", "human", "base", "unknown", "this", "Total", "full", "raw", "used", "available", "complete", "free", "bar", "no", "equal", "zero", "index", "good", "successful", "title", "created", "note", "amount", "description", "all", "info", "number", "eta", "otal", "required", "num", "local", "size", "sequence", "valid", "sum", "ta", "done", "offset", "last", "to", "unique", "less", "current", "summary"]}}
{"id1": "6517139", "id2": "12744653", "code1": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getPrefsKey": ["getPrefskey", "getPrefixData", "getPrefsValue", "getPrefsData", "getPrefmskey", "getPrefmsKey", "getPrefixValue", "getPrefmsValue", "getPrefmsData", "getPrefoValue", "getPrefixKey", "getPrefixkey", "getPrefoKey", "getPrefokey", "getPrefoData"], "key": ["text", "y", "type", "secret", "default", "k", "data", "str", "base", "id", "unknown", "sk", "phrase", "prefix", "result", "Key", "string", "client", "hash", "path", "item", "index", "obj", "ace", "address", "name", "password", "token", "description", "network", "json", "info", "value", "service", "link", "lock", "message", "char", "my", "entry", "ek", "label", "null", "code", "keys", "KEY", "error"], "MD5": ["HTML3", "DE45", "MDole", "md6", " MD1", " MD10", "md1", "MD7", "MT3", "MDdown", "HTMLole", "MP5", " MD7", "DE1", " MD3", "MD8", " MD4", " MD6", "MT5", "MD3", "MT7", "MP3", "MTole", "HTMLdown", "md3", "MT2", "MP4", "HTML5", "MT6", "md7", "MTdown", " MD2", "MD45", "MP2", " MD45", "DE5", "MT8", " MDole", "md45", "md5", " MD8", "MD1", "MD6", "MD10", "MD4", "MD2", " MDdown", "md10", "MT10", "md8", "DE3", "md2", "md4"], "resultBytes": ["successBytes", "answerString", " resultbytes", "resultsbytes", "Resultbytes", "ResultBytes", " resultBs", " resultByte", "resultbytes", "ResultByte", "resultByte", "resultBs", "answerBytes", "successString", " resultString", "resultsBytes", "successResults", "answerBs", "answerResults", "resultString", "resultResults", " resultResults", "successBs", "resultsByte"]}}
{"id1": "5125848", "id2": "822452", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"combineJs": ["combinateLink", "Combosejs", "ComboseJS", "CombineJs", "combineJS", "combinateJS", "combinatejs", "combinateJs", "CombineJS", "ComboseJs", "comboseJS", "combINEjs", "comboseJs", "combinejs", "combosejs", "combINELink", "ComboseLink", "comboseLink", "Combinejs", "combineLink", "combINEJS", "CombineLink", "combINEJs"], "base": ["buffer", "bound", "ase", "based", "re", "host", "data", "id", "server", " bases", "file", "bottom", "bas", "b", "prefix", " basis", "uri", "source", "origin", "address", " Base", "start", "root", "absolute", "relative", " based", "Base", "api", "template", "site", "local", "domain", "from", "reset", "bid", "page", "db"], "linkJs": ["linkTags", "inkScript", "linkJS", "inkLinks", "LinkJS", "linkjs", "Linkjs", "linkLinks", " linkJS", " linkjs", "LinkJs", "inkJS", " linkScript", "inkJs", "LinkTags", "inkTags", "linkedJS", "linkScript", " linkLinks", "linkedLinks", "inkjs", " linkTags", "linkedJs", "linkedScript"], "newFiles": [" newLinks", "newLinks", "newDocuments", "linkfiles", "newfiles", "linkLinks", "nextLinks", "nextDocuments", "nextfiles", " newfiles", "linkDocuments", "nextFiles", " newDocuments", "linkFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "manager", "dr", "lib", "md", "id", "auto", "file", "disk", "div", "loc", "mod", "temp", "dd", " directory", "sys", "out", "mk", "dm", "Dir", "DB", "ref", "created", "DIR", "tar", "root", "diff", "fd", "folder", "d", "pkg", "di", "fs", "directory", "module", " Dir", "lock", " d", "desc", "rel", "area", "ir", "local", "vol", "done", "doc", "addr", "zip", "good", "db", "def"], "name": [" rebuild", " dummy", " self", " db", " vm", " log", " info", " prefix", " manager", " b", " scanner", " browser", " loader", " res", " parser", " logger", " start", " karma", " msg", " names", " err", " cleaner", " report", " bar", " str", " foo", " filename", " tmp", " os"], "minDir": ["smallDir", "minPref", "minRel", "minuteDar", "MinNet", "minutePref", "miniTrans", "mindir", "skindir", "skinDir", "minTrans", "maindir", "minJar", " minJar", "minDb", " minPref", "smallNet", "minuteDir", "minDar", "minFile", " minTier", " minRel", "minTier", "sortDir", "sortRel", " minDar", " minFile", "thinJar", " minTrans", "smallDb", " minNet", "thinTier", "minLoc", "smallLoc", "mainDb", "skinDb", "minuteRel", "smalldir", "sortDar", "miniTier", "sortPref", "smallFile", "skinLoc", "minNet", "mainDir", "thinDir", "miniDir", "thinTrans", "MinFile", "miniJar", "mainLoc", "MinDir"], "combineFile": ["cominatefile", "cominateMessage", "coordINEFile", "coordINESet", "combinateFile", "combINEWriter", "comboseWriter", "combinSet", "combinerfile", "cominateFile", "comboseSet", "comineFile", "coordineFile", "comineMessage", "comboiceFile", "combINESet", "comboseFile", "coordineSet", "combinerFile", "cominefile", "combinerMessage", "combinefile", "combinFile", "combinateMessage", "coordinefile", "combosefile", "comineEmail", "combineMessage", "comboiceEmail", "combINEfile", "coordINEWriter", "coordineWriter", "comboiceMessage", "comboicefile", "coordINEfile", "combinateEmail", "combineEmail", "cominateEmail", "combinWriter", "combinatefile", "combinerEmail", "combinfile", "combineSet", "combINEFile"], "concatFile": ["comcFile", "concDir", "concatfile", "concapFiles", "concFile", "comcDir", "conatFile", "conatFiles", "concatFiles", "covertTable", "comcatDir", "conCatFilename", "convertfile", "convertFiles", "cocatFiles", "cocatTable", "concFilename", "concapfile", "conCatDir", "covertfile", "covertFile", "comcatFilename", "conatTable", "conatfile", "concatFilename", "comcFilename", "concapTable", "cocatfile", "convertTable", "concatDir", "covertFiles", "concapFile", "convertFilename", "convertFile", "conCatFile", "concatTable", "comcatFile", "cocatFile", "convertDir"], "combineWriter": ["declineFile", "declinateReader", "declinateWriter", "combineReader", "combinateFile", "declinateFile", "combinateWrite", "combenwriter", "combinateWriter", "combinewriter", "Combosewriter", "comboseWriter", "ComboseCounter", "comboseReader", "combenWrite", "combinatewriter", "declineReader", "declineWrite", "comboseFile", "comboseWrite", "declinateWrite", "ComboseWrite", "combieWriter", "CombineWrite", "combosewriter", "combieWrite", "combineCounter", "combinateCounter", "combieReader", "combinateReader", "combineWrite", "CombineCounter", "declineWriter", "combieFile", "CombineWriter", "combenCounter", "Combinewriter", "combenWriter", "ComboseWriter", "comboseCounter"], "concatWriter": ["concatWrite", "concatsReader", "cocatWriter", "conatReader", "conatFile", "coatWriter", "comvertWriter", "cocatReader", "cocatWrite", "comcatWrite", "comvertReader", "coatWrite", "conatWriter", "concatsWrite", "convertReader", "coatFile", "comcatReader", "convertWrite", "comvertFile", "coatReader", "comvertWrite", "concatReader", "concatsWriter", "conatWrite", "convertWriter", "convertFile", "comcatWriter", "comcatFile", "cocatFile", "concatsFile"], "fails": ["mails", " failed", "facocks", "ifails", "lalls", "facails", "frailed", "ifocks", "mailed", "lails", "falls", "failing", "malls", "frails", "fils", "mocks", "Fils", "lailing", "focks", "ifailed", " focks", "ifailing", "facailing", "facailed", "failed", "frailing", "Failing", "frils", "mailing", "Fails", "lailed", " falls", "Failed", " failing", "lils"], "link": ["embed", "c", "li", "follow", "close", "inline", "links", "log", "loc", "self", "l", "add", "mark", "relation", "ln", "linked", "child", "line", "check", "open", "address", "ink", "map", "script", "load", "match", "set", "display", "Link", "task", "node", "code", "share", "remote", "source", "skip", "push"], "path": ["text", "location", "kind", "src", "PATH", "data", "str", "id", "prop", "full", "file", "loc", "ath", "image", "join", "prefix", "hex", "route", "uri", "string", "pattern", "input", "alias", "ref", "Path", "format", "root", "p", "relative", "href", "match", "template", "entry", "style", "resource", "source", "key"], "url": ["li", "location", "request", "build", "ul", "host", "nl", "mount", "str", "id", "html", "this", "loc", "lr", "l", "gl", "web", "uri", "il", "string", "r", "browser", "ssl", "ls", "mail", "ref", "sl", "address", "ur", "get", "http", "href", "hl", "ll", "rel", "abs", "URL", "char", "null", "addr", "resource", "Url", "source"], "inputStream": ["InputTime", "InputSteam", "outputstream", " inputSet", "inputTime", "inSet", "inputStyle", "outputSteam", "inTime", " inputStyle", "Inputstream", " inputTime", "inStream", "instream", "inputSet", "InputStyle", "inputstream", " inputSteam", "InputStream", "inputSteam", "outputStyle", "InputSet", " inputstream"], "jsFile": ["javascriptName", "javascriptFilename", "jsTable", "cssPath", "jsFilename", " jsFilename", "JsFilename", " jsfile", "cssFilename", "Jsfile", "JsPath", "javascriptPath", "jsfile", " jsPath", " jsTable", "JsFile", "javascriptTable", " jsName", "cssTable", "javascriptFile", "javascriptfile", "cssfile", "jsPath", "jFilename", "jsName", "jName", "jFile", "jPath", "cssFile"], "fileName": ["getPath", "FileHash", "filePath", "Filename", "getName", " fileHash", " filePath", "FilePath", "FileName", "getHash", "getname", " filename", "filename", "fileHash"], "outputStream": [" outputstream", "OutputSet", "OutputStyle", "OutputSteam", "outputstream", "inputStyle", "OutputStream", "outputSteam", "writeStream", "outputSet", "writeSet", "OutputForm", "outputForm", " outputStyle", "inputstream", "Outputstream", "writeSteam", " outputForm", " outputSet", " outputSteam", "inputForm", "inputSteam", "outputStyle", "writestream"], "first": ["prev", "then", "same", "top", "default", "each", "stack", "ind", "quick", "self", "now", "next", "continue", "sort", "index", "open", "third", "success", "primary", "fourth", "start", "false", "send", "all", "natural", "important", "only", "seconds", "valid", "must", "st", "latest", "fast", "First", "initial", "true", "real", "last", "second", "master", "unique", "front", "current"], "reader": ["io", "read", "buffer", "rator", "ocr", "rl", "mr", "stream", "data", "core", "this", "file", "layer", "inner", "loader", "Reader", "ro", "parser", "r", "ner", "driver", "rer", "input", "rar", "rc", "er", "builder", "wrapper", "http", "row", "context", "runner", "handler", "rr", "resource", "writer", "iterator"], "jsCompressor": ["jscomposer", "jsCompression", "cssComposer", "jsBuffression", "cssCompressor", "jscompressor", "jsReposer", "jsComposer", "jscompression", "cssRepression", "jscompiler", "jsRepression", "cssRepressor", "cssRepiler", "cssReposer", "jsBuffiler", "jsRepressor", "jsCompiler", "jsBuffoser", "cssCompiler", "jsBuffressor", "jsRepiler", "cssCompression"], "s": ["qs", "ings", "gs", "t", "ss", "y", "ies", "ps", "details", "tags", "ats", "es", "less", "hs", "parts", "os", "full", "ers", "l", "cs", "ds", "is", "ls", "ms", "ids", "words", "fs", "eds", "S", "ens", "lines", "ts", "ns", "pers", "tes", "xs"], "s1": ["s3", "ys1", "esFirst", "ls0", "ls3", "es9", "s0", "id1", "s9", "s81", "ys81", "ps1", " s3", "es2", "ys0", "ls81", "es1", "ls1", "pers1", "sFirst", "ys3", " s0", "id2", "id9", "idFirst", "ps0", " s81", "pers0"], "i": ["ori", "ip", "li", "io", "y", "um", "v", "bi", "ii", "ity", "I", "id", "ui", "mi", "iu", "ati", "oi", "ig", "im", "iti", "ie", "is", "ifier", "ci", "pi", "iat", "p", "ia", "di", "o", "it", "ch", "j", "ai", "us", "ion", "ic", "ri"], "s2": ["msTwo", "s02", "tes2", "ztwo", "zSecond", "ss02", "gs2", "gstwo", "gsSecond", "SSecond", "ms2", "z02", "es2", "tes1", "sTwo", "S2", "es1", "tes02", "Stwo", "ss22", "ms02", "es02", "sSecond", "ss2", "gs02", "S02", "tesTwo", "esTwo", "stwo", "s22", "z2", "ssTwo", "ms22"], "i1": ["p4", "o1", "it0", "o0", "it1", "it01", "iOne", "aOne", "e1", "it2", "i0", "eOne", "a2", "e4", "p1", "e2", "a1", "p2", "p0", "i2", "oOne", "it4", "a01", "pOne", "o4", "itOne", "p01", "i01", "i4"]}}
{"id1": "3024992", "id2": "4750967", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2null_"], "baout": ["BAouth", "dboul", "caout", "BAin", "BAOut", "dbin", "gaouth", "gaout", "gaoul", "caOut", " bain", "dbouth", "BAouts", "baouts", "bain", "baouth", "gain", "buin", "cain", "cait", "abain", "abait", "bait", "abaout", "buOut", "BAoul", "BAout", "baoul", "buouts", " baOut", "dbout", "abaOut", "baOut", "BAit", "buout", " baouts"], "out": ["tmp", "io", "gr", "write", "in", "pool", "serv", "result", "sys", " OUT", "res", "err", "er", "n", "o", "gen", "net", "outs", "it", "Out", "output", "ex", "null", "ser", "OUT"], "writer": ["println", "widget", "reader", "buffer", "write", "worker", "killer", "data", "this", "usher", "file", "print", "inner", "document", "client", "driver", "player", "NULL", "riter", "er", "nw", "builder", "maker", "processor", "writ", "woman", "Writer", "target", "wright", "service", "channel", "w", "rw", "output", "null", "handler", "wrote", "window", "outer"]}}
{"id1": "13946197", "id2": "19549577", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"transformByMD5": [" encryptByMCTime", " encryptbyMD5", " encryptBySMTime", " encryptBySM4", " encryptbymd5", " encryptByMDTime", " encryptByMD4", " encryptBymd7", " encryptbymdTime", " encryptBymd4", " encryptbymd7", " encryptByMD7", " encryptByMC7", " encryptbyMD7", " encryptBySM5", " encryptByMC5", " encryptBymd5", " encryptByMD5", " encryptByMC4", " encryptbyMDTime", " encryptbyMD4", " encryptBymdTime", " encryptbymd4", " encryptBySM7"], "password": ["text", "wd", "secret", "PASS", "padding", "account", "data", "user", "username", "phrase", "prefix", "sword", "pattern", "security", "hash", "path", "email", "database", "address", "name", "login", "command", "pass", "Password", "token", "description", "hello", "value", "w", " passwords", "message", "entry", " Password", "filename", "auth", "word", "key"], "md5": [" md3", "mdnt", " md10", "mand5", "MD7", "mdle", " MDle", " MD7", "mag2", " MD3", " MDnt", "MD3", "MDle", "mag3", "md3", "md7", "mand10", "MDhed", " MD2", " mdhed", " mdnt", "mdhed", "mag5", " md2", " MD5", "MD10", "dig2", " md7", "MD2", "mand2", " mdle", "md10", "maghed", "dig3", "MD5", "MDnt", "dig5", "mand3", "md2"], "output": ["respond", "text", "four", "exit", "results", "buffer", "write", "echo", "current", "view", "data", "answer", "column", "OU", "csv", "log", "file", "batch", "collection", "document", "print", "result", "web", "console", "out", "hidden", "STDOUT", "line", "input", "put", "Output", "successful", "accept", "export", " outputs", "PUT", "all", "list", "response", "block", "message", "display", " Output", "remote", "ou", "source", "outer"], "bufferPass": ["bufferAdd", "memorySe", " bufferSe", "bufPASS", "screenAss", "bufPass", " bufferCat", "BufferPASS", "batchPassword", "screenPassword", "bufCat", "bufDe", " bufferDe", "screenAdd", "sequenceAss", "sequencePassword", "memoryDe", "sequenceAdd", "BufferPass", " bufferAss", "sequencePass", "memoryEn", "batchpass", "bufferCat", "bufferDe", " bufferpass", "bufpass", "bufferSe", "memoryPass", "screenPass", "BufferPassword", "BufferCat", "bufferpass", " bufferEn", " bufferAdd", "batchPass", " bufferPassword", "Bufferpass", "bufferAss", "bufEn", "bufferEn", " bufferPASS", "bufferPASS", "bufferPassword", "bufSe"], "b": ["sb", "c", "B", "bg", "y", "v", "buffer", "bound", "wb", "bi", "emb", "k", "bs", "blue", "base", "u", "fb", "bis", "batch", "l", "bt", "ib", "bc", "e", "bar", "r", "mb", "cb", "ob", "rb", "a", "n", "p", "d", "be", "gb", "o", "nb", "w", "bp", "block", "j", "z", "m", "bit", "g", "h", "i", "bool", "db", "bb"]}}
{"id1": "21979462", "id2": "16511008", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURL2JSON", " downloadURL2String", " downloadurltoString", " downloadurloJSON", " downloadURLToText", " downloadURLtoJSON", " downloadurloBytes", " downloadurloText", " downloadurltoBytes", " downloadURLToBytes", " downloadurloString", " downloadURLoBytes", " downloadurltoText", " downloadURLoJSON", " downloadURLToJSON", " downloadurltoJSON", " downloadURLtoText", " downloadURLToString", " downloadURLtoBytes", " downloadURL2Bytes", " downloadURLoText", " downloadURL2Text", " downloadURLoString"], "url": ["dl", "location", "ul", "run", "mount", "base", "id", "log", "file", "l", "gl", "web", "uri", "ssl", "browser", "ls", "job", "mail", "ref", "sl", "address", "uu", "name", "bel", "un", "ur", "http", "all", "ll", "link", "domain", "ret", "URL", "char", "resource", "Url", "rect"], "in": ["io", "reader", "bin", "read", "din", "copy", "or", "re", "inc", "isin", "ind", "ill", "inner", "inf", "mc", "out", "is", "input", "check", "al", "up", "er", "In", "on", "thin", "gin", "ma", "all", "info", "conf", "IN", "mn", "con", "it", "sum", "from", "ins", "inn", "cin", "ai", "again", "i", "ic", "oin", "by", "and"], "sb": ["lb", "zb", "lp", "bg", "bd", "sg", "pa", "wb", "bh", "bs", "sd", "bf", "sk", "sam", "rob", "bis", "sq", "b", "bt", "ib", "sa", "ab", "ssl", "mb", "eb", "gc", "cb", "SB", "rb", "gb", "erb", "pb", "nb", "bj", "kb", "xb", "bp", "db", "gob", "sf", "sp", "bsp", "bn", "ub", "bb"], "str": ["text", "fr", "t", "gr", "dr", "Str", "arr", "re", "part", "comment", "div", "print", "l", "b", "comm", "bc", "pt", "next", "iter", "string", "del", "r", "ls", "tr", "br", "err", "obj", "sl", "bl", "chain", "dat", "n", "req", "exec", "p", "comp", "expr", "cur", "list", "STR", "sts", "ch", "vol", "sp", "st", "char", "j", "block", "cat", "syn", "m", "msg", "i", "s", "cont", "source", "set", "def", "txt"]}}
{"id1": "9796161", "id2": "16798376", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["toMD7", "getmd7", "toMD5", "getMD4", "getSHA4", "toMD4", "getmd4", "getmd5", "getMD7", "getMD2", "toMD2", "toSHA7", "toSHA5", "getSHA7", "getSHA2", "getSHA5", "toSHA2", "getmd2", "toSHA4"], "s": ["sb", "text", "t", "gs", "ss", "y", "ps", "strings", "v", "ies", "es", "ats", "bs", "src", "str", "js", "data", "os", "space", "sv", "sq", "l", "b", "gets", "aws", "string", "is", "ls", "ms", "ws", "c", "n", "its", "p", "f", "ses", "fs", "rs", "S", "sts", "ends", "abs", "sql", "bytes", "ins", " gets", "h", "ts", "i", "ns", "g", "source", "xs"], "m": ["pm", "managed", "y", "v", "manager", "bm", "mr", "sm", "rem", "md", "mt", "mi", "om", "mod", "l", "mut", "e", "hm", "mc", "mk", "mask", "fm", "dm", "mo", "mac", "vm", "tm", "me", "M", "perm", "rm", "em", "man", "am", "made", "cm", "gm", "nm", "mu", "g", "h", "mm", "ms"]}}
{"id1": "20751378", "id2": "1235538", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["updatePassword", "HashPrivate", " hashPrivate", "updatePrivate", "HashPassword", " hashpassword", "hashPrivate", " hashText", "Hashpassword", "updatepassword", "hashpassword", "hashText", "HashText", "updateText"], "password": ["encrypted", "request", "wd", "secret", "padding", "PASS", "default", "key", "connection", "user", "column", "comment", "attribute", "username", "phrase", "print", "prefix", "expression", "language", "sword", "string", "client", "pattern", "security", "crypt", "input", "application", "device", "email", "database", "address", "login", "name", "command", "wordpress", "shadow", "pass", "p", "token", "description", "property", "hello", "value", "directory", "query", "w", "message", "argument", "reset", " Password", "auth", "word", "Password"], "hash": ["object", "oh", "also", "has", "hex", "locking", "ho", "alg", "cloth", "address", "token", "search", "reading", "message", "sh", "filter", "other", "version", " Hash", "replace", "build", "bh", "ah", "username", "trust", "dig", "mask", "tr", "index", "cache", "ha", "rh", "shadow", "mass", "height", "checking", "ping", "response", "h", "where", "copy", "hing", "html", "user", "total", "ash", "string", "crypt", "shift", "check", "alert", "hed", "value", "ashing", "block", "key", "proof", "method", "str", "log", "test", "Hash", "print", "result", "sha", " hashing", "put", "zero", "title", "handle", "uh", "array", "her", "number", "hello", "tag", "sum", "report", "here", "class"], "md": ["pm", "bd", "MD", "managed", "dh", "det", "cd", "dr", "sd", "sm", "js", "sam", "mand", "ind", "mt", "mod", "add", "dd", "hd", "dir", "del", "sha", "mc", "cmd", "ds", "df", "mk", "nd", "dm", "obj", "pd", "grad", "mp", "d", "der", "di", "ld", "man", "mn", "od", "m", "red", "ad", "mm", "ms", "and"]}}
{"id1": "13233761", "id2": "807346", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["executeUpdateTask", "executeWriteTransaction", "executeWriteTx", "executeUpdateStatement", "startQueryTask", "executeInsertStatement", "startQueryStatement", "startQueryTransaction", "startUpdateTransaction", "executeInsertTransaction", "startUpdateTask", "executeQueryTask", "executeWriteStatement", "executeQueryTransaction", "executeInsertTx", "startQueryTx", "executeInsertTask", "startUpdateStatement", "executeWriteTask", "startUpdateTx", "executeUpdateTx", "executeQueryStatement", "executeQueryTx"], "queries": ["Quands", "quues", "Queries", "gallands", "aquiries", "galleries", "qualeries", "qualands", " Queries", "quenges", " Quands", "queues", "aquands", " Quarks", "aqueries", "qualenges", "gallenges", "galliries", "Quues", "quiries", "qualiries", "queands", " Quues", "quands", "Quarks", "quarks", "aquenges", "queeries", "quearks"], "autoCommit": ["autoCompcommit", "autoAmport", "automaticCompate", "autoAbsate", "automaticCommist", "autoCommate", "autoBemit", "AutoClit", "autoAmits", "autoAmmit", "autoAbsist", "automaticCompcommit", "autoBeits", "automaticCompit", "autoCommcommit", "autoClport", "autoDebist", "automaticCommit", "autoDebcommit", "AutoCommport", "AutoClport", "AutoCommmit", "autoCommits", "automaticCommate", "autoClmit", "autoAbscommit", "autoCommist", "automaticCommcommit", "autoCommport", "autoClits", "AutoCommits", "AutoClmit", "autoCommmit", "AutoClits", "AutoCommit", "autoCompit", "autoClit", "autoDebit", "autoCompist", "autoCompate", "autoAbsit", "automaticCompist", "autoAmit", "autoBeport", "autoDebate", "autoBeit"], "iterator": ["ator", "immigrant", "started", "taker", "former", "river", "reader", "instance", "pler", "oser", "Iterator", "stream", "gener", "encer", "starter", "liner", "collection", "ski", "series", "inner", "bis", "next", "integer", "trace", "loader", "continue", "udder", "iter", "creator", "storage", "rows", "ner", "operator", "menu", "pour", "video", "zero", "upper", "rounder", "pee", "pie", "loop", "folder", "processor", "members", "list", "number", "interstitial", "finder", "directory", "size", "sample", "sequence", "seconds", "runner", "values", "giving", "vector", "walker", "internet", "information", "issues", "writer", "ter", "current", "page", "set", "outer"], "query": ["version", "parse", "request", "comment", "test", "series", "sq", "join", "prefix", "qu", "result", "string", "q", "update", "menu", "check", "family", "title", "name", "Query", "command", "term", "quest", "escape", "password", "script", "description", "execute", "row", "question", "lock", "sequence", "sql", "message", "condition", "subject", "quote", "task", "resource", "table", "code", "key"], "statement": ["confirmed", "parse", "fire", "minute", "binary", "usage", "status", "state", "connection", "comment", "mt", "batch", "print", "phrase", "continue", "expression", "session", "word", "line", "Statement", "rule", "command", "description", "execute", "slot", "template", "sequence", "block", "message", "sql", "group", "condition", "call", "shell", "resource", "table", "task", "ment", "quote", "set", "system"]}}
{"id1": "17193692", "id2": "20602651", "code1": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 0, "substitutes": {"execUpdate": ["executeSelect", " executeSelect", " executeUpdate", " ExecUpdate", "ExecSet", " ExecSet", "executeSet", "ExecSelect", " ExecAction", " executeAction", " executeSet", "executeUpdate", " ExecSelect", "ExecAction", "ExecUpdate", "executeAction"], "sqlStmts": ["sqlSylsts", "sqlStrrters", "sqlStrmps", "sqlStrrns", "sqlStrmments", "sqlStrts", "sqlStamuts", "sqlStlsts", "sqlStmtks", "sqlStamths", "sqlStrrnt", "sqlStarmters", "sqlStsps", "sqlSylms", "sqlStmtns", "sqlStrrls", "sqlStmtms", "sqlSymts", "sqlStrrms", "sqlStmns", "sqlStrrths", "sqlStmments", "sqlStmuts", "sqlStmrks", "sqlStrrmps", "sqlStmms", "sqlStlps", "sqlStamters", "sqlStmtsts", "sqlStrmks", "sqlStrmuts", "sqlSttmts", "sqlStamts", "sqlStrmms", "sqlStmrts", "sqlStlters", "sqlStrruts", "sqlStrms", "sqlStrmns", "sqlSymsts", "sqlStrps", "sqlStrters", "sqlStsts", "sqlStmrters", "sqlStrrps", "sqlStrrmnt", "sqlStrmters", "sqlStrmths", "sqlStrls", "sqlSymps", "sqlStrrmters", "sqlStmps", "sqlStrns", "sqlSttmls", "sqlStmsts", "sqlStmls", "sqlSttmps", "sqlStrrts", "sqlStruts", "sqlSylts", "sqlSttmnt", "sqlStlts", "sqlStrrks", "sqlStarmms", "sqlStrmts", "sqlStarmts", "sqlStrrmts", "sqlStrrments", "sqlStrmnt", "sqlSttmters", "sqlStrments", "sqlStrmls", "sqlStmtters", "sqlStmtts", "sqlStrks", "sqlStlms", "sqlStmks", "sqlStsls", "sqlStsnt", "sqlStmnt", "sqlSymms", "sqlStmtps", "sqlStlments", "sqlStrmsts", "sqlStrnt", "sqlStmrns", "sqlStmths", "sqlSylps", "sqlStrths", "sqlStmters", "sqlStarmments"], "i": ["ip", "ori", "c", "li", "y", "v", "bi", "in", "ii", "phi", "multi", "asi", "point", "key", "I", "id", "u", "xi", "ui", "ind", "mi", "iu", "gi", "uri", "im", "hi", "cli", "x", "is", "ti", "ie", "index", "ci", "slice", "pi", "ij", "ji", "a", "n", "me", "qi", "si", "ix", "ma", "di", "info", "ini", "ei", "ims", "o", "it", "yi", "sim", "j", "my", "\u0438", "m", "z", "ai", "us", "g", "zi", "ic", "ri"], "stmt": ["Stg", " stg", "ostmt", "smt", " stmp", "stmp", "Stt", "stt", "Stmp", "Stmt", "sm", " stMT", "StMT", "stm", "stymsg", "Stmsg", "ostm", "ostg", "smp", " stmsg", "stmsg", "stMT", "stg", "ostMT", " stt", "stymt", " stm", "st", "Stm", "styMT", "stym"]}}
{"id1": "23118425", "id2": "7948308", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypt", "enryption", "encipher", "decrypt", "enipher", "decrypted", "encrypted", "Encrypt", "Encryption", "enrypted", "decryption", "encryption", "decipher", "Encrypted", "Encipher"], "plaintext": [" plainpassword", "publicth", "realstring", "broadtext", "realText", "publictext", " Plainth", " plainText", "realtxt", "plainstring", " plainstring", "plainth", " Plaintext", "publicpassword", "broadText", "publicText", "broadtxt", "plaintxt", " PlainText", "realtext", " plainth", " Plainpassword", "broadstring", "plainpassword", " plaintxt", "plainText"], "md": [" Md", "bd", "MD", "managed", "dh", "det", "cd", "med", "gr", "dr", "sd", "sm", "mt", "ind", "mod", "esm", "dd", "hd", "mc", "del", "dig", "cmd", " dd", "ds", "deb", "mk", " mc", "mb", "dm", "mo", "nd", "df", "pd", "nt", "metadata", "material", "grad", "mp", "d", "der", "ld", "rm", "mn", "od", "m", "doc", "msg", "ad", "mm", "red", "good", "mg", "ms"], "raw": ["rendered", "ng", "data", "extra", "html", "core", "unknown", "full", "available", " RAW", "original", "draw", "hex", "bare", "hook", "out", "input", "RAW", " Raw", "aw", "pack", "cooked", "rew", "known", "n", "orig", "mem", "buf", "clear", "custom", "all", "json", "row", "unsigned", "w", "message", "valid", "bytes", "random", "sh", "clean", "Raw"], "hash": ["ashed", "proof", "bh", "html", "id", "total", "ash", "ssh", "Hash", "has", "print", "dump", "hex", "component", "sha", "mask", "tr", "check", "mac", "cloth", "alert", "ASH", "name", "rh", "password", "handle", "shadow", "hed", "height", "href", "json", "search", "tag", "message", "sum", "ashes", "sh", "h", "key"]}}
{"id1": "3375724", "id2": "19147281", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" insertarEmissoresDosTitulasFe", " insertarEmissoresDosTitULosF", " insertarEmissoresDosTitULosFe", " insertarEmissoresDosTitulOsF", " insertarEmissoresDosTitulosF", " insertarEmissoresDosTitulOsT", " insertarEmissoresDosTitulOsC", " insertarEmissoresDosTituloT", " insertarEmissoresDosTitULoFe", " insertarEmissoresDosTitulasF", " insertarEmissoresDosTitULoF", " insertarEmissoresDosTituloFe", " insertarEmissoresDosTitulosC", " insertarEmissoresDosTitULoC", " insertarEmissoresDosTitULosT", " insertarEmissoresDosTitulasC", " insertarEmissoresDosTituloC", " insertarEmissoresDosTitULosC", " insertarEmissoresDosTitulasT", " insertarEmissoresDosTitulOsFe", " insertarEmissoresDosTitulosT", " insertarEmissoresDosTitulosFe", " insertarEmissoresDosTituloF", " insertarEmissoresDosTitULoT"], "pArquivoTXT": ["pArquivoFRL", "pArquivoNXT", "pArquivoBxt", "pArquivoXTxt", "pArquivotXT", "pArquivNXT", "pArquivoFBT", "pArquiveNEX", "pArquivTOX", "pArquivoDEX", "pArquivoNEX", "pArquiveNBT", "pArquivoXTXT", "pArquivoDXT", "pArquivoFXT", "pArquiveNXT", "pArquivRXT", "pArquiveNxt", "pArquivRIN", "pArquivTXT", "pArquivoBBT", "pArquivoNRL", "pArquivoTOX", "pArquivTRL", "pArquivoRXT", "pArquiveTEX", "pArquivoNxt", "pArquivoTBT", "pArquivoXTOX", "pArquivoRxt", "pArquivotxt", "pArquivotIN", "pArquivoROX", "pArquivoTIN", "pArquivoFEX", "pArquivTEX", "pArquivoTxt", "pArquivROX", "pArquivoDRL", "pArquivoFxt", "pArquivoTEX", "pArquivoBEX", "pArquivoBXT", "pArquivNxt", "pArquivNRL", "pArquivoTRL", "pArquivTIN", "pArquivoXTIN", "pArquiveTBT", "pArquivRxt", "pArquiveTXT", "pArquivoRIN", "pArquivoNBT", "pArquivotOX", "pArquivTxt", "pArquivNEX", "pArquivoDxt", "pArquiveTxt"], "pAndamento": ["pAndumentoS", "pAndementos", "pandamentoS", "pAndumentO", "pAndmentoS", "pAndumentos", "pAndamentos", "pandmento", "pandmentos", "pAndemento", "pAndmentos", "pandamentos", "pandmentO", "pAndementoS", "pAndumento", "pAndementO", "pAndamentoS", "pandmentoS", "pAndamentO", "pAndmentO", "pandamento", "pandamentO", "pAndmento"], "numeroDoRegistro": ["numeroDoRegistulo", "numeroDoregestros", "numeroDoRegitr", "numeroDoRegendro", "numeroDoRegitulo", "numeroDoRegendulo", "numeroDoregistros", "numeroDoRegendros", "numeroDoRegitros", "numeroDoRegistr", "numeroDoRegistros", "numeroDoRegitro", "numeroDoRegestros", "numeroDoregistulo", "numeroDoRegestulo", "numeroDoregistro", "numeroDoregestr", "numeroDoregestulo", "numeroDoRegestro", "numeroDoregistr", "numeroDoRegestr", "numeroDoRegendr", "numeroDoregestro"], "in": ["scan", "reader", "bin", "din", "min", " din", "inc", "isin", "rin", " sin", "inner", "ln", "inf", "vin", "out", "ner", "input", " nin", "pin", "nin", "In", "n", "thin", "gin", "f", " out", "edIn", "IN", "con", " ins", "from", " inn", "ins", "inn", "m", "cin", "tin", "sin", "kin", "inning"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestination", "stmtLimpezaInicialDecinos", "stmtLimpezaInicialDestination", "stmtLimpezaInicioEstinos", "stmtLimpezaInicialDecino", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialStINO", "stmtLimpezaInicialDestINO", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialEstaine", "stmtLimpezaInicialStinos", "stmtLimpezaInicialDestaine", "stmtLimpezaIniciaEstination", "stmtLimpezaIniciaEstinos", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciaEstino", "stmtLimpezaInicialStino", "stmtLimpezaInicialStaine", "stmtLimpezaInicialdestino", "stmtLimpezaInicioEstino", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialdestinos", "stmtLimpezaIniciaDestINO", "stmtLimpezaInicialDecINO", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialDecaine", "stmtLimpezaInicialEstINO", "stmtLimpezaInicioEstINO", "stmtLimpezaIniciaDestinos", "stmtLimpezaInicioEstaine", "stmtLimpezaInicioDestaine", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialEstination", "stmtLimpezaIniciaEstINO", "stmtLimpezaInicialEstino", "stmtLimpezaInicioDestino", "stmtLimpezaInicioDestinos", "stmtLimpezaInicialStination"], "sql": ["qs", "dl", "SQL", "details", "lex", "inv", "spr", "sd", "sn", "nl", "str", "js", "html", "select", "csv", "log", "raw", "sv", "eps", "sq", "join", "statement", "expression", "ln", "scl", "serv", "session", "string", "q", "cmd", "ssl", "ls", "ql", "pel", "spec", "name", "format", "command", "params", "script", "url", "description", "json", "template", "query", "wal", "rel", "seed", "pp", "socket", "msg", "xml", "s", "sp", "sol", "fn", "xs"], "stmtDestino": ["stmtStination", "stmtInstination", "stmtdestino", "stmtDecino", "stMTDestino", "stmtInstino", "stMTDecinos", "stmtStino", "stmtStorno", "stmtDestINO", "stmtDestinos", "stmmInstino", "stmtStINO", "stMTDecin", "stmtDestination", "stMTDestin", "stMTDestinos", "stmmDestinos", "stmmInstorno", "stmmInstination", "stmtdestin", "stMTDestINO", "stmtdestINO", "stmtStinos", "stmtDecINO", "stmtInstorno", "stmmDestination", "stmtdestorno", "stmtDestorno", "stmtDecin", "stmtDecinos", "stmmDestino", "stMTDecINO", "stmtdestinos", "stmmInstinos", "stmmDestorno", "stmtInstinos", "stmtDestin", "stmtdestination", "stmtStin", "stMTDecino"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABECALLHA", "TAMANHO_DO_CABECARH", "TAMANHO_DO_CABUCALHO", "TAMANHO_DO_CABUCALHI", "TAMANHO_DO_CABECILHI", "TAMANHO_DO_CABUCALLH", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALHA", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABUCALLHI", "TAMANHO_DO_CABUCALLHO", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECILH", "TAMANHO_DO_CABECARHA", "TAMANHO_DO_CABECILHO", "TAMANHO_DO_CABUCALLHA", "TAMANHO_DO_CABUCALHA", "TAMANHO_DO_CABECULH", "TAMANHO_DO_CABECILHA", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECALH", "TAMANHO_DO_CABECALLH", "TAMANHO_DO_CABUCALH"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE2Do", "TAMANHO_DO_RODAPE2do", "TAMANHO_DO_RODAPEJFILE", "TAMANHO_DO_RODAPE_FILE", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPE2DO", "TAMANHO_DO_RODAP_FILE", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPE_Do"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADSON", "TAMANHO_DOS_METADADDS_", "TAMANHO_DOS_METADABos_", "TAMANHO_DOS_METADADOON", "TAMANHO_DOS_METADABO_", "TAMANHO_DOS_METADADS_", "TAMANHO_DOS_METADADOSON", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADABOS_", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADABOON", "TAMANHO_DOS_METADADDSON", "TAMANHO_DOS_METADABOSON"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_REMESS", "TAMANHO_MEDIO_POR_REMIS", "TAMANHO_MEDIO_POR_RECis", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_REMES", "TAMANHO_MEDIO_POR_RegIN", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGis", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REMIN", "TAMANHO_MEDIO_POR_REGIN", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegESS", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_Regis", "TAMANHO_MEDIO_POR_REGES"], "tamanhoDosArquivos": ["tamanhoDosArqIVs", "tamanhoDosArquivores", "tamanhoDosArqivo", "tamanhoDosArquesivoes", "tamanhoDosArquesivo", "tamanhoDosArquiveo", "tamanhoDosArquivalores", "tamanhoDosArquiveores", "tamanhoDosArquivlos", "tamanhoDosArquIVoes", "tamanhoDosArqIVores", "tamanhoDosArquIVores", "tamanhoDosArquesivalos", "tamanhoDosArqivs", "tamanhoDosArquivalos", "tamanhoDosArquesivaoes", "tamanhoDosArquivelos", "tamanhoDosArquiveoes", "tamanhoDosArquesivaos", "tamanhoDosArquivals", "tamanhoDosArqivores", "tamanhoDosArquivaos", "tamanhoDosArquIVo", "tamanhoDosArqIVos", "tamanhoDosArquivao", "tamanhoDosArquIVos", "tamanhoDosArquIVlos", "tamanhoDosArquivoes", "tamanhoDosArquivaoes", "tamanhoDosArquivalo", "tamanhoDosArqivos", "tamanhoDosArquives", "tamanhoDosArquIVs", "tamanhoDosArquivo", "tamanhoDosArquesivlos", "tamanhoDosArquesivos", "tamanhoDosArquiveos", "tamanhoDosArqIVo", "tamanhoDosArquivs", "tamanhoDosArquesivao"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstamados", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstamadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstimmados", "quantidadeDeRegistrosEstamado", "quantidadeDeRegistrosEstamada", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmadas"], "registro": ["Regestros", "regitr", "Registrob", "regestrob", "regdistrob", "regitro", "regitrob", "registros", "Regestr", "Registr", "regestr", "regitros", "Regestrob", "registrob", "Regestro", "regdistro", "Registro", "regestro", "regestros", "regdistr", "regdistros", "registr", "Registros"], "campos": ["jamOS", "taro", "tarOS", "jamos", "jamo", "jamOs", " campOS", "campOs", "campo", "taros", "tarOs", "campOS", " campo", " campOs"]}}
{"id1": "2736184", "id2": "20663364", "code1": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"getURLContent": ["postURLBody", "getHTTPContents", "getHTTPBody", "getUrlContent", "geturlBody", "getURLBody", "getUrlBody", "getHTTPContent", "postURLData", "postHTTPBody", "getHTTPData", "getURLContents", "postHTTPContents", "geturlContent", "geturlContents", "getUrlContents", "postHTTPData", "postURLContents", "geturlData", "postHTTPContent", "getUrlData", "postURLContent", "getURLData"], "urlPath": ["urlP", "UrlPath", "dllPa", "uriName", " urlP", " urlPa", "filePo", "urlPo", "urlName", "uriPa", "UrlPo", " urlName", "UrlName", "filePath", "fileName", "uriPath", "dllCl", " urlCl", " urlPo", "uriCl", "fileP", "urlCl", "dllName", "urlPa", "dllPath", "UrlP"], "requestData": ["caseData", " requestString", "referenceDate", "RequestDATA", "caseContent", "requestString", "referenceInfo", "requestInfo", "caseDATA", "questDate", "referenceData", "questData", "requestDATA", " requestInfo", "questInfo", "requestContent", "RequestString", "RequestData", "RequestContent", " requestDate", " requestDATA", "requestDate", "questContent", " requestContent", "caseString", "referenceContent"], "charset": ["cherset", "contablesets", "chablesET", "chablesec", "chersET", "chamesets", "CharsET", " charsabet", "chaset", "chARSET", "charsat", "chARSpec", "chablesets", "contarsets", "chARSet", "contarsET", "chapset", "chableset", "chatsets", "chapsET", " chapsect", "chinspec", "chaspec", "charsabet", "chARSat", "chamesET", "chapsect", "contablesec", "chersabet", "chinsET", "charsect", "chinsect", "ChARSET", "Charspec", "contarset", "chatsec", "chinsabet", "ChARSet", "chameset", "Charset", "chasat", "chasET", "charsets", "contableset", "chinsat", "contablesET", "chatsET", " charsect", " chapset", "charsec", " chapsabet", "charspec", "chapsabet", "chatset", "contarsec", "chinset", "ChARSpec", " chapsET", "ChARSat", "chersect", " charsET", "charsET", "Charsat", "chamesec"], "reader": ["io", "read", "rd", "dr", "in", "rl", "mr", "stream", "rx", "comment", "file", "lr", "print", "inner", "loader", "Reader", "ro", "iter", "parser", "r", "ner", "client", "driver", "ssl", "rer", "rc", "rar", "er", "builder", "wrapper", "row", "query", "runner", "readable", "rr", "handler", "resource", "writer", "ser", "source", "iterator"], "conn": ["org", "ann", "ctx", "en", "comm", " con", "cp", "cmd", "cert", "err", "conv", "on", "init", "conf", "con", "fin", "j", "subject", "canon", "act", "addr", "auth", "connect", "cf", "col", "ont", "nn", "client", "proc", "cc", "ls", "open", "net", "gen", "Connection", "syn", "pg", "ca", "txt", "ct", "tp", "reg", "cs", "ln", "pas", "att", "nt", "exec", "pkg", "cur", "cn", "yn", "dial", "msg", "cont", "nc", "c", "close", "enc", "connection", "Conn", "jp", "ssl", "cb", "res", "obj", "n", "typ", "co", "coll", "wn", "ch", "bo", "rel", "apt", "com", "ns", "lang"], "buffer": ["Buffer", "binary", "memory", "copy", "printf", "commit", "black", "connection", "buff", "comment", "this", "total", "file", "batch", "pool", "document", "print", "temp", "trace", "result", "string", "bar", "queue", "line", "reference", "cache", "database", "program", "command", "buf", "row", "template", "response", "sequence", "block", "message", "output", "report", "table", "code", "bridge", "header"], "out": ["t", "io", "can", "write", "in", "or", "ne", "extra", "user", "os", "by", "OU", "external", "auto", "file", "en", "print", "serv", "aos", "ent", "at", "flush", "sys", "ot", "client", "oss", "no", "gc", "cache", "res", "obj", "end", "nt", "up", "conv", "op", "n", "note", "on", "co", "timeout", "all", "o", "net", "con", "one", "cn", "w", "ch", "outs", "it", "output", "Out", "to", "cos", "g", "writer", "ou", "source", "OUT", "outer"], "url": ["lb", "dl", "ml", "org", "ul", "rl", "nl", "str", "base", "log", "el", "loc", "lr", "l", "b", "gl", "loader", "web", "il", "arl", "q", "r", "ssl", "ls", "open", "mail", "sl", "name", "bel", "ur", "f", "pl", "http", "api", "net", "hl", "ll", "link", "rel", "abs", "ol", "URL", "char", "Url"], "repCode": ["RepCount", " repCount", "respZone", "repRate", "regZone", "repDay", "repZone", "servCount", " repCl", "regCount", "repCount", "RepCode", "respCount", "respCl", "servCode", " repDay", "respCode", "servZone", "respDay", "respRate", "regCode", "regRate", "RepDay", "servRate", "RepCl", "repCl"], "count": ["c", "ctr", "ct", "read", "acc", "max", "core", "cycle", "length", "total", "ind", "batch", "const", "add", "cell", "cc", "child", "index", "cache", "check", "counter", "found", "nt", "n", "start", "amount", "len", "match", "number", "depth", "nb", "conf", "find", "list", "force", "num", "size", "ch", "sum", "char", "report", "Count", "call", "code", "ount", "port", "cont", "current"], "chBuffer": ["echFrame", "achBuff", "echLength", "achLength", "chFrame", "Chbuffer", "charBuff", "ichQueue", "charBegin", "charbuffer", "echbuffer", "ChQueue", "ichbuffer", "achbuffer", "qBuff", " chFrame", "ichBuffer", " chLength", "achFrame", "qbuffer", "ChBuff", "echBuffer", "chBegin", "ichBuff", "achQueue", "qBegin", "chQueue", "charBuffer", "chLength", "chbuffer", " chbuffer", "chBuff", "ChBegin", "achBuffer", "ChBuffer", "qBuffer"], "input": ["ip", "history", "text", "read", "in", "current", "view", "active", "data", "more", "inc", "raw", "file", "ahead", "image", "inner", "add", "before", "inf", "inside", "q", "client", "pattern", "progress", "open", "Input", "get", "query", "local", "it", "ch", "output", "char", "cont", "background", "source", "form"]}}
{"id1": "189963", "id2": "8788371", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "11153282", "id2": "12417893", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": [" existURL", "existURL", "existUrl", "existUR", "exitsUrl", "exitsURL", "existingUR", "existingURL", "exitsUR", "existsHTTP", " existHTTP", " existUR", "existsUrl", " existsHTTP", " existUrl", " existsUR", "existsUR", "existingUrl", " existsUrl", "exitsHTTP", "existHTTP", "existingHTTP"], "urlStr": ["uriSpec", "UrlSpec", "URLStr", "URLString", "UrlStr", "UrlObj", "urlString", "uriStr", "uriSt", " urlSpec", "urlObj", " urlObj", "UrlSt", "urlSpec", " urlSt", "uriWr", "uriObj", "URLWr", "urlSt", "URLSpec", "uriString", " urlString", " urlWr", "urlWr"], "url": ["lb", "dl", "org", "build", "ul", "conn", "rl", "acl", "nl", "mount", "str", "base", "this", "log", "file", "loc", "l", "b", "uri", "https", "il", "arl", "r", "ssl", "ls", "gc", "job", "sl", "name", "sur", "bel", "ur", "arch", "p", "pl", "http", "ll", "link", "abs", "URL", "char", "null", "Url"], "con": ["compl", "c", "close", "can", "conn", "cont", "re", "Con", "connection", "Conn", "col", "user", "pen", "en", "sub", "inner", "cs", "bc", "cf", "comm", "ln", "ain", "cp", "client", "proc", "cons", "res", "CON", "cond", "open", "conv", "n", "un", "on", "ran", "co", "coll", "soc", "cur", "conf", "num", "cn", "fin", "cm", "ch", "fc", "canon", "rec", "dial", "syn", "com", "ctrl", "cos", "nc", "fn", "connect"], "responseCode": ["conditionMap", " responseType", "ResponseMessage", "responsecode", "responseMap", " responseMap", "replycode", "answerType", "replyMessage", "ResponseCode", "answerZone", "conditionCode", "answerMap", " responseMessage", "responseMessage", "Responsecode", "answerCode", " responsecode", "conditionType", "replyCount", "responseType", "responseZone", "ResponseCount", "responseCount", "conditionZone", "replyCode", " responseZone", " responseCount"]}}
{"id1": "755203", "id2": "9727056", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "17202158", "id2": "17207832", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readLineIDs", "findZoneID", "readZoneNames", "findZoneNames", "readLocalNames", "readZoneIDS", "findLocalIDs", "readLocalIDS", "readLineNames", "readObjectIDS", "findLocalNames", "readObjectID", "readLocalIDs", "findLocalID", "findZoneIDs", "readLocalID", "findZoneIDS", "readLineID", "readZoneID", "readLineIDS", "readObjectNames", "findLocalIDS", "readObjectIDs"], "zoneFileName": ["zoneFolderName", " zoneFileChain", "zoneFileType", "ZonefileName", "zoneFilenameSource", "zoneFileNames", "zoneFileChain", "ZonefileFilename", "zoneFilesPath", " zonefileName", "zoneFILEType", "zoneFileSource", " zoneFileNames", "zoneDirName", "zoneFolderType", " zoneFilePath", "zonefileName", "ZoneFileSpec", "zoneFilePath", "zoneFilesNames", "ZonefileSpec", "zoneFolderPath", "ZonefileType", "ZoneFileFilename", "zoneFolderFilename", "ZonefileSource", "zoneDirPath", "zonefileType", "zoneFILENames", "zonefileChain", "ZoneFileName", "zonefileSource", "ZoneFileSource", "zonefilePath", "zoneFILEName", " zonefilePath", "zonefileSpec", "ZonefilePath", "zoneFilesChain", "zoneDirSpec", "zonefileNames", "ZoneFileType", "zoneFILEPath", "zoneFILEChain", "zoneDirSource", " zonefileNames", " zonefileChain", "zoneFilenameSpec", "zonefileFilename", "zoneFileSpec", "zoneFilenamePath", "ZoneFilePath", "zoneFilenameName", "zoneFilesName", "zoneFileFilename", "zoneFILEFilename"], "zoneids": ["zlines", "znames", "zoneoids", "zanaires", "elementuploads", " zoneuploads", "zonenaires", "zoneuploads", "elementlines", " zoneoids", "zIDs", " zonecodes", "zipIDs", "zaoids", "zipnames", " zonenames", " zoneIDs", "tznaires", "zuploads", "elementcodes", "zipids", "zaIDs", "zonelines", "zcodes", " zonelines", " zonenaires", "elementids", "tzIDs", "zonecodes", "zoneIDs", "zaids", "tzoids", "zonenames", "ziplines", "tzids", "zids"], "url": ["lb", "dl", "cl", "build", "ul", "rl", "nl", "mount", "str", "base", "user", "this", "log", "file", "loc", "lr", "l", "loader", "result", "web", "uri", "q", "r", "ssl", "browser", "ls", "open", "ref", "sl", "name", "bel", "ur", "f", "http", "ll", "rel", "ret", "URL", "char", "resource", "Url"], "lnr": ["cnr", "lenr", "nlr", "nlp", "cnp", "lnR", "cncr", "olnR", "lndr", "linr", "lenn", "cnrar", "lnp", "nlrar", "lncr", "nln", "lincr", "nlR", "linp", "olnr", "lnn", "lnrar", "lendr", "lenR", "linrar", "olnn", "nlcr", "nldr", "olndr"], "line": ["text", "day", "le", "lin", "lane", "inline", "range", "point", "nl", "stream", "part", "comment", "log", "file", "liner", "LINE", "print", "l", "phrase", "next", "ln", "continue", "e", "cell", "ge", "Line", "eline", "string", "normal", "stroke", "section", "chain", "ine", "online", "frame", "number", "row", "net", "link", "sample", "block", "sequence", "message", "char", "display", "entry", "style", "code", "word", "page", "header"]}}
{"id1": "8046691", "id2": "18748516", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievedFile", "retractLocal", "detrieveLocal", "detrievedLocal", "detrieveFile", "retrieveImage", "retireLocal", "retractFile", "retrievedLink", "detrieveImage", "retrievedLocal", "retrieveLink", "detrievedImage", "retrievedImage", "retractLink", "detrieveLink", "retractImage", "detrievedLink", "retrieveLocal", "detrievedFile", "retireFile", "retireLink", "retireImage"], "url": ["dl", "ml", "location", "build", "rl", "host", "nl", "run", "str", "base", "id", "u", "el", "file", "l", "image", "web", "uri", "string", "arl", "cp", "ssl", "path", "ls", "job", "ref", "sl", "address", "name", "bel", "un", "ur", "get", "f", "pl", "http", "row", "ll", "abs", "URL", "char", "m", "call", "resource", "Url", "remote", "rect"], "link": ["le", "li", "dl", "detail", "relation", "cp", "mail", "loop", "init", "list", "message", "tool", "remote", "system", "def", " lock", "ml", "build", "links", "file", "l", "add", "loader", "sign", "path", "ls", "index", "open", "ink", "get", "ld", "local", "entry", "label", "style", "error", "ment", "type", "write", "status", "lib", "let", "stream", "download", "self", "image", "post", "line", " jump", "check", "pack", "map", "thread", "light", " load", "load", " delay", "info", "network", "query", "block", "Link", "share", "msg", " reload", "db", "key", "set", "page", " relay", " check", "base", " LINK", "log", "go", "mark", "linked", "ssl", "install", "library", "handle", " block", "tag", "lock", "rel", "master", "task"], "httpConn": ["httpCmd", "httpsCon", "socketConn", "appConn", "HTTPConn", "httpConnect", "httpCon", "ttpSyn", "socketconn", "internalconn", "HTTPCons", " httpconn", "internalCon", "httpsConnection", "HttpConnection", "ttpConn", "httpsCons", "hoverConn", "HttpConnect", "realconn", "appConnect", "socketConnect", "httpSyn", "ttpCt", "localConnection", "hoverCon", "httpCons", "ttpCmd", " httpCt", "hoverConnect", "hoverCt", "HttpConn", "realConn", "htmlCt", "httpsConnect", "hoverCons", "internalCt", " httpConnect", "hoverSyn", "htmlConnect", "htmlConn", "HttpCon", "ttpconn", "ttpConnection", " httpCon", "realConnect", " httpCmd", "appconn", "internalConnect", "htmlconn", "internalConn", "ttpCons", "hoverConnection", "ttpCon", "HTTPConnect", "realCt", "socketConnection", "httpconn", "httpCt", "httpsCmd", "ttpConnect", "httpsconn", " httpSyn", "localconn", " httpConnection", "internalConnection", "localCon", "localConn", "httpConnection", "HTTPCon", "appConnection", " httpCons", "httpsConn"], "outs": ["qs", "gs", "nos", "aps", "locks", "ats", "bs", " layouts", "fits", "os", "als", "eps", "gets", "lists", " ops", "ports", "yout", "bits", "ks", "orts", "out", "ds", "plays", "ows", "ls", "uds", "ops", "dates", "aches", "tops", "its", "uts", "ches", "checks", "lets", " outputs", " out", "offs", "uns", "cells", "ims", "sets", "uploads", "ends", "nets", "ios", "obs", "ins", "boxes", "cos", "s", "ts", "ns", "vals", "aos", "ips"], "bins": ["binn", "lins", "blins", "blans", " binn", "bin", "blouts", "bids", "lin", "bobs", " bans", " bids", "hins", "blinn", "houts", "rans", "lids", "linn", "routs", "bans", "wins", "hin", "linos", "wobs", "blkins", "win", "hobs", "wouts", "blinos", "lobs", " bkins", "blids", " binos", "rkins", "louts", "rins", "binos", "bkins"], "bouts": ["bbyout", "fbins", " baints", " baos", "wbout", "fbyout", "bbins", "bbbs", "Bouts", " bonds", " bout", "fbouts", "wbonds", "wbaos", "bout", "Baints", "Baos", "wout", "wins", "obins", "bbouts", "wonds", "wbouts", "obouts", "wouts", "bbs", "waos", "waints", "byout", "baints", "baos", "fbbs", "obbs", "obyout", "Bins", "bonds"], "postData": ["POSTDATA", "PostBody", "PostData", "PostDATA", "postdata", "PostBytes", " postDat", "postDATA", " postDATA", " postBody", "PostQuery", "formDat", "POSTBody", "postBody", " postBytes", "postDat", "POSTQuery", "postQuery", "Postdata", "POSTDat", "POSTdata", "formData", " postQuery", "postsBytes", " postdata", "postBytes", "POSTData", "POSTBytes", "formdata", "postsData", "formDATA", "postsdata", "postsDATA"], "mimePattern": ["mimeTemplate", " muxTemplate", "smimeFormat", "mIMEFormat", "smimePattern", "mimepattern", "metyPattern", "mimeFormat", " mimeTemplate", "muxTemplate", " mimepattern", " muxpattern", "muxPattern", "metypattern", "mimespattern", "mimesFormat", "smetyPattern", "smetyFormat", " muxPattern", "mimesTemplate", "muxpattern", "smetypattern", "mIMEpattern", "metyFormat", "mIMEPattern", "smimepattern", "metyTemplate", "mimesPattern"], "matcher": ["pather", "mather", "mature", "disure", "patch", " matmatch", "stather", "Match", "statcher", "matter", "discher", "matching", "statching", "statter", "matches", " mature", "Matches", "Matching", "matmatch", " mather", "Mature", "dismatch", "Mather", "Matcher", "match", " matches", " matching", " match", "Matter", " matter", "patter", "disches", "Matmatch", "patcher"], "byteBuffer": ["byteVar", "byteMatrix", "noteVar", "Bytebuffer", "noteBuilder", "bytebuffer", " byteMatrix", "byteFFER", "noteBuffer", "wordMatrix", "charBuff", "wordFrame", "letterbuffer", "wordBuffer", "charVar", "ByteFFER", "bFFER", "ByteBuff", " bytebuffer", "ByteBuffer", "byteBuff", "byteFrame", "letterFrame", "bBuff", " byteVar", "byteBuilder", " byteFrame", " byteFFER", "letterMatrix", " byteBuff", "bbuffer", "noteBuff", "charBuffer", " byteBuilder", "charBuilder", "letterBuffer", "bBuffer", "wordbuffer"], "count": ["c", "ctr", "read", "buffer", "acc", "max", "core", "more", "length", "cycle", "total", "comment", "ind", "batch", "add", "continue", "result", "val", "iter", "cc", "child", "index", "cache", "check", "err", "counter", "found", "nt", "n", "loop", "start", "amount", "len", "all", "find", "list", "conf", "number", "first", "depth", "num", "force", "size", "ch", "cap", "sum", "char", "Count", "call", "code", "ount", "last", "C", "cont", "current"]}}
{"id1": "22418839", "id2": "1188100", "code1": "    public void handleHandshake(Packet2Handshake par1Packet2Handshake) {\n        boolean flag = true;\n        String s = par1Packet2Handshake.username;\n        if (s == null || s.trim().length() == 0) {\n            flag = false;\n        } else if (!s.equals(\"-\")) {\n            try {\n                Long.parseLong(s, 16);\n            } catch (NumberFormatException numberformatexception) {\n                flag = false;\n            }\n        }\n        if (!flag) {\n            netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" });\n        } else if (par1Packet2Handshake.username.equals(\"-\")) {\n            addToSendQueue(new Packet1Login(mc.session.username, 29));\n        } else {\n            try {\n                URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString());\n                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s1 = bufferedreader.readLine();\n                bufferedreader.close();\n                if (s1.equalsIgnoreCase(\"ok\")) {\n                    addToSendQueue(new Packet1Login(mc.session.username, 29));\n                } else {\n                    netManager.networkShutdown(\"disconnect.loginFailedInfo\", new Object[] { s1 });\n                }\n            } catch (Exception exception) {\n                exception.printStackTrace();\n                netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { (new StringBuilder()).append(\"Internal client error: \").append(exception.toString()).toString() });\n            }\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"handleHandshake": ["handleServerRequest", "handleHandRequest", "handlehandshake", "handlehandRequest", "handleServerication", "handleServershake", " handlehandRequest", "handlehandchange", "handleHealthshake", "handlehandication", " handleHandication", " handlehandshake", " handlehandication", "handleHandchange", "handleHealthchange", "handleHandication", "handleHealthRequest", "handleHealthication", " handlehandchange", "handleServerchange", " handleHandchange", " handleHandRequest"], "par1Packet2Handshake": ["par1Packet2Handlelers", "par1Packet2Hza", "par1Packet2Hler", "par1Packet2Hostza", "par1Packet1Handleshake", "par1Packet1Handle", "par1Packet1Handleza", "par1Packet1handle", "par1Packet2handza", "par1Packet2Hostle", "par1Packet2Handler", "par1Packet2handle", "par1Packet1Handler", "par1Packet2Hshake", "par1Packet2Handlers", "par1Packet2Handlele", "par1Packet2Headlers", "par1Packet2Hostshake", "par1Packet2handler", "par1Packet1handza", "par1Packet1Handlers", "par1Packet2handshake", "par1Packet1Handza", "par1Packet2handlers", "par1Packet2Handleler", "par1Packet2Headshake", "par1Packet2Handleza", "par1Packet1Handlelers", "par1Packet2Handle", "par1Packet2Headle", "par1Packet1handshake", "par1Packet2Headza", "par1Packet1Handshake", "par1Packet1handler", "par1Packet2Handza", "par1Packet2Handleshake"], "s": ["qs", "gs", "c", "t", "sb", "ss", "y", "ps", "save", "v", "se", "ats", "less", "hs", "js", "str", "u", "sam", "sv", "sq", "l", "b", "sort", "e", "su", "gins", "string", "r", "ds", "x", "is", "ls", "sl", "ws", "spec", "conv", "n", "simple", "its", "sing", "p", "f", "rs", "S", "sts", "stats", "w", "abs", "sql", "j", "st", "sym", "sh", "g", "h", "i", "ns", "ts"], "flag": ["agged", "stage", "compl", "sync", "level", "car", "agg", "ground", "status", "bird", "member", "age", "nl", "run", "flags", "log", "file", " Flag", "func", "print", "image", "error", "continue", "lag", "lead", "cmd", "limit", "line", "Flag", "cond", "mail", "FLAG", "f", "ld", "bug", "arg", "tag", "local", "lock", "group", "valid", "field", "char", "leaf", "true", "stay", "store", "xml", "lv", "fail", "bool", "cloud", "set", "and"], "url": ["ml", "dl", "li", "location", "build", "ul", "acl", "nl", "mount", "str", "user", "lr", "l", "web", "gl", "uri", "https", "il", "r", "client", "ssl", "browser", "mb", "ls", "www", "mail", "sl", "address", "bel", "ur", "http", "channel", "ll", "link", "rel", "ret", "URL", "char", "socket", "resource", "xml", "Url", "window"], "bufferedreader": ["buffererwriter", "BufferedReader", "Bufferredbuffer", "Bufferredreader", "bufferingReader", "Bufferredrar", "buffledReader", "bufferedwriter", "Bufferedwriter", "buffererbuffer", "bufferedrar", "buffledrar", "bufferredreader", "Bufferredwriter", "bufferedReader", "buffledreader", "buffererReader", "buffererreader", "bufferredrar", "Bufferedrar", "buffledbuffer", "bufferingwriter", "bufferredwriter", "BufferredReader", "bufferingrar", "Bufferedbuffer", "buffererrar", "bufferredbuffer", "bufferredReader", "bufferedbuffer", "buffledwriter", "bufferingreader", "Bufferedreader"], "s1": ["sts1", "s001", "str1", "sOne", "str2", "psOne", " s001", "s0", "str4", "sesinton", " sinton", "str0", "ps1", "s2", "S4", "ses001", "s4", " s4", "sts001", "S2", "ses1", "ps2", " s0", "stsinton", "ses2", " s2", "ps0", "sinton", "SOne", "S1", " sOne", "S0", "sts2"]}}
{"id1": "8921716", "id2": "88047", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"MD5": ["MD2", "SHA3", "SHA2", " md3", "SHAHash", " MD2", " MD3", "MDHash", "MD3", " mdHash", "SHA5", " md2", " MDHash", " md5"], "text": ["aut", "content", "t", "ct", "buffer", "read", "translation", "str", "data", "ext", "comment", "select", "log", "test", "document", "print", "now", "prefix", "pt", "TEXT", "string", "source", "q", "out", "pattern", "x", "path", "input", "title", "nt", "name", "format", "term", "command", "password", "url", "value", "event", "context", "message", "output", "tx", "subject", "act", "code", "msg", "word", "Text", "form", "txt"], "UnsupportedEncodingException": ["UnsupportedEncoderException", "UnsupportedEncodeEx", "UnsupportedEncodingError", "UnsupportedDecodingError", "UnsupportedEncoderError", "UnsupportedDecoderError", "UnsupportedEncode ", "UnsupportedEncodedException", "UnsupportedEncodeException", "UnsupportedDecoder ", "UnsupportedEncoder ", "UnsupportedEncodingEx", "UnsupportedDecoding ", "UnsupportedEncodeError", "UnsupportedEncodedError", "UnsupportedEncoded ", "UnsupportedDecoderEx", "UnsupportedDecoderException", "UnsupportedEncoderEx", "UnsupportedEncoding ", "UnsupportedDecodingException", "UnsupportedEncodedEx", "UnsupportedDecodingEx"], "md": [" img", "bd", "MD", " cmd", "deep", "ctr", "det", "dr", "Cmd", "sd", "mand", "mt", "ind", "mod", " man", "add", "pt", "dd", " done", "hd", "dir", "dig", "pkg", "cmd", "df", "mk", "nd", "mb", "dm", " med", "hash", "mail", "pd", " mk", "grad", "mp", " ok", "d", " df", " exec", " dist", " doc", " cd", " de", " rand", "mond", "der", "ld", " def", " sch", " del", "mn", "od", "rm", "di", "m", " ind", "red", "h", "mm", "ad", "mg", "ms"], "md5hash": ["md512index", "md3h", "md5index", " md4key", "md3hash", "MD5sum", "MD2sum", "md5key", " md5key", " md4index", " md5Hash", "md4key", "md2hash", "md3hex", "md3key", "md2h", "md512key", "md7hash", "md5Hash", "md512hex", "md4hash", "md3Hash", " md4hex", "MD5h", "md5hex", " md5sum", " md3Hash", "md4Hash", " md5index", "md4index", "md5h", "md2Hash", "MD5hash", "md4hex", "md3index", "md5sum", "MD2h", "md7sum", " md5hex", "MD2Hash", "md4sum", "md3sum", " md3sum", " md5h", " md3h", " md3hash", "md2sum", "md4h", "MD5Hash", "md7h", "md512hash", "MD2hash", " md4hash", "md7Hash"]}}
{"id1": "14865947", "id2": "2910383", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"execute": [" command", "Command", " Run", " evaluate", "Exec", "run", "invoke", " executable", " executions", " resume", " Exec", " interpret", " execution", " manage", " Execution", "Action", "command", "exec", " parse", " dispatch", " executed", " operate", " executing", " executes", "process", " query", " proceed", " eval"], "event": [" command", "t", "ae", "ev", "te", "se", "ce", "Event", " Event", "Ev", "xe", " invocation", " frame", "de", " events", "command", " EVENT", "pe", "exc", "frame", "w", "context", " environment", "ex", "ee", "E", "EE", "ed"], "shell": ["sb", "scroll", "history", "ja", "widget", "fr", "buffer", "pty", "detail", "range", "nl", "quit", "js", "tree", "html", "scope", "help", "stack", "base", "bot", "ssh", "pool", "l", "b", "cell", "body", "session", "console", "Shell", "tools", "sys", "cli", "grid", "line", "theme", "kernel", "screen", "windows", "handle", "root", "layout", "search", "template", "query", "hl", "lock", "message", "sql", "tab", "hell", "microsoft", "tool", "round", "sh", "h", "style", "sol", "window", "system"], "view": ["version", "VIEW", "widget", "cv", "v", "buffer", "View", "views", "tree", "html", "ui", "eye", "document", "image", "review", "vp", "web", "browser", "iew", "vm", "screen", "layout", "ve", "list", "template", "query", "row", "w", "tv", "block", "display", "report", "show", "see", "ou", "window"], "rootFolder": ["rootLibrary", "parentDir", " rootEntry", "bottomFolder", "parentEntry", "coverLibrary", "bottomDisk", "RootDir", "rootDirectory", "coverDirectory", "rootDisk", " rootDirectory", "rootArea", " rootDir", "RootDirectory", " rootCategory", "RootEntry", "rootCategory", " rootDisk", "rootEntry", "RootFolder", "parentDirectory", "bottomLibrary", "rootDir", " rootLibrary", "coverFolder", "parentArea", " rootArea", "parentFolder", "coverDisk", "RootArea", "bottomDirectory", "RootCategory", "parentCategory"], "dialog": ["dialj", "choDialog", "closer", "dializ", "Dialogs", "Dializ", "logDialog", " Dialj", "dialDialog", "selectDialog", "selectoser", " Dialoc", "callog", "callDialog", "clDialog", "selectig", "dialoser", " Dializ", "dliz", "selectog", "logoser", "logog", "callogs", "Dialoc", "dlog", "logig", "callOG", "clog", "choogs", "dialOG", "Dialj", "Dialog", "dialogs", "dialig", "clig", " Dialog", "dlj", "choog", "DialOG", "DialDialog", "dloc", "choOG", "dialoc"], "password": ["encrypted", "request", "buffer", "padding", "secret", "wd", "PASS", "data", "key", "user", "comment", "attribute", "raw", "username", "phrase", "prefix", "expression", "language", "picture", "sword", "string", "pattern", "definition", "hash", "path", "device", "database", "address", "login", "command", "shadow", "pass", "clear", "p", "paste", "description", "words", "hello", "directory", "query", "response", "message", "entry", "reset", "table", "word", "source", "Password"], "md5": ["mb2", "md6", " md512", "mm6", " md64", "MD64", "ma2", "MD7", "mm5", "MD512", "mt5", "ma64", "md512", "mt4", "md64", "mt2", "MD3", "mb512", "m4", "md3", "mt3", " md6", "md7", "m5", "mm7", "mb4", "m3", " md4", " md2", "mb5", "mm2", "ma7", " md7", "MD4", "MD2", "m2", "MD5", "ma5", "MD6", "md2", "md4"], "md": ["pm", " Md", "bd", "MD", "ct", "dh", "pdf", "det", "cd", "dr", "sd", "sm", "mt", "ind", "mod", "pt", "dd", "hd", "mc", "dig", "cmd", " dd", "df", "mk", "mb", "nd", "dm", "hash", "mac", "de", "magic", "pd", "nt", "metadata", "d", "ld", "rm", "mn", "od", "m", "red", "msg", "mm", "mg", "ms"]}}
{"id1": "18962382", "id2": "411595", "code1": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"connect": ["sync", "respond", "submit", "create", "request", "close", "write", "read", "build", "conn", "run", "connection", "bind", "pen", "select", "log", "ssh", "join", "add", "construct", "open", "connected", "setup", "login", "start", "Connect", "use", "fit", "init", "con", "ping", "link", "process", "dial", "config", "establish", "set", "ready"], "IOException": ["IOStatus", "NetworkException", "ioStatus", "NetworkError", "ioError", "IOError", " IOStatus", "ioException", "NetworkStatus", " IOError"], "LoginFailException": ["LoginfailInstance", " LoginfailError", " LoginfailException", " LoginFailInstance", "LoginPassEx", "LoginPassError", "LoginfailException", "LoginfailError", " LoginfailEx", "LoginFailError", "LoginPassException", " LoginFailEx", "LoginfailEx", "LoginFailInstance", " LoginFailError", "LoginFailEx", "LoginPassInstance"], "client": ["c", "het", "cl", "close", "conn", "connection", "user", "server", "controller", "phone", "secure", "cell", "session", "console", "cli", "bolt", "util", "application", "ci", "obj", "command", "url", "co", "http", "contact", "qualified", "list", "channel", "control", "con", "force", "proxy", "local", "response", "bo", "Client", "socket", "store", "config", "node", "call", "resource", "remote", "window", "key", "and"]}}
{"id1": "300397", "id2": "11645260", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "10131427", "id2": "8932510", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyfile", "CopyStream", " copyStream", " cpStream", " cpfile", "CopyImage", " CopyStream", " Copyfile", " cpImage", "CopyFile", "Copyfile", " CopyImage", " cpFile", " copyImage"], "in": ["din", "inc", "isin", "rin", "ind", "el", "en", "l", "b", "inf", "vin", "r", "is", "input", "up", "In", "n", "on", "old", "gin", "edIn", "o", "IN", "it", "st", "from", "ar", "ins", "inn", "cin", "i", "mm", "ic", "s", "source"], "out": ["t", "io", "v", "po", "ne", "help", "os", "str", "log", "file", "l", "b", "serv", "gt", "ot", "oss", "check", "err", "nt", "n", "o", "net", "w", "outs", "it", "ch", "output", "Out", "ex", "to", "i", "s", "ou", "OUT"], "sourceChannel": ["SourceStream", "matchButton", "matchChannel", "ourceChannel", " sourceConnection", "seedApplication", "Sourcechannel", "inputChannel", "SourceChannel", "sourceButton", "sourcechannel", "srcchannel", "srcStream", "ourceStream", "sourceStream", "SourceConnection", "sourceChain", "ourceChan", "resourceChannel", "resourceStream", " sourceButton", "seedChannel", "seedChuck", "sourceChan", " sourceChain", "resourceConnection", "srcButton", "inputConnection", "inputChan", "seedButton", "singleChuck", " sourceStream", " sourcechannel", "singleApplication", "srcChannel", "singleChannel", "singleButton", "ourceChain", "matchApplication", "sourceConnection", "inputChain", "sourceApplication", " sourceChan", "ourceButton", "sourceChuck", "resourcechannel", "ourcechannel", "ourceConnection", "matchChuck"], "destinationChannel": ["DestinationConnection", "DestinationContext", "desticationBlock", "destinatoryBlock", "DestationConnection", "destroyChan", "destationCow", "destensionChan", "desticationChan", "DestationChan", "destationBlock", "destinationChan", "DestinationCow", "destinatoryCow", "destroyConnection", "DestensionClient", "destationContext", "destroyClient", "DestationContext", "destinationsConnection", "destinationContext", "destinationsChan", "DestinationChan", "destinatoryChan", "DestinationClient", "destensionChannel", "destinationConnection", "DestationCow", "destationConnection", "DestensionConnection", "destationChannel", "destensionConnection", "destinationsChannel", "DestensionChan", "DestationChannel", "destinatedContext", "DestensionChannel", "destinatedChannel", "DestinationBlock", "destensionClient", "DestationBlock", "destinatoryChannel", "destinationBlock", "destinationCow", "destinationClient", "desticationCow", "DestinationChannel", "destinatedChan", "destinationsContext", "destationChan", "destroyChannel", "destationClient", "destinatedConnection", "desticationChannel"]}}
{"id1": "14390569", "id2": "18748516", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"title": ["content", "text", "t", "details", "tip", "Title", "type", "padding", "heading", "parts", "html", "help", "prefix", "holiday", "lead", "hd", "string", "hash", "theme", "setup", "name", "term", "metadata", "start", "password", "notice", "layout", "description", "template", "question", " Title", "size", "message", "subject", "label", "msg", "TIT", "filename", "itle", "header", "summary"], "imageURL": ["fileURI", "ImageUrl", "mediaURL", "imageUrl", "photoUrl", "photoURL", "imageString", "ImageURI", "fileURL", "fileUrl", "ImageURL", " imageString", "mediaID", "ImageID", "mediaUrl", "mediaURI", "imageURI", "photoID", " imageURI", "photoUR", "imageID", " imageUrl", " imageUR", "imageUR", "photoURI", "photoString", "fileString", "ImageUR"], "jd": ["ajdm", "jsD", "jjD", " jad", "jbd", "ijd", "qds", "djc", "qD", "jdt", "jc", "jsd", " jc", "JD", "javadm", "simmd", "zd", "Jds", "Jd", "Jbd", " jds", "Jc", "jdm", "ijD", "djd", "ajd", "zad", "ujD", "simD", "ujad", "jmd", "jobd", "ujd", "ajpd", "qbd", "Jad", "jpd", "jobdt", "gbd", "jjd", "javapd", "Jdt", "jobdo", "jD", "zsd", " jdt", "simdt", "jspd", "gdo", "jad", "ijds", "jsdm", "djad", "javads", "Jp", "ujmd", "kds", "jdo", "Jmd", "simd", "kdo", " jsd", " jD", "jds", "ajds", "djsd", "kd", "qp", "gds", "Jdo", "djds", "kdt", "kbd", "jsds", "jjp", "jjbd", "djdo", "ujdt", "qd", "gd", "javad", "qdo", " jdo"], "jl": ["jj", "ja", "lp", "dl", "li", "Label", "J", "jet", "yl", " li", "rl", "mil", "nl", "js", "dyl", "elle", "jc", "ln", "il", "jin", "kel", "ijk", "kn", "dll", "elt", "bol", "ji", "ij", "abl", "ibl", "elly", "ell", "jac", "uj", "kl", " ol", "bj", "isl", "j", "syn", "gn", "lu", "lv", "jah", "igl", "dj", "kj", "txt"], "icon": ["ico", "pic", "iban", "ocon", " tip", "conn", "chron", " fruit", "font", "ICO", "pen", " lang", "fa", " conn", "\u4e2d", "jc", "iao", "image", " intent", " ion", "png", "nic", "cil", "gc", "conv", "icol", "eric", "icons", "Icon", " ancestor", "con", "cn", "lock", " widget", "ex", " canvas", "syn", "label", " captcha", "ion", "addon", "ic", "fn", " screen", " Icon"], "chooser": [" choicer", "choicer", "compose", "poicer", "choose", "CHOicer", "booser", "boosen", " choose", "Chooser", "comperer", " choosen", "chooder", "Choose", "Choosen", "composen", "Chooder", "Choicer", " chooder", "pooder", "boose", "CHOoser", "choosen", "pooser", "CHOosen", "CHOose", "choerer", "composer", " choerer", "compicer", "poose", "boerer"], "jp": [" np", " sip", "ja", "np", "JP", "pic", "js", " mp", " joint", "jc", " cp", " ap", "jin", "ij", " sp", "p", "btn", " ja", " dj", "bj", "bp", "j", " gp", " pl", " ip", " je", " pic", "sp", "kj"], "jb": ["qcb", "jbd", "qb", "qbd", "kjbd", "Jbd", "jcb", "Jb", "kjb", " jcb", "Jcb", "kjcb", " jbd"], "e": ["c", "t", "v", "ev", "te", "or", "es", "re", "u", "en", "Event", "ie", "a", "er", "n", "p", "f", "d", "o", "event", "w", "it", "E", "ee", "m", "g", "s", "ed"], "returnVal": ["getVol", "retValue", "retval", "ReturnVal", "returnValid", " returnValue", "responseVal", " returnValid", "responseVol", "ReturnVAL", "responseVAL", "Returnval", "ReturnValue", "retVal", "returnVol", "getVAL", "getValid", "returnValue", " returnVol", " returnval", " returnVAL", "returnVAL", "returnval", "retVAL", "responseValid", "getVal"], "file": ["le", "io", "create", "buffer", "fe", "type", "status", "or", "run", "tree", "base", "core", "user", "FILE", "full", "File", "document", "image", "relation", "dir", "place", "drop", "body", "il", "source", "ile", "path", "library", "work", "open", "rule", "name", "format", "foo", "handle", "get", "f", "http", "be", "target", "channel", "info", "fs", "fp", "local", "link", "valid", "report", "null", "real", "angle", "stat", "to", "table", "resource", "port", "h", "db", "model", "word", "page", "filename", "class"], "fileName": ["FileSystem", "FileSet", "taskName", "fileExt", "entitySet", "FILESet", "fileSet", "FileFace", "ileClass", "handleNAME", "handlename", "imagename", "ileNAME", "imageNAME", "fileFace", "fileSystem", "entityNAME", " fileExt", "FILESystem", "handleClass", " fileClass", "ilename", "FILEPath", "handleName", "FilePath", "imageName", "FileName", "FileNAME", "FILEExt", "FILEName", "fileNAME", "imagePath", "filePath", "fileNames", "ileName", " filePath", " fileSystem", "entityPath", "FILENames", "FileNames", " fileNames", "entityName", "fileClass", "taskname", "Filename", " fileNAME", "FileExt", "imageFace", "taskFace", "taskPath", " filename", "filename", "FILENAME"], "ext": ["t", "ct", "fr", "enc", "Ext", "off", "lex", "lib", "eur", "part", "EXT", "external", "ind", "test", "xt", "hex", "dir", "aux", "cod", "cmd", "sem", "vert", "end", "ec", "typ", "req", "exp", "xp", "exc", "len", "ix", "pat", "ord", "desc", "ag", "exe", "ex", "prot", "cont", "word", "def", "txt"], "i": ["ori", "li", "y", "bi", "status", "ii", "phi", "I", "id", "xi", "ui", "mi", "iu", "print", "gi", "hi", "cli", "is", "ti", "index", "ci", "pi", "qi", "si", "init", "info", "di", "ini", "ei", "it", "j", "fi", "m", "ai"], "doIt": [" doWhich", "waIt", " doIs", "doneit", "doneIT", " doHe", "diIt", "donIT", "didYou", "diHe", " doit", "doWhich", "donit", " doIT", "odoit", "odoHe", "odoWhich", "waIs", "donIt", "diit", "donIs", "doYou", "donYou", "doneIt", "odoIt", "didit", "waIT", "doIs", "doIT", "didIt", "doit", "didIs", "odoIT", " doYou", "diWhich", "doHe"], "src": ["lb", "gs", "sb", "ources", "ctr", "tmp", "trans", "sr", "copy", "sc", "rl", "rx", "usr", "rob", "rest", "loc", "sq", "inner", "sub", "https", "sys", "r", "proc", "ssl", "impl", "input", "crop", "ource", "sl", "rc", "rb", "conv", "ptr", "start", "url", "comp", "http", "init", "rt", "sec", "rs", "rel", "st", "from", "ins", "syn", "sh", "inst", "cont", "ser", "source"], "dest": ["est", "tmp", "coord", "Dest", "trans", "can", "pipe", "des", "usr", "nom", "rest", "loc", "foreign", "temp", "dir", "https", "pas", "iter", "origin", "sys", "cp", "out", "proc", "way", "dat", "nw", "pot", "orig", "mem", "comb", "target", "dist", "slave", "gest", "local", "desc", "cat", "output", "st", "rel", "master", "port", "decl", "sp", "cont", "source"]}}
{"id1": "14877116", "id2": "823074", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": [" cpStream", " dupBuffer", " copSingle", " copStream", " copBuffer", "pasteStream", " dupSingle", "pasteFile", " dupStream", " cpSingle", "pasteSingle", " dupFile", " cpBuffer", "pasteBuffer", " copFile"], "source": ["scope", "select", "series", "component", "original", "before", "secure", "origin", "ource", "spec", "up", "init", "search", "service", "char", "subject", "null", "config", "parent", "sp", "remote", "in", "this", "attribute", "file", "none", "path", "ace", "Source", "get", "local", "site", "style", "create", "unit", "status", "copy", "se", "scene", "stream", "self", "image", "string", "ie", "SOURCE", "old", "start", "use", "find", "template", "query", "sample", "sql", "shell", "resource", "scan", "peer", "base", "ce", "dest", "input", "name", "format", "comp", "from", "store", "current", "form"], "target": ["t", "tmp", "mount", "scope", "localhost", "origin", "normal", "primary", "output", "null", "tool", "parent", "remote", " dst", "build", "host", "this", "file", "join", "next", "secondary", "transform", " Target", "path", "alias", "global", "goal", "root", "project", "local", "link", "internal", "site", "style", "window", "Target", "buffer", "type", " targ", "default", "range", "point", "dev", "tree", "update", "gt", "tor", "arg", "template", "force", "it", "that", "to", "table", "resource", "bolt", "set", "peer", "top", "arget", "base", "dest", "test", "print", "theme", "ARGET", "format", "handle", "tif", "master", "port", "current"], "replace": ["keep", "save", "places", "close", "write", "inline", "repair", "copy", "compatible", "remote", "insert", "register", "join", "add", "prefix", " Replace", "place", "update", "fill", "format", "hide", "use", "fix", "load", "delete", "match", "repeat", "find", "search", "first", "rm", "force", "record", "link", "apply", "append", "enable", "only", "display", "report", "null", "change", "store", "share", "placed", "ignore", "include", "repl", "remove"], "bufferSize": [" bufferSIZE", "windowCount", "blockSize", "windowSIZE", "windowSize", " bufferCount", " bufferName", " bufferStyle", "BufferSize", "BufferName", "blockStyle", "blockCount", "blockSIZE", "BufferCount", "bufferSIZE", "bufferStyle", "BufferStyle", "BufferSIZE", "bufferCount", "bufferName", "windowName"], "src": ["sync", "sb", "img", "ctr", "tmp", "sr", "read", "bin", "copy", "in", "sc", "sin", "rl", "stream", "rx", "usr", "str", "dest", "sq", "sub", "secure", "RC", "iter", "sys", "out", "proc", "SOURCE", "input", "obj", "rc", "sl", "conv", "rb", "req", "supp", "Source", "http", "init", "rt", "sec", "cur", "rs", "std", "st", "fc", "ins", "syn", "sf", "inst", "sp", "ser", "txt"], "tarn": ["utorn", "pann", "wtarn", "wtara", " tarm", " tinn", "Tourn", "tard", "tarp", "Tarn", " tann", "starn", " tarp", "starm", "vtorn", "starl", "pourn", "utann", "Tinn", "Torn", "tara", " tarl", "vtarm", "Tara", "vtann", "tharn", " tara", "Tarm", "wtinn", "Tann", "tourn", "yarm", "utard", " tourn", "torn", "parm", "stourn", "tann", "starp", "parn", "yourn", "porn", "vtarn", "wtann", "Tard", "storn", "thourn", "thorn", "utarn", " tard", "tinn", "yarp", "tharl", "tarl", " torn", "tarm", "yarn"], "tardir": [" tardar", "tardore", "tartir", "taredint", " tartart", " tarddir", "tardart", "tardr", "tartore", " tardore", " tartir", " tardint", "tarddir", "taddir", " tartr", "taredir", "tartdir", "tradr", " tardr", "tartart", " tarnir", "tartar", "taredar", "tradart", "tadr", " tarnr", "tadir", "tarnir", " tartore", " tardart", "tarnore", "tartr", "tardint", "tarnint", "tadint", "tadar", " tarnint", "tarnr", "tradir", " tarnar", "tarndir", " tarndir", "tareddir", "tarnart", "tradore", "tardar", "tarnar"], "n": ["c", "t", "count", "y", "nu", "sn", "max", "k", "nl", "nr", "ind", "en", "norm", "l", "next", "ln", "na", "nn", "x", "index", "nt", "nan", "un", "on", "N", "d", "number", "nb", "mn", "con", "num", "cn", "w", "j", "m", "z", "nm", "g", "i", "nc", "ns"], "tar": ["car", "parse", "ctr", "tf", "gz", "cube", "buffer", "stable", "dr", "te", "copy", "or", "part", "tg", "archive", "csv", "cro", "sv", "add", "bare", "mar", "war", "dra", "nut", "mask", "tr", "tan", "Tar", "par", "pack", "tap", "rar", "roo", "tif", "cast", "tor", "qa", "vol", "cat", "sea", "sum", "ar", "star", "store", "gob", "trap", "cot", "zip", "box", "bolt", "drop", "gre", "txt"], "bytes": ["qs", "ings", "gs", "strings", "classes", "es", "bs", "parts", "services", "frames", "series", "gets", "pins", "ones", "cs", "bits", "pages", "rows", "versions", "elines", "some", "reports", "ls", "bags", "unks", "bps", "its", "Bytes", "words", "cells", "les", "users", "lines", "seconds", "blocks", "resources", "outs", "values", "files", "groups", "pieces", "steps", "boxes", "bles", "vals", "ips", "tes"], "readn": [" readl", "loadn", "loadl", "rollns", "writel", "writeN", "readle", "Readnl", " Readl", "writens", "readnl", "loadnn", "ReadN", "rollle", "writen", "readnn", "Readl", " readnl", "readns", "writele", "printl", " Readnl", "printn", "Readn", "rolll", "Readnn", "writenn", "rolln", " Readn", "readN", "printns", "loadN", "printle", "readl"]}}
{"id1": "4164833", "id2": "3806532", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"buildDeb": ["buildAud", " rebuildDub", "BuildDeb", " builddeb", " rebuildAud", "BuildDub", "buildDub", " buildAud", " rebuildDeb", " buildDub", "builddeb", "BuildAud", " rebuilddeb", "Builddeb"], "debFile": [" debFilename", "debFiles", "ubFilename", "pkgFilename", "audFilename", "obFile", "audFile", "obile", "ubfile", "audFiles", "obfile", "debFILE", " debile", "debFilename", "debfile", "pkgFiles", "ubFile", "ubile", "pkgFILE", " debFILE", " debFiles", "pkgFile", "debile", " debfile", "obFilename", "audFILE"], "controlFile": ["rolfile", "scriptFile", "rolFile", "rolFILE", "scriptFiles", "datafile", "dataChain", " controlLog", " controlChain", "controlfile", "configfile", "controlFILE", "ctrlFiles", "ctrlLog", "ctrlFile", "ctrlChain", "controlChain", "ctrlFILE", " controlfile", "scriptFILE", "configFILE", "dataLog", "dataFiles", "controlLog", "configFiles", "configFile", "scriptfile", "ctrlfile", " controlFiles", "controlFiles", " controlFILE"], "dataFile": ["DATAFiles", " dataLot", "byLot", "dataList", "datafile", "runFILE", "DataTable", "DataFile", " dataSet", "helpFile", "DATAFile", "datfile", "byFile", "valueFiles", "dataFILE", "runLot", "runSet", "valueFile", "dataStream", "runList", "helpfile", " dataFILE", " dataList", "dataFiles", "valueLot", "datFILE", "dataTable", " dataTable", " dataStream", "byFiles", "dataSet", "DATAStream", "DataFiles", "helpLot", "helpList", "datSet", "valueFILE", "byFILE", " datafile", "runFile", "DataStream", "dataLot", "datFile", " dataFiles", "runfile", "DATATable"], "now": ["low", "then", "app", "create", "Now", "aj", "fx", "off", "age", "length", "full", "loc", "percent", "post", "NOW", "since", "ow", "www", "time", "aw", "zero", "java", "today", "on", "start", "old", "always", "date", "present", "after", "sw", "stuff", "first", "cur", " NOW", "num", "force", "size", " Now", "from", "wait", "store", "current", "here", "set", "system", "and"], "deb": ["dl", "stab", "cd", "sd", "dp", "sub", "review", "comm", "web", "cp", "cmd", "Deb", "conf", "prep", "fin", "cm", "gob", "decl", "def", "bb", "reb", "compl", "debug", "rob", "ib", "bar", "eg", "df", "de", "req", " Deb", "erb", "ub", "img", "priv", "dep", "iban", "dev", "etc", "download", "broad", "del", "eb", "ob", "pay", "og", "dat", "dan", "debian", "av", "pkg", "be", "db", "sb", "jpg", "und", "fb", "div", "dt", "dec", "mb", "put", "dm", "cb", "aud", "bl", "gif", "daily", "rel", "abs", "desc", "we", "report", "com", "red", "pub"], "control": ["scroll", "history", "compl", "ctr", "content", "rl", "core", "controller", "rol", "controlled", "const", "comm", "cell", "ro", "console", "cc", "cmd", "cons", "check", "cond", "setup", "Control", "critical", "rc", "command", "co", "comp", "con", "ll", "crit", "cm", "rel", "correct", "trl", "roll", "ctl", "com", "ctrl", "config", "code", "ca", "cont", "current", "connect", "form", "system"], "buffer": ["scroll", "parse", "history", "memory", "binary", "window", "Buffer", "view", "stack", "stream", "buff", "base", "length", "comment", "attribute", "batch", "document", "phrase", "print", "temp", "result", "iter", "button", "bar", "queue", "shape", "library", "cache", "hold", "database", "chain", "term", "command", "note", "variable", "buf", "absolute", "paste", "frame", "match", "number", "directory", "template", "row", "sample", "sequence", "block", "message", "append", "bo", "context", "label", "table", "function", "resource", "filter", "bridge", "rule", "page"], "read": ["text", "then", "run", "select", "draw", "give", "mix", "iter", "pe", "search", "val", "like", "valid", "char", "readable", "ek", "config", "connect", "io", "build", "reflect", "READ", "in", "each", "bind", "core", "add", "dd", "ro", "index", "play", "req", "get", "pass", "height", "match", "rand", "error", "remove", "est", "count", "rd", "write", "se", "stream", "length", "raw", "check", "hold", "thread", "old", "start", "exec", "len", "load", "depth", "find", "query", "reads", "cont", "through", "key", "skip", "ang", "ip", "scroll", "reader", "close", "need", "ind", "print", " Read", "input", "fill", "end", "handle", "send", "size", "ke", "seek", "report", "red", "word", "push"], "data": ["meta", "reader", "bin", "debug", "DATA", "dev", "extra", "help", "ata", "auto", "raw", "file", "test", "div", "batch", "image", "bus", "da", "error", "next", "na", "normal", "video", "no", "cache", "database", "dat", "news", "d", "feed", "http", "di", "list", "info", "query", "one", "internal", "rel", "valid", "to", "mu", "table", "not", "share", "good", "window", "db", "def"]}}
{"id1": "11153282", "id2": "11049257", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": [" existURL", "existURL", "existUrl", "existUR", "exitsUrl", "exitsURL", "existingUR", "existingURL", "exitsUR", "existsHTTP", " existHTTP", " existUR", "existsUrl", " existsHTTP", " existUrl", " existsUR", "existsUR", "existingUrl", " existsUrl", "exitsHTTP", "existHTTP", "existingHTTP"], "urlStr": ["uriSpec", "UrlSpec", "URLStr", "URLString", "UrlStr", "UrlObj", "urlString", "uriStr", "uriSt", " urlSpec", "urlObj", " urlObj", "UrlSt", "urlSpec", " urlSt", "uriWr", "uriObj", "URLWr", "urlSt", "URLSpec", "uriString", " urlString", " urlWr", "urlWr"], "url": ["lb", "dl", "org", "build", "ul", "conn", "rl", "acl", "nl", "mount", "str", "base", "this", "log", "file", "loc", "l", "b", "uri", "https", "il", "arl", "r", "ssl", "ls", "gc", "job", "sl", "name", "sur", "bel", "ur", "arch", "p", "pl", "http", "ll", "link", "abs", "URL", "char", "null", "Url"], "con": ["compl", "c", "close", "can", "conn", "cont", "re", "Con", "connection", "Conn", "col", "user", "pen", "en", "sub", "inner", "cs", "bc", "cf", "comm", "ln", "ain", "cp", "client", "proc", "cons", "res", "CON", "cond", "open", "conv", "n", "un", "on", "ran", "co", "coll", "soc", "cur", "conf", "num", "cn", "fin", "cm", "ch", "fc", "canon", "rec", "dial", "syn", "com", "ctrl", "cos", "nc", "fn", "connect"], "responseCode": ["conditionMap", " responseType", "ResponseMessage", "responsecode", "responseMap", " responseMap", "replycode", "answerType", "replyMessage", "ResponseCode", "answerZone", "conditionCode", "answerMap", " responseMessage", "responseMessage", "Responsecode", "answerCode", " responsecode", "conditionType", "replyCount", "responseType", "responseZone", "ResponseCount", "responseCount", "conditionZone", "replyCode", " responseZone", " responseCount"]}}
{"id1": "22401746", "id2": "4562786", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 1, "substitutes": {"sendRequest": [" sendCommand", "sendCommand", " sendrequest", "submitrequest", "Sendrequest", " sendPost", "SendRequest", "sendPost", "submitRequest", "sendrequest", "submitPost", "submitCommand", "SendPost", "SendCommand"], "servletName": ["servLETNames", "servenderFamily", "servidgetName", "servendername", "serviceletname", "ServLETName", " servletPath", "servletsPath", " servletsName", "servletFamily", "serviceantName", "ServletSimple", "servletePath", "servletsNames", "serviceletFamily", "servantSimple", "Servletname", "ServLETname", "serviceantname", "servenderName", "servantFamily", "servletsNAME", "servLETSimple", "servleteNames", "serviceletNAME", "servidgetInfo", "servenderNAME", "ServLETInfo", "servLETName", "servLETFamily", " servletsNames", "servletPath", "ServletInfo", "servantName", "servLETNAME", " servletNames", "servidgetname", "servletNAME", "serviceantFamily", "servantname", "servLETPath", "ServLETSimple", "serviceantNAME", "servletInfo", "servleteNAME", "servletname", "servletsName", "servLETname", " servletNAME", "servleteName", "servantNAME", "serviceletName", "servletSimple", "servletNames", " servletsPath", "servidgetSimple", "ServletName", " servletsNAME", "servantInfo", "servLETInfo"], "request": ["reply", "text", "submit", "create", "raw", "attribute", "QUEST", "document", "print", "express", "post", "result", "body", "string", "q", "transform", "input", "application", "work", "address", "command", "accept", "req", "quest", "password", "get", "Request", "send", "execute", "frame", "hello", "value", "query", "question", "response", "message", "output", "report", "argument", "xml"], "reqxml": ["questxml", "questjson", "requestjson", "requxml", "requestml", "reqml", "questml", "requestxml", "requml", "reqjson", "requjson"], "retdoc": ["Retdec", "Retdoc", "retDoc", " defdoc", "RetDoc", " retDoc", " retdec", "retdec", " defDoc", " defdec"], "myurl": ["serverport", "serveruri", "MyURL", "someurl", "mineurl", "myUrl", "someport", "serverUrl", "veryport", "veryuri", "serverurl", "someuri", "miUrl", "MYbase", "minestr", "miurl", "amiURL", "amigl", "mystr", "MYURL", "serverstr", "mybase", "mygl", "Mybase", "minessl", "Myurl", "veryurl", "veryUrl", "serverssl", "myURL", "missl", "mineUrl", "someUrl", "amibase", "myssl", "myuri", "MYurl", "mistr", "amiurl", "MYgl", "Mygl"], "myport": ["Myports", "yourpod", " myPORT", "Mypod", "mipport", "tmppport", "miports", "myphone", "yourport", "Myphone", "Myport", "miwidth", "myPort", "miPort", "miphone", "myPORT", "Mywidth", "tmpport", "mipod", "miport", "yourPort", "mywidth", " mypport", "tmpports", "MyPORT", " myphone", "yourPORT", " mywidth", "miPORT", "Mypport", "tmpPORT", "myports", "mypod", " myPort", "MyPort", "mypport", " myports"], "codebase": ["citybind", " codebind", "pagebased", "pagebas", "createase", "Codebased", "CodeBase", " codebas", "codebind", "cybase", "Codebas", " codebal", "cybal", "codebased", " codease", "codebal", "cybind", "createbase", "codease", "createbas", "Codebase", "createBase", "pagebase", " codebased", "pageBase", "cityBase", " codeBase", "codeBase", "cyBase", "citybal", "Codease", "citybase", "codebas"], "serverURL": ["clientURL", " serverSSL", " serverurl", "serALL", "ServerUR", "Serverurl", "clientHTTP", "serverCL", "erverALL", "browserSSL", "serverUrl", " serverHTTP", "serverURI", "erverURL", "erverCL", "serverSSL", "browserURL", " serverCL", "clientID", "erverRL", "serverurl", "erverUrl", "browserID", "ServerUrl", "ServerER", " serverER", "serverALL", "serverRL", "serverER", "serUR", "browserALL", "serURI", "erverOUT", " serverOUT", "siteOUT", "siteUrl", "erverHTTP", "browserER", "clientUrl", " serverALL", "serverHTTP", "serUrl", "ServerURL", "serverID", "serER", " serverUR", "siteurl", "serCL", "serverUR", "erverUR", "serURL", "browserUR", " serverRL", "ServerRL", " serverID", "browserUrl", "erverER", "siteURL", " serverUrl", "erverSSL", "erverURI", "ServerURI", "serverOUT", "erverID", "erverurl"], "ipdig": ["lipDig", "ipDig", "IPdb", " ipdb", " ipDig", "capdig", "ipmd", "ipdb", "cpmd", "ippmd", "hipdiv", "IPdig", " ipbad", "capdiv", "ipdiv", "phpdig", " ipmd", "ippdiv", "ipbad", "phpcd", "ipcd", "ippcd", "ippDig", "ippdd", "IPDig", "cpdig", "phpbad", " ipcd", "ippdel", "ipdel", "hipdig", " ipdd", "ippdig", "cpdd", "capdel", "capDig", "lipdig", "hipdel", "ipdd", "cpDig", "phpDig", "ippbad", "hipDig", "lipdb"], "url": ["dl", "org", "ul", "conn", "rl", "rawl", "mount", "str", "nl", "u", "el", "file", "log", "l", "gl", "web", "loader", "uri", "il", "https", "r", "ssl", "browser", "deb", "uf", "ls", "www", "ob", "util", "open", "dll", "sl", "uu", "un", "ur", "f", "pkg", "http", "proxy", "ll", "link", "au", "URL", "Url"], "urlconn": [" urlConn", "Urlconn", "lcmd", "weblink", "urlcol", "Urlcon", "lconn", "Urlj", "connlink", "webconn", "connconn", "httpConn", "webConn", "urlcmd", "urlConn", "httpfin", " urlcon", "Urlcmd", "urlj", "llcol", "webcon", "llconn", "urlfin", "connConn", "urllink", "httplink", "webfin", "httpcon", "llConn", " urlj", " urlfin", " urlcol", "lcon", "httpconn", "llcon", "conncon", " urlcmd", "lcol", "urlcon", "lj", "lConn"], "os": ["et", "ss", "io", "Os", " bos", "des", "js", "OS", "pos", "cs", "sys", "ot", "as", "ds", "is", "ls", "res", "ws", "soc", "fs", "o", "rs", "osi", "socket", "cms", "us", "ms"], "req1xml": ["reqxmlhtml", "request1html", "req2xml", "request1xml", "req1ml", "req01html", "reqxmlx", "request2ml", "request2xml", "request1ml", "req01x", "req2x", "req01ml", "reqxmlml", "request1x", "request2x", "req2ml", "reqxmlxml", "req1x", "request2html", "req01xml", "req2html", "req1html"], "cos": [" des", " bos", " outs", "oe", "des", " bout", " los", " om", " ox", "cs", "aos", "oss", "is", "oses", "ous", "uts", "ox", "oops", " nos", "oes", "cms", "osi", " ups", " Os", "oos", " cout"]}}
{"id1": "8932510", "id2": "8069594", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["actionPre", "doPut", "doPre", "doPOST", "DoPut", "actionPost", " doPre", "actionPut", " doPOST", " doPut", "DoPost", "actionPOST", "DoPOST", "DoPre"], "request": ["object", "memory", "select", "web", "session", "reference", "address", "position", "pair", "frame", "search", "first", "condition", "message", "subject", "change", "initial", "xml", "remote", "order", "server", "this", "client", "time", "application", "java", "art", "req", "get", "project", "record", "context", "error", "requ", "remove", "create", "copy", "user", "QUEST", "document", "self", "post", "setup", "quest", "start", "url", "info", "query", "question", "block", "have", "reset", "call", "resource", "forward", "instance", "re", "connection", "complete", "register", "cgi", "input", "enter", "command", "Request", "http", "container", "report", "store", "current", "form"], "response": ["version", "reply", "respond", "object", "onse", "write", "default", "view", "connection", "respons", "tree", "release", "ce", "document", "image", " responding", "result", "session", "render", "application", "res", "success", "resp", "send", "description", "frame", "event", "one", "site", "context", "output", " Response", "report", "reset", "information", "model", "Response"], "is": ["ip", "tis", "ists", "iris", "in", "es", "sis", "isin", "bis", "isc", "isi", "has", "image", "isp", "was", "bits", "xs", "as", "iso", "lis", "ys", "ois", "its", "IS", "si", "init", "ris", "info", "ims", "ais", "isa", "mis", "iss", "ios", "isl", "ir", "obs", "ins", "icks", "i", "Is", "ips", "ms"], "page": ["content", "object", "age", "point", "view", "stream", "po", "part", "html", "data", "server", "pos", "file", "go", "pool", "document", "image", "next", "post", "result", "wiki", "session", "out", "pages", "browser", "menu", "line", "index", "cache", "address", "title", "url", "p", "pe", "token", "frame", "o", "row", "proxy", "link", "Page", "pc", "message", "entry", "pp", "article", "node", "port", "table", "resource", "sp", "error", "form"], "os": ["io", "ps", "Os", "or", "es", "po", " o", "OS", "ui", "pos", "pool", "so", "oss", "iso", "mo", "ops", "res", "op", "si", "sw", "o", "ios", "oid", "offset", "s", "oos", "ms"], "rootUrl": ["baseURL", "baseUr", "homeurl", "parenturl", "homeURL", " rootURL", "parentUrl", "parentURL", "webDir", "webURL", " rootDir", "baseUrl", "webUr", " rootUr", "baseDir", "homeUrl", "rootDir", "rootURL", "rooturl", "rootUr", "parentUr", "homeUr", " rooturl"], "isMultipart": ["isManipand", "isMulticart", "isMultisparted", "isMultiparted", "isMultiisparted", "isManipage", "isMulticarts", "isManIPage", "isMultisparts", "isMultiisparts", "isMultIPage", "isMultiparts", "isManiparts", "isMultiispart", "isManipart", "isMultispand", "isMultiipage", "isMulticage", "isMultiipart", "isMultiiparted", "isMultIParted", "isMultipand", "isMultipland", "isMultiplart", "isMultispart", "isMultiplarts", "isMultIPand", "isMultispage", "isManIPart", "isManIParts", "isMultipage", "isMulticarted", "isMultiispage", "isMultiiparts", "isMultIPart", "isMultiplage", "isMultIParts", "isManIPand"], "rd": ["ird", "rid", "RD", "fr", "ard", "rg", "dr", "td", "rl", "dk", "rown", "ud", "rob", "ind", "xd", "dd", "ro", "rend", "dra", "vd", "nder", "dig", "hd", "erd", "r", "rer", "nd", "rus", "hr", "adr", "rb", "rc", "ra", "hod", "rh", "ptr", "fd", "rt", "ld", "ord", "rs", "yd", "rw", "rand", "gd", "rr", "red", "rn", "rod"], "upload": ["save", "imgur", "ack", "tmp", "create", "pload", "archive", "transfer", "ud", "file", "insert", "download", "ut", "select", "image", "add", "grab", " Upload", "post", "update", "allow", "install", "input", "ow", "aw", "util", "own", "art", "up", "attach", "Upload", "move", "load", "delete", "execute", "row", "uploads", "fax", "form"], "webUrl": ["WebUrl", "netUrl", "wwwUr", "webPort", "httpUr", "WebURL", "httpUrl", "rootVer", "neturl", "weUrl", "wwwUrl", "wwwURL", "weUr", "webURL", "netUr", "weURL", "netPath", "webUr", "webPath", "rootPort", "weVer", "wwwPath", "weurl", "netURL", "Weburl", "rootPath", "weburl", "rootURL", "httpVer", "httpPort", "WebUr", "wePort", "rootUr", "webVer"], "iter": ["ip", "ator", "li", "former", "cer", "reader", "where", "fer", "iz", "inv", "ver", "orient", "IT", "order", "ind", "inter", "loc", "ipper", "oper", "inner", "ait", "next", "loader", "kit", "dir", "ner", "tr", "er", "iterator", "loop", "tif", "coll", "iv", "init", "train", "it", "valid", "ir", "iner", "walker", "i", "ter", "iver", "ser", "outer", "Iter"], "item": ["ip", "object", "li", "unit", "instance", "status", "or", "member", "in", "order", "base", "el", "file", "Item", "attribute", "image", "error", "other", "im", "hit", "step", "obj", "rule", "up", "mem", "info", "element", "json", "row", "value", "option", "module", "event", "it", "record", "link", "local", "area", "block", "tab", "entry", "stat", "container", "m", "store", "mm", "atom", "word", "source", "key", "iterator"], "name": ["named", "type", "Name", "part", "data", "order", "id", "base", "file", "ame", "prefix", "common", "string", "normal", "path", "no", "family", "alias", "magic", "title", "a", "term", "n", "old", "on", "NAME", "names", "ma", "len", "channel", "o", "module", "event", "local", "size", "block", "one", "cap", "num", "sequence", "label", "resource", "parent", "word", "source", "key", "class"], "baos": ["BAis", "BAoes", "baOS", " baops", "BAoss", "boos", "wais", "daOS", "booS", "booes", "aooss", "BAoS", "kaoes", "waOS", "gaos", "bois", "BAOS", "gaoS", "kaOS", " baoss", "baoss", "baops", "bais", "kaoss", "boo", "daos", "aoOS", "gais", "booss", "daoes", "baoes", "waos", "boops", "BAops", "aoos", "daoss", "gaoss", "boOS", "BAo", "waoss", "kaos", "BAos", "bao", "baoS", " bao", "aooS", "gaOS", " baoes"], "wpIs": ["xpI", "wpShares", "wpIm", "ipInst", "wtShares", "hwIS", "phpis", "cpIS", "wtI", "phpIS", "wtIs", "cpis", "WPI", "hwInst", "wpI", "WPUrl", "phpIs", "wordpressis", "WPInst", "fwI", "wpAre", "wpis", "WPIS", "wordpressIm", "hwI", "ipIs", "wpInst", "cpIs", "fwIm", "WPIm", "wpIS", "ipI", "phpI", "phpShares", "xpShares", "wordpressUrl", "fwIs", "wordpressIS", "fwUrl", "wordpressIs", "wordpressI", "WPIs", "xpIs", "wtAre", "hwIs", "wpUrl", "xpAre", "ipIS", "phpAre"], "u": ["fu", "uv", "io", "ul", "nu", "eu", "uid", "user", "ui", "iu", "l", "gu", "su", "uri", " nu", "hu", "uni", "r", "uf", "ux", "ue", "cu", "uu", "ur", "url", "p", "f", "o", "uj", "tu", "w", "it", "au", "U", "mu", "us", "lu", "ru", "i", "bu", "ou"]}}
{"id1": "13891080", "id2": "17557289", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyDir", "transferFile", "cloneTo", " copyStream", " copyTo", "cloneDir", "cloneFile", "transferTo", "transferDir", " copyDir", "copyStream", "transferStream", "copyTo", "cloneStream"], "srcFile": [" srcfile", "subfile", " srcEmail", "srcPath", "initfile", "initEmail", "rcPath", "rcfile", "sourceFile", "subBlock", "subEmail", " srcPath", "sourcefile", "srcfile", "destPath", "rcFile", " srcBlock", "initBlock", "initFile", "srcEmail", "srcBlock", "subFile"], "destFile": ["altFile", "altDir", "refMail", "DestDir", "destStyle", " dstPlace", " destStyle", " destfile", " dstFile", "refFILE", "altfile", "destDir", "litMail", "destFILE", "Destfile", "destMail", "altStyle", " destPlace", "destfile", "DestFile", "litDir", "srcStyle", "srcfile", "destPlace", "refDir", "DestPlace", "litFile", " destDir", " destFILE", "litFILE", "srcDir", "refFile", " dstDir", " dstfile", " destMail"], "srcChannel": ["rbClient", " srcStream", " srcSection", "rcChannel", "rcChan", "subChannel", " srcChan", "srcFace", "rcSection", "curSection", " srcFace", "rcchannel", "rcStream", " srcButton", "srcchannel", "srcStream", "curConnection", "curChannel", "srcSection", "curchannel", "rbFace", "curStream", " srcchannel", " srcConnection", "rbButton", "subClient", "srcButton", " srcClient", "subFace", "srcChan", "srcClient", "curChan", "rcConnection", "rbChannel", "subButton", "srcConnection"], "dstChannel": ["dndConnection", "dotBuffer", "dndChannel", "distBuffer", "ddestChannel", " dotChannel", "rdstChan", "dotChannel", "dotConnection", "ddestConnection", " dotCow", "rddestChan", "dotStore", "dblChannel", "rdstConnection", "dblStore", "ddestBuffer", "dndChan", " dstConnection", " dstChan", " dstCow", "dotCow", "rddestChannel", "dotChan", "rddestStore", "distConnection", " dstBuffer", "dstCow", "ddestStore", " dotConnection", " dstUser", "dstUser", "dstStore", " dotBuffer", "ddestCow", "rdstStore", "ddestUser", "ddestChan", "dblConnection", "distChannel", "dstChan", "rdstChannel", "distUser", "rddestConnection", "dotUser", "dstBuffer", " dotChan", "dblChan", " dotUser", "dndCow", "dstConnection"]}}
{"id1": "16466743", "id2": "3514286", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getmd5": ["getsha5", "getmd6", " getMD6", " getMD2", "getMD5", "getMD4", "getsha2", "getmd4", " getMD5", " getMD4", "getMD6", "getMD2", " getmd6", "getsha4", " getmd4", "getmd2", "getsha6", " getmd2"], "password": ["text", "wd", "secret", "padding", "data", "user", "attribute", "username", "phrase", "prefix", "sword", "string", "pattern", "security", "hash", "path", "email", "database", "address", "name", "login", "wordpress", "shadow", "pass", "Password", "p", "token", "description", "hello", "value", "ew", "w", "message", "entry", " Password", "code", "auth", "word", "key"], "pwHash": ["pwtHas", " pwHas", "pWhash", "pWSum", "pwsHash", "pWHash", "pwsHas", "spwHas", "pwthash", "pwdhash", "pwshash", "pwdHash", "pwtHash", "pwsSum", "pwHas", "pwdSum", "pwhash", "spwhash", "spwdSum", " pwdSum", "spwdHas", "pWHas", "spwHash", "pswSum", "spwSum", " pwdhash", "pswHash", "pswHas", " pwdHas", "pwdHas", " pwdHash", "spwdHash", "pswhash", "pwSum", " pwSum", " pwhash", "pwtSum", "spwdhash"], "md": ["pm", " Md", "bd", "MD", " mo", "det", "cd", " mm", "td", "ng", "sd", "sm", "mt", "ind", "mod", "add", "dd", "hd", "dir", "mc", "dig", "del", "cmd", " dd", "ds", "df", " mc", "mk", "nd", "dm", "mo", "mb", "cond", "mail", "pd", "metadata", "material", "mem", "exec", "grad", "mp", "d", "der", "di", "ld", "rm", "man", "mn", "od", "desc", "def", "m", "doc", "msg", "cmp", "mm", "red", "ad", "mg", "ms"], "b": ["sb", "B", "y", "binary", "v", "bi", "ba", "bh", "bs", "buff", "fb", "bf", "bis", "batch", "bas", "l", "bc", "ib", "bar", "ab", "mb", "eb", "cb", "ob", "br", "obj", "rb", "a", "p", "f", "d", "be", "gb", "nb", "w", "bp", "abs", "bytes", "m", "g", "bu", "db", "bb", "reb"], "i": ["ip", "li", "y", "io", "v", "span", "bi", "in", "ii", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "iu", "mi", "ski", "oi", "l", "gu", "next", "gi", "im", "iter", "q", "hi", "cli", "x", "is", "ki", "ti", "ie", "index", "ci", "pi", "ji", "ij", "a", "n", "p", "qi", "si", "init", "ix", "di", "json", "ini", "ei", "o", "it", "yi", "sim", "j", "my", "\u0438", "m", "ai", "us", "ic", "ri", "ms"]}}
{"id1": "3801655", "id2": "14598566", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"helper": ["hyper", "hoper", "homer", "heler", "duter", "hoter", "helpporter", "helmer", "transmer", "hyter", "helpter", "helporter", "transer", "helhel", "hyhel", "transter", "helter", "duporter", "duper", "duhel", "hoer", "hyporter", "helpper", "helphel", "transper", "helpmer"], "dataset": ["datasET", "dataassET", "dataasET", "datisets", "datbasetic", "datisetic", "datasetic", "Datasset", "datisET", "datarset", "datbaset", "datatet", "datassetic", "Dataset", "Datasets", "databasesset", "databasesets", "datatets", "dataasetic", "datatetter", "datasets", "dataasets", "dataassset", "dataassetter", "dataasetter", "Datasetter", "datassET", "dataassets", "datassetter", "dataassetic", "Datassetter", "datasetter", "datatset", "datarsets", "datiset", "datisetter", "databasesET", "dataasset", "datbasetter", "datarsset", "datbasET", "dataaset", "datassset", "Datassets", "datasset", "datisset", "datassets", "datarsET", "databaseset", "Datassset"], "zip": ["ip", "io", "jar", "pdf", "zone", "lex", "se", "lib", "archive", "file", "download", "ze", "dir", "xf", "install", "zero", "pack", "mail", "rar", "tar", "bag", "handle", "project", "pkg", "comp", "feed", "folder", "json", "directory", "module", "wrap", "lock", "link", "sea", "sheet", "Zip", "z", "code", "xml", "zo", "box", "cf", "system"], "entries": ["trs", "entables", "Enters", "currs", "contrys", "Entrys", "enires", "enrys", "entsers", "entrys", "Entables", "enries", "entities", "geters", "enters", "enresses", "Entities", "Entlements", "entsrys", "getrys", "entires", "curables", "entresses", "entsries", "attries", "curries", "Entires", "trys", "entents", "getries", "entlements", "contresses", "contires", "entrs", "Entresses", "attrys", "entslements", "Entrs", "getlements", "Entents", "Entries", "tables", "currys", "attents", "entsities", "attities", "entsents", "contries", "tries"], "performance": ["union", "scale", "speed", "ul", "evaluate", "due", "volume", "log", "test", "mult", "dimension", "shape", "storage", "grade", "split", "duration", "util", "work", "maximum", "step", "spec", "capacity", "fit", "load", "expected", "force", "sum", "minimum", "cost"], "index": ["level", "Index", "count", "type", "max", "connection", "order", "length", "total", "ind", "pos", "available", "update", "limit", "x", "open", "loop", "capacity", "number", "value", "lock", "size", "seek", "j", "offset", "set"], "entry": ["io", "jar", "instance", "ry", "keeper", "or", "member", "se", "part", "data", "archive", "test", "add", "next", "e", "result", "cell", "ent", "ie", "item", "job", "enter", "ace", "name", "Entry", "element", "match", "channel", "row", "module", "office", "record", "internal", "it", "context", "link", "char", "sheet", "resource", "xml", "cont", "word", "key"], "temp": ["tem", "t", "tmp", "create", "mint", "pdf", "Temp", "copy", "por", "base", "this", "mt", "file", "test", "dest", "mod", "pt", "dir", "tc", "cp", "porary", "mk", "tr", " temporary", "EMP", "partial", "created", "stem", "thread", "tm", "tar", "orig", "mem", "root", "mp", "wrapper", "template", "wrap", "local", "pre", "emp", "tx", "tim", "tab", "null", "empty", "table", "parent", "fake", "current", " tmp", "txt"], "writer": ["ger", "write", "worker", "ler", "wire", "stream", "connection", "server", "external", "file", "document", "print", "loader", "Reader", "iter", "console", "creator", "ner", "driver", "browser", "player", "riter", "writing", "thread", "er", "variable", "builder", "maker", "wrapper", "writ", "Writer", "network", "service", "wp", "penter", "w", "rw", "output", "writers", "message", "walker", "null", "master", "handler", "parent", "ter", "wrote", "owner", "window", "system", "iterator"], "reader": ["peer", "ard", "dr", "ry", "volume", "stream", "rx", "rot", "file", "inner", "loader", "Reader", "ro", "iter", "ner", "r", "driver", "rer", "input", "rar", "er", "handle", "builder", "wrapper", "feed", "row", "reading", "roller", "runner", "readable", "handler", "rr", "ri", "iterator"], "buffer": ["scroll", "history", "memory", "Buffer", "binary", "background", "padding", "stack", "buff", "font", "column", "length", "batch", "document", "phrase", "word", "iter", "bar", "queue", "stroke", "cache", "database", "command", "variable", "capacity", "buf", "frame", "template", "row", "sample", "block", "sequence", "message", "append", "char", "vector", "null", "table", "window", "header"], "read": ["parse", "text", "count", "create", "write", "close", "build", "skip", "READ", "take", "run", "each", "stream", "need", "bind", "length", "select", "used", "raw", "test", "en", "print", "add", "next", "before", "give", "mix", "iter", "q", " Read", "input", "fill", "time", "check", "open", "hold", "end", "format", "mem", "start", "handle", "old", "get", "send", "len", "load", "find", "Read", "query", "like", "tell", "reading", "enable", "reads", "size", "seek", "readable", "report", "word", "source", "set", "ready"], "outfile": ["initfolder", "outbuffer", "outfolder", "outFile", "outstream", "outputstream", "inputfile", " outstream", "infile", "outputfolder", "inputbuffer", "infolder", "outchannel", "initfile", "OUTfile", "initstream", "inchannel", "OUTFile", "outputfile", " outFile", "instream", "outputFile", " outbuffer", "inbuffer", "inputFile", "inputstream", "OUTchannel", "initFile", " outchannel", "inFile"], "line": ["text", "le", "detail", "lin", "inline", "range", "point", "column", "comment", "log", "file", "LINE", "liner", "l", "phrase", "ln", "statement", "e", "cell", "iter", "Line", "eline", "string", "word", "lo", "section", "chain", "ine", "note", "online", "train", "frame", "row", "link", "lines", "sample", "block", "message", "sequence", "char", "code", "msg", "port", "page", "header"], "parser": ["parse", "lp", "cer", "ler", "worker", "auto", "file", "bank", "layer", "asser", "loader", " scanner", "uler", "ner", "operator", "rer", "magic", "policy", "conv", "format", "er", "builder", "maker", "processor", "arser", "pair", "music", "finder", "Parser", "hander", "penter", "runner", "walker", "handler", "xml", "system", "iterator"], "list": ["level", "li", "detail", "dict", "range", "member", "part", "data", "LIST", "file", "pool", "collection", "batch", "lists", "l", "print", "left", "result", "ist", "out", "queue", "menu", "listed", "chain", "map", "array", "all", "match", "record", "sequence", "group", "output", "null", "table", "parent"], "rule": ["parse", "ule", "range", "rl", "re", "run", "file", "rol", "relation", "statement", "result", "Rule", "r", "definition", "item", "policy", "chain", "command", "play", "ULE", "feature", "match", "value", "row", "module", "force", "record", "rank", "block", "field", "role", "style", "rr", "table", "filter", "node", "function"], "measure": ["MEMeasure", "meMeasure", "Measure", "peMeasure", "measuring", "measured", "peasuring", "MeMeasure", "peasured", "MEasuring", "peasure", "Measuring", "MEasured", "MEasure", "Measured"]}}
{"id1": "22401746", "id2": "22875895", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"sendRequest": [" sendCommand", "sendCommand", " sendrequest", "submitrequest", "Sendrequest", " sendPost", "SendRequest", "sendPost", "submitRequest", "sendrequest", "submitPost", "submitCommand", "SendPost", "SendCommand"], "servletName": ["servLETNames", "servenderFamily", "servidgetName", "servendername", "serviceletname", "ServLETName", " servletPath", "servletsPath", " servletsName", "servletFamily", "serviceantName", "ServletSimple", "servletePath", "servletsNames", "serviceletFamily", "servantSimple", "Servletname", "ServLETname", "serviceantname", "servenderName", "servantFamily", "servletsNAME", "servLETSimple", "servleteNames", "serviceletNAME", "servidgetInfo", "servenderNAME", "ServLETInfo", "servLETName", "servLETFamily", " servletsNames", "servletPath", "ServletInfo", "servantName", "servLETNAME", " servletNames", "servidgetname", "servletNAME", "serviceantFamily", "servantname", "servLETPath", "ServLETSimple", "serviceantNAME", "servletInfo", "servleteNAME", "servletname", "servletsName", "servLETname", " servletNAME", "servleteName", "servantNAME", "serviceletName", "servletSimple", "servletNames", " servletsPath", "servidgetSimple", "ServletName", " servletsNAME", "servantInfo", "servLETInfo"], "request": ["reply", "text", "submit", "create", "raw", "attribute", "QUEST", "document", "print", "express", "post", "result", "body", "string", "q", "transform", "input", "application", "work", "address", "command", "accept", "req", "quest", "password", "get", "Request", "send", "execute", "frame", "hello", "value", "query", "question", "response", "message", "output", "report", "argument", "xml"], "reqxml": ["questxml", "questjson", "requestjson", "requxml", "requestml", "reqml", "questml", "requestxml", "requml", "reqjson", "requjson"], "retdoc": ["Retdec", "Retdoc", "retDoc", " defdoc", "RetDoc", " retDoc", " retdec", "retdec", " defDoc", " defdec"], "myurl": ["serverport", "serveruri", "MyURL", "someurl", "mineurl", "myUrl", "someport", "serverUrl", "veryport", "veryuri", "serverurl", "someuri", "miUrl", "MYbase", "minestr", "miurl", "amiURL", "amigl", "mystr", "MYURL", "serverstr", "mybase", "mygl", "Mybase", "minessl", "Myurl", "veryurl", "veryUrl", "serverssl", "myURL", "missl", "mineUrl", "someUrl", "amibase", "myssl", "myuri", "MYurl", "mistr", "amiurl", "MYgl", "Mygl"], "myport": ["Myports", "yourpod", " myPORT", "Mypod", "mipport", "tmppport", "miports", "myphone", "yourport", "Myphone", "Myport", "miwidth", "myPort", "miPort", "miphone", "myPORT", "Mywidth", "tmpport", "mipod", "miport", "yourPort", "mywidth", " mypport", "tmpports", "MyPORT", " myphone", "yourPORT", " mywidth", "miPORT", "Mypport", "tmpPORT", "myports", "mypod", " myPort", "MyPort", "mypport", " myports"], "codebase": ["citybind", " codebind", "pagebased", "pagebas", "createase", "Codebased", "CodeBase", " codebas", "codebind", "cybase", "Codebas", " codebal", "cybal", "codebased", " codease", "codebal", "cybind", "createbase", "codease", "createbas", "Codebase", "createBase", "pagebase", " codebased", "pageBase", "cityBase", " codeBase", "codeBase", "cyBase", "citybal", "Codease", "citybase", "codebas"], "serverURL": ["clientURL", " serverSSL", " serverurl", "serALL", "ServerUR", "Serverurl", "clientHTTP", "serverCL", "erverALL", "browserSSL", "serverUrl", " serverHTTP", "serverURI", "erverURL", "erverCL", "serverSSL", "browserURL", " serverCL", "clientID", "erverRL", "serverurl", "erverUrl", "browserID", "ServerUrl", "ServerER", " serverER", "serverALL", "serverRL", "serverER", "serUR", "browserALL", "serURI", "erverOUT", " serverOUT", "siteOUT", "siteUrl", "erverHTTP", "browserER", "clientUrl", " serverALL", "serverHTTP", "serUrl", "ServerURL", "serverID", "serER", " serverUR", "siteurl", "serCL", "serverUR", "erverUR", "serURL", "browserUR", " serverRL", "ServerRL", " serverID", "browserUrl", "erverER", "siteURL", " serverUrl", "erverSSL", "erverURI", "ServerURI", "serverOUT", "erverID", "erverurl"], "ipdig": ["lipDig", "ipDig", "IPdb", " ipdb", " ipDig", "capdig", "ipmd", "ipdb", "cpmd", "ippmd", "hipdiv", "IPdig", " ipbad", "capdiv", "ipdiv", "phpdig", " ipmd", "ippdiv", "ipbad", "phpcd", "ipcd", "ippcd", "ippDig", "ippdd", "IPDig", "cpdig", "phpbad", " ipcd", "ippdel", "ipdel", "hipdig", " ipdd", "ippdig", "cpdd", "capdel", "capDig", "lipdig", "hipdel", "ipdd", "cpDig", "phpDig", "ippbad", "hipDig", "lipdb"], "url": ["dl", "org", "ul", "conn", "rl", "rawl", "mount", "str", "nl", "u", "el", "file", "log", "l", "gl", "web", "loader", "uri", "il", "https", "r", "ssl", "browser", "deb", "uf", "ls", "www", "ob", "util", "open", "dll", "sl", "uu", "un", "ur", "f", "pkg", "http", "proxy", "ll", "link", "au", "URL", "Url"], "urlconn": [" urlConn", "Urlconn", "lcmd", "weblink", "urlcol", "Urlcon", "lconn", "Urlj", "connlink", "webconn", "connconn", "httpConn", "webConn", "urlcmd", "urlConn", "httpfin", " urlcon", "Urlcmd", "urlj", "llcol", "webcon", "llconn", "urlfin", "connConn", "urllink", "httplink", "webfin", "httpcon", "llConn", " urlj", " urlfin", " urlcol", "lcon", "httpconn", "llcon", "conncon", " urlcmd", "lcol", "urlcon", "lj", "lConn"], "os": ["et", "ss", "io", "Os", " bos", "des", "js", "OS", "pos", "cs", "sys", "ot", "as", "ds", "is", "ls", "res", "ws", "soc", "fs", "o", "rs", "osi", "socket", "cms", "us", "ms"], "req1xml": ["reqxmlhtml", "request1html", "req2xml", "request1xml", "req1ml", "req01html", "reqxmlx", "request2ml", "request2xml", "request1ml", "req01x", "req2x", "req01ml", "reqxmlml", "request1x", "request2x", "req2ml", "reqxmlxml", "req1x", "request2html", "req01xml", "req2html", "req1html"], "cos": [" des", " bos", " outs", "oe", "des", " bout", " los", " om", " ox", "cs", "aos", "oss", "is", "oses", "ous", "uts", "ox", "oops", " nos", "oes", "cms", "osi", " ups", " Os", "oos", " cout"]}}
{"id1": "2521141", "id2": "17083703", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "save", "io", "create", "replace", "write", "close", "archive", "transfer", "select", "file", "upload", "download", "insert", "ate", "drop", "clip", "clone", "cp", "cop", "edit", "crop", "slice", "export", "get", "opy", "cut", "move", "paste", "load", "delete", "link", "Copy", "share", "zip", "source", "set", "remove"], "from_name": [" from_case", "from_Name", "from_no", " from_Name", "from_names", "fromamekey", " from_resource", "fromamefilename", "from_case", " from_info", " from_names", "from_filename", "fromkname", " from_part", " from_filename", " from_no", "fromameName", "fromkName", "fromkcase", " from_key", "from_resource", "from_part", "from_key", "fromkpart", "from_info", "fromamename"], "to_name": ["tolyfile", "to7get", "tolynumber", "eto_name", "to_new", "to_get", "tolynm", "toNamefile", "toNameget", "to7new", "to_Name", "eto_word", "toNamename", " to_number", "to_word", "to7file", "from_new", "from_get", "toNamenew", "to_number", " to_nm", "to_nm", "eto_Name", "tolyname", "to7name"], "from_file": ["fromsdir", "from_port", "or_name", " from_resource", "fromlyresource", "from_dir", "fromlyfile", " from_type", "from_node", "from_type", " from_time", " from_do", "fromlynode", "to_dir", " from_port", "or_run", " from_node", "from_do", "from_resource", "fromlyFile", "from_time", "fromsfile", "from_File", "or_File", "from_run", "or_file", " from_File", "fromsname"], "to_file": ["to_create", "that_File", "TO_element", "TO_port", "to_link", " to_create", "toJFile", "TO_file", "TO_name", "toJdrop", "to_files", "from_dir", "to_tree", "toJfile", "from_type", "to_element", " to_File", "to_drop", "to_base", "that_tree", "to_port", "to_dir", "that_link", "to_run", "TO_FILE", "to_type", " to_dir", " to_base", " to_run", " to_local", "to_FILE", "toJblock", "to_local", "to_block", "that_file", " to_drop", "to_File", " to_block", "TO_files"], "parent": ["parents", "ip", "peer", "pid", "unit", "where", "pa", "top", "instance", "default", "point", "mother", "part", "tree", "base", "id", "remote", "comment", "server", "user", "prop", "file", "test", "pool", "percent", "prefix", "temp", "form", "shape", "client", "child", "path", "paren", "family", "par", "chain", "spec", "name", "up", "global", "tar", "position", "params", "root", "p", "per", "folder", "ma", "timeout", "relative", "directory", "man", "event", "desc", "block", "def", "my", "null", "master", "holder", "page", "owner", "port", "sp", "cmp", "pixel", "rule", "source", "home", "Parent"], "dir": ["dep", "det", "cd", "wd", "dr", "dict", "part", "str", "md", "ind", "file", "div", "loc", "self", "mod", "dd", "iter", "del", "cmd", "path", "tr", "Dir", "cond", "DIR", "dim", "coll", "fd", "d", "folder", "init", "di", "directory", "dist", "module", "cur", "local", "rel", "vol", "ir", "rec", "addr", "red", "sp", "cont", "good", "db", "def"], "from": ["fr", "io", "bound", "or", "in", "se", "re", "stream", "back", "base", "user", "pos", "file", "with", "en", "func", "inner", "left", "error", "before", "so", "ent", "form", "out", "normal", "client", "ie", "no", "check", "term", "ra", "old", "From", "on", "start", "orig", "false", "init", "set", "query", "con", "local", "link", "vol", "fun", "st", "entry", "reset", "com", "style", "empty", "store", "window", "source", "by", "and"], "to": ["t", "TO", "stable", "top", "te", "can", "or", "tty", "po", "ne", "too", "base", "auto", "total", "tt", "please", "go", "b", "ato", "so", "e", "eto", "sys", "out", "client", "no", "two", "will", "pi", "nt", "To", "op", "on", "co", "pretty", "token", "ma", "target", "o", "tto", "toc", "output", "must", "that", "null", "ta", "table", "ts", "into", "by"], "buffer": ["binary", "memory", "Buffer", "stack", "buff", "base", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "word", "button", "bar", "queue", "stroke", "cache", "database", "command", "variable", "buf", "password", "paste", "frame", "character", "template", "row", "event", "sample", "block", "sequence", "message", "append", "char", "entry", "table", "function", "window", "page"], "bytes_read": ["bytes_range", "bytesyncread", " bytes_Read", "bytes2range", "words_write", "Bytes_read", "Bytes_write", "wordsyncread", " bytes2read", "wordsynclen", " bytes2write", "bytesynclen", "bytes2Read", "bytes__range", "words_len", "wordsyncwrite", "bytes2write", "bytes__Read", " bytes_write", "words_report", "bytes_run", "bytes2read", " bytes2Read", "bytes__read", "bytesyncreport", "bytes_Read", "bytes__write", "words_read", "Bytes_run", " bytes_range", "wordsyncreport", "bytes_write", "bytes_len", "bytesyncwrite", "bytes_report", " bytes2range"]}}
{"id1": "20660203", "id2": "8667872", "code1": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"temp": ["tem", "T", "c", "t", "tmp", "count", "mint", "v", "buffer", "Temp", "str", "fac", "perature", "length", "total", "prime", "mod", "pt", "result", "cum", "tc", "iter", "cp", "tr", "Temperature", "partial", "cu", "term", "dat", "variable", "ptr", "late", "mp", "p", "cel", "template", "pre", "emp", "unt", "null", "deg", "m", "fake", "current", "alt", "txt"], "a1": [" a4", "a001", "A512", "aaa1", "aaaOne", "anOne", "aOne", "areaache", "aka5", "a2", "pa1", "ao001", " a01", "aa9", "a5", "xa591", "era591", "aa5", "aa512", "A6", "wa6", "alpha3", "aa1", "aaa9", "era1", "ao0", " aOne", "aaa8", " a256", "aeOne", "ca001", "aa8", "xa2", "an1", " a5", "ao01", "area61", "ca1", "anache", "aa10", "a61", " a61", "alphaOne", "xa0", " a9", "xa512", "ao10", "aa4", "ca01", "xa01", "sa4", "alpha1", "A2", "akaache", " aache", "a3", "A8", "a10", "pa256", "sa1", "aa256", "alpha9", "a591", "aka1", "aaa6", "era01", "aone", "ao1", "a8", "aeache", "saone", "pa01", "area5", "wa0", "aka61", "i2", " aone", "aa6", "a01", " a0", "aaone", "A1", "a4", "wa5", "wa1", " a591", "ao256", "aache", "ae1", "pa001", "area1", "ca256", "i256", "xa1", "aa0", "a9", "a0", "aaa3", " a2", "aaOne", "a512", "A0", "sa2", " a8", "i1", "aaa2", "a6", "i512", "xa256", "era256", "aa3", "a256", "aa2", " a10", " a6"], "j": ["jj", "ja", "fr", "y", "J", "v", "aj", "k", "js", "key", "ne", "ind", "jc", "pr", "jp", "b", "im", "ge", "at", "q", "x", "ie", "jump", "tr", "job", "obj", "ji", "ij", "n", "Ja", "ix", "json", "uj", "bj", "jl", "rel", "ort", "jo", "z", "adj", "g", "dj", "kj", "other"], "i": ["li", "y", "bi", "ii", "xi", "I", "batch", "gu", "iter", "hi", "cli", "ami", "is", "wi", "ni", "init", "list", "ini", "ei", "ims", "sim", "my", "g", "zi", "us", "ic", "io", "in", "multi", "this", "inner", "ki", "index", "pi", "ij", "iri", "ia", "qi", "di", "ori", "fire", "status", "point", "asi", "id", "mi", "gi", "uri", "ie", "iii", "ji", "iq", "me", "si", "ix", "json", "info", "php", "it", "yi", "ish", "fi", "key", "ip", "iy", "phi", "ui", "ind", "iu", "oi", "im", "ti", "ci", "chain", "a", "\u0438", "ai", "port", "ri", "span"]}}
{"id1": "14001795", "id2": "310182", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverwarFile", "copyoverwarFilename", "copyOverTarfile", "copyOverWarFiles", "copyoverWarFile", "copyoverwarFiles", "copyOverwarFilename", "copyOverTarFile", "copyOverwarfile", "copyoverWarFiles", "copyOverTarFilename", "copyoverWarfile", "copyoverwarfile", "copyOverWarfile", "copyoverwarFile", "copyOverTarFiles", "copyoverWarFilename", "copyOverWarFilename", "copyOverwarFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "dr", "re", "md", "ind", "file", "disk", "log", "div", "loc", "add", "dd", "iter", " directory", "del", "out", "df", "mk", "path", "dm", "Dir", "res", "DIR", "dat", "name", "dim", "old", "url", "coll", "fd", "d", "folder", "di", "ld", "directory", "dist", "cur", " Dir", "fin", "local", " d", "desc", "rel", "vol", "ir", "dial", "direct", "doc", "addr", "parent", "zip", "good", "window", "db", "form", "def"], "ff": ["fact", "tf", " aft", "aff", " cf", "fx", " ref", "off", "ef", "buff", "bf", "FF", "mt", "file", " FF", " eff", "xf", "ck", "UFF", "xff", "af", "df", "uf", "lf", "cb", "cond", "ft", "fd", " df", "aft", "ld", "wind", "fp", " def", "ffe", " af", "fc", "fl", "fg", "F", "filter", "sf", "uff", "iff", "eff", "cf", "alf"], "files": ["features", "facts", "faces", "ions", "Files", "parts", "forms", "file", "images", "frames", "assets", "ports", "balls", "items", "rows", "leases", "ls", "objects", "days", "styles", "mas", "plates", "ails", "iles", "names", "bees", "models", "flows", "members", "fs", "les", "jobs", "uploads", "lines", "resources", "tests", "values", "fields", "keys", "issues", "ories"], "f": ["c", "t", "tf", "v", "rf", "fe", "k", "fac", "col", "bf", "fa", "file", "l", "b", "e", "fab", "xf", "uf", "lf", "fm", "fw", "a", "n", "ft", "exp", "p", "d", "fd", "fs", "fp", "w", "fc", "fl", "elf", "m", "F", "g", "sf", "i", "h", "cf", "alf", "def"], "newFile": ["newPlace", "oldFilename", "NewNode", "NewFile", " newPlace", "oldFile", "secureFile", "newsfile", "uniqueNode", "newsFile", "newNode", "newFiles", "uniquePage", "anotherFile", "NewPlace", "newFilename", " newFiles", "anotherPlace", "securefile", "newKey", "NewPage", "oldfile", "uniqueFile", "NEWfile", "newPage", "uniquefile", "NewFilename", "NEWFile", "secureKey", "NEWPage", "newfile", "Newfile", "anotherfile", "NewKey", "newsKey", "NewFiles", "anotherFiles", " newfile", " newFilename", "NEWNode"], "fi": ["fr", "li", "io", "fe", "bi", "ii", "phi", "bf", "fa", "iu", "mi", "isi", "flo", "ti", "uf", "lf", "ki", "FI", "ci", "pi", "ni", "fd", "si", "di", "ini", "fp", "fin", "afi", "ifa", "ife", "zi", "i", "sf", "ri", "cf", "Fi"], "fo": ["tf", "te", "oe", "po", "hea", "sty", "uo", "oo", "ato", "FO", "ho", "oooo", "xf", "flo", "eto", "tk", "ph", "hi", "ti", "ki", "ott", "mo", "wo", "ow", "eno", "fam", "zz", "vo", "tif", "co", "opa", "o", "tto", "bo", "wt", "jo", "zo", "sf", "ko", "cf"]}}
{"id1": "647224", "id2": "11952735", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"uploadFile": ["putFiles", "saveFiles", "uploadImage", " uploadfile", "putfile", " uploadImage", " uploadFiles", "uploadFiles", "putImage", "savefile", "saveFile", "putFile", "saveImage", "uploadfile"], "inputFile": ["imgOne", "infoFilename", "inputFILE", "inputfile", " inputLe", "inputField", "InputFiles", "Inputfile", "inputResource", "imgLe", "targetField", "fromField", "evalField", "imgFile", "outputLine", " inputfile", "inputLe", "outputPath", "imgLine", "updateOne", "infoFile", "updateFile", "thisLine", "targetFILE", "outputfile", "inputLine", "evalFile", "targetResource", "inputPath", "fromResource", "InputLine", "fromFile", "inputOne", "inFILE", "thisPath", "updateLe", "outputFiles", "fromFILE", "inLine", "infoFILE", " inputFiles", "thisfile", " inputFilename", " inputFILE", " inputLine", "InputFile", "inputFiles", "inFilename", " inputPath", "evalResource", "inFile", "inputFilename", "evalFILE", "infoLine", "updateLine", "thisFile", " inputOne"], "targetFile": ["sourceFiles", "outputDir", "targetPath", "detailString", "targetString", " targetFilename", "TargetFile", " targetString", "tofile", "toDir", " targetFILE", "outputDate", "TargetString", "sourceDir", "targetFilename", "outputFolder", "TargetPath", "sourceFile", "detailDir", "TargetFiles", "outputPath", "targetDir", "targetDate", "toFile", "toFolder", "targetFILE", "sourceDate", "outputfile", " targetPath", "sourcefile", " targetDir", "targetfile", "outputFilename", "targetFiles", "targetFolder", "detailFILE", "detailFile", "sourceFolder", "outputFiles", "sourcePath", "sourceFilename", " targetDate", "TargetDir", "TargetFILE"], "outputFile": ["sourceFiles", " outputGe", "outputDir", "inputLog", "removePlace", "displayFILE", "targetDirectory", "outFile", "outputPlace", " outputDir", "inputfile", "inputDo", "putFile", "noGe", "putPlace", "sourceDir", "displayPlace", " outputDirectory", "displayStore", "nullStyle", "noPlace", "targetFilename", "outDir", "sourceFile", "nofile", "targetDir", "outModel", " outputLog", "inputDirectory", "outFiles", "outputfile", "outputDo", "outputFILE", "displayFile", "sourcefile", "removeFile", "outfile", "putfile", "nullfile", "targetfile", "targetFiles", " outputStore", "removeStore", " outputStyle", "outputFilename", "targetLog", "outputLog", " outputModel", "outputFiles", " outputFILE", "removeFILE", "outDo", " outputFilename", "inputDir", "outStyle", "targetModel", " outputPlace", "inputFiles", "putGe", "nullFile", "outputStore", "inputModel", "nullModel", " outputfile", "outputDirectory", " outputDo", " outputFiles", "noFile", "outputStyle", "outputModel", "outputGe", "inputFilename"], "in": ["io", "read", "bin", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "l", "ze", "inf", "ain", "inside", "iter", "ro", "mc", "im", "is", "input", "al", "In", "on", "per", "init", "info", "ini", "IN", "like", "con", "it", "ar", "ins", "inn", "cin", "act", "ai", "i", "mm", "ic", "ri", "source", "by"], "out": ["t", "println", "io", "v", "dis", "can", "write", "by", "os", "auto", "log", "print", "inner", "b", "ln", "at", "console", "sys", "ot", "client", "put", "cache", "res", "err", "end", "obj", "screen", "name", "nt", "up", "n", "on", "co", "all", "list", "conf", "IN", "net", "o", "con", "cn", "outs", "it", "vol", "Out", "output", "sum", "report", "null", "we", "ex", "to", "cos", "g", "writer", "s", "ou", "aos", "OUT", "outer", "and"], "line": ["detail", "lin", "lane", "inline", "range", "point", "nl", "column", "comment", "log", "LINE", "phrase", "l", "ln", "cell", "eline", "Line", "lo", "stroke", "entity", "rule", "chain", "ine", "command", "ide", "frame", "row", "query", "edge", "record", "sample", "block", "field", "sequence", "lock", "message", "link", "entry", "label", "node", "code", "word", "page"], "bytes": ["gs", "terms", "ies", "oms", "uses", "classes", "es", "bs", "gments", "parts", "ales", "xes", "frames", "gets", "ones", "books", "errors", "bits", "lements", "ges", "ites", "pages", "ows", "rows", "bes", "ls", "comments", "odes", "bps", "Bytes", "otes", "cells", "les", "ices", "amples", "ends", "outs", "lines", "seconds", "blocks", "nets", "reads", "files", "comes", "values", "steps", "bles", "times", "vals", "ips", "tes", "units", "sofar"]}}
{"id1": "3024992", "id2": "20100809", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2null_"], "baout": ["BAouth", "dboul", "caout", "BAin", "BAOut", "dbin", "gaouth", "gaout", "gaoul", "caOut", " bain", "dbouth", "BAouts", "baouts", "bain", "baouth", "gain", "buin", "cain", "cait", "abain", "abait", "bait", "abaout", "buOut", "BAoul", "BAout", "baoul", "buouts", " baOut", "dbout", "abaOut", "baOut", "BAit", "buout", " baouts"], "out": ["tmp", "io", "gr", "write", "in", "pool", "serv", "result", "sys", " OUT", "res", "err", "er", "n", "o", "gen", "net", "outs", "it", "Out", "output", "ex", "null", "ser", "OUT"], "writer": ["println", "widget", "reader", "buffer", "write", "worker", "killer", "data", "this", "usher", "file", "print", "inner", "document", "client", "driver", "player", "NULL", "riter", "er", "nw", "builder", "maker", "processor", "writ", "woman", "Writer", "target", "wright", "service", "channel", "w", "rw", "output", "null", "handler", "wrote", "window", "outer"]}}
{"id1": "5744493", "id2": "5998352", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" synchronizedFileMove", " doPageMove", " synchronizedFullCopy", " doPageDownload", " doFileDownload", " doStreamMove", " doStreamDownload", " synchronizedFullMove", " doFileCopy", " doFullMove", " doFullDownload", " synchronizedFileCopy", " doStreamCopy", " synchronizedFullDownload", " doFullCopy", " doFileMove", " doPageCopy", " synchronizedFileDownload"], "in": ["din", "ac", "or", "inc", "isin", "rin", "ind", "file", "el", "en", "l", "b", "inf", "ain", "ck", "r", "as", "input", "up", "In", "n", "old", "gin", "init", "o", "IN", "it", " input", "from", "ins", "ex", "inn", "cin", "i", "mm", "ic", "source"], "out": ["c", "t", "io", "v", "write", "po", "ne", "help", "os", "log", "file", "l", "serv", "at", "gt", "ot", "as", "check", "res", "nt", "up", "op", "n", "p", "o", "net", "w", "outs", "it", "output", "Out", "ch", "ex", "null", "to", "s", "ou", "OUT"], "inChannel": ["dinConnection", "InCh", "inButton", "cinCommand", " inCase", "inChan", "isinChan", "isinConnection", "cinChannel", " inCh", "innButton", "innChannel", "INStream", "isinChannel", "InChannel", "vinConnection", "innerChannel", "cinCategory", "outchannel", "INChan", " inchannel", "dinButton", "innCommand", "innerchannel", "dinChan", " inChan", "cinButton", "outStream", "vinCommand", "inchannel", "inStream", " inConnection", " inCommand", "INChannel", " inButton", "isinButton", "inCase", "innerStream", "outCh", "dinChannel", "dinCase", "INchannel", " inCategory", "innCategory", "inConnection", "inCommand", "vinChannel", "innerChan", "inCh", "InChan", "outChan", "vinCase", "Inchannel", "inCategory", "dinCommand"], "outChannel": ["aosDisk", "outSection", "outDisk", "outputStream", "inChan", "aosMachine", "onChan", "outputCh", "outerStream", "cosDisk", "outchannel", "newChan", "outMachine", "OutChan", "OutChannel", "newConnection", "cosSection", "upSection", "outStream", "aosChannel", "outRoom", "inStream", " outChan", "onchannel", "outerRoom", "aosSection", "outputChan", "outerChannel", "onConnection", "outCh", "upChannel", "outputChannel", "inRoom", "OutStream", "cosMachine", "outerChan", "newchannel", "outChan", " outchannel", "OutCh", "upMachine", " outRoom", "onChannel", "cosChannel", " outConnection", " outStream", "newChannel", " outCh", "outConnection", "upDisk"], "maxCount": ["MaxCount", "maxCast", "MAXCount", " maxCast", "minCount", "MaxCast", "minFlag", "minLength", " maxSize", " maxFlag", "maxFlag", "minSize", "maxSize", "MaxSize", "minCast", "maxLength", "MaxLength", "MAXFlag", "MAXLength", " maxLength"], "size": ["scroll", "scale", "count", "ose", "close", "write", "fee", "score", "speed", "read", "any", "range", "sd", "space", "length", "total", "south", "gets", "ze", "body", "shape", "is", "equal", "duration", "shift", "sent", "name", "small", "export", "resolution", "notice", "capacity", "position", "start", "send", "si", "height", "len", "sample", "message", "area", "sum", "SIZE", "bytes", "readable", "seek", "m", "show", "ize", "empty", "keys", "Size", "set", "ms"], "pos": ["coord", "pid", "ps", "off", "point", "part", "po", "os", "length", "POS", "loc", "pr", "left", "l", "pt", "pg", "limit", "x", "pointer", "no", "index", "zero", "pi", "spec", "n", "position", "start", "exp", "Position", "p", "pass", "seq", "pl", "resp", "len", "slot", "o", "row", "pose", "it", "pc", "rel", "sp", "pro", "offset", "to", "doc", "port", "cos", "i", "page", "Pos", "def"]}}
{"id1": "15971794", "id2": "14317425", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getWave": ["downloadAudio", " getAudio", "getAudio", "getwave", "downloadwave", "setWave", "downloadWar", " getWar", "downloadWave", " getwave", "setwave", "setAudio", "setWar", "getWar"], "url": ["dl", "v", "ul", "rl", "host", "nl", "str", "base", "id", "server", "file", "loc", "l", "b", "web", "uri", "string", "q", "r", "out", "input", "path", "ls", "www", "ref", "name", "password", "ur", "f", "http", "api", "ll", "link", "URL", "fl", "fc", "Url", "word", "key"], "Word": ["Label", " word", "Po", "Token", "wd", "bow", "W", "Length", "Str", "Hack", "Name", "Week", "WC", "File", "Fix", "Key", "sword", "Weight", "Char", "Wi", "War", "wo", "Wave", "stem", "Wo", "Language", "Win", "Query", "Words", "Field", "words", "Letter", "Part", "User", "WF", "wp", "Term", "Message", "Tag", "w", "Nob", "Form", "Work", "Wr", "Bank", "word", "Text", "Password"], "FF": ["tf", "aff", "HF", "Temp", "ff", "FP", "SF", "Factory", "FC", "Pref", "IFF", "FB", "FILE", "File", "FD", "CC", "FO", "UF", "UFF", "uf", "FL", "lf", " ff", "FN", "Field", "fd", "f", "aft", "WF", "DF", "AF", "FS", "PF", "EF", "TF", "Aff", "fi", "F", " F", "uff", "Fi", "IF"], "url2": ["url4", "lTwo", "uri3", "str2", "ls2", " url4", "url1", "lsTwo", " url1", "Url3", "UrlRel", "l2", "strRel", "urlTwo", "l4", "uri2", "url3", " urlTwo", "strTwo", "ls1", "urlRel", "uriRel", "l1", "ls4", "str3", "uriTwo", "UrlTwo", "Url2"], "stream": ["sync", "history", "fr", "reader", "v", "buffer", "read", "speed", "sc", "src", "view", "stack", "pipe", "mount", "length", "sam", "download", "sv", "now", "inner", "ream", "dd", "iter", "console", "source", "transform", "REAM", "progress", "ssl", "path", "line", "tr", "input", "ob", "chain", "conv", " upstream", "loop", "feed", "http", "sw", "Stream", "channel", "row", "list", "Steam", "sample", "response", "size", "standard", "message", "context", "steam", "zip", "window", "ST", "form", "iterator"], "Fdel": ["fDel", " FDel", "FMdelete", " Fdep", "FDdel", "Fdep", "Fdelete", " Fdelete", "fel", "Fdes", "FDel", "FMDel", " Fdes", "PFdel", "FDDel", "FMdep", "FMdel", "fdes", "FDdes", "PFDel", "Fel", " Fel", "PFdelete", "PFdep", "fdel"], "outstream": ["Outstore", "outputform", "outerstream", "newstream", "outputstream", "endconsole", "Outconsole", "outputpipe", "endview", "newstore", "instore", "outerform", "outStream", " outview", "inStream", "outpipe", "upstream", "outerfield", "instream", "newconsole", "outform", "outview", "Outstream", "endstream", "endform", "newStream", "OutStream", "outstore", "Outview", " outform", " outconsole", "outfield", "upfield", "inconsole", "upform", "uppipe", "outerpipe", "Outform", "outconsole", "outputfield"], "bwriter": ["cbworker", "Bwriter", "bler", "Bler", "bener", "binreader", "rwriter", "gwriter", "Bcreator", " bworker", " bWriter", " bler", "gWriter", " bcreator", "bcreator", "binener", "cbrunner", "gler", "rreader", "bincreator", "binwriter", " breader", "bWriter", "Bener", "bworker", "brunner", "BWriter", " bener", "breader", "Breader", "cbreader", "cbwriter", "rworker", "greader", "rrunner", " brunner"], "binput": [" binoutput", "boxput", "bincut", "binpixel", "binaryoutput", "binaryput", "bpost", "binpost", "obinstr", " binpost", "obinpixel", " binbutt", "boxbyte", "binaryPut", "bPut", " binpixel", " binPut", "binstr", "obinoutput", "binbyte", "bput", "binarypixel", "obinput", "obincut", "bstr", "binarypost", "binoutput", "boxstr", "obinbyte", "binarystr", " binstr", "binbutt", "boxcut", "obinbutt", "binarycut", "binarybutt", "binarybyte", "binPut"], "len": ["compl", "lp", "le", "li", "dl", "ler", "bin", "lon", "nl", "L", "length", "el", "log", "wl", "en", "pos", "ind", "l", "wid", "den", "ln", "gl", "iter", " le", "vec", "del", "lan", "ls", "no", "lf", "cond", "elt", "end", "bl", "nt", "ellen", "n", "coll", "all", "ell", "val", "ld", "kl", " clen", "ll", "hl", "fin", "size", "fun", "num", "fl", "lit", "contin", "lim", "Len"]}}
{"id1": "21754659", "id2": "18504192", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getButtonSonico", "getButtonDonida", "getButtonSonida", "getButtonDonido", "getbuttonSonida", "getbuttonSonico", "getbuttonSonilo", "getButtonLeonido", "getbuttonSonido", "getButtonDonico", "getButtonLeonico", "getButtonLeonida", "getButtonDonilo", "getButtonLeonilo", "getButtonSonilo"], "buttonSonido": ["positionSonido", "labelSONphp", "fieldsoningo", "buttonSonano", "buttonHonilo", "buttonSunao", "ButtonSonao", "buttonSONilo", "ButtonSunico", "buttonSonicho", "buttonNorthingo", "buttonsonilo", "buttonSunata", "labelSONido", "buttonJonphp", "buttonDenicho", "buttonSynido", "buttonSunido", "ButtonSunao", "buttonBoningo", "keySonardo", "secondSonicho", "buttonJonida", "fieldSonida", "secondSynido", "buttonNorthano", "labelSonido", "buttonSonao", "keysonilo", "buttonJonidable", "buttonSonata", "secondSynidable", "buttonJonito", "buttonSynicho", "buttonSynphp", "keyson\u00ed", "fieldsonano", "buttonJonao", "fieldSoningo", "ButtonSonico", "buttonSonito", "positionSonito", "buttonJonilo", "buttonsonardo", "buttonBonida", "buttonSunilo", "buttonSonardo", "keySonido", "positionJonico", "buttonsonano", "buttonSONico", "buttonsoningo", "buttonHonardo", "fieldSonido", "buttonBonata", "labelSonida", "buttonBon\u00ed", "buttonDenidable", "buttonBonilo", "ButtonSonata", "labelSONida", "buttonSONida", "buttonSynidable", "buttonSONila", "buttonHon\u00ed", "fieldSonano", "buttonNorthida", "buttonJonicho", "buttonNorthido", "keysonido", "buttonSunito", "buttonsonido", "buttonBonao", "buttonJonico", "secondSynito", "buttonJonido", "buttonSONphp", "buttonsonida", "buttonDenito", "labelSonila", "buttonSonidable", "fieldsonido", "buttonSonilo", "buttonJonata", "ButtonSunata", "keySon\u00ed", "positionJonito", "buttonSonida", "buttonBonido", "buttonSoningo", "buttonSynito", "secondSynicho", "buttonSunico", "buttonSonphp", "labelSonphp", "positionJonilo", "ButtonSunido", "buttonBonano", "keysonardo", "secondSonido", "positionSonico", "buttonSONido", "positionJonido", "buttonBonardo", "buttonJonila", "positionSonilo", "buttonSynida", "labelSONila", "secondSonidable", "buttonDenido", "fieldsonida", "buttonSon\u00ed", "buttonBonico", "buttonHonido", "secondSonito", "buttonSONito", "buttonSonico", "buttonSynila", "keySonilo", "buttonSonila", "ButtonSonido", "buttonson\u00ed"], "e": ["t", "ese", "ae", " ie", "ev", "te", "es", " ate", "AE", " ke", " pe", "ie", "ED", " ge", " ve", "a", "er", "ing", "me", "pe", " fe", "event", "E", "ee", "act", " sent", " who", "ed"], "fc": ["c", "tf", "cv", "FC", "rl", "abc", "WC", "etc", "uc", "bf", "fb", "inc", "fa", "isc", "dc", "bc", "fab", "tc", "mc", "cc", "ic", "icc", "lf", "fm", "gc", "mac", "rc", "conv", "ec", "RFC", "irc", "coll", "soc", "f", "fd", "fs", "fp", "con", "vc", "pc", "fl", "anc", "ifa", "fi", "ctrl", "nc", "fn", "cf", "lc"], "returnVal": ["retValue", "retval", "ReturnVal", " returnValue", "ReturnVAL", "resultVAL", "retVal", "ReturnValue", "Returnval", "resultValue", "resultval", "resultVal", "returnValue", " returnval", " returnVAL", "returnVAL", "returnval", "retVAL"], "file": ["io", "create", "buffer", "type", "fe", "data", "tree", "base", "user", "this", "FILE", "full", "File", "disk", "document", "image", "dir", "uri", "ile", "single", "input", "path", "time", "spec", "name", "format", "handle", "url", "get", "f", "http", "info", "channel", "template", "fp", "local", "link", "block", "output", "message", "valid", "files", "null", "stat", "show", "to", "table", "resource", "page", "parent", "word", "source", "form"], "rutaGlobal": ["RutoLocal", "rutanGlobal", "rutaglobal", "redutaGeneral", "RutoGlobal", "rutoStatic", "redutaLocal", "RutaGlobal", "RutoRemote", "redutaDefault", "rutenGlobal", "Rutaglobal", "RutaLocal", "rutiDefault", "rutaStatic", "rutiFile", "rontoLocal", "rutoLocal", "rutoRemote", "rutoglobal", "rutiRemote", "rutiStatic", "rutoGlobal", "rutenRemote", "rutaRemote", "rutenStatic", "redutanDefault", "RutaRemote", "rutiglobal", "rutanLocal", "rutaGeneral", "rutoFile", "RutoFile", "redutaGlobal", "rutenglobal", "redutanGeneral", "rontoGlobal", "rutiGlobal", "rontoDefault", "rutanDefault", "rutenLocal", "RutoStatic", "rutiGeneral", "rutanGeneral", "redutanLocal", "rontoGeneral", "rutaLocal", "redutanGlobal", "RutaFile", "rutenFile", "rutaFile", "rutaDefault", "rutiLocal", "Rutoglobal", "RutaStatic"], "rutaRelativa": ["rutaRELativa", "rutaRELATiva", "rutaRelantiv", "rutaRelATivo", "rutaRELATiv", "rutaRelativ", "rutaRELitiva", "rutaRelantiva", "rutaRELitivo", "rutaRelitiv", "rutaRelatiiva", "rutaRelatiivo", "rutaRelativo", "rutaRELATivas", "rutaRelATiv", "rutaRelantivo", "rutaRelatiiv", "rutaRELATivo", "rutaRELitivas", "rutaRelantivas", "rutaRelitivas", "rutaRelATiva", "rutaRELitiv", "rutaRelitivo", "rutaRELativo", "rutaRelativas", "rutaRelATivas", "rutaRELativ", "rutaRelitiva", "rutaRelatiivas", "rutaRELativas"], "fis": ["flis", "dfois", "vois", "dfis", "dfiss", "fiss", " fais", "ros", "df\u00eds", "dfisa", "viss", "dfais", "lfisa", " fois", " fiss", "fois", "lfiss", "flys", "fais", "flisc", "f\u00eds", " fisa", "ris", "flos", "fisa", "fys", "lf\u00eds", " fisc", "vis", " fys", "rys", " f\u00eds", "vais", "risc", "fisc", "lfis"], "fos": ["ioses", "woes", "foes", "mos", "mops", "wios", "fows", "fops", "woses", "fios", "iios", "hos", "fdoss", "woss", " foss", "fdaos", "foss", "hios", "vos", "faos", "vows", " fops", "vops", "fdos", "foses", "moes", "mows", "fdoes", "hoss", "waos", "ios", " faos", " fows", "ioss", "voes", " foes", "hoses", "wos"], "canalFuente": ["canallfucer", "canalFuestro", "canallFuper", "canalfuelia", "canallFuente", "canalFUent", "canelFaelia", "canelFuante", "canalfumelon", "canalFaent", "canalFaante", "canalFaestro", "canalPotper", "canallFuent", "canalFuencia", "canalfuestro", "canelFaent", "canallFuencia", "canalFient", "canalFaelia", "canelFuent", "canallFuestro", "canallfumelon", "canalFraencia", "canallfuestro", "canalFramelon", "canalFUelia", "canelFaente", "canalFucer", "canalfuente", "canelFuelia", "canalFuante", "canallfuent", "canalFiente", "canalFaente", "canalFuper", "canalPotmelon", "canallfuper", "canelFuente", "canalFuelia", "canalFacer", "canalPotente", "canallFucer", "canallfuente", "canalFUente", "canallFumelon", "canalfuencia", "canelFaante", "canalfucer", "canalfuper", "canalfuante", "canalFiestro", "canalFUante", "canalFicer", "canallfuencia", "canalFraper", "canalFuent", "canalfuent", "canalFraente", "canalFumelon", "canalPotencia"], "canalDestino": ["canaldOrigine", "canalNegina", "canalsDestina", "canaldDestina", "canaldOrigination", "canalsDestinian", "canalDescina", "canalDescination", "canalOrigination", "canalNegination", "canalDestine", "canaldestinian", "canalOrigine", "canalNegino", "canalDescine", "canalsdestina", "canalDestinian", "canalsdestination", "canalsDestination", "canaldestination", "canalsdestino", "canalsDestino", "canalDestination", "canaldDestino", "canalOrigino", "canaldestina", "canalOrigina", "canalDescino", "canaldDestination", "canaldOrigina", "canalsdestinian", "canalDestina", "canaldestino", "canalNeginian", "canaldOrigino", "canaldDestine"]}}
{"id1": "21488518", "id2": "20375440", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"createNew": ["getNext", "dataFresh", "createFresh", "CreateNext", "dataResource", "getFresh", "createResource", "CreateFresh", "dataNew", "CreateResource", "dataNext", "createNext", "getNew", "CreateNew", "getResource"], "name": ["version", "create", "named", "type", "current", "Name", "part", "data", "key", "base", "id", "file", "ame", "now", "prefix", "lat", "action", "common", "body", "string", "missing", "normal", "none", "client", "path", "index", "no", "time", "alias", "end", "title", "address", "format", "n", "old", "password", "handle", "NAME", "names", "description", "use", "value", "template", "one", "local", "size", "event", "only", "null", "nm", "code", "resource", "ename", "word", "source", "filename"], "in": ["c", "t", "reader", "mat", "bin", "din", "data", "asin", "isin", "rin", "ind", "file", "en", "inner", "b", "body", "vin", "mc", "r", "is", "input", "err", "al", "In", "get", "p", "gin", "ma", "IN", "con", "it", "from", "ins", "inn", "cin", "xml", "i", "mm", "s", "source"], "length": ["content", "text", "count", "buffer", "padding", "read", "Length", "enc", "max", "stream", "data", "total", "body", "shape", "input", "path", "duration", "position", "password", "amount", "description", "len", "height", "value", "size", "sequence", "message", "bytes"], "contentType": ["mediaLength", "contentLength", "mediatype", "Contenttype", "contenttype", "ContentType", "mediaType", "mediaTypes", " contenttype", "ContentTypes", "ContentLength", "contentTypes", " contentLength", " contentTypes"], "dest": [" dst", "tmp", " Dest", "coord", "Dest", "trans", "wb", "copy", "src", "oe", "nom", "this", "prop", "rest", "disk", "loc", "self", "temp", "result", "dir", "iter", "origin", " destination", "path", "obj", "dat", "orig", "mem", "comb", "resp", "d", "folder", "there", "target", "cat", "lit", "table", "parent", "cont", "source", "home"], "out": ["t", "io", "write", "OUT", "can", "off", "copy", "conn", "po", "col", "os", "OU", "external", "log", "file", "go", "en", "serv", "ent", "sys", "client", "oss", "res", "obj", "end", "conv", "op", "up", "n", "co", "o", "net", "con", "outs", "w", "it", "output", "Out", "ex", "null", "to", "cos", "ion", "port", "s", "ou", "aos", "set", "outer"], "request": ["claim", "create", "ire", "re", "user", "begin", "select", "QUEST", "result", "require", "child", "input", "reference", "library", "open", "enter", "quest", "req", "requ", "params", "url", "Request", "move", "pair", "relative", "search", "query", "response", "message", "ask", "report", "reset", "current", "forward", "push", "remove"]}}
{"id1": "12766377", "id2": "10436471", "code1": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"index": ["version", "scan", "parse", "Index", "create", "read", "write", "build", "blog", "se", "view", "evaluate", "tree", "html", "archive", "ind", "insert", "download", "author", "print", " analyse", " Index", "document", "image", "review", " indexed", "update", "open", "address", "xx", "execute", "search", "service", "find", "list", "query", "link", "process", "display", " ingest", "show", "suggest", "node", "connect", "access"], "url": ["lb", "t", "dl", "ml", "cl", "location", "org", "build", "ul", "rl", "nl", "mount", "str", "base", "user", "server", "html", "log", "el", "loc", "lr", "l", "b", "web", "gl", "loader", "uri", "https", "il", "r", "browser", "ssl", "cert", "path", "ls", "impl", "www", "util", "mail", "ref", "sl", "address", "bel", "un", "ur", "p", "get", "pl", "github", "http", "kl", "ll", "hl", "link", "rel", "au", "URL", "char", "fl", "addr", "resource", "xml", "Url"], "in": ["t", "io", "bin", "din", "min", "inv", "po", "asin", "inc", "isin", "rin", "ind", "file", "en", "inner", "l", "inf", "ain", "mc", "out", "as", "r", "is", "input", "up", "er", "In", "on", "gin", "conf", "IN", "o", "ini", "con", "it", "pc", "sum", "from", "ar", "ins", "inn", "m", "cin", "xml", "i", "s"], "contentType": ["documentLength", " contentCode", "commentType", "Contenttype", "contentTypes", " contentTypes", "contentLength", "ContentType", "contentFormat", "documentType", "ontentTypes", "commentTyp", "contentStyle", "ontentType", "ContentLength", " contentLength", " contentFormat", "conditionFormat", "conditionType", "contentCode", " contentStyle", "ontenttype", "conditionStyle", "conditionTyp", " contenttype", "ontentLength", "documentCode", "ContentCode", " contentTyp", "documentTypes", "contenttype", "contentTyp", "commentFormat", "ContentTypes", "commentStyle"], "pageContent": ["pageContents", " pageSync", "wikiOne", "resultContent", "PageAuth", " pageComment", "contentComment", "contentSync", " pageConn", "pixelOne", " pageContext", "pagesCode", "pageComment", "PageContent", "articleAuth", " pageAuth", "pagesConn", " pagecontent", " pageContents", "pagesContents", "pagecontent", "serverContent", "pageContext", "articleContents", "articleContent", "resultConn", "pixelcontent", "articleSync", "PageContents", "pageOne", "serverContents", "profileContent", "pixelCa", " pageCode", "profileContext", " pageOne", "wikiCa", "resultContents", "serverContext", "pixelContent", "resultCode", "profileContents", "serverComment", "pageConn", "pageAuth", "contentContent", "articlecontent", "profileComment", "pageSync", "pageCa", "wikiContent", "articleComment", "wikicontent", " pageCa", "pageCode", "pagesContent", "Pagecontent", "contentContents"], "redireccion": ["redileccension", "redirecion", "redirecsION", "redirecciton", "redirecsison", "redireccison", "redirepcION", "redirecsiton", "redileccion", "redilecciton", "redirenciton", "redirequestiton", "redirecedion", "redirepcions", "redIREccION", "redIREncION", "redirepcion", "redirecedison", "redilenciton", "redorecion", "redileccison", "redileccao", "redIREcciton", "redIREncion", "redoreccison", "redirecsions", "redoreccION", "redirequestion", "redireccao", "redilencion", "redirecsension", "redIREccison", "redirecION", "redirequestION", "redilencison", "redoreccions", "redirebcison", "redirecediton", "redoreccion", "redIREnciton", "redilencao", "redirequestison", "redirencION", "redirencension", "redorecison", "redirepcison", "redIREccion", "redirencison", "redirecsao", "redireccions", "redirecison", "redireccION", "redirencao", "redirebcion", "redirebciton", "redirebcao", "redIREncison", "redirencion", "redirecedension", "redorecions", "redilencension", "redireccension", "redorecION", "redirecions", "redirecsion"], "doc": ["content", "t", "pic", "pdf", "mat", "dr", "oc", "po", "tree", "html", "md", "log", "file", "dc", "document", "Document", "ent", "out", "dec", "mk", "df", "DOC", "de", "nt", "exp", "coll", "d", "Doc", "cam", "it", "st", "tx", "m", "article", "msg", "page", "xml", "good", "word", "db", "def"]}}
{"id1": "1421557", "id2": "12783713", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "7351534", "id2": "344764", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdifiers", "getStreamFromSystemIdifer", "getStreamFromSystemIdifier", "getStreamFromSystemIdentifer", "getStreamFromSysIdentifer", "getStreamFromSystemIdification", "getStreamFromSystemidentifer", "getStreamFromSysIdentifiers", "getStreamFromSysIdentification", "getStreamFromSystemIdentifiers", "getStreamFromSystemidentifier", "getStreamFromSysidentifier", "getStreamFromSysidentification", "getStreamFromSysIdentifier", "getStreamFromSystemidentifiers", "getStreamFromSysidentifer", "getStreamFromSystemIdentification", "getStreamFromSysidentifiers", "getStreamFromSystemidentification"], "systemId": ["cmsStart", "ystemMid", "serverid", "publicName", "publicMid", "humanStart", "systemID", "ystemID", "humanID", "localhostMid", "cmsMid", " systemName", "ystemIs", "ystemById", "humanIs", "ystemid", "serverById", "sysId", "systemName", "ystemIn", "systemid", "humanId", "publicIn", "ystemId", "serverIn", " systemMid", "systemIs", "systemDoes", "sysID", "publicid", "sysById", "serverId", "ystemName", "cmsDoes", "localhostDoes", "systemIn", "publicById", "localhostStart", "localhostId", "publicId", "humanDoes", "systemById", "humanById", "sysIs", "cmsId", "systemStart", " systemById", "humanMid", "systemMid"], "resolver": ["reolve", "reolver", "resolutionolution", "persolver", "persolution", "perslove", "rsanger", "persolve", "reolved", "relove", "persolved", "resolve", "persolving", "reanger", " reserver", "rserver", " resolution", "resolved", "resolutionlove", "resolution", " resolved", "resolving", "reolution", "reerver", "reslove", "resanger", "resolutionolving", " resolve", "reolving", "reserver", "resolutionolver", " resanger", "rsolver", "rsolution"], "source": ["object", "peer", "unit", "reader", "create", "instance", "status", "copy", "se", "src", "cause", "scope", "base", "raw", "file", "ce", "attribute", "series", "relation", "image", "component", "inner", "result", "uri", "console", "origin", "string", "storage", "missing", "SOURCE", "input", "ource", "spec", "supp", "Source", "get", "init", "target", "service", "channel", "template", "proxy", "force", "site", "via", "sample", "sequence", "context", "sql", "from", "local", "subject", "seed", "null", "response", "store", "style", "shell", "resource", "table", "parent", "sp", "remote", "ser", "rule", "node", "system", "iterator"], "stream": ["sync", "object", "mount", "data", "batch", "impl", "loop", "Stream", "row", "message", "output", "valid", "null", "socket", "read", "pipe", "file", "ream", "poll", "temp", "next", "body", "out", "proc", "REAM", "progress", "cache", "open", "present", "response", "zip", "window", "buffer", "length", "upload", "download", "shape", "our", "hold", "export", "wrapper", "load", "channel", "control", "sample", "resource", "cont", "content", "peer", "encrypted", "pod", "reader", "trans", "instance", "stack", "log", "test", "pool", "complete", "result", "console", "ssl", "input", "chain", "feed", "http", "sw", "sequence", "port", "clean", "form", "iterator"], "url": ["dl", "location", "build", "ul", "rl", "nl", "mount", "back", "external", "l", "b", "gl", "web", "uri", "r", "browser", "ssl", "ls", "job", "mail", "ref", "sl", "address", "term", "bel", "ur", "f", "http", "service", "hl", "ll", "link", "rel", "ret", "URL", "char", "null", "resource", "Url", "window", "key", "system"]}}
{"id1": "8778962", "id2": "13499897", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "22022715", "id2": "22855019", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "label": 0, "substitutes": {"digest": ["dested", "digests", "decest", "mnist", "mdest", "decge", "Digge", "mdests", "dest", "Digate", "den", "digine", "mnests", "mdested", "digen", "mdum", "decate", "digge", "Digine", "mdist", "digested", "dine", "mnest", "date", "mden", "mnen", "mdine", "digate", "dum", "dist", "dge", "Digest", "decested", "dests", "digist", "Digested", "Digum", "digum"], "s": ["sb", "text", "t", "c", "ss", "y", "ps", "strings", "v", "ats", "js", "str", "space", "sv", "sq", "l", "b", "e", "string", "r", "is", "ls", "a", "n", "p", "f", "ses", "o", "S", "sts", "sql", "bytes", "m", "h", "ts", "i", "ms"], "ret": ["t", "tmp", "det", "arr", "re", "RET", "rem", "back", "reg", "over", "ext", "data", "Return", "mt", "az", "test", "xt", "Ret", "jp", "rets", "result", "ert", "gt", "out", "r", "uf", "tr", "res", "repl", "elt", "att", "found", "ref", "nt", "ft", "buf", "resp", "pet", "rt", "val", "gb", "rm", "rs", "arg", "it", "cat", "report", "reset", "ts", "cont", "rep", "txt"], "md": ["pm", " Md", "bd", "MD", "managed", "dh", "pdf", "det", "cd", "med", "dr", "sd", "sm", "mand", "mt", "ind", "mod", "dd", "hd", "del", "mc", "cmd", "ds", "df", "mk", "mb", "nd", "dm", "mo", "mail", "pd", " MD", "d", "der", "di", "ld", "rm", "man", "mn", "od", "met", "m", "red", "mm", "mg", "ms", "and"]}}
{"id1": "13333160", "id2": "812803", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"run": ["scan", "app", "unit", "read", "view", "test", "go", "action", "Run", "render", "flow", "proc", "running", "work", "eval", "ran", "exec", "start", "pass", "execute", "query", "wal", "apply", "runner", "process"], "xmlIn": ["domIns", "jsonIn", "xmlInput", "domInput", " xmlIns", "domIn", "fileIn", "xIns", " xmlin", "jsonOut", "jsonInput", "fileIns", "xOut", "filein", "htmlIns", "xmlIns", "xIn", "xInput", "xmlin", "htmlin", "htmlIn", "xmlOut", "jsonIns", "domOut"], "out": ["t", "io", "v", "off", "in", "stream", "os", "OU", "raw", "file", "log", "pool", "client", "res", "err", "end", "ws", "nt", "obj", "up", "p", "d", "sw", "o", "set", "one", "w", "outs", "output", "Out", "report", "null", "ex", "to", "i", "s", "ou", "aos", "OUT"], "dom": ["dn", "img", "fr", "dl", "mat", "cd", "iam", "dr", "host", "data", "tree", "html", "md", "os", "el", "div", "document", "om", "comm", "web", "result", "parser", "DOM", "browser", "df", "dm", "atom", "Dom", "p", "d", "frame", "yang", "mom", "domain", "j", "process", "m", "doc", "node", "xml", "page", "model", "dem", "utils", "window", "db"], "f": ["c", "fr", "tf", "v", "rf", "fx", "ff", "Factory", "fac", "bf", "fb", "full", "l", "foreign", "inf", "fab", "xf", "forge", "af", "df", "uf", "lf", "fm", "fo", "conv", "ft", "of", "fd", "d", "fs", "conf", "w", "it", "fc", "fl", "fg", "fi", "F", "g", "sf", "fy", "cf", "fort"], "b": ["sb", "bg", "B", "c", "bd", "v", "bh", "bi", "bs", "base", "bf", "fb", "l", "bc", "bt", "e", "ab", "r", "mb", "eb", "rb", "a", "builder", "p", "d", "be", "gb", "nb", "pb", "Builder", "j", "m", "g", "db", "bb"], "root": ["object", "gr", "ul", "mount", "data", " rooted", "scope", "bot", "bank", "author", "available", "ain", "browser", "Root", "primary", "cover", "feature", "element", "first", "row", "valid", "null", "node", "xml", "parent", "box", "ok", "rap", "host", "mr", "ro", "ow", "roid", "get", "rt", "rank", "group", "h", "create", "type", "oot", "tree", "html", "os", "raw", "document", "roots", "ram", "ax", "start", "av", "p", "nav", "doc", "table", "owner", " Root", "head", "top", "instance", "base", "rown", "used", "div", "loc", "result", "DOM", "r", "res", "right", "chain", "module", "container", "wrap", "ree", "area", "m"], "att": ["t", "ct", "tmp", "aff", "mat", " ut", "aj", "ac", "acc", "data", "prop", "tt", "attribute", " attribute", "pt", "ATT", "ap", "at", "aux", "feat", "tr", "nat", "ach", "nt", "dat", "attach", "alt", "av", "pet", "Att", " dat", "atts", "rt", "info", "aria", "ar", "apt", " matt", "adj", "addr", "rib", "ts", "attr", "set", "def", "txt"], "menu": ["li", "Menu", "omo", "um", "usage", "window", "manager", "ul", "mouse", "tree", "category", "ui", " menus", "next", "wiki", "options", "button", "queue", " Menu", "theme", "item", "library", "admin", "cache", "family", "title", "chain", "up", "command", "pie", "men", "option", "list", "row", "module", "site", "nav", "cm", "sequence", "block", "settings", "m", "consumer", "ctrl", "mu", "us", "parent", "node", "config", "movie", "page", "header", "summary"], "id": ["version", "mid", "pid", "type", "method", "status", "uid", "data", "scope", "file", "icon", "uri", "ids", "ref", "title", "name", "ID", "url", "description", "init", "target", "value", "tag", "link", "source", "key", "Id", "class"], "zout": ["zipnet", "zerOut", "zserv", "zerot", "zipor", "ozup", "ziposs", "zouts", "zipouter", "enzOut", "Zaos", " zouts", "ozout", "ozpoint", "znet", " zor", "gznet", "zeross", "Zin", "zipout", "izserv", " zin", "zclient", "czout", "izaos", "zOUT", "izOut", "czclient", "enzout", "zerOUT", "czOut", "zipup", "zouter", "gzin", "Zout", "ozOUT", " zaos", "ZOut", "gzout", "ezouts", "enzpoint", "ozot", "zot", "zippoint", "zor", " zOut", "zipaos", "zipot", "zerouter", "zerup", "zipOut", "zpoint", "zipOUT", " zserv", "zipclient", "czup", "zup", "ozouter", " zup", "zin", "zaos", " zclient", "ozOut", "izout", "zipin", "ezout", " zpoint", "zipserv", "ozoss", "gzor", "zOut", " znet", "zoss", "ozouts", "zerout", "ezpoint"], "content": ["text", "object", "request", "data", "ext", "full", "cmd", "address", "reason", "metadata", "position", "media", "search", "output", "message", "condition", "config", "xml", "read", "host", "core", "file", "htm", "now", "inner", "body", "section", "x", "path", "Content", "time", "cache", "context", "good", "header", "txt", "create", "padding", "default", "tree", "html", "comment", "raw", "document", "image", "expression", "string", "script", "layout", "wrapper", "load", "json", "value", "template", "query", "cur", "block", "ontent", "cont", "page", "source", "c", "ce", "pool", "result", "title", "format", "command", "accept", "description", "size", "sequence", "lay", "article", "code", "current"], "signal": ["several", "scale", "scal", "signil", "signature", "sealing", "scaling", "SIGNal", "Signaling", " signale", "scature", "signAL", " signil", "severaling", "Signal", " signaling", "signaling", "severil", "severale", "SIGNale", "seil", "severAL", " signAL", "seature", "seale", "seAL", "severature", "signale", " signature", "SIGNaling", "Signature", "seal", "SIGNature"], "n": ["dn", "tn", "c", "t", "np", "count", "nu", "sn", "ng", "nl", "nr", "ne", "pos", "en", "norm", "l", "ln", "nn", "nv", "an", "no", "index", "zero", "nt", "nan", "unn", "on", "un", "nw", "N", "p", "d", "ni", "len", "natural", "number", "o", "nb", "mn", "num", "cn", "nor", "j", "z", "nm", "m", "node", "g", "h", "i", "nc", "ns"], "entry": ["tmp", "instance", "ry", "se", "member", "data", "connection", "comment", "log", "insert", "quick", "join", "add", "next", "e", "result", "cell", "ent", "ie", "line", "enter", "nt", "ace", "Entry", "escape", "slot", "element", "row", "query", "office", "record", "link", "cue", "sheet", "table", "pixel", "RY", "zip", "page", "system"], "pout": ["zouter", "ppent", " pent", "phpout", "ptnew", "pent", "jpou", "phpin", " pOut", "zconn", "ptout", "ptouter", "wpout", "phpinner", " pinner", " pnew", "jpconn", "zot", " pto", "psys", "ptOut", "pin", "POut", "Psys", "phpOut", "ppinner", "ppot", "pconn", "pot", "pou", "ppout", "pouter", " pouter", "jpout", "pOut", "pto", "phpsys", "phpot", "phpnew", " pconn", "wpent", "Pout", "pinner", "Pin", "jpinner", " pou", "ppond", "zinner", "wpond", " pond", "zou", "phpouter", " psys", " pin", "pnew", "wpto", "ppouter", "pond", "ppto"]}}
{"id1": "21821404", "id2": "21642215", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getDebugPage", "getWebUrl", "getwebPage", "getDebugpage", "getwebpage", "getLivePages", "getLiveUrl", "downloadWebPage", "getWebPages", "getDebugUrl", "downloadwebPages", "downloadwebpage", "getWebpage", "downloadWebPages", "downloadWebpage", "getwebPages", "getLivePage", "getLivepage", "downloadwebUrl", "downloadwebPage", "getwebUrl", "downloadWebUrl", "getDebugPages"], "urlObj": ["urlOb", "logOb", " urlobj", "uriCtrl", "uriObject", "UrlOnce", "httpObject", " urlOb", "logObj", "uriOnce", " urlInd", "uriobj", "httpInfo", "UrlObj", "logObject", "uriInd", "UrlObject", " urlInfo", "httpObj", " urlCtrl", "logInfo", "httpOb", "UrlCtrl", "uriObj", "urlObject", "urlobj", "urlInfo", "Urlobj", " urlObject", "urlOnce", "UrlInd", "urlInd", "urlCtrl", " urlOnce"], "content": ["text", "object", "buffer", "read", "write", "articles", "view", "data", "str", "html", "core", "ext", "comment", "raw", "ce", "document", "complete", "temp", "continue", "result", "body", "equ", "string", "clean", "section", "Content", "comments", "address", "reason", "title", "format", "command", "layout", "wrapper", "load", "value", "template", "cm", "sequence", "response", "message", "output", "context", "display", "ontent", "article", "code", "page", "empty", "cont", "current", "source", "header", "txt"], "is": ["or", "\u00eds", "isc", "has", "web", "ot", "plays", "job", "err", "his", "ris", "ir", "Is", "ism", "other", "tis", "ese", "in", "es", "sit", "isi", "was", "e", "ist", "sys", "out", "were", "nis", "its", "fs", "rs", "net", "ios", "internet", "s", "when", "by", "ms", "being", "ians", "where", "ists", "ire", "se", "does", "sis", "os", "id", "isin", "more", "isf", "string", "iso", "ois", "sels", "IS", "are", "be", "ais", "isa", "iss", "isl", "rys", "not", "and", "c", "iris", "re", "bis", "as", "lis", "res", "chain", "name", "a", "mis", "i", "ri"], "reader": ["io", "read", "buffer", "dr", "ader", "in", "stream", "file", "liner", "ipper", "inner", "loader", "Reader", "ro", "iper", "iter", "dra", "parser", "ner", "r", "ocker", "rar", "er", "per", "anger", "row", "roller", "reading", "runner", "editor", "handler", "rr", "writer", "ser", "ri", "iterator"], "line": ["text", "le", "zone", "detail", "lin", "lane", "inline", "range", "point", "nl", "part", "column", "comment", "el", "file", "liner", "LINE", "print", "l", "ln", "e", "cell", "Line", "eline", "string", "lo", "piece", "stroke", "section", "email", "ine", "online", "lined", "frame", "row", "record", "link", "sample", "block", "sequence", "message", "char", "entry", "label", "word", "page"]}}
{"id1": "8216539", "id2": "494226", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasString", "getFileContentasStr", "getFileContentAsText", "getFileTextAsText", "getFileContentAsStr", "getFileTextAsString", "getFileTextAsStr", "getFileContentasText"], "filePath": ["baseString", "basePath", "FileString", " fileName", " fileInfo", "fileDef", "entryName", "ileDef", "FILEPath", "FILEpath", "FilePath", "FileName", "ilePath", "FileDef", "ileInfo", "FILEName", "fileName", "filepath", "baseName", "FILEPATH", " filepath", "ileName", "entrypath", " fileString", "FileInfo", "FilePATH", "fileInfo", "entryPath", "filePATH", " fileDef", "Filepath", "basepath", "fileString", "entryPATH"], "encoding": ["enoding", "enaching", "unicode", "encuing", "ENCaching", "enode", "unicuing", "characteraching", "Encging", "encode", "enuing", "Encordering", "Encuing", "Encode", "Encoding", "unicaching", "encging", "Encaching", "characterging", "characterordering", "encordering", "unicoding", "characteroding", "encaching", "ENCging", "ENCoding", "ENCordering"], "testURL": ["testingUR", " testUR", "TestSR", " testRE", "checkURL", "testRE", "TestUR", "testUrl", " testUrl", "testedUrl", "checkUrl", "TestURL", "testedRE", "testingUrl", "testUR", "checkSR", "testedUR", "testingSR", "testingRE", "checkUR", "testedURL", "TestUrl", " testSR", "testSR", "testingURL"], "input": ["tmp", "data", "quick", "batch", "has", "iter", "focus", "address", "exist", "up", "Input", "PUT", "init", "list", "output", "act", "config", "xml", "pull", "read", "in", "file", "inner", "add", "lat", "q", "client", "missing", "hidden", "audio", "open", "eval", "get", "qa", "context", "can", "quit", "stream", "comment", "upload", "raw", "image", "op", "exec", "start", "url", "json", "channel", "cur", "it", "sample", "cont", "source", "ip", "submit", "reader", "view", "acl", "active", "accept", "command", "feed", "hello", "unsigned", "from", "empty", "current", "form", "iterator"], "sw": ["wra", "sb", "igm", "kw", "SW", "enc", "sc", "sn", "wh", "sm", "sk", "wl", "sv", "hw", "was", "wr", "su", "sa", "ows", "tw", "ow", "wo", "fw", "aw", "sem", "rew", "sl", "ws", "sur", "iw", "nw", "ews", "wn", "wa", "ew", "Sw", "w", "we", " Sw", "sh", "sf", "sp"]}}
{"id1": "3584508", "id2": "10451698", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" copiedUrl", "copyAddress", "copyUrl", "downloadAddress", " copiedResource", " copyFile", "downloadResource", " copyAddress", "downloadFile", " copyUrl", "downloadUrl", " copiedAddress", "copyFile", " copiedFile"], "url": ["dl", "ml", "cl", "ul", "rl", "re", "nl", "mount", "str", "host", "base", "html", "el", "file", "loc", "l", "gl", "web", "uri", "https", "string", "r", "ssl", "cert", "browser", "path", "ls", "mb", "util", "mail", "ref", "sl", "address", "ur", "gif", "f", "github", "http", "service", "hl", "ll", "link", "rel", "ret", "URL", "fl", "char", "null", "resource", "Url", "source"], "input": ["ip", "parse", "text", "reader", "request", "read", "can", "state", "in", "acl", "active", "stream", "base", "unknown", "user", "select", "upload", "raw", "file", "image", "inner", "add", "access", "before", "ain", "inside", "iter", "missing", "audio", "focus", "ssl", "index", "open", "eval", "enter", "up", "op", "accept", "start", "Input", "exec", "get", "feed", "PUT", "info", "http", "init", "qa", "local", "it", "context", "sum", "null", "initial", "act", "config", "empty", "cont", "source", "form", "pull"], "output": ["text", "object", "four", "exit", "bool", "write", "connection", "ne", "auto", "file", "print", "icon", "image", "component", "next", "continue", "web", "secure", "secondary", "console", "update", "out", "client", "hidden", "Output", "put", "success", "entity", "format", "position", "online", "network", "o", "net", "unsigned", "beta", "response", "group", "you", "display", "null", "ilo", "table", "remote", "ou", "current", "outer", "other"], "b": ["sb", "c", "B", "t", "y", "binary", "v", "wb", "bi", "ba", "k", "bs", "base", "buff", "bf", "fb", "u", "l", "bc", "ib", "body", "bits", "ab", "r", "mb", "eb", "cb", "ob", "br", "ble", "rb", "obj", "p", "f", "d", "be", "gb", "nb", "bp", "block", "j", "char", "m", "z", "bit", "g", "i", "db", "by", "bb"]}}
{"id1": "10218878", "id2": "18693224", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeMAPFiles", "DecodeMapFiles", "DecodeToLog", "DecodeMAPfile", "DecvertMAPfile", "DecvertMAPFile", "DecodeFromLog", "DecvertMapfile", "DecodeToFiles", "DecodeMapfile", "DecodeTofile", "DecvertMapFiles", "DecvertMapLog", "DecodeFromfile", "DecodeMAPFile", "DecvertMapFile", "DecodeFromFile", "DecvertMAPFiles", "DecodeToFile", "DecvertMAPLog", "DecodeFromFiles", "DecodeMAPLog", "DecodeMapLog"], "mapFile": ["mapFILE", "mapFilename", "MapStream", "listFile", "imageFile", "MapFile", "listPath", " mapFilename", "mapfile", "mapStream", "Mapfile", "cacheFile", " mapPath", "cacheFILE", "imageStream", "cachePath", "imageFilename", " mapStream", "listFILE", " mapFILE", " mapfile", "imagefile", "MapFilename", "mapPath"], "outputFile": ["outputDir", "OutputDir", "outputStream", "inputName", "outFile", "OutputPath", " outputDir", "writeName", "outPath", "mapStream", "mapName", "OutputFilename", "outDir", "writeStream", "outFilename", "outputPath", "mapDir", "writeFile", " outputPath", "inputStream", "OutputFile", "outputFilename", "inputFile", " outputFilename", "inputDir", "outputName", "writeDir"], "magicKey": [" magicCode", "prefixKey", "magicChar", "uniqueCounter", " magicChar", "prefixValue", " magicField", "serialKEY", "encryptedKey", " magicKEY", "anticKey", "serialKey", "antickey", "MagicName", "prefixCounter", "magicValue", "magicCounter", "uniqueValue", "magicField", "serialId", " magicId", "magicKEY", " magicValue", "magicName", "serialName", "MagicKey", "prefixCode", "magicId", "magicCode", "encryptedChar", "MagicKEY", "magickey", "anticField", " magickey", " magicCounter", "anticChar", "uniqueKey", "encryptedkey", " magicName", "uniqueCode", "MagicId", "encryptedField"], "buffer": ["history", "memory", "Buffer", "binary", "detail", "stack", "stream", "black", "pad", "buff", "base", "length", "total", "attribute", "batch", "document", "flash", "print", "phrase", "iter", "button", "shape", "queue", "stroke", "index", "cache", "check", "program", "database", "screen", "command", "variable", "mem", "buf", "bone", "paste", "frame", "template", "row", "sample", "block", "sequence", "message", "bo", "display", "vector", "char", "sum", "initial", "append", "table", "filter", "code", "bridge", "window", "page", "header"], "nread": ["ncwrite", "renwrite", "nreadable", "rawreader", "rawwrite", "rentry", "maxget", "rawtry", "Nread", "maxread", "ncRead", " nwrite", "rnread", "maxadd", "Nwrite", "NRead", "nREAD", "maxRead", " ntry", " nREAD", "ncget", "rawread", "ncread", "nwrite", "ntry", "rnwrite", "rnRead", "NREAD", "ncreadable", " nreadable", "renreader", "ncadd", " nRead", "nreader", "nget", "nRead", "rnREAD", "Nget", "Nadd", "renread", " nreader", "Nreadable", "nadd"], "map": ["meta", "apper", "parse", "ip", "aps", "app", "ml", "where", "memory", "window", "read", "manager", "maps", "view", "down", "mount", "mt", "file", "batch", "mod", "image", "mate", "place", "shape", "mask", "cache", "open", "pack", "ace", "ape", "address", "up", "op", "mem", "apping", "mp", "clear", "co", "per", "pl", "load", "set", "man", "module", "con", "pose", "lock", "cm", "block", "master", "com", "config", "MAP", "m", "collect", "table", "ap", "bridge", "make", "form"], "output": ["object", "four", "exit", "write", "can", "oe", "blue", "stream", "auto", "log", "file", "batch", "icon", "print", "next", "web", "result", "secure", "console", "update", "out", "client", "hidden", "queue", "input", "Output", "put", "cache", "plain", "open", "entity", "format", "online", "network", "target", "o", "net", "response", "block", "display", "latest", "ilo", "socket", "port", "ou", "current", "outer", "other"], "i": ["ip", "t", "li", "y", "v", "span", "bi", "ii", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "mi", "iu", "batch", "b", "gu", "gi", "spin", "uri", "q", "cli", "ami", "x", "is", "ti", "ie", "index", "ci", "pi", "ji", "n", "qi", "ni", "si", "ix", "di", "ini", "ei", "it", "ish", "sim", "j", "m", "fi", "ai", "g", "us", "ic", "ri", "ms"]}}
{"id1": "15904772", "id2": "10715601", "code1": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getSystemStateHash": ["getSysStatesHash", "getSysStateSalt", "getSystemStatehash", "getSysStatehash", "getSystemLocalKey", "getSystemLocalHash", "getSystemRandomhash", "getSystemStatesHash", "getSysStatesSalt", "getSystemStateshash", "getSystemStatesKey", "getSysStatesKey", "getSystemRandomHash", "getSystemLocalhash", "getSystemLocalSalt", "getSysStateKey", "getSystemRandomKey", "getSysStateshash", "getSystemStatesSalt", "getSysStateHash", "getSystemStateSalt", "getSystemRandomSalt", "getSystemStateKey"], "sha1": ["ha01", "sha51", "ha1", "tar100", "ha64", "sha384", "sh100", "sche4", "ha0", "tar3", "shaacy", "shape4", "shape51", "tar7", "sche7", "ha001", "scheOne", "sche51", "SHAone", "ami1", "sche1", "SHA1", "ha7", "sh3", "sha100", "sha11", "no81", "ka01", "shape1", "sche81", "sche8", "ka001", "SHA3", "sha256", "sh11", "sha0", "ha51", "waone", "sh8", "sha8", "ssh1", "sha4", "sche100", "scheache", "tarache", "sche0", "sh01", "sh256", "ha4", "sha64", "shaOne", "sche9", "haache", "ha81", "ppa1", "ha100", "no1", "sche2", "ha256", "shaone", "tar1", "sha2", "amiacy", "sha81", "sha7", "ha6", "ssh8", "tar384", "sche64", "sha01", "sh2", "sh81", "sh6", "ha384", "sh9", "wa3", "sha61", "shapeache", "ha9", "SHA4", "sh0", "no01", "no3", "shaache", "sche11", " SHA1", "wa1", "haOne", "sche6", "sche3", "shOne", "sh384", "ka1", "tar01", "ha8", "sh1", "shake7", "sha001", "shake64", "ami7", "sh4", "ha11", "ssh6", "ha2", "shache", "sche61", "sh7", "ka81", "ka11", "sha9", "haacy", "sh61", "shake61", "ha3", "SHA2", "sha3", "ppa100", "ssh81", " SHA001", "ppaache", "shone", "sche256", " SHA11", "shacy", "sh64", "ppa01", "shake1", "haone", "sha6", "ka3", "scheone"], "props": ["pperties", "Properties", "Probs", "prperties", "rops", "Proports", " prors", "prors", "prop", "prps", " properties", "roperties", "Prors", "prbs", "pbs", "preps", "ProPS", "roms", "proPS", "pports", " proPS", "proports", "pps", "prePS", "Prop", "properties", "prep", "proms", " prop", "rors", "prports", "preperties", "probs", " proms", "Props", "Proms"], "names": ["parents", "pres", "nos", "modules", "terms", "codes", "strings", "aps", "ors", "AMES", "testers", "paces", "als", "makers", "Names", "ers", "ones", "ports", "photos", "these", "ern", "versions", "objects", "nes", "ons", "ids", "ews", "mas", "n", "chains", "words", "ames", "idents", "properties", "members", "papers", "ens", "beans", "appers", "nets", "values", "files", "groups", "nm", "keys", "events", "s", "ns", "ren", "ms"], "name": ["create", "named", "type", "Name", "part", "str", "base", "id", "comment", "attribute", "ame", "print", "prefix", "common", "string", "path", "item", "no", "family", "alias", "title", "address", "term", "var", "n", "old", "a", "url", "NAME", "description", "pair", "info", "number", "value", "event", "num", "size", "entry", "label", "nm", "node", "resource", "parent", "nam", "code", "word", "key", "def", "class"]}}
{"id1": "5125848", "id2": "23672408", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"combineJs": ["combinateLink", "Combosejs", "ComboseJS", "CombineJs", "combineJS", "combinateJS", "combinatejs", "combinateJs", "CombineJS", "ComboseJs", "comboseJS", "combINEjs", "comboseJs", "combinejs", "combosejs", "combINELink", "ComboseLink", "comboseLink", "Combinejs", "combineLink", "combINEJS", "CombineLink", "combINEJs"], "base": ["buffer", "bound", "ase", "based", "re", "host", "data", "id", "server", " bases", "file", "bottom", "bas", "b", "prefix", " basis", "uri", "source", "origin", "address", " Base", "start", "root", "absolute", "relative", " based", "Base", "api", "template", "site", "local", "domain", "from", "reset", "bid", "page", "db"], "linkJs": ["linkTags", "inkScript", "linkJS", "inkLinks", "LinkJS", "linkjs", "Linkjs", "linkLinks", " linkJS", " linkjs", "LinkJs", "inkJS", " linkScript", "inkJs", "LinkTags", "inkTags", "linkedJS", "linkScript", " linkLinks", "linkedLinks", "inkjs", " linkTags", "linkedJs", "linkedScript"], "newFiles": [" newLinks", "newLinks", "newDocuments", "linkfiles", "newfiles", "linkLinks", "nextLinks", "nextDocuments", "nextfiles", " newfiles", "linkDocuments", "nextFiles", " newDocuments", "linkFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "manager", "dr", "lib", "md", "id", "auto", "file", "disk", "div", "loc", "mod", "temp", "dd", " directory", "sys", "out", "mk", "dm", "Dir", "DB", "ref", "created", "DIR", "tar", "root", "diff", "fd", "folder", "d", "pkg", "di", "fs", "directory", "module", " Dir", "lock", " d", "desc", "rel", "area", "ir", "local", "vol", "done", "doc", "addr", "zip", "good", "db", "def"], "name": [" rebuild", " dummy", " self", " db", " vm", " log", " info", " prefix", " manager", " b", " scanner", " browser", " loader", " res", " parser", " logger", " start", " karma", " msg", " names", " err", " cleaner", " report", " bar", " str", " foo", " filename", " tmp", " os"], "minDir": ["smallDir", "minPref", "minRel", "minuteDar", "MinNet", "minutePref", "miniTrans", "mindir", "skindir", "skinDir", "minTrans", "maindir", "minJar", " minJar", "minDb", " minPref", "smallNet", "minuteDir", "minDar", "minFile", " minTier", " minRel", "minTier", "sortDir", "sortRel", " minDar", " minFile", "thinJar", " minTrans", "smallDb", " minNet", "thinTier", "minLoc", "smallLoc", "mainDb", "skinDb", "minuteRel", "smalldir", "sortDar", "miniTier", "sortPref", "smallFile", "skinLoc", "minNet", "mainDir", "thinDir", "miniDir", "thinTrans", "MinFile", "miniJar", "mainLoc", "MinDir"], "combineFile": ["cominatefile", "cominateMessage", "coordINEFile", "coordINESet", "combinateFile", "combINEWriter", "comboseWriter", "combinSet", "combinerfile", "cominateFile", "comboseSet", "comineFile", "coordineFile", "comineMessage", "comboiceFile", "combINESet", "comboseFile", "coordineSet", "combinerFile", "cominefile", "combinerMessage", "combinefile", "combinFile", "combinateMessage", "coordinefile", "combosefile", "comineEmail", "combineMessage", "comboiceEmail", "combINEfile", "coordINEWriter", "coordineWriter", "comboiceMessage", "comboicefile", "coordINEfile", "combinateEmail", "combineEmail", "cominateEmail", "combinWriter", "combinatefile", "combinerEmail", "combinfile", "combineSet", "combINEFile"], "concatFile": ["comcFile", "concDir", "concatfile", "concapFiles", "concFile", "comcDir", "conatFile", "conatFiles", "concatFiles", "covertTable", "comcatDir", "conCatFilename", "convertfile", "convertFiles", "cocatFiles", "cocatTable", "concFilename", "concapfile", "conCatDir", "covertfile", "covertFile", "comcatFilename", "conatTable", "conatfile", "concatFilename", "comcFilename", "concapTable", "cocatfile", "convertTable", "concatDir", "covertFiles", "concapFile", "convertFilename", "convertFile", "conCatFile", "concatTable", "comcatFile", "cocatFile", "convertDir"], "combineWriter": ["declineFile", "declinateReader", "declinateWriter", "combineReader", "combinateFile", "declinateFile", "combinateWrite", "combenwriter", "combinateWriter", "combinewriter", "Combosewriter", "comboseWriter", "ComboseCounter", "comboseReader", "combenWrite", "combinatewriter", "declineReader", "declineWrite", "comboseFile", "comboseWrite", "declinateWrite", "ComboseWrite", "combieWriter", "CombineWrite", "combosewriter", "combieWrite", "combineCounter", "combinateCounter", "combieReader", "combinateReader", "combineWrite", "CombineCounter", "declineWriter", "combieFile", "CombineWriter", "combenCounter", "Combinewriter", "combenWriter", "ComboseWriter", "comboseCounter"], "concatWriter": ["concatWrite", "concatsReader", "cocatWriter", "conatReader", "conatFile", "coatWriter", "comvertWriter", "cocatReader", "cocatWrite", "comcatWrite", "comvertReader", "coatWrite", "conatWriter", "concatsWrite", "convertReader", "coatFile", "comcatReader", "convertWrite", "comvertFile", "coatReader", "comvertWrite", "concatReader", "concatsWriter", "conatWrite", "convertWriter", "convertFile", "comcatWriter", "comcatFile", "cocatFile", "concatsFile"], "fails": ["mails", " failed", "facocks", "ifails", "lalls", "facails", "frailed", "ifocks", "mailed", "lails", "falls", "failing", "malls", "frails", "fils", "mocks", "Fils", "lailing", "focks", "ifailed", " focks", "ifailing", "facailing", "facailed", "failed", "frailing", "Failing", "frils", "mailing", "Fails", "lailed", " falls", "Failed", " failing", "lils"], "link": ["embed", "c", "li", "follow", "close", "inline", "links", "log", "loc", "self", "l", "add", "mark", "relation", "ln", "linked", "child", "line", "check", "open", "address", "ink", "map", "script", "load", "match", "set", "display", "Link", "task", "node", "code", "share", "remote", "source", "skip", "push"], "path": ["text", "location", "kind", "src", "PATH", "data", "str", "id", "prop", "full", "file", "loc", "ath", "image", "join", "prefix", "hex", "route", "uri", "string", "pattern", "input", "alias", "ref", "Path", "format", "root", "p", "relative", "href", "match", "template", "entry", "style", "resource", "source", "key"], "url": ["li", "location", "request", "build", "ul", "host", "nl", "mount", "str", "id", "html", "this", "loc", "lr", "l", "gl", "web", "uri", "il", "string", "r", "browser", "ssl", "ls", "mail", "ref", "sl", "address", "ur", "get", "http", "href", "hl", "ll", "rel", "abs", "URL", "char", "null", "addr", "resource", "Url", "source"], "inputStream": ["InputTime", "InputSteam", "outputstream", " inputSet", "inputTime", "inSet", "inputStyle", "outputSteam", "inTime", " inputStyle", "Inputstream", " inputTime", "inStream", "instream", "inputSet", "InputStyle", "inputstream", " inputSteam", "InputStream", "inputSteam", "outputStyle", "InputSet", " inputstream"], "jsFile": ["javascriptName", "javascriptFilename", "jsTable", "cssPath", "jsFilename", " jsFilename", "JsFilename", " jsfile", "cssFilename", "Jsfile", "JsPath", "javascriptPath", "jsfile", " jsPath", " jsTable", "JsFile", "javascriptTable", " jsName", "cssTable", "javascriptFile", "javascriptfile", "cssfile", "jsPath", "jFilename", "jsName", "jName", "jFile", "jPath", "cssFile"], "fileName": ["getPath", "FileHash", "filePath", "Filename", "getName", " fileHash", " filePath", "FilePath", "FileName", "getHash", "getname", " filename", "filename", "fileHash"], "outputStream": [" outputstream", "OutputSet", "OutputStyle", "OutputSteam", "outputstream", "inputStyle", "OutputStream", "outputSteam", "writeStream", "outputSet", "writeSet", "OutputForm", "outputForm", " outputStyle", "inputstream", "Outputstream", "writeSteam", " outputForm", " outputSet", " outputSteam", "inputForm", "inputSteam", "outputStyle", "writestream"], "first": ["prev", "then", "same", "top", "default", "each", "stack", "ind", "quick", "self", "now", "next", "continue", "sort", "index", "open", "third", "success", "primary", "fourth", "start", "false", "send", "all", "natural", "important", "only", "seconds", "valid", "must", "st", "latest", "fast", "First", "initial", "true", "real", "last", "second", "master", "unique", "front", "current"], "reader": ["io", "read", "buffer", "rator", "ocr", "rl", "mr", "stream", "data", "core", "this", "file", "layer", "inner", "loader", "Reader", "ro", "parser", "r", "ner", "driver", "rer", "input", "rar", "rc", "er", "builder", "wrapper", "http", "row", "context", "runner", "handler", "rr", "resource", "writer", "iterator"], "jsCompressor": ["jscomposer", "jsCompression", "cssComposer", "jsBuffression", "cssCompressor", "jscompressor", "jsReposer", "jsComposer", "jscompression", "cssRepression", "jscompiler", "jsRepression", "cssRepressor", "cssRepiler", "cssReposer", "jsBuffiler", "jsRepressor", "jsCompiler", "jsBuffoser", "cssCompiler", "jsBuffressor", "jsRepiler", "cssCompression"], "s": ["qs", "ings", "gs", "t", "ss", "y", "ies", "ps", "details", "tags", "ats", "es", "less", "hs", "parts", "os", "full", "ers", "l", "cs", "ds", "is", "ls", "ms", "ids", "words", "fs", "eds", "S", "ens", "lines", "ts", "ns", "pers", "tes", "xs"], "s1": ["s3", "ys1", "esFirst", "ls0", "ls3", "es9", "s0", "id1", "s9", "s81", "ys81", "ps1", " s3", "es2", "ys0", "ls81", "es1", "ls1", "pers1", "sFirst", "ys3", " s0", "id2", "id9", "idFirst", "ps0", " s81", "pers0"], "i": ["ori", "ip", "li", "io", "y", "um", "v", "bi", "ii", "ity", "I", "id", "ui", "mi", "iu", "ati", "oi", "ig", "im", "iti", "ie", "is", "ifier", "ci", "pi", "iat", "p", "ia", "di", "o", "it", "ch", "j", "ai", "us", "ion", "ic", "ri"], "s2": ["msTwo", "s02", "tes2", "ztwo", "zSecond", "ss02", "gs2", "gstwo", "gsSecond", "SSecond", "ms2", "z02", "es2", "tes1", "sTwo", "S2", "es1", "tes02", "Stwo", "ss22", "ms02", "es02", "sSecond", "ss2", "gs02", "S02", "tesTwo", "esTwo", "stwo", "s22", "z2", "ssTwo", "ms22"], "i1": ["p4", "o1", "it0", "o0", "it1", "it01", "iOne", "aOne", "e1", "it2", "i0", "eOne", "a2", "e4", "p1", "e2", "a1", "p2", "p0", "i2", "oOne", "it4", "a01", "pOne", "o4", "itOne", "p01", "i01", "i4"]}}
{"id1": "16557837", "id2": "8150996", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["copyFileFile", "transferfromTo", "transferfromDir", "copyFromFrom", "transferfromFrom", "copyFileDir", "copyFromDir", "transferfromFile", "transferFromTo", "copyFormTo", "copyFileFrom", "copyFormFile", "transferFromDir", "copyfromFile", "copyFormFrom", "copyFormDir", "copyfromFrom", "transferFromFile", "copyFromFile", "copyFileTo", "copyfromTo", "transferFromFrom", "copyfromDir"], "srcFile": ["destPage", " srcPlace", " srcfile", "rcFILE", "ivFile", "sortFiles", " srcFILE", " srcFilename", "srcPath", "sourceDir", "rcPath", "ivSourceFile", "rcDir", "destDir", "sbFilename", "sbPlace", "sourceFile", "sysfile", "ivFILE", "sysFile", " srcFiles", " srcDir", "ivPage", "sortSourceFile", "destfile", " srcPath", "sourcefile", "rcFiles", "srcPlace", "srcfile", "sortPage", "srcFiles", "srcPage", "srcFilename", "rcFile", " srcPage", "srcSourceFile", "destPath", "sourcePath", "sbFile", "sortFile", "rcPage", "sysPlace", "srcFILE", "sbfile", "sysFilename", "srcDir", " srcSourceFile", "sortFILE"], "destFile": ["descFilename", "DestDir", "descFILE", "descDir", "restFILE", "etcDirectory", "DestFILE", "DestDirectory", "restDirectory", "restFilename", " destfile", "srcPath", "restFile", "memFilename", "DestFilename", "optFile", "memFile", "destDir", "DestPath", "destFILE", "Destfile", "destDirectory", "destfile", "destFilename", "DestFile", "memfile", "DestFiles", "srcFiles", " destFilename", "destPath", "srcFilename", " destFiles", " destDirectory", "etcFILE", "memFILE", "descFile", "destFiles", "optDir", " destDir", "optFilename", "optfile", " destFILE", "srcDir", "etcFilename", "etcFile", " destPath", "srcDirectory"], "in": ["t", "io", "bin", "can", "din", "read", "conn", " din", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "add", "l", "inf", "ain", "inside", "iter", "vin", "mc", "body", "is", "input", "ci", " IN", "In", "n", "on", "co", "gin", "init", "all", "info", "o", "IN", "net", "ini", "con", "local", "it", " input", "from", "ar", "ins", "ex", "inn", "m", "cin", "i", "mm", "source"], "out": ["t", "det", "gr", "v", " output", "or", "boot", "ext", "session", "ot", "cmd", " OUT", "up", "term", "on", "list", "con", "output", "Out", "ins", "null", "ion", "writer", "g", "outer", "io", "conn", "ne", "file", "sys", "client", "cache", "o", "net", "group", "ret", "ou", "aos", "txt", "can", "write", "tree", "os", "over", "OU", "inter", "at", "no", "screen", "nt", "p", "pretty", "json", "cn", "it", "to", "table", "msg", "not", "set", "OUT", "c", "cfg", "inv", "str", "log", "pool", "print", "res", "obj", "end", "n", "co", "all", " Out", "outs", "ch", "desc", "w", "sum", "unt", "ex", "store", "i", "summary"], "fis": ["foois", "freris", "fiss", " fisan", "elfisan", "fens", "foris", "sfis", "cfos", "Fois", "elfiss", " fois", " fiss", "fois", "freois", "foiss", "Fos", "sfos", "freens", "Fist", "elfis", "foens", "cfois", "sfisan", "cris", "sfiss", "Fiss", "fisan", "elfos", "cfis", "fist", "cois", "foos", " fist", "freis", "foist", "cens", "cfiss", "Fis", "cis", "fris"], "fos": ["fortos", "flot", "foes", "fortres", " fot", "Foss", "pus", "fous", "lus", "fot", "fres", "vot", "fios", "pos", "fooes", "vom", " fsys", "fortsys", " foss", "fois", "foss", "fiios", "vos", "loes", "flom", "Fos", "lis", "flres", "voss", " fios", "Fres", "vios", "poes", "wis", "flos", "los", "floss", "fus", "Fsys", "fioes", "fsys", "foos", "wom", " fres", " fom", "fom", "voes", "fiot", "wres", "flis", " foes", "pis", "fortoss", "wos"], "srcModified": ["srcmoded", "srcTrmodified", "rcTrify", "srcModsification", "srcMODed", "srcHasifier", "curModsification", "curModsify", "srcmodify", "rcModifier", "srcMODified", "srcModsined", "srcModifier", "rcTrifier", "srcModmodified", "rcModed", "srcHasified", "srcModify", "srcTrifier", "curModified", "srcHasmodified", "rcTrined", "rcTrified", "srcModined", "srcModsifier", "curModsmodified", "rcTred", "srcModed", "srcModsmodified", "srcModification", "srcTrify", "srcTrined", "srcModsified", "srcmodified", "rcModmodified", "srcHasined", "srcModsify", "rcModined", "rcModify", "rcModified", "srcMODification", "curModify", "curModmodified", "srcTred", "srcMODifier", "rcTrmodified", "srcTrified", "srcMODify", "curModification", "srcmodifier", "srcMODmodified", "curModsified"]}}
{"id1": "4602568", "id2": "771802", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"storeImage": ["StoreFile", "saveImages", "StoreImages", " storeImages", "storeFile", "StorePicture", "storeImages", " storeFile", " storePicture", "saveFile", "StoreImage", "savePicture", "saveImage", "storePicture"], "inStream": ["cinView", " inSteam", "outFile", " inFile", " inForm", "cinSteam", "cinFile", "inSteam", " inView", "outSteam", "fileStream", "fileFile", "inputStream", "inForm", "fileSteam", "inputFile", "inputView", "fileForm", "inFile", "inputSteam", "cinStream", "outForm", "inView"], "fileName": ["fileType", "imageInfo", " fileInfo", "FileType", "imagename", "FILEPath", "FilePath", "imageName", "FileName", "imageTime", "resourcePath", "FILEName", "imagePath", "filePath", " filePath", "FileInfo", "imageType", "FileTime", "fileTime", "resourceTime", "fileInfo", "FILEInfo", "resourceType", "Filename", " fileType", "resourceName", "FILEname", " filename", "filename"], "resize": ["renized", " resized", " resizes", "renize", "renizes", "resizes", "Resized", "Ressize", "rensize", " ressize", "resized", "ressize", "Resizes", "Resize"], "rightNow": ["westNow", "rServer", "rightCurrent", "rightFuture", "correctToday", "RightCurrent", "rNOW", " rightNOW", "RightToday", "correctFuture", "RightNow", "rNow", "westThen", "westFuture", "rightServer", "westCurrent", "correctNOW", " rightThen", " RightThen", " RightNOW", " RightCurrent", " rightToday", " rightFuture", "rightNOW", " rightServer", "westToday", " RightNow", "rightToday", "westServer", "rToday", "correctNow", " rightCurrent", "westNOW", "rightThen", "RightFuture"], "dayNamedFolderName": ["dayNamedFolderNames", "dayNamingDirectoryNames", "dayNamingFileNames", "dayNamedDirectoryName", "dayNamedFileSize", "dayNamingDirectory1", "dayNamedFoldername", "dayNamedFilePath", "dayNamedDirectoryname", "dayNamingFileName", "dayNamedFileNames", "dayNamedFileName", "dayNamedFolder1", "dayNamedThemeNames", "dayNamingDirectoryname", "dayNamedDirectory1", "dayNamedThemeSize", "dayNamingFilePath", "dayNamingFolderSize", "dayNamedfoldername", "dayNamedAreaname", "dayNamedAreaNames", "dayNamedAreaName", "dayNamingFoldername", "dayNamedfolder1", "dayNamedThemename", "dayNamingFileSize", "dayNamedfolderName", "dayNamingDirectoryName", "dayNamedDirectoryNames", "dayNamingFolder1", "dayNamingFolderName", "dayNamedFolderSize", "dayNamingFilename", "dayNamedThemePath", "dayNamedfolderNames", "dayNamedFilename", "dayNamedfolderPath", "dayNamedThemeName", "dayNamedArea1", "dayNamingFolderPath", "dayNamedFolderPath", "dayNamingFolderNames"], "uploadDirRoot": ["uploadDirectoryRoot", "UploadDbBase", " uploadRelPath", "saveDirRoot", "uploadUrlParent", "uploadDirParent", "UploadDirCover", "saveDbroot", "saveDirroot", "uploadNetBase", "uploadFolderRoot", "uploadDirBase", "uploadDbroot", "UploadDbRoot", "uploadDirPath", "uploadFolderroot", "uploadUrlBase", "uploadNetCover", "uploadRelBase", "uploadDbBase", "uploadUrlRoot", "UploadDirroot", "UploadDbCover", "uploadDirectoryroot", "uploadFolderPath", "uploadNetRoot", "uploadDbRoot", "uploaddirCover", "saveDirParent", "uploadDbParent", " uploadDirPath", "uploadFolderBase", "uploadNetroot", " uploadRelroot", "uploaddirRoot", "saveDbRoot", "uploadRelroot", "uploadDbCover", "uploadUrlPath", "UploadDirRoot", "uploadDirCover", "uploadRelPath", " uploadRelRoot", "uploaddirroot", "uploadRelRoot", " uploadRelBase", "uploadDirroot", "saveDbParent", "uploaddirBase", "uploadDirectoryParent", "UploadDirBase", "UploadDbroot", " uploadDirBase", " uploadDirroot", "uploadUrlroot"], "file": ["t", "type", "top", "run", "tree", "base", "FILE", "full", "el", "File", "pool", "image", "dir", "il", "source", "ile", "no", "time", "work", "open", "entity", "name", "up", "op", "handle", "project", "get", "f", "folder", "channel", "force", "local", "link", "null", "to", "table", "resource", "parent", "port", "node", "task", "page", "key", "h", "class"], "extension": ["expention", "exention", "EXTend", "dimensions", "expended", "expensions", "xtended", "dimension", "EXTension", "EXTended", "exendant", "dimention", "EXTention", "extensions", "expend", "xtend", "expendant", "extend", "exensions", "extendant", "extended", "xtention", "extention", "xtension", "expension", "exension", "dimendant"], "outFileName": ["outFileInfo", "outLinename", " outFilename", "OUTFieldName", "outDirName", "OutFileKey", "outLineNames", "OUTLogPath", " outLogname", "outLogName", "outLogVersion", "outFieldname", "outFileKey", "OutFileName", "OUTFilePath", "infileType", "outLogPath", "inFileType", "outDirPath", "OUTLogname", "outImageKey", " outLogNames", "OUTFieldname", "outFieldName", "outLogKey", "outFilenameName", "outFileVersion", "outfilePath", "inFileName", "outFilesName", "OutFilePath", "outFilenameKey", "outDirname", " outLineInfo", "outfileName", "Outfilename", "outfilename", "outfileVersion", "outLogname", "outFilenameInfo", "outImagename", "outFilenameNames", "outfileKey", "outFilenameSize", "outImageNames", "infilename", " outLogName", "outLineKey", "inFilename", "outFilenamename", "outFilenameVersion", "outFilesname", "inFileSize", " outLinePath", " outLineName", "outFilenamePath", "infileSize", "OUTLogName", "outFilenameType", "OutfileName", "outFileNames", " outFileVersion", " outFileInfo", "OUTFieldPath", "OUTLogKey", "outFilesPath", " outFilePath", "outFieldPath", "outfileType", "OutfilePath", " outFileNames", "OUTFileName", "outLineInfo", "infileName", "OutFilename", "OutfileKey", "outFileType", " outLineNames", "outFilename", "outImageInfo", "outfileNames", " outLogVersion", "outFieldSize", "outFileSize", "outLogNames", "outImageName", "outLinePath", "outLineName", "OUTFilename", "OUTFileKey", "outImagePath", "outfileSize", "outFilePath", "outFieldType"], "outPathAndName": ["outPortAndName", "outPathOrKey", "outPathOrNames", "outTimeButName", "outPathANDName", "outPortAndPath", "outTimeAndLike", "outPathOrLike", "outPortButName", "outLocationAndKey", "outLocationandNames", "outLocationAndName", "outTimeAndPath", "outPathButName", "outPathAndTime", "outPathandSize", "outTimeButLike", "outPathButTime", "outPathANDLike", "outPathandNames", "outPathAndKey", "outTimeAndTime", "outPathAndPath", "outTimeButTime", "outPathButLike", "outPortButKey", "outPathOrName", "outPathandName", "outLocationandSize", "outPathAndNames", "outPathandPath", "outPathButKey", "outTimeButPath", "outPathOrSize", "outLocationandName", "outPathButPath", "outPathAndSize", "outPathAndLike", "outPathANDPath", "outPathOrTime", "outPortButPath", "outPathandKey", "outTimeAndName", "outPathOrPath", "outPathANDTime", "outLocationandKey", "outLocationAndSize", "outPortAndKey", "outLocationAndNames"], "uploadedFile": ["presentedfile", "uploadiedFile", "presentedFILE", "uploadededFormat", " uploadededLine", " uploadedifiedF", "uploadpedLine", "uploadiedF", " uploadededF", "uploadedGlobal", "presenttedField", "presenttedfile", "uploadmedFile", " uploadededFile", " uploadedifiedUnit", "uploadashedfile", "uploadedF", "uploadashedFile", "presentedFile", "uploaderfile", "uploadedLine", "uploadredGlobal", "uploadredFile", "uploadededPlace", "uploadtedfile", "presenttedFILE", "uploadedField", "presenttedFile", "uploadtedFILE", "uploadifiedLine", "uploadiedLine", " UploadmedPlace", "uploadashedField", "uploadredPlace", "uploaderField", " UploadmedFormat", "uploadpedUnit", " UploadedGlobal", "uploadashedFILE", "uploadedUnit", " UploadmedGlobal", " UploadedPlace", "uploadmedFormat", "uploadedfile", "uploaderFILE", "uploadifiedUnit", " uploadededUnit", "uploadmedPlace", "uploadtedFile", "uploadedFILE", " uploadedifiedLine", "uploadmedGlobal", "uploadredFormat", " UploadmedFile", "uploadededFile", "presentedField", "uploadifiedFile", "uploadpedF", "uploadedPlace", "uploadiedUnit", " UploadedFormat", "uploadifiedF", "uploadtedField", "uploadededGlobal", " uploadedifiedFile", "uploadpedFile", "uploaderFile", " UploadedFile", "uploadedFormat"], "outStream": ["outView", "oSteam", "_", "outFile", "oFile", "inSteam", "outSteam", "oStream", " outFile", " outSteam", "inFile", " outView", "oView", "inView"]}}
{"id1": "17296916", "id2": "7761195", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"logging": ["Loging", "logger", " loging", "debugStorage", "debugging", "loging", " logStorage", "debugger", "logStorage", "debuging", "LogStorage", "Logger", " logger", "Logging"], "wrap": ["wra", "parse", "create", "rap", "read", "build", "W", "wire", "pad", "inter", "python", "add", "web", "xf", " wrapper", "word", "form", "transform", "shape", " wrapped", "x", "ow", "work", "aw", "pack", "ws", "chain", "format", "nw", "start", "handle", "me", "get", "safe", "root", "wrapper", "use", "sw", "find", "wind", "ew", "wa", "gate", "wx", "w", "sp", "message", "we", "link", "force", "reset", "store", "ad", "zip", "box", "window", "grow"], "buffer": ["reply", "Buffer", "binary", "bb", "memory", "surface", "view", "buff", "base", "attribute", "layer", "batch", "document", "flash", "print", "phrase", "complete", "trace", "flag", "body", "iter", "console", "word", "bar", "button", "queue", "profile", "line", "library", "reference", "cache", "ob", "database", "screen", "command", "note", "position", "face", "buf", "builder", "wrapper", "frame", "directory", "template", "row", "pb", "size", "block", "append", "message", "output", "display", "report", "sequence", "bo", "reset", "store", "table", "writer", "bridge", "window", "quote", "header"], "encoding": ["enryption", "enoded", "enumging", "enoding", "encoder", "enumlanguage", "enlanguage", "coding", "cododer", "cododing", "Encryption", "encoded", "enclanguage", "enumoding", "Encoding", "ecryption", "caling", "enaling", "Encoder", "Encaling", "encging", "ecoding", "cryption", "encaling", "ecoded", "ecoder", "codryption", "cging", "clanguage", "encryption", "enoder", "cododed", "enumoder", "enging", "coder"], "getEncoding": ["getencryption", "getencging", "getExpryption", " getEnination", "getencression", "getEnling", " getEnoding", "getExpression", "getEnging", "getOrigryption", " getEnling", " getEncging", " getEnression", "getencination", "getEncling", "getEncging", "getOrigination", "getEncression", "getencoding", " getEncling", "getencling", " getEnging", "getEnination", "getOrigling", " getEncryption", " getEnryption", "getExpoding", "getEncryption", "getEnryption", "getEnoding", " getEncression", "getEnression", "getOrigoding", " getEncination", "getExpging", "getEncination"], "headers": ["pres", "codes", "terms", "head", "modules", "tags", "images", "ers", "frames", "holders", "pins", "relations", "ports", "limits", "ilers", "ctors", "objects", "heads", "comments", "reports", "styles", "ids", "drivers", "checks", "params", "ppers", "chains", "builders", "names", "properties", "members", "rs", "users", "blocks", "writers", "values", "authors", "fields", "groups", "ters", "boxes", "keys", "weights", "caps", "header"], "is": ["isd", "tis", "ip", "ists", "dis", "iris", "or", "in", "bs", "\u00eds", "does", "os", "sis", "isin", "ui", "isc", "bis", "isi", "has", "was", "isf", "ist", "sys", "as", "iso", "lis", "nis", "ys", "ois", "its", "IS", "si", "ris", "fs", "ais", "ims", "isa", "mis", "iss", "ios", "isl", "obs", "ins", "osi", "us", "i", "Is", "ic", "ri", "ms"], "bos": ["oids", "tis", "dos", "nos", "pod", "ps", "bones", "bin", "ots", "bi", "bh", "bs", "fits", "js", "des", "os", "ui", "bot", "bis", "bas", "isi", "cs", "ones", "bits", "ts", "sys", "ows", "oss", "bes", "oos", "ms", "ys", "windows", "tops", "uts", "banks", "eros", "soc", "boards", "ubis", "lets", "oops", "ses", "ols", "los", "fs", "jas", "stats", "bo", "ios", "obs", "bytes", "cos", "ods", "uds", "aos", "tes"], "e": ["c", "t", "le", "ae", "v", "ev", "se", "es", "eeee", "re", "oe", "ne", "ate", "en", "ge", "r", "x", "ie", "err", "de", "er", "a", "n", "me", "p", "f", "d", "exc", "o", "E", "ex", "ee", "m", "g", "h", "i", "error", "ed"]}}
{"id1": "5237257", "id2": "4798332", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"download": ["save", " Download", "write", "copy", " downloaded", "upload", "file", "dump", " restore", " checkpoint", " retrieve", "open", " downloading", " zip", "Download", "export", "get", "paste", " seek", "init", " downloads", "load", "delete", " drop", " upload", " browse", " recover", " dump"], "fileName": ["FILEFilename", "fileType", "FileType", "projectPath", " fileFilename", "FILEPath", " fileTime", "FilePath", "FileName", "imageName", "projectFilename", "resourcePath", "FILEName", "fileFilename", "imagePath", "projectname", "projectName", "FileTime", "fileTime", "resourceTime", "resourceType", " fileType", "resourceName", "FILEname", " filename", "filename"], "filePath": ["languagePath", " fileUrl", "languageId", "FileId", "FileP", "FileStart", "fileId", "resourceUrl", "fileUrl", "FILEP", "FILEPath", "FILEpath", "FilePath", "FileName", "ilePath", "resourcePath", "FILEName", "FILEStart", "resourcepath", "FILEUrl", "filepath", "ileName", " fileId", "fileStart", "ileStart", "fileP", "languageName", "resourceName", "ileP", " filepath"], "in": ["io", "bin", "read", "din", "or", "re", "id", "inc", "isin", "rin", "ind", "mi", "el", "en", "inner", "l", "ln", "inf", "ain", "im", "inside", "iter", "r", "ie", "is", "input", "nin", "pi", "al", "up", "login", "In", "n", "on", "co", "gin", "f", "init", "win", "ini", "IN", "o", "net", "con", "one", "local", "it", "st", "from", "ar", "ins", "inn", "m", "cin", "ai", "i", "sin"], "out": ["t", "io", "v", "can", "write", "conn", "or", "boot", "po", "ne", "os", "user", "OU", "file", "inner", "ent", "at", "na", "sys", "gt", "oss", "client", "no", "nin", "obj", "end", "nt", "conv", "op", "up", "n", "note", "name", "on", "co", "p", "o", "net", "con", "cn", "it", "ch", "w", "outs", "output", "Out", "we", "ex", "null", "ns", "to", "not", "ion", "cos", "i", "ou", "aos", "OUT", "outer"]}}
{"id1": "8815137", "id2": "3187685", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyToDir": ["copy2Directory", "transfer2File", "transfer2Dir", "copyToFile", "copyFromDirectory", "copytoDirectory", "transfer2Directory", "copyFromDir", "copyFromPath", "copyToDirectory", "copy2Path", "copytoPath", "transferToPath", "copyFromFile", "transfer2Path", "transferToFile", "transferToDirectory", "copytoFile", "copy2File", "copyToPath", "transferToDir", "copy2Dir", "copytoDir"], "dir": ["tmp", "det", "dis", "wd", "manager", "dr", "lib", "src", "re", "data", "base", "md", "id", "ext", "full", "pos", "disk", "div", "loc", "mod", "dd", "del", "out", "ds", "mk", "path", "dm", "Dir", "tr", "res", "de", "draft", "spec", "DIR", "name", "old", "req", "root", "fd", "folder", "d", "init", "pkg", "directory", "cur", "module", "dist", "fin", "local", "desc", "rel", "vol", "ir", "rec", "null", "doc", "parent", "cont", "window", "db", "def"], "file": ["le", "state", "FILE", "full", "il", "job", "init", "message", "output", "null", "change", "parent", "model", "rule", "io", "core", "this", "el", "File", "ile", "limit", "out", "path", "cache", "open", "foo", "play", "get", "project", "f", "issue", "fp", "local", "link", "entry", "label", "h", "filename", "create", "unit", "type", "status", "tree", "comment", "controller", "image", "line", "entity", "url", "p", "use", "info", "value", "force", "field", "to", "table", "resource", "msg", "source", "page", "db", "base", "used", "log", "disk", "print", "result", "flag", "fn", "title", "name", "format", "handle", "http", "all", "module", "lock", "domain", "report", "task", "port", "current", "form", "class"], "fileOutputStream": [" fileOutputSteam", "fileInputstream", "fileLogSteam", "fileInputSteam", "fileControlSteam", "FileInputForm", " fileOutputForm", "FileInputView", "fileControlView", "filePutstream", "fileOutputForm", "fileLogForm", " fileWritestream", "fileInputView", "filePutSteam", "FileOutputSocket", "fileSystemView", " fileWriteStream", "fileWriteForm", "fileSystemSteam", "fileOutputstream", "FileOutputForm", "fileLogStream", "fileWriteStream", "fileInputForm", "FileOutputSteam", "fileWriteSteam", "fileOutputSteam", "fileOutputSocket", " fileOutputstream", " fileWriteSteam", "fileSystemStream", "FileOutputStream", "fileInputSocket", "filePutStream", " fileWriteForm", "fileSystemSocket", "fileControlStream", "FileInputSocket", "FileInputStream", "FileOutputView", "fileControlSocket", "fileWritestream", "FileInputSteam", "fileOutputView", "filePutForm"], "fileInputStream": ["fileInStream", " fileOutputSteam", "fileInputstream", "FILEOutputThread", "fileInputSteam", "FILEOutputstream", "fileInSource", "FILEOutputStream", "FileOutputRead", "fileOutputThread", "fileInsertList", "FILEInputThread", "FILEOutputStreamer", "fileOutputStreamer", "FileOutputList", "fileInputStreamer", "FILEInputstream", "fileinputList", "fileOutputController", "fileInController", "fileInputController", " fileOutputSource", "FILEInputStream", "fileInterStream", "fileOutputstream", "fileInputSource", " fileInputSteam", "FileOutputSteam", "fileOutputList", "fileOutputSteam", " fileInputSource", "fileInputList", "fileOutputSource", " fileInputController", "fileInterStreamer", "FILEInputStreamer", "fileInterstream", "fileinputStream", "fileInputThread", "FileOutputStream", "fileinputRead", " fileOutputController", "fileinputSource", "FileInputRead", "FileInputStream", "fileInsertStream", "fileInsertRead", "fileInterThread", "FileInputList", "FileInputSteam", "fileOutputRead", "fileInsertSteam", "fileinputSteam", "fileInputRead", "fileInSteam", "fileinputController"], "read": ["parse", "count", "ok", "reader", "write", "close", "READ", "in", "run", "each", "need", "seen", "stream", "length", "ind", "with", "raw", "print", "trust", "add", "shape", "r", "x", "input", "index", "shift", "check", "open", "hold", " write", "end", "pack", "n", "req", "start", "get", "send", "len", "load", "height", "find", "set", "Read", "num", "tell", "size", "reading", "reads", "seek", "ask", "readable", "have", "report", "wait", "offset", "last", "i", "skip", "push", "ready"], "buffer": ["history", "text", "binary", "memory", "Buffer", "stack", "stream", "buff", "attribute", "batch", "available", "document", "phrase", "print", "result", "body", "word", "iter", "button", "bar", "cache", "chain", "reason", "command", "variable", "capacity", "buf", "frame", "template", "row", "event", "sample", "sequence", "block", "message", "append", "char", "initial", "table", "filter", "window", "page", "header"]}}
{"id1": "9371421", "id2": "7372311", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"eventHash": ["EventName", "EventRender", " eventhash", " eventRender", " eventName", "eventRender", "textName", "textHash", "EventHash", "textRender", "Eventhash", "eventName", "texthash", "eventhash"], "eventstr": ["msgstr", " eventStr", "Eventname", "msgStr", "eventstring", "msgname", "msgstring", "ventStr", "Eventstr", " eventenc", "eventenc", " eventstring", "ventenc", "Eventenc", "eventStr", "eventname", "ventstr", "Eventstring", "ventname", " eventname", "EventStr"], "md": ["pm", "bd", "MD", "dh", "det", "cd", "dr", "td", "sd", "down", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "dig", "del", "cmd", "df", "mk", "mb", "nd", "mo", "dm", "pd", "nt", "metadata", "dat", "grad", "mem", "mp", "d", "ma", "der", "di", "ld", "rm", "mn", "od", "met", "m", "red", "ad", "mm", "mg", "ms"], "theDigest": [" theDEST", "theDecest", "theDFEST", "THEDigEST", "theDEST", "theDigEST", "theMDested", "THEMDested", "THEDigest", "theDigests", "theDested", " theDested", " theDigested", "thedigested", "theDecested", "theDFesting", "theDFest", "theDesting", "theDecEST", "theMDest", "THEDigested", " theDesting", "THEMDEST", "theDest", "theDigested", "theDests", "THEDigests", " theDigesting", "theMDEST", "thedigest", "theDigesting", "THEMDest", "THEMDests", "theMDests", "theDFested", " theDigEST", "thedigesting", "theDecests", " theDest", "thedigEST"]}}
{"id1": "16673769", "id2": "14877116", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 0, "substitutes": {"Start": [" restart", "Command", "Application", " Startup", "run", " Stop", "Configuration", "Continue", "Runtime", " resume", "Loader", "Load", " Launch", " Serve", "Run", "Next", "Services", "Launch", " START", " start", "start", " Init", " Activate", " Continue", "Config", "Init", " starting"], "resources": ["states", "parents", "modules", "features", "faces", "ions", "links", "classes", "headers", "services", "images", "relations", "roots", "options", "these", "https", "cles", "ables", "pages", "objects", "stores", "reports", "archives", "ids", "actions", "builders", "rooms", "names", " Resources", "models", "flows", "works", "uploads", "users", "types", "packages", "seconds", "writers", "bytes", "files", "groups", "ues", "Resources", "issues", "events", "times", "apps", "they"], "url": ["t", "dl", "location", "request", "buffer", "rl", "host", "nl", "mount", "str", "html", "base", "server", "external", "this", "raw", "log", "file", "id", "l", "b", "gl", "web", "loader", "uri", "r", "pattern", "browser", "impl", "path", "ls", "item", "res", "util", "ref", "sl", "address", "name", "bel", "un", "ur", "handle", "get", "f", "http", "json", "row", "ll", "link", "rel", "domain", "ret", "URL", "sql", "char", "entry", "config", "addr", "resource", "xml", "Url", "remote", "key"], "configFileContents": ["configfileContent", "configPageSettings", "configPageContent", "jsonFileRest", "configPageCont", "textFileContent", "configPageContents", "jsonFileSettings", "jsonFileContent", "configStreamRest", "configFileBytes", "configDocumentBytes", "textFileCont", "configStreamContent", "configfileContents", "jsonFileContents", "configFILEContents", "configFILECont", "configDocumentRest", "configStreamContents", "configStreamSettings", "configFileRest", "textfileContents", "textfileCont", "jsonPageSettings", "textfileContent", "configFileSettings", "jsonfileRest", "jsonPageContents", "configDocumentContents", "configFILEContent", "configFileCont", "jsonFileBytes", "configfileCont", "configfileRest", "textFileContents", "configfileBytes", "jsonPageContent", "configfileSettings", "configStreamBytes", "jsonfileBytes", "configFileContent", "jsonfileContents"], "configurable": [" configured", "capturable", "configure", " configure", "confure", "controlurer", "logorable", "configurer", "cturer", "Configured", "configured", "confcrete", "captorable", "Configutable", "captured", "figurer", "conforable", "logurable", "capturer", "muturable", "configcrete", "figurable", "formurer", "logcrete", "controlured", "confurer", "mutcrete", "formurable", "figuable", " configurer", "ctutable", "Configuable", "configorable", " configcrete", "mutuable", "configuable", "controlurable", "configutable", "confured", "ctured", "formuable", " configutable", "Configurable", "formured", " configuable", "confurable", "logure", "Configurer", "Configcrete", "controlutable", "figured", "cturable", " configorable", "mututable"], "jsonData": ["configInfo", " jsondata", "sonEntry", "JSONInfo", "jsonEntry", " jsonEntry", "configDat", " jsonDat", "sonInfo", "sonTime", "configData", " jsonPart", "jsonTime", "JSONdata", "xmlInfo", "configdata", "jsonDat", "jsonInfo", "sonData", "xmldata", " jsonInfo", "JSONDat", "xmlContent", "jsonPart", "logInfo", "sondata", " jsonTime", "xmlEntry", "logPart", "sonDat", "xmlData", "logData", "logDat", "configPart", "jsondata", "jsonContent", "configTime", " jsonContent", "configContent", "xmlDat", "JSONData"]}}
{"id1": "6418781", "id2": "18748516", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"client": ["batch", "component", "secure", "web", "google", "cmd", "cli", "list", "service", "row", "con", "cm", "sim", "remote", "system", "conn", "patch", "server", "prefix", "cell", "pattern", "cache", "policy", "ace", "builder", "get", "local", "response", "entry", "Client", "window", "plugin", "type", "tree", "controller", "self", "check", "nt", "url", "wrapper", "contact", "channel", "template", "query", "control", "force", "block", "call", "to", "resource", "bolt", "key", "and", "c", "cl", "close", "manager", "connection", "base", "ce", "tc", "console", "util", "obj", "chain", "command", "co", "http", "man", "store"], "names": ["states", "pres", "terms", "nos", "aps", "strings", "named", "ans", "AMES", "spe", "olds", "said", "roots", "books", "these", "prints", "some", "objects", "ls", "ons", "ids", "mas", "n", "chains", "ames", "models", "idents", "members", "papers", "rs", "sts", "users", "lines", "nets", "types", "files", "orders", "keys", "s", "nam", "ns", "aos", "ren", "ms"], "name": ["c", "t", "create", "named", "in", "member", "Name", " named", "str", "data", "key", "id", "core", "comment", "user", "ame", "l", "brain", "e", "common", "string", "out", "path", "a", "nan", "n", "me", "p", "NAME", "value", "cn", " Name", "entry", "nm", "node", "nam", "ename", "word", "filename", " NAME"], "ftpFiles": ["fttpFile", "ftfOps", "etpfiles", "ftnfiles", "etpsfiles", "aftpFiles", "ftnFile", "etpFiles", "afpFile", "etpsFile", "aftpOps", "ftpsiles", "afpTypes", "ftpOps", "aftpTypes", "ftpfiles", "ftpiles", "afpOps", "ftpsfiles", "etpsiles", "fttpTypes", "ftnFiles", "ftpsFiles", "ftniles", "ftnTypes", "ftfFile", "ftnOps", "etpsFiles", "fttpFiles", "ftpTypes", "ftfTypes", "fttpOps", "afpFiles", "etpFile", "fttpiles", "ftfFiles", "aftpFile", "etpiles", "fttpfiles", "ftpsFile"], "ftpFile": ["fltpEntity", "fftpFile", "fftpDocument", "fttpFile", "ffpfile", "ftpnfile", "ftpDocument", "fltpFiles", "ftnItem", "aftpFiles", "ftnFile", "ftrFile", "fltpfile", "flpfile", "flpFiles", "fltpFile", "ftnfile", "ffpFiles", "ffpDocument", "aftnFiles", "aftpStyle", "fftpFiles", "fttpDocument", "ftpItem", "fttpItem", "ftrFiles", "flpFile", "ftPFiles", "ftPFile", "ftrfile", "fttpfile", "fttpEntity", "flpEntity", "ftnFiles", "fttpStyle", "ftnDocument", "aftnStyle", "fftpfile", "aftnFile", "ftPStyle", "ftpnFiles", " ftnfile", "ftpEntity", " ftpfile", " ftnFiles", "fttpFiles", "ftpfile", " ftnFile", "ffpFile", "ftpStyle", "ftpnDocument", "ftnStyle", "aftpFile", "ftrEntity", "ftrItem", "ftpnFile", "ftnEntity", " ftpItem", " ftnItem"]}}
{"id1": "3046085", "id2": "4531653", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"s": ["gs", "c", "t", "text", "ss", "strings", "ps", "v", " ts", "es", "js", "str", "data", "os", "b", "e", "string", "q", "r", "is", "ls", "name", "a", "n", "its", "p", "f", "rs", "S", "w", "m", "h", "i", "g", "ns"], "tokenizer": ["operatoriter", "valueizable", "nodeization", " tokeniner", "okenzer", "tokenized", " tokener", "dateizable", "nodeisher", "Tokenize", "Tokenization", "okenizer", "terminisher", "serialzer", "terminizer", "valueisher", "valueoser", "tokenazer", "tokenitor", "Tokenizers", "serialize", "okenifier", "okenisher", "operatoriser", "toolize", "serializable", " tokenzie", "nodeized", "tokener", "okenitor", "okenener", " tokenifier", "Tokenized", "terminizable", "okeniser", "dateize", "kinizers", "okeniter", "templateizer", "tokenisher", "tokenization", "Tokenner", "terminize", "terminiser", "tokenize", "terminization", "kinizer", "tokeniner", "templateer", "toolizer", " tokenener", "datezer", "operatorzie", "okenner", " tokenner", "kinzer", " tokenoser", "operatorized", "Tokenzer", "tokenener", "templateisher", "templatezer", "tokenizers", "operatorization", "terminitor", "webitor", " tokenzer", "operatoriner", "tokenner", "operatorazer", " tokenisher", "dateizer", "okeniner", "valueizer", "okenoser", "nodeizer", "webizer", "operatorisher", "webizable", "Tokenisher", "terminazer", "templateizable", " tokenization", "Tokenifier", "templateization", "Tokener", "kinize", "okenizable", "webisher", "okenazer", "tokeniser", "terminiter", " tokenizable", "tokenzie", "toolizers", "okenize", "tokenifier", "tokeniter", "tokenzer", "Tokenener", "webize", "toolzer", "okenzie", "webization", "operatorizer", "tokenoser", "Tokenizer", "tokenizable", "serializer"], "title": ["version", "meta", "text", "t", "tip", "Title", "type", "itled", "part", "displayText", "id", "total", "story", "author", "phrase", "prefix", "holiday", "lead", "profile", "horse", "primary", "art", "name", "term", "metadata", "note", "position", "description", "template", "important", "tag", "label", "article", "table", "source", "filename", "itle", "summary"], "artist": ["object", "track", "photo", "volume", "part", "chapter", "user", "archive", "attribute", "author", "assisted", "username", "component", "image", "song", "picture", "adult", "creator", "audio", "player", "item", "art", "metadata", "position", "Artist", "project", "folder", "album", "music", "directory", "tag", "rank", "gallery", "voice", "person", "associated", "source"], "location": ["zone", "country", "translation", "near", "comment", "loc", "language", "phone", "place", "origin", "shape", "reference", "time", "address", "activity", "Location", "position", "direction", "layout", "feature", "media", "folder", "description", "directory", "local", "gallery", "area", "source"], "rating": ["meta", "scale", "frequency", "score", "average", "training", "erate", "scoring", "playing", "boarding", "profile", "library", "credit", "metadata", "rate", "weight", "confidence", "media", "music", "rates", "rank", "fps", "Rating", "rated", "movie", "genre", "ranking", "race"], "overplay": ["Overgrade", "overgrade", "appride", " overgrade", "Overcast", " override", "Override", "override", "appcast", "Overplay", "appplay", "overcast", " overcast", "appgrade"], "temp": ["tem", "generated", "tmp", "encrypted", "unit", "memory", "buffer", "type", "Temp", "base", "test", "loc", "flash", "now", "prefix", "porary", " tmp", " temporary", "time", "cache", "Temperature", "partial", "created", "stem", "tm", "name", "term", "mem", "orig", "template", "local", "texture", "emp", "output", "null", "empty", "fake", "current", "source", "key", "set", " Temp"], "tags": ["terms", "ags", "strings", "details", "links", "flags", "parts", "images", "lists", "assets", "relations", "options", "marks", "balls", "thumbnails", "pages", "tracks", "reports", "comments", "dates", "styles", "words", "names", "atts", "stats", "Tags", "types", "lines", "nets", "packages", "lights", "files", "fields", "groups", "keys", "weights", "stars"], "bytes": ["videos", "gs", "terms", "classes", "es", "bs", "parts", "services", "images", "frames", "gets", "bits", "rows", "pages", "mb", "comments", "ids", "bps", "Bytes", "words", "len", "loads", "gb", "uploads", "lines", "seconds", "blocks", "values", "files", "fields", "groups", "keys", "vals", "ips", "tes"], "hasher": ["hadher", "hydHer", "hadter", "hadger", " hascher", "haveest", " hasDR", "haveher", "hahers", "haser", "haest", "hater", "hadHer", " haser", "haster", " haster", "hadpher", "HasDR", " hader", "hashers", " hasest", "haveter", " hadher", "haher", "hascher", "havehers", "hasHer", "Hashed", "hydher", "hasest", " hadDR", " hashed", "hadcher", "hasDR", " haspher", " hadter", " hasHer", "Haster", "hasger", " hashers", "hydcher", "haspher", "Hasher", " hasger", "hashed", "Haser", "Haspher", "hydger", "hadhed"]}}
{"id1": "62362", "id2": "17296916", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 1, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "4686922", "id2": "2511579", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResources2Files", "extractResource2file", "extractResources2File", "extractResourceFromStream", "extractResourceAsfile", "extractResource2Stream", "extractResourcesToFiles", "extractResourceToFiles", "extractResourceFromfile", "extractResourceFromFile", "extractResources2Stream", "extractResourceAsFile", "extractResource2File", "extractResourcesTofile", "extractResourcesToStream", "extractResources2file", "extractResourceToStream", "extractResourceAsStream", "extractResourceFromFiles", "extractResourceAsFiles", "extractResource2Files", "extractResourceTofile", "extractResourcesToFile"], "resourcePath": ["templatePath", "resourceIn", "ResourceIn", "attributeLocation", "uriName", "uriLocation", "resourceUrl", "templatepath", " resourceName", "ResourceName", "resourcepath", "Resourcepath", "attributeUrl", "uriPath", "templateIn", "ResourcePath", "attributeName", " resourceIn", "uriUrl", " resourcepath", "resourceName", "ResourceLocation", "ResourceUrl", "resourceLocation", "attributePath", "templateName"], "dest": ["img", "tmp", "coord", "Dest", "trans", "src", "etc", "des", "nom", "this", "prop", "rest", "loc", "self", "temp", "result", "dir", "origin", "opt", "end", "dat", "orig", "mem", "comb", "target", "dist", "w", "desc", "cat", "output", "lit", "gov", "null", "to", "parent", "decl", "sp", "cont", "good", "source", "home"], "in": ["bin", "din", " din", "or", "sin", "re", "ne", "id", "inc", "isin", "rin", "ind", "file", "mi", "raw", "inner", "l", "ln", "inf", "inside", "iter", "mc", "r", "none", "is", "input", "no", "al", "up", "In", "on", "gin", "f", "init", "all", "conf", "IN", "ini", "con", "local", "it", "from", "ins", "inn", "m", "cin", "resource", "i", "source"], "out": ["t", "tmp", "io", "exit", "v", "can", "stable", "write", "ne", "col", "os", "en", "pool", "print", "inner", "b", "at", "na", "sys", "ot", "oss", "client", "no", "cache", "res", "obj", "nt", "conv", "n", "note", "on", "co", "f", "o", "net", "con", " Out", "outs", "w", "cn", "it", "Out", "output", "ch", "null", "again", "to", "cos", "writer", "i", "ou", "aos", "OUT", "outer"]}}
{"id1": "19113613", "id2": "22320592", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "ip", "save", "create", "same", "replace", "write", "Cop", "core", "py", "transfer", "download", "cross", "clip", "clone", "cp", "cop", "split", "gc", "crop", "slice", "map", "opy", "co", "move", "init", "paste", "delete", "proxy", "php", "link", "cat", "Copy", "to", "share", "cos", "pixel", "zip"], "in": ["y", "bin", "din", "inv", "sin", "re", "id", "inc", "isin", "rin", "ind", "el", "en", "mi", "inner", "l", "inf", "inside", "iter", "ie", "is", "input", "check", "up", "In", "on", "old", "gin", "init", "all", "info", "o", "IN", "net", "ini", "con", "local", "it", "from", "ir", "ins", "ar", "inn", "cin", "act", "ai", "i", "ic", "by"], "out": ["t", "tmp", "io", "y", "v", "write", "can", "conn", "ver", "base", "os", "over", "OU", "this", "log", "en", "l", "b", "inner", "result", "at", "ent", "ot", "gt", "client", "oss", "sys", "cache", "res", "err", "end", "obj", "nt", "op", "n", "on", "co", "p", "all", "o", "set", "net", "con", "one", "local", "w", "it", "outs", "output", "Out", "ch", "ex", "null", "store", "to", "not", "ion", "port", "ou", "aos", "OUT", "outer"], "source": ["scan", "unit", "status", "se", "src", "sin", "range", "cause", "scope", "base", "space", "lower", "select", "this", "attribute", "ce", "relation", "inner", "prefix", "language", "string", "origin", "ie", "SOURCE", "input", "index", "ource", "title", "format", "position", "start", "Source", "use", "si", "search", "service", "template", "query", "finder", "local", "site", "sequence", "sql", "from", "subject", "style", "store", "shell", "resource", "parent", "s", "sp", "key", "system"], "target": ["t", "location", "top", "translation", "arget", "point", "scope", "base", "tree", "dest", "test", "print", "join", "other", "origin", "gt", "pattern", "ARGET", "alias", "step", "term", "goal", "tif", "url", "root", "token", "match", "arg", "template", "query", "module", "local", "link", "rel", "output", "that", "null", "style", "to", "table", "parent", "resource", "bolt", "key", "Target"], "files": ["states", "features", "modules", "facts", "details", "faces", "parts", "headers", "services", "workers", "images", "assets", "ports", "books", "balls", "thumbnails", "items", "tools", "pages", "reports", "ls", "objects", "styles", "actions", "plates", "banks", "iles", "lets", "models", "members", "fs", "les", "jobs", "uploads", "users", "lines", "resources", "packages", "values", "pieces", "issues", "events"], "file": ["tile", "le", "fe", "data", "key", "tree", "base", "user", "FILE", "full", "el", "File", "document", "image", "print", "relation", "e", "dir", "word", "ile", "child", "line", "path", "item", "library", "work", "job", "rule", "name", "foo", "play", "feature", "f", "ve", "pe", "folder", "be", "row", "fp", "event", "local", "block", "field", "entry", "label", "table", "model", "resource", "page", "node", "parent", "port", "current", "filename"], "inCh": ["inch", "cinch", "cinCor", "rinCl", "incCor", "InCh", " inch", "cinSam", "inChan", "cinChan", "inCr", "InCl", "rinChan", "incCr", "cinCod", "InCod", "dinSam", " inChan", "inCor", "inCl", "rinCh", "dinCh", "cinCr", "incSam", "cinCh", " inCl", "rinCod", "dinCor", "inSam", "dinCr", "InChan", "inCod", "outCod", "outChan", "incCh", "outch", " inCod"], "outCh": ["inch", "outputCod", "inChan", "outGr", "outputCh", "outputGr", "newch", "newGr", "newCod", "newChan", "inCol", " outch", " outChan", "outputChan", " outCod", " outGr", " outCol", "outCod", "outCol", "outChan", "newCh", "outch", "newCol"]}}
{"id1": "3197876", "id2": "23088292", "code1": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"showTopLetters": ["showTopLters", "showTopItter", "showBottomItors", "showBottomItters", "showTopLers", "showTopItters", "showBottomLetors", "showTopLetter", "showTopItors", "showTopLetterters", "showTopLeters", "showBottomLetter", "showBottomItter", "showTopIters", "showTopLetors", "showBottomIters", "showBottomLeters", "showTopLors", "showTopLetterers", "showBottomLetters", "showTopLter", "showTopLetterter", "showTopLetterors"], "tempArray": ["empAlpha", "temArray", "temAmount", "temMessage", "tmpArea", "temarray", "tmpAs", "tempArea", "tmpArray", "temAlpha", "tmpInstance", "empAs", "tempOrder", "temIndex", "tmparray", "tempAt", "tempIndex", "tempAmount", " tempArea", "tempMessage", " tempInstance", "tmpInteger", " tempAt", "temArea", "empMap", " tempOrder", "empInstance", "empOrder", "templateArray", "empMessage", "empAt", "empInteger", "tempAlpha", " temparray", "temInstance", "empIndex", "tempMap", " tempAs", "tempInteger", "templateMessage", "temAt", "temAs", "tmpAmount", "tmpAt", "templateAlpha", "temparray", "empArray", "temMap", " tempInteger", "emparray", " tempIndex", "tempAs", "templateArea", "empArea", "tmpMap", " tempAmount", " tempAlpha", "tempInstance", "tmpOrder"], "tempArrayLetters": ["tempAreaLetators", "tempArrayLetiers", "tempRAYLetiers", "tempArrayLetlets", "tempArrayDelers", "tempAreaLetlets", "tempAreaLetowers", "tempAreaLetets", "tempArrayLETTER", "tempArrayFilers", "tempArraySetiers", "tempArrayletters", "tempRAYLetarers", "tempArrayButters", "tempRAYPatiers", "tempArrayColowers", "tempRAYDeleners", "tempStringFilter", "tempArrayLatriers", "tempArrayButlets", "tempArrayleters", "tempAreaLETbers", "tempArrayLaters", "tempArrayButeners", "tempArrayFilators", "tempStringFilters", "tempRAYLetters", "tempAreaLETter", "tempArrayMailbers", "tempArrayMailters", "tempArrayletators", "tempArraySetts", "tempArrayLatters", "tempArrayLetets", "tempArrayLetterts", "tempRAYLetlets", "tempArrayLetterters", "tempArrayLetterarers", "tempRAYDelers", "tempArrayFilebers", "tempArrayDellets", "tempArrayPainners", "tempArrayLETers", "tempArrayLetowers", "tempAreaLetners", "tempRAYPatts", "tempArrayLetarers", "tempAreaLetbers", "tempAreaFilters", "tempAreaFilbers", "tempAreaFilowers", "tempArrayFilters", "tempArrayLatter", "tempArrayMailers", "tempAreaLetter", "tempArrayFillets", "tempArrayLetriers", "tempArrayFilbers", "tempRAYLeteners", "tempArrayItets", "tempArrayLetts", "tempArrayDeleners", "tempRAYPatarers", "tempArrayLetteriers", "tempArrayFilners", "tempAreaLETlets", "tempArrayLetter", "tempArraySetators", "tempArraySetaters", "tempAreaFilners", "tempArrayLETlets", "tempAreaFilaters", "tempArrayColners", "tempAreaLETers", "tempArrayShutters", "tempArrayFilets", "tempArrayPatiers", "tempArrayFilter", "tempArrayPainers", "tempArrayPatarers", "tempRAYPatters", "tempAreaFilers", "tempRAYDelters", "tempStringLetter", "tempArrayShutlets", "tempArrayItters", "tempArrayLeters", "tempArrayColers", "tempArraySeters", "tempArrayButers", "tempArrayletTER", "tempArrayPainowers", "tempArrayletaters", "tempArrayLetaters", "tempArrayLETter", "tempArrayItbers", "tempStringFilers", "tempAreaLETchers", "tempAreaLetters", "tempArrayLETriers", "tempArrayLetators", "tempArrayFileTER", "tempArrayFilchers", "tempRAYLetts", "tempAreaLetaters", "tempArrayLetners", "tempArrayFilowers", "tempArrayLatchers", "tempAreaLETters", "tempArrayFileters", "tempAreaFilets", "tempArrayLetchers", "tempStringLetriers", "tempArrayDelters", "tempArrayPatters", "tempStringFilriers", "tempRAYDellets", "tempArrayLETeners", "tempArrayLETchers", "tempArrayMailets", "tempArrayShuters", "tempArrayLETbers", "tempStringLeters", "tempArraySetarers", "tempArrayFilriers", "tempArrayIters", "tempArrayLetTER", "tempAreaLeters", "tempArrayletbers", "tempArrayLeteners", "tempAreaLetTER", "tempArrayFilaters", "tempAreaFilators", "tempArrayColters", "tempArrayPatts", "tempAreaLETTER", "tempArrayShutter", "tempStringLetters", "tempArrayPainters", "tempArrayFileers", "tempArrayLETters", "tempArraySetters", "tempArrayLetbers", "tempAreaLetchers", "tempRAYLeters"], "resultTopFiveLetters": ["resultTopFiveFiliers", "resultTopFiveLetiers", "resultTopTwoLetators", "resultTopFiveItaters", "resultTopFiveAlators", "resultTopFiveItters", "resultTop5Leters", "resultTopFiveAlter", "resultTopTwoLetaters", "resultTopFiveItators", "resultTopFiveAlaters", "resultTop5Letters", "resultTopTwoLetters", "resultTopFiveFilter", "resultTopFourLetters", "resultTopFiveGetters", "resultTopFiveLetter", "resultTopFiveFilaters", "resultTopFourMatters", "resultTopFourMatter", "resultTopFiveGetter", "resultTopTwoLETiers", "resultTopFiveLETaters", "resultTop5Alter", "resultTopFiveFilators", "resultTop5Alators", "resultTopFiveMaters", "resultTopFiveGeters", "resultTopFiveAlters", "resultTopFiveLetators", "resultTopFiveMatters", "resultTopFiveItiers", "resultTopFiveFilters", "resultTopFourLetter", "resultTopFiveLeters", "resultTopFiveGetators", "resultTopFiveLetaters", "resultTopTwoLETaters", "resultTopFiveLETters", "resultTopFourMaters", "resultTopTwoLetiers", "resultTopFiveLETiers", "resultTopFourMataters", "resultTopFiveMataters", "resultTopTwoLETters", "resultTopFourLeters", "resultTopFiveMatter", "resultTopTwoLETators", "resultTop5Letators", "resultTopFourLetaters", "resultTopFiveAlers", "resultTop5Alers", "resultTop5Letter", "resultTopFiveLETators", "resultTop5Alters", "resultTopFiveFilers"], "tempCount": ["empCounter", "tmpCast", "tempCast", "empMax", "temCounter", "stemCounter", "temCast", "tmpCounter", "empC", "tempSize", "empCast", "tempTr", "tmpCount", "tempCounter", "totalCount", "tempLength", "tmpLength", "temCount", "temLength", "empTr", "stemLength", "temC", "tmpSize", "stemCount", "empCount", "temSize", "stemSize", "tempC", "temTr", "totalTr", "totalCounter", "tmpMax", "tempMax", "temMax", "totalC"], "tempLetters": ["tempFunators", "templateLETners", "tmpPainators", "tempMatators", "templateLETers", "tempMatners", "tempMatchers", "tempLETters", "templateLetters", "templateLETaters", "tempSetinters", "tempFunters", "temLETchers", "tempFormatters", "tmpPaininters", "tempSetators", "tempFuninters", "templateLETters", "tempLETners", "tempPainters", "tempAlators", "temLETators", "tempMatters", "tempLetaters", "tempLetators", "templateLeters", "tempPainTER", "tempPaininters", "temLetters", "tempFormaters", "templateLetners", "tmpLetters", "tempLeters", "tempFormataters", "tempLetTER", "tempAlners", "tempAlters", "tempFunTER", "tempLETaters", "tempAlchers", "tempLETers", "tempSetters", "temLETners", "tmpLetinters", "tempLETators", "tmpLetators", "tempSetTER", "tempFormatners", "tempLetchers", "tempLetners", "tmpPainters", "tempLETchers", "temLetchers", "templateLetaters", "tempAlers", "temLETters", "tempLetinters", "tmpLetTER", "tempPainators", "temLetners", "tmpPainTER", "temLetators", "tempAlaters"], "j": ["jj", "ja", "fr", "y", "J", "aj", "k", "js", "ind", "jc", "pr", "jp", "oj", "b", "at", "q", "x", "jump", "no", "ijk", " J", "job", "err", "att", "obj", "ij", "ji", "n", "jit", "Ja", "ix", "json", "jac", "uj", "bj", "it", "jl", "Job", "jo", "z", "adj", "g", "dj", "kj"], "i": ["ip", "ori", "li", "io", "y", "bi", "status", "in", "ii", "phi", "multi", "point", "asi", "xi", "id", "I", "u", "ui", "this", "ind", "mi", "iu", "oi", "print", "gi", "uri", "im", "hi", "cli", "ami", "ie", "is", "ti", "ki", "index", "ci", "pi", "ij", "chain", "ji", "a", "iq", "wi", "me", "iri", "ia", "qi", "ni", "si", "init", "ix", "di", "info", "ini", "ei", "list", "o", "ims", "it", "ish", "sim", "ir", "\u0438", "m", "fi", "ai", "zi", "ic", "ri", "source"]}}
{"id1": "19494842", "id2": "1508930", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 1, "substitutes": {"callService": ["runQuery", "callservice", "useQuery", "runService", " callservice", "callServices", "useServices", " callQuery", "callQuery", " callServices", "runServices", "runservice", "useService", "useservice"], "url": ["sb", "dl", "ul", "conn", "acl", "nl", "str", "base", "file", "l", "b", "web", "gl", "google", "uri", "oul", "r", "client", "ssl", "browser", "ls", "sl", "address", "bel", "ur", "get", "pl", "http", "service", "channel", "hl", "ll", "link", "URL", "char", "resource", "Url"], "in": ["io", "reader", "bin", "read", "din", " din", "inc", "isin", "rin", "el", "en", "ill", "inner", "b", "l", "inf", "iter", "mc", "r", "out", "is", "input", "check", "er", "In", "on", "gin", "all", "conf", "IN", "mn", "con", "it", "sum", "from", "ins", "inn", "cin", "again", "i", "ic", "ri", "oin", "and"], "inputLine": ["responseline", " inputL", "responseLINE", "helloLINE", "contextL", "InputRow", "parseLINE", " inputline", "outputL", "parseRow", "contextline", "outputLine", "helloFile", "InputLINE", "responseLine", " inputLINE", "Inputline", "helloLine", "InputLine", "contextLine", "inputL", "inputLINE", "parseFile", "inputFile", "responseRow", "inputline", "helloRow", "contextRow", "outputline", " inputFile", " inputRow", "parseLine", "outputRow", "inputRow"], "buf": ["bg", "img", "cv", "raf", "Buffer", "buffer", "bh", "hung", "inv", "bed", "buff", "nom", "Buff", "comm", "cf", "vec", "aux", "bar", "cmd", "alph", "queue", "uf", "mk", "cb", "ob", "br", "fam", "rb", "conv", "bag", "mem", "pkg", "cur", "pb", "vet", "cam", "cap", "block", "area", "tab", "nm", "mu", "msg", "bu", "gor", "db"], "answer": ["version", "reply", "say", "onse", "exit", "replace", "ver", "sn", "archive", "interpret", "print", "review", "username", "image", "poll", "continue", "result", "place", "install", "offer", "cache", "address", "remember", "accept", "command", "answered", "ve", "send", "array", "search", "option", "value", "channel", "question", "response", "sequence", "message", "ask", "report", "entry", "about", "argument", "Answer", "again", "equ", "form"]}}
{"id1": "21348951", "id2": "20019847", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubsmitted", "processAddByURLSUBmission", "processAddByURlsumit", "processAddByURLSummission", "processAddByURLSubsmission", "processAddByURLSubit", "processAddByURlsubmission", "processAddByURlsubmit", "processAddByURLSUBmitted", "processAddByURLSubmission", "processAddByURLSubmitted", "processAddByURLSummitted", "processAddByURLSummit", "processAddByURLSubsmit", "processAddByURlsubit", "processAddByURLSubsit", "processAddByURLSUBmit", "processAddByURlsummission", "processAddByURLSumit", "processAddByURLSUBit", "processAddByURlsummit", "processAddByURlsummitted", "processAddByURlsubmitted"], "url": ["dl", "location", "ul", "rl", "nl", "run", "mount", "str", "base", "id", "u", "html", "external", "el", "file", "loc", "document", "l", "web", "uri", "string", "q", "ssl", "browser", "impl", "input", "ls", "path", "item", "util", "email", "ref", "sl", "address", "mail", "name", "un", "bel", "ur", "use", "http", "ll", "force", "link", "rect", "URL", "char", "addr", "resource", "Url", "page", "key"], "invalidUrlMsg": ["invalidStrLog", "invalidStrMsg", "inInvalidUrlLog", "inInvalidStrLog", "inInvalidURLmsg", "invalidUrStr", "invalidURLMsg", "invalidurlmsg", "invalidUrlMessage", "inInvalidStrMsg", "invalidFileMessage", "invalidFileMsg", "invalidUrlLog", "invalidUrmsg", "invalidUrLog", "inInvalidUrlMessage", "invalidUrlStr", "invalidUrlmsg", "invalidFileStr", "inInvalidUrlStr", "inInvalidUrlmsg", "invalidURLmsg", "inInvalidURLMsg", "invalidFileLog", "invalidURLStr", "invalidUrMessage", "invalidurlStr", "inInvalidURLStr", "invalidUrMsg", "invalidStrStr", "invalidurlMsg", "inInvalidStrMessage", "inInvalidStrStr", "invalidStrMessage", "inInvalidUrlMsg"], "xmlSourceWriter": ["xmlSourcesReader", "xmlStringCode", "xmlsourceBuilder", "xmlSourceBuilder", "jsonStringCode", "xmlSourcesWriter", "xmlsourceWriter", " xmlSourceRW", "xmlSourceReader", "jsonSourceReader", "xmlSourceFileRW", " xmlSourceWriting", " xmlSourceWrite", "xmlStringReader", "xmlSourceWriting", " xmlSourceBuilder", "xmlSourceFileWriting", "xmlSourceFileBuilder", "jsonSourceWriter", "xmlsourceRW", "xmlsourceWrite", "jsonSourceCode", "jsonStringWriting", "jsonStringWriter", "xmlStringWriting", "xmlSourcesWriting", "xmlSourceWrite", "xmlsourceWriting", "xmlsourceReader", "xmlSourceRW", "xmlSourceCode", "jsonStringReader", "xmlStringWriter", "xmlSourcesCode", "jsonSourceWriting", " xmlSourceReader", "xmlSourceFileWriter"]}}
{"id1": "6299111", "id2": "324679", "code1": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"retrieveQ": ["RetDownloadQ", "retriveP", "retrieveURL", "retDownloadP", "retriveU", "RetrieveQ", "retDownloadU", "RetrieveU", "retriveURL", "RetrieveP", "retrievedURL", "RetDownloadP", "retDownloadURL", "retrievedU", "retrieveP", "retrievedP", "RetrieveURL", "RetDownloadURL", "retriveQ", "retDownloadQ", "RetDownloadU", "retrievedQ", "retrieveU"], "urlToRetrieve": ["urlTORetetch", "urlToRetceive", "urlTORefetch", "urlTORefrieve", "urlToReftain", "urlToretceive", "urlToRefetch", "urlToRetDownload", "urlToRetrieving", "urlToSupprieving", "urlTORefDownload", "urlToSupprieve", "urlTORetceive", "urlToRefceive", "urlToretrieve", "urlToRefrieve", "urlToRestain", "urlTORetDownload", "urlToResrieve", "urlToRefDownload", "urlToRetetch", "urlToRerieve", "urlTORefceive", "urlToretDownload", "urlToResrieving", "urlToRefrieving", "urlToReceive", "urlToReetch", "urlToRettain", "urlToSupptain", "urlToretetch", "urlTORetrieve", "urlToReDownload"], "url": ["ml", "org", "build", "ul", "conn", "acl", "nl", "mount", "loc", "l", "gl", "web", "uri", "https", "il", "r", "cmd", "ssl", "ls", "www", "open", "job", "mail", "ref", "sl", "bel", "ur", "f", "pl", "http", "hub", "hl", "ll", "URL", "char", "call", "resource", "Url"], "uc": ["c", "cl", "um", "sc", "oc", "eu", "ac", "conn", "ub", "u", "ui", "ud", "bc", "cus", "tc", "uma", "mc", "cc", "nic", "usc", "uf", "uci", "uca", "ux", "ci", "cu", "rc", "uu", "userc", "UC", "ucc", "ec", "unc", "soc", "auc", "cm", "fc", "anc", "lu", "cr", "us", "nc", "ou", "lc"], "is": ["ists", "iris", "es", "bs", "os", "sis", "isin", "isc", "bis", "isi", "isf", "im", "ics", "sys", "iso", "lis", "nis", "its", "IS", "si", "ris", "ais", "isa", "mis", "iss", "it", "ios", "isl", "ir", "ins", "ates", "us", "i", "Is", "ic", "ri"], "in": ["io", "reader", "bin", "read", "din", " din", "re", "inc", "isin", "rin", "ind", "en", "ill", "inner", "ln", "inf", "inside", "iter", "il", "mc", "out", "input", "In", "un", "on", "win", "ini", "IN", "mn", "con", "it", "from", "ins", "inn", "cin", "ai", "i", "ic", "ri", "oin", "by", "and"], "output": ["written", "text", "object", "content", "four", "buffer", "write", "detail", "bool", "data", "answer", "column", "OU", "csv", "batch", "collection", "icon", "print", "left", "region", "next", "continue", "web", "result", "body", "console", "update", "string", "render", "out", "hidden", "client", "Output", "put", "input", "application", "name", "format", "position", "export", "cut", "pretty", "all", "network", "list", "o", "net", "control", "response", "message", "you", "display", "null", "ilo", "second", "quiet", "ou", "current", "outer", "other"], "str": ["text", "t", "fr", "ctr", "v", "gr", "dr", "Str", "arr", "part", "data", "div", "pr", "print", "inner", "b", "next", "pt", "comm", "hex", "iter", "string", "del", "r", "out", "piece", "input", "tr", "res", "check", "br", "err", "obj", "name", "dat", "n", "req", "exec", "expr", "set", "list", "STR", "ch", "vol", "sp", "st", "j", "char", "cat", "m", "msg", "g", "s", "cont", "source", "key", "form", "txt"], "first": ["prev", "pres", "th", "same", "top", "current", "each", "lower", "sum", "full", "quick", "now", "next", "sort", "before", "soft", "major", "cond", "open", "third", "success", "primary", "fourth", "irst", "start", "all", "natural", "required", "make", "only", "valid", "st", "must", "latest", "fast", "dirty", "First", "true", "master", "real", "second", "last", "empty", "bool", "other"]}}
{"id1": "2461169", "id2": "12085127", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "21642215", "id2": "9647576", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["addID", "addNames", "setIDS", " addIDS", "setNames", " addID", "processNames", "processIDs", "setIDs", "addIDS", " addNames", "setID", "processIDS", "processID"], "row": ["ack", "buffer", "week", "instance", "ry", "col", "user", "rown", "raw", "batch", "post", "result", "cell", "ro", "r", "out", "rows", "ows", "item", "board", "ow", "tr", "job", "pair", "channel", "list", "record", "rank", "block", "group", "report", "entry", "roll", "star", "Row", "table", "node", "box", "error", "skip"], "name": ["version", "text", "create", "named", "type", "Name", "file", "ame", "image", "prefix", "string", "path", "item", "title", "address", "format", "a", "n", "password", "NAME", "description", "search", "value", "template", "query", "question", "label", "filename", "word", "source", "key"], "in": ["scan", "t", "reader", "bin", "din", "copy", "conn", "re", "inc", "isin", "rin", "log", "file", "el", "en", "l", "inner", "ln", "serv", "inf", "ain", "il", "at", "vin", "mc", "update", "out", "r", "ssl", "is", "input", "pin", "check", "nin", "al", " IN", "up", "er", "In", "n", "on", "get", "gin", "init", "win", "conf", "IN", "ini", "con", "local", "it", "sql", "ins", "ex", "inn", "m", "cin", "again", "db", "xml", "i", "s", "ic", "source", "form"], "urlName": ["logKey", "lKey", "UrlNAME", "urlKey", "lPath", "implPath", "implname", "implName", "urlNAME", " urlname", "lNAME", "lNames", "UrlName", "logName", "urlNames", "urlname", "urlPath", "logNAME", "implNames", "lname", "UrlNames", "lName", "Urlname", " urlNames", "implNAME", " urlPath", " urlNAME", "logname", "UrlKey"], "url": ["t", "cl", "reader", "ul", "rl", "nl", "mount", "str", "base", "el", "file", " URL", "l", "b", "gl", "loader", "web", "result", "il", "uri", "r", "client", "ssl", "browser", "ls", "open", "ref", "sl", "ur", "http", "channel", "con", "ll", "link", "rel", "ret", "URL", "char", "resource", "Url"], "inputLine": ["inputPage", "listEntry", "statusline", "formLINE", " inputline", "tableLink", "helloEntry", " inputPage", "inputPort", "firstBlock", "listLine", "dataNet", "dataBlock", "inputRecord", "keyL", "formLine", "contextLINE", "viewLINE", "submitLine", "InputLine", "latline", "patternline", " inputBlock", "operationNet", "InputFile", "inputFrame", "tempLINE", "tempLine", "contextRow", " inputFile", "statusLINE", "intLin", " inputFrame", "inputLin", "helloLINE", "singleBlock", "submitBlock", "dataLINE", "cacheLine", "viewLine", "helloPort", "inputNet", "tableLINE", "statusLine", "InputLINE", "singleLINE", "intLINE", " inputLINE", "commandBlock", "Inputline", "dataLine", " InputLine", "formFrame", "dataline", "contextLine", "cacheLINE", "sourceLine", "viewRow", "sourceLINE", "sourceNode", "keyLine", "templine", "singleDe", "inline", "cacheNode", "operationLine", "InputRow", "keyline", "dataLink", "listPort", "inputEntry", " inputRecord", " Inputline", " InputLin", "sourcePage", "patternLine", "InputL", "inputL", "latRecord", "tablePort", "inLINE", "inputFile", "inputNode", " inputNode", " inputRow", "singleLine", " InputLINE", " inputPort", "inputRow", "inputDe", "dataFrame", "patternLINE", "commandLINE", "listLINE", "inRecord", " inputDe", "InputBlock", " inputEntry", "latLine", "intLine", "statusFile", "formBlock", "commandLine", "keyLINE", "latLINE", "operationLINE", "dataPort", "inL", "cachePage", "intBlock", "tableLine", " inputLink", "inputLink", "firstLINE", "helloLine", "inputBlock", "inputLINE", " inputNet", "inputline", "inLine", "dataFile", " inputLin", "intline", "submitDe", "submitLINE", "patternRow", "firstLine"], "score": ["level", "scan", "scroll", "scale", "count", " Score", "average", "status", "sc", "scoring", "core", "length", "test", "draw", "result", " scores", "price", "distance", "grade", "index", "check", "err", "success", "goal", "weight", "rate", "confidence", "Score", "match", "depth", "value", "search", "rank", "message", "strength", "sum", "display", "report", "style", "error", "source", "loss", "set"], "metaboliteID": ["metabolitationId", "metaboliceInfo", "metabolteId", "metaboliciteid", "metaboliciteID", "metmbolitationId", "metabolisticIN", "metabolicitationID", "metaboliceId", "metaboliterName", "metaboliteId", "metabolisticId", "metmboliteId", "metabolitateid", "metabolteHandle", "metmboliteID", "metmboliteIN", "metabolitionName", "metmbolitationID", "metabolicITEId", "metaboliterID", "metabolitableUID", "metabolitationid", "metabiliteId", "metabolitionid", "metabolteUID", "metabolitationName", "metabiliteid", "metabolitionID", "metabiliteUID", "metabolitableId", "metaboliciteId", "metabiliteHandle", "metabolisticID", "metaboliciteType", "metaboliceid", "metabiliterName", "metabiliteID", "metabolicitationid", "metabiliterHandle", "metaboliteInfo", "metabolitableID", "metaboliterIN", "metabolicITEID", "metabolitateId", "metaboliteType", "metaboliterType", "metaboliteName", "metabolicITEName", "metaboliteUID", "metabolitationInfo", "metabiliterId", "metabolicitationId", "metabolteID", "metabiliterUID", "metabolicitationInfo", "metaboliciteName", "metaboliteHandle", "metabolitateID", "metaboliteIN", "metabolitateInfo", "metaboliterHandle", "metabolITEID", "metaboliterid", "metaboliciteInfo", "metabolITEType", "metabolitationIN", "metabiliterid", "metaboliteid", "metaboliterId", "metabolitesid", "metabiliteName", "metabolitesName", "metabolITEName", "metaboliceID", "metmbolitationIN", "metabolitationID", "metabolitationType", "metabolitableHandle", "metabolitesID", "metabolicITEType", "metabolITEId", "metaboliterUID", "metabiliterID"], "dataScore": ["dataTest", " dataStyle", "dataSc", " dataRank", "parentScore", "divScore", "errorWeight", "DATARank", "deviceTransfer", "ataSc", "relationWeight", "relationscore", "blockSpeed", "deviceSize", "arrayStyle", "divRank", "dataWeight", "DataRank", "deviceScore", "errorscore", " dataWeight", "deviceSc", "relationScore", "blockSc", "DATATest", "relationSize", "tdSc", " dataSc", "blockStyle", "arrayAge", " datascore", "parentTest", "dataRank", "arrayScore", " dataTest", "divSc", "DataScore", "DATASc", "DATAScore", "DataSize", "dataAge", "errorSize", "errorScore", "arraySpeed", "DataSc", "tdScore", "tdAge", " dataSpeed", "parentSc", "arraySc", "parentRank", "dataStyle", "divSize", " dataTransfer", "dataSpeed", " dataAge", "ataTransfer", "ataSize", "dataTransfer", "blockScore", "datascore", "ataScore", "dataSize", " dataSize"], "data": ["content", "text", "details", "results", "buffer", "td", "DATA", "extra", "html", "supported", "base", "ata", "space", "raw", "batch", "available", "series", "image", "draw", "hex", "string", "missing", "none", "hash", "video", "zero", "cache", "step", "rew", "chain", "multiple", "map", "dat", "params", "words", "array", "description", "all", "info", "json", "value", "size", "users", "lines", "valid", "values", "bytes", "table", "mu", "keys", "ns", "window", "set"], "molecularWeight": ["molellularWeight", "moleculeData", "mlecularWeight", "mlecularData", "mleularweight", "molecularScore", "molellularweight", "mleularScore", "moleularweight", "moleculeweight", "molecularData", "mleularWeight", "moleularScore", "moleudoScore", "moleularFont", "molellularFont", "moleularData", "mlecularFont", "moleculeWeight", "moleuralWater", "mleularFont", "moleudoWater", "mleularWater", "molecularFont", "molecularWater", "moleuralWeight", "molellularData", "moleuralScore", "moleularWater", "moleularWeight", "moleudoWeight", "molecularweight", "mlecularweight", "mlecularScore", "mlecularWater", "mleularData", "moleculeFont"]}}
{"id1": "5399593", "id2": "11005804", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypt", "ecode", "decrypt", "decrypted", "encrypted", "decode", "encode", "eccode", "enrypted", "ecrypt", "ecrypted", "enccode", "enode", "deccode"], "plaintext": [" plainpassword", "plaincontext", " Plainth", "preword", " plainText", "plainText", "plaininput", "ainth", " plaincontext", "aininput", "pretext", "preText", "aintext", "maintext", "plainth", " Plaintext", "precontext", " plainword", "plainword", " Plaininput", " plainth", " Plainpassword", "mainword", "plainpassword", "mainText", "ainpassword", "maincontext", " plaininput"], "UnsupportedEncodingException": ["UnsupportedEncoderException", "UnsupportedEncryptionError", "UnsupportedEncodingError", "UnsupportedCompoderException", "UnsupportedEncoderError", "UnsupportedEncryptionException", "UnsupportedCompoderError", "UnsupportedEncodedException", "UnsupportedCompodingException", "UnsupportedEncodingEx", "UnsupportedEncodedError", "UnsupportedCompoderEx", "UnsupportedEncoderEx", "UnsupportedCompodingError", "UnsupportedEncryptionEx", "UnsupportedEncodedEx", "UnsupportedCompodingEx"], "md": ["pm", " Md", "bd", "MD", " cmd", " mo", "det", "cd", "med", " mm", "dr", "sd", "sm", "mand", "mt", "ind", "mod", "add", "dd", "hd", "mc", "sha", "del", "cmd", " dd", " mc", "mk", "nd", "dm", "mb", "df", "mo", "pd", "nt", " MD", "grad", "exec", "mg", "mp", "d", "der", "ld", "mn", "od", " ma", "def", "gm", "m", "red", "ad", "mm", " m", "ms"], "raw": ["read", "serial", "rendered", "strip", "data", "des", "core", "full", "available", " RAW", "draw", "hex", "bare", "hook", "was", "out", "input", "RAW", " Raw", "aw", "pack", "cooked", "known", "n", "orig", "mem", "buf", "clear", "custom", "load", "all", "json", "row", "unsigned", "message", "valid", "bytes", "empty", "sh", "clean", "Raw"], "hash": ["ashed", "proof", "bh", "html", "id", "unknown", "total", "ash", "ssh", "Hash", "has", "component", "dump", "hex", "result", "sha", "zh", "hidden", "mask", "tr", "hat", "check", "mac", "cloth", "ASH", "name", "password", "shadow", "hed", "height", "search", "tag", "message", "sum", "ashes", "sh", "code", "h", "key"]}}
{"id1": "19549489", "id2": "18693224", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "save", "create", "read", "write", "replace", "Cop", " mirror", "upload", " duplicate", "transfer", "csv", "download", " cp", "add", "clone", "cp", " Copy", "slice", "map", "export", "paste", "move", "load", "delete", "rm", "cat", "Copy"], "sourceFile": ["SourceFilename", "inputPage", " sourceFilename", "inputfile", "ourcefile", "ourcePage", "ourceFile", "ourceLine", " sourcefile", "sourcePage", "inputLine", "sourcefile", " sourceLine", "sourceLine", "SourceFile", "inputFile", " sourcePage", "SourcePage", "ourceFilename", "sourceFilename", "SourceLine", "Sourcefile"], "destinationFile": ["estinatedPlace", "destinoFilename", "declinatorPlace", "destinoFile", "destinationsfile", "destinatorPlace", "destinofile", "declinationPath", "destinatePath", "declinationFilename", "declinationFile", "estinationFilename", "destinoPlace", "destinationPath", "estinationFile", "destinationFilename", "destinationfile", "estinatedFile", "estinatedfile", "destinatorFilename", "destrativePlace", "destinatedPlace", "destinationsPlace", "destrativePath", "destinationsFile", "estinationPlace", "destinateFile", "destinationsFilename", "destrativeFile", "destinatePlace", "destinatedfile", "estinatedFilename", "declinationPlace", "destinationPlace", "destinatedFilename", "destinatorPath", "destinatedFile", "destinateFilename", "declinatorFile", "declinatorFilename", "destrativeFilename", "destinatorFile", "declinatorPath", "estinationfile"], "sourceFileChannel": ["sourceByteEntry", "srcFileEntry", "sourceStreamApplication", "srcFilechannel", "sourceFileEntry", "sourceLineChannel", "sourceEntryConnection", "sourceEntryChan", "sourceBlockConnection", "srcBlockEntry", "sourceBaseApplication", "sourceFileConnection", "sourceBaseHandler", "sourceStreamChan", "ourceFileChan", "sourceLineConnection", "sourceLineChan", "srcBlockConnection", "sourceStreamchannel", "srcBlockchannel", "sourceStreamChuck", "srcBlockChannel", "sourceByteConnection", " sourceFileApplication", "sourceLineEntry", " sourceFileChuck", "sourceByteChannel", "sourceFileApplication", "ourceFileChannel", "sourceEntrychannel", "sourceFileChan", "sourceFileHandler", "ourceEntrychannel", "ourceEntryChan", "sourceBytechannel", " sourceFileHandler", "sourceFileChuck", "ourceFilechannel", "sourceLinechannel", "sourceBlockChannel", "sourceBaseChannel", "ourceFileConnection", "sourceEntryChannel", "sourceBlockEntry", "ourceEntryConnection", "srcFileConnection", "sourceFilechannel", "sourceBlockchannel", "srcFileChannel", "sourceStreamChannel", "sourceStreamHandler", "sourceStreamConnection", "sourceBaseChuck", "ourceEntryChannel"], "destinationFileChannel": ["destinationfileManager", "destmentResourceChannel", "destmentPageChannel", "destinationFilesConnection", "destinationfileEntry", "destinatorFilesChannel", "destinationChannelEntry", "destinationFileManager", "destmentFilechannel", "destinationResourcechannel", "destinationFilesChannel", "destinationChannelCh", "destinationPageChannel", "destinatorFileCh", "destinationResourceManager", "destinationPageEntry", "destmentPageContext", "destinationfileConnection", "destmentPageEntry", "destinationResourceChan", "destmentResourcechannel", "destmentFileChannel", "destinationfilechannel", "destinationFileConnection", "destinationDirectoryChannel", "destinationDirectorychannel", "destinationfileCh", "destinatorFilesConnection", "destinationfileChannel", "destmentResourceManager", "destinationChannelChannel", "destinationPageContext", "destmentPageChan", "destinationFileContext", "destinationFilechannel", "destinationPageChan", "destinationChannelChan", "destinationFileEntry", "destinationDirectoryManager", "destinationChannelConnection", "destinationChannelContext", "destinationfileChan", "destinationfileContext", "destinationFileChan", "destinatorFilesCh", "destinationResourceChannel", "destmentFileChan", "destinationFilesChan", "destinationFileCh", "destmentResourceChan", "destinationFilesCh", "destinatorFileConnection", "destmentFileContext", "destinatorFileChannel", "destmentFileEntry", "destinatorFilesChan", "destmentFileManager", "destinatorFileChan", "destinationDirectoryChan"]}}
{"id1": "5274228", "id2": "6009527", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"put": ["head", "submit", "request", "GET", "replace", "write", "patch", "run", "operation", "upload", "post", "uri", "update", "POST", "exec", "get", "send", "PUT", "execute", "http", "delete", "response", "Put", "apply", "output", "resource", "set", "pull"], "resourceID": ["resourcesIL", "requestName", "resourcesId", "requestID", "resId", "resourceIL", "clientID", "clientId", "ResourceId", "ResourceName", " resourceIL", " resourceId", "resourcesTracker", "resourceTracker", "requestId", "resID", "resourceId", "resourcesID", "resIL", "ResourceID", "resTracker", "resourceName", " resourceTracker", "clientName"], "headersMap": ["ilersMap", "namesSet", "namesList", " headersSet", "headsAdd", "namesMap", "headersSet", "namesAdd", "ilersWith", "namesWith", "headersWith", "headsList", " headersWith", " headersAdd", "headsSet", "headsMap", "headersAdd", "ilersList"], "httpClient": [" httpclient", "httPut", "httpStore", " httpBuilder", "httpBuilder", "httpsClient", "httpsBuilder", "httClient", "ttpBuilder", "httpNet", "HTTPclient", "HTTPFactory", "HttpClient", "hclient", " httpNet", "hNet", "hPut", "httpsCall", "httpFactory", "httNet", "hClient", " httpStore", "ttpclient", "ttpCall", "HTTPStore", "HTTPClient", "httpclient", " httpCall", "httpsclient", "HttpFactory", "Httpclient", "httpCall", "ttpClient", "HttpStore", "httclient", " httpFactory"], "httpPut": ["hPUT", "viewGet", "buildPUT", "consolePUT", "httpGet", "ttpGet", "hGet", "ttpPUT", "buildput", " httpGet", "httpsClient", "servicePUT", "htmlPutting", "htmlPut", "hDelete", "httpWrite", "buildPutting", "serviceClient", "HttpClient", "HttpPut", "buildPut", "consolePut", "viewWrite", "htmlput", "HttpPUT", "HTTPGet", "HttpGet", "httpsput", "httpPutting", "hPut", "servicePut", "HttpWrite", "HTTPPut", " httpDelete", "ttpCall", "httpPUT", "httpput", "htmlClient", "HTTPClient", "consolePutting", "viewPUT", "ttpPut", " httpCall", "HttpDelete", "HttpCall", "ttpWrite", "consoleput", "htmlPUT", "httpDelete", "httpCall", "httpsPUT", " httpPUT", "viewPut", "httpsPut", "HTTPPUT", "serviceput"], "headersList": ["ersL", "namesList", "headsL", "ersMap", "namesMap", "headersLIST", "namesArray", "partsL", "headsArray", "headsList", "partsMap", "ersList", "headsMap", "headsLIST", "partsLIST", "headersL", "partsList", "ersLIST"], "iterator": ["ator", "immigrant", "li", "former", "consider", "reader", "river", "eni", "instance", "pler", "Iterator", "stream", "gener", "encer", "starter", "liner", "collection", "series", "inner", "next", "integer", "trace", "loader", "timer", "iter", "creator", "ner", "rows", "player", "menu", "operator", "pointer", "driver", "rounder", "chain", "outer", "pee", "later", "loop", "ste", "wrapper", "processor", "finder", "list", "size", "sample", "sequence", "race", "runner", "context", "values", "iner", "vector", "walker", "icer", "issues", "writer", "ter", "set"], "headersArray": ["usersList", "ersArea", " headersarray", "ersMap", "headersArea", "headersHash", "usersArray", "ctorsArea", " headersArea", "ersarray", "ctorsArray", "headsHash", "ersArray", "usersHash", "headsArray", " headersHash", "headsList", "usersMap", "fieldsarray", "headersarray", "fieldsArray", "fieldsMap", "headsMap", "ctorsMap"], "fields": ["qs", "states", "gs", "codes", "FIELD", "tags", "links", "owners", "services", "relations", "errors", "rows", "pages", "sections", "objects", "comments", "dates", "names", "properties", "fs", "lines", "field", "values", "obs", "files", "keys"], "occiHeaders": ["occiMetlers", "occiHeadlers", "occiMeters", "occiBuffels", "occiMetERS", "occiMetels", "occiHandERS", "occiBuffERS", "occiHandels", "occciMetERS", "occiHeadERS", "occciHeaders", "occiBuffers", "occciMetels", "occiHeadels", "occciHeadels", "occciHeadlers", "occciMetlers", "occiHandlers", "occciMeters", "occiHanders", "occciHeadERS", "occiBufflers"], "H": ["T", "B", "R", "J", "HS", "O", "W", "Header", "HB", "CH", "L", "HEAD", "I", "G", "TH", "PH", "Z", "OH", "Hash", "K", "Counter", "HI", "Y", "HH", "A", "D", "HER", "P", "HT", "Handle", "GH", "HA", "Head", "V", "N", "M", "HC", "He", "High", "S", " HH", "MH", "Handler", "HL", "U", "X", "F", "C", "HE"], "header": ["head", "th", "peer", "request", "buffer", "dr", "heading", "Header", "status", "part", "data", "user", "column", "attribute", "layer", "document", "hd", "hidden", "hash", "line", "item", "title", "name", "metadata", "er", "format", "variable", "handle", "wrapper", "token", "cookie", "frame", "info", "first", "value", "channel", "event", "response", "block", "field", "entry", "argument", "holder", "handler", "code", "filter", "port", "table", "rule", "key"], "statusLine": ["StatusCode", "versionLine", "Statusline", "statusline", "statCode", "StatusString", "statusSet", " statusString", "StatusSet", " statusSet", " statusline", "statString", "statSet", "statusString", "StatusLine", "versionCode", "versionline", "statLine", "versionString"], "httpResponse": ["httpResp", "ttpResponse", "httpsAnswer", "httpsPage", "httpresponse", "hoverResp", "webResponse", "httpFour", "phpResponse", "viewResponse", "viewAnswer", " httpFour", "phpFour", "procAnswer", "httpsresponse", "httpsClient", "httpStatus", "httpsBody", "Httpresponse", "HTTPStatus", "HttpClient", "httpRes", " httpAnswer", "adminResponse", "webFour", "HTTPPage", "adminresponse", "httpsStatus", "httpsResponse", "procresponse", "HttpResponse", "webRes", " httpStatus", "httpPage", "procResponse", "webAnswer", "hoverClient", "phpRes", " httpresponse", " httpRes", "httpBody", " httpResp", "HttpResp", "httpAnswer", "adminAnswer", "ttpBody", " httpPage", "viewresponse", "phpAnswer", "procBody", "hoverResponse", "hoverresponse", "HTTPClient", "HTTPResponse", "viewBody", "ttpClient", "ttpPage", " httpBody", "adminPage", "ttpStatus"], "statusCode": ["scoreCount", "StatusCode", " statusChain", "statusCount", "statusChain", "statusCo", "StatusPoint", " StatusCo", " StatusChain", " statusClass", "statCode", "statPoint", "StatusString", "statusClass", " statusString", " statusPoint", " statusCount", "StatusClass", "statString", "scoreChain", "statCount", "statClass", "statusString", "statusPoint", "scoreCo", " statusCo", "StatusCount", "StatusLine", " StatusCode", "statLine", "scoreCode", " StatusCount"]}}
{"id1": "14865947", "id2": "23620712", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" command", "Command", " Run", " evaluate", "Exec", "run", "invoke", " executable", " executions", " resume", " Exec", " interpret", " execution", " manage", " Execution", "Action", "command", "exec", " parse", " dispatch", " executed", " operate", " executing", " executes", "process", " query", " proceed", " eval"], "event": [" command", "t", "ae", "ev", "te", "se", "ce", "Event", " Event", "Ev", "xe", " invocation", " frame", "de", " events", "command", " EVENT", "pe", "exc", "frame", "w", "context", " environment", "ex", "ee", "E", "EE", "ed"], "shell": ["sb", "scroll", "history", "ja", "widget", "fr", "buffer", "pty", "detail", "range", "nl", "quit", "js", "tree", "html", "scope", "help", "stack", "base", "bot", "ssh", "pool", "l", "b", "cell", "body", "session", "console", "Shell", "tools", "sys", "cli", "grid", "line", "theme", "kernel", "screen", "windows", "handle", "root", "layout", "search", "template", "query", "hl", "lock", "message", "sql", "tab", "hell", "microsoft", "tool", "round", "sh", "h", "style", "sol", "window", "system"], "view": ["version", "VIEW", "widget", "cv", "v", "buffer", "View", "views", "tree", "html", "ui", "eye", "document", "image", "review", "vp", "web", "browser", "iew", "vm", "screen", "layout", "ve", "list", "template", "query", "row", "w", "tv", "block", "display", "report", "show", "see", "ou", "window"], "rootFolder": ["rootLibrary", "parentDir", " rootEntry", "bottomFolder", "parentEntry", "coverLibrary", "bottomDisk", "RootDir", "rootDirectory", "coverDirectory", "rootDisk", " rootDirectory", "rootArea", " rootDir", "RootDirectory", " rootCategory", "RootEntry", "rootCategory", " rootDisk", "rootEntry", "RootFolder", "parentDirectory", "bottomLibrary", "rootDir", " rootLibrary", "coverFolder", "parentArea", " rootArea", "parentFolder", "coverDisk", "RootArea", "bottomDirectory", "RootCategory", "parentCategory"], "dialog": ["dialj", "choDialog", "closer", "dializ", "Dialogs", "Dializ", "logDialog", " Dialj", "dialDialog", "selectDialog", "selectoser", " Dialoc", "callog", "callDialog", "clDialog", "selectig", "dialoser", " Dializ", "dliz", "selectog", "logoser", "logog", "callogs", "Dialoc", "dlog", "logig", "callOG", "clog", "choogs", "dialOG", "Dialj", "Dialog", "dialogs", "dialig", "clig", " Dialog", "dlj", "choog", "DialOG", "DialDialog", "dloc", "choOG", "dialoc"], "password": ["encrypted", "request", "buffer", "padding", "secret", "wd", "PASS", "data", "key", "user", "comment", "attribute", "raw", "username", "phrase", "prefix", "expression", "language", "picture", "sword", "string", "pattern", "definition", "hash", "path", "device", "database", "address", "login", "command", "shadow", "pass", "clear", "p", "paste", "description", "words", "hello", "directory", "query", "response", "message", "entry", "reset", "table", "word", "source", "Password"], "md5": ["mb2", "md6", " md512", "mm6", " md64", "MD64", "ma2", "MD7", "mm5", "MD512", "mt5", "ma64", "md512", "mt4", "md64", "mt2", "MD3", "mb512", "m4", "md3", "mt3", " md6", "md7", "m5", "mm7", "mb4", "m3", " md4", " md2", "mb5", "mm2", "ma7", " md7", "MD4", "MD2", "m2", "MD5", "ma5", "MD6", "md2", "md4"], "md": ["pm", " Md", "bd", "MD", "ct", "dh", "pdf", "det", "cd", "dr", "sd", "sm", "mt", "ind", "mod", "pt", "dd", "hd", "mc", "dig", "cmd", " dd", "df", "mk", "mb", "nd", "dm", "hash", "mac", "de", "magic", "pd", "nt", "metadata", "d", "ld", "rm", "mn", "od", "m", "red", "msg", "mm", "mg", "ms"]}}
{"id1": "17724879", "id2": "5951961", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getDigest": ["getDigse", "getDigEST", "getMDest", " getMDested", "getMDEST", " getDigested", "getHashest", "getHashEST", "getdigEST", " getDigse", "getHashse", "getdigested", " getMDse", " getDigEST", "getMDested", "getDigested", "getdigse", "getMDse", " getMDEST", "getdigest", " getMDest", "getHashested"], "attribute": ["object", "request", "type", "member", "each", "operation", "data", "space", "document", "relation", "add", "expression", "at", "ident", "missing", "definition", "operator", "input", "item", "reference", "ribute", "Attribute", "application", "att", "policy", "address", "al", "name", "metadata", "variable", "a", "position", "command", "password", "communication", "description", "property", "pair", "qualified", "element", "character", "value", "directory", "option", "event", "message", "subject", "report", "entry", "argument", "information", "article", "associated", "attr", "management", "word", "and"], "digestAlgorithm": ["digestALgorithm", "digestsalgo", "digestPalgo", "digestAlgorith", "digestalgebra", "digestSchegebra", "digestsAlgorithm", "digestsalgebra", "digesterAlgorithm", "digestALgorith", "digestAlgebra", "digesteralgebra", "digesteralgo", "digestSchegorithm", "digesteralgorithm", "digestALgebra", "digestPalgorith", "digesteralgorith", "digestALgo", "digestalgorithm", "digestsalgorithm", "digestalgorith", "digestAlgo", "digesterAlgebra", "digesterAlgorith", "digestPalgorithm", "digestsAlgo", "digestalgo", "digestSchego", "digestsAlgebra", "digesterAlgo", "digestPalgebra"], "digest": ["digests", "digse", "digitude", " digEST", "mdest", "Digests", "hashest", "designests", " digse", "digtest", "mditude", "designest", "mdse", "Digtest", "equend", " digested", " digests", "hashEST", "diagnitude", "diagnest", "digEST", "digested", "designist", "DigEST", "hashend", "Digist", "digend", "equEST", "diagnse", "diagnested", "equest", "designEST", " digtest", " digist", "Digest", "equested", " digitude", "digist", "mdtest", "hashested", "Digested", "Digend", "mdested", "Digse"], "md": ["pm", "bd", "MD", "ct", "managed", "dh", "pdf", "det", "cd", "rpm", "wd", "dr", "sd", "sm", "js", "ud", "mt", "ind", "mod", "esm", "pt", "dd", "hd", "mc", "cmd", "ds", "df", "mk", "mb", "nd", "dm", "amd", "mac", "cond", "pd", "mind", "nt", "metadata", "grad", "fd", "d", "ma", "der", "di", "ld", "rm", "strong", "mn", "met", "m", "red", "mm", "good", "mg", "ms"]}}
{"id1": "7872659", "id2": "9846843", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoindexTable", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndVideoindexfile"], "completePath": ["CompleteLocation", "completePod", "totalPath", " completesDirectory", "COMPLEPath", "pletePath", "pleteScript", " completeDirectory", "completeDirectory", "totalRoot", "CompleteLog", "totalPod", "fullPod", "fullRoot", "CompleteDir", "completeScript", " completeDir", "pletionProject", "completeLog", "pleteLog", "CompleteDirectory", "COMPLEScript", "pletionNow", "CompleteNow", "pletionDir", "fullPath", "completeProject", "CompletePath", "pleteRoot", "pleteNow", "totalLocation", " completesDir", "pletionPath", "fullLocation", "pleteLocation", " completesPath", " completesLocation", "completeDir", "CompleteProject", "COMPLEDir", "completeRoot", "completeNow", "CompleteScript", "COMPLELog", "pletePod", "pleteProject", "completeLocation", " completeLocation", "pleteDir"], "masterFile": ["completefile", "managerFile", "MasterPath", "currentFile", " masterfile", "currentPath", "masterName", "masterfile", "managerfile", "MasterFilename", "masterPath", "masterFilename", "completeFile", "completeName", "Masterfile", "MasterName", " masterFilename", "currentName", "MasterFile", "currentfile", " masterPath", "managerFilename", "managerPath"], "CustRatingFileName": ["CustRankFileName", "CustRankFileInfo", "CustRatingfileType", "CustRatingFilenameType", "CustRankFilesType", "CustRatingFilesType", "CustRatedFileType", "CustRatingFieldName", "CustRatingTableType", "CustRatedfileName", "CustRatingFieldType", "CustRatingFileSet", "CustRatingFilesname", "CustRankFilesName", "CustRatingFieldInfo", "CustRatingFieldname", "CustRatedfileType", "CustRatingFileType", "CustRatingTableSet", "CustRatingFilesInfo", "CustRatedFileNames", "CustRatingTableNames", "CustRatingfileNames", "CustRatingFileInfo", "CustRatedFileName", "CustRatingTablename", "CustRatingFilenameName", "CustRatingFilename", "CustRatingTableName", "CustRatedfileNames", "CustRankFilename", "CustRatingFileNames", "CustRatingTableInfo", "CustRatingfileName", "CustRatingFilenameSet", "CustRatingfileSet", "CustRankFilesInfo", "CustRatingFilenameNames", "CustRatedFileSet", "CustRankFilesname", "CustRatedfileSet", "CustRatingFilesName", "CustRankFileType"], "MovieIndexFileName": ["MovieindexfileType", "MovieindexFileName", "MovieIndexFILEName", "MovieindexFileKey", "MovieIndexfileName", "MovieIndexFieldType", "MovieindexFileNumber", "MovieIndexfileNames", "MovieindexFileNames", "MovieIndexTableType", "MovieIndexFileNames", "MovieIndexfileType", "MovieindexFileType", "MovieIndexFILENumber", "MovieIndexFILENames", "MovieIndexFileKey", "MovieIndexFieldNames", "MovieIndexTableKey", "MovieIndexFieldName", "MovieIndexFILEType", "MovieindexfileKey", "MovieIndexfileKey", "MovieIndexTableNames", "MovieindexfileName", "MovieIndexFieldKey", "MovieIndexfileNumber", "MovieindexfileNames", "MovieIndexTableName", "MovieIndexFileNumber", "MovieindexfileNumber", "MovieIndexFileType"], "inFile": ["localfile", " infile", "outF", " inF", "outFile", "INC", "infile", "localC", " inFILE", "INF", "INFILE", "INfile", "localFile", "outfile", "inFILE", "localFILE", "outC", "INFile", "inF"], "inC": [" inL", " outC", "outF", " inF", "inCL", "outFile", "iCI", " inR", " outF", "intCS", "intR", "inputG", "intCI", " inCI", "outG", "inG", "inL", "iC", " outCL", "iCS", " inG", "inR", " inCS", "intC", "inputC", "inCI", "inputF", "outCL", "inputFile", "outC", " outL", "outL", "iR", " inCL", "inCS", "inF"], "outFile1": ["outPage6", " outfile0", "outputFile1", "outPage2", "outPageOne", "outputFile9", "outfile6", "outChannelOnce", "outputFileOne", "outputPageOne", " outfile6", "outputPage1", " outfile1", "outChannelOne", "outChannel1", "outPage9", "outFile9", "outFILE0", "outFileOnce", "outFILE6", "outputPage9", "outPage0", "outfile0", "outFILE1", "outfile1", "outFileOne", "outfile2", "outputPageOnce", " outfile2", "outFILE2", "outputFileOnce", " outFile6", "outChannel9", "outPageOnce", "outFile6", " outFile0", "outPage1", "outFile0"], "outC1": ["outR1", "outP2", "outc2", "outCB3", "outP3", "inC2", "outPOne", "inFile2", "outC3", "outCOne", "outP1", "outFile3", "inFile1", "outR3", "inC3", "outCB1", "outROne", "outCB2", "inFile3", "outFileOne", "inCOne", "outc3", "inC1", "outCB0", "outc1", "outc0", "outR2", "outC0", "inC0", "inFileOne"], "outFile2": ["exChannel0", "outChannel0", "outfile02", "outTable2", " outFileTwo", "outChannel3", "outTableTwo", "exChannel1", "outChannel1", "exChannel2", "outfileTwo", "outFile3", "outF2", " outFile3", "outF0", "outTable3", "outTable02", "outF1", " outFile02", "outfile0", "outFile02", "outfile1", "exFile1", "outFileTwo", "outfile3", "outfile2", "exFile2", "exFile0", "exFile3", "exChannel3", "outChannel2", "outF3", "outFile0"], "outC2": ["OutR1", "outC4", "outR1", "outM22", "outE1", "outS3", "outB2", "outE4", "outM2", "outSTwo", "allC22", "OutC2", "outC3", "OutC1", "OutR3", "outCTwo", "outR3", "allCTwo", "allB2", "allB3", "outR4", "outE2", "outC22", "outS22", "outBTwo", "outS2", "outB3", "allBTwo", "OutR2", "allB22", "outM3", "outMTwo", "allC3", "outB22", "allC2", "outR2", "OutC4", "outE3", "OutC3", "OutR4"], "fileSize": [" fileSIZE", "baseSize", " fileLength", " fileName", "fileSIZE", "issueName", "byteName", "FileSize", "FileLength", " fileCount", "baseSIZE", "FileName", "fileName", "issueSize", "baseName", "issueLength", "FileSIZE", "FileCount", "fileCount", "byteSIZE", "baseCount", "byteSize", "issueSIZE", "byteLength", "fileLength"], "totalNoDataRows": ["totalNoDataBows", "totalNoDataRecues", "totalNodataRues", "totalNoDataRecoles", "totalNoDataSlocks", "totalNodataRocks", "totalNoDataRocks", "totalNodataRecocks", "totalNoDataRues", "totalNodataRecows", "totalNodataRows", "totalNoDataRecows", "totalNoDataSlues", "totalNodataRecoles", "totalNoDataRoles", "totalNoDataBues", "totalNoDataSlows", "totalNoDataBoles", "totalNoDataBocks", "totalNoDataRecocks", "totalNodataRoles", "totalNoDataSloles", "totalNodataRecues"], "mappedBuffer": ["mattedBB", "mmappingBuff", "mmappedBuffer", "mappingCounter", " mappedBuff", "mappedCallback", "MapperBuffer", "mappingQueue", " mapperBuffer", "matchedBuffer", "MapperBB", " mappedCallback", "MappedBuff", "mapedQueue", "mmappingbuffer", "mressedBuffer", "mapedData", " mappedQueue", "MappedBB", "mappingBuff", "mapedBuffer", "mapperbuffer", "mapedCallback", "matchedBuff", "mressedCallback", "maphCallback", "MapperBuff", " mapperBuff", "mmappedbuffer", " mapedCallback", "mapBB", "mappingbuffer", "mapBuffer", " mapperQueue", " mappedFB", " mapedBuff", "maphFB", "mappingData", "mapedbuffer", "mappedCounter", "mappedFB", "maphBuffer", "mappedQueue", "mapperQueue", "MappedBuffer", "mattedBuffer", "MapedBuffer", "MapedBuff", "mattedBuff", "MappedData", "MapedBB", "mmappedQueue", " mapperCounter", "mattedData", "mapedBuff", "mappedBB", " mapedFB", " mappedCounter", "maphBuff", "mressedBuff", "mapedBB", "matchedCounter", "mapedFB", "matchedQueue", " mapedBuffer", "mappedbuffer", "mappedBuff", "mappingBB", "MapedData", "mmappingBuffer", "mapperCounter", "mapperBuffer", "mapperBB", "mmappingQueue", "mmappedBuff", "mressedFB", "mapBuff", "mappedData", "mappingBuffer", "mapperBuff"], "startIndex": ["endPage", "Startindex", "StartPosition", "StartIndex", "firstindex", "startPoint", "currentPoint", " startindex", "startIter", "startInd", " startPoint", "startPage", " startPage", "currentPos", "StartIter", "StartPos", "firstInd", "startPos", "endPosition", " startPos", " startPosition", "endIter", "StartPoint", "initPosition", "startPosition", "firstIndex", "currentIndex", "initIndex", "initindex", "StartPage", "StartInd", " startIter", "firstPosition", " startInd", "endIndex", "currentPosition", "startindex"], "count": ["c", "ctr", "type", "state", "status", "max", "mount", "order", "core", "more", "length", "id", "total", "ind", "category", "user", "batch", "now", "add", "next", "continue", "result", "limit", "index", "check", "counter", "found", "name", "created", "n", "start", "amount", "cast", "coll", "find", "number", "conf", "list", "depth", "info", "con", "num", "force", "size", "first", "sum", "process", "Count", "act", "call", "code", "ount", "last", "i", "current", "page", "cloud"], "currentMovie": ["primaryMovie", "currentlyMovie", "firstDate", "currentHero", "currentMedia", " currentMouse", "currentImage", "activeVideo", "currentMusic", " currentSpider", "currentMouse", "reportedImage", "reportedMouse", "currentlyMonster", "primaryHero", "presentMovie", "primaryVideo", "activeSpider", "reportedHero", "firstMedia", "firstMouse", "reportedMusic", "firstMonster", "currentlyHero", "currentlySpider", "currentSpider", "currentDate", " currentMusic", "reportedMedia", "currentVideo", " currentMedia", " currentVideo", "firstHero", "presentHero", " currentHero", " currentImage", " currentMonster", "activeMovie", "reportedMovie", "activePlayer", "presentMusic", "currentlyDate", "currentMonster", "presentImage", "firstMovie", " currentPlayer", "currentlyVideo", "firstVideo", "currentPlayer", "currentlyPlayer", "primaryDate"], "movieName": ["mpegNAME", "filmType", "oviename", "httpNAME", "mpegName", " movieType", "MovieType", "monsterNAME", " moviename", "ovieNAME", "moviename", "httpname", "Moviename", "MovieTitle", "movieType", "movieNAME", "ovieName", " movieNAME", "monsterName", "MovieName", "ovieGroup", "movieGroup", "movieTitle", "monstername", "filmName", "mpegGroup", "mpegname", "filmNAME", "filmGroup", "httpName", " movieTitle", "filmTitle", "filmname"], "customer": ["Customity", "Customizer", "customizer", "developer", "developator", " customator", "customator", "developizer", "Customer", "customorder", "ustomorder", "developorder", "developER", "ustomator", "stickizer", "ustomER", "stickity", "stickER", " customorder", " customER", "ustomer", "customER", "CustomER", "sticker", "developity", "customity"], "rating": ["scale", "type", "score", "heading", "translation", "average", "scoring", "core", "user", "attribute", "rage", "card", "playing", "review", "boarding", "credit", "term", "format", "rate", "weight", "option", "setting", "rat", "ping", "reporting", "tag", "rank", "testing", "reading", "having", "strength", "ating", "Rating", "saving", "rated", " Rating", "error", "ranking"], "outBuf1": ["outBuf0", "outBufl", "outBuff3", "outBBuff1", "outBuc0", "outBlf1", "outBulp3", "outBuf64", "outRbuf1", "outBdfOnce", "outBuff0", "outBfx0", "outBbufOne", "outBuffyone", "outBlf0", "outBbuf5", "outBool3", "outDuf0", "outBulp64", "outBdf64", "outRuf0", "outBuf5", "outBulpOnce", "outRuf5", "outBbufOnce", "outBooll", "outBuffy1", "outBool1", "outBuf3", "outBuffyl", "outBuff1", "outBfx1", "outBurg3", "outBbufl", "outBbufone", "outBbuf64", "outBuf18", "outDuf11", "outBBuff0", "outRuf3", "outBurg18", "outRuf18", "outBurg1", "outBbuf11", "outRuf1", "outBlf2", "outBdf3", "outDbuf1", "outBoolone", "outBuffy18", "outDuf3", "outBuc5", "outBufOnce", "outBlf3", "outBdf1", "outBfx11", "outRbuf3", "outBurg0", "outBfx3", "outBbuf3", "outBbuf1", "outDuf1", "outBufOne", "outRbuf5", "outBuffy3", "outRufOne", "outRbuf18", "outBbuf18", "outDbuf3", "outBbuf0", "outBucOne", "outBBuff3", "outBuff2", "outRbufOne", "outBuc1", "outBBuff11", "outDbuf11", "outBulp1", "outBuf11", "outDbuf0", "outBuffy0", "outRbuf0", "outBufone"], "outBuf2": ["outMuf1", "outBfg4", "outBuffyTwo", "outBuff3", "outFbuf4", "outBbuff3", "outFufTwo", "outBuffy4", "outFuf02", "outFbuf02", "outFuf4", "outMbuf2", "outBuffj", "outMbuf15", "outBuffy3", "outFbufTwo", "outBbuf15", "outMbuf3", "outMuf2", "outBbuf2", "outFuf2", "outBbuf42", "outBuffy2", "outBfg2", "outBbuf02", "outBbuffj", "outBuff4", "outBuf3", "outBfx2", "outBbufj", "outBuf42", "outBuf02", "outBuff1", "outFbuf2", "outBuff42", "outBbuf4", "outMbuf1", "outBuff2", "outMuf3", "outBuf15", "outBuf4", "outBbuff42", "outBbuff2", "outBuffTwo", "outBuffy02", "outBfx1", "outMuf15", "outBfx15", "outBufTwo", "outBbuff15", "outBfx3", "outBbufTwo", "outBfgTwo", "outBfg02", "outBbuf3", "outBufj", "outBbuff1", "outBbuf1", "outBbuff4"], "endOfIndexFile": ["endOfIndexTable", "endOfErrorfile", "endOfErrorFiles", " endFile", "endOfIndfile", "endOfindexfile", "endOFindexFile", "endOFindexfile", "endofIndexFile", "endofindexfile", "endOfindexTable", "EndFile", "endofindexFile", "endofindexTable", "endOfindexFiles", "endOFIndexLine", "endOfIndLine", "endOfIndexLine", "endofIndexfile", "endOfIndexF", "endOfindexFile", "endOfPositionFiles", "endOfPositionTable", "endofindexF", "endOfPositionFile", "endofIndexF", "endOfIndFile", "endOFindexLine", "endedFile", "endOfIndexfile", "endOfindexF", "endofIndexTable", "endOFIndexfile", "endOfPositionfile", "endFile", "endOfErrorFile", "endOfIndexFiles", "endofindexFiles", "endofIndexFiles", "endOfindexLine", "endOFIndexFile", "endOfErrorF"]}}
{"id1": "12236729", "id2": "13783898", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["read", " replicate", " combine", " duplicate", "transfer", " transfer", " dup", " cp", " restore", " cat", "cp", " copying", " Copy", " delete", " parallel", " download", " clone", " join", "paste", " seek", " upload", " operate", "Copy", " append", " paste", " recover", " merge", " move"], "inputFile": ["outputDir", "inile", "inputfile", "configPath", " inputPost", "argumentPath", " inputile", "configfile", "inputPost", "inPath", "argumentfile", "outputPath", " inputfile", "configPost", "inputPath", "configFile", "argumentFile", "argumentPost", " inputDir", "outputile", "inputDir", "inFile", "inDir", " inputPath", "inputile"], "outputFile": ["outPlace", "outputDir", "targetPath", "outFile", "outputPlace", " outputDir", "inputfile", "writePlace", "outPath", "outDir", "outFilename", "outputPath", "targetDir", "writeFile", "outputfile", "inputPath", "outfile", "targetfile", "outputFilename", " outputFilename", "inputDir", " outputPlace", "targetFile", "writeFilename", "writeDir"], "in": ["reader", "read", "bin", "din", "min", " din", "inc", "isin", "rin", "ind", "en", "inner", "ze", "inf", "inside", "iter", "is", "input", "al", "up", "In", "on", "old", "gin", "per", "init", "all", "info", "ini", "IN", "con", "it", "ir", "from", "ins", "inn", "cin", "ai", "i", "ic", "ri", "sin"], "out": ["io", "v", "dis", "can", "write", "OUT", "ne", "user", "os", "auto", "log", "en", "print", "at", "flush", "sys", "ot", "client", "cache", "check", "res", "end", "obj", "nt", "n", "on", "co", "o", "net", "con", "one", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "cos", "g", "writer", "ou", "aos", "by", "outer"], "c": ["t", "ct", "count", "cl", "v", "cd", "ac", "k", "uc", "u", "ce", "arc", "l", "cs", "bc", "mc", "cp", "cod", "r", "cc", "x", "cb", "gc", "cache", "cu", "rc", "chain", "ec", "n", "unc", "f", "d", "character", "conf", "con", "ch", "cm", "pc", "cap", "char", "z", "code", "nc", "cos", "C", "i", "cont", "cr", "current", "cf", "lc"]}}
{"id1": "5607440", "id2": "4168534", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 1, "substitutes": {"updateShoppingBean": ["updateShowshipBein", "updateShowshipBeans", "updateShoppingSpans", "updateShoppingMeans", "updateShowshipSpans", "updateShoppingBeans", "updateShoppingBan", "updateShowshipBean", "updateShoppingBaning", "updateShoppingBein", "updateShowshipSpin", "updateShoppingMein", "updateShoppingBeaning", "updateShoppingMeaning", "updateShoppingMean", "updateShowshipBeaning", "updateShowshipSpaning", "updateShoppingSpin", "updateShoppingBin", "updateShoppingBans", "updateShowshipSpan", "updateShoppingSpaning", "updateShoppingSpan"], "userId": ["USERName", "userLog", "USERReference", " userLog", "UserName", "UserLog", "UserId", "userPath", "UserReference", "USERLog", "clientId", " userid", " userName", "clientid", "userName", " userPath", "Userid", "userReference", "userid", " userReference", "clientPath", "USERId", "UserPath", "clientName"], "connection": ["c", "generation", "license", "usage", "close", "manager", "conn", "operation", "server", "collection", "document", "relation", "computer", "statement", "session", "creator", "client", "driver", "pointer", "library", "reference", "application", "open", "engine", "database", "communication", "command", "city", "network", "character", "directory", "query", "container", "con", "Connection", "office", "link", "response", "bo", "context", " Connection", "settings", "output", "sql", "entry", "condition", "subject", "socket", "information", "config", "table", "resource", "ion", "writer", "function", "management", "connect"], "preparedStatement1": ["preparedstatementOne", "preparedMessageOne", "preparedstatement5", "preparedstatement1", "preparedTemplate11", "prearedQuery1", "preprotectedStatement9", "preparedRequest4", "preparedStatement5", "preparedStatement7", "preparedStatONE", "preprotectedTemplate1", "preparedStatementONE", "preparedStatementn", "preparedstatement2", "preparedStatus11", "preparedTransaction9", "preparedStatement6", "prearedStatement4", "preparedStat10", "preparedQuery8", "prequalifiedStatOne", "preparedStatement8", "preculatedCommentOne", "preprotectedStatement11", "preparedRequestOne", "prearedStatementOne", "preparedPolicyOne", "preparedCommentOne", "preparedTransaction2", "preparedTemplate9", "preparedQuery4", "preparedTransaction1", "prearedQueryn", "preparedTemplate12", "preparedQuery5", "preparedStatement11", "preparedMessage7", "prearedStatement2", "preparedStat2", "prearedQuery5", "preculatedComment7", "preparedQuery10", "preculatedStatement8", "preparedComment4", "preculatedStatement1", "preparedStatn", "prearedStatement5", "preparedStatOne", "preparedRequest2", "preparedTransaction11", "preparedMessage8", "preparedTransaction12", "prequalifiedStatementOne", "preparedRequest1", "prearedStatement1", "preparedPolicyn", "preparedMessage1", "preparedStatement9", "preparedTemplate1", "prequalifiedStatement1", "preparedComment5", "preparedStat6", "preparedStat1", "preprotectedTemplate12", "prequalifiedStatement2", "prequalifiedStat6", "preparedStatement4", "preparedQuery2", "prearedQuery2", "preprotectedStatement12", "prequalifiedStat1", "preparedstatement4", "prequalifiedStatement6", "preparedComment1", "preparedQuery7", "preprotectedTemplate11", "preprotectedTemplate9", "preculatedStatement7", "preparedPolicy1", "preparedComment8", "prearedQueryOne", "prearedQuery4", "preparedComment7", "preculatedComment8", "preparedQueryOne", "preparedQueryn", "preparedQuery1", "preculatedStatementOne", "preparedQueryONE", "preparedStatement12", "preparedComment2", "preculatedComment1", "preparedPolicy10", "prequalifiedStat2", "preparedStatus12", "preparedStatus1", "preparedTransaction10", "preparedStatement10", "prearedStatementn", "preparedTransactionOne", "preprotectedStatement1", "preparedStatementOne", "prearedQuery10", "preparedStatus9", "prearedStatement10"], "preparedStatement2": ["preededTransaction4", "preparedSession4", "preparedSessionSecond", "preededStatement4", "preparedTransaction4", "preparedTransaction2", "preparedSessionTwo", "preededStatementSecond", "preparedstatementTwo", "preparedTransaction1", "preparedList2", "prearedStatementTwo", "preparedListTwo", "preparedTransactionTwo", "preededTransactionSecond", "preededStatement2", "preparedstatementSecond", "preparedSession2", "prearedStatement2", "preparedList1", "preparedStatement4", "preededStatementTwo", "preparedstatement2", "preparedListSecond", "preparedstatement4", "preededTransaction2", "preparedStatementSecond", "prearedStatementSecond", "preparedTransactionSecond", "prearedStatement1", "preparedStatementTwo", "preededTransactionTwo"], "preparedQuery": ["prefixedStatement", "prelatedQu", "prelatedQuery", "preparedQu", "PrearedQuery", "premediatedQ", "postparedStatement", "prearedSpec", "prelatedQ", "premittedStatement", "preferredQuery", "PreparedQ", "precedQu", "prefixedQu", "preferredQL", "PreparedString", "PrearedQu", "PreparedQuery", "prelatedStatement", "PrearedSpec", "PreparedStatement", "preparedSpec", "prefixedSpec", "prefixedQuery", "PrearedQ", "preparedQL", "PrearedStatement", "prearedQ", "preferredStatement", "PreparedSpec", "postaredStatement", "postparedQL", "precedQuery", "prearedString", "preparedQ", "postaredQL", "postparedQuery", "PrearedString", "preutedQuery", "premittedQuery", "premediatedQuery", "premediatedQu", "precedStatement", "preferredQu", "prearedQu", "preutedQu", "prearedStatement", "premittedQL", "preparedString", "prearedQuery", "preutedString", "preparedStatement", "preferredString", "premediatedStatement", "preutedStatement", "precedSpec", "prearedQL", "postaredQuery", "PreparedQu"], "date": ["day", " day", "zone", "status", "state", "age", "data", "order", "user", "ate", "Date", "document", "now", "draw", "result", "year", "dt", "render", "grade", "dated", "time", "duration", "address", "today", "dat", "note", "start", "late", "get", "month", "diff", "number", "value", "query", "tag", "office", "event", "message", "when"], "format": ["parse", "scale", "license", "unit", "type", "write", "printf", "data", "html", "mt", "Format", "file", "print", "join", "add", "prefix", "sort", "at", "string", " Format", "dt", "render", "transform", "pattern", "spec", "export", "late", "get", "layout", "pretty", "f", "use", "after", "fix", "service", "set", "template", "api", "value", "tag", "it", "pre", "append", "cat", "output", "apply", "process", "sche", "style", "handler", "filter", "writer", "atter", "function", "act", "call", "fn", "form"], "orderDate": ["orderNow", "OrderYear", " orderNow", " orderYear", "orderedDay", " orderDeliveryDate", " orderdate", "gradeDate", "orderDeliveryDate", "OrderDate", "gradedate", "orderedDate", "orderedNow", " orderDay", "orderYear", "gradeDeliveryDate", "Orderdate", "orderedYear", "orderdate", "OrderNow", "gradeDay", "orderDay", "OrderDeliveryDate", "OrderDay"], "iterator": ["ator", "history", "river", "former", "consider", "reader", "instance", "Iterator", "stream", "data", "chest", "starter", "liner", "collection", "ater", "inner", "dump", "next", "integer", "trace", "loader", "udder", "older", "iter", "creator", "storage", "versions", "operator", "sequ", "pointer", "video", "cache", "upper", "era", "rounder", "database", "counter", "chain", "pee", "later", "pie", "loop", "wrapper", "processor", "ippy", "info", "finder", "directory", "network", "list", "size", "sample", "sequence", "race", "runner", "vector", "values", "walker", "internet", "information", "writer", "ter", "filename", "set", "outer"], "shoppingInfo": ["shppingINFO", "shoutingInfo", "shippingInfo", "shippingInformation", "shoutingDetails", "shppingInformation", "choppingInfo", "shppingInfo", "shitchingData", "sharingInfo", "shoppingInformation", "shitchingInf", "shootingInfo", "shippingData", "sharingData", "shoppingData", "shoutingInf", "ShoppingInf", "shillingInfo", "choppingData", "chootingINFO", "shoppingInf", "choppingINFO", "shppingData", "chootingInfo", "sharingInformation", "shillingData", "shippingInf", "shootingData", "choppingInf", "chootingData", "ShoppingInformation", "ShoppingInfo", "shillingDetails", "shitchingInfo", "shoutingData", "shppingInf", "ShippingInfo", "shoppingINFO", "ShoppingDetails", "shillingInf", "ShippingDetails", "chootingInf", "sharingInf", "shippingINFO", "ShippingInf", "shootingINFO", "ShoppingData", "shootingInf", "ShippingInformation", "shippingDetails", "ShippingData", "shoppingDetails"], "product": ["object", "top", "translation", "Product", "category", "order", "products", "base", "id", "shop", "attribute", "cart", "collection", "document", "relation", "image", "print", "brand", "prototype", "result", "common", "client", "operator", "division", "application", "device", "program", "pi", "production", "name", "command", "material", "position", "project", "per", "processor", "media", "property", "contact", "qualified", "service", "template", "module", "process", "article", "node", "pixel", "resource", "source", "system"], "quantity": ["materialularity", "severicity", "Quantication", "quantularity", "quantitude", "percentularity", "Quantity", "Quantularity", "severication", "parify", "percentitude", "qualicity", " quantularity", "parularity", "quantify", "percentity", "severity", "quantency", "quantication", "quanti", " quanti", "parity", "severency", "severitude", "qualitude", "severularity", " quantify", "qualularity", "materialication", "quality", "percenticity", "Quantency", "pari", "materiality", "quanticity", "materialency", "percenti", "percentify"], "cartInfo": ["CartInf", "armInf", "cartNote", "chantNotice", "artInformation", "cotNote", " cartInformation", "commerceData", "CartINFO", " cartNote", " cartData", "cartInf", "cartInformation", "chipData", "cartNotice", "artInf", "chipNote", "CartInfo", " cartINFO", "cotData", "cotInfo", "cotCheck", "chantINFO", "chipCheck", "chantInfo", "commerceNotice", " cartNotice", "cartData", "armINFO", " cartCheck", "commerceINFO", "CartData", "chipInfo", "commerceInfo", "cartCheck", "armData", " cartInf", "armInfo", "chantData", "cartINFO", "artData", "artInfo", "CartInformation"], "i": ["ip", "ori", "t", "li", "y", "io", "v", "bi", "ii", "ite", "phi", "multi", "xi", "I", "u", "ui", "mi", "iu", "l", "gi", "im", "hi", "cli", "ami", "is", "ti", "ice", "ci", "pi", "ij", "me", "p", "si", "init", "ix", "info", "di", "ini", "ims", "o", "it", "m", "fi", "ai", "h", "s", "ic"], "productList": ["cartLibrary", "productlist", " productLibrary", "currentlist", "cartLIST", "currentList", " productOrder", " productlist", "productLIST", "processList", "productOrder", "cartlist", "processOrder", "cartList", "productLibrary", "processlist", "currentLIST", " productLIST", "cartOrder", "currentLibrary"], "components": ["Compositories", "ompresses", "supponent", "coponents", "Compresses", "comports", "compducers", "coputes", " Compresses", "commonents", "condresses", "supponents", "compositories", "ompositories", "coports", "condonents", "supputes", "condducers", "coponent", " Compcomponent", "commutes", "omponents", "producers", " Components", "compcomponent", "condositories", " compositories", "proonents", "supports", "compresses", "ompducers", " compresses", " compcomponent", "commorts", "Components", " Compositories", "proresses", "proositories", "commonent", "computes", "Compcomponent"], "j": ["jj", "ja", "J", "v", "aj", "k", "js", "SELECT", "this", "select", "insert", "jc", "l", "jp", "oj", " ii", "q", "item", "obj", "ji", "ij", "n", "p", "Connect", "json", "query", "jl", "sql", "jo", "z", "m", "Database", "g", "Insert", "connect", "kj"]}}
{"id1": "11475527", "id2": "2807585", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDataFromLocation", "addTextFromurl", "addTextFromURL", "addDatafromUrl", "addDatafromurl", "addDataFormUrl", "addTextFormUrl", "addDataFormLocation", "addDataFromurl", "addTextFormLocation", "addDataFromUrl", "addTextFormurl", "addDatafromLocation", "addTextFormURL", "addDataFormurl", "addTextFromLocation", "addDataToUrl", "addDataTourl", "addDataToURL", "addDataToLocation", "addTextFromUrl", "addDataFormURL", "addDatafromURL"], "theurl": ["teurl", "theloader", "hefile", "theuri", " thefile", "thurl", "heloader", " theUrl", "heuri", "teuri", "teUrl", "heUrl", "thefile", "TheUrl", "heurl", "thfile", "Theuri", " theuri", " theloader", " theURL", "teURL", "theURL", "heURL", "thloader", "theUrl", "thUrl", "TheURL", "Theurl"], "line": ["text", "day", "le", "zone", "lin", "lane", "status", "inline", "point", "comment", " inline", "LINE", "liner", "print", "l", "ln", "cell", "Line", "source", "string", "eline", "ner", "stroke", "ice", "email", "chain", "ine", "name", "online", "lined", "frame", "row", "record", "link", "sample", "block", "sequence", "message", "valid", "char", "entry", "code", "node", "rule", "page", "header"], "in": ["t", "reader", "bin", "read", "din", "conn", "or", "ac", "id", "inc", "isin", "rin", "mi", "en", "inner", "l", "serv", "inf", "ain", "lo", "mc", "out", "r", "proc", "is", "ic", "input", "pin", "open", "phys", "al", "In", "n", "old", "gin", "f", "ma", "init", "win", "o", "IN", "con", "it", "st", "from", "ins", "inn", "cin", "ai", "again", "i", "include", "source", "oin"], "data": ["content", "text", "io", "reader", "read", "buffer", "DATA", "stream", "pipe", "user", "ata", "this", "raw", "file", "join", "da", "bus", "next", "result", "body", "client", "out", "dec", "input", "cache", "dat", "a", "d", "feed", "info", "query", "size", "ad", "writer", "window", "def", "iterator"], "e": ["c", "t", "le", "ele", "y", "ae", "v", "te", "or", "se", "es", "eeee", "re", "oe", "eu", "ne", "ce", "b", "ze", "ge", "r", "x", "ie", "ue", "err", "de", "ine", "er", "a", "ec", "n", "me", "p", "ve", "pe", "d", "f", "be", "element", "o", "event", "E", "ee", "entry", "ex", "m", "g", "h", "i", "error", "ed"]}}
{"id1": "18097962", "id2": "5299276", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getVersion": ["GetVERSION", "GetVersions", "getServer", "getVERSION", "formatVersion", "formatVERSION", " getVersions", "GetVersion", "GetServer", " getServer", "formatServer", " getVERSION", "getVersions", "formatVersions"], "version": ["vers", "history", "license", "v", "usage", "serial", "status", "translation", "ver", "VER", "volume", "human", "key", "release", "software", "tested", "comment", "log", "python", "print", "expression", "language", "result", "string", "update", "versions", "browser", "hash", "video", "program", "title", "address", "name", "format", "command", "Version", "project", "feature", "description", "info", "number", "value", "json", "required", "tag", "sequence", "latest", "VERSION", "about", "vector", "label", "ion", "xml", "lease", "installed", "current", "filename", "summary"], "version_url": ["ver2ur", "ver_url", "version2Url", "version_service", " version_file", "ver_uri", "ver2Url", "ver2url", "version_Url", "version_file", " version_http", "version_uri", "version_http", " version_service", "version2uri", "version2url", "ver2uri", "ver_Url", "version_ur", "version2ur", "ver_ur"], "url": ["lb", "dl", "cl", "ul", "conn", "nl", "cal", "str", "mount", "base", "atl", "log", "loc", "l", "gl", "web", "https", "r", "client", "ssl", "cert", "browser", "ls", "www", "open", "mail", "ref", "sl", "bel", "ur", "f", "pl", "github", "http", "pkg", "hl", "ll", "link", "rel", "ret", "URL", "Url"], "con": ["c", "cl", "can", "conn", "sin", "re", "Con", "connection", "pen", "bc", "ln", "ain", "client", "cert", "cons", "CON", "open", "conv", "connect", "login", "co", "soc", "conf", "cur", "cn", "cm", "ch", "fc", "dial", "com", "cin", "ctrl", "cos", "nc", "cf"], "in": ["io", "reader", "bin", "read", "din", " din", "re", "asin", "inc", "isin", "rin", "el", "en", "ill", "inner", "ln", "inf", "mc", "r", "out", "is", "input", "err", "al", "login", "er", "In", "on", "gin", "ma", "all", "conf", "IN", "mn", "sum", "from", "ins", "inn", "cin", "again", "i", "ic", "oin", "form"], "inputLine": ["feedLINE", "InputBlock", "InputRow", "fromLine", " inputline", "inputNet", "clientNet", "httpString", "commandLine", "feedStream", "feedNet", " inputStream", "httpLINE", "commandRow", "clientLINE", " inputLINE", "inputStream", "fromData", "commandBlock", "feedLine", "Inputline", "inputString", "InputLine", "fromString", "inputBlock", "fromLINE", "inputLINE", "commandline", " inputNet", "inputData", "inputline", " inputString", " inputBlock", "clientStream", " inputData", "httpData", " inputRow", "httpLine", "clientLine", "inputRow"]}}
{"id1": "19335986", "id2": "6188784", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncaughtFailure", " uncuredError", "uncuredception", "uncaughtception", " uncaughtception", "uncurredError", "uncuredFailure", "uncurredFailure", " uncaughtError", "uncappedFailure", " uncaughtFailure", "uncurredException", "uncaughtError", "uncappedError", " uncuredFailure", " uncuredException", "uncurredception", "uncuredException", "uncuredError", "uncappedException", "uncappedception", " uncuredception"], "t": ["T", "c", "tf", "y", " tid", "l", "b", " ti", "out", " th", "title", "thread", "n", "Thread", "p", "f", "d", "o", "w", " title", " T", "m", "to", "task", "g", "h", " st", "window"], "e": ["et", "c", "ele", "ae", "fe", "ev", "te", "se", "eu", "eeee", "es", "oe", "ef", "u", "el", "ce", "en", "b", "eg", "r", "xe", "x", "ie", "Error", "de", "err", "er", "ec", "a", "p", "pe", "exc", "f", "d", "o", "event", "it", "ea", "E", "ee", "ex", "m", "i", "error", "ed"], "display": ["scroll", "details", "dis", "Display", "view", "server", "this", "log", "print", "l", "b", "draw", "body", "session", "console", "render", "browser", "DIS", "screen", "name", "play", "position", "layout", "d", "present", "list", "link", "output", "report", "lay", "label", "show", "style", "table", "s", "window"], "shell": ["scroll", "sb", "buffer", "dis", "echo", "or", "view", "nl", "quit", "scope", "help", "sound", "server", "tree", "ui", "log", "ssh", "print", "l", "b", "expression", "ro", "body", "session", "console", "Shell", "storage", "cli", "browser", "library", "board", "program", "screen", "environment", "command", "handle", "layout", "control", "output", "report", "hell", "tool", "sh", "window", "form", "system"], "message": ["content", "object", "say", "memory", "request", "buffer", "detail", "manager", "echo", "translation", "member", "view", "comment", "payment", "log", "document", "image", "error", "language", "trace", "result", "body", "session", "console", "button", "menu", "application", "open", "mail", "email", "title", "metadata", "command", "position", "layout", "description", "hello", "Message", "template", "module", "question", "essage", "meter", "one", "response", "field", "report", "subject", "label", "m", "show", "msg", "management", "window", "system", "summary"], "e1": ["ee1", "e3", "ee0", "E1", "ee2", "e0", "ee3", " e3", " e2", "E0", "E2", "E3", " e0", "e2"]}}
{"id1": "5836744", "id2": "293167", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"read": ["sync", "scan", "parse", "create", "reader", "write", "buffer", "close", "READ", "run", "stream", "data", "test", "download", "print", "input", "index", "check", "open", "handle", "get", "init", "load", "find", "Read", "query", "reading", "reads", "seek", "readable", "process", "stat", "report", "show", "connect", "access", "ready"], "name": ["version", "t", "create", "named", "location", "type", "state", "default", "Name", "nl", "part", "str", "data", "order", "id", "key", "comment", "base", "file", "ame", "mod", "image", "prefix", "uri", "string", "client", "normal", "path", "no", "ref", "title", "address", "term", "n", "mem", "on", "start", "old", "NAME", "names", "ma", "info", "search", "value", "event", "local", "w", "size", "link", "message", "domain", "null", "nm", "code", "parent", "sp", "word", "filename"], "status": ["sync", "version", "Status", "scale", "exit", "details", "v", "uses", "type", "dr", "state", "sc", "score", "str", "id", "server", "print", "complete", "prefix", "continue", "gl", "result", "flag", "console", "update", "cli", "ssl", "progress", "iso", "x", "index", "gc", "comments", "check", "success", "err", "login", "format", "handle", "use", "description", "json", "service", "set", "iss", "ping", "size", "sequence", "st", "char", "report", "stat", "wait", "ex", "US", "code", "xml", "msg", "s", "mode", "error", "source", "access", "summary"], "url": ["dl", "li", "cl", "build", "ul", "rl", "host", "nl", "mount", "str", "base", "user", "html", "log", "l", "gl", "web", "r", "client", "ssl", "cert", "browser", "www", "open", "mail", "ref", "sl", "bel", "ur", "f", "pkg", "http", "service", "net", "hl", "ll", "link", "rel", "URL", "fl", "char", "Url"], "in": ["io", "reader", "bin", "din", "or", "stream", "inc", "isin", "rin", "mi", "file", "en", "inner", "serv", "im", "body", "mc", "out", "client", "is", "input", "pin", "al", "In", "gin", "ma", "all", "ini", "IN", "con", "pc", "sum", "from", "ins", "inn", "m", "cin", "ai", "i", "source", "form"]}}
{"id1": "3994258", "id2": "17874479", "code1": "    public boolean connectServer(String server, String user, String password) {\n        boolean result = true;\n        try {\n            if (user.equals(\"\")) {\n                user = \"anonymous\";\n                password = \"anonymous\";\n            }\n            this.server = server;\n            this.user = user;\n            this.password = password;\n            ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(encode);\n            ftpClient.connect(server);\n            ftpClient.setSoTimeout(1000 * 30);\n            ftpClient.setDefaultTimeout(1000 * 30);\n            ftpClient.setConnectTimeout(1000 * 30);\n            ftpClient.enterLocalPassiveMode();\n            ftpClient.login(user, password);\n            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                ftpClient.disconnect();\n                return false;\n            }\n            queFilePath = \"data\\\\\" + this.server + \".que\";\n            bufFilePath = \"data\\\\\" + this.server + \".buf\";\n            startGetList();\n        } catch (java.net.SocketTimeoutException e1) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e1, \"\u8fde\u63a5\u8d85\u65f6\");\n        } catch (Exception e) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e, \"\u672a\u77e5\u5f02\u5e38\");\n        } finally {\n            if (ftpClient.isConnected()) {\n                try {\n                    ftpClient.disconnect();\n                } catch (IOException ioe) {\n                    cn.imgdpu.util.CatException.getMethod().catException(ioe, \"IO\u5f02\u5e38\");\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "label": 0, "substitutes": {"connectServer": ["connectDatabase", "openDatabase", "selectServer", "connectionSite", "openSer", "selectSer", "connectSer", "connectionSer", "selectSite", "connectionDatabase", "connectSite", "connectionServer", "selectDatabase", "openServer", "openSite"], "server": ["version", "ip", "peer", "scale", "manager", "instance", "ver", "host", "connection", "base", "remote", "column", "total", "erver", "controller", "test", "computer", "free", "serv", "Server", "uri", "center", "localhost", "console", "source", "client", "browser", "mobile", "device", "engine", "database", "email", "address", "enter", "name", "er", "url", "project", "ve", "folder", "description", "http", "cookie", "search", "service", "directory", "hello", "slave", "row", "query", "template", "site", "value", "domain", "sample", "entry", "socket", "store", "master", "table", "port", "node", "code", "model", "seed", "ser", "ter", "page", "parent", "system"], "user": ["usage", "any", "manager", "account", "type", "or", "ver", "uid", "host", "human", "data", "usr", "order", "u", "used", "attribute", "file", "author", "usa", "username", "post", "form", "word", "string", "creator", "client", "profile", "path", "admin", "ername", "util", "device", "rule", "database", "login", "name", "term", "note", "command", "er", "me", "root", "student", "issue", "per", "use", "token", "User", "info", "query", "basic", "field", "person", "you", "char", "from", "USER", "nick", "consumer", "owner", "port", "auth", "store", "error", "key", "by"], "password": ["pty", "padding", "secret", "wd", "PASS", "worker", "account", "data", "comment", "power", "attribute", "pool", "username", "phrase", "prefix", "language", "picture", "sword", "session", "parser", "client", "profile", "pattern", "crypt", "security", "hash", "sudo", "mask", "application", "device", "database", "policy", "chain", "remember", "login", "command", "wordpress", "shadow", "pass", "p", "words", "paste", "token", "description", "hello", "directory", "number", "wp", "code", "port", "auth", "word", "Password"], "ftpClient": ["ftcCan", "aftpConnection", "ftpCan", "fftControl", "aftpClient", "aftPBuilder", "ftpclient", "aftcHandler", "aftPConnection", "factpDo", "ftcControl", "aftPDo", "fttpClient", " ftPClient", "ftppControl", "ftcpMethod", "ftcclient", " ftpConnection", "ftpStore", "aftcpControl", "ftcpClient", "ftlpClient", "ftcNode", "factpClient", "ctcpclient", "aftpBuilder", "ftpHandler", "ftwpclient", "ftpAdmin", "fttStore", "ftcBuilder", "fttHandler", "ftcpHandler", " ftpBody", "ftpaMethod", "fftCan", "ftphpContent", "fttpclient", "fftpConnection", "fttpBuilder", "factpatclient", "ftphpclient", "ftwpClient", "fftpclient", "ctcpContent", "ftPclient", "fttclient", "ftppclient", "ftpiContent", "ftppCan", "ftpMethod", " ftPclient", "ftpatClient", "ffpControl", " ftpStore", "ftcStore", "aftPClient", "ftcpclient", "aftcpMethod", "ftpatDo", "factpNode", "aftpMethod", " ftPConnection", "ftphpClient", "fttCan", "fttControl", "ftlpContent", "ftcpBody", "ftpBody", "ftpContent", "factpclient", "ftPClient", "fttMethod", "aftpclient", "aftpDo", "ftfControl", "ftpatclient", "ftfClient", "factpatDo", "ftPBuilder", "ctpContent", "ftcContent", "ctpclient", "ftlpBody", "ftpConnection", "ctpClient", "aftpControl", "ftpiClient", "fttAdmin", "fftpClient", "fttClient", "ftppClient", "ftpatNode", "ftpiBody", " ftpContent", "ftwpNode", "ffpClient", "ftfConnection", "ftpatAdmin", "ffpCan", "fftclient", "ftcpStore", " ftcpBody", "ftpBuilder", "ftcDo", "ftPStore", "ffpConnection", "aftcpConnection", "factpatClient", "aftcclient", "fftAdmin", " fttclient", "aftcpclient", "ftcConnection", "ftpControl", "ftpNode", "ffpclient", " ftcpContent", "ftPConnection", "fttpControl", "ffpAdmin", "ftpaClient", " ftPStore", "fttConnection", "fftClient", " ftcpClient", "ftcClient", "ftcpConnection", " fttClient", " fttStore", "ftcpContent", "ctcpClient", "fttpConnection", "aftpHandler", "ftfclient", " fttConnection", "ftcAdmin", " ftpclient", "ftlpDo", "aftcControl", "ftpatControl", "aftcClient", "ftcpControl", "ftcHandler", "ftwpDo", "ftpDo", "ftpaclient", "factpatNode", "ftPDo", "fttpStore", "aftcpClient", "fttpDo"], "queFilePath": [" queTableName", "queFileDir", " queTableId", "queDirPath", "queLinepath", "queFPath", "queTablePath", " queTableDir", "queTimePath", "bufFilepath", "queFilePart", "queFileId", " queFileId", "queFPos", "queItemPath", "queStoreStep", "queLinePath", "queFileFormat", "quFilePath", "queTableName", "queLinePos", "queItemInfo", "queStorePart", "queFileName", "quItemInfo", "queStoreInfo", "queDirDir", "queDirName", "quefilePath", "queFileInfo", "queTableDir", "queTimeStep", "quItemPart", "queItemStep", "quefileName", "queLineFormat", "quFileStep", "queFpath", "queTimePart", "queStorePath", "queDirId", "quItemPath", "queFilePos", "quFilePart", "bufFilePos", "queFilepath", "quFileInfo", "queTimeInfo", "queItemPart", "queFileStep", "queTableId", "queFFormat", "bufFileFormat", " queFileName", "quefileDir", " queFileDir", "quefileId", "quItemStep", " queTablePath"], "bufFilePath": ["bufTableData", "buffileLocation", "vecFilePath", "vecQueueName", "bufFilenameDef", "bufLinepath", " bufFileLocation", "bufByteName", "bufQueueStr", "bufferfileName", "buffileData", "vecFileDef", "bufTablePath", "buffileName", "bufFilepath", "bufferFilePath", "bufFileStr", " bufFileData", "bufQueueDef", "bufLineName", "bufRelName", "bufferFileName", "bufFileName", "bufTableLocation", "bufRelpath", " bufByteLocation", "buffileTime", "bufferfilepath", "vecFileName", " bufFileName", "buffileDef", "bufBytePath", "buffilepath", "bufQueuePath", "vecQueuePath", "bufferFileTime", "bufQueueName", "bufRelTime", "bufferFilepath", "bufFileTime", "bufFileDef", " bufByteName", "bufTableName", "vecQueueStr", "bufRelPath", "vecQueueDef", "bufByteData", "bufFilenameStr", "bufFileLocation", " bufByteData", "bufferfilePath", "vecFileStr", "bufByteLocation", "bufFileData", "bufLineTime", " bufBytePath", "bufFilenamePath", "bufFilenameName", "buffileStr", "bufLinePath", "buffilePath", "bufferfileTime"], "errMsg": ["erMess", "erLog", "erMsg", "errStr", "erMessage", "sprStr", "cfgLog", "errMess", "errLog", "sprSm", "errSm", " errLog", "failStr", " errStr", " errSm", "sprMess", "failSm", "cfgMessage", " errMess", "failMess", "cfgMsg", "sprMsg", "errMessage", " errMessage", "failMsg", "cfgMess"], "errCode": ["errCon", "urgNo", " errCount", "eorDef", "urgCode", "eorSc", "errNo", "errSc", "sprSc", "sprDef", "sprCode", " errCon", "urgCheck", "errCount", "sprCount", "rrNo", "eorCount", " errCheck", "errCheck", "rrCon", " errDef", "rrCheck", " errSc", " errNo", "rrCode", "errDef", "eorCode", "urgCon"], "result": ["results", "details", "status", "run", "data", "fac", "answer", "relation", "draw", "continue", "su", "flag", " res", "out", "r", "cert", "profile", "mask", "were", "duration", "res", "cache", "success", "chain", "global", "goal", "false", "journal", "feature", "date", "description", "perm", "match", "value", "event", "sequence", "ret", "valid", "process", "report", " Result", "show", "Result", "msg", "know", "table", "make"]}}
{"id1": "5148212", "id2": "7911686", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", " copyfile", "cloneImage", "cloneFile", "copImage", "copFile", "copyImage", "copfile", " copyImage", "clonefile"], "src": ["img", "sr", "ipl", "sc", "str", "usr", "inc", "sit", "rest", "urg", "file", "loc", "sq", "ident", "iter", "sys", "usc", "ie", "input", "path", "ls", "ource", "obj", "rc", "sur", "req", "start", "Source", "ur", "url", "pkg", "iv", "init", "sec", "cur", "rs", "ost", "rel", "st", "lit", "from", "ins", "syn", "inst", "sf", "attr", "ser", "source", "filename", "txt"], "dest": ["fr", "coord", "Dest", "v", "min", "sup", "data", "usr", "dir", "ident", "iter", "origin", "spec", "nw", "dist", "crit", "output", "null", "parent", "decl", "sp", "fe", "sit", "this", "rest", "file", "temp", "path", "tr", "de", "req", "delete", "ord", "cat", "good", "est", "img", "etc", "des", "nom", "them", "foreign", "gt", "nd", "opt", "dat", "orig", "vol", "lit", "gov", "deg", "doc", "to", "cont", "source", "trans", "tom", "prop", "test", "loc", "result", "way", "mk", "end", "obj", "tif", "comb", "d", "comp", "target", "desc", "st", "master", "port"], "bufSize": ["fontSize", " bufSIZE", "bufCount", "boxsize", "bufsize", "ufSIZE", " bufInfo", "queueLength", "queueLen", "bufferSize", "boxSize", "BufferSize", " bufsize", "fontInfo", "fontSIZE", "ufSize", "bufInfo", "BufferLength", "bufLen", "bufSIZE", "ufInfo", "queueSize", "BufferCount", "buffersize", "boxSIZE", "BufferLen", "bufferSIZE", "bufferLen", "queueCount", "ufsize", "fontsize", "bufferLength", "bufferCount", "bufLength"], "force": ["sync", " enforce", "pdf", "replace", "write", "fx", "default", "ghost", "auto", "external", "ce", "raise", "func", "print", "error", "forcing", "secure", "flag", "e", "flush", "require", "forge", "allow", "update", "cmd", "cp", "vert", "open", "ace", "reason", " override", "start", "handle", "always", "Force", "send", "use", "frame", "like", "only", "forced", "enable", "apply", "append", "fast", "seed", " confirm", "dirty", "yes", "fail", "ignore", "remote", "rule", "quote", "form"], "f": ["c", "t", "fr", "ct", "v", "rf", "ef", "part", "fac", "bf", "file", "l", "b", "e", "dir", "inf", "xf", "r", "df", "uf", "lf", "fm", "fo", "exp", "p", "of", "d", "fs", "conf", "fp", "w", "fc", "elf", "fi", "m", "F", "g", "sf", "s", "h", "cf"], "buffer": ["parse", "text", "history", "memory", "binary", "window", "Buffer", "write", "stack", "buff", "base", "length", "attribute", "batch", "document", "print", "phrase", "temp", "result", "iter", "bar", "shape", "queue", "stroke", "line", "library", "index", "cache", "database", "command", "variable", "buf", "password", "paste", "frame", "number", "template", "row", "sample", "sequence", "block", "message", "append", "char", "table", "filter", "word"], "read": ["ip", "parse", "t", "count", "reader", "write", "take", "READ", "range", "run", "stream", "str", "bind", "need", "length", "select", "ind", "raw", "log", "en", "print", "gets", "add", "before", "give", "im", "iter", "q", "allow", "shape", " Read", "input", "index", "fill", "time", "check", "open", "end", "mem", "start", "get", "pe", "send", "feed", "len", "load", "height", "find", "hello", "info", "Read", "like", "query", "record", "w", "it", "ke", "size", "reads", "reading", "readable", "valid", "seek", "char", "i", "word", "key", "skip"], "in": ["io", "bin", "din", "or", "inc", "isin", "rin", "ind", "mi", "en", "inner", "image", "l", "ln", "inf", "ain", "im", "inside", "iter", "client", "ie", "is", "input", "irm", "al", "up", "In", "on", "get", "gin", "per", "ma", "init", "ini", "IN", "net", "con", "local", "it", "internal", "ir", "from", "ins", "ex", "ar", "inn", "m", "cin", "to", "i", "mm", "ic", "source", "oin", "by"], "out": ["t", "io", "v", "bin", "write", "can", "conn", "or", "oe", "ne", "os", "user", "OU", "full", "file", "print", "inner", "b", "ln", "at", "flush", "ot", "sys", "oss", "client", "cache", "end", "obj", "nt", "conv", "up", "n", "on", "note", "co", "list", "o", "net", "con", "one", "cn", "it", "outs", "output", "Out", "ex", "to", "cos", "ion", "writer", "parent", "not", "ou", "aos", "OUT", "outer"]}}
{"id1": "23273706", "id2": "7458833", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectListdata", "getProjectNodeList", "getProjecttreeData", "getProjectNodedata", "getProjectListList", "getApptreeInfo", "getProjectTreeInfo", "getProjecttreeList", "getProjectTreedata", "getProjectNodeInfo", "getApptreeData", "getProjecttreeInfo", "getAppTreedata", "getProjectListInfo", "getProjectListData", "getAppTreeData", "getAppTreeInfo", "getProjectNodeData", "getApptreeList", "getApptreedata", "getProjectTreeList", "getProjecttreedata", "getAppTreeList"], "treeData": ["tableInfo", "treeInfo", "treeValid", "statusData", "reeList", " treeMap", "reeInfo", "statusMap", "tableData", "treeList", "reeMap", "towerValid", "tableDat", " treeInfo", "treeMap", "reeData", "reeDat", "TreeMap", " treePart", "statusDat", " treeDat", "treeDat", "towerDat", "listPart", " treeList", "listDat", " treeValid", "towerData", "tableMap", "TreeInfo", "cacheDat", "cacheData", "cachePart", "listData", "treePart", "tableValid", "tableList", "TreeData"], "filename": ["save", "println", "jpg", "generation", "river", "location", "fil", "FILE", "file", "FIL", "username", "original", "prefix", "temp", "nil", "uri", "uno", "string", "localhost", "png", "path", "ername", "FN", "title", "lua", "name", "metadata", "root", "url", "SourceFile", "folder", "ames", "json", "fs", "directory", "URI", "FS", "fp", "local", "Filename", "URL", "output", "sql", "fps", "latest", "KEY", "ename", "fax", "fn", "source", "key", "txt"], "urlString": ["URLString", "URLSite", "Urlstring", " urlstring", "lString", "urlSingle", "uriSite", "lStr", "UrlSite", "URLstring", "urlService", "callString", "uristring", "URLSingle", "callstring", "uriSingle", "urlStr", "UrlString", "urlSite", "UrlSingle", "callService", " urlService", "lService", "callStr", "uriString", "lstring", "urlstring", " urlStr"], "urldata": ["urledatum", "urldATA", "urldedata", "udldescription", "udlenata", "urleddata", "urlenATA", " urldeatum", " urldATA", " urldatum", " urldedata", "udldata", " urldeata", "udldATA", "urlfata", " urldeATA", "urldeATA", "uriledatum", "urledata", "urldeata", "urlfatum", "udldatum", "urldatum", "urldescription", "urlddata", "udlenATA", "urldeatum", "urrdatum", "urlfATA", "udlenescription", "urlenatum", "urledATA", "udlenatum", "urlfescription", "urileddata", "uriledATA", "urrdATA", " urlddata", "urrdescription", "urlenata", "uriledata", "urrdata", "urlenescription"], "factory": [" facter", "fault", "votype", "fFactory", "Fotype", "Facter", "Factory", "facault", "vactory", "Frozen", "facacter", "affotype", "facactory", "affactory", "efFactory", "Fixture", " fixture", "Fault", " fFactory", " fault", "vacter", "affFactory", "fotype", "affacter", "facixture", " facet", "facet", "frozen", "FFactory", " frozen", "facter", "fixture", "efacet", "Facet", "efactory", "vFactory", "efrozen"], "parser": ["parse", "io", "pdf", "reader", "manager", "instance", "sup", " parsing", "power", "file", "bank", "fascist", "expression", "loader", "Reader", "x", "df", "jack", "actory", "util", "policy", "conv", "er", "command", " parse", "builder", "p", "processor", "arser", " df", "dom", "Parser", "fp", "php", "au", "walker", "xml", "writer", "sf", "apache", "utils", " p"], "u": ["fu", "uv", "io", "ua", "ul", "nu", "eu", "uid", "ui", "iu", "ut", "l", "su", "uri", "hu", "r", "uf", "ue", "util", "cu", "uu", "un", "ur", "url", "p", "o", "tu", "it", "au", "U", "mu", "us", "lu", "ru", "h", "ou"], "is": ["io", "ists", "dis", "iris", "in", "es", "sis", "ui", "iu", "isc", "bis", "isi", "has", "ib", "im", "il", "ist", "sys", "oss", "iso", "lis", "ys", "ires", "its", "IS", "si", "ris", "are", "info", "fs", "ims", "ais", "isa", "mis", "iss", "ost", "it", "ios", "abs", "isl", "ir", "obs", "ins", "ar", "rys", "ai", "us", "Is", "ic", "ri", "ms"], "os": ["et", "dos", "ss", "io", "mos", "Os", "or", "es", "bs", "ros", "des", "OS", "pos", "so", "aos", "oa", "osa", "bos", "sys", "as", "oss", "ot", "out", "ows", "oses", "ls", "ys", "ops", "uts", "ox", "fs", "o", "ost", "ens", "ios", "css", "obs", "osi", "oes", "socket", "cos", "us", "s", "oos", "ms"], "iBufSize": ["iBphLength", "iRbufSize", "iBuffLen", "iBufLen", "iBuffSize", "iLbufLen", "iRufSize", "iBphCount", "iBbufSIZE", "iRufLength", "iBuffSIZE", "iBphSize", "iBuffCount", "iBulCount", "iBbufCount", "iLbufSize", "iLufCount", "iBulSize", "iBphSIZE", "iBufCount", "iRufCount", "iLufsize", "iRbufLength", "iBuffLength", "iRbufCount", "iBufSIZE", "iBbufSize", "iBulsize", "iRbufSIZE", "iRufSIZE", "iBbufsize", "iBuffsize", "iBbufLength", "iBbufLen", "iBufsize", "iLufLen", "iLufSize", "iLbufsize", "iBufLength", "iBulLen", "iLbufCount"], "inBuf": [" inRuc", "inBigbuf", "inBuff", "inBlBuff", "inBiguc", "outRBuff", "InChuf", "inBuc", "inBBuff", "inBufferuf", "outBBuff", "outBuf", "inChuf", "InBbuf", " inBuc", " inRbuff", "inBufferBuff", "inRBuff", "inRuff", "inBigbuff", "inChuff", "outRbuf", "inBufferuff", "outBbuf", "inBul", "inBluf", " inRbuf", "inLbuff", "outRul", " inBbuf", "inBufferbuf", "inLuc", "InBBuff", "InChBuff", "inBlbuf", "inLuf", "inRuf", "InChbuf", "inLbuf", "inRuc", "inRbuff", "inRul", "InBuff", "inBufferul", " inRuf", "inBbuf", "inChBuff", " inBbuff", "InChuff", "outRuf", "outBul", "inChbuf", "inBiguf", "InBuf", "inBbuff", "inRbuf", "inBlul"], "iNumRead": ["aiNumberRead", "iRemRead", "iiNumRead", "iNumberWrite", "inumNeed", "iNumRun", "aiNumWrite", "iNumberRead", "aiNumRead", "iNumPrint", "inumRead", "iRemWrite", "InumPrint", "iiNumFind", "iNumWrite", "iNUMRead", "iNUMNeed", "inumDef", "iNumNeed", "iNumFind", "INumNeed", "iLenRead", "InumRun", "iLenRun", "inumRun", "iNUMRun", "iNumberFind", "iFatRead", "aiNumberFind", "InumNeed", "INumRead", "InumRead", "inumFind", "iLenNeed", "iFatDef", "iinumRead", "iinumDef", "INumPrint", "aiNumberWrite", "aiNumFind", "iinumFind", "iNumDef", "inumPrint", "INumRun", "iRemFind", "iFatFind", "iLenPrint", "iiNumDef", "iNUMPrint"], "f": ["c", "t", "fr", "tf", "y", "v", "fe", "fac", "bf", "fa", "file", "l", "b", "e", "af", "df", "fm", "fo", "n", "p", "fd", "d", "fs", "o", "fp", "w", "fc", "fi", "F", "g", "h", "sf", "fax", "cf"], "inputstream": ["Inputstyle", "inputform", " inputdraw", "iterscreen", "uploaddraw", " inputform", "uploadStream", "Inputdraw", "Inputstream", " inputStream", "uploadstream", "inputStream", "Inputform", "iterstream", "uploadscreen", "inputscreen", "InputStream", "iterstyle", "inputstyle", "uploadstyle", "uploadform", "iterStream", "Inputscreen", "inputdraw"], "document": ["version", "content", "object", "ml", "tree", "html", "raw", "file", "collection", "complete", "Document", "language", "expression", "result", "browser", "df", "application", "ocument", "database", "command", "n", "media", "present", "dom", "number", "directory", "template", "response", "context", "message", "ree", "information", "m", "doc", "article", "xml", "model", "node", "apache", "window", "page"], "nodelist": ["snodeelist", " nodeseline", "nodeeman", "nannodeemark", "nodeestyle", "snodeline", "nostemark", "nODist", "snodestyle", "nanodety", "nodeseline", "nodedemark", "noyist", "snodemark", "noyeline", "nodestyle", "snodelist", "snodeemark", "nostelist", "nodesist", "nomest", "snodeestyle", " nodeselist", " nodeseto", "nodeety", "nodedeline", "noyeto", "nanodist", "nomelist", "nomeman", "neodelist", "nODelist", "neodeist", "nodeemark", "nodeelist", "nnodeemark", "nodeman", "nodedety", "nodest", "nnodeelist", "neodeeman", "noyelist", "nosteline", "nodedelist", "nodety", "nodeselist", "nodedestyle", "nannodeety", "nodeeline", "nondest", "nomist", "nanodelist", "nodeto", "nannodeelist", "nnodeety", "nondelist", "nODeto", "neodest", "neodeman", "nodeline", "neodist", "nondeman", "nnodeist", "nannodeist", "neodeelist", "nodist", "nodeist", "snodeeline", "nostestyle", " nodesist", " nodeto", "nodemark", "nanodemark", "nodeseto", "neodeest", " nodeline", "nODeline", "nondist", " nodist", "nodedist", "nodeest"], "num": ["np", "count", "coord", "um", "current", "max", "nu", "multi", "cal", "nom", "length", "total", "umi", "mult", "om", "result", "su", "uni", "alph", "proc", "no", "zero", "n", "dim", "un", "mem", "Number", "umer", "NUM", "perm", "all", "Num", "number", "list", "man", "mn", "net", "con", "UM", "sum", "m", "nm", "mu", "nam", "set", "mon"], "i": ["ip", "history", "li", "y", "io", "bi", "in", "ii", "phi", "multi", "xi", "I", "ui", "this", "mi", "iu", "batch", "them", "l", "e", "gi", "im", "q", "hi", "cli", "ami", "x", "ti", "ie", "index", "major", "ci", "pi", "ij", "ji", "a", "iq", "n", "wi", "me", "p", "qi", "si", "ix", "init", "di", "info", "ini", "ei", "it", "sim", "j", "ex", "my", "\u0438", "m", "z", "ai", "us", "zi", "ic", "ri"]}}
{"id1": "19934218", "id2": "16063533", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"doCrypt": [" doesCrypt", "docrypt", "doHash", " doDec", "Docrypt", "doDec", "DoCrypt", " doesHash", " doescrypt", " doHash", "DoHash", " doesDec", " docrypt", "DoDec"], "text": ["aut", "content", "t", "ct", "binary", "buffer", "read", "translation", "str", "data", "ext", "comment", "select", "log", "test", "document", "now", "print", "pt", "TEXT", "body", "string", "source", "pattern", "x", "path", "input", "title", "nt", "name", "format", "term", "command", "password", "url", "value", "template", "event", "w", "context", "message", "output", "tx", "subject", "act", "config", "code", "msg", "cont", "word", "Text", "key", "form", "txt"], "UnsupportedEncodingException": ["UnsupportedChodingExit", "UnsupportedEncoderException", "UnsupportedEncryptionError", "UnsupportedEncodingError", "UnsupportedChoderEx", "UnsupportedEncodingExit", "UnsupportedEncoderError", "UnsupportedEncgorithmException", "UnsupportedChodingException", "UnsupportedEncryptionException", "UnsupportedEncgorithmExit", "UnsupportedChodingError", "UnsupportedChoderExit", "UnsupportedEncodingEx", "UnsupportedEncryptionExit", "UnsupportedEncoderExit", "UnsupportedEncoderEx", "UnsupportedEncgorithmEx", "UnsupportedEncgorithmError", "UnsupportedChoderError", "UnsupportedEncryptionEx", "UnsupportedChoderException", "UnsupportedChodingEx"], "md": [" Md", "bd", "MD", " cmd", " mo", "det", "cd", "td", " rm", "sd", "sm", " od", " maj", " mp", "mand", "mt", "ind", " man", "add", "dd", "hd", "dir", "ent", "mc", "sha", "cmd", " dd", "df", "mk", "nd", "mb", "dm", "pd", "grad", "mp", "d", " df", " cd", " exec", "der", "di", "ld", "rm", "mn", "od", " ms", "gm", "m", "red", " mac", "mm", "ad", "mg", "ms"], "sha1hash": ["shaOneheader", "sha2Hash", "sha2cache", "SHA2Hash", "sha2sum", "sha512sum", " SHA1sum", "ha1hash", "sha3hash", "sha4cache", "ha1sum", "sha1key", "sha512hash", "sha2key", " SHA1hash", " SHAOnecache", "sha2hex", "sha4hash", "SHA1hash", "shaonekey", " SHAOnesum", "shaOnecache", " SHAOnehash", "sha512Hash", "ha1Hash", "shaonehex", "sha4header", "sha3hex", "sha1Hash", "sha1header", "shaonecache", "shaonesum", "haoneHash", "SHA2key", " SHAOneheader", "sha3Hash", "sha3key", "SHA2hex", "sha512cache", "SHA2hash", "sha1cache", "haonesum", "sha1sum", "shaonehash", "sha4sum", " SHA1header", "haonecache", "sha1hex", "sha2hash", "SHA1Hash", "haonehash", "sha2header", " SHA1cache", "SHA1hex", "SHA1key", "shaOnehash", "ha1cache", "shaOnesum", "shaoneHash"]}}
{"id1": "9824814", "id2": "932225", "code1": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"run": ["unit", "build", "begin", "test", "go", "Run", "render", "running", "work", "open", "job", "loop", "exec", "start", "play", "get", "un", "execute", "launch", "runs", "sample", "block", "runner", "show", "call"], "file": ["content", "text", "object", "le", "io", "binary", "reader", "fe", "type", "instance", "stream", "data", "base", "user", "tree", " FILE", "FILE", "upload", "log", "File", "download", "pool", "document", "image", "fine", "e", "result", "web", "picture", "body", "session", "string", "ile", "out", "path", "entity", "rule", "name", "format", "face", "handle", "get", "p", "f", "pe", " File", "http", "channel", "fp", "record", "lock", "local", "message", "output", "fast", "files", "angle", "handler", "page", "resource", "port", "table", "error", "db", "filename", "header", "class"], "inputStream": ["InputView", "InputStream", " inputView", "InputPath", "inputPath", "InputFile", " inputPath", " inputFile", " InputFile", " InputView", " InputStream", " InputPath", "inputFile", "inputView"], "url": ["dl", "location", "method", "build", "ul", "rl", "host", "nl", "mount", "str", "base", "id", "u", "server", "log", "loc", "document", "l", "b", "web", "loader", "uri", "https", "il", "string", "r", "client", "ssl", "cert", "browser", "path", "ls", "library", "www", "open", "email", "mail", "sl", "address", "name", "builder", "ur", "get", "github", "http", "service", "channel", "ll", "link", "domain", "sql", "URL", "socket", "xml", "resource", "Url", "page"], "beatportAccessor": ["beatportAccessior", "beatphoneAccessOR", "beatportProcesser", "beatportCreatOR", "beatcraftAccesser", "beatcraftAdapter", "beatportAdaptor", "beatportaccessutor", "beatportSelector", "beatportSelecter", "beatphoneaccessutor", "beatphoneaccessor", "beatcraftAdaptOR", "beatportSelectior", "beatportSelectOR", "beatportProcessutor", "beatphoneAccessor", "beatportaccesser", "beatcraftAccessior", "beatportAdaptOR", "beatportCreatutor", "beatportCreator", "beatportProcessor", "beatphoneaccessOR", "beatcraftAccessOR", "beatportAccesser", "beatportAdaptior", "beatcraftAdaptor", "beatportAccessOR", "beatportaccessOR", "beatphoneAccesser", "beatportCreater", "beatcraftAdaptior", "beatportAccessutor", "beatportaccessior", "beatcraftAccessor", "beatphoneAccessutor", "beatphoneaccesser", "beatportAdapter", "beatportaccessor", "beatportProcessOR"], "sessionCookies": ["essionCopies", " sessionCookries", "sessioncookms", "sessioncookrys", "sessionCopms", "essionCopessions", "sessionStrys", "sessionCookessions", "sessionCookrys", " sessioncookys", "sessioncookessions", " sessionBuffies", "sessionCooks", "sessionPrefles", "SessionCookles", "sessioncookies", "essionCookies", "sessionBuffries", " sessionCookys", "sessionCessions", "sessionPrefrys", " sessionCooks", "sessionCookys", " sessionCookles", "sessionCys", "sessionCoples", "sessionCrys", "sessioncookries", "Sessioncooks", "SessionCooks", "sessionCopessions", "essionCookles", " sessioncookels", "sessionCookries", "sessionCles", "sessionPrefies", "sessionStrles", "sessionCs", " sessionBuffries", " sessioncookles", "Sessioncookrys", "sessioncookys", "Sessioncookies", "sessionPrefs", "sessionStrels", "essionCookessions", "sessioncooks", " sessionCookels", " sessioncookies", "sessionBuffs", "sessionCms", "essionCopms", "SessionCookies", "sessionCopies", "SessionCookrys", "sessionCies", "essionCoples", "sessionCookles", " sessionBuffs", "sessionCries", "sessioncookels", "essionCookms", "Sessioncookles", "sessionStries", "sessionCookels", "sessionCels", "sessioncookles", "sessionBuffies", "sessionCookms"], "connection": ["version", "c", "location", "creation", "close", "method", "translation", "conn", "cone", "data", "operation", "controller", "log", "collection", "relation", "document", "computer", "statement", "language", "result", "still", "uri", "session", "established", "client", "pointer", "reference", "application", "connected", "engine", "database", "created", "reason", "communication", "command", "position", "description", "token", "network", "json", "channel", "directory", "character", "number", "termination", "con", "Connection", "record", "link", "response", "context", "message", "settings", "condition", "entry", "internet", "information", "socket", "to", "function", "resource", "ion", "handler", "connect"], "contentLength": ["documentSize", "documentToken", "documentLength", "documentLen", "sizeLen", "sizeLength", "codelength", " contentFrame", "Contentlength", "ontentFrame", "ontentToken", "contentENGTH", "contentToken", "ontentLen", "ContentType", " contentlength", "ContentLength", " contentType", " contentLen", "codeLength", "sizeType", "contentType", "contentSize", "contentDuration", "codeENGTH", "ContentENGTH", "ontentSize", "ontentDuration", "ContentDuration", " contentSize", "ontentLength", "codeLen", " contentENGTH", "contentFrame", "sizeSize", "ContentSize", "contentlength", "contentLen", " contentToken", "ContentFrame", " contentDuration", "ContentLen", "ontentlength"], "size": ["content", "scroll", "scale", "count", "type", "fee", "serial", "speed", "state", "max", "data", "length", "total", "sized", "body", "storage", "limit", "index", "zero", "cache", "sent", "address", "name", "small", "position", "city", "notice", "amount", "capacity", "news", "send", "grow", "timeout", "height", "number", "huge", "sample", "area", "sum", "SIZE", "bytes", "done", "ize", "empty", "Size", "set", "summary"], "downloaded": ["_", "this", "https", "New", "info", "Exception", "call", "connect"], "status": ["version", "Status", "scale", "type", "state", "active", "id", "server", "complete", "result", "flag", "progress", "name", "login", "start", "service", "process", "stat", "wait", "code", "mode", "s", "error", "source", "summary"], "success": [" succeed", "results", "top", " succ", "successfully", " successes", " shutdown", " succeeds", "ccess", "continue", "result", " successful", " completion", " failure", "cc", "Success", "progress", "successful", "exist", "accept", " Success", " successfully", "failed", " proceed", " suc", "fail", "summary"]}}
{"id1": "62362", "id2": "1966310", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "8953394", "id2": "17116123", "code1": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"update": ["sync", "save", "submit", "create", "replace", "copy", "Update", "insert", "batch", "updated", "flush", "put", "edit", "database", "step", "exec", "send", "use", "load", "delete", "touch", "query", "apply", "sql", "UPDATE", "db", "set"], "statement": ["content", "text", "status", "commit", "sn", "ause", "str", "comment", "mt", "batch", "document", "phrase", "print", "expression", "result", "session", "string", "word", "Statement", "name", "command", "description", "execute", "delete", "template", "query", "sequence", "sql", "message", "condition", "stat", "article", "table", "msg", "rule", "quote"], "con": ["c", "ct", "can", "enc", "conn", "ctx", "Con", "connection", "po", "Conn", "pen", " conn", "en", "pool", "bc", "cf", "ain", "tc", "mc", "cp", "cc", "client", "clean", "nn", "cons", "CON", "cond", "cu", "rc", "conv", "ec", "un", "city", "ran", "co", "coll", "soc", "cur", "conf", "cn", "cm", "ch", "bo", "fc", "dial", "com", "cin", "ctrl", "db", "ca", "nc", "connect"], "do_log": ["do_write", "do__save", "do__trace", " do_quote", " do_print", "do_quote", " do_save", "do_save", " do_write", "do_print", "do_trace", "do__log", "do__print", " do_trace"], "s": ["qs", "sb", "gs", "t", "c", "ss", "ps", "v", "se", "bs", "less", "hs", "sm", "js", "os", "sv", "sq", "gets", "l", "cs", "comm", "serv", "session", "as", "ds", "is", "ls", "sl", "ws", "spec", "p", "ses", "fs", "o", "rs", "S", "iss", "ends", "sts", "st", "ins", "m", "socket", "g", "h", "ts", "sol", "ns", "source", "set", "ms"]}}
{"id1": "13666876", "id2": "530882", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformOnefile", "TransformSimplePage", "TransformSimpleModel", "processSingleSourceFile", "transformSimpleRecord", "transformsinglefile", "processSingleFiles", "transformMultiPage", "transformMultifile", "transformsingleFiles", "transformSinglePage", "transformMultiRecord", "transformMultiFiles", "processsinglefile", "processsingleFile", "transformsingleSourceFile", "transformOneFile", "processSingleFile", "transformOneFiles", "TransformSimpleFile", "TransformSingleRecord", "TransformSingleFile", "transformSingleModel", "TransformSimpleRecord", "TransformSingleModel", "transformOneSourceFile", "transformSimplePage", "transformsingleFile", "transformsinglePage", "transformsingleRecord", "transformMultiSourceFile", "transformsingleModel", "transformSingleSourceFile", "transformSingleFiles", "transformSimpleFile", "transformSingleRecord", "processsingleFiles", "processsingleSourceFile", "transformMultiModel", "processSinglefile", "transformSinglefile", "transformMultiFile", "transformSimpleModel", "TransformSinglePage"], "xed": [" xEd", "passed", "uxed", "txed", "exed", "exED", " xied", "passED", "xred", "wxEd", " xED", "xied", "pxeds", "xED", "uxied", "wxented", "xented", "rxED", "exeds", "rxeds", "txeds", " xred", "wxred", "passred", "wxED", "wxied", "Xeded", "rxed", " xented", "txED", "uxented", "xeds", "wxed", "Xed", "Xer", "xer", "exeded", "pxED", "xeded", "uxED", "xEd", "Xeds", "txer", "passEd", "XED", "rxer", "pxeded", "pxed"], "node": ["stage", "object", "day", "create", "range", "scene", "view", "station", "tree", "remote", "ode", "image", "component", "post", "line", "Node", "our", "index", "no", "right", "job", "entity", "de", "map", "name", "n", "hand", "note", "feature", "array", "load", "channel", "directory", "row", "edge", "one", "event", "link", "process", "entry", "resource", "parent", "seed", "word", "set", "and"], "dob": ["diobb", "drob", "dobar", "Dab", " dod", "diab", "diod", " dobb", "drab", "Dob", " dab", "adobar", "dab", "adab", "drod", " doy", "dobb", "Dobar", "Doy", "diob", "dod", "adoy", "doy", "adob", " dobar", "drobb"], "mySrc": ["mySRC", "myInsRC", "mySource", " mySRC", "mySsrc", "myInsrc", "myInsfc", " mySfc", " mySsrc", "MySrc", "mySelources", "myDesRC", "myAsRC", "MySources", "mySelrc", "mySingfc", "mySourceource", "mySfc", "MySource", "mySingrc", "myDesources", "myDessrc", "myDesrc", "mySources", "mySourceRC", "myAsrc", "myAsource", "mySingRC", "MySRC", "mySourcesrc", "myInssrc", "mySingsrc", "mySelRC", "myAssrc", "mySourcerc", "mySelsrc", "MySsrc"], "mySrcF": ["myMourceO", "mySrcC", "mySourceV", "mySRCP", "mySsrcP", "mySsrcV", "myMourceF", "mySufV", "mySRCC", "mySrtF", "mySrtP", "mySsrcI", "mySrcP", "myMrcO", "mySourceF", "mySourceFP", "myMrcF", "mySrcFP", "myMourceFP", "mySufO", "myMourceV", "mySrcI", "mySrcV", "myMrcV", "mySourceO", "mySsrcFP", "mySrcO", "myMrcFP", "mySufF", "mySrtI", "mySsrcO", "mySrtC", "mySRCI", "mySRCF", "mySsrcF", "mySufFP", "mySsrcC"], "myOutF": ["myArtFL", "myOffFile", "myOutputDF", "myInFile", "myObjFs", " myOutC", "myArtF", "myOutDF", "myOutputF", "myInC", "MyInFs", "mysNetFL", "mysOutFL", "mysOutF", "myOutFL", "myArtL", "mysOutW", " myOutE", "myoutV", "myOffF", "myOutputE", "myNetF", "myNetL", "myOutW", "myInL", "myOffE", "myNetFL", "myOutputL", " myOutFile", "myOutputC", "myoutL", " myoutC", "MyInF", "MyOutFile", " myOutL", "myoutF", "myOutputFs", "myObjV", "myOutFile", "myInF", " myNetE", "myCoL", "myCoFL", "mysNetL", "MyOutFs", "myNetW", "myNetDF", "myNetFile", "MyInFile", " myoutF", "mysNetW", "myoutC", "MyOutV", "mysOutL", " myNetFile", "myCoF", "myOffDF", "myOutputV", "mysNetF", "myOutputFile", "myOutFs", " myNetF", "myOutV", "myCoW", "myInFs", "myObjFile", "myInV", "myOutC", "myObjF", "myNetE", "myOutL", "MyInV", "myArtW", " myOutV", " myOutDF", "MyOutF", "myOutE", " myoutV", " myNetDF", " myoutL"], "co": ["c", "ico", "coord", "xc", "cv", "io", "can", " Co", "cl", "copy", "oc", "cal", "po", "col", "ce", "go", "loc", "cs", "ho", "so", "cho", "ro", "flo", "ck", "lo", "cod", "cc", "roc", "ror", "cop", "mo", "wo", "gc", "no", "ci", "cache", "fo", "cu", "ace", "obj", "cover", "coll", "soc", "aco", "Co", "o", "con", "cm", "CO", "fc", "yes", "com", "ctrl", "cos", "nc", "ca", "ko", "lc"], "x3dvFile": ["x3dbfile", "x3cdVFile", "x3dVPath", "x3davPath", "x3dbFilename", "x3dvFilename", "x3dtString", "x3dtFile", "x3pdvString", "x3dvsPath", "x3pdbfile", "x3dVFilename", "x3dVString", "x3dVFile", "x3dtFilename", "x3dbFile", "x3pdbFilename", "x3cdvPath", "x3dvsFilename", "x3dvString", "x3dvPath", "x3dbString", "x3cdvFile", "x3dvfile", "x3dtfile", "x3cdvFilename", "x3cdVFilename", "x3pdbString", "x3pdvfile", "x3dvsFile", "x3cdVPath", "x3pdvFilename", "x3dVfile", "x3pdvFile", "x3davFilename", "x3davFile", "x3pdbFile"], "fis": ["fileiss", "frie", "fileiz", "fiss", " fiz", "frisi", "fires", "fliss", "bis", " fires", "bisi", " fiss", "fisi", "fileis", " fisi", "fiz", "fileires", "bie", "friss", "flires", " fie", "fie", "biss", "fliz", "flis", "fris"], "gzos": ["sslo", "zies", "zaos", "gzies", "gtoss", "go", "goss", "gtops", "zipnos", "ggoes", "zos", "ggops", "gaos", "gsoss", "gzo", "gzops", "gtnos", "ggies", "ziposs", "gzoes", "gties", "gtoes", "gsnos", "sslaos", "gsops", "ssloss", "zipos", "sslos", "zoss", "gzoss", "gos", "gznos", "gsos", "zops", "zo", "gtos", "zipops", "ggos", "zoes", "gzaos"], "buf": ["img", "cv", "Buffer", "buffer", "wb", "emb", "arr", "max", "buff", "font", "Buff", "fb", "raw", "batch", "b", "bus", "vec", "bar", "cmd", "uf", "cb", "br", "good", "ref", "rb", "conv", "aka", "bag", "mem", "orig", "var", "cast", "pkg", "seq", "cur", "cam", "block", "cap", "cat", "bytes", "tab", "mu", "box", "cf"], "ret": ["et", "ctr", "v", "ry", "re", "RET", "back", "ext", "mt", "test", "inter", "print", "Ret", "rets", "continue", "iter", "aux", "gt", "r", "out", "cmd", "cert", "tr", "res", "elt", "ref", "err", "obj", "nt", "att", "end", "ptr", "ft", "len", "rt", "val", " Ret", "arg", "deg", "pret", "red", "ter", "cont", "repl", "alt", "def"]}}
{"id1": "14053882", "id2": "7761195", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", "decrypted", "encrypted", "decode", "encode", "Encrypt", " encrypted", "encryption", " encryption", "Encryption", "decryption", "Encrypted", " encode", "Encode"], "plaintext": ["broadth", " plainpassword", "broadtext", "plainTEXT", "mainpassword", "publictext", "mainTEXT", " plainText", " plainTEXT", "publicTEXT", "longth", "maintext", "plainth", "publicpassword", "broadText", "publicText", "broadmessage", "longmessage", "longText", " plainmessage", " plainth", "plainpassword", "mainText", "plainmessage", "longtext", "plainText"], "md": ["managed", "MD", " mo", "dh", "det", "cd", "med", "dr", "ng", "sd", "sm", "sam", "mand", "mt", "ind", "mod", "esm", "mark", "dd", "hd", "mc", "dig", "del", "cmd", " dd", "ds", "sha", "mk", " mc", "mb", "dm", "mo", "df", "nd", "pd", "nt", "metadata", "grad", "mp", "d", "ma", "der", "ld", "rm", "mn", "od", " ma", "met", "m", "mm", "mg", "ms"], "raw": ["encrypted", "bound", "rendered", "box", "strip", "data", "extra", "base", "unknown", "full", "available", " RAW", "original", "hook", "hex", "bare", "r", "out", "input", "RAW", " Raw", "aw", "right", "pack", "known", "n", "orig", "buf", "clear", "custom", "array", "all", "value", "row", "unsigned", "message", "valid", "bytes", "random", "sh", "clean", "good", "Raw"], "hash": ["ashed", "proof", "html", "id", "unknown", "total", "ash", "ssh", "Hash", "has", "print", "flash", "hex", "sha", "hidden", "cert", "sign", "mask", "tr", "cache", "hat", "mac", "alert", "password", "handle", "shadow", "url", "hed", "height", "href", "json", "search", "tag", "message", "sum", "ashes", "sh", "h", "key"]}}
{"id1": "3024992", "id2": "8182932", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2null_"], "baout": ["BAouth", "dboul", "caout", "BAin", "BAOut", "dbin", "gaouth", "gaout", "gaoul", "caOut", " bain", "dbouth", "BAouts", "baouts", "bain", "baouth", "gain", "buin", "cain", "cait", "abain", "abait", "bait", "abaout", "buOut", "BAoul", "BAout", "baoul", "buouts", " baOut", "dbout", "abaOut", "baOut", "BAit", "buout", " baouts"], "out": ["tmp", "io", "gr", "write", "in", "pool", "serv", "result", "sys", " OUT", "res", "err", "er", "n", "o", "gen", "net", "outs", "it", "Out", "output", "ex", "null", "ser", "OUT"], "writer": ["println", "widget", "reader", "buffer", "write", "worker", "killer", "data", "this", "usher", "file", "print", "inner", "document", "client", "driver", "player", "NULL", "riter", "er", "nw", "builder", "maker", "processor", "writ", "woman", "Writer", "target", "wright", "service", "channel", "w", "rw", "output", "null", "handler", "wrote", "window", "outer"]}}
{"id1": "15510198", "id2": "6418781", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"buildParser": ["Buildparser", "newReader", "newProxy", "BuildReader", "createProxy", "createReader", "buildProxy", "createParser", "newParser", "newparser", "buildparser", "buildReader", "BuildParser", "BuildProxy", "createparser"], "url": ["dl", "location", "build", "ul", "host", "run", "mount", "str", "base", "log", "file", "document", "l", "b", "web", "uri", "string", "ssl", "path", "ls", "util", "job", "mail", "ref", "sl", "address", "email", "name", "pl", "http", "ll", "link", "domain", "URL", "char", "resource", "Url", "page"], "ParserException": ["parserException", "ReaderException", "ReaderError", "parseEvent", "parserEvent", "parseException", "parseError", "ParserError", "parserWarning", "ParserWarning", "ReaderWarning", "parseWarning", "ReaderEvent", "parserError", "ParserEvent"], "parser": ["parse", "lp", "peer", "taker", "reader", "manager", "worker", "instance", " parsing", " provider", "layer", "pool", " parsed", "document", "bank", "inner", "jp", "language", "asser", "loader", "still", " scanner", "could", "driver", "jack", "library", "util", "job", "policy", "program", "arson", "er", "payer", "format", " parse", "builder", "p", "processor", "arser", "pair", "json", "Parser", "fp", "php", "message", "runner", "master", "consumer", " soup", "handler", "xml", "writer"], "connection": ["c", "generation", "creation", "close", "instance", "conn", "cone", "server", "closed", "pool", "relation", "document", "computer", "now", "still", "session", "established", "client", "pointer", "application", "open", "connected", "database", "created", "communication", "command", "position", "currently", "http", "network", "character", "channel", "directory", "con", "Connection", "link", "response", "condition", "message", "entry", "handler", "to", "ion", "resource", "associated", "remote", "current", "connect"]}}
{"id1": "5138455", "id2": "17158020", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"save": [" persist", "write", "copy", " dump", " store", "upload", "dump", " restore", " swap", "clone", "gc", " clone", " insert", "paste", "load", " upload", "Save", " seal", "Copy", " Save", "store", "to", " append", " paste", " set", " recover", " merge", " move"], "bytes": ["gs", "terms", "ies", "binary", "trans", "classes", "es", "bs", "parts", "amps", "raw", "gets", "b", "was", "bits", "aws", "ces", "some", "unks", "odes", "bps", "its", "Bytes", "words", "ses", "loads", "gb", "rs", "lines", "blocks", "reads", "seconds", "values", "pieces", "steps", "bles", "ents", "tes"], "outputFile": ["outputDir", "OutputFiles", "Outputfile", "OutputDir", "OutputFILE", "outFile", "OutputPath", " outputDir", "tempFile", "inputfile", "outPath", "outDir", "outFilename", "outputPath", "referenceFiles", "referenceDir", " outputPath", "outputfile", "outputFILE", "inputPath", "OutputFile", "outputFilename", "inputFile", " outputFILE", "outputFiles", "tempDir", " outputFilename", "inputDir", "tempPath", "referenceFILE", " outputFiles", "tempfile", "referenceFile", "inputFilename"], "in": ["io", "reader", "bin", "read", "din", " din", "sin", "id", "inc", "isin", "rin", "ind", "raw", "mi", "en", "print", "inner", "l", "ze", "inf", "im", "inside", "iter", "mc", "r", "ie", "is", "input", "al", "up", "In", "on", "gin", "f", "ini", "IN", "con", "it", "pre", "st", "from", "ins", "inn", "m", "cin", "act", "xml", "mm", "i", "include", "ri", "source", "by"], "out": ["t", "io", "v", "can", "stable", "write", "ne", "os", "auto", "OU", "log", "file", "full", "print", "l", "b", "at", "sys", "ot", " OUT", "client", "cache", "res", "obj", "end", "nt", "screen", "op", "n", "on", "co", "o", "net", "cn", "outs", "it", "output", "Out", "null", "to", "page", "writer", "i", "ou", "fn", "aos", "OUT", "outer"]}}
{"id1": "12066447", "id2": "1180878", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["extuncicate", "extvalidation", "trvalidation", "truncation", "extuncate", "trunize", "trunate", "trunation", "trculize", "extuncize", "trculicate", "trculation", "truncicate", "extvalidize", "trvalidate", "trvalidize", "trunicate", "trculate", "extvalidate", "extuncation", "extvalidicate", "trvalidicate", "truncize"], "file": ["object", "le", "io", "create", "type", "or", "range", "current", "run", "data", "tree", "base", "user", "FILE", "full", "log", "File", "attribute", "this", "image", "zip", "e", "dir", "source", "ile", "out", "line", "path", "time", "work", "spec", "name", "format", "foo", "handle", "get", "f", "use", "frame", "be", "channel", "info", "template", "module", "fp", "event", "local", "link", "lock", "block", "size", "message", "from", "report", "null", "files", "to", "resource", "model", "port", "table", "parent", "word", "page", "filename", "class"], "backupRoot": ["workupidHome", "backuproot", "backupsBox", "backflowRoot", " backupidDir", "workuproot", "workupHome", "workupidBoot", "backupidRoot", "backupidFolder", "backuperroot", "backmpDir", "backuperHome", "backupBoot", "BackupidRoot", " backupDir", "backumpBox", " backuproot", "BackupFolder", "BackupDir", "backuperRoot", "backumproot", "backupidDir", "backdownFolder", "workupRoot", "workupDir", "backupHome", "backupBox", "backupsRoot", "BackupidFolder", "backflowFolder", "backmpRoot", "backdownDir", " backupBox", "backupidroot", "backureroot", "workupidDir", "backupFolder", "backupidBox", "backuperDir", "backflowDir", "backureHome", "backmproot", "backureRoot", "backureBoot", "backupDir", "backureDir", "workupidRoot", "backupidHome", "backmpBoot", " backupidRoot", "backumpRoot", " backupidBox", "backupsroot", " backupidroot", "backupidBoot", "backupsDir", "BackupRoot", "workupidroot", "backdownRoot", "BackupidDir", "backumpDir", "workupBoot"], "df": ["dl", "tf", "raf", "pdf", "du", "dep", "cd", "dr", "sd", "md", "bf", "dp", "dc", "cf", "dd", "hd", "dt", " pdf", "ds", "deb", "uf", "lf", "dm", "pd", "format", "dim", "tif", "Def", "dx", "fd", "f", "d", "di", "DF", "fun", "NF", "gd", "sf", "mm", "db", "def"], "date": ["version", "save", "day", "content", "create", "zone", " day", "default", "range", "age", "down", "run", "data", "due", "cal", "future", "ate", "Date", "now", "year", " Date", "dt", "string", "update", "grade", "days", "time", "dated", "dates", "duration", "name", "dat", "format", "today", "note", "start", "late", "get", "month", "daily", "frame", "match", "number", "value", "module", "tag", "event", "standard", "message", "output", "sum", "resource", "when"], "zipFile": ["logfile", "pdfStream", "zFile", "zipPath", "zipStore", "ZipFile", "pdfFile", "logFile", "zipfile", "Zipfile", "ZipStream", "jsonfile", "zFilename", "ZipPath", "zStore", "logFilename", "zfile", "logPath", "jsonFile", "zipStream", "logStream", "logStore", "jsonFilename", "jsonStore", "zipFilename", "pdffile", "pdfPath"], "zos": ["zb", "ozo", "ss", "zar", "zan", "asar", "Sax", "asio", "bs", "ros", "zin", "js", "rez", "sbm", "sis", " sands", "hz", "os", "hs", "nz", "cz", "south", "zen", "esm", "ze", "webkit", "ones", "zer", "sch", "zona", "hess", "oss", "bes", "oses", "zag", "zzle", "eros", "enos", "ses", "estro", "los", "ez", "jas", "stice", "css", "za", "zers", "enz", "zon", "z", "zo", "tz", "zi", "zes", "zik", "sol", "cos", "shed"], "fis": ["foia", "dfIs", "fiiss", "fiois", "li", "sfisc", "dfis", "sfIs", "dfiss", "ofis", "fiss", "ofib", "ofits", "fits", "lia", "sfis", " fib", "ef\u00eds", "fiib", "foIs", "Fia", "foi", " fois", "Fisc", "F\u00eds", "fois", "efIs", "Fier", " fiss", "cfisc", "fier", "lis", "ofiss", "efisc", "FIs", "f\u00eds", "fia", "fiis", "lIs", "cfits", "ifisc", "sfier", "sfiss", "Fiss", "fib", "ofois", "ofisc", "cfis", "fIs", "efis", "dfier", "cfiss", "Fis", "ifis", "fi", "fisc", "sfits", "ifIs", "Fi", "if\u00eds"], "entry": ["object", "deep", "ry", "or", "member", "se", "connection", "data", "comment", "attribute", "ce", "tex", "insert", "add", "e", "cell", "ent", "word", "section", "ie", "entity", "de", "obj", "ace", "command", "Entry", "escape", "description", "delete", "element", "ary", "search", "row", "option", "rance", "office", "event", "record", "internal", "cue", "char", "sheet", "zo", "resource", "xml", "ion", "zip", "ment", "key", "set", "def", "and"], "buffer": ["binary", "memory", "Buffer", "padding", "view", "stack", "volume", "buff", "category", "base", "length", "comment", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "word", "button", "bar", "queue", "library", "zero", "cache", "screen", "command", "variable", "buf", "paste", "frame", "template", "sample", "block", "sequence", "message", "append", "char", "table", "code", "window", "page", "letter", "header"], "readed": ["READd", "ReadED", "reader", "readableied", "READer", "READED", "readd", "redented", "readared", " readED", "Readared", "findared", "indexeded", "reded", "readented", "counted", "Reader", "Readied", "rededed", "readED", "indexed", "indexED", "readableED", "readeded", "readableared", " readeded", "findied", "counter", "finded", "redED", "Readd", "READed", " readented", "readied", "countED", "Readed", "readableed", "findED", "countd", "indexented"]}}
{"id1": "20588811", "id2": "16063533", "code1": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 0, "substitutes": {"run": ["submit", "unit", "build", "invoke", "begin", "test", "go", "func", "Run", "profile", "running", "install", "runtime", "job", "loop", "start", "exec", "get", "execute", "launch", "runs", "sample", "block", "runner", "process"], "time": ["version", "history", "t", "minute", "Time", "type", "ime", "instance", "clock", "age", "TIME", "space", "length", " Time", "file", "delay", "go", "now", "join", "trace", "timer", "year", "before", "string", "transform", "duration", "runtime", "step", "hour", "tm", "name", "start", "date", " TIME", "etime", "timeout", "info", "value", "event", "size", "eth", "context", "message", "tim", "change", "m", "second", "code", "h", " timestamp", "times", "money", "ts", "set"], "hostname": ["hostnames", "Hostnames", "domainno", "Hostame", "hostame", "ithname", "localhostName", "domainName", "localhostnumber", "domainname", " hostnames", " hostnumber", "ithame", "localhostno", "hostName", "hostno", " hostame", "domainnumber", "ithnames", "hostnumber", " hostno", " hostName", "Hostname", "localhostname"], "protocol": ["statocol", "prootype", " protility", "prome", "protme", "statme", "Protocl", "protocl", " protocl", "Protme", "prototype", "statotype", "protility", " prototype", "proility", "Protocol", "proocl", "Prototype", "statility", "Protility", "proocol"], "port": ["version", "ip", "pod", "pid", "type", "secret", "age", "point", "host", "Port", "user", "server", "length", "select", "file", "ty", "phone", "eport", "ports", "localhost", "ORT", "client", "mobile", "duration", "device", "address", "PORT", "format", "position", "project", "pe", "timeout", "number", "pose", "ort", "socket", "priority", "pport", "page", "key"], "path": ["version", "text", "th", "kind", "near", "point", "host", "stream", "PATH", "part", "user", "full", "log", "file", "ath", "component", "prefix", "trace", "dir", "string", "transform", "pattern", "partial", "chain", "name", "format", "p", "json", "value", "template", "module", "query", "directory", "context", "process", "resource", "Path"], "action": ["version", "type", "method", "state", "status", "operation", "controller", "test", "flash", "session", "hash", "Action", "success", "step", "policy", "ction", "format", "a", "actions", "name", "op", "token", "ping", "event", "sequence", "ACTION", "message", "process", "act", "code", "function", "resource", "mode", "what", "key"], "xml": ["content", "text", "ml", "pic", "view", "tree", "html", "str", "md", "full", "log", "file", "raw", "htm", "with", "document", "image", "web", "body", "inx", "transform", "out", "ML", "x", "input", "ql", "www", "ws", "format", "son", "ox", "feed", "http", "tml", "dom", "json", "element", "template", "mx", "php", "response", "output", "tx", "bytes", " XML", "my", "rss", "m", "config", "doc", "model", "msg", "X", "form", "txt"], "data": ["version", "content", "text", "request", "default", "DATA", "stream", "connection", "str", "id", "ata", "this", "raw", "file", "relation", "image", "add", "post", " DATA", "options", "result", "session", "string", "input", "step", "name", "dat", "a", "actions", "command", "format", "p", "media", "d", "feed", "all", "json", "info", "value", "api", "query", "response", "context", "message", "output", "information", "to", "function", "what", "lu", "resource", "error", "key", "def"], "u": ["c", "t", "fu", "uv", "ua", "ul", "nu", "eu", "k", "uid", "uc", "user", "ui", "iu", "ut", "l", "gu", "su", " nu", "hu", "uf", "ue", "cu", "uu", "ur", "p", "o", "tu", "au", "U", "lu", "us", "mu", "i", "ru", "bu", "ou", "units"], "url": ["dl", "nl", "connection", "str", "uc", "user", "l", "b", "norm", "web", "loader", "gl", "uri", "il", "https", "cp", "client", "r", "ssl", "browser", "cert", "ls", "util", "open", "res", "sl", "address", "obj", "bel", "ur", "p", "http", "api", "net", "con", "ll", "link", "ret", "URL", "addr", "Url"], "conn": ["c", "ct", "org", "close", "ann", "enc", "ctx", "connection", "Conn", "l", "ait", "https", "pas", "cp", "client", "cert", "ssl", "nec", "cb", "res", "open", "err", "obj", "nt", "conv", "n", "req", "exec", "resp", "info", "net", "con", "Connection", "cn", "fin", "ch", "socket", "addr", "fail", "nc", "connect", "access"]}}
{"id1": "6457199", "id2": "23370621", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["doQuery", "dorequest", "handlerequest", "processRequest", "doResponse", " doResponse", "handleResponse", "processrequest", " doQuery", " dorequest", "handleQuery", "handleRequest", "processResponse", "processQuery"], "request": ["create", "view", "each", "re", "user", "select", "QUEST", "document", "complete", "transform", "input", "reference", "application", "open", "setup", "address", "command", "quest", "position", "req", "get", "project", "Request", "http", "frame", "search", "first", "hello", "query", "question", "context", "message", "seek", "report", "reset", "initial", "call", "xml", "forward"], "response": ["reply", "respond", "content", "onse", "fire", "exit", "write", "status", "view", "re", "connection", "respons", "release", "server", "document", "image", "print", "relation", "next", "continue", "e", "result", "console", "render", "out", "application", "res", "format", "position", "resp", "send", "feed", "http", "frame", "json", "channel", "service", "block", "context", "output", "message", "display", "report", "reset", "socket", "xml", "Response", "writer", "page", "header"], "path": ["text", "where", "binding", "location", "kind", "type", "method", "near", "patch", "PATH", "mount", "host", "base", "core", "key", "parts", "select", "full", "raw", "log", "prop", "test", "length", "ath", "print", "physical", "prefix", "trace", "route", "dir", "uri", "string", "transform", "pattern", "pointer", "input", "index", "right", "alias", "policy", "primary", "partial", "Path", "chain", "name", "format", "root", "url", "p", "pkg", "relative", "qualified", "json", "href", "template", "api", "local", "context", "message", "ex", "parent", "port", "clean", "error", "filename"], "internal": ["managed", "binary", "bin", "inline", "in", "uid", "central", "back", "id", "invoke", "external", "this", "inter", "inner", "original", "skin", "common", "identified", "inside", "ident", "console", "origin", "virtual", "normal", "impl", "index", "alias", "primary", "generic", "name", "orig", " external", "url", "Internal", "init", "relative", "regular", "template", "api", "local", "standard", "rel", "context", "ret", "valid", "entry", "real", "initial", "intern", "san"], "resource": ["object", "create", "binary", "buffer", "instance", "range", "re", "stream", "connection", "release", "core", "controller", "file", "region", "component", "image", "print", "result", "uri", "console", "pointer", "reference", "library", "res", "address", "resolution", "handle", "url", "media", "network", "channel", "directory", "service", "record", "resources", "Resource", "context", "local", "process", "entry", "socket", "store", "exclusive", "model", "remote", "source", "system"], "mimeType": ["mimeName", "mimesStyle", " mimesType", " meshType", " mimesTypes", "MimeTypes", "Mimetype", "mimeStyle", "mimeTypes", "miscTypes", "mtimeName", "mtimeType", " meshtype", "mimesType", "mimesPolicy", "miscType", "MetyType", "metytype", "metyName", "Metytype", "meshStyle", "misctype", "mimesTypes", "meshtype", "mIMEName", "MimeType", " mimetype", " meshName", " mimeName", "MetyName", "maxType", "metyPolicy", "mIMEtype", "meshType", "metyTypes", "MimeName", " meshStyle", " mimesStyle", "miscName", "mIMEType", " mimePolicy", "mimePolicy", "mtimeStyle", "meshName", "metyStyle", "MetyTypes", "maxPolicy", "mIMETypes", " mimeTypes", "maxStyle", "mIMEStyle", "mimetype", "metyType", "mtimetype", " mimeStyle", " mimesPolicy", "maxTypes"], "is": ["ains", "iris", "in", "es", "sis", "isin", "bis", "isc", "isi", "mus", "gets", "has", "cs", "isf", "ics", "as", "iso", "ls", "nis", "ys", "ri", "res", "its", "IS", "ris", "si", "are", "fs", "ais", "rs", "isa", "iss", "ios", "isl", "obs", "ins", "icks", "i", "s", "ic", "ism", "Is"], "os": ["et", "nos", "oz", "ss", " Os", "ps", "Os", "es", "bs", "ros", "des", "OS", "oS", "cs", "aos", "ks", "bos", "sys", "ot", "oss", "ds", "as", "oses", "ls", "ys", "res", "er", "ox", "ols", "los", "fs", "o", "ios", "css", "obs", "osi", "oes", "us", "s", "ts", "oos", "ms"]}}
{"id1": "16931472", "id2": "11546108", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"handler": ["request", "read", "controller", "processing", "hook", "action", "update", "render", "transform", "proc", "index", "success", "Handle", "end", "received", "handled", "accept", "handle", "processor", "init", "execute", "adapt", "output", "Handler", "done", "callback", "forward"], "result": ["results", "memory", "buffer", "product", "details", "status", "data", "full", "total", "complete", "mate", "out", "profile", "hash", "cache", "res", "RESULTS", "success", "successful", "found", "created", "map", "all", "list", "make", "response", "sequence", "output", "valid", "met", "ret", "report", "done", "master", "Result", "page", "table", "current", "source"], "target": ["object", "t", "detail", "scope", "component", "trace", "iter", "cmd", "primary", "term", "service", "output", "valid", "subject", "tool", "node", "parent", "remote", "version", "history", "closure", "translation", "this", "external", "next", "e", "transform", "alias", "goal", "project", "match", "expected", "local", "link", "internal", "trigger", "style", "window", "Target", "buffer", "type", "tree", "controller", "self", "gt", "thread", "layout", "pkg", "info", "template", "arg", "it", "that", "to", "table", "bolt", "page", "source", "peer", "manager", "top", "arget", "view", "base", "dest", "test", "complete", "jp", "prototype", "name", "format", "handle", "tif", "http", "proxy", "report", "master", "task"], "url": ["dl", "build", "ul", "rl", "nl", "mount", "connection", "base", "html", "el", "file", "lr", "loc", "l", "loader", "web", "uri", "client", "ssl", "cert", "browser", "impl", "ls", "mail", "sl", "address", "bel", "ur", "f", "http", "service", "hub", "hl", "ll", "link", "rel", "URL", "char", "git", "Url"], "reader": ["linger", "read", "buffer", "rl", "stream", "rot", "file", "layer", "liner", "inner", "review", "and", "loader", "Reader", "ro", "older", "iter", "uri", "parser", "ner", "driver", "operator", "upper", "rar", "er", "builder", "redo", "cur", "row", "reading", "context", "runner", "readable", "rr", "resource", "writer", "iterator"], "line": ["level", "ip", "text", "le", "zone", "buffer", "detail", "lin", "inline", "state", "status", "range", "point", "nl", "base", "user", "comment", "log", "file", "liner", "LINE", "print", "l", "now", "next", "ln", "continue", "trace", "cell", "body", "iter", "Line", "eline", "string", "lo", "limit", "out", "queue", "section", "no", "email", "entity", "rule", "chain", "ine", "loop", "online", "date", "frame", "network", "row", "lock", "sample", "sequence", "block", "message", "link", "lines", "stay", "style", "store", "code", "port", "node", "page", "word", "source"], "entry": ["object", "deep", "exit", "instance", "ry", "or", "se", "member", "part", "comment", "quick", "inner", "add", "e", "cell", "ent", "ie", "check", "job", "ace", "enter", "term", "Entry", "escape", "pair", "search", "element", "list", "row", "match", "office", "record", "it", "field", "char", "ex", "pixel", "ary", "key", "def"], "fromIndex": ["normalIndex", "FromInd", "leftPosition", "fromInt", "minInd", " fromindex", "minIndex", "normalindex", "fromInd", "oldLink", "fromPosition", "forindex", "leftindex", " fromPosition", "fromindex", "minInt", "forInd", "forIndex", "minindex", " fromInt", "leftInd", "leftIndex", "normalInd", " fromInd", "FromAlpha", "FromIndex", "oldAlpha", " fromAlpha", "normalInt", "oldIndex", "oldInd", "fromAlpha", " fromLink", "FromLink", "forPosition", "fromLink"], "r": ["fr", "R", "vr", "v", "rg", "sr", "rd", "dr", "range", "re", "mr", "nr", "str", "u", "l", "b", "e", "q", "render", "res", "err", "rb", "rar", "rc", "er", "n", "rate", "p", "rt", "rs", "w", "ar", "m", "rr", "cr", "g", "kr", "rect"]}}
{"id1": "7757297", "id2": "324679", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["save", "create", "request", "close", "run", "upload", "download", "sub", "print", "post", "update", "input", "edit", "open", "login", "format", "accept", " submission", "send", "execute", "launch", "apply", "Submit", "process", "report", "display", "form"], "uri": ["du", "location", "range", "id", "doi", "ui", "file", "prefix", "course", "wiki", "origin", "path", "pi", "address", "title", "name", "term", " URI", "password", "ur", "iri", "description", "http", "href", "info", "directory", "URI", "campus", "link", "message", "URL", "subject", "report", "resource", "msg", "i", "ri", "source", "filename"], "Exception": ["Exit", "Warning", "T", "Status", "Class", "Application", "ception", "Event", "Document", "Error", "Throw", "API", "Default", "Message", "Connection", "E", "null", "Result", "X", "EX", "Response", "Failure"], "encodedrdf": ["encodedridfc", "encodedridf", "encuredrdf", "encodingrsfs", "encodeddrp", "encodingrsl", "encodingrsf", "encodeddrf", "encuredrl", "encuredrdl", "encodedrsfx", "encodedwsfx", "encodedwsf", "encodedrf", "encodedwsl", "encodedrsfs", "encodedrdp", "encodedrdfx", "encodedrl", "encodedrsf", "encodingrdl", "encodedrtfx", "encodingrdfs", "encodeddrl", "encodedrp", "encodingrdfx", "encodeddrfc", "encodedrtfs", "encodedrdfs", "encodedridl", "encodingrdf", "encodedrfc", "encuredrfc", "encuredrf", "encodedrtf", "encodedwsfs", "encodedrsl", "encuredrp", "encodedridp", "encodedrtl", "encodedrdfc", "encodingrsfx", "encodedrdl", "encuredrdfc", "encuredrdp"], "url": ["sb", "li", "location", "build", "ul", "conn", "nl", "mount", "str", "base", "log", "file", "loc", "l", "b", "web", "https", "r", "client", "ssl", "cert", "browser", "ls", "open", "sl", "address", "name", "ur", "p", "http", "service", "con", "ll", "link", "URL", "m", "socket", "resource", "Url"], "connection": ["c", "generation", "io", "in", "conn", "server", "ticket", "document", "l", "relation", "using", "statement", "result", "still", "web", "https", "session", "creator", "client", "established", "index", "application", "open", "connected", "database", "communication", "command", "n", "position", "description", "network", "channel", "number", "con", "Connection", "link", "response", "context", "condition", "output", "message", "entry", "socket", "handler", "function", "resource", "ion", "writer", "connect"], "lastUser": ["LastUser", "LastCategory", "lastCategory", "latestCategory", "LastAuthor", " lastAuthor", "latestAuthor", "latestDate", " lastDate", "lastDate", "latestUser", "lastAuthor", "LastDate", " lastCategory"], "out": ["io", "v", "gr", "write", "OUT", "in", "inv", "conn", "rem", "help", "server", "raw", "log", "pool", "print", "inner", "serv", "at", "ent", "sys", "client", "cmd", "line", "cache", "check", "res", "err", "obj", "chain", "nt", "up", "format", "conv", "n", "screen", "co", "pretty", "p", "init", "timeout", "json", "all", "o", "list", "net", "query", "con", "conf", "outs", "it", "ch", "output", "Out", "report", "ex", "null", "to", "table", "writer", "cont", "ou", "window", "aos", "set", "txt"]}}
{"id1": "8973505", "id2": "16308040", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean update(String dbName, Query[] queries) throws ServiceException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        int rows = 0;\n        try {\n            con = getDbConnection().getConnection(dbName);\n            con.setAutoCommit(false);\n            for (int i = 0; i < queries.length; i++) {\n                Query query = queries[i];\n                System.out.println(query.getSql());\n                pstmt = con.prepareStatement(query.getSql());\n                addParametersToQuery(query, pstmt);\n                rows += pstmt.executeUpdate();\n            }\n            con.commit();\n            return rows > 0;\n        } catch (DbException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } catch (SQLException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } finally {\n            closeConnection(con, pstmt, null);\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["readfileName", "writeFileInfo", "writeContentName", "writePageType", "readfiletype", "readFiletype", "writefileInfo", "writeFileName", "writeContentInfo", "readFileType", "writefiletype", "readfileType", "readFileName", "writefileType", "writeContentType", "writefileName", "writePageInfo", "readFileInfo", "readfileInfo", "writeContenttype", "writeFiletype", "writePagetype", "writePageName"], "uriFile": ["iriFile", "rangeData", "uriData", "filenameFile", "urifile", "uriFiles", "filefile", "uriFilename", "rangefile", "fileFiles", "fileFile", "filenameFiles", "filenameFilename", "fileFilename", "URIfile", "uriFILE", "rangeFile", "irifile", "iriData", "filenamefile", "URIFILE", "iriFILE", "URIFiles", "URIData", "URIFile", "rangeFILE", "URIFilename"], "outputfile": ["inputbase", "Outputfile", "OutputFILE", "imageFile", "outFile", "Outputport", "inputFILE", "inputfile", "outputbase", "imageport", " outputbase", "outputport", "outputFILE", "outf", "outfile", "inputport", "OutputFile", "outputFile", "outputf", "inputFile", "outbase", "imagefile", " outputFile", "inputf", " outputf", "imageFILE"], "num": ["np", "count", "um", "max", "current", "multi", "nom", "total", "mult", "add", "alph", "x", "no", "index", "zero", "check", "end", "n", "Number", "NUM", "all", "Num", "number", "required", "nb", "con", "done", "random", "m", "nm", "cmp", "nam", "mon"], "writer": ["memory", "director", "wire", "data", "layer", "author", "ner", "driver", "riter", "term", "maker", "processor", "writ", "service", "writers", "editor", "RW", "written", "read", "worker", "ener", "server", "external", "file", "liner", "inner", "loader", "timer", "creator", "client", "writing", "builder", "caster", "Writer", "wright", "event", "record", "link", "entry", "function", "window", "ender", "buffer", "write", "commit", "stream", "comment", "document", "Reader", "storage", "player", "operator", "er", "journal", "wrapper", "network", "thus", "handler", "to", "resource", "owner", "table", "utils", "linger", "widget", "manager", "connection", "usher", "test", "flush", "console", "will", "format", "variable", "width", "w", "runner", "iterator"], "uri": ["du", "location", "obo", "doi", "qu", "uno", "origin", "uni", "hi", "browser", "reference", "ource", "address", "ni", "href", "directory", "URI", "ei", "basic", "via", "ir", "subject", "bid", "remote", "rid", "details", "multi", "file", "username", "inner", "prefix", "pi", "uu", "iterator", "iri", "qi", "link", "filename", "hyper", "unit", "copy", "range", "uid", "id", "user", "mi", "umi", "phrase", "image", "wiki", "https", "ref", " URI", "channel", "query", "resource", "source", "ip", "general", "phi", "connection", "ui", "result", "queue", "chain", "ur", "folder", "description", "http", "ugi", "verb", "domain", "i", "ri", "form", "sofar"], "counter": ["ctr", "count", "memory", "buffer", "manager", "frequency", "instance", "clock", "mill", "mr", "nr", "TER", "order", "book", "scope", "controller", "total", "ounter", "card", "currency", "const", "inner", "phrase", "Counter", "continue", "timer", "common", "loader", "machine", "creator", "browser", "mer", "pointer", "ier", "index", "time", "term", "outer", "conv", "cover", "loop", "amount", "coll", "processor", "another", "cookie", "norm", "number", "finder", "container", "meter", "sequence", "context", "message", "walker", "entry", "random", "editor", "cms", "ter", "money", "key", "system", "iterator"], "reader": ["yer", "read", "buffer", "method", "rl", "rx", "server", "file", "layer", "liner", "document", "inner", "loader", "dd", "Reader", "ro", "iter", "timer", "parser", "older", "ner", "r", "driver", "player", "input", "upper", "rar", "address", "iterator", "er", "builder", "journal", "processor", "redo", "row", "roller", "context", "runner", "entry", "handler", "resource", "editor"], "url": ["dl", "li", "location", "build", "re", "nl", "mount", "str", "base", "loc", "l", "gl", "web", "google", "il", "https", "r", "client", "browser", "ssl", "www", "open", "mail", "ref", "sl", "address", "name", "bel", "ur", "get", "github", "http", "hl", "ll", "link", "rel", "URL", "char", "resource", "Url"], "myConnection": ["thisConnection", "myConn", "myconnection", "myLink", "newLink", "Myconnection", "MyLink", "MyConnection", " myConnector", "MyConnector", "newConnection", "yourConnector", "yourConnection", "myConnect", "thisConn", " myconnection", "newConn", " myConn", "thisLink", "thisConnect", " myConnect", "newConnect", "yourconnection", "myConnector", "yourLink", " myLink"], "myReader": ["myFr", "myWriter", " myParser", "MyWriter", "mxSer", "yourReader", " mySer", " myFr", "myParser", "mySer", "yFr", "MyRead", "mxReader", "yourParser", "myRead", "yWriter", "yourWriter", "MyParser", "yReader", "mxFr", " myRead", "ySer", " myWriter", "yourRead", "MyReader", "mxWriter"], "line": ["ip", "text", "le", "detail", "lin", "lane", "inline", "range", "point", "part", "user", "comment", " Line", "log", "raw", "ode", "liner", "LINE", "l", " LINE", "ln", "trace", "cell", "body", "ge", "Line", "eline", "iter", "lo", "normal", "stroke", "definition", "cli", "ole", "no", "email", "rule", "ine", "side", "online", "frame", "channel", "row", "edge", "one", "link", "sample", "block", "sequence", "message", "char", "entry", "label", "style", "code", "word", "page"], "linecount": ["linnumber", " lineCount", "strokenumber", "elinecounter", "linconsider", " linenumber", "Linecount", "lineconsider", " lineconst", "Linefound", "linefound", "inlineconst", "linelength", "lineamount", "linercount", "LineCount", "lincount", "Lineconfig", "elinecount", "elineconst", " lineconfig", "inlinecount", "linecounter", "linerconfig", "strokeconsider", "lineconfig", " linecounter", "linenumber", "inlinelength", "linerCount", "linerfound", "inlinecounter", " lineconsider", " linefound", "lineconst", "lineCount", " linelength", " lineamount", "strokecount", "elinelength", "linamount", "strokeamount"], "hasOWL": ["hasOWLP", "hasOWNLP", " hasEWLP", "hasOWB", " hasOWSLP", " hasEWLS", " hasOWNL", "hasSOLS", " hasOWLP", "hasEWR", "hasOWSR", " hasOWSR", "hasEWL", "hasOWSB", "hasOWSS", "HasOWS", "hasEWLP", "hasOWSL", "HasOWSB", "hasROL", "hasEWS", "HasOWSLP", "hasOHS", "hasOHL", "hasSOR", " hasEWR", "hasEWB", " hasOWSNL", "hasOWNL", " hasOWR", " hasEWL", "hasRONL", "hasOWS", "HasOWL", "HasOWB", "hasOWSNL", "hasOWNNL", "hasOWSLP", "hasEWLS", "hasOHLP", " hasOWLS", "hasOWR", "hasROLP", "hasOWSLS", "hasOWNR", "HasOWSS", "hasOWLS", "HasOWSL", "hasOHB", "hasSOLP", " hasOWSL", "HasOWLP", "hasROR", "hasSOL"], "hasRDFS": ["hasRDFM", "hasXDSDS", "hasRDSCS", "hasRdfs", "hasRRIs", "hasORDFM", "hasXDFM", "hasXDSM", "hasORDSS", "hasRDFB", "hasORDFS", "hasRMLS", "hasRdfS", "hasRdfB", "hasSRDFB", "hasSRDSS", "hasRDFs", "hasRNFs", "hasXDFS", "hasSRDFS", "hasXDSS", "hasRNFDS", "hasXDSs", "hasSRDSB", "hasSRDFCS", "hasRDSB", "hasRDSM", "hasRNFS", "hasRDSS", "hasRRICS", "hasORDFs", "hasRMLs", "hasRNFM", "hasRdfM", "hasORDSs", "hasRdfCS", "hasRDFDS", "hasORDSM", "hasRMLDS", "hasXDFDS", "hasSRDFs", "hasRdfDS", "hasRDSs", "hasRRIS", "hasSRDSs", "hasRMLM", "hasSRDSCS", "hasXDFs", "hasRRIB", "hasORDSDS", "hasRDSDS", "hasORDFDS", "hasRDFCS"], "hasRDF": ["hasRCCD", " hasRDR", " hasDdf", "hsRDT", "hasRDS", "hasRDI", "hasREDI", "hasREDT", "hsRDF", " hasRRDF", "hasRRDS", "hasRTNF", " hasRRDR", " hasRCD", "hasRRCD", " hasRRDS", "hsRRDF", "hasRADS", "hasRRdf", " hasDDF", "hsRDS", "hasRRDR", "hasORDF", "hasRdf", "hasRRDT", "hasRNF", "hasRTDS", "hasRCDF", "hasRCD", "hasRDR", " hasDNF", "hasRRDI", "hasREDF", " hasRRNF", " hasRDS", "hasDCD", "hasRTDR", "hasRADT", "hasDdf", "hsRRDS", "hasRADF", "hasORNF", "hsRDI", "hsRRDT", " hasRdf", " hasDCD", "hasRADI", "hasRRDF", "hasDDF", "hasRCNF", "hasORDS", "hasRDT", "hasDNF", "hasORDR", "hasRRNF", "hasRTDF", "hasRCdf", "hsRRDI", "hasREDS", " hasRNF"]}}
{"id1": "8093133", "id2": "22431487", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlFormWeb", "loadXmlAsWeb", "loadXMLFormFile", "loadXMLFromURL", "loadXmlFromWeb", "loadXmlFormURL", "loadXmlFromURL", "loadXmlFromFile", "loadXmlWithUrl", "loadXmlAsURL", "loadXmlWithFile", "loadXMLFormUrl", "loadXmlAsFile", "loadXmlFormFile", "loadXMLFromFile", "loadXmlWithWeb", "loadXmlAsUrl", "loadXMLFromWeb", "loadXMLFromUrl", "loadXMLFormURL", "loadXMLFormWeb", "loadXmlWithURL", "loadXmlFormUrl"], "url": ["location", "request", "build", "in", "host", "nl", "str", "base", "html", "user", "id", "u", "log", "file", "loc", "document", "l", "b", "web", "uri", "ssl", "path", "input", "res", "open", "job", "sl", "address", "name", "n", "bel", "ur", "get", "http", "ll", "link", "domain", "abs", "URL", "char", "xml", "Url", "page"], "timeout": ["version", "t", "io", "unit", "buffer", "frequency", "type", "monitor", "padding", "max", "server", "length", "total", "delay", "course", "blocking", "limit", "sleep", "out", "client", "duration", "time", "policy", "term", "resolution", "amount", "Timeout", "password", "capacity", "height", "network", "number", "directory", "until", "size", "seconds", "it", "period", "latest", "wait", "exclusive", "to", "mode", "window", "OUT"], "xmlType": ["fileType", "xmlStyle", "xmlUnit", "complexUnit", "xmltype", " xmlTypes", "xmlTypes", " xmlUnit", "xmlTyp", "complextype", "fileBlock", "xmlBlock", " xmltype", "imageStyle", "mlUnit", "imageTypes", "complexType", "imageBlock", "imageType", "mltype", "mlType", " xmlTyp", "fileStyle", " xmlStyle", "complexTyp", "mlTyp", " xmlBlock", "fileTypes"], "connection": ["c", "generation", "io", "creation", "usage", "close", "manager", "conn", "cone", "user", "relation", "computer", "statement", "still", "uri", "session", "creator", "client", "established", "pointer", "reference", "application", "connected", "open", "database", "communication", "command", "position", "city", "builder", "description", "network", "character", "channel", "directory", "number", "con", "Connection", "link", "response", "opening", "condition", "subject", "entry", "internet", "socket", "config", "to", "resource", "ion", "nc", "current", "connect", "system"], "buffInputStream": ["BuffInputStream", "buffEarField", "buffIOForm", "buffInputChannel", "buffEarSteam", "buffEarForm", "buffEntityChannel", "buffInputForm", "BuffInputChannel", "buffIOSteam", "buffIOStream", "buffOutputStream", "buffEntityForm", "BuffOutputField", "BuffInputField", "BuffOutputForm", "buffOutputSteam", "BuffInputSteam", "buffIOField", "buffEarStream", "BuffOutputChannel", "BuffOutputSteam", "buffOutputChannel", "BuffInputForm", "buffEntityStream", "buffOutputField", "BuffOutputStream", "buffInputField", "buffOutputForm", "buffInputSteam"]}}
{"id1": "22844377", "id2": "9450274", "code1": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 1, "substitutes": {"scrapeForIsbns": ["scrapeForISbbn", "scrapeForIsrbms", "scrapeForISBbn", "scrapeForIsbbns", "scrapeForIsbms", "scrapeForIsBns", "scrapeForIsrbbn", "scrapeForISBms", "scrapeForIsrbns", "scrapeForIsbbn", "scrapeForIsbcs", "scrapeForISbcs", "scrapeForIsbbbn", "scrapeForIsbbms", "scrapeForISbns", "scrapeForIsBbn", "scrapeForISbms", "scrapeForIsbbcs", "scrapeForIsrbcs", "scrapeForISBns", "scrapeForIsBms", "scrapeForISBcs", "scrapeForIsBcs"], "url": ["dl", "build", "ul", "rl", "nl", "stream", "mount", "html", "u", "el", "file", "download", "loc", "l", "gl", "web", "loader", "uri", "https", "string", "r", "ssl", "browser", "ls", "open", "sl", "address", "bl", "ur", "f", "http", "ll", "link", "URL", "char", "resource", "Url"], "matches": ["exches", "matets", "matums", "matizes", "exchers", "matchedatches", "mataches", "matchedches", "expects", " matatches", "ischers", "ispects", "retches", "retchers", "isets", "exets", "matchedaches", " matpects", " matchers", "matchches", "parums", "matchedchers", " matums", "parches", "parizes", " matizes", "matchaches", " matets", "parchers", " mataches", "retums", "matatches", "matchchers", "matpects", "isches", "matchers", "matchatches", "retizes"], "p": ["c", "t", "np", "lp", "ps", "tp", "pa", "pn", "re", "pr", "jp", "pt", "parser", "cp", "q", "r", "proc", "pattern", "hp", "P", "par", "policy", "up", "pkg", "pe", "per", "perm", "pl", "pat", "pb", "ping", "pc", "bp", "sp", "pro", "pp", "g", "h", "ap", "rep"], "m": ["pm", "t", "managed", "mat", "v", "bm", "mr", "sm", "md", "mt", "mi", "mod", "l", "om", "mun", "mate", "mut", "e", "hm", "mc", "r", "mask", "mo", "dm", "mac", "vm", "tm", "er", "n", "mem", "me", "mp", "M", "d", "perm", "all", "match", "rm", "em", "man", "am", "meter", "cm", "sim", "j", "met", "gm", "arm", "mu", "g", "model", "mm", "lem", "ms"], "i": ["ip", "c", "t", "li", "io", "y", "count", "v", "bi", "ii", "phi", "multi", "mill", "I", "id", "u", "xi", "ui", "ind", "mi", "iu", "batch", "oi", "l", "e", "gi", " ii", "im", "hi", "x", "is", "ie", "ki", "ti", "index", "ci", "pi", "a", "n", "me", "qi", "f", "ia", "si", "init", "ix", "di", "ini", "ei", "it", "yi", "sim", "j", "ai", "us", "ic", "ri"], "in": ["fr", "io", "reader", "bin", "din", "dr", "stream", "inc", "rin", "ind", "el", "l", "b", "inner", "inf", "r", "out", "is", "input", "al", "In", "n", "f", "info", "o", "IN", "it", "from", "ins", "inn", "cin", "us", "ic"], "br": ["fr", "bd", "io", "vr", "gr", "Br", "bm", "dr", "bh", "bi", "shr", "bs", "mr", "lr", "pr", "b", "bt", "wr", "ber", "ro", "yr", "r", "out", "browser", "tr", "hr", "bl", "rb", "er", "buf", "bro", "be", "bp", "ch", "cr", "BR", "kr"], "str": ["c", "fr", "t", "text", "cl", "v", "dr", "enc", "Str", "arr", "cont", "re", "part", "print", "l", "b", "comm", "bc", "hex", "e", "string", "del", "r", "piece", "line", "tr", "sent", "obj", "bl", "spec", "name", "chain", "n", "exec", "list", "cur", "STR", "w", "ch", "vol", "st", "j", "char", "syn", "g", "msg", "sp", "s", "source", "form", "txt"]}}
{"id1": "17111859", "id2": "7948308", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"getHash": ["createHash", "getKey", " gethash", "GetSum", "getSum", "createhash", "createKey", "GetKey", " getSum", "gethash", " getKey", "Gethash", "createSum", "GetHash"], "string": ["content", "text", "object", "strings", "v", "buffer", "type", "instance", "status", "data", "ring", "key", "space", "comment", "attribute", "test", "prefix", "dump", "ident", "pattern", "hash", "input", "cache", "address", "chain", "name", "format", "password", "array", "pair", "list", "value", "sample", "message", "sql", "char", "null", "function", "s", "word", "source", "filename"], "hashTime": ["messageTime", "HashTime", "messageTimes", "clockLength", "HashTimer", "hashLock", "HashTimes", "hashLength", "clockTimer", "HashLock", "messageLength", "clockTimeout", " hashTimer", "messageTimeout", "hashTimer", "hashTimes", "hashTimeout", "clockTime", " hashTimeout", " hashLock", " hashTimes", "messageLock", "messageTimer", " hashLength"], "md5": [" md3", " Md5", " md1", "det2", " md512", " md10", " MD10", "md1", "hash512", "det3", "MD512", "dig45", " MDock", " MD3", " Md55", "md55", "MD3", "md512", "hash3", " Mdock", "mdock", "md3", " MD2", "MD45", "md45", " md2", "dig1", " md55", " MD5", "MD1", "MD10", "dig2", "MD2", "md10", " md45", "hash5", "det5", " Md3", "MD5", "hash2", "dig5", " MD55", " mdock", "md2"], "result": ["results", "product", "buffer", "answer", "comment", "total", "test", "card", "complete", "currency", "mate", "hex", "su", "r", "cache", "res", "RESULTS", "success", "work", "chain", "reverse", "params", "comb", "diff", "comp", "array", "pair", "search", "match", "list", "cur", "row", "response", "sequence", "valid", "correct", "output", "ret", "report", "done", "Result", "table", "current", "cup"], "hexString": [" hexBuffer", " hexCharacter", " HexResult", "hexResult", "exResult", "hexChain", "hexCharacter", "exStr", " hexChain", "exChain", " hexResult", "alphChain", "hexArray", "exString", " HexStr", " hexArray", "alphCharacter", "charResult", "hexBuffer", " HexArray", "exBuffer", "alphString", "hexStr", "charBuffer", "alphArray", "charString", " hexStr", "exCharacter", "charArray", " HexString", "exArray"], "i": ["ip", "li", "y", "io", "v", "bi", "in", "ii", "k", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "mi", "l", "gu", "e", "gi", "uri", "q", "hi", "cli", "x", "is", "ki", "ti", "index", "ci", "pi", "chain", "ji", "a", "n", "me", "qi", "si", "ix", "di", "o", "ei", "ini", "it", "sequence", "sim", "j", "my", "\u0438", "m", "z", "ai", "to", "us", "ic"], "str": ["text", "fr", "ctr", "t", "buffer", "stable", "dr", "enc", "status", "Str", "arr", "data", "hex", "r", "out", "hash", "tr", "cache", "res", "br", "obj", "chain", "name", "n", "p", "sw", "STR", "sequence", "st", "ret", "output", "char", "cr", "msg", "sp", "key", "txt"]}}
{"id1": "2396191", "id2": "12454178", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFormHTTPSafe", "getLinksFromURIFast", "getLinksFromUrlSafe", "getLinksFromURLfast", "getLinksFormHTTPFast", "getLinksFromHTTPfast", "getLinksFormURLfast", "getLinksFromHTTPFast", "getLinksFromUrlfast", "getLinksFromURLSafe", "getLinksFromURISafe", "getLinksFormURLFast", "getLinksFormHTTPfast", "getLinksFromHTTPSafe", "getLinksFromURIfast", "getLinksFromUrlFast", "getLinksFormURLSafe"], "p_url": ["x3lr", "pingYurl", "pYurl", "pYpage", "p___lr", "postonurl", "p_org", "primaryongurl", "admin_uid", "p3uri", "x3dir", "pingYpage", "p___page", "p_page", "ping_url", "adminoymail", "pYlr", "admin_url", "admin_mail", "primary_url", "p_line", "ping_page", "pswlink", "primaryongorg", "p6url", "ping_line", "postonemail", "poreurl", "x3url", "p6browser", "pongURL", "x3uri", "p_uri", "primary_org", "pYline", "vp_url", "private_html", "postonURL", "pongemail", "adminoydir", "ping_lr", "p6dir", "p3url", "p_html", "poymail", "p64url", "private_browser", "private_url", "porehtml", "primaryongemail", "adminoyuid", "p6html", "p_uid", "adminoyurl", "p_browser", "p___line", "porebrowser", "p_mail", "pingYlr", "p_lr", "poydir", "private_dir", "primary_email", "primaryongURL", "pongurl", "poyurl", "pswurl", "p_dir", "p64org", "postonorg", "poredir", "admin_dir", "primary_URL", "x_uri", "p3lr", "p64email", "vp_lr", "p___url", "pswjson", "p3dir", "pingYline", "vp_link", "poyuid", "vp_json", "p64URL", "p_URL", "x_lr", "p_email", "pswlr", "p_link", "pongorg", "p_json"], "x_url": ["xJweb", " x_cn", "xJurl", "x_net", " x_log", "x_web", "x_log", " x_web", "xJnet", "x_ls", " x_net", "x_cn", " x_ls", "xJlog"], "x_conn": ["x3connection", " x_connection", "p_con", "x_ws", " x_nt", "x3client", "x3conn", "p_conn", "p_connection", "x_con", "p_ws", "x3nt", "x_connection", "x_nt", "x_client", " x_client"], "x_is_reader": ["x_ais_reader", "x_ais_parser", "x_isresparser", "x_is_read", "x_is2reader", "x_is_Reader", "x_is2writer", "x_is_rx", "x_is2Reader", "x_ais_writer", "x_ais_rx", "x_is2read", "x_isreswriter", "x_isresreader", "x_isresrx", "x_is_parser", "x_is_writer"], "x_reader": ["rx_buffer", "ex_rr", "x8rot", "ex_stream", "x8reader", "x_rr", "rx_rot", "ex_writer", "x_writer", "x_buffer", "ex_reader", "x_stream", "rx_reader", "x_rot", "rx_writer", "x8buffer", "x8writer"], "x_line": ["xmyline", "x_print", "ex_page", "xLEpage", "ex_line", "xLEline", "xmyiter", "x_____match", "ex_stream", "xmystream", "ex_link", "x_____page", "x_____print", "ex_iter", "xmypage", "x_route", " x_print", "xLEstream", "x_____line", "x_iter", "x_stream", "ex_route", "xLEiter"], "e": ["et", "ye", "c", "t", "ele", "le", "ae", "y", "fe", "ev", "te", "eur", "se", "eu", "es", "re", "oe", "eeee", "ef", "ne", "u", "el", "ce", "en", "eps", "l", "ze", "ent", "ge", "eg", "r", "xe", "x", "ie", "eb", "ue", "de", "err", "ere", "end", "er", "ec", "a", "n", "me", "exp", "pe", "d", "f", "be", "element", "o", "ei", "he", "EEE", "event", "one", "ea", "we", "ee", "E", "m", "g", "h", "ed"], "x_match": ["x__find", "ex_look", "x___match", "rx_tag", "xi_move", "x___move", " x_find", "x__result", "x_tag", "x_mat", "x___fire", "rx_match", "x2match", "x_entry", " x_mat", "x67process", "x67mat", "x10member", "ex_result", "x10result", " x2mat", "x___mat", "x10match", " x_member", "x_look", "x___member", " x2process", " x_process", "ex_match", "x2mat", "xi_match", "x2process", "rx_member", "ex_member", "x_process", "x10entry", "x_fire", "x67match", "x_message", "xi_message", "x_move", "x___message", " x2member", "x67member", " x2match", "x__match", "x__mat", "x___tag", "x_find", "ex_entry", "x_member", "x2member", "xi_fire", "rx_mat"], "x_dir": ["ex_path", "ex_div", "x_div", "x_file", "ex_file", "x_path", "x5path", "ex_dir", "x5dir", "x5div", "x5file"], "x_root": ["inx_parent", "x_parent", "inx7parent", "x7path", "inx_path", "x_target", "inx7root", "x__parent", "x__root", "x7target", "x_path", "inx_target", "x__target", "inx_root", "inx7target", "x7parent", "x__path", "inx7path", "x7root"], "x_links": ["x__pages", "x__lines", "x_lines", "x_relations", "x_pages", "x__links", " x_pages", "x__relations", " x_relations", " x_lines"], "x_texts": ["x_paths", "x_lengthes", "x__logls", "x_textls", "x_logls", "x_pathls", "x_textes", "x__logsets", "x_logsets", "x_lengthsets", "x_pathes", "x_logs", "x__logs", "x_pathsets", "x__textsets", "x__loges", "x__textes", "x__texts", "x__textls", "x_textsets", "x_lengths", "x_loges", "x_lengthls"], "x_buf": ["x___Buff", "ex2buf", "ex_temp", " x_buff", " x_uf", "x7buf", " x_buffer", " x2buff", "x2buf", "x_bag", "x7buff", "x2pool", "x_buff", "x2uf", "ex_bag", "ex_Buff", "ex_buf", "ex2temp", "x64Buff", " x2temp", "ex2bag", " x_pool", "x_pool", "x_Buff", " x2pool", " x2buf", "x2buffer", "x2buff", "x64buf", "x7temp", "x2Buff", "x_buffer", "ex2Buff", "x2bag", "x___temp", " x_temp", "x2temp", "x_uf", "x7pool", "x___bag", "x64bag", "x64temp", "x___buf", "x_temp"], "x_matches": ["x_matists", "x2matters", "x_maaches", "x2patcher", "x__matches", "x__matists", "x2patches", "x2patters", "x_matchchers", "x_attches", "x_machers", "x_memaches", "x_actches", "x_morcher", "x_matqs", "x2patets", "x_formatices", "x_morters", "x_Matqs", "x_masets", "x_patchers", "x__matets", "x_catets", "x_maches", "x_formatchers", "x_matchers", "x2matcher", "x_catters", "x_actices", "x_Mataches", "x_matets", "x_matcher", "x_matchcher", "x__masets", "x_morches", "x_maschers", "x_memches", "x_matices", "x_mataches", "x_masists", "x_catists", "x_actcher", "x_Matcher", "x2matches", "x_memchers", "x_matchets", "x_actchers", "x_Matchers", "x_patcher", "x_memqs", "x_masches", "x__matchers", "x_Matches", "x_attets", "x_Matices", "x_morets", "x__masches", "x_attchers", "x2matets", "x_matters", "x_matchches", "x_patches", "x_patters", "x_catchers", "x_catches", "x_patets", "x__masists", "x_maqs", "x_attists", "x_formatches", "x__maschers", "x_matchters", "x_formatcher"], "x_page": ["x_message", "xhomeport", "x_net", "x_port", "p_net", "x_pp", " x_pp", "p_line", " x_port", "p_page", "xtpage", "xtmessage", "xhomepage", "xhomeline", "xturl", "xtline", " x_message", "xhomepp"], "x_link": ["x_location", "x42page", "x42link", " x_location", "x42path", "x_path", "xe_link", " x_path", "x_ink", "xe_ink", "xe_links", "x42location", "xe_url"], "i": ["ip", "ori", "fire", "li", "io", "y", "v", "bi", "in", "ii", "phi", "multi", "key", "xi", "I", "u", "id", "ui", "this", "mi", "batch", "oi", "PI", "gi", "im", "iter", "origin", "hi", "cli", "ami", "x", "is", "ki", "ti", "ci", "pi", "chain", "ji", "iq", "n", "me", "qi", "si", "init", "ix", "di", "info", "ini", "ims", "it", "sim", "j", "m", "fi", "ai", "us", "ic"]}}
{"id1": "12039034", "id2": "12389873", "code1": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "code2": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 0, "substitutes": {"importRoles": ["importRles", "importPole", "importPules", " importRules", "importPles", "importResoles", "importResole", " importRole", "importResles", "importResules", "importPoles", "importRole", "importRules", " importRles"], "urlString": [" urlSource", " urlList", " URLString", "urlRest", "uriSource", "Urlstring", " urlstring", "UrlStr", " URLList", "urlList", "uriStr", " urlRest", " curlString", " curlRest", " curlStr", "uristring", " URLRest", "urlStr", "UrlString", " curlList", "urlSource", "UrlSource", "uriString", " URLStr", "urlstring", " urlStr"], "results": ["parents", "features", "modules", "places", "details", "locks", "maps", " Results", "posts", "es", "parts", "products", "olds", "forms", "csv", "images", "ults", "relations", "roots", "result", "rings", "photos", "options", "games", "ces", "items", "rows", "changes", "finals", "prints", "reports", "objects", "res", "RESULTS", "abilities", "successful", "tops", "its", "chains", "helps", "artifacts", "properties", "Results", "ands", "works", "uploads", "runs", "sets", "rates", "outs", "reads", "blocks", "users", "tests", "values", "settings", "pieces", "times", "s", "vals"], "url": ["lb", "dl", "ul", "re", "nl", "mount", "str", "base", "u", "el", "file", "loc", "l", "b", "web", "gl", "uri", "q", "r", "ssl", "browser", "open", "mail", "sl", "ur", "get", "p", "f", "pl", "http", "ll", "link", "rel", "ret", "URL", "char", "resource", "Url"], "in": ["io", "reader", "bin", "buffer", "din", "inc", "rin", "ind", "el", "file", "ill", "inner", "l", "serv", "inf", "body", "iter", "out", "is", "input", "In", "on", "get", "f", "fs", "conf", "IN", "con", "from", "sum", "ins", "inn", "m", "cin", "doc", "i", "by", "and"], "buff": ["sb", "bg", "fr", "ack", "tf", "tmp", "raf", "Buffer", "pdf", "buffer", "bound", "bm", "build", "off", "ff", "printf", "bed", "bs", "quit", "bind", "Buff", "fb", "col", "butt", "urg", "b", "rend", "form", "aux", "ck", "roc", "alph", "cmd", "uf", "mb", "nd", "cb", "ob", "hold", "cond", "prof", "zz", "tm", "conv", "mem", "supp", "buf", "builder", "comp", "pb", "row", "bo", "tab", "uff", "zip", "qq", "grow", "bb", "txt"], "line": ["text", "le", "buffer", "lin", "lane", "inline", "range", "point", "nl", "str", "comment", "log", "file", "LINE", "liner", "l", "ln", "e", "cell", "body", "iter", "Line", "string", "eline", "lo", "out", "cmd", "stroke", "ice", "lf", "no", "email", "chain", "ine", "command", "n", "note", "pe", "len", "frame", "channel", "row", "record", "link", "lines", "block", "sample", "entry", "label", "code", "msg", "node", "word", "page", "header"], "name": ["named", "zone", "instance", "member", "Name", "spe", "part", "id", "ame", "prefix", "common", "ident", "string", "profile", "alias", "title", "n", "mem", " names", "NAME", "ni", "names", "number", "value", "num", "cn", "sequence", "cap", "group", "person", "role", " Name", "nm", "node", "nam", "ename", "ns", "qual", "key", " NAME", "system"]}}
{"id1": "804637", "id2": "15445861", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "9996334", "id2": "7948308", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"generateToken": [" GeneratesToken", "generateCode", " GeneratesString", " GeneratesKey", " GenerateToken", " GenerateString", "generatesCode", " GeneratesCode", "generatesToken", "generatesString", "generatorString", "generatesKey", "generateKey", "generatorCode", " GenerateCode", "generatorToken", "generatorKey", "generateString", " GenerateKey"], "code": ["content", "codes", "text", "c", "close", "buffer", "state", "data", "str", "html", "ce", "ode", "test", "component", "e", "string", "x", "hash", "address", "reason", "name", "command", "password", "Code", "token", "hello", "value", "template", "response", "sequence", "message", "char", "function", "error", "source", "rice"], "md": ["pm", "bd", "MD", "dh", "pdf", "det", "cd", "med", "mat", "dr", "sd", "sm", "mand", "mt", "ind", "mod", "add", "dd", "hd", "mc", "cmd", "ds", "df", "mk", "mb", "nd", "mo", "dm", "amd", "de", "pd", "mp", "d", "der", "di", "ld", "rm", "mn", "od", "desc", "m", "red", "msg", "mm", "mg", "ms"], "bytes": ["gs", "terms", "strings", "binary", "pdf", "results", "classes", "es", "bs", "parts", "raw", "gets", "b", "hex", "bits", "ds", "versions", "pages", "objects", "unks", "bps", "its", "Bytes", "words", "gb", "outs", "lines", "blocks", "seconds", "users", "values", "files", "latest", "groups", "pieces", "steps", "keys", "s", "vals", "ents", "tes", "ms"]}}
{"id1": "2642914", "id2": "6171406", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGsz", "addFileToTarGp", "addFileToTarGst", "addFileToTarJzip", "addFileToTarRzip", "addFileToTarGez", "addFileToTarBt", "addFileToTarRw", "addFileToTarRx", "addFileToTarBw", "addFileToTarJz", "addFileToTarGep", "addFileToTarGx", "addFileToTarGet", "addFileToTarBzip", "addFileToTarGzip", "addFileToTarRz", "addFileToTarGsp", "addFileToTarJw", "addFileToTarGszip", "addFileToTarBp", "addFileToTarGw", "addFileToTarBx", "addFileToTarJx", "addFileToTarBz", "addFileToTarGt", "addFileToTarGezip"], "taro": [" tary", "ttara", "trro", "Tamo", "tary", "Targo", "taco", "staco", "temparo", "Tolan", "retaro", "tarro", "Tro", "toa", "tempargo", "Taco", "qtaro", "trary", "ktara", " targo", " toa", "ttaro", "margo", "thrar", "ttosa", "tara", "qtolan", "ktrar", "tory", " tosa", "stary", "thara", "stamo", "Taro", "qtro", "retara", "troa", " tarro", "tosa", "trar", "thosa", "ktaro", "stoa", "staro", "wro", "tempamo", "tolan", " trar", "stargo", "qtory", "tharo", "tamo", "wargo", "tro", "waro", "tempro", "retaco", "ktarro", "warro", "ttamo", "Tory", "starro", " taco", " tamo", "Tara", "Tarro", " tara", "tharro", "retamo", "maro", " tolan", "thamo", "mro", "targo", " tro", "stro", "marro", "traro", " tory"], "path": ["history", "text", "c", "th", "binding", "kind", "PATH", "key", "mount", "parts", "core", "full", "file", "ath", "print", "dir", "string", "transform", "pattern", "ref", "pi", "chain", "name", "root", "url", "project", "p", "local", "w", "ex", "entry", "m", "doc", "h", "clean", "Path"], "base": ["binding", "create", "buffer", "padding", "ase", "build", "based", "default", "part", "pad", "extra", "bf", "server", "full", "file", "bas", "b", "prefix", "bare", "common", "normal", "check", "family", "alias", "name", "start", "bad", "root", "absolute", "shadow", "relative", "Base", "template", "basic", "reset", "parent", "db"], "f": ["life", "c", "t", "fr", "tf", "y", "v", "rf", "fe", "fx", "fed", "fac", "bf", "fb", "fa", "file", "l", "b", "e", "inf", "fab", "xf", "far", "r", "af", "df", "uf", "lf", "fm", "fo", "ft", "p", "fd", "d", "perm", "fs", "o", "fp", "w", "fc", "fl", "fg", "elf", "fi", "F", "g", "sf", "i", "h", "cf", "alf", "form"], "entryName": ["ryName", "rowName", "rowType", "entryLetter", " entryname", "ryType", " entryType", "rowLetter", "EntryPath", "ryLetter", "elementKey", " entryLetter", "elementname", "EntryType", "entryKey", "cueType", "EntryName", "elementPath", " entryPath", "rowname", " entryKey", "entryPath", "cueName", "EntryKey", "entryType", "Entryname", "elementName", "ryname", "cueKey", "cuename", "entryname"], "goIn": ["goIns", "GoIns", " goIns", "poin", "GoIN", "GoIn", "moIN", "GoOut", "moIns", "goInput", " goOut", "goOut", "Goin", " goIN", "poOut", "moin", " goin", "moInput", "goIN", "goin", "poIN", "poIn", "geInput", "geIn", " goInput", "geIns", "gein", "moIn"], "tarEntry": ["rarEnt", "rarCategory", "tarCategory", " tarentry", "carEntry", "warEntry", "carEnt", " tarCategory", "rarItem", " tarComponent", "rarEntry", "tarItem", "rarComponent", "warEnt", "rarentry", "carentry", "tarentry", " tarItem", "tarEnt", "warComponent", "tarComponent", "warItem", " tarEnt", "carCategory"], "children": ["parents", "modules", "ml", "follow", "ps", "ul", "cloud", "each", "batch", "gall", "cs", "ports", "roots", "these", "balls", "ren", "items", "pages", "objects", "ls", "reports", "cache", "Children", "wn", "names", "all", "members", "los", "json", "fs", "kids", "jobs", "ll", "packages", "resources", "blocks", "users", "files", "stories", "groups", "hawks", "parent", "keys", "aos", "they", "many"], "child": ["c", "fr", "count", "follow", "close", "col", "id", "comment", "file", "batch", "l", "friend", "cell", "uncle", "q", "ph", "client", "Child", "lf", "cache", "job", "name", "cow", "handle", "fd", "row", "ll", "ch", "block", "char", "entry", "label", "last", "shell", "parent", "pixel", "zip", "brother", "background", "page", "key"]}}
{"id1": "13499897", "id2": "494226", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"CopyFile": ["Downloadfile", "DownloadDir", "Transferfile", " CopyPath", "DownloadPath", " Copyfile", "TransferPath", "CopyPath", " CopyDir", "Copyfile", "TransferDir", "CopyDir", "DownloadFile", "TransferFile"], "sourcefile": ["sourcepath", "ourceattribute", "ourcefile", "stylekey", "Sourceurl", "starturl", "ourceFile", "startpath", "ourcekey", "sourceFile", "sourceattribute", "styleFile", "stylefile", "srcattribute", "srcfile", "startfile", "SourceFile", " sourcepath", "startFile", "Sourcepath", "styleattribute", "srcFile", " sourceurl", "srckey", "sourcekey", "Sourcefile", " sourceFile", "sourceurl"], "destfile": ["Destile", "Desturl", "sourcepath", " destport", "temppath", "tempFile", "Destfilename", " destFile", "destport", "masterpath", "masterfile", "sourceFile", "sourceport", "sourcefilename", "sourcename", "destFILE", "masterFile", "Destfile", " destfilename", "destile", "Destpath", "DestFile", "tempFILE", "sourceile", "destpath", "srcfile", "resultfile", " destname", "tempfilename", " destile", "srcpath", "resultFile", "Destname", "destname", " desturl", "desturl", "masterFILE", "srcFile", "srcport", "destFile", " destpath", " destFILE", "resultpath", "resultfilename", "tempfile", "destfilename", "sourceurl"], "last": ["prev", "est", "count", "any", "top", "based", "max", "default", "strip", "base", "length", "this", "total", "rest", "full", "bottom", "region", "left", "most", "pop", "lot", "since", "nd", "index", "right", "end", "reverse", "old", "start", "Last", "shadow", "get", "after", "first", "dist", "ast", "size", "st", "latest", "master", "show", "recent", "good", "and"], "parent": ["parents", "ip", "fr", "pid", "where", "tmp", "pa", "tip", "padding", "request", "instance", "unit", "point", "part", "mother", "tree", "server", "prop", "full", "test", "pool", "prefix", "temp", "dir", "snap", "older", "shape", "missing", "child", "path", "paren", "family", "fat", "chain", "spec", "up", "global", "tar", "params", "root", "exp", "p", "folder", "per", "ma", "wrapper", "def", "master", "holder", "m", "owner", "sp", "page", "key", "home", "Parent", "and"], "f": ["c", "fr", "tf", "v", "rf", "fed", "fe", "part", "fac", "bf", "file", "l", "b", "e", "fab", "af", "df", "lf", "fm", "fw", "fo", "ft", "p", "of", "fd", "fs", "fp", "local", "w", "fc", "fl", "elf", "fi", "m", "F", "g", "sf", "h", "cf", "alf"], "srcChannel": ["sqCase", "ctrChain", "rcChannel", "srcCase", "rcChan", "subChannel", " srcChan", "instChan", "srcChain", "rcchannel", "sourceButton", " srcButton", "subPanel", "srcchannel", "rcChain", "sourcechannel", "curConnection", "curChannel", "curchannel", " srcChain", "instButton", "rcButton", " srcchannel", " srcConnection", "sourceChan", "subCase", "srcButton", "instchannel", "instChannel", "sqPanel", "srcChan", "subchannel", " srcCase", "curChan", "rcConnection", "sourceChannel", "srcPanel", " srcPanel", "ctrChannel", "ctrChan", "srcConnection", "ctrButton", "sqChannel", "sqchannel"], "dstChannel": ["distCategory", "dbrchannel", "dndChannel", "distCh", "dstchannel", "cdstButton", " dotChannel", "dndCh", "dotChannel", "dotConnection", "distButton", "dltCh", "ddrConnection", "dndCategory", "dstCategory", "dblChannel", "destCh", "deltChan", "cdistChannel", "dndButton", " dstConnection", " dstChan", "dltChannel", "dndChan", "cdistCategory", "destChannel", "drtCategory", "dotChan", "cdstChannel", "cdstCh", "ddrChan", " dotConnection", "cdstCategory", "dbrConnection", "dblCh", "drtChannel", " dstchannel", "dbrChan", "dstButton", "dltChan", "dstCh", "dltButton", "cdistButton", "destChan", "ddrchannel", "dblButton", "deltCh", "drtButton", "deltButton", "distChannel", "dstChan", "drtCh", "dotchannel", " dotchannel", "cdistCh", "ddrChannel", " dotChan", "dblChan", "deltChannel", "destButton", "dbrChannel", "dstConnection"]}}
{"id1": "16378239", "id2": "19096138", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"byReference": [" byResource", "ByResource", "forreference", "ByRef", "forReference", "byreference", "Byreference", "byResource", "forResource", "ByReference", "byRef", "forRef", " byreference", " byRef"], "inputStream": ["InputSteam", "readablestream", "readableStream", "inSteam", "readableSteam", "Inputstream", "inStream", "instream", "InputReader", "inputFile", "inputReader", "inputstream", " inputSteam", "InputStream", " inputReader", "InputFile", "inFile", " inputFile", "inputSteam", "readableReader", " inputstream"], "tempFile": ["tmpPath", " temporaryFiles", "TempChain", " tempUrl", "empFile", "tmpDirectory", "tempPlace", "TempDirectory", "empPlace", " tempChain", " temporaryfile", "poraryfile", "empName", "empPath", "TempFiles", "tmpfile", "TempFile", "tempDirectory", "poraryPlace", "Tempfile", "tempChain", " tempfile", "TempPath", "poraryUrl", "tempFiles", "tmpName", " temporaryChain", " tempFiles", "TempUrl", "tempName", "empDirectory", " tempDir", "tempDir", "empfile", "poraryName", "tempPath", "tempUrl", "poraryDir", "TempDir", "poraryFile", "tmpFile", "tmpPlace", "tempfile", " temporaryFile"], "out": ["t", "io", "v", "dis", "gr", "in", "os", "user", "auto", "OU", "file", "l", "serv", "aos", "ent", "sys", "oss", "as", "conv", "up", "n", "ao", "co", "all", "o", "net", "con", "one", "outs", "Out", "output", "sum", "lay", "ex", "null", "ins", "again", "to", "cos", "us", "writer", "s", "msg", "ou", "source", "OUT"]}}
{"id1": "822452", "id2": "8932510", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "8011262", "id2": "536614", "code1": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"uploadFile": ["uploadImage", "updatePath", "updateFilename", "UploadPage", "UploadImage", "createPath", "uploadPage", "updateImage", " uploadMessage", "updateFile", "uploadMessage", "createFilename", "updatePage", "uploadFilename", "updatefile", "createfile", "updateMessage", " uploadImage", " uploadPage", "createFile", "UploadMessage", "savefile", "saveFile", "saveFilename", "savePath", "uploadfile", "UploadFile", "uploadPath"], "end": ["ender", "est", "close", "default", "endif", "quit", "pad", "except", "stop", "order", "begin", "external", "comment", "rest", "bottom", "en", "hend", "join", "ended", "add", "post", "e", " End", "ent", "End", "ending", "pend", "ue", "right", "enter", "chain", "start", "END", "send", "use", "ord", "edge", "event", "ends", "die", "enable", "append", "entry", "reset", "pard", "empty", "ad", "ment", "drop", "and"], "twoHyphens": ["twohyphens", " twoHyphen", "twoPerskens", "secondhypkens", "secondhyphen", "twoHykens", "twohypphas", "threehyphes", "twoHyphers", "twoHyphen", "twoHyoms", "twoHaskens", "twoDiskens", "secondHyphen", "threeHypkens", "fourHypoms", "secondHyphens", "twoDisphas", "twoHyens", " twoHypkens", "twoHyhers", "twoHyhens", "twoHypkens", "twoHotens", "twoHyphes", "fourHypens", "twoHascludes", "fourHyens", "fourHyphes", "twoHypphas", "threehypkens", "twoHyhes", "secondhyphers", "threeHyphens", "twoPerscludes", "secondHyphers", "threehyphens", "twoHothes", "twoPershens", "threehypcludes", "twoHypoms", "threeHypcludes", "fourHyoms", "twohyphes", "twohyphen", "twohypkens", "threeHyphes", "twoHothens", "secondHypkens", "twoHypcludes", "twoHashes", "twohyphers", " twoHypphas", "twoPershes", "secondhyphens", "twoDishens", "twoDishen", "fourHyphens", "twohypcludes", "fourHyhens", "twoHashens", "twoHyhen", "fourHyhes", "twoHypens", "twoHotoms"], "boundary": ["bounditary", "mbARY", "commonaration", "banory", "terminaration", "boundory", "verbaries", "directionory", "boundaries", "boundaration", "mbory", "minary", "Boundangle", "boundARY", "commonitary", "commonaries", "bindory", "Boundory", "Boundary", "banaries", "terminory", "banary", "terminary", "verbARY", "verbaration", "boundangle", "commonary", "directionaries", "mbitary", "terminARY", "bindry", "commonory", "banry", "boundry", "verbary", "directionangle", "minARY", "minory", "mbary", "directionary", "bindary", "Boundaries", "terminaries", "bindangle", "commonARY", "minitary", "bindaries", "terminry"], "url": ["c", "dl", "ocl", "ml", "ul", "conn", "rl", "re", "nl", "cal", "uc", "str", "atl", "log", "loc", "l", "gl", "uri", "https", "il", "r", "client", "ssl", "ls", "gc", "open", "sl", "sur", "ur", "f", "pl", "http", "ll", "link", "URL", "fl", "ctrl", "Url"], "con": ["c", "ct", "cl", "can", "conn", "ver", "cont", "cal", "Con", "connection", "fac", "Conn", "col", "pen", "pos", "go", "func", "en", "loc", "const", "cs", "bc", "ln", "comm", "ain", "cp", "cc", "cmd", "client", "cert", "ls", "cons", "CON", "open", "don", "conv", "connect", "sur", "ran", "un", "co", "coll", "soc", "conf", "cur", "num", "cn", "cm", "pc", "fc", "fl", "canon", "dial", "com", "act", "ctrl", "cos", "call", "nc", "fn", "cf"], "ds": ["qs", "sync", "gs", "dos", "bd", "dl", "ads", "dh", "ps", "dis", "conn", "ats", "bs", "sd", "posts", "hs", "des", "js", "ils", "vs", "cks", "els", "dp", "eps", "dds", "dc", "cs", "ones", "dd", "aos", "Ds", "ts", "scripts", "aws", "ks", "sys", "dt", "ows", "DS", "ls", "ys", "ops", "nas", "pd", "ws", "fd", "d", "ses", "loads", "der", "di", "edes", "ands", "fs", "rs", "eds", "sets", "sts", "docs", "stats", "sql", "css", "def", "obs", "ods", "s", "uds", "ns", "db", "pers", "xs"], "fStream": ["fSteam", "mstream", "aForm", "fstream", "mThread", "ftStream", "fileRound", " fStreamer", "sfSteam", "ftRound", " fRound", "mStreamer", "fpstream", "fileSystem", " fstream", "ftSystem", "fStreamer", "mStream", "aStream", " fThread", "fSystem", "sfStream", "aSteam", "fileStream", "sfReader", "fThread", "aReader", " fSteam", " fSystem", " fReader", "fRound", "sfForm", "fpStream", "fForm", "fpThread", "fileForm", "fReader", "ftForm", " fForm", "fpStreamer"], "bufferSize": [" bufferSIZE", " bufferCount", "buffScale", "buffSize", "BufferScale", "BufferSize", " bufferLength", "BufferLength", "surfaceSize", "surfaceScale", "surfaceLength", "BufferCount", "buffSIZE", "bufferSIZE", "surfaceSIZE", "BufferSIZE", "tableSIZE", "tableCount", "bufferScale", "bufferLength", "bufferCount", "buffLength", "tableSize", "tableLength"], "buffer": ["memory", "binary", "Buffer", "view", "stack", "buff", "total", "raw", "batch", "available", "document", "phrase", "temp", "result", "word", "iter", "bar", "queue", "stroke", "pause", "library", "reference", "cache", "database", "variable", "command", "face", "buf", "bone", "paste", "frame", "number", "template", "sample", "sequence", "block", "message", "append", "char", "initial", "table", "bridge", "window", "source"], "length": ["history", "count", "deep", "ENGTH", "kind", "Length", "bow", "point", "volume", "tail", "pad", "core", "ah", "total", "rest", "full", "idth", "collection", "component", "l", "result", "shape", "piece", "no", "duration", "database", "partial", "command", "loop", "capacity", "amount", "position", "present", "enth", "len", "load", "be", "number", "height", "hello", "all", "expected", "size", "sequence", "angle", "ength", " Length", "code"], "is": ["ip", "tis", "ps", "ists", "iris", "ii", "bs", "does", "sis", "os", "isin", "vs", "isc", "bis", "isi", "has", "isf", "sys", "ls", "lis", "nis", "ys", "its", "IS", "si", "ris", "fs", "ims", "ais", "isa", "iss", "ios", "isl", "ates", "icks", "Is", "i", "ism", "ri", "ms"], "ch": ["inch", "c", "ct", "count", "y", "ctr", "cl", "cy", "chan", "che", "CH", "unk", "str", "col", "comment", "ce", "Ch", "ty", "cle", "cs", "ouch", "qu", "chid", "cell", "cho", "sch", "ph", "cp", "cmd", "zh", "x", "ech", "check", "br", "ach", "och", "ches", "ich", "cha", "channel", "cur", "conf", "cm", "pc", "cor", "j", "char", "tch", "ex", "cht", "code", "sh", "i", "unch"], "b": ["sb", "c", "bd", "B", "binary", "v", "bound", "wb", "ba", "emb", "bs", "buff", "base", "fb", "bf", "auto", "ib", "ab", "bar", "r", "mb", "eb", "cb", "ob", "orb", "br", "job", "rb", "a", "buf", "f", "d", "be", "gb", "nb", "pb", "bp", "xb", "shell", "s", "db", "bb"]}}
{"id1": "15896098", "id2": "841724", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checksam", "getSHA256Checkchecksums", "getSHA256Checkchecksam", "getSHA256Checsam", "getSHA256Checsum", "getSHA256Checkcksam", "getSHA256Checkum", "getSHA256Checkchecksume", "getSHA256Checkcksums", "getSHA256Chechecksam", "getSHA256Checsume", "getSHA256Checsums", "getSHA256Checksume", "getSHA256Checkcksume", "getSHA256Checkam", "getSHA256Checksums", "getSHA256Chechecksum", "getSHA256Checkchecksum", "getSHA256Checkums", "getSHA256Chechecksums", "getSHA256Checkcksum", "getSHA256Chechecksume", "getSHA256Checkume"], "source": ["content", "text", "buffer", "secret", "status", "in", "src", "data", "base", "this", "raw", "file", "image", "body", "string", "out", "SOURCE", "input", "path", "ource", "reason", "name", "format", "Source", "url", "target", "value", "template", "sample", "sequence", "context", "message", "from", "output", "subject", "style", "s", "seed", "filename"], "checksum": ["checkums", " checksums", "checkim", " checksume", "checksim", "ckssum", "checkssum", "cksum", "csume", "checkum", "checkume", " checksim", "cksums", "cksumb", "checksume", "cssum", "cksim", "csum", "checksums", "checksumb", "checkumb", " checkssum", " checksumb", "csim", "cksume"], "md": ["pm", " Md", "bd", "MD", "dh", "pdf", "det", "cd", "wd", "dr", "Cmd", "sd", "down", "sm", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "cmd", "df", "mk", "mb", "dm", "mo", "pd", "nt", " MD", "grad", "mp", "d", "der", "di", "ld", "mn", "od", "def", "m", "red", "ad", "mm", "mg", "ms"], "byteData": ["routeDat", "channelData", "sliceList", "ioDATA", "bytesData", "channeldata", "phraseData", "routeData", "byteBytes", " byteParts", "bleData", "byteCount", "byteDATA", "byteArray", "sliceDATA", "bytesBytes", " bytedata", " byteList", "ByteDATA", "byteRel", " byteRel", " byteDATA", "ioData", "bledata", "wordData", "sliceData", " byteCount", "bleRel", "bytesArray", "sliceDat", "ioList", " byteDat", "reverseDat", "channelParts", "phraseDATA", "byteList", "ByteParts", "wordDATA", " byteBytes", "bleParts", "byteDat", "wordArray", "wordBytes", "channelRel", "routeDATA", "phraseBytes", "reverseData", "reverseCount", "ioDat", " byteArray", "reverseDATA", "routeCount", "ByteBytes", "bytedata", "byteParts", "bytesDATA", "ByteData", "phraseParts"], "sb": ["lb", "zb", "bg", "sg", "lp", "bash", "bh", "wb", "SF", "bs", "sm", "sbm", "bf", "sam", "bis", "sv", "sq", "b", "bt", "ib", "sa", "ssl", "mb", "eb", "cb", "ob", "obb", "SB", "rb", "bps", "si", "sw", "gb", "erb", "nb", "pb", "bj", "kb", "xb", "shell", "sh", "sf", "sp", "bsp", "db", "ub", "bb"], "i": ["li", "y", "bi", "ii", "xi", "I", "series", "gu", "hi", "cli", "err", "loop", "init", "list", "ims", "ini", "ei", "sim", "j", "my", "g", "ion", "remote", "ic", "life", "history", "io", "any", "multi", "u", "this", "l", "q", "client", "ki", "pi", "ij", "qi", "di", "o", "ms", "ity", "point", "id", "mi", "gi", "uri", "ie", "ji", "er", "iq", "me", "si", "ix", "info", "json", "it", "to", "set", "ip", "iy", "ime", "phi", "ui", "ind", "iu", "oi", "ski", "print", "im", "ti", "major", "ci", "chain", "\u0438", "m", "ai", "ri"], "hexString": [" Hexstring", "shortstring", "hashString", "fullStore", " hexstring", "shortResource", "shortArray", "hexResource", "htmlBuffer", "hexArray", " HexString", "shortBuffer", "exString", " HexBuffer", "hexStore", " hexResource", " hexArray", "fullString", "shortString", "hexBuffer", "hashArray", "hexstring", "exStore", "htmlString", "fullBuffer", "hashBuffer", "exstring", " hexStore", "exBuffer", " HexResource", "hashstring", "htmlstring", "fullstring", "htmlArray", " hexBuffer", "exArray"], "hex": ["oct", "rendered", "des", "html", "ext", "prop", "raw", "full", "tex", "sex", "flash", "dump", "temp", "rex", "mix", "ph", "alph", "zh", "x", "none", "solid", "alias", "term", "rh", " Hex", "exp", "pex", "comp", "json", "hello", "he", "php", "hl", " ex", "cat", "tx", "lit", "ex", "com", " sex", "sh", "h", "cont", "form", "def"]}}
{"id1": "16388708", "id2": "19134229", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "822452", "id2": "15768167", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "23467091", "id2": "7499186", "code1": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"listen": ["laten", "Listener", "Listhen", " listhen", "Listen", "listener", " listener", "latenn", "Listenn", "listenn", "latener", "listhen", "lathen", " listenn"], "url": ["dl", "cl", "location", "org", "build", "ul", "k", "host", "nl", "mount", "str", "base", "html", "u", "server", "full", "el", "raw", "loc", "l", "norm", "web", "gl", "uri", "string", "r", "ssl", "impl", "browser", "path", "ls", "cert", "ob", "util", "mail", "ref", "sl", "address", "name", "term", "ur", "pkg", "pl", "github", "http", "load", "hl", "ll", "link", "domain", "rel", "ret", "URL", "pp", "addr", "lim", "xml", "Url", "window"], "conn": ["c", "ct", "org", "ann", "close", "enc", "ctx", "host", "po", "connection", "Conn", "col", "en", "loc", "jp", "comm", "pg", "cp", "cc", "client", "cmd", "ds", "cert", "cb", "open", "ws", "nt", "conv", "n", "typ", "co", "resp", "init", "rt", "cur", "conf", "net", "con", "Connection", "yn", "cn", "ch", "rel", "canon", "syn", "com", "ctrl", "pub", "ca", "nc", "ns", "connect"], "in": ["c", "t", "reader", "bin", "read", "din", "min", "inv", "or", "re", "stream", "po", "inc", "isin", "rin", "en", "inner", "l", "b", "e", "inf", "ain", "mc", "out", "is", "line", "input", "In", "n", "on", "p", "gin", "ma", "all", "len", "info", "o", "IN", "con", "cm", "sum", "ins", "inn", "socket", "cin", "m", "oin"], "data": ["version", "content", "text", "buffer", "default", "DATA", "id", "ata", "log", "batch", "image", "bus", "next", "body", "out", "no", "step", "reason", "name", "dat", "d", "info", "value", "response", "block", "sequence", "message", "valid", "rel", "output", "done", "table", "mu", "good", "window"], "i": ["t", "fire", "li", "io", "y", "v", "bi", "ii", "phi", "multi", "key", "I", "u", "ui", "ind", "iu", "mi", "batch", "gu", "e", "gi", "iter", "q", "out", "cli", "x", "is", "ki", "ti", "ie", "ci", "pi", "chain", "n", "qi", "si", "init", "ix", "di", "ini", "it", "sequence", "sim", "j", "m", "ai", "zi", "ic", "ms"]}}
{"id1": "646016", "id2": "11049257", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"elimina": ["ellimisa", "eligina", "elimisa", "elitisa", "allimisa", "alimisa", "elimino", "elitine", "eligino", "alimino", "alimina", "ellimine", "ellimino", "elimine", "ellimina", "allimino", "elitino", "elitina", "allimine", "allimina", "eligisa", "eligine", "alimine"], "cli": ["c", "dl", "li", "cl", "Cl", "cfg", "conn", " CLI", "multi", " cl", "ui", "l", "gui", "ln", "e", "cho", "console", "client", "cmd", "cgi", "idi", "clus", "grid", "uci", "aci", "util", "ci", "gil", "cu", "pi", "eric", "cci", "udi", "exe", "ctl", "GUI", "dial", "Client", "ctrl", "lu", "prot", "i", "coni", "lc", "coe"], "id": ["ip", "rid", "mid", "pid", "type", "status", "in", "ida", "sd", "uid", "md", "iden", "with", "wid", "vid", "e", " fid", "ident", "del", "did", "sid", "aid", "out", "hash", "is", "index", "no", "res", "ref", "ids", "mail", "end", "name", "ide", "start", "ID", "url", "f", "d", "info", "value", "num", "it", "rand", "oid", "null", "bid", "code", "h", "kid", "i", "ad", "db", "key", "Id", "and"], "sql": ["sb", "dl", "SQL", "ship", "sal", "details", "ps", "lex", "spr", "inv", "sd", "nl", "js", "html", "software", "sk", "csv", "services", "sv", "eps", "sq", "scl", "ln", "expression", "https", "string", "sys", "xs", "ds", "ssl", "security", "ls", "ql", "pel", "util", "mail", "sl", "lua", "spec", "format", "url", "pkg", "json", "query", " SQL", "wal", "ping", "lock", "ll", "sp", "owl", "ns", "pp", "socket", "shell", "xml", "msg", "s", "what", "sol", "fn", "db", "ips", "ms", "QL"], "stmt": [" stmm", "Stmn", "STmt", "STMT", "Stmt", "stmb", " stMT", "Stmm", "StMT", "stm", "strmb", "strmt", "scm", "Sttm", " stmb", "sctm", " sttm", "scmm", "STmn", "tmm", "Stmb", "tm", "stMT", "strMT", "STmm", "ttm", "sttm", " stmn", "strm", "tmt", "scmt", " stm", "STm", "Stm", "stmm", "stmn"]}}
{"id1": "10218878", "id2": "7927042", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecodeMAPFiles", "DecodeMapFiles", "DecodeToLog", "DecodeMAPfile", "DecvertMAPfile", "DecvertMAPFile", "DecodeFromLog", "DecvertMapfile", "DecodeToFiles", "DecodeMapfile", "DecodeTofile", "DecvertMapFiles", "DecvertMapLog", "DecodeFromfile", "DecodeMAPFile", "DecvertMapFile", "DecodeFromFile", "DecvertMAPFiles", "DecodeToFile", "DecvertMAPLog", "DecodeFromFiles", "DecodeMAPLog", "DecodeMapLog"], "mapFile": ["mapFILE", "mapFilename", "MapStream", "listFile", "imageFile", "MapFile", "listPath", " mapFilename", "mapfile", "mapStream", "Mapfile", "cacheFile", " mapPath", "cacheFILE", "imageStream", "cachePath", "imageFilename", " mapStream", "listFILE", " mapFILE", " mapfile", "imagefile", "MapFilename", "mapPath"], "outputFile": ["outputDir", "OutputDir", "outputStream", "inputName", "outFile", "OutputPath", " outputDir", "writeName", "outPath", "mapStream", "mapName", "OutputFilename", "outDir", "writeStream", "outFilename", "outputPath", "mapDir", "writeFile", " outputPath", "inputStream", "OutputFile", "outputFilename", "inputFile", " outputFilename", "inputDir", "outputName", "writeDir"], "magicKey": [" magicCode", "prefixKey", "magicChar", "uniqueCounter", " magicChar", "prefixValue", " magicField", "serialKEY", "encryptedKey", " magicKEY", "anticKey", "serialKey", "antickey", "MagicName", "prefixCounter", "magicValue", "magicCounter", "uniqueValue", "magicField", "serialId", " magicId", "magicKEY", " magicValue", "magicName", "serialName", "MagicKey", "prefixCode", "magicId", "magicCode", "encryptedChar", "MagicKEY", "magickey", "anticField", " magickey", " magicCounter", "anticChar", "uniqueKey", "encryptedkey", " magicName", "uniqueCode", "MagicId", "encryptedField"], "buffer": ["history", "memory", "Buffer", "binary", "detail", "stack", "stream", "black", "pad", "buff", "base", "length", "total", "attribute", "batch", "document", "flash", "print", "phrase", "iter", "button", "shape", "queue", "stroke", "index", "cache", "check", "program", "database", "screen", "command", "variable", "mem", "buf", "bone", "paste", "frame", "template", "row", "sample", "block", "sequence", "message", "bo", "display", "vector", "char", "sum", "initial", "append", "table", "filter", "code", "bridge", "window", "page", "header"], "nread": ["ncwrite", "renwrite", "nreadable", "rawreader", "rawwrite", "rentry", "maxget", "rawtry", "Nread", "maxread", "ncRead", " nwrite", "rnread", "maxadd", "Nwrite", "NRead", "nREAD", "maxRead", " ntry", " nREAD", "ncget", "rawread", "ncread", "nwrite", "ntry", "rnwrite", "rnRead", "NREAD", "ncreadable", " nreadable", "renreader", "ncadd", " nRead", "nreader", "nget", "nRead", "rnREAD", "Nget", "Nadd", "renread", " nreader", "Nreadable", "nadd"], "map": ["meta", "apper", "parse", "ip", "aps", "app", "ml", "where", "memory", "window", "read", "manager", "maps", "view", "down", "mount", "mt", "file", "batch", "mod", "image", "mate", "place", "shape", "mask", "cache", "open", "pack", "ace", "ape", "address", "up", "op", "mem", "apping", "mp", "clear", "co", "per", "pl", "load", "set", "man", "module", "con", "pose", "lock", "cm", "block", "master", "com", "config", "MAP", "m", "collect", "table", "ap", "bridge", "make", "form"], "output": ["object", "four", "exit", "write", "can", "oe", "blue", "stream", "auto", "log", "file", "batch", "icon", "print", "next", "web", "result", "secure", "console", "update", "out", "client", "hidden", "queue", "input", "Output", "put", "cache", "plain", "open", "entity", "format", "online", "network", "target", "o", "net", "response", "block", "display", "latest", "ilo", "socket", "port", "ou", "current", "outer", "other"], "i": ["ip", "t", "li", "y", "v", "span", "bi", "ii", "phi", "multi", "I", "id", "u", "xi", "ui", "ind", "mi", "iu", "batch", "b", "gu", "gi", "spin", "uri", "q", "cli", "ami", "x", "is", "ti", "ie", "index", "ci", "pi", "ji", "n", "qi", "ni", "si", "ix", "di", "ini", "ei", "it", "ish", "sim", "j", "m", "fi", "ai", "g", "us", "ic", "ri", "ms"]}}
{"id1": "1966310", "id2": "10436471", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"init": ["create", "bin", "build", "inv", "js", "base", "id", "ui", "norm", "construct", "initialized", "kit", "update", "render", "gc", "destroy", "setup", "n", "start", "late", " Init", "clear", "get", "load", "ini", "set", "fp", "launch", "fin", "it", "rand", "reset", "initial", "plot", "config", "ize", "ic", "ns", "fn", "Init", "def"], "doActions": [" doCallactions", " doAnactions", "doDeaction", " doAnctions", " doAncs", " doCallctions", "doDecs", " doDections", "doDections", "doAactions", " doDeactions", " doAactions", " doAcs", "doDeactions", " doDecs", " doAnaction", " doAaction", "doAcs", " doCallaction", " doCallcs", "doAaction", " doDeaction"], "_plot": ["_log", " _config", "_chart", "_config", " _log", "_layout", "_Plot", "_hide", " _layout"], "width": ["history", "content", "scale", "widget", "px", "write", "lon", "padding", "wd", "min", "current", "view", "Width", "column", "length", "pen", "full", "idth", "en", "now", "wid", "draw", "left", "body", "render", "focus", "x", "path", "right", "term", "format", "dim", "weight", "layout", "wn", "frame", "len", "all", "sw", "depth", "size", "w", "rel", "output", "area", "display", "wy", "change", "wt", "true", "port", "window", "axy"], "height": ["history", "gravity", "y", "widget", "where", "buffer", "padding", "max", "yt", "host", "volume", "view", "data", "html", "length", "total", "power", "bottom", "div", "ty", "draw", "Height", "hang", "shape", "ows", "stroke", "rows", "hash", "above", "radius", "inches", "crop", "density", "capacity", "resolution", "layout", "grow", "depth", "json", "row", "size", "rank", "high", "display", "style", "alpha", "h", "window", "ht", "axy"], "widthspec": ["heightpec", "windowspecies", "lengthpec", "weightproc", " widthpec", "lengthproc", "lengthspe", "lengthspec", "sizepec", "weightspe", "sizespe", "sizeSpec", " widthSpec", "sizespec", "lengthSpec", "widthproc", "heightspe", " widthspe", "heightSpec", "widthSpec", "windowproc", "weightspecies", "lengthspecies", "weightspec", "widthpec", "widthspecies", "windowspec", "windowspe", "widthspe"], "heightspec": ["heuesspec", " heatsSpec", "hericspec", "hericserial", "weightsspe", "hericsspec", "heatspr", "weightsspec", "heightpec", "hericsimp", "heavesspec", " heightsSpec", "heavespect", "heavespec", "heowspec", "heuesSpec", "heuespec", "weowspec", "heowspr", "weowsspe", "heatsspec", "heilspec", "heavesspe", " heightspr", " heatspr", "heightimp", "heightspr", "heightspect", "heowserial", "weightspect", " heatsspec", "weowserial", "heightsimp", "weowsspec", "heatsSpec", "weowspect", "heightsSpec", " heatspec", "heighterial", " heightsspec", "heowsspe", "heuespr", "heatspec", "heowspect", "heowsspec", "heowsSpec", "weightspec", "weightsimp", "heilsspe", "heowsimp", "weightserial", "heilspect", "heightserial", "weowsimp", "heightsspe", "heilsspec", "heightsspec"], "background": ["history", "bg", "ground", "memory", "buffer", "close", "binary", "padding", "default", "foundation", "ghost", "black", "back", "font", "sound", "base", "comment", "bottom", "collection", "draw", "pull", "body", "storage", "radius", "pattern", "focus", "hidden", "library", "mask", "gc", "database", "ref", "today", "gradient", "material", "escape", "password", "shadow", "layout", "clear", "wrapper", "internal", "bo", "border", "area", "blank", "display", "style", "Background", "callback", "shell", "support", "color", "alpha", "cloud", "system"], "colorspec": ["colorsspe", "colarspec", "colororesspec", "colorsspec", "colororsspec", "colororsetpec", "colororespec", "colororsetspec", "colororsync", "colorsetSpec", "colorasSpec", "condorsec", "colororsetig", "collectionsspe", "colorscmp", "colorsetec", "colorsetpect", "colorsetig", "coloraspec", "colororsproc", "condorsSpec", "colodesig", "colorsetpe", "colororsetpe", "colorsproc", "condorspec", "colornsproc", "colorsSpec", "colorasspec", "colornsspec", "colorespec", "colorsetspec", "colnersspec", "coloresSpec", "colororsetpect", "coleterselect", "colarsspec", "colororesSpec", "colororsetelect", "coleterscmp", "condorsspec", "condorsetspec", "colororesproc", "coloresec", "colororsig", "condorsetpec", "colnerspec", "colororsspe", "coleterspect", "condorsetSpec", "colorselect", "colororsetync", "collectionsspec", "coloresspec", "colornspec", "colorsync", "colodesspe", "colodesspec", "collectionspe", "collectionspec", "colorsetproc", "colororsetcmp", "colorasec", "colorsetpec", "colodesync", "colororspe", "colororspect", "colorsetync", "colororselect", "colarspect", "condorsetec", "colodespec", "colororscmp", "colorsec", "colodeselect", "colororsetspe", "colnersspe", "colorsig", "colororspec", "collectionsync", "colorsetspe", "colorsetcmp", "coletersig", "colarscmp", "colnerspe", "colornsSpec", "colorspe", "coleterspec", "colorspect", "colororsSpec", "coletersspec", "colorsetelect", "coloresproc"], "foreground": ["FOREGROUND", "Forebackground", "forbase", "vermond", " Foreground", " forebackground", "foregb", "forecolor", "forbackground", "foremond", "Foremond", "verground", "frontground", "frontbackground", "FOREground", "foreGROUND", "forground", "Foremain", "foregrounds", "Forecolor", "vergb", "FOREmond", " Forecolor", "FOREbackground", "verbackground", "ForeGROUND", "Foregb", "foremain", "forebackground", " forebase", "Forebase", " Forebackground", "Foreground", "forebase", " forecolor", " Foremain", " foregrounds", " foremain", " foregb", "Foregrounds", "forgrounds", " foremond", "frontGROUND", "frontmond"], "dataurlspec": [" dataurlpec", "DataurlSPEC", "datalSpec", "datafilenamespe", "dataurlSpec", "DATAurlSpec", " datafilenameSpec", "Dataurlspec", "dataUrlSPEC", "datastringSpec", "datafilenameSPEC", "dataUrlSpec", "DataUrlspec", "Dataurlspe", "dataurispec", "datauriSPEC", "datastrspec", "datastringpec", "datafilenameSpec", "DATAfilenameSpec", "dataUrlpec", "datalspe", "DataUrlspe", " datafilenamepec", " datafilenamespe", "dataurlSPEC", "DataUrlSpec", "dataUrlspec", "DATAurlspe", "dataurlspe", "datalSPEC", "DATAfilenamespe", "datastringspe", "DataurlSpec", "datalspec", "datastrSpec", "dataurispe", "datafilenamepec", " datafilenamespec", "datauriSpec", "DATAfilenamespec", "datastrSPEC", "DATAfilenameSPEC", "dataurlpec", " dataurlSpec", "datastringspec", "datastrspe", "dataUrlspe", "DataUrlSPEC", " dataurlspe", "DATAurlspec", "DATAurlSPEC", "datafilenamespec"], "dataurl": ["mufeed", "imageuri", "imageurl", "imageURL", " datautil", "Datautil", "imageUrl", "DataURL", "Dataurl", "muurl", " datafeed", "resourceURL", "DataUrl", "resourceUrl", "datauri", " dataUrl", "resourceuri", "muutil", "resourceurl", "muUrl", "dataUrl", "Datauri", "dataURL", "datautil", "datafeed", "Datafeed"], "in": ["c", "t", "bin", "din", " din", "stream", "data", "id", "isin", "rin", "ind", "file", "log", "inner", "serv", "body", "vin", "r", "out", "is", "input", " IN", "In", "gin", "f", "d", "ma", "o", "IN", "ini", "it", "sample", "from", "ins", "inn", "m", "cin", "doc", "i", "source"]}}
{"id1": "21316706", "id2": "22411381", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"openConnection": ["openChannel", "doChannel", " openChannel", "doconnection", "openConnect", " obtainconnection", " openconnection", " obtainConnect", " openConnect", "openconnection", " obtainChannel", "doConnect", " obtainConnection", "doConnection"], "url": ["parse", "location", "build", "ul", "host", "re", "mount", "str", "id", "server", "el", "file", "log", "loc", "l", "b", "web", "uri", "string", "q", "r", "ssl", "browser", "path", "ls", "util", "job", "mail", "sl", "address", "name", "un", "ur", "http", "all", "ll", "link", "domain", "ret", "URL", "char", "addr", "config", "xml", "Url", "key", "access"], "proxy": ["version", "zone", "manager", "pipe", "connection", "po", "server", "roxy", "uri", "client", "Proxy", "profile", "ssl", "none", "browser", "pointer", "library", "cache", "cas", "policy", "address", "password", "project", "shadow", "pe", "token", "property", "http", "timeout", "service", "slave", "module", "force", "via", "ping", "link", "one", "report", "pro", "socket", "port", "resource", "pse"]}}
{"id1": "21821404", "id2": "14303294", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "label": 0, "substitutes": {"getWebPage": ["getDebugPage", "getWebUrl", "getwebPage", "getDebugpage", "getwebpage", "getLivePages", "getLiveUrl", "downloadWebPage", "getWebPages", "getDebugUrl", "downloadwebPages", "downloadwebpage", "getWebpage", "downloadWebPages", "downloadWebpage", "getwebPages", "getLivePage", "getLivepage", "downloadwebUrl", "downloadwebPage", "getwebUrl", "downloadWebUrl", "getDebugPages"], "urlObj": ["urlOb", "logOb", " urlobj", "uriCtrl", "uriObject", "UrlOnce", "httpObject", " urlOb", "logObj", "uriOnce", " urlInd", "uriobj", "httpInfo", "UrlObj", "logObject", "uriInd", "UrlObject", " urlInfo", "httpObj", " urlCtrl", "logInfo", "httpOb", "UrlCtrl", "uriObj", "urlObject", "urlobj", "urlInfo", "Urlobj", " urlObject", "urlOnce", "UrlInd", "urlInd", "urlCtrl", " urlOnce"], "content": ["text", "object", "buffer", "read", "write", "articles", "view", "data", "str", "html", "core", "ext", "comment", "raw", "ce", "document", "complete", "temp", "continue", "result", "body", "equ", "string", "clean", "section", "Content", "comments", "address", "reason", "title", "format", "command", "layout", "wrapper", "load", "value", "template", "cm", "sequence", "response", "message", "output", "context", "display", "ontent", "article", "code", "page", "empty", "cont", "current", "source", "header", "txt"], "is": ["or", "\u00eds", "isc", "has", "web", "ot", "plays", "job", "err", "his", "ris", "ir", "Is", "ism", "other", "tis", "ese", "in", "es", "sit", "isi", "was", "e", "ist", "sys", "out", "were", "nis", "its", "fs", "rs", "net", "ios", "internet", "s", "when", "by", "ms", "being", "ians", "where", "ists", "ire", "se", "does", "sis", "os", "id", "isin", "more", "isf", "string", "iso", "ois", "sels", "IS", "are", "be", "ais", "isa", "iss", "isl", "rys", "not", "and", "c", "iris", "re", "bis", "as", "lis", "res", "chain", "name", "a", "mis", "i", "ri"], "reader": ["io", "read", "buffer", "dr", "ader", "in", "stream", "file", "liner", "ipper", "inner", "loader", "Reader", "ro", "iper", "iter", "dra", "parser", "ner", "r", "ocker", "rar", "er", "per", "anger", "row", "roller", "reading", "runner", "editor", "handler", "rr", "writer", "ser", "ri", "iterator"], "line": ["text", "le", "zone", "detail", "lin", "lane", "inline", "range", "point", "nl", "part", "column", "comment", "el", "file", "liner", "LINE", "print", "l", "ln", "e", "cell", "Line", "eline", "string", "lo", "piece", "stroke", "section", "email", "ine", "online", "lined", "frame", "row", "record", "link", "sample", "block", "sequence", "message", "char", "entry", "label", "word", "page"]}}
{"id1": "18433984", "id2": "20920051", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doUpload": ["doImport", "postUpload", "postupload", "doupload", "defaultImport", "postTransfer", " doupload", "postImport", "defaultUpload", " doTransfer", " doImport", "defaultTransfer", "doTransfer", "defaultupload"], "request": ["object", "du", "begin", "component", "session", "reference", "address", "reason", "up", "position", "un", "frame", "first", "message", "condition", "subject", "initial", "xml", "model", "version", "each", "order", "server", "attribute", "file", "ure", "now", "q", "client", "application", "open", "art", "req", "params", "get", "pass", "record", "context", "access", "requ", "create", "buffer", "point", "user", "upload", "raw", "QUEST", "document", "string", "quest", "url", "query", "question", "reset", "argument", "call", "resource", "forward", "key", "content", "submit", "method", "instance", "re", "view", "connection", "complete", "result", "input", "necessary", "enter", "name", "command", "accept", "Request", "http", "such", "tim", "report", "information", "current"], "response": ["reply", "respond", "onse", "write", "status", "state", "view", "re", "connection", "respons", "ce", "file", "document", "image", "session", "application", "res", "success", "resp", "send", "event", "output", "message", " Response", " responses", "report", "Response", "sp"], "reqSession": ["curState", "qESSION", " reqS", "reqS", "qsession", "reqsession", "reqState", "requSite", "requESSION", " reqState", "reqSite", "questESSION", " reqESSION", "requsession", "curS", "requSession", "requState", "reqSocket", "questState", "requSocket", " reqSocket", "curSite", "requS", "curSession", "questSocket", " reqSite", "reqESSION", "questSession", "qSession", " reqsession"], "uploadFiles": [" uploadTypes", "inputfiles", "transferfiles", "transferFiles", "transferTypes", "uploadTypes", "inputFiles", "inputResources", " uploadfiles", "inputTypes", "uploadResources", " uploadResources", "uploadfiles", "transferResources"], "tempDirName": [" tempFolderDefault", "tempFilename", "tmpFileNAME", "tempPathName", "tempRelToken", "tempDirFamily", "tempRelname", "tempVername", "tempDirNAME", "tempDIRNAME", "tempDIRName", "TempFolderFamily", " tempFolderPath", "tmpFileName", "tmpDirToken", "tempRelName", "tempLocName", "TempDirName", "tempVerNAME", "tempVerFamily", "tempDirname", "TempFoldername", "tempFileFamily", "tempDirDefault", "tempFolderFamily", "tmpFileDefault", " tempDirPath", "tmpDirNAME", "TempFolderNAME", "TempDirname", "TempDirNAME", "tmpDirDefault", "tmpFileToken", "tempRelNAME", "tempPathNAME", "tempFolderNAME", "tempFoldername", "TempFolderName", "tempPathDefault", "tempLocPath", "tempDbName", " tempDirDefault", "tempFileToken", "tempPathname", "tempDIRToken", "tempLocDefault", "tmpDirname", "tempDbDefault", " tempFolderName", "tempDirToken", "tempVerName", "tempDbPath", "TempDirFamily", "tempFileNAME", "tmpFilename", "tempFileDefault", "tempDIRname", "tempFileName", "tmpDirName", "tempFolderDefault", "tempFolderPath", "tempDirPath", "tempFolderName"], "tempUploadDir": ["tmpUpDir", "tempAttachLoc", "tmpDownloadFiles", "tempuploadRel", "temUploadDir", "tempUploadFiles", "tempSaveDirectory", "tempUpdateDir", "tempNewSys", "tempUploadDirectory", "temActionDir", "tempSaveFiles", "tmpUploadJar", "tempUploadDest", "tempDownloadDb", "tmpUploadRel", "empAttachDir", "tmpUploadFiles", "tmpAttachSys", "empUploadDir", "tempuploadLoc", "tempAttachDir", "tempActionLoc", "tempDownloadJar", "tempNewdir", "tmpUploadLoc", "TempDownloadDir", "tmpUploadDirectory", "empuploadDis", "tempUpdatedir", "tempUpdateDis", "tempUploadLen", "tmpDownloadDirectory", "tempLoadLock", "tmpUploadSys", "tempDeployDir", "empUploadLen", "tempUploadRel", "tempAttachLen", "temActiondir", "tempUpdateD", "tempuploaddir", "tempActD", "tempAttachdir", "tempAttachRel", "empuploadDir", "empUploadD", "tempUploadLoc", "temUploadDb", "tempDeployLen", "tempuploadDir", "tempuploadDirectory", "empAttachDest", "tempuploadD", "tempUpgradeLen", "empAttachLen", "tempUploadLock", "temUploaddir", "tempActdir", "tempDownloadFiles", "tempUpgradeDest", "tempUploadFolder", "tempActionLen", "tempNewLock", "tempUpLoc", "empuploadD", "tmpUploadFolder", "tempLoadDir", "empAttachD", "empUploadRel", "tempDeployJar", "empUploadDis", "tempActiondir", "tempDeployDb", "tmpUploaddir", "tempDeploydir", "tmpAttachdir", "TempDownloaddir", "tempUploadDb", "tempSaveDir", "tempAttachLock", "tempAttachFiles", "tempuploadJar", "tempDeployD", "tempActDir", "tmpUpRel", "tempAttachDest", "empUploaddir", "tempDeployFolder", "empAttachRel", "tempActionRel", "tempUpRel", "tempuploadLen", "temActionDb", "tempuploadDis", "tempActDis", "TempUploadDir", "tempNewDir", "empUploadDest", "tempAttachSys", "TempDownloadDirectory", "tempUploadDis", "tmpUpLoc", "tempUpgradeD", "tempuploadFolder", "TempUploaddir", "tempUploadJar", "tmpAttachLock", "tmpDownloadFolder", "tempUploadSys", "tempDownloadFolder", "tempLoadSys", "tempDeployDest", "tmpDownloadJar", "tmpUploadDir", "tempActionDb", "tempDownloadDir", "TempUploadDirectory", "tempAttachDirectory", "tempUploadD", "tempUpgradeDir", "tmpUploadLock", "tmpDownloadDir", "tempDeployDirectory", "tempUploaddir", "empAttachLoc", "empuploaddir", "empUploadLoc", "tempUpDir", "tempDownloadDirectory", "tempActionDir", "tempDownloaddir", "tempAttachD", "tmpAttachDir", "tempLoaddir"], "attachmentDir": ["attmentDIR", "attachmentDirectory", "attachedDir", "attachignmentDir", "aditutionDet", "attachignmentFolder", "adachmentDet", "attachachmentdir", "attacherD", "attachedStr", "attachableD", "attestationDir", "attignmentDet", "attignmentDir", "attachingDIR", "extacherDIR", "attitutionRect", "adachmentDir", "attmentDir", "adachmentTier", "attributeachedStr", "extachmentDIR", "attacherDirectory", "attachmentRect", "attachachmentFolder", "attachableDIR", "extachmentDir", "attestationDet", "attributeachedDirectory", "attachmentDIR", "attentionDirectory", "attributeachmentDirectory", "attachmentStr", "attachachmentDir", "attentionStr", "attignmentdir", "attachingDir", "attestationRect", "attributionDIR", "attachmentTier", "attributionFolder", "attachmentD", "aditutionRect", "attignmentDIR", "attestationTier", "attmentdir", "attitutionDet", "attitutionDir", "attachmentFolder", "attributiondir", "attacherDir", "aditutionDir", "attignmentTier", "extachmentD", "attachingD", "attignmentRect", "extacherDir", "aditutionTier", "attributeachedDir", "attmentFolder", "extacherD", "attachableDir", "attachmentdir", "attitutionTier", "adachmentRect", "attachignmentDIR", "attentionDir", "attachachmentDIR", "attributeachmentDir", "attacherDIR", "attachedDirectory", "attignmentFolder", "attachmentDet", "attacherStr", "attributionDir", "attributeachmentStr", "attachignmentdir"], "paramMap": ["paramCache", "propertyApply", "pixelCache", " paramTable", "permMap", "paramsSet", " parammap", "paramLock", "ParamMaps", "aramTable", "aramMaps", "aramMap", "paramMaps", "pixelApply", "pixelMap", "propertyMap", "paramTable", "paramApply", "propertyCache", " paramSkip", "aramSet", "fieldList", "paramsMap", "ParamSkip", "paramap", "parammap", "paramsap", " paramSet", "ParamSet", "paramSet", " paramap", "permCache", "permLock", "ParamMap", "aramap", "paramsMaps", " paramList", "paramSkip", "arammap", "fieldTable", "aramSkip", "fieldMap", "propertyLock", "aramList", "pixelLock", " paramMaps", "fieldmap", "permApply", "paramList"]}}
{"id1": "6379126", "id2": "16572931", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": [" crearTiblServer", " crearTutorialPage", " crearTiaryPage", " crearTeoyServer", " crearToyPage", " crearTeoyPage", " crearTeutorialScreen", " crearToyScreen", " crearTiblPages", " crearTiblScreen", " crearToyServer", " crearTeutorialServer", " crearTeoyPages", " crearTutorialScreen", " crearTiaryScreen", " crearTiblPage", " crearTeoyScreen", " crearTutorialServer", " crearTeutorialPages", " crearTiaryPages", " crearTiaryServer", " crearTeutorialPage", " crearToyPages", " crearTutorialPages"], "indexDir": ["appPath", "htmlDir", "scriptDir", "scriptFolder", "htmlDIR", "scriptDIR", "htmlFolder", "appDir", "indexDIR", "indexFolder", "appDIR", "appFolder", "indexPath", "scriptPath", "htmlPath"], "cssDir": ["ssDirectory", "ssdir", "csdir", "cssDb", "cssDIR", "stylesDIR", "ssDir", "cssUrl", "stylesUrl", "cmsDIR", "icsDirectory", "icsdir", "ssRect", "cmsdir", "cssdir", "cmsDirectory", "cssRect", "ssDIR", "cmsDir", "icsDir", "ssUrl", "csRect", "statsDb", "csDirectory", "csUrl", "stylesDir", "stylesDb", "cssDirectory", "csDir", "statsDir", "ssDb", "icsRect", "stylesDirectory", "stylesdir", "statsUrl"], "capDir": ["cmpDb", "CapTier", "capFile", "configFile", "capDb", "configTier", "cmpTier", "cmpDir", "configDb", "CapDb", "capTier", "cmpFile", "CapDir", "CapFile", "configDir"], "licDir": ["vidDb", "libRot", "vidDir", "liaDb", "libDir", "libDs", "licDb", "licRot", "liaRot", "liaDs", "vidDs", "libDb", "licDs", "vidRot", "liaDir"], "midDir": ["manCat", "mnCat", "pidCat", "manDir", "manRot", "pidDirectory", "manDirectory", "mnRot", "mnDirectory", "midRot", "midDirectory", "pidRot", "midCat", "pidDir", "mnDir"], "filesDir": ["sectionsIter", "videosdir", "framesIter", "sectionsJar", "videosDIR", "imagesFix", "tagsIter", "tagsJar", "filesRect", "imagesDir", "filesFix", "framesRel", "filesdir", "tagsDir", "imagesFolder", "sectionsDir", "videosFolder", "filesDIR", "videosFix", "filesRel", "framesFolder", "framesdir", "framesDIR", "pagesRel", "imagesDIR", "framesFix", "filesIter", "pagesdir", "filesJar", "framesRect", "framesDir", "pagesDir", "tagsRect", "pagesFolder", "framesJar", "filesFolder", "sectionsRect", "videosRel"], "videosDir": ["videosdir", "videosFile", "versionsFolder", "imagesDir", "imagesFolder", "videosFolder", "imagesdir", "videoDir", "versionsDir", "videodir", " videosdir", "videoFolder", "imagesFile", " videosFile", "versionsFile", " videosFolder"], "imagensDir": ["imagearsDb", "imagotsFolder", "imagmesDir", "imgensDIR", "imgetsDir", "imagetsDirectory", "imagensDb", "imagotsDir", "imagensFolder", "imgetsDIR", "imagetsDb", "imgetsFolder", "imagetsFolder", " imagensFolder", "imagensDIR", "imagearsFolder", " imagensDb", "imagmesDirectory", "imagensesDb", " imagetsFolder", "imagensesIn", "imagensesDir", "imagetsDir", " imagetsDb", " imagetsDir", "imagensDirectory", "imagetsIn", "imagearsDir", "imagearsIn", "imagetsDIR", "imgensFolder", "imagmesFolder", "imagotsDIR", "imagotsDirectory", " imagensIn", "imgensDirectory", "imagmesDIR", "imagensesFolder", "imagensIn", " imagetsIn", "imgetsDirectory", "imgensDir"], "local": ["managed", "tmp", "personal", "pid", "location", "where", "Local", "serial", "state", "lib", "central", "pal", "back", "base", "part", "server", "full", "test", "loc", "shared", "self", "south", "l", "temp", "dir", "localhost", "western", "land", "client", "single", "install", "util", "upper", "mail", "al", "global", "simple", "root", "installed", "present", "http", "val", "list", "internal", "standard", "lock", "hid", "valid", "initial", "alpha", "parent", "remote", "current", "home", "system"], "srcCss1": ["srcCSS1", "srcCcss0", "srcScssOnce", "srcCass1", "srcLss2", "srcSCass0", "srcCassOnce", "srcCsonOnce", "srcLass1", "srcLssOnce", "srcLass2", "srcSssOnce", "srcCcss3", "srcScss3", "srcScss2", "srcCass3", "srcLss10", "srcCSS2", "srcCssasso", "srcSCass1", "srcChess0", "srcCfg3", "srcLassOnce", "srcLss1", "srcCfgOnce", "srcSss3", "srcSCss1", "srcLass10", "srcCfg2", "srcChessasso", "srcCson2", "srcCssOnce", "srcCass2", "srcSss1", "srcCassasso", "srcCxx10", "srcCxx1", "srcCss0", "srcChess10", "srcCson10", "srcScss1", "srcCxxasso", "srcChess1", "srcSss2", "srcCSS0", "srcSCss3", "srcCson1", "srcCxx0", "srcCcss10", "srcCss10", "srcCcss1", "srcSCss2", "srcCass0", "srcCfg1", "srcSCass2", "srcCSS3", "srcCcss2", "srcCcssOnce", "srcSCass3", "srcSCss0", "srcCass10"], "destCss1": ["destCss100", "destSss5", "destCass1", "destCass2", "destScss5", "destCcss100", "destSass2", "destSassPre", "destCassPre", "destCxxPre", "destCcss5", "destCrss1", "destSss0", "destCcssPre", "destSass0", "destChess0", "destCrss2", "destChess1", "destSass100", "destCcss0", "destCrss5", "destScss1", "destSass1", "destCcss1", "destSss100", "destScss0", "destCxx2", "destCcss2", "destChess100", "destCss0", "destCssPre", "destSss2", "destCrss0", "destSss1", "destCass100", "destCass5", "destCass0", "destScss2", "destCxx0", "destChess2", "destCxx1", "destSssPre"], "srcCss2": ["srcSCss4", "srcCass1", "srcCtx1", "srcCtxTwo", "srcCcss4", "srcCssTwo", "srcCss48", "srcCsv52", "srcSCass4", "srcCcss3", "srcSCssTwo", "srcCcss52", "srcCass4", "srcCson4", "srcSCass1", "srcCfg8", "srcCcss48", "srcCtx2", "srcCsv2", "srcSCss1", "srcCfg4", "srcCfg2", "srcCtx4", "srcCsv3", "srcCson2", "srcCass2", "srcCffee2", "srcCassTwo", "srcCss52", "srcCsv48", "srcSCassTwo", "srcCffee3", "srcCffee1", "srcCsv1", "srcCson8", "srcCson1", "srcCffee52", "srcCcss1", "srcSCss2", "srcCcss8", "srcCfg1", "srcSCass2", "srcCcss2", "srcCss8", "srcCcssTwo"], "destCss2": ["destSss3", "destCcss56", "destCcss42", "destCcs02", "destCass1", "destCass2", "destCss56", "destCss02", "destSass2", "destSass56", "destCcss02", "destCcs42", "destCrosse1", "destCrosse4", "destCass3", "destCcss3", "destChess1", "destChess3", "destCSS2", "destCass4", "destSass1", "destCcss1", "destCSS02", "destChess56", "destCSS42", "destCcss2", "destCss42", "destCcss4", "destCcs2", "destCrosse2", "destSass3", "destCass56", "destSss2", "destSss56", "destSss1", "destChess2", "destCcs3", "destCSS3"], "srcCss3": ["srcCessThird", "srcCrss3", "srcCass03", "srcCSS2", "srcCss43", "srcCxx03", "srcCsv1", "srcSss43", "srcCSS3", "srcCcss4", "srcCss03", "srcScss43", "srcScss3", "srcCcss03", "srcCoss6", "srcCsv2", "srcCcssthree", "srcCsv3", "srcScss03", "srcCassThird", "srcCssThird", "srcCoss3", "srcCSS1", "srcCssthree", "srcCess6", "srcSss03", "srcCcss6", "srcCess4", "srcSss3", "srcCxx43", "srcCcssThird", "srcCass43", "srcCess3", "srcCessThree", "srcCrss1", "srcCrss2", "srcCcss43", "srcCcss3", "srcCass3", "srcCassThree", "srcCass4", "srcCossthree", "srcCxx3", "srcCcssThree", "srcCessthree", "srcCssThree"], "destCss3": ["destCSS1", "destCass30", "destCass1", "destCass2", "destCfg03", "destCss23", "destCess53", "destCfg3", "destCss03", "destCcss03", "destCess83", "destCass3", "destCcss83", "destCss83", "destCcss3", "destCls3", "destCass23", "destCSS2", "destCess3", "destCSS30", "destCfg23", "destCass03", "destCcss30", "destCcss1", "destCss30", "destCss53", "destCcss2", "destCcss53", "destCcss23", "destCls83", "destCls53", "destCSS3"], "srcCss4": ["srcCSSFour", "srcCcss4", "srcCssFour", "srcScss2", "srcCSS2", "srcSss5", "srcCSS4", "srcCsv4", "srcScss5", "srcCsv2", "srcCsvFour", "srcCcssFour", "srcCsv5", "srcScssFour", "srcSss4", "srcSss2", "srcCSS5", "srcSssFour", "srcCcss5", "srcScss4", "srcCcss2"]}}
{"id1": "21642215", "id2": "16798376", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["addID", "addNames", "setIDS", " addIDS", "setNames", " addID", "processNames", "processIDs", "setIDs", "addIDS", " addNames", "setID", "processIDS", "processID"], "row": ["ack", "buffer", "week", "instance", "ry", "col", "user", "rown", "raw", "batch", "post", "result", "cell", "ro", "r", "out", "rows", "ows", "item", "board", "ow", "tr", "job", "pair", "channel", "list", "record", "rank", "block", "group", "report", "entry", "roll", "star", "Row", "table", "node", "box", "error", "skip"], "name": ["version", "text", "create", "named", "type", "Name", "file", "ame", "image", "prefix", "string", "path", "item", "title", "address", "format", "a", "n", "password", "NAME", "description", "search", "value", "template", "query", "question", "label", "filename", "word", "source", "key"], "in": ["scan", "t", "reader", "bin", "din", "copy", "conn", "re", "inc", "isin", "rin", "log", "file", "el", "en", "l", "inner", "ln", "serv", "inf", "ain", "il", "at", "vin", "mc", "update", "out", "r", "ssl", "is", "input", "pin", "check", "nin", "al", " IN", "up", "er", "In", "n", "on", "get", "gin", "init", "win", "conf", "IN", "ini", "con", "local", "it", "sql", "ins", "ex", "inn", "m", "cin", "again", "db", "xml", "i", "s", "ic", "source", "form"], "urlName": ["logKey", "lKey", "UrlNAME", "urlKey", "lPath", "implPath", "implname", "implName", "urlNAME", " urlname", "lNAME", "lNames", "UrlName", "logName", "urlNames", "urlname", "urlPath", "logNAME", "implNames", "lname", "UrlNames", "lName", "Urlname", " urlNames", "implNAME", " urlPath", " urlNAME", "logname", "UrlKey"], "url": ["t", "cl", "reader", "ul", "rl", "nl", "mount", "str", "base", "el", "file", " URL", "l", "b", "gl", "loader", "web", "result", "il", "uri", "r", "client", "ssl", "browser", "ls", "open", "ref", "sl", "ur", "http", "channel", "con", "ll", "link", "rel", "ret", "URL", "char", "resource", "Url"], "inputLine": ["inputPage", "listEntry", "statusline", "formLINE", " inputline", "tableLink", "helloEntry", " inputPage", "inputPort", "firstBlock", "listLine", "dataNet", "dataBlock", "inputRecord", "keyL", "formLine", "contextLINE", "viewLINE", "submitLine", "InputLine", "latline", "patternline", " inputBlock", "operationNet", "InputFile", "inputFrame", "tempLINE", "tempLine", "contextRow", " inputFile", "statusLINE", "intLin", " inputFrame", "inputLin", "helloLINE", "singleBlock", "submitBlock", "dataLINE", "cacheLine", "viewLine", "helloPort", "inputNet", "tableLINE", "statusLine", "InputLINE", "singleLINE", "intLINE", " inputLINE", "commandBlock", "Inputline", "dataLine", " InputLine", "formFrame", "dataline", "contextLine", "cacheLINE", "sourceLine", "viewRow", "sourceLINE", "sourceNode", "keyLine", "templine", "singleDe", "inline", "cacheNode", "operationLine", "InputRow", "keyline", "dataLink", "listPort", "inputEntry", " inputRecord", " Inputline", " InputLin", "sourcePage", "patternLine", "InputL", "inputL", "latRecord", "tablePort", "inLINE", "inputFile", "inputNode", " inputNode", " inputRow", "singleLine", " InputLINE", " inputPort", "inputRow", "inputDe", "dataFrame", "patternLINE", "commandLINE", "listLINE", "inRecord", " inputDe", "InputBlock", " inputEntry", "latLine", "intLine", "statusFile", "formBlock", "commandLine", "keyLINE", "latLINE", "operationLINE", "dataPort", "inL", "cachePage", "intBlock", "tableLine", " inputLink", "inputLink", "firstLINE", "helloLine", "inputBlock", "inputLINE", " inputNet", "inputline", "inLine", "dataFile", " inputLin", "intline", "submitDe", "submitLINE", "patternRow", "firstLine"], "score": ["level", "scan", "scroll", "scale", "count", " Score", "average", "status", "sc", "scoring", "core", "length", "test", "draw", "result", " scores", "price", "distance", "grade", "index", "check", "err", "success", "goal", "weight", "rate", "confidence", "Score", "match", "depth", "value", "search", "rank", "message", "strength", "sum", "display", "report", "style", "error", "source", "loss", "set"], "metaboliteID": ["metabolitationId", "metaboliceInfo", "metabolteId", "metaboliciteid", "metaboliciteID", "metmbolitationId", "metabolisticIN", "metabolicitationID", "metaboliceId", "metaboliterName", "metaboliteId", "metabolisticId", "metmboliteId", "metabolitateid", "metabolteHandle", "metmboliteID", "metmboliteIN", "metabolitionName", "metmbolitationID", "metabolicITEId", "metaboliterID", "metabolitableUID", "metabolitationid", "metabiliteId", "metabolitionid", "metabolteUID", "metabolitationName", "metabiliteid", "metabolitionID", "metabiliteUID", "metabolitableId", "metaboliciteId", "metabiliteHandle", "metabolisticID", "metaboliciteType", "metaboliceid", "metabiliterName", "metabiliteID", "metabolicitationid", "metabiliterHandle", "metaboliteInfo", "metabolitableID", "metaboliterIN", "metabolicITEID", "metabolitateId", "metaboliteType", "metaboliterType", "metaboliteName", "metabolicITEName", "metaboliteUID", "metabolitationInfo", "metabiliterId", "metabolicitationId", "metabolteID", "metabiliterUID", "metabolicitationInfo", "metaboliciteName", "metaboliteHandle", "metabolitateID", "metaboliteIN", "metabolitateInfo", "metaboliterHandle", "metabolITEID", "metaboliterid", "metaboliciteInfo", "metabolITEType", "metabolitationIN", "metabiliterid", "metaboliteid", "metaboliterId", "metabolitesid", "metabiliteName", "metabolitesName", "metabolITEName", "metaboliceID", "metmbolitationIN", "metabolitationID", "metabolitationType", "metabolitableHandle", "metabolitesID", "metabolicITEType", "metabolITEId", "metaboliterUID", "metabiliterID"], "dataScore": ["dataTest", " dataStyle", "dataSc", " dataRank", "parentScore", "divScore", "errorWeight", "DATARank", "deviceTransfer", "ataSc", "relationWeight", "relationscore", "blockSpeed", "deviceSize", "arrayStyle", "divRank", "dataWeight", "DataRank", "deviceScore", "errorscore", " dataWeight", "deviceSc", "relationScore", "blockSc", "DATATest", "relationSize", "tdSc", " dataSc", "blockStyle", "arrayAge", " datascore", "parentTest", "dataRank", "arrayScore", " dataTest", "divSc", "DataScore", "DATASc", "DATAScore", "DataSize", "dataAge", "errorSize", "errorScore", "arraySpeed", "DataSc", "tdScore", "tdAge", " dataSpeed", "parentSc", "arraySc", "parentRank", "dataStyle", "divSize", " dataTransfer", "dataSpeed", " dataAge", "ataTransfer", "ataSize", "dataTransfer", "blockScore", "datascore", "ataScore", "dataSize", " dataSize"], "data": ["content", "text", "details", "results", "buffer", "td", "DATA", "extra", "html", "supported", "base", "ata", "space", "raw", "batch", "available", "series", "image", "draw", "hex", "string", "missing", "none", "hash", "video", "zero", "cache", "step", "rew", "chain", "multiple", "map", "dat", "params", "words", "array", "description", "all", "info", "json", "value", "size", "users", "lines", "valid", "values", "bytes", "table", "mu", "keys", "ns", "window", "set"], "molecularWeight": ["molellularWeight", "moleculeData", "mlecularWeight", "mlecularData", "mleularweight", "molecularScore", "molellularweight", "mleularScore", "moleularweight", "moleculeweight", "molecularData", "mleularWeight", "moleularScore", "moleudoScore", "moleularFont", "molellularFont", "moleularData", "mlecularFont", "moleculeWeight", "moleuralWater", "mleularFont", "moleudoWater", "mleularWater", "molecularFont", "molecularWater", "moleuralWeight", "molellularData", "moleuralScore", "moleularWater", "moleularWeight", "moleudoWeight", "molecularweight", "mlecularweight", "mlecularScore", "mlecularWater", "mleularData", "moleculeFont"]}}
{"id1": "21979462", "id2": "14877116", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURL2JSON", " downloadURL2String", " downloadurltoString", " downloadurloJSON", " downloadURLToText", " downloadURLtoJSON", " downloadurloBytes", " downloadurloText", " downloadurltoBytes", " downloadURLToBytes", " downloadurloString", " downloadURLoBytes", " downloadurltoText", " downloadURLoJSON", " downloadURLToJSON", " downloadurltoJSON", " downloadURLtoText", " downloadURLToString", " downloadURLtoBytes", " downloadURL2Bytes", " downloadURLoText", " downloadURL2Text", " downloadURLoString"], "url": ["dl", "location", "ul", "run", "mount", "base", "id", "log", "file", "l", "gl", "web", "uri", "ssl", "browser", "ls", "job", "mail", "ref", "sl", "address", "uu", "name", "bel", "un", "ur", "http", "all", "ll", "link", "domain", "ret", "URL", "char", "resource", "Url", "rect"], "in": ["io", "reader", "bin", "read", "din", "copy", "or", "re", "inc", "isin", "ind", "ill", "inner", "inf", "mc", "out", "is", "input", "check", "al", "up", "er", "In", "on", "thin", "gin", "ma", "all", "info", "conf", "IN", "mn", "con", "it", "sum", "from", "ins", "inn", "cin", "ai", "again", "i", "ic", "oin", "by", "and"], "sb": ["lb", "zb", "lp", "bg", "bd", "sg", "pa", "wb", "bh", "bs", "sd", "bf", "sk", "sam", "rob", "bis", "sq", "b", "bt", "ib", "sa", "ab", "ssl", "mb", "eb", "gc", "cb", "SB", "rb", "gb", "erb", "pb", "nb", "bj", "kb", "xb", "bp", "db", "gob", "sf", "sp", "bsp", "bn", "ub", "bb"], "str": ["text", "fr", "t", "gr", "dr", "Str", "arr", "re", "part", "comment", "div", "print", "l", "b", "comm", "bc", "pt", "next", "iter", "string", "del", "r", "ls", "tr", "br", "err", "obj", "sl", "bl", "chain", "dat", "n", "req", "exec", "p", "comp", "expr", "cur", "list", "STR", "sts", "ch", "vol", "sp", "st", "char", "j", "block", "cat", "syn", "m", "msg", "i", "s", "cont", "source", "set", "def", "txt"]}}
{"id1": "11183087", "id2": "14820302", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["Dopost", "handlepost", "handleAdd", "doPOST", "DoPOST", "handlePOST", "doAdd", " doAdd", "handlePost", "DoAdd", "DoPost", " doPOST", "dopost", " dopost"], "request": ["object", "run", "begin", "select", "web", "browser", "reference", "work", "address", "position", "frame", "search", "first", "list", "message", "subject", "initial", "model", "parent", "xml", "remote", "connect", "system", "version", "order", "server", "collection", "require", "client", "the", "application", "open", "req", "project", "get", "event", "record", "context", "law", "requ", "create", "user", "controller", "raw", "QUEST", "document", "post", "setup", "quest", "start", "url", "query", "question", "reset", "argument", "call", "forward", "re", "connection", "print", "complete", "register", "result", "input", "enter", "command", "handle", "Request", "http", "hello", "report", "current"], "response": ["reply", "respond", "content", "onse", "exit", "write", "status", "default", "view", "re", "connection", "server", "ce", "collection", "document", "image", "print", "next", "result", "e", "out", "application", "res", "success", "environment", "resp", "ve", "send", "frame", "service", "one", "context", "output", "message", "report", "entry", "to", "Response", "page"], "senha": [" senhi", "Senja", "tenHa", "ensenHA", "Senca", "senHa", "Senigma", "senja", "tinha", "tenwa", "tenja", "SenHA", "senHA", " senigma", "Senho", "Senwa", "senwa", "ensenca", "tinhas", "Senhas", "senho", "Senha", "ensenha", "tenha", " senho", "senigma", "Senhi", "renha", "renHa", "tinigma", "SenHa", " senHA", "senhas", " senhas", "renja", "ensenho", " senca", "renwa", "senca", "senhi", "tinhi"], "email": ["ip", "le", "license", "example", "echo", "detail", "secret", "oe", "ne", "live", "external", "el", "file", "username", "image", "e", "string", "line", "path", "ql", "alias", "mail", "address", "enter", "login", "IL", "name", "Mail", "password", "ails", "url", "Email", "elly", "gmail", "hello", "office", "lock", "sample", "domain", "message", "ilo", "label", "addr", "zip", "quote"], "messageDigest": ["messagemdest", "messageIGester", "messageDigester", "Messagedigse", "messagedigse", "messagediger", "messagemdester", "Messagedigester", "messageMDest", "messageDiger", "messageDigse", "messageIGse", "messageDester", "messageMDEST", "MessageDig5", "Messagedigest", "messagemdEST", "MessageDigEST", "messagedigEST", "messageDer", "MessagedigEST", "messageMDester", "messageIGest", "MessageDigest", "messageDse", "MessageDigester", "messagedig5", " messageDigester", "Messagedig5", " messagedigest", "MessageDigse", "messageDigEST", " messagedigester", " messagediger", "messagedigest", " messagedigse", " messageDiger", "messageDest", "messageDig5", "messagedigester", " messageDigse", "messageMDse", "messageIGEST", "messagemd5"], "usuario": ["usui\u00e9r", "usruarios", "usnuario", "cusu\u00e9r", "usruino", " ussuarial", "uscuario", "uscuarios", "uscuarial", "cussuario", "ussuarial", " usuarius", "uscuino", "usuarios", "ususarius", "ussuarios", " ussurio", "usruarial", "usnuarial", "ussuino", "ussuario", "ususrio", "cussuino", "usruario", "usnuarius", "cussu\u00e9r", "usuiarios", "ususarial", "usuino", "cusuarial", "ususario", " usuarial", "cusuarios", "ussuarius", "usu\u00e9r", " ussuarius", "cusuino", " ussuario", "usnurio", "ussu\u00e9r", "usuiarial", "uscu\u00e9r", "cussuarios", "ussurio", "usuarius", " usurio", "usuarial", "usurio", "usuiario", "cussuarial", "cusuario"], "redirect": ["redrict", "indirect", "edir", " redirection", "Redirection", "reddigate", "Reddraw", "ederer", " redurl", "Redirect", "redirection", "reddRECT", "inderer", " reddraw", "preddraw", "predirect", " redir", "indrict", "redigate", "rightigate", "REDir", "Redurl", "reddraw", "RedRECT", "redRECT", "predirection", "edirect", "rightRECT", "rightirection", "REDirect", "REDurl", "indirection", "rightirect", "predurl", "edirection", "redir", "Redigate", "redurl", "Rederer", "Redrict", "reddirection", "reddirect", "rederer", "edrict", "edurl", "REDirection"], "session": ["save", "instance", "state", "current", "connection", "data", "user", "server", "shared", "relation", "still", "sid", "client", "browser", "ess", "input", "cache", "application", "activity", "environment", "metadata", "ESSION", "Session", "params", "layout", "use", "cookie", "json", "container", "ession", "local", "context", "sql", "condition", "group", "person", "store", "task", "s", "trip", "window", "system"]}}
{"id1": "9805906", "id2": "21308543", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"dump": ["save", " dumped", "println", "read", "write", "copy", "debug", "download", "print", " debug", " describe", "flush", "update", "export", "diff", "send", "init", "load", "info", " println", " show", "link", " dumps", "display", "stat", "show", "store", "zip"], "source": ["text", "copy", "se", "src", "view", "scope", "select", "file", "image", "iter", "origin", "sys", "ie", "SOURCE", "input", "ource", "check", "java", "spec", "ink", "start", "Source", "script", "init", "search", "service", "template", "info", "local", "sample", "sequence", "site", "sql", "from", "style", "config", "shell", "resource", "parent", "store", "remote", "form"], "target": ["t", "replace", "top", "copy", "current", "arget", "host", "compatible", "base", "file", "test", "dest", "next", "gt", "pattern", "mac", "term", "goal", "tif", "project", "delete", "match", "arg", "template", "proxy", "local", "it", "link", "output", "that", "null", "style", "to", "table", "bolt", "Target"], "is": ["tis", "ip", "mos", "ists", "iris", "in", "ii", "es", "sis", "isin", "isc", "bis", "isi", "has", "ib", "isf", "im", "bits", "ics", "ist", "sys", "oss", "iso", "ms", "lis", "ls", "nis", "ys", "ois", "its", "IS", "ris", "are", "si", "init", "ais", "ims", "isa", "iss", "it", "ios", "isl", "abs", "ir", "ar", "ins", "act", "ai", "i", "Is", "ic", "s", "ri", "xs"], "os": ["dos", "nos", "ss", "io", "ps", "mos", "ose", "Os", "or", "es", "bs", "ros", "js", "OS", "pos", "oS", "cs", "bos", "sys", "ot", "oss", "ows", "ds", "oos", "oses", "ls", "ants", "uts", "ox", "ols", "los", "fs", "o", "ost", "outs", "ios", "css", "obs", "osi", "oes", "cos", "s", "ts", "ns", "aos"], "done": ["checked", "shown", "started", "Done", "du", "disabled", "led", "needed", "des", "gone", "seen", "enabled", "complete", "continue", "flag", "did", " continued", " Done", "ished", "progress", "pleted", "de", "found", "created", "later", "d", "di", "loaded", "set", "expected", "made", "die", "finished", "desc", "only", "failed", "valid", "dirty", "given", "filled", "ded"]}}
{"id1": "20310134", "id2": "12783713", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyfile", " copyStream", " cpStream", " cpDirectory", " cpfile", " CopyDirectory", " CopyStream", " Copyfile", " duplicateDirectory", " cpFile", " duplicateFile", " duplicatefile", " copyDirectory", " duplicateStream"], "in": ["io", "din", "id", "inc", "isin", "rin", "ind", "el", "en", "l", "b", "inf", "ain", "r", "as", "is", "input", "up", "In", "old", "on", "gin", "init", "ini", "IN", "it", "from", "ins", "inn", "cin", "i", "mm", "ic", "source"], "out": ["c", "t", "io", "v", "po", "ne", "help", "os", "log", "l", "b", "serv", "at", "gt", "ot", "err", "nt", "op", "n", "p", "o", "net", "w", "it", "outs", "output", "Out", "ex", "null", "to", "msg", "g", "s", "ou", "OUT"], "inChannel": ["sinButton", "sinCase", "sinListener", "cinRoom", "inButton", " inCase", " inApplication", "inChan", "cinListener", "cinChannel", "cinCase", "oinConnection", "inputChannel", "cinClient", "inApplication", " inRoom", "outchannel", " inchannel", "dinButton", "oinChannel", "inputCommand", "dinChan", "sinClient", "cinButton", " inChan", "intButton", "sinChannel", "insideCommand", "inClient", "inchannel", "intCommand", " inCommand", " inConnection", "inputPanel", " inButton", "oinApplication", "inCase", "inListener", "dinChannel", "outApplication", "inRoom", "inConnection", "inCommand", "sinRoom", " inPanel", "oinchannel", "insidePanel", "inPanel", " inClient", "insideChannel", "intChannel", "intChan", " inListener", "outConnection", "dinCommand"], "outChannel": ["cosCategory", "noteMember", "noteChannel", "inChan", " outCategory", "outputCh", "outCategory", "fullCategory", "outputchannel", "OUTCan", "outerConnection", "cosChan", "outerUser", "outUser", "outchannel", "OUTChannel", "OUTChan", "outCan", "inchannel", " outUser", "outMember", " outChan", "fullCan", "fullChannel", "OUTCategory", "outputChan", "fullChan", "outerChannel", "outCh", "outputConnection", "outputChannel", "noteChan", "inCh", " outCan", "inMember", "outputUser", "outerChan", "outChan", " outchannel", "inCategory", "cosChannel", " outConnection", "noteCategory", " outCh", "cosMember", "outConnection"]}}
{"id1": "8216539", "id2": "13333160", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasString", "getFileContentasStr", "getFileContentAsText", "getFileTextAsText", "getFileContentAsStr", "getFileTextAsString", "getFileTextAsStr", "getFileContentasText"], "filePath": ["baseString", "basePath", "FileString", " fileName", " fileInfo", "fileDef", "entryName", "ileDef", "FILEPath", "FILEpath", "FilePath", "FileName", "ilePath", "FileDef", "ileInfo", "FILEName", "fileName", "filepath", "baseName", "FILEPATH", " filepath", "ileName", "entrypath", " fileString", "FileInfo", "FilePATH", "fileInfo", "entryPath", "filePATH", " fileDef", "Filepath", "basepath", "fileString", "entryPATH"], "encoding": ["enoding", "enaching", "unicode", "encuing", "ENCaching", "enode", "unicuing", "characteraching", "Encging", "encode", "enuing", "Encordering", "Encuing", "Encode", "Encoding", "unicaching", "encging", "Encaching", "characterging", "characterordering", "encordering", "unicoding", "characteroding", "encaching", "ENCging", "ENCoding", "ENCordering"], "testURL": ["testingUR", " testUR", "TestSR", " testRE", "checkURL", "testRE", "TestUR", "testUrl", " testUrl", "testedUrl", "checkUrl", "TestURL", "testedRE", "testingUrl", "testUR", "checkSR", "testedUR", "testingSR", "testingRE", "checkUR", "testedURL", "TestUrl", " testSR", "testSR", "testingURL"], "input": ["tmp", "data", "quick", "batch", "has", "iter", "focus", "address", "exist", "up", "Input", "PUT", "init", "list", "output", "act", "config", "xml", "pull", "read", "in", "file", "inner", "add", "lat", "q", "client", "missing", "hidden", "audio", "open", "eval", "get", "qa", "context", "can", "quit", "stream", "comment", "upload", "raw", "image", "op", "exec", "start", "url", "json", "channel", "cur", "it", "sample", "cont", "source", "ip", "submit", "reader", "view", "acl", "active", "accept", "command", "feed", "hello", "unsigned", "from", "empty", "current", "form", "iterator"], "sw": ["wra", "sb", "igm", "kw", "SW", "enc", "sc", "sn", "wh", "sm", "sk", "wl", "sv", "hw", "was", "wr", "su", "sa", "ows", "tw", "ow", "wo", "fw", "aw", "sem", "rew", "sl", "ws", "sur", "iw", "nw", "ews", "wn", "wa", "ew", "Sw", "w", "we", " Sw", "sh", "sf", "sp"]}}
{"id1": "335223", "id2": "7911686", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "659316", "id2": "18570190", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"argv": ["argvs", " argc", "argV", "argc", "argsc", "Argm", "suppp", "callv", "argsV", "argss", " argm", "Argc", " argvs", "callp", "callV", "Args", "suppvs", " argp", "Argv", "argsm", "suppV", "callvs", "ArgV", "suppv", "argp", " argV", "argsv", "argm"], "sources": ["servors", " sets", "seets", "servures", " sodes", " soots", "slources", "seodes", "sliders", "inults", "tocks", "sloots", "inets", "sors", " sors", "tiders", "soots", "sults", "seults", "servources", "sodes", "inources", "slocks", "seources", "socks", " socks", " sults", "inodes", "tources", "stets", "servets", "stources", "sets", "siders", "sures", "stures", " sures", "stors", "toots", " siders"], "targets": ["targetgers", "toksets", "tankgers", "tokends", "Targets", "tokgers", "Topches", "tassends", "tanges", "targgers", "toolsarggers", " targens", "toolsargsets", "targetens", "topens", "Targends", "topends", "targetsets", "tangens", "toolsargets", "tangches", " targes", "topets", "tokes", "tassets", "targetets", "tassches", "Targches", "tasses", " tangends", "tokens", " targends", "tokets", "targens", "tankets", " tangens", "Topets", "targches", "topches", "tanksets", "targsets", "toolsankgers", "toolsargens", "topes", "toolsankets", "Targes", "toolsankens", " tanges", "Topes", "targends", "toolsanksets", "tangends", "Topends", "tangets", "tankens", "targes", " tangets"], "srclen": ["srklog", " srplade", "srklue", "rsclogn", "srselen", "srselog", "srklogn", "srccue", "rsclog", "srclue", " srpln", "srseln", "srccen", "srselade", "rsccog", "rsclue", " srclength", "srklen", "srCLen", "srpln", "srselue", "srccog", " srcln", "srselogn", " srplen", "srselength", "srplen", "srplade", " srclade", " srplength", "rsccen", "srclogn", "srclength", "srplength", "srCLade", "rsccue", "srcln", "rsccogn", "srccogn", "srclog", "srCLength", "rsclen", "srclade", "srCLn"], "source": ["scan", "scale", "create", "reader", "buffer", "score", "status", "copy", "src", "scope", "select", "this", "file", "inner", "trace", "secure", "iter", "console", "sys", "SOURCE", "input", "ource", "cache", "start", "Source", "root", "me", "get", "escape", "wrapper", "service", "match", "template", "search", "query", "info", "force", "internal", "link", "sequence", "local", "standard", "context", "from", "site", "null", "style", "store", "resource", "parent", "s", "sp", "ser", "set", "system"], "tgt": ["tgn", "tegt", " tht", "tegn", "tpt", "nht", " targ", "warg", "tetarget", "itarg", "Targ", "itht", "ngn", "targ", "tearget", "itgt", "teht", "ngt", "itarget", "tht", "ittarget", "starget", "wtarget", "stgt", "Tht", "tept", "npt", "tearg", "wgt", " tpt", "sttarget", "warget", " ttarget", "ttarget", "starg", " tgn", "Tgt", "Target"], "target": ["peer", "tmp", "buffer", "stable", "top", "manager", "copy", "member", "arget", "base", "dest", "inter", "next", "trace", "secondary", "localhost", "sys", "gt", "out", "child", "ARGET", "pointer", "mask", "path", "goal", "wrapper", "match", "touch", "template", "channel", "proxy", "local", "internal", "rel", "link", "output", "null", "socket", "to", "table", "parent", "resource", "trap", "writer", "owner", "handler", "bolt", "Target"], "deletes": ["Deels", "dulets", "desges", "desleted", "seles", "delves", "delletes", "delets", "duletes", "seletes", "dules", "seels", "seleted", "leletes", "deles", "Deles", "deels", "Deletes", "desets", "desletes", "dellets", "deves", "dleted", "deleted", "dges", "desves", "duges", "duels", "lelets", "duleted", "deets", "leets", "leves", "dletes", "deges", "Deleted", "dlets", "deslets"], "del": ["compl", "dl", "ele", "le", "cl", "dis", "dr", "se", "inv", "let", "re", "nl", "rl", "des", "ne", "rem", "md", "col", "el", "els", "tl", "rol", "l", " dele", "dec", "ls", "tr", "pel", "de", "elt", "err", "bl", "nt", "pl", "len", "delete", "cel", "vet", "kl", "ll", "Del", "rel", "syn", "sel", "dem", "def"]}}
{"id1": "10728243", "id2": "2199604", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scrambles ", "scramblesPassword", "scrambled ", "scrambledpassword", "scambleBasic", "scramlepassword", "scramblePassword", "scramlePassword", "scramblesBasic", "scamblesPassword", "scamblepassword", "scrambledBasic", "scamblespassword", "scrambledPassword", "scramble ", "scramle ", "scramleBasic", "scamblePassword", "scrambleBasic", "scramblepassword", "scamble ", "scambles ", "scamblesBasic", "scramblespassword"], "password": ["text", "wd", "secret", "padding", "data", "key", "user", "attribute", "username", "phrase", "prefix", "sword", "string", "profile", "pattern", "crypt", "hash", "email", "database", "primary", "address", "remember", "shadow", "pass", "words", "token", "description", "hello", "message", "reset", "auth", "word", "Password"], "seed": ["example", "create", "padding", "secret", "se", "derived", "prime", "test", "sex", "phrase", "eder", "mix", "Salt", "needs", "hash", "df", "sudo", "index", "setup", " seeds", "start", "shadow", "feed", " seeded", "eed", "template", "sample", "rand", "sequence", "sql", "vector", "entry", "reset", "random", "initial", "offset", "ser", "source", "key"], "md": ["pm", "img", "bd", "MD", "ct", "managed", "dh", "pdf", "det", "cd", "rpm", "med", "dr", "rd", "td", "ann", "sd", "multi", "sm", "mand", "mt", "ind", "mod", "esm", "pt", "dd", "hd", "mc", "sha", "dig", "cmd", "df", "mk", "mb", "nd", "dm", "ms", "amd", "de", "pd", "mind", "nt", "metadata", "grad", "exec", "mp", "pkg", "d", "ma", "der", "di", "ld", "rm", "mn", "od", "cm", "desc", "gm", "m", "addr", "msg", "ad", "mm", "red", "mg", "def"], "passwordHashStage1": ["passwordHashSHA1", "passwordhashStage0", "passwordHashPhase0", "passwordHashstageOne", "passwordHashSHA01", "passwordHashPage5", "passwordhashStage1", "passwordHashPage0", "passwordhashstage2", "passwordHashSHA2", "passwordhashstage1", "passwordhashStage2", "passwordHashstage5", "passwordHashstage0", "passwordHashPage1", "passwordHashStage5", "passwordhashstage0", "passwordHashPhase1", "passwordhashStageOne", "passwordHashPhaseOne", "passwordHashstage01", "passwordHashStage0", "passwordhashstageOne", "passwordHashPhase2", "passwordHashStageOne", "passwordHashstage1", "passwordHashstage2", "passwordHashPage2", "passwordHashStage01", "passwordHashSHA0"], "passwordHashStage2": ["passwordHashVersion4", "passwordHashPhase4", "passwordHashScene62", "passwordHashSceneTwo", "passwordHashStage4", "passwordHashVersionTwo", "passwordHashScene2", "passwordHashStage3", "passwordHashVersion1", "passwordSaltStage3", "passwordHashstage4", "passwordHashStyle62", "passwordHashPhaseTwo", "passwordHashStage62", "passwordHashPhase1", "passwordHashStageTwo", "passwordHashStyle2", "passwordHashPhase2", "passwordHashstage1", "passwordHashstage2", "passwordHashStyleTwo", "passwordHashScene3", "passwordHashVersion2", "passwordSaltStage2", "passwordSaltStageTwo", "passwordHashStyle3", "passwordSaltStage62", "passwordHashstageTwo"], "toBeXord": ["toBEXord", "toBeXLords", "toBeZor", "toBeZord", "toBeTxorg", "toBeXLod", "toBEXond", "toBeZXold", "toBEXod", "toBexords", "toBeYord", "toBeXond", "tobeXord", "toBeXLord", "toBeYorg", "toBeYords", "toBeTxord", "toBeZXor", "toBeZXord", "tobeYords", "toBeTxond", "toBeXod", "toBEXorg", "toBexorg", "toBexond", "tobeXorg", "tobeYord", "toBeTxords", "tobeYorg", "toBEXor", "tobeXor", "toBeXLor", "toBeYor", "tobeYor", "tobeYold", "toBEXords", "tobeXold", "toBeXorg", "toBeYold", "toBeXords", "toBeZXords", "toBeZorg", "toBexord", "toBeXor", "toBeZords", "toBeXold", "toBeYod", "toBexor", "tobeXords"], "numToXor": ["numToXord", "numToXore", "numtoXor", "numToxors", "numToXors", "numToYOR", "num2Restors", "num2Xore", "numToRestor", "numtoYOR", "numToZOR", "numToRestore", "numtoXors", "numToZors", "numToxord", "numToRestOR", "num2XOR", "numToZore", "num2Restor", "numToYord", "numToYor", "numToZor", "numToRestors", "num2Xors", "numToxor", "numtoXord", "numtoYor", "num2Restore", "num2RestOR", "numtoYors", "numtoXOR", "numToxore", "numToYors", "numtoYord", "numToZord", "numToXOR", "numToxOR", "num2Xor"], "i": ["ip", "t", "li", "y", "io", "span", "bi", "in", "ii", "k", "phi", "multi", "xi", "I", "u", "fi", "ui", "ind", "mi", "batch", "e", "gi", "uri", "im", "cli", "x", "is", "ti", "ie", "ci", "pi", "ji", "n", "qi", "ni", "si", "ix", "init", "di", "info", "ini", "ei", "o", "it", "sequence", "sim", "j", "ex", "\u0438", "m", "z", "ai", "us", "g", "ic", "zi", "ri", "s", "set", "ms"]}}
{"id1": "14617444", "id2": "2511579", "code1": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 0, "substitutes": {"readUNI": ["readUnION", "readUNi", " readANION", " readUni", " readUNION", " readUnION", " readANI", " readANi", " readUNS", " readOUION", " readUnI", "readUnS", " readOUi", "readUNS", " readOUI", "readUni", " readUNi", "readUnI", " readOUS", " readANS", "readUNION", " readUnS"], "descriptions": ["descriptations", "describesisions", "desriptions", "descriptisions", "desccription", "desccriptisions", "describations", "descructions", "describescriptions", "descriptIONS", "desccriptions", "desccripturations", "describedions", " describedIONS", " describedcriptions", "describions", "desripturations", "desription", "describurations", " descriptcriptions", "descriptcriptions", "describesions", "desccriptations", " descriptisions", "descripturations", "description", "desriptations", " describedisions", "describedcriptions", "describion", "describesIONS", "descruction", "descructurations", " describedions", "desccriptcriptions", "describedIONS", " descriptIONS", "desccriptIONS", "descructations", "describedisions"], "source": ["content", "text", "in", "src", "stream", "file", "uri", "body", "string", "origin", "SOURCE", "path", "input", "ource", "address", "name", "note", "start", "Source", "description", "target", "value", "sample", "sequence", "message", "from", "output", "sql", "subject", "style", "code", "resource", "i", "s", "seed", "filename"], "is": ["ip", "tis", "ists", "dis", "iris", "in", "es", "bs", "os", "sis", "isin", "isc", "bis", "isi", "has", "isp", "serv", "was", "isf", "sys", "as", "oss", "iso", "lis", "ys", "ws", "ois", "its", "IS", "sels", "ris", "info", "fs", "ims", "ais", "isa", "iss", "ios", "isl", "ir", "ins", "us", "i", "Is", "s", "ms"], "url": ["build", "ul", "host", "nl", "mount", "str", "html", "user", "file", "loc", "lr", "l", "gl", "web", "google", "uri", "ssl", "browser", "ls", "open", "mail", "sl", "address", "name", "bel", "ur", "get", "f", "pl", "http", "service", "hl", "ll", "link", "rel", "abs", "URL", "char", "resource", "Url"], "scanner": ["pener", "scanter", "ScanNER", "Scanning", "Scaner", "canNER", "penner", "canning", "scanning", "caner", "scaner", "gatening", "Scaniner", "scaniner", "gatener", "Scanner", "caniner", " scanter", "gateter", " scanNER", "Scanter", "penter", "peniner", "canner", "canter", "scanNER", "gateer", " scaner"], "line": ["ip", "text", "le", "detail", "lin", "inline", "range", "se", "nl", "str", "ne", "comment", "log", "file", "raw", "liner", "LINE", "l", "ln", "cell", "iter", "Line", "eline", "lo", "string", "email", "ine", "ide", "online", "pe", "frame", "row", "query", "record", "link", "lines", "block", "char", "entry", "label", "code", "word", "page", "lc", "header"], "id": ["ip", "rid", "mid", "pid", "status", "ver", "uid", "part", "md", "iden", "ind", "wid", "hd", "ident", "iter", "sid", "aid", "ids", "title", "name", "ide", "ID", "description", "init", "info", "od", "tag", "it", "link", "oid", "label", "bid", "ad", "kid", "i", "h", "db", "key", "Id", "and"], "desc": ["text", "dl", "disc", "cd", "sc", "dev", "sup", "des", "str", "esc", "md", "comment", "dest", "pr", "dc", "sub", "phrase", "Desc", "dir", "cmd", "ds", "dec", "title", "name", "diff", "seq", "description", "Description", "info", "json", "dist", "sec", "tag", "rel", "asc", "sum", "null", "pro", "label", "doc", "msg", "cmp", "attr", "ser", "lc", "def", "summary"], "linescanner": ["linesscaninner", "linesgateener", "linespinner", " linesscann", "linespaninner", " linescanter", "inesanters", "lineskinter", "linesannner", "linesgateNER", "linesscanter", "linesgatener", " linesscanner", "linecancer", "linesscann", "lineskners", "inescaninner", "linesscanner", "linespininner", "linecanter", "lineskner", "linescaner", "linescanener", "linesancer", "linespanner", "linesscanener", "linesscanNER", "lineskinner", "linescancer", "linesanner", "linesancell", "linesscaner", "inesscanner", "inescancell", "inescanener", " linescaninner", " linescaner", "linespinters", "linesscancell", "linesanners", "linesscancer", "inesanner", "linesann", "linesanninner", "linesaninner", "linecanner", " linesscaninner", "linescancell", "inesscanNER", "inesscanener", "linesannter", "inescanter", "linesscanters", "linesanncell", "inescanNER", "lineskiner", "inesscanter", "linespanener", "linesaner", "lineskter", "inesancell", "inesanter", "linesanters", "linespinter", "linespanNER", "linescanners", "linescanters", "linescaninner", "linecaninner", "inesaninner", " linesscaner", " linescann", "inescanner", "linescanter", "linesanncer", "linesgateter", " linesscanter", "inescanners", "linesscanners", "linespann", "linespanter", "linescann", "inescanters", "inesanners", "linesanter", "linescanNER", "lineskininner"]}}
{"id1": "659316", "id2": "14191679", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"argv": ["argvs", " argc", "argV", "argc", "argsc", "Argm", "suppp", "callv", "argsV", "argss", " argm", "Argc", " argvs", "callp", "callV", "Args", "suppvs", " argp", "Argv", "argsm", "suppV", "callvs", "ArgV", "suppv", "argp", " argV", "argsv", "argm"], "sources": ["servors", " sets", "seets", "servures", " sodes", " soots", "slources", "seodes", "sliders", "inults", "tocks", "sloots", "inets", "sors", " sors", "tiders", "soots", "sults", "seults", "servources", "sodes", "inources", "slocks", "seources", "socks", " socks", " sults", "inodes", "tources", "stets", "servets", "stources", "sets", "siders", "sures", "stures", " sures", "stors", "toots", " siders"], "targets": ["targetgers", "toksets", "tankgers", "tokends", "Targets", "tokgers", "Topches", "tassends", "tanges", "targgers", "toolsarggers", " targens", "toolsargsets", "targetens", "topens", "Targends", "topends", "targetsets", "tangens", "toolsargets", "tangches", " targes", "topets", "tokes", "tassets", "targetets", "tassches", "Targches", "tasses", " tangends", "tokens", " targends", "tokets", "targens", "tankets", " tangens", "Topets", "targches", "topches", "tanksets", "targsets", "toolsankgers", "toolsargens", "topes", "toolsankets", "Targes", "toolsankens", " tanges", "Topes", "targends", "toolsanksets", "tangends", "Topends", "tangets", "tankens", "targes", " tangets"], "srclen": ["srklog", " srplade", "srklue", "rsclogn", "srselen", "srselog", "srklogn", "srccue", "rsclog", "srclue", " srpln", "srseln", "srccen", "srselade", "rsccog", "rsclue", " srclength", "srklen", "srCLen", "srpln", "srselue", "srccog", " srcln", "srselogn", " srplen", "srselength", "srplen", "srplade", " srclade", " srplength", "rsccen", "srclogn", "srclength", "srplength", "srCLade", "rsccue", "srcln", "rsccogn", "srccogn", "srclog", "srCLength", "rsclen", "srclade", "srCLn"], "source": ["scan", "scale", "create", "reader", "buffer", "score", "status", "copy", "src", "scope", "select", "this", "file", "inner", "trace", "secure", "iter", "console", "sys", "SOURCE", "input", "ource", "cache", "start", "Source", "root", "me", "get", "escape", "wrapper", "service", "match", "template", "search", "query", "info", "force", "internal", "link", "sequence", "local", "standard", "context", "from", "site", "null", "style", "store", "resource", "parent", "s", "sp", "ser", "set", "system"], "tgt": ["tgn", "tegt", " tht", "tegn", "tpt", "nht", " targ", "warg", "tetarget", "itarg", "Targ", "itht", "ngn", "targ", "tearget", "itgt", "teht", "ngt", "itarget", "tht", "ittarget", "starget", "wtarget", "stgt", "Tht", "tept", "npt", "tearg", "wgt", " tpt", "sttarget", "warget", " ttarget", "ttarget", "starg", " tgn", "Tgt", "Target"], "target": ["peer", "tmp", "buffer", "stable", "top", "manager", "copy", "member", "arget", "base", "dest", "inter", "next", "trace", "secondary", "localhost", "sys", "gt", "out", "child", "ARGET", "pointer", "mask", "path", "goal", "wrapper", "match", "touch", "template", "channel", "proxy", "local", "internal", "rel", "link", "output", "null", "socket", "to", "table", "parent", "resource", "trap", "writer", "owner", "handler", "bolt", "Target"], "deletes": ["Deels", "dulets", "desges", "desleted", "seles", "delves", "delletes", "delets", "duletes", "seletes", "dules", "seels", "seleted", "leletes", "deles", "Deles", "deels", "Deletes", "desets", "desletes", "dellets", "deves", "dleted", "deleted", "dges", "desves", "duges", "duels", "lelets", "duleted", "deets", "leets", "leves", "dletes", "deges", "Deleted", "dlets", "deslets"], "del": ["compl", "dl", "ele", "le", "cl", "dis", "dr", "se", "inv", "let", "re", "nl", "rl", "des", "ne", "rem", "md", "col", "el", "els", "tl", "rol", "l", " dele", "dec", "ls", "tr", "pel", "de", "elt", "err", "bl", "nt", "pl", "len", "delete", "cel", "vet", "kl", "ll", "Del", "rel", "syn", "sel", "dem", "def"]}}
{"id1": "3514286", "id2": "2807585", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getHashedPassword": ["getHackedPassword", "getShashedUser", "getHackedUser", "getShashPassword", "getShashedPassword", "getHashedSecret", "getShashSecret", "getHashespassword", "getShashUser", "getHashesSecret", "getHashesUser", "getHashedUser", "getHashedpassword", "getShashedpassword", "getHashUser", "getHackedSecret", "getShashedSecret", "getHackedpassword", "getHashPassword", "getShashpassword", "getHashpassword", "getHashesPassword", "getHashSecret"], "password": ["text", "wd", "secret", "padding", "default", "data", "key", "user", "raw", "attribute", "username", "phrase", "prefix", "sword", "string", "pattern", "hash", "input", "email", "database", "address", "login", "name", "command", "REDACTED", "wordpress", "shadow", "pass", "description", "token", "value", "message", "reset", "word", "Password"], "digest": ["dested", "digests", "digse", "mdest", " digester", "hashest", "Digests", "hashse", " Digse", " digse", "mdests", "dest", "mdse", "digester", "mdester", " digested", " digests", "digested", " Digest", " Digester", "hashests", "Digest", "dests", "Digester", "hashested", "hashester", "Digested", "Digse"], "hashedInt": ["happedInt", "hushedId", "hushedInteger", "hashedId", "hashINT", " hushedTx", " hashedInteger", "hhedInteger", "hashashedINT", "happedInteger", "hashashingInteger", "hashInteger", "hashingInteger", "hushedTx", "hashashedInteger", "hashInt", "hashedINT", "hashedTx", " hushedInteger", "hcheckedInt", " hashedId", "hashingINT", "happedId", "hashashedInt", "hhedId", "hashingInt", "hashashingINT", "hcheckedINT", " hushedId", " hashedTx", " hushedInt", "hashedInteger", "hashashingInt", "happedTx", "hhedInt", "hushedInt", "hhedTx", "hcheckedInteger"]}}
{"id1": "13563706", "id2": "2465747", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"doGet": ["handleget", " doGET", "Doget", "DoPut", "DoGet", "doPut", "handleGET", "handleGet", "handlePut", "doget", "doGET", "DoGET", " doget", " doPut"], "request": ["version", "create", "re", "each", "view", "connection", "order", "user", "attribute", "QUEST", "document", "complete", "route", "transform", "input", "reference", "path", "application", "setup", "address", "command", "position", "project", "get", "url", "Request", "use", "http", "frame", "search", "hello", "first", "directory", "query", "event", "context", "message", "subject", "report", "reset", "initial", "socket", "call", "resource", "xml", "parent", "current", "forward"], "response": ["version", "reply", "respond", "fire", "example", "exit", "write", "status", "default", "view", "foundation", "connection", "tree", "server", "answer", "ce", "collection", "document", "print", "image", "relation", "next", "continue", "result", "console", "render", "security", "hash", "zero", "application", "res", "success", "format", "position", "resp", "ve", "description", "http", "frame", "network", "search", "json", "service", "sequence", "block", "output", "message", "condition", "display", "report", "see", "Response", "header", "summary"], "selectedPage": ["electedpage", "selectItem", "specifiedPage", "electionDocument", "selectedPath", "singlePort", "namedpage", "matchedPort", "electionFrame", "selectedKey", "selectedpage", "electedFrame", "selectLine", "selectedDocument", "namedFrame", "selectionItem", " selectedFile", "singlepage", "namedKey", "selectionLine", "electionPort", "lectedpage", "verifiedRow", " selectedPath", "electedPort", "selectedItem", "lectedItem", "selectPath", "matchedPage", "lectedRow", "selectedFrame", "lectedPort", "specifiedDocument", "selectedToken", "verifiedpage", "lectedKey", "lectedLine", "selectedRow", "selectionPort", "selectFile", " selectedLine", "namedLine", "singleFrame", "electionPage", "namedPort", "selectPort", "selectionPage", " selectedpage", "lectedPath", "matchedpage", "namedPage", "verifiedPage", "specifiedFrame", " selectedKey", "singlePage", "selectionFile", " selectedFrame", "verifiedFile", "specifiedPort", "electedPage", "selectedLine", "namedToken", "lectedPage", "lectedDocument", "lectedFrame", "matchedFrame", "lectedFile", " selectedRow", "selectedFile", "selectedPort", "selectPage", "selectionToken", "lectedToken", " selectedPort"], "page": ["object", "profile", "address", "position", "frame", "row", "message", "output", "node", "parent", "filter", "rule", "version", "server", "collection", "next", "phone", "client", "menu", "pointer", "cache", "application", "policy", "successful", " Page", "project", "site", "record", "group", "window", "age", "point", "user", "document", "phrase", "image", "self", "language", "pages", "line", "created", "me", "url", "p", "layout", "be", "network", "channel", "office", "force", "Page", "block", "pp", "to", "table", "resource", "peer", "instance", "view", "log", "pool", "complete", "result", "chain", "number", "proxy", "display", "port", "associated", "current", "form"], "portalRequest": ["portalingAccess", "portalerequest", "portalidRequest", " portaleApply", "terminalidQuery", "portsortalrequest", "portortalRequest", " portalCall", "PortaleQuery", "terminalRequest", "terminalSession", "portsortalResponse", "portaleEvent", "PortalRequest", "portalApply", "portaleContext", "portaleFrame", "portalaAccess", "PortaleThread", "portalQuery", "portaleAccess", "portpalRequest", "PortaleRequest", "portalingCall", "portortalContext", "portortalResponse", "portalityRequest", "portaleQuery", "portortalrequest", "portalaRequest", "portalAccess", "PortaleFrame", "portalrequest", "portortalQuery", "portalContext", "portaleResponse", "portaleCall", "portalThread", "portsalResponse", "portortalThread", "portualRequest", "terminalQuery", "portalityContext", "PortalQuery", "portsortalRequest", "PortaleContext", "portalidResponse", "portpalContext", "portalityFrame", " portaleRequest", "PortalResponse", "portalFrame", " portaleCall", "portalidFrame", "portalEvent", "portalityResponse", "PortalFrame", "portalingApply", "PortalThread", "portalidQuery", "portsalRequest", "portsortalEvent", "portalSession", "portaleRequest", "portualResponse", "portualrequest", " portalAccess", "portpalThread", "portaleSession", "portralResponse", "portralRequest", "portalCall", "portpalResponse", "portralSession", "portalaCall", "terminalidSession", "portaleThread", "portortalEvent", "portalResponse", "portralQuery", "portalidSession", "terminalidResponse", "terminalidRequest", "portralContext", "portsalrequest", "portsalEvent", " portalApply", "portalaApply", " portaleAccess", "portualEvent", "terminalResponse", "portaleApply", "portalidContext", "portalingRequest", "PortalContext", "PortaleResponse"], "pageProp": ["imagePred", "ageProp", "profilePred", "profileZip", "keyPr", "propertyDef", " pageProperty", "pagePred", "pagePr", "phraseComp", "officePriv", " pageDef", "pagePriv", "poolProp", "sectionZip", "imagePr", "imagePro", " pagePred", "sectionPred", "propertyProp", "officeProp", "phraseProperty", "pagePro", "keyComp", "sectionPro", "propertyPack", "poolPro", " pagePr", "officeDef", "officePack", "sectionProp", "phrasePr", "imageProp", "poolPred", "pageZip", "pageComp", "agePred", "pageDef", " pageComp", "keyProp", "propertyPriv", " pagePack", "poolZip", "profilePro", " pagePriv", " pagePro", "profileProp", "phraseProp", "pageProperty", "agePr", "agePro", "pagePack", "keyProperty"], "possiblePage": ["pableTag", "pbablePage", "PossibleCollection", "pentialpage", "pbableCollection", " packedPage", "pibleUser", "pentialPage", "packedCollection", "possibleLine", "PossibleTag", "possiblyLine", "packedLine", " possibleCollection", "PossiblePage", "pentialTag", "possibleUser", "pableLine", "PossiblyPage", "PossibleUser", "PossiblePages", "pspecifiedpage", "PossiblyChild", "pibleChild", " packedTag", "piblePage", " packedCollection", " packedLine", "possiblyPage", "possiblepage", "pspecifiedPage", "possiblyTag", "possibleCollection", "pspecifiedPages", "possiblyUser", "pspecifiedTag", "PossiblyUser", "pbableUser", "possiblyCollection", "packedTag", "possibleTag", "pableCollection", "packedPage", "pbableChild", "pentialPages", "possiblePages", "PossiblyCollection", "Possiblepage", "pibleCollection", "pablePage", " possibleLine", "PossibleChild", "possiblyChild", " possibleTag", "possibleChild"], "property": ["object", "location", "type", "rue", "behavior", "prop", "attribute", "relation", "phrase", "integer", "expression", "trace", "string", "definition", "operator", "policy", "title", "address", "name", "metadata", "command", "variable", "position", "p", "feature", "description", "frame", "properties", "service", "value", "Property", "domain", "field", "message", "config", "function", "resource", "second", "owner", "rule", "key", "header", "class"], "referer": ["printrer", "Refrer", "refrier", "refender", "rederee", "reerential", "frer", "reener", "redrer", "reeree", "diffrer", "refirect", "defrer", "fering", "deferer", "retrer", "fener", "reterer", "defirect", "reere", "reender", "defered", "Refere", "rearer", "rorered", "relender", " refirect", "aferer", "Referee", "reerer", "reportered", "ferer", "refered", "refarer", "refere", "rangeerer", "printerer", "refering", "requerer", "verrer", "differing", "reportarer", "diffonder", "relener", "reportrer", "printerential", "reered", "verrier", "rangerer", "referential", "relering", "relerer", "rangeener", "refener", "reonder", "rederer", "Referer", "relrer", "redere", "requonder", "reporterer", "vererer", "printrier", "rorerer", "relerential", "rerer", " refrer", " refered", "aferential", "requrer", "rerier", "rorirect", "refrer", "rangeender", "refonder", "differer", "referee", "vererential", "retered", "reering", "retarer", "afener", "requering", "afrer", "rorrer"], "e": ["t", "ae", "echo", "te", "eur", "se", "eu", "eeee", "es", "oe", "ception", "ge", "eg", "r", "x", "ie", "err", "de", "a", "er", "n", "me", "p", "f", "o", "event", "ee", "E", "m", "g", "h", "error"]}}
{"id1": "19467540", "id2": "18202328", "code1": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 0, "substitutes": {"updateProductIfAvailable": ["updateProductOrValid", "updateProductWhereValid", "updateProductOravailable", "updateProductIsavailable", "updateProductsIfavailable", "updateProductsOrAvailable", "updateProductsOrValid", "updateProductsOravailable", "updateProductWhereAvailable", "updateProductsIfValid", "updateProductIfavailable", "updateProductsIfAvailable", "updateProductIsAvailable", "updateProductIsValid", "updateProductIfValid", "updateProductWhereavailable", "updateProductOrAvailable"], "carro": ["carrob", "barros", "CarRO", "barrom", "barRO", "Carlo", " caraco", "carri", "Carrob", "Carrom", "Carros", "barro", "Caraco", "contros", "barrob", "controb", "Carro", "carlo", " carri", " carRO", "barri", "contlo", "barlo", " carrob", " carros", "carRO", "caraco", "baraco", "contro", " carrom", "Carri", "carros", " carlo", "carrom"], "request": ["object", "exit", "framework", "foundation", "view", "data", "user", "server", "attribute", "pool", "collection", "respect", "document", "join", "web", "uri", "session", "client", "input", "platform", "reference", "application", "setup", "enter", "environment", "address", "accept", "req", "quest", "get", "project", "Request", "media", "http", "use", "contact", "search", "list", "template", "query", "question", "response", "context", "message", "report", "reset", "resource", "xml", "model", "apache", "parent", "current", "access", "push"], "listado": ["parentado", "Listado", "listament", "Listato", " listato", "listados", "Listament", "parentato", "parentados", " listados", "parentament", "Listados", " listament", "listato"], "conexion": ["coneuxinion", "conexiION", "cinxaison", "conenexions", "conenexione", "coneuxression", "coneixone", "coneixion", "conexpdial", "coneixions", "conectionison", "conexpison", "coneexION", "conexadial", "conegexinion", "conenexor", "conexpao", "conexaion", "conexaions", "canxao", "coexpression", "raneixion", "conexior", " conexison", "cinxaions", "coneexor", "canixon", "conexaison", "coneexions", "conenexion", "coneuxione", "conexao", " conenexione", "coneaxion", "conexION", " conexao", "conectionioned", "conxion", "conenexison", "conegexression", "coneuxion", "cinxioned", " conexdial", " conexaion", "raneixone", "coexison", "coneaxison", "conenexioned", " conexions", "cinxison", "cinxaioned", "conegexison", "conexiao", "raneixions", "coexinion", "coexion", "coneuxions", "conegexion", "coexpinion", "conexpione", "conexinion", "cinxions", "conexone", " conenexion", "conexaioned", "conexione", "coneuxao", "conenexao", "coexpion", "coneaxdial", "canixao", "coexpison", "conxION", " conenexao", "coneixION", "cinxaion", " conexadial", "conexdial", "conxions", "canixION", "conexpinion", "conexison", " conexaions", "coneexion", "conexions", "conexpression", "canxon", "conexpions", "conexon", "ranexions", "ranexone", "canxion", "conexiion", " conexaison", "conectionion", "coneuxison", "conectionions", "cinxion", "conexression", "conexiions", "canxION", " conexione", "coneexone", "conxor", "coneixon", "conexor", "conenexon", "conexpion", "canixion", "coneaxions", "coexression", "conenexone", " conenexions", "coneixao", "ranexion", "conenexION", "conexioned"], "select": ["sync", "parse", "text", "ct", "where", "read", "serial", "reflect", "Select", "copy", "conn", "SELECT", "which", "insert", "quick", "download", "print", "construct", "qu", "selected", "cho", "source", "q", "edit", "elect", "util", "setup", "success", "exec", "get", "use", "execute", "delete", "search", "find", "expr", "row", "query", "crit", "it", "sql", "lect", "struct", "sel", "reset", "show", "call", "collect", "pse", "include", "connect", "set", "pull", "selection"], "update": ["save", "upt", "where", "unit", "replace", "write", "ul", "current", "each", "Update", "upload", "insert", "ut", "batch", "now", "add", "updated", "result", "other", "place", "ge", "edit", "put", "fill", "check", "util", "up", "alt", "un", "get", "move", "use", "execute", "delete", "find", "touch", "row", "it", "apply", "UPDATE", "change", "apt", "stat", "bit", "make", "set", "pull", "remove"], "rs": ["Rs", "qs", "vers", "ps", "vr", "sr", "rd", "rpm", "rg", "rl", "bs", "ats", "mr", "ros", "js", "hs", "rx", "usr", "vs", "cks", "ers", "ests", "eps", "cs", "ems", "rets", "rings", "rics", "mc", "ks", "xs", "rows", "ds", "r", "ows", "arts", "hr", "ys", "res", "rc", "ws", "RS", "pps", "otes", "acks", "ris", "rt", "fs", "ims", "rm", "ars", "arms", "sts", "stats", "rates", "ins", "rss", "ubs", "rys", "rr", "times", "ts", "ras", "ns", "vals", "cases", "ms"], "codigoProd": ["codigoProvl", "codisoPropdo", "codidoProdo", "codigoComdo", "codigoPROl", "codigoPc", "codigoPropd", "codigaProd", "codigoProdun", "codukaProx", "codigoComd", " codichoselect", "codidoprod", "codigoProdud", "codigaprodid", "codisoPropc", "codigaProdid", "codidoprop", "codigoPROx", "codukaPROdr", "codidoPror", "codigoproc", "codigoProdudo", "codigoOp", "codigoProl", "codichoselect", "codukaPROl", "codigoKeyr", "codukaProl", "codukaPROd", "codigoprodo", "codidoPron", "codigoProdo", "codidoprodo", "codoselect", "codigaProl", "codigoOn", "codigoselect", "codigoProp", " codigoselect", "codigoKeyc", "codigaprod", "codigoPROdid", "codigoComc", "codigoProvdr", "codigoPropdo", "codigoOl", "codigaproc", "codigoProdid", "codigoProdr", "codigoPROd", "codidopror", "codigoProduc", "codisoProdo", "codisoProc", "codigoProx", "codigoPROc", "codigoPl", "codigoPd", "codisoPron", "codigoOd", "codigoProvd", "codigoPROdr", "codigoPron", "codigoKeydo", "codigoprodr", "codukaProd", "codigoprod", "codidopron", "codigoprol", "codigoPdid", "codigoprox", "codukaPROx", "codukaProdr", "codidoProd", "codigoPropc", "codisoProd", "codidoproc", "codigoPror", "codidoprol", "codigoPropn", "codigoProvx", "codidoProl", "codigoKeyd", "codisoPropd", "codigaprol", "codigoprodid", "codidoProc", "codigoComr", "codigaselect", "codigoProc", "codigaProc", "codigopror", "codigoprop", "codidoProp", "codisoPropn", "codigopron"], "filasAfectadas": [" filasafectada", " filasAcessadas", " filasAgregados", " filasafectadas", " filasAcessado", " filasAcessada", " filasAcessados", " filasAfectado", " filasAgregadas", " filasAgregado", " filasaffectados", " filasafectados", " filasAgregada", " filasAffectado", " filasAffectadas", " filasAfectada", " filasaffectado", " filasAffectados", " filasAfectados", " filasAffectada", " filasaffectadas", " filasafectado", " filasaffectada"], "iterador": ["eraton", "terator", " iterato", "formeramo", "Iterstep", "formerador", "iteratoracion", "iterstep", "iteraman", "Iterator", "iteraton", "itato", "literaton", "eraman", "iterrane", " iterrane", "iteratorator", " iteracion", "literrane", "iteratoraman", "itator", "operaman", "Iteraton", "operador", "itrane", "terador", "operator", "iteracion", "teraman", " iterstep", "iteratorador", "formerable", " iteramo", "literstep", " iterable", "iteratoramo", "iterable", "iteramo", "Iterrane", " iteraton", "literator", "iterato", "operamo", "Iterador", "iteratorable", "literaman", "erador", " iterator", "teramo", "literador", "itador", "erator", " iteraman", "formeracion", "Iterato", "iterator"], "prod": ["produrod", " pror", "produdx", "Prog", "prodund", " prord", " proda", "pubdx", "produr", "proda", " prodx", "prorod", "pubg", "produd", "produrd", "Pror", " prol", "Prol", "Prond", "prog", "pror", "prodx", " prog", " prond", "Proda", "prol", " prorod", "Prodx", "Prod", "Prorod", "pubda", "produl", "prond", "pubd", "Prord", "prord"], "exito": ["exterior", "expiration", " inexito", "comito", "lexita", " inexita", "lexito", "compiration", " inexpiration", "comita", "exita", "lexterior", "comterior", " inexterior", "lexpiration"]}}
{"id1": "13657527", "id2": "23452437", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatisetsList", "getDatisetResult", "getDatisetsStatus", "getDatasesStatus", "getDatisetStatus", "getDatasesResult", "getDatasuresStatus", "getDatasetStatus", "getDatisetsResult", "getDatasetList", "getDatasuresList", "getDatisetList", "getDatasetsResult", "getDatasetResult", "getDatasesList", "getDatasetsStatus", "getDatasuresResult"], "surl": ["sUrl", "sysuri", "sserver", "stsserver", "sname", "lsmail", "stsurl", "sURL", "esurl", "lsuri", "lslt", " sUrl", "sslim", "jsuri", "sysurl", "lsserver", "lsUrl", "ssuri", "esURL", "suri", "sysserver", "ssURL", "ssurl", "syslt", "slim", "slt", " suri", "ssUrl", "stslt", "esuri", "esUrl", "jsurl", " sname", "stsuri", "lsurl", "esname", "jslim", " smail", "jsUrl", "smail"], "datasetsList": ["datasetsTable", "datassetsTable", "datasamesSet", "datarssetsSet", "datasagesList", "datassetsData", "datasagesData", "datmasetsMap", "datasourcesSet", "datmassetsMap", "datasamesMap", "datasetsGroup", "datasetSet", "datasameslist", "datarssetsLock", "datassetslist", "datasensMap", "datasETSList", "datasetlist", "datasetMap", "datisetsList", "datasetsMap", "datasagesLock", "datmassetsLock", "datassetsList", "datarsetsMap", "datasagesTable", "datarssetsList", "datasetsData", "datasetsSet", "datasetLock", "datisetsName", "datasetData", "datarsetlist", "datarsetList", "dataselinesName", "datarssetsTable", "datisetList", "datassetsSet", "datisetName", "datasetGroup", "datarsetsSet", "datasagesSet", "datasETSGroup", "datasetsName", "datasETSMap", "datasourcesTable", "datarsetslist", "datarsetMap", "datasuresSet", "datasuresList", "datmassetsList", "datasetslist", "datmasetsData", "dataselinesMap", "datmasetsLock", "datarsetsList", "datasureslist", "datasensList", "dataselinesList", "datasetList", "datisetGroup", "datasourcesLock", "datasetsLock", "datassetsMap", "datmasetsList", "datmassetsData", "datasetName", "datassetsLock", "datasenslist", "datasamesList", "dataselinesGroup", "datarsetsLock", "datasETSName", "datisetsMap", "datisetsGroup", "datasagesMap", "datisetMap", "datasourcesList", "datasuresMap", "datarsetSet", "datarsetsTable"], "result": ["results", "details", "buffer", "detail", "status", "default", "successfully", "answer", "comment", "test", "relation", "complete", "form", "cert", "menu", "res", "success", "successful", "found", "chain", "exist", "diff", "folder", "description", "there", "contact", "search", "first", "record", "response", "sequence", "message", "valid", "ret", "report", "Result", "table", "set", "def"], "reader": ["peer", "river", "read", "buffer", "rd", "dr", "READ", "range", "rl", "mr", "stream", "file", "layer", "liner", "author", "test", "inner", "loader", "timer", "Reader", "ro", "older", "iter", "parser", "body", "client", "r", "ner", "driver", "operator", "rer", "upper", "rar", "er", "handle", "wrapper", "per", "redo", "row", "query", "via", "reading", "roller", "bo", "field", "runner", "socket", "handler", "rr", "resource", "writer", "ser", "iterator"], "url": ["dl", "location", "org", "ul", "rl", "nl", "stream", "mount", "str", "user", "id", "file", "lr", "l", "loader", "web", "uri", "il", "r", "client", "browser", "ssl", "ls", "mail", "sl", "address", "ur", "http", "row", "ll", "link", "URL", "char", "null", "resource", "Url", "key"], "s": ["qs", "gs", "sb", "t", "ss", "y", "ps", "strings", "v", "ats", "es", "less", "bs", "hs", "js", "str", "os", "full", "csv", "sv", "series", "sq", "l", "b", "gets", "cs", "has", "still", "string", "r", "as", "ds", "is", "ls", "ids", "ws", "n", "its", "sw", "rs", "S", "sts", "sample", "abs", "sql", "sym", "ins", "us", "h", "ts", "i", "ns", "source", "tes", "ms"], "list": ["dl", "li", "ml", "detail", "top", "member", "stack", "part", "L", "full", "log", "LIST", "test", "batch", "collection", "pool", "l", "left", "add", "print", "lists", "join", "form", "ist", "single", "listed", "ls", "chain", "format", "note", "layout", "pretty", "array", "all", "php", "ll", "local", "block", "sequence", "st", "group", "def", "table", "cont", "word", "set"]}}
{"id1": "14783950", "id2": "10385815", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["composeWithzip", "compressWithzip", "compresswithExt", "composeWithZip", "compressByExt", "composeWithExt", "compressWithExt", "compressWithFiles", "composeWithoutExt", "compresswithFiles", "compressByZip", "composeWithFiles", "composeWithoutZip", "compressByzip", "compresswithZip", "compressByFiles", "compressWithoutzip", "compresswithzip", "compressWithoutExt", "composeWithoutFiles", "composeWithoutzip", "compressWithoutZip", "compressWithoutFiles"], "fileList": [" FileLIST", "fileL", "fileIterator", "tileLIST", "pageList", "itemNames", "fileSet", "pageCode", "fileLIST", "fileCode", "pageLIST", "tileIterator", " fileLIST", "pagelist", " fileCode", "resourceNames", " fileIterator", "ileLIST", "itemList", "fileLock", "wordLIST", "pageL", " FileList", "filelist", "resourceLock", " fileSet", "wordList", "wordIterator", "fileNames", "itemLock", "wordSet", " fileL", "ileL", " FileSet", " filelist", " fileLock", "ileList", "pageSet", " fileNames", " FileCode", "ilelist", "tileSet", "tileList", "resourceList"], "zipFileName": ["zFilenameName", "zipFilenamePath", "zFileFilename", "zipFilenameName", "zipDirName", " zipFileNames", "zipfileName", "zFilenamename", "zipFileNames", "zFileName", " zipFileFilename", "zipfileFilename", "zFilename", "zipDirPath", "zipFilenamename", "zFilePath", "zipFilePath", "zipFileFilename", " zipFilePath", "zFilenameFilename", " zipfilePath", "zipileName", "zipfilePath", "zipfileNames", "zipilename", " zipfileName", "zipDirNames", "zipileFilename", " zipfileNames", " zipfileFilename", "zipilePath", "zipFilenameNames", "zipFilename", "zFilenamePath", "zipDirFilename", "zipFilenameFilename", "zipfilename"], "fos": ["loos", "flis", "lfos", "lOS", "Foos", "flOS", "Foss", "FOS", " foos", " fOS", "woss", "lfOS", "foss", "Fos", "wOS", "floos", "fOS", "flos", "los", "lfoos", "foos", "woos", "lfis", "loss", "wos"], "zos": ["zb", "ss", "zar", "ps", "zan", "Sax", "iners", "es", "zin", "js", "rez", "sbm", "sis", "hz", "os", "ippers", "nz", "cz", "zen", "webkit", "ze", "zip", "zer", "zh", "hess", "oss", "ess", "han", "bes", "zero", "zag", "ws", "ossus", "zzle", "eros", "iaz", "enos", "ses", "los", "ez", "jas", "zu", "css", "za", "enz", "zers", "zon", "z", "rys", "zo", "zes", "zi", "zik", "less"], "iter": ["ip", "ator", "li", "former", "cer", "ger", "where", "fer", "reader", "ver", "re", "Iterator", "gener", "orient", "order", "user", "el", "inter", "loc", "ipper", "oper", "inner", "ait", "izer", "Iter", "loader", "kit", "ner", "is", "tr", "er", "ptr", "loop", "its", "exp", "maker", "coll", "iv", "train", "list", "it", "vis", "valid", "ir", "iner", "ee", "walker", "i", "ter", "iver", "ser", "liter", "here", "outer", "iterator"], "fileName": ["fieldname", "FileString", "fNumber", "ileCurrent", "localNAME", " fileNumber", "fileSet", "fileStore", "shortStore", "ileString", "fBody", "getname", "fName", "getSource", "localname", "ileNAME", "ileBody", "localName", " fileSource", "shortSource", "fNames", " fileStore", "ilename", "tableName", "fileBody", "fieldList", "FilePath", "FileName", "ilePath", "FileCurrent", "fileCurrent", "fileNumber", "fileNAME", "fSource", "filePath", " fileSet", "fileSource", "fileNames", "tableSet", "ileSet", "ileName", "fieldNAME", " filePath", " fileString", " fileCurrent", " fileBody", "fileString", "FileNames", " fileNames", "ileSource", "ileList", "Filename", "getStore", "getName", "tablePath", "fString", "fname", "localList", "fieldName", "shortname", " filename", "filename", "ileNumber"], "ind": ["count", "cd", "kind", "med", "td", "pred", "inder", "bind", "md", "Ind", "inc", "pos", "butt", "stick", "div", "loc", "mod", "hend", "draw", "ent", "cod", "cand", "sign", "nd", "index", "cond", "IND", "att", "mind", "n", "ptr", "req", "typ", "d", "pl", "find", "ld", "wind", "num", "j", "dial", "roll", "inn", "red", "i", "seed", "dj", "ded"], "shortName": ["shortType", " shortKey", "shortFilename", "ShortType", "ShortCode", "fullType", "shortKey", "quickString", "smallCode", "fullName", "smallName", "recentname", "smallFilename", "recentFilename", "ShortKey", " shortType", "ShortString", "recentCode", "quickname", " shortString", "fullString", "shortString", "smallname", "shortCode", "fullname", "Shortname", "quickKey", " shortname", "quickName", "ShortFilename", "shortname", "recentName", "ShortName"], "fis": ["ufois", "sfIs", "pris", "sfis", "wois", "ufi", "cfris", "ufris", "ufIs", "sfi", "fois", "hi", "ufis", " fris", "FIs", "pi", "hris", " fIs", "wi", "Fris", "cfois", "wis", "his", "wIs", "pois", "cfis", "fIs", "Fis", "fi", "hois", "cfi", "pis", "sfois", "fris"], "buf": ["img", "cv", "Buffer", "buffer", "bin", "wb", "arr", "bed", "buff", "fb", "Buff", "batch", "b", "bus", "bc", "temp", "vec", "bar", "cmd", "uf", "tr", "cb", "br", "ref", "bl", "fam", "rb", "conv", "var", "bag", "mem", "orig", "aka", "seq", "pkg", "cur", "block", "cap", "cat", "fg", "bytes", "tab", "mu", "msg", "box", "db"], "bytesRead": ["blocksLoad", "blocksRead", "BytesWritten", "bytesNeed", "postsLoad", "bytesLoad", "BytesLength", " bytesNeed", " bytesLength", "usersReady", "postsFind", "secondsWritten", "BytesRead", "postsRead", "flowsLoad", " bytesLoad", "blocksWritten", "bytesFind", "postsReady", "flowsFind", "BytesNeed", "usersFind", " bytesWrite", "bytesWritten", "linesWritten", " bytesWritten", "secondsRead", "linesLength", "bytesWrite", "secondsWrite", "usersRead", "secondsLoad", "flowsRead", "linesRead", "bytesLength", "blocksWrite", "bytesReady", "usersLoad", "flowsReady", "linesNeed"]}}
{"id1": "6009527", "id2": "21488868", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadDetention", "doFinishShowAttention", "doFinishLoadAttachachment", "doFinishLoadAttachached", "doFinishLoadAttached", "doFinishLoadAssachment", "doFinishShowDetachment", "doFinishLoadAttention", "doFinishShowDetention", "doFinishShowAttached", "doFinishShowAttachment", "doFinishLoadAttachention", "doFinishShowDetached", "doFinishLoadAssached", "doFinishLoadAssention", "doFinishLoadDetachment", "doFinishLoadDetached"], "attachmentId": ["attociationID", "attagramId", "attociationName", "attachmentid", "atutationName", "ATTociationId", "detachedid", "attociationById", "attentionById", "attachmentKey", "ATTociationid", "attgmentId", "detachmentid", "ATTachmentId", "attentionID", "attgmentKey", "ATTachmentid", "ATTachmentKey", "attachmentName", "attagramKey", "attachmentById", "attachedKey", "attociationid", "attociationKey", "attachmentID", "atachmentId", "attociationId", "ATTociationKey", "atutationById", "attagramid", "attagramById", "attgmentid", "detachedKey", "atachmentName", "attutationId", "attachedById", "detachedId", "attentionId", "ATTociationById", "atachmentById", "attentionName", "attachedid", "detachmentKey", "attutationName", "detachmentId", "atutationID", "attutationById", "ATTachmentById", "attutationID", "attachedId", "atutationId", "atachmentID"], "attachment": ["attachociation", "detachment", "addociation", "assachment", "detacher", "assention", "assached", "attment", "detment", "contached", "attachachment", " attacher", "ATTached", "ATTention", " attment", "association", "ATTachment", "attachacher", "contacher", "assacher", "attached", "addachment", "ATTacher", "attachention", "addached", "attaching", "attachaching", "contachment", "contment", " attached", "attociation", "detached", "attachached", "attention", "addaching", "attacher", "assaching"], "attachmentUri": ["attachmentTpi", "attachmentUtrid", "attachmentUtri", "attentionUtpi", "attentionUtri", "attachmentOURI", "attachmentUuri", "attachmentOri", "attachmentOuri", "attachmenturid", "attachableOpi", "attachableOri", "attachableUri", "attachmentUnpi", "attachmentUnURI", "attentionUri", "attachmentTuri", "attachmentUrid", "attachmentUnri", "attachableOuri", "attachmentTURI", "attachableUpi", "attachmentUnuri", "attachmentUtRI", "attachableOURI", "attachmentTri", "attentionUrid", "attachmentURI", "attachmentUURI", "attachmenturi", "attentionUpi", "attentionUtrid", "attachmentOpi", "attachmentupi", "attentionUtRI", "attachmentUpi", "attachableUuri", "attachmentuRI", "attachableUURI", "attachmentUtpi", "attentionURI"], "contentUri": ["resourceURI", "contentuuri", "ContentUsri", "contentUnrid", "messageUiri", "contentUruri", "contentUnuri", "messageUtri", "contentURri", "contentUric", "contenturi", "ContentUsris", "contentUtiri", "ContentUrid", "contentUtres", "contentUres", "contentSri", "resourceURres", "contentUtRI", "contentUsris", "contentSuri", "resourceURuri", "contentUnris", "resourceUuri", "messageUturi", "resourceUri", "contentUnri", "ContentUri", "ContentUsrid", "contentURRI", "contentUuri", "messageUri", "contentUrri", "contentUiri", "contentures", "ContentUuri", "contentUsuri", "contentUtris", "messageUuri", "contentUsri", "contentUrid", "contentSric", "contentUtric", "contentSiri", "resourceURRI", "messageUtiri", "contentURI", "contentUturi", "contentUrric", "ContentUris", "contentUtrid", "contentuRI", "ContentUsuri", "resourceUres", "contentUris", "contentURuri", "resourceURri", "messageUtric", "contentUsrid", "messageUric", "contentUriri", "contentUtri", "contentURres"], "file": ["save", "content", "le", "create", "buffer", "type", "tree", "base", "user", "FILE", "upload", "File", "disk", "pool", "document", "image", "zip", "result", "dir", "picture", "il", "ile", "line", "page", "path", "work", "entity", "name", "format", "play", "f", "folder", "media", "init", "channel", "template", "fp", "local", "link", "output", "message", "from", "files", "angle", "to", "db", "resource", "sf", "port", "ca", "table", "h", "rule", "source", "filename", "header"], "in": ["io", "bin", "read", "din", " din", "inc", "isin", "rin", "ind", "mi", "en", "inner", "l", "inf", "ain", "inside", "body", "is", "input", "al", " IN", "up", "In", "on", "play", "gin", "ini", "IN", "con", "it", "sql", "from", "ar", "ins", "inn", "cin", "i", "ic", "source", "and"], "out": ["io", "v", "can", "stable", "write", "os", "auto", "OU", "print", "b", "serv", "flush", "sys", "client", "oss", "put", "check", "res", "obj", "nt", "conv", "screen", "n", "ao", "co", "all", "o", "net", "con", "outs", "w", "it", "Out", "output", "ex", "null", "to", "g", "writer", "i", "ou", "aos", "OUT", "outer"], "intent": ["text", "venture", "widget", "animate", "method", "ence", "inv", "displayText", "activate", "verbal", "ant", "complete", "Activity", "express", "phrase", "statement", "continue", "action", "ent", " Intent", "q", "ident", "agent", "asso", "ment", "concept", "device", "alert", "entity", "activity", "term", "ink", "communication", "spirit", "wordpress", "init", "json", "service", "prom", "man", "query", "skill", "intention", "event", "activation", "automatic", "context", "voice", "condition", "entry", "initial", "act", "xml", "inst", "ic", "window"]}}
{"id1": "17791385", "id2": "9796161", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyfile", "cloneFiles", " cpfile", "cloneFile", " copyResource", "cloneResource", " cpResource", " copyFiles", " cpFile", " cpFiles", "clonefile", "copyResource"], "src": ["sb", "ctr", "sr", "ipl", "sc", "rl", "bs", "sin", "rx", "usr", "sit", "sq", "ck", "sys", "usc", "input", "ux", "ys", "rc", "sur", "req", "start", "Source", "iv", "init", "sec", "cur", "rs", "via", "rel", "st", "from", "obs", "ins", "sel", "sf", "inst", "cont", "ser", "source", "txt"], "dst": ["dth", "wth", "ddest", " dth", "Dth", "Dnd", "dnt", "ddst", "dnd", "snt", " dnd", "ddnd", "snd", "sst", "Dnt", " ddest", "ddnt", "Dst", "sdest", "dddest", "wdest", "Ddest", "wst", "wnd"], "in": ["bin", "din", "min", "inc", "isin", "rin", "ind", "en", "inner", "ze", "ln", "inf", "ain", "inside", "iter", "im", "source", "is", "input", "al", "up", "In", "on", "gin", "init", "info", "IN", "con", "it", "st", "from", "ar", "ins", "rec", "inn", "cin", "ai", "act", "mm", "i", "ic", "sin", "oin"], "out": ["t", "io", "dis", "can", "write", "OUT", "bin", "oe", "po", "ne", "os", "auto", "inner", "at", "ot", "gt", "sys", "client", "oss", "res", "obj", "nt", "up", "conv", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "sum", "ex", "st", "to", "g", "writer", "ou", "aos", "by", "outer", "and"], "buf": ["cv", "Buffer", "stab", "buffer", "bh", "arr", "bed", "buff", "Buff", "fb", "prop", "log", "batch", "norm", "b", "bus", "cf", "vec", "ck", "bar", "cp", "cmd", "uf", "cb", "br", "good", "conv", "var", "bag", "aka", "seq", "pkg", "pl", "cur", "gen", "cam", "block", "cap", "cat", "tx", "bytes", "tab", "mu", "msg", "box", "db"], "len": ["compl", "t", "dl", "count", "le", "v", "lon", "lib", "str", "L", "length", "el", "pos", "en", "loc", "l", "wid", "ln", "e", "il", "lan", "lf", "no", "ls", "elt", "end", "nt", "n", "exp", "coll", "seq", "all", "val", "ld", "ll", "fin", "size", "num", "vol", "fun", "lic", "fl", "cap", "rel", "z", "lim", "h", "cmp", "Len", "ren"]}}
{"id1": "20100809", "id2": "16572931", "code1": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "save", "create", "same", "write", "Cop", "archive", "transfer", "download", "cross", "clip", "clone", "cp", "mk", "cop", "split", "gc", "crop", "slice", "map", "export", "opy", "move", "perm", "paste", "delete", "proxy", "php", "link", "cat", "Copy", "share", "pixel", "zip", "remote", "remove"], "srcPath": ["selPath", " srcFolder", "rxPath", " srcPort", " srcFile", "rxForm", "selFile", "srcPatch", "srPath", "sourceDir", "sourceCh", "srcRoot", "rcPath", "rcDir", "urgPath", "rcUrl", "rcPain", "srcMat", "rcForm", "sourceFile", "usrFile", " srcDir", "sourceRoot", "srcPort", "srcCh", "urgMat", "usrPain", "hlPatch", "rcRoot", "selFolder", " srcForm", "srcUrl", "rxPort", "rcFile", "srUrl", "hlUrl", "hlPath", "srPatch", "usrMat", "rcPort", "rcCh", "sourcePath", "hlCh", "srcForm", "srcFile", "rcPatch", "srcPain", "urgFile", "rxDir", "srCh", " srcCh", "srcDir", " srcRoot", "srcFolder", "urgPain", "rcMat", "usrPath", "rcFolder", "selDir"], "dstPath": ["dstCl", "dndCh", "dptDir", "drcPretty", "derstTime", "derdPos", "ddDir", "thrcPath", "destCh", " dstParent", "DdestPath", " dstCl", " dndpath", "ddTime", "dptName", "dstCh", "thstPath", "dstpath", "DstCh", "DstFile", "derdPath", "DstHome", "derstPos", " dndDir", "DdestHome", "dndHome", " dndCh", "dctpath", "derstPath", "ddestHome", "thrcPretty", "DstPath", "derdTime", "dktCh", "dSTName", "DdestFile", "drcpath", "ddestPretty", "dstParent", "ddestPath", "dndCl", "dndTime", "dktHome", "ddestFile", "dndParent", " dstDir", "ddestCl", "dstPretty", " dndName", "dstFile", "ddestDir", "ddestName", "dctPath", "destDir", " dstCh", "dctDir", " ddestName", "drcFile", "dctFile", "drcPath", "destParent", "dstHome", "dndName", "dSTCl", " ddestPath", "dstName", "derdDir", "thstFile", "ddestpath", "dctTime", "ddPos", "ddestCh", "thrcFile", "dktPath", "dptPath", "dSTPath", "thstPretty", "dSTDir", "thrcpath", "dndpath", "dndPath", "ddestParent", " dndParent", "ddPath", "dndFile", "dctPretty", "dstPos", " ddestCl", " dstName", "dptpath", " ddestDir", "DdestCh", "destPath", "derstDir", " dstpath", "dndPos", "dndDir", "dstDir", "dstTime", " dndPath", "dctPos", "thstpath", "dktFile"], "result": ["confirmed", "results", "product", "status", "successfully", "comment", "test", "complete", "region", "register", "forge", "gem", "cert", "sign", "ful", "were", "res", "success", "successful", "fully", "global", "date", "there", "contact", "match", "record", "group", "valid", "ret", "char", "process", "report", "trade", "done", "true", "Result", "know", "table", "associated", "resource", "make", "set"], "files": ["states", "features", "pres", "mails", "faces", "links", "Files", "workers", "images", "forms", "assets", "ports", "books", "balls", "items", "reports", "ls", "leases", "days", "objects", "styles", "mas", "actions", "plates", "chains", "iles", "names", "fs", "les", "works", "uploads", "users", "resources", "lines", "packages", "tests", "fields", "issues"], "file": ["tile", "le", "type", "part", "data", "key", "base", "id", "FILE", "File", "print", "image", "e", "dir", "string", "ile", "child", "line", "path", "item", "chain", "name", "play", "url", "p", "f", "pe", "row", "record", "link", "sample", "block", "field", "message", "from", "local", "entry", "style", "task", "page", "table", "resource", "rule", "source", "filename"], "in": ["io", "bin", "read", "din", "or", "sin", "conn", "re", "inc", "isin", "rin", "ind", "mi", "en", "inner", "image", "ln", "inf", "ain", "im", "inside", "iter", "vin", "client", "ie", "is", "ic", "input", "al", "up", "In", "n", "old", "on", "get", "co", "gin", "init", "all", "win", "ini", "IN", "net", "o", "con", "like", "one", "ch", "local", "it", "internal", "ir", "ar", "ins", "from", "inn", "cin", "ai", "again", "i", "mm", "include", "source", "oin"], "out": ["t", "io", "v", "bin", "can", "write", "conn", "or", "oe", "ne", "os", "user", "ext", "inner", "ln", "serv", "at", "sys", "ot", "oss", "gt", "client", "cmd", "check", "end", "nt", "conv", "op", "up", "n", "on", "co", "o", "net", "con", "one", "cn", "outs", "it", "Out", "output", "ex", "ns", "null", "again", "to", "cos", "not", "writer", "msg", "ou", "aos", "OUT", "outer", "other"], "size": ["scale", "count", "close", "write", "fee", "read", "speed", "range", "sn", "max", "space", "length", "total", "pos", "en", "ness", "gets", "ze", "string", "shape", "zero", "name", "n", "export", "city", "amount", "notice", "width", "capacity", "position", "send", "get", "start", "len", "height", "number", "num", "sum", "zie", "SIZE", "bytes", "seek", "area", "z", "see", "ize", "empty", "Size", "loss"], "buf": ["bg", "img", "cv", "Buffer", "buffer", "ann", "bh", "data", "buff", "Buff", "batch", "func", "pool", "b", "bc", "vec", "bar", "cmd", "queue", "uf", "cb", "br", "job", "ref", "fam", "rb", "map", "aka", "bag", "mem", "pkg", "seq", "cur", "cam", "bp", "cap", "cat", "fg", "tab", "msg", "good", "db"]}}
{"id1": "14001795", "id2": "22625683", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyOverwarFile", "copyoverwarFilename", "copyOverTarfile", "copyOverWarFiles", "copyoverWarFile", "copyoverwarFiles", "copyOverwarFilename", "copyOverTarFile", "copyOverwarfile", "copyoverWarFiles", "copyOverTarFilename", "copyoverWarfile", "copyoverwarfile", "copyOverWarfile", "copyoverwarFile", "copyOverTarFiles", "copyoverWarFilename", "copyOverWarFilename", "copyOverwarFiles"], "dir": ["dl", "tmp", "dep", "cd", "wd", "dr", "re", "md", "ind", "file", "disk", "log", "div", "loc", "add", "dd", "iter", " directory", "del", "out", "df", "mk", "path", "dm", "Dir", "res", "DIR", "dat", "name", "dim", "old", "url", "coll", "fd", "d", "folder", "di", "ld", "directory", "dist", "cur", " Dir", "fin", "local", " d", "desc", "rel", "vol", "ir", "dial", "direct", "doc", "addr", "parent", "zip", "good", "window", "db", "form", "def"], "ff": ["fact", "tf", " aft", "aff", " cf", "fx", " ref", "off", "ef", "buff", "bf", "FF", "mt", "file", " FF", " eff", "xf", "ck", "UFF", "xff", "af", "df", "uf", "lf", "cb", "cond", "ft", "fd", " df", "aft", "ld", "wind", "fp", " def", "ffe", " af", "fc", "fl", "fg", "F", "filter", "sf", "uff", "iff", "eff", "cf", "alf"], "files": ["features", "facts", "faces", "ions", "Files", "parts", "forms", "file", "images", "frames", "assets", "ports", "balls", "items", "rows", "leases", "ls", "objects", "days", "styles", "mas", "plates", "ails", "iles", "names", "bees", "models", "flows", "members", "fs", "les", "jobs", "uploads", "lines", "resources", "tests", "values", "fields", "keys", "issues", "ories"], "f": ["c", "t", "tf", "v", "rf", "fe", "k", "fac", "col", "bf", "fa", "file", "l", "b", "e", "fab", "xf", "uf", "lf", "fm", "fw", "a", "n", "ft", "exp", "p", "d", "fd", "fs", "fp", "w", "fc", "fl", "elf", "m", "F", "g", "sf", "i", "h", "cf", "alf", "def"], "newFile": ["newPlace", "oldFilename", "NewNode", "NewFile", " newPlace", "oldFile", "secureFile", "newsfile", "uniqueNode", "newsFile", "newNode", "newFiles", "uniquePage", "anotherFile", "NewPlace", "newFilename", " newFiles", "anotherPlace", "securefile", "newKey", "NewPage", "oldfile", "uniqueFile", "NEWfile", "newPage", "uniquefile", "NewFilename", "NEWFile", "secureKey", "NEWPage", "newfile", "Newfile", "anotherfile", "NewKey", "newsKey", "NewFiles", "anotherFiles", " newfile", " newFilename", "NEWNode"], "fi": ["fr", "li", "io", "fe", "bi", "ii", "phi", "bf", "fa", "iu", "mi", "isi", "flo", "ti", "uf", "lf", "ki", "FI", "ci", "pi", "ni", "fd", "si", "di", "ini", "fp", "fin", "afi", "ifa", "ife", "zi", "i", "sf", "ri", "cf", "Fi"], "fo": ["tf", "te", "oe", "po", "hea", "sty", "uo", "oo", "ato", "FO", "ho", "oooo", "xf", "flo", "eto", "tk", "ph", "hi", "ti", "ki", "ott", "mo", "wo", "ow", "eno", "fam", "zz", "vo", "tif", "co", "opa", "o", "tto", "bo", "wt", "jo", "zo", "sf", "ko", "cf"]}}
{"id1": "19467540", "id2": "23531898", "code1": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"updateProductIfAvailable": ["updateProductOrValid", "updateProductWhereValid", "updateProductOravailable", "updateProductIsavailable", "updateProductsIfavailable", "updateProductsOrAvailable", "updateProductsOrValid", "updateProductsOravailable", "updateProductWhereAvailable", "updateProductsIfValid", "updateProductIfavailable", "updateProductsIfAvailable", "updateProductIsAvailable", "updateProductIsValid", "updateProductIfValid", "updateProductWhereavailable", "updateProductOrAvailable"], "carro": ["carrob", "barros", "CarRO", "barrom", "barRO", "Carlo", " caraco", "carri", "Carrob", "Carrom", "Carros", "barro", "Caraco", "contros", "barrob", "controb", "Carro", "carlo", " carri", " carRO", "barri", "contlo", "barlo", " carrob", " carros", "carRO", "caraco", "baraco", "contro", " carrom", "Carri", "carros", " carlo", "carrom"], "request": ["object", "exit", "framework", "foundation", "view", "data", "user", "server", "attribute", "pool", "collection", "respect", "document", "join", "web", "uri", "session", "client", "input", "platform", "reference", "application", "setup", "enter", "environment", "address", "accept", "req", "quest", "get", "project", "Request", "media", "http", "use", "contact", "search", "list", "template", "query", "question", "response", "context", "message", "report", "reset", "resource", "xml", "model", "apache", "parent", "current", "access", "push"], "listado": ["parentado", "Listado", "listament", "Listato", " listato", "listados", "Listament", "parentato", "parentados", " listados", "parentament", "Listados", " listament", "listato"], "conexion": ["coneuxinion", "conexiION", "cinxaison", "conenexions", "conenexione", "coneuxression", "coneixone", "coneixion", "conexpdial", "coneixions", "conectionison", "conexpison", "coneexION", "conexadial", "conegexinion", "conenexor", "conexpao", "conexaion", "conexaions", "canxao", "coexpression", "raneixion", "conexior", " conexison", "cinxaions", "coneexor", "canixon", "conexaison", "coneexions", "conenexion", "coneuxione", "conexao", " conenexione", "coneaxion", "conexION", " conexao", "conectionioned", "conxion", "conenexison", "conegexression", "coneuxion", "cinxioned", " conexdial", " conexaion", "raneixone", "coexison", "coneaxison", "conenexioned", " conexions", "cinxison", "cinxaioned", "conegexison", "conexiao", "raneixions", "coexinion", "coexion", "coneuxions", "conegexion", "coexpinion", "conexpione", "conexinion", "cinxions", "conexone", " conenexion", "conexaioned", "conexione", "coneuxao", "conenexao", "coexpion", "coneaxdial", "canixao", "coexpison", "conxION", " conenexao", "coneixION", "cinxaion", " conexadial", "conexdial", "conxions", "canixION", "conexpinion", "conexison", " conexaions", "coneexion", "conexions", "conexpression", "canxon", "conexpions", "conexon", "ranexions", "ranexone", "canxion", "conexiion", " conexaison", "conectionion", "coneuxison", "conectionions", "cinxion", "conexression", "conexiions", "canxION", " conexione", "coneexone", "conxor", "coneixon", "conexor", "conenexon", "conexpion", "canixion", "coneaxions", "coexression", "conenexone", " conenexions", "coneixao", "ranexion", "conenexION", "conexioned"], "select": ["sync", "parse", "text", "ct", "where", "read", "serial", "reflect", "Select", "copy", "conn", "SELECT", "which", "insert", "quick", "download", "print", "construct", "qu", "selected", "cho", "source", "q", "edit", "elect", "util", "setup", "success", "exec", "get", "use", "execute", "delete", "search", "find", "expr", "row", "query", "crit", "it", "sql", "lect", "struct", "sel", "reset", "show", "call", "collect", "pse", "include", "connect", "set", "pull", "selection"], "update": ["save", "upt", "where", "unit", "replace", "write", "ul", "current", "each", "Update", "upload", "insert", "ut", "batch", "now", "add", "updated", "result", "other", "place", "ge", "edit", "put", "fill", "check", "util", "up", "alt", "un", "get", "move", "use", "execute", "delete", "find", "touch", "row", "it", "apply", "UPDATE", "change", "apt", "stat", "bit", "make", "set", "pull", "remove"], "rs": ["Rs", "qs", "vers", "ps", "vr", "sr", "rd", "rpm", "rg", "rl", "bs", "ats", "mr", "ros", "js", "hs", "rx", "usr", "vs", "cks", "ers", "ests", "eps", "cs", "ems", "rets", "rings", "rics", "mc", "ks", "xs", "rows", "ds", "r", "ows", "arts", "hr", "ys", "res", "rc", "ws", "RS", "pps", "otes", "acks", "ris", "rt", "fs", "ims", "rm", "ars", "arms", "sts", "stats", "rates", "ins", "rss", "ubs", "rys", "rr", "times", "ts", "ras", "ns", "vals", "cases", "ms"], "codigoProd": ["codigoProvl", "codisoPropdo", "codidoProdo", "codigoComdo", "codigoPROl", "codigoPc", "codigoPropd", "codigaProd", "codigoProdun", "codukaProx", "codigoComd", " codichoselect", "codidoprod", "codigoProdud", "codigaprodid", "codisoPropc", "codigaProdid", "codidoprop", "codigoPROx", "codukaPROdr", "codidoPror", "codigoproc", "codigoProdudo", "codigoOp", "codigoProl", "codichoselect", "codukaPROl", "codigoKeyr", "codukaProl", "codukaPROd", "codigoprodo", "codidoPron", "codigoProdo", "codidoprodo", "codoselect", "codigaProl", "codigoOn", "codigoselect", "codigoProp", " codigoselect", "codigoKeyc", "codigaprod", "codigoPROdid", "codigoComc", "codigoProvdr", "codigoPropdo", "codigoOl", "codigaproc", "codigoProdid", "codigoProdr", "codigoPROd", "codidopror", "codigoProduc", "codisoProdo", "codisoProc", "codigoProx", "codigoPROc", "codigoPl", "codigoPd", "codisoPron", "codigoOd", "codigoProvd", "codigoPROdr", "codigoPron", "codigoKeydo", "codigoprodr", "codukaProd", "codigoprod", "codidopron", "codigoprol", "codigoPdid", "codigoprox", "codukaPROx", "codukaProdr", "codidoProd", "codigoPropc", "codisoProd", "codidoproc", "codigoPror", "codidoprol", "codigoPropn", "codigoProvx", "codidoProl", "codigoKeyd", "codisoPropd", "codigaprol", "codigoprodid", "codidoProc", "codigoComr", "codigaselect", "codigoProc", "codigaProc", "codigopror", "codigoprop", "codidoProp", "codisoPropn", "codigopron"], "filasAfectadas": [" filasafectada", " filasAcessadas", " filasAgregados", " filasafectadas", " filasAcessado", " filasAcessada", " filasAcessados", " filasAfectado", " filasAgregadas", " filasAgregado", " filasaffectados", " filasafectados", " filasAgregada", " filasAffectado", " filasAffectadas", " filasAfectada", " filasaffectado", " filasAffectados", " filasAfectados", " filasAffectada", " filasaffectadas", " filasafectado", " filasaffectada"], "iterador": ["eraton", "terator", " iterato", "formeramo", "Iterstep", "formerador", "iteratoracion", "iterstep", "iteraman", "Iterator", "iteraton", "itato", "literaton", "eraman", "iterrane", " iterrane", "iteratorator", " iteracion", "literrane", "iteratoraman", "itator", "operaman", "Iteraton", "operador", "itrane", "terador", "operator", "iteracion", "teraman", " iterstep", "iteratorador", "formerable", " iteramo", "literstep", " iterable", "iteratoramo", "iterable", "iteramo", "Iterrane", " iteraton", "literator", "iterato", "operamo", "Iterador", "iteratorable", "literaman", "erador", " iterator", "teramo", "literador", "itador", "erator", " iteraman", "formeracion", "Iterato", "iterator"], "prod": ["produrod", " pror", "produdx", "Prog", "prodund", " prord", " proda", "pubdx", "produr", "proda", " prodx", "prorod", "pubg", "produd", "produrd", "Pror", " prol", "Prol", "Prond", "prog", "pror", "prodx", " prog", " prond", "Proda", "prol", " prorod", "Prodx", "Prod", "Prorod", "pubda", "produl", "prond", "pubd", "Prord", "prord"], "exito": ["exterior", "expiration", " inexito", "comito", "lexita", " inexita", "lexito", "compiration", " inexpiration", "comita", "exita", "lexterior", "comterior", " inexterior", "lexpiration"]}}
{"id1": "19549489", "id2": "19868933", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "save", "create", "read", "write", "replace", "Cop", " mirror", "upload", " duplicate", "transfer", "csv", "download", " cp", "add", "clone", "cp", " Copy", "slice", "map", "export", "paste", "move", "load", "delete", "rm", "cat", "Copy"], "sourceFile": ["SourceFilename", "inputPage", " sourceFilename", "inputfile", "ourcefile", "ourcePage", "ourceFile", "ourceLine", " sourcefile", "sourcePage", "inputLine", "sourcefile", " sourceLine", "sourceLine", "SourceFile", "inputFile", " sourcePage", "SourcePage", "ourceFilename", "sourceFilename", "SourceLine", "Sourcefile"], "destinationFile": ["estinatedPlace", "destinoFilename", "declinatorPlace", "destinoFile", "destinationsfile", "destinatorPlace", "destinofile", "declinationPath", "destinatePath", "declinationFilename", "declinationFile", "estinationFilename", "destinoPlace", "destinationPath", "estinationFile", "destinationFilename", "destinationfile", "estinatedFile", "estinatedfile", "destinatorFilename", "destrativePlace", "destinatedPlace", "destinationsPlace", "destrativePath", "destinationsFile", "estinationPlace", "destinateFile", "destinationsFilename", "destrativeFile", "destinatePlace", "destinatedfile", "estinatedFilename", "declinationPlace", "destinationPlace", "destinatedFilename", "destinatorPath", "destinatedFile", "destinateFilename", "declinatorFile", "declinatorFilename", "destrativeFilename", "destinatorFile", "declinatorPath", "estinationfile"], "sourceFileChannel": ["sourceByteEntry", "srcFileEntry", "sourceStreamApplication", "srcFilechannel", "sourceFileEntry", "sourceLineChannel", "sourceEntryConnection", "sourceEntryChan", "sourceBlockConnection", "srcBlockEntry", "sourceBaseApplication", "sourceFileConnection", "sourceBaseHandler", "sourceStreamChan", "ourceFileChan", "sourceLineConnection", "sourceLineChan", "srcBlockConnection", "sourceStreamchannel", "srcBlockchannel", "sourceStreamChuck", "srcBlockChannel", "sourceByteConnection", " sourceFileApplication", "sourceLineEntry", " sourceFileChuck", "sourceByteChannel", "sourceFileApplication", "ourceFileChannel", "sourceEntrychannel", "sourceFileChan", "sourceFileHandler", "ourceEntrychannel", "ourceEntryChan", "sourceBytechannel", " sourceFileHandler", "sourceFileChuck", "ourceFilechannel", "sourceLinechannel", "sourceBlockChannel", "sourceBaseChannel", "ourceFileConnection", "sourceEntryChannel", "sourceBlockEntry", "ourceEntryConnection", "srcFileConnection", "sourceFilechannel", "sourceBlockchannel", "srcFileChannel", "sourceStreamChannel", "sourceStreamHandler", "sourceStreamConnection", "sourceBaseChuck", "ourceEntryChannel"], "destinationFileChannel": ["destinationfileManager", "destmentResourceChannel", "destmentPageChannel", "destinationFilesConnection", "destinationfileEntry", "destinatorFilesChannel", "destinationChannelEntry", "destinationFileManager", "destmentFilechannel", "destinationResourcechannel", "destinationFilesChannel", "destinationChannelCh", "destinationPageChannel", "destinatorFileCh", "destinationResourceManager", "destinationPageEntry", "destmentPageContext", "destinationfileConnection", "destmentPageEntry", "destinationResourceChan", "destmentResourcechannel", "destmentFileChannel", "destinationfilechannel", "destinationFileConnection", "destinationDirectoryChannel", "destinationDirectorychannel", "destinationfileCh", "destinatorFilesConnection", "destinationfileChannel", "destmentResourceManager", "destinationChannelChannel", "destinationPageContext", "destmentPageChan", "destinationFileContext", "destinationFilechannel", "destinationPageChan", "destinationChannelChan", "destinationFileEntry", "destinationDirectoryManager", "destinationChannelConnection", "destinationChannelContext", "destinationfileChan", "destinationfileContext", "destinationFileChan", "destinatorFilesCh", "destinationResourceChannel", "destmentFileChan", "destinationFilesChan", "destinationFileCh", "destmentResourceChan", "destinationFilesCh", "destinatorFileConnection", "destmentFileContext", "destinatorFileChannel", "destmentFileEntry", "destinatorFilesChan", "destmentFileManager", "destinatorFileChan", "destinationDirectoryChan"]}}
{"id1": "15018553", "id2": "20208819", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" enccrypt", "uncrypt", "unccrypt", "encrypted", "Encrypt", "encode", "Enccrypt", " encrypted", "uncrypted", "uncode", "Encrypted", " encode", "Encode", "enccrypt"], "text": ["content", "t", "ct", "th", "v", "read", "buffer", "translation", "str", "data", "ext", "comment", "select", "test", "ut", "document", "phrase", "print", "now", "pt", "TEXT", "body", "string", "source", "q", "pattern", "x", "path", "input", "title", "nt", "name", "password", "url", "p", "value", "w", "message", "output", "tx", "act", "code", "msg", "cont", "word", "Text", "form", "txt"], "md": ["pm", "c", "bd", "MD", " cmd", "t", "dh", "ct", "det", "cd", "img", "mand", "mt", "ind", "mod", "dd", "hd", "mc", "dig", "del", "cmd", " dd", "sha", "df", "mk", "mb", "nd", "dm", "mo", "hash", "mac", "de", "err", "pd", "metadata", "mem", "grad", "mp", "pkg", "d", " cd", "mond", "der", "ld", "rm", "di", "mn", "od", "m", "doc", "msg", "h", "mm", "cmp", "ad", "mode", "mg", "ms", "and"], "md5hash": ["md3h", "md512h", "md3hash", " md2cloth", " md2hash", "md2sha", " md5Hash", "md2hash", "md5cloth", "md3hex", "md2h", "md5Hash", "md5sha", "md3Hash", "md512Hash", "md5hex", " md5sum", " md3Hash", "md5h", "md2Hash", "md3sha", " md3sha", " md5sha", " md2sum", "md5sum", " md5hex", "md2hex", "md3sum", "md3cloth", " md5h", " md3h", "md2cloth", "md2sum", " md2hex", " md3sum", " md3hash", "md512sum", "md512hash", "md512sha", " md5cloth"]}}
{"id1": "1798720", "id2": "23611770", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"save": ["version", "data", "release", "archive", "upload", "download", "register", "dump", "update", "install", "aw", "pack", "accept", "export", "send", "folder", "pkg", "init", "delete", "Save", " seal", " Save", "store", "saving", "zip", "filename"], "packageName": ["packageId", "pkgNames", " packageNames", "PackageId", " packageKey", "PackageType", "packageType", "pkgCode", "PackageName", " packageCode", "moduleKey", "pkgName", "moduleCode", "pkgId", "packagename", " packagename", "moduleName", " packageId", "pkgname", "PackageNames", " packageType", "packageCode", "modulename", "packageNames", "moduleNames", "packageKey", "pkgType", "pkgKey", "moduleId"], "fileContents": ["pageContents", " fileValues", "fileValues", "FileIngredients", "pageNames", "byteNames", "pageItems", "pageBytes", "fileItems", "FileContent", "fileContent", "fileBytes", " fileContent", "packageContents", "FileContents", "FileBytes", "FileItems", "FileValues", "FileNames", "fileIngredients", " fileItems", "packageIngredients", "packageContent", "byteContents", "packageNames", " fileIngredients", "byteContent", " fileBytes", "byteValues"], "fileNames": [" fileLeaks", "dirNames", " fileValues", "fieldNames", "resourceContents", "issueVaults", "moduleContents", "fieldTypes", "fileLeaks", "FileLeaks", " fileName", "fileValues", "resourceValues", "fieldContents", "issueName", "FileTypes", " fileNumbers", "issueNames", "messageValues", "dirLeaks", "resourceNames", "resourceTypes", "FileKeys", "FileName", "fileVaults", "messageKeys", "moduleName", "fieldNumbers", "fileName", "dirKeys", "moduleVaults", "FileContents", " fileTypes", "messageName", "FileNames", "FileValues", " fileKeys", "fileKeys", " fileVaults", "fileNumbers", "moduleNames", "dirTypes", "messageNames", "fileTypes", "resourceNumbers", "issueContents"], "dirBase": ["directoryBasic", "pkgSet", "dirbase", " directoryBase", "pathBas", "DIRBase", "directorybase", "irBas", "pkgBase", "pkgBas", "dirBas", "DirBottom", " directoryBas", "dirBottom", "pkgbase", "directoryBas", "dirBuilder", "DirBuilder", "directoryBase", "dirSet", "pathbase", "folderBasic", "DIRBas", "DIRBottom", "folderBase", "dirBasic", "folderbase", "folderBas", "pathBasic", " directoryBottom", "DIRBuilder", "irBase", "directorySet", "irSet", "irbase", "DirBase", " directoryBuilder", "DirBas", "pathBase"], "packageDir": ["podDir", " packageDist", "packageDef", "installDef", " packageD", "pkgFolder", "installDir", "moduleRel", "packageFolder", "pkgPath", " packageDef", " packagePath", "pkgDir", "moduleFolder", " packageRel", "podD", "installD", "modulePath", " packageFolder", "packageDist", "installDist", "podDef", "pkgDef", "packageRel", "moduleDef", "pkgRel", "packagePath", "moduleDir", "packageD", "podDist"], "created": ["confirmed", "generated", "checked", "started", "create", "creation", "registered", "called", "defined", "mounted", "arted", "raised", "produced", "existent", "creat", "recorded", "developed", "creator", "reported", "printed", "founded", "allowed", "successful", "Created", "present", "TED", "loaded", "ced", "made", "forced", "added", "joined", " started", "provided", " generated", "activated", "given", "associated", "released", "installed", "filled", "locked", "ready"], "currentPath": ["currentlyPath", " currentName", " currentParent", "currentPoint", "currentFile", "currentlyName", " currentFile", "CurrentPath", "currentCh", " currentCh", "CurrentFile", "currentParent", "currentName", " currentPoint", "CurrentCh", "recentParent", "currentlyFile", "CurrentPoint", "recentPoint", "CurrentParent", "recentPath", "currentlyCh", "recentName", "CurrentName"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "batch", "hi", "cli", "ami", "exp", "init", "ini", "ei", "sim", "j", "my", "mu", "g", "zi", "ic", "in", "multi", "u", "this", "q", "ki", "index", "pi", "ij", "qi", "f", "di", "o", "jj", "status", "ity", "id", "os", "mi", "them", "gi", "uri", "ie", "iii", "slice", "ji", "iq", "me", "p", "si", "ix", "info", "it", "yi", "key", "ip", "iy", "phi", "ui", "ind", "iu", "go", "ski", "oi", "im", "cgi", "ti", "major", "ci", "chain", "ex", "m", "ai", "ri"], "file": ["et", "le", "io", "buffer", "type", "base", "comment", "FILE", "log", "File", "disk", "pool", "l", "dir", "body", "ile", "child", "path", "fo", "name", "format", "play", "handle", "p", "f", "info", "row", "template", "local", "link", "handler", "page", "port", "sf", "resource", "table", "parent", "db", "rule", "source", "h", "set", "header"], "fos": ["woes", "foes", " foes", "Faos", "Foss", "ffos", "FOS", "woses", " fow", "ffoes", " foses", " fOS", "oo", "oow", "woss", "sfaos", " foss", "flo", "foss", "floes", "fbow", "flaos", "Foes", "sfoss", "oos", "faos", "Fos", "sfos", "fo", "fbaos", "sfOS", "fOS", "flos", "floses", "floss", "oaos", "ffo", "ffaos", "fow", "fbo", " faos", " fo", "Fo", "foses", "fbos", "wos"], "fileSrc": [" fileInsRC", "fileDsrc", " fileInsource", "fileInRC", "fileInssrc", "fileEci", " fileInsrc", " fileSsrc", "jobNrc", " fileSource", "fileErc", "fileNci", "fileDci", "fileInsrc", "fileSri", "jobNci", " fileInssrc", "fileSRC", "jobSri", "fileInource", "fileSource", "fileSci", "fileNrc", "jobNri", "fileErl", "fileEri", "fileInsource", "jobSrl", "fileInrc", "fileNrl", "jobSrc", "fileDRC", "jobNrl", " fileSRC", "fileDri", "fileDrc", "fileSsrc", "fileDource", "jobSci", "fileSrl", "fileNri", "fileDrl", "fileInsRC"], "fileDst": ["filedld", "FileSld", "fileNld", "fileDot", "FileDst", "fileNst", "filednd", "fileSpl", "FileDld", "fileDnd", "fileDld", "FileSst", "fileDpl", "FileDpl", "fileWst", "fileDcr", "fileSst", "FileSpl", "fileScr", "FileSnd", "FileDlt", "filedcr", "fileSlt", "FileSlt", "fileWlt", "FileDot", "FileSot", "fileNnd", "fileNlt", "fileWot", "FileDnd", "FileDcr", "fileSld", "fileWpl", "fileNot", "FileScr", "fileNcr", "fileSnd", "fileNpl", "fileSot", "filedst", "fileDlt"], "reader": ["ler", "read", "buffer", "dr", "ader", "actor", "rl", "stream", "rx", "rot", "book", "controller", "author", "review", "inner", "loader", "Reader", "ro", "iter", "oder", "parser", "ner", "r", "driver", "rer", "Larry", "upper", "ocker", "rar", "rc", "er", "row", "query", "roller", "reading", "context", "runner", "readable", "entry", "rr", "handler", "resource", "ri", "iterator"], "writer": ["println", "buffer", "write", "worker", "read", "manager", "wire", "stream", "order", "user", "server", "test", "liner", "document", "print", "draw", "loader", "Reader", "adder", "flush", "console", "word", "parser", "creator", "storage", "client", "iter", "driver", "player", "operator", "browser", "riter", "writing", "later", "format", "iterator", "variable", "builder", "maker", "caster", "wrapper", "Writer", "wright", "service", "query", "w", "runner", "writers", "report", "walker", "entry", "store", "handler", "table", "function", "ter", "window", "outer", "editor"], "line": ["text", "le", "detail", "lin", "inline", "range", "point", "nl", "user", "column", "comment", "liner", "LINE", "print", "l", "continue", "ln", "cell", "word", "Line", "eline", "source", "string", "stroke", "ole", "entity", "chain", "ine", "date", "pe", "lined", "frame", "number", "row", "edge", "record", "link", "sample", "block", "sequence", "message", "valid", "entry", "label", "style", "code", "port", "node", "rule", "page", "kin", "header"]}}
{"id1": "5977352", "id2": "12724876", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    private void loadURL(URL url, String username, String password, JLabel statusDialogMBLabel) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (username != null && !username.equals(\"\")) {\n            if (password == null) {\n                password = \"\";\n            }\n            String encoding = new sun.misc.BASE64Encoder().encode(new String(username + \":\" + password).getBytes());\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        this.tmpVRMLFile = File.createTempFile(\"xnavi-\", null, null);\n        System.out.println(\"Created tmp file: \" + this.tmpVRMLFile.getAbsolutePath());\n        FileWriter fw = new FileWriter(this.tmpVRMLFile);\n        long bytesInFile = this.tmpVRMLFile.length();\n        double sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n        String response = \"\";\n        while ((inputLine = in.readLine()) != null) {\n            response = inputLine + \"\\n\";\n            fw.write(response);\n            fw.flush();\n            if (statusDialogMBLabel != null) {\n                bytesInFile = this.tmpVRMLFile.length();\n                sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n                sizeInMB *= 100.0;\n                sizeInMB = (double) ((int) sizeInMB);\n                sizeInMB /= 100.0;\n                statusDialogMBLabel.setText(sizeInMB + \" MB\");\n                statusDialogMBLabel.repaint();\n            }\n        }\n        fw.close();\n        System.out.println(\"Wrote file \" + this.tmpVRMLFile.getAbsolutePath());\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyFiles", "cpfile", " copyfile", "copyfile", "copyFolder", "cpFolder", " cpfile", "cpFile", "cpFiles", " copyFiles", " cpFolder", " copyFolder", " cpFile", " cpFiles"], "src": ["sb", "img", "ctr", "sr", "ipl", "sc", "rl", "usr", "sit", "rest", "loc", "sq", "sys", "SOURCE", "input", "rc", "req", "start", "Source", "orig", "pkg", "init", "sec", "cur", "rs", "via", "rel", "st", "from", "ins", "sf", "inst", "cont", "ser", "source"], "dest": ["est", " dst", "th", "coord", "tmp", "Dest", "trans", "tom", "copy", "etc", "usr", "nom", "sit", "rest", "test", "loc", "self", "them", "foreign", "temp", "result", "dir", "del", "origin", "gt", "cp", "none", "mk", "opt", "de", "end", "nt", "name", "dat", "nw", "spec", "orig", "tif", "comb", "comp", "target", "dist", "desc", "cat", "st", "lit", "null", "master", "port", "parent", "decl", "sp", "cont", "good", "source", "txt"], "bufSize": ["fontSize", " bufSIZE", " bufferSIZE", "bcLen", "ufNum", "ufSIZE", "fontNum", "bcNum", " bufferNum", "ufLen", "bcSIZE", " bufferSize", "fontSIZE", "ufSize", "bufLen", "bufSIZE", " bufNum", "bcSize", " bufLen", "bufNum"], "force": ["kill", " Force", "replace", "write", "close", "default", "base", "auto", "stall", "ce", "raise", "print", "draw", "error", "forcing", "flag", "forge", "require", "allow", "cmd", "fill", "forces", "check", "command", "always", "Force", "co", "send", "f", "use", "safe", "frame", "only", "forced", "enable", "apply", "fast", "reset", "remote", "rule", "quote", "form"], "buffer": ["history", "text", "binary", "memory", "Buffer", "view", "stack", "tree", "buff", "base", "length", "comment", "total", "attribute", "batch", "document", "phrase", "print", "temp", "word", "queue", "shape", "limit", "library", "cache", "device", "command", "variable", "mem", "buf", "paste", "frame", "number", "template", "row", "sample", "sequence", "block", "message", "display", "table", "window", "quote"], "read": ["scan", "text", "t", "parse", "count", "reader", "request", "write", "range", "READ", "run", "stream", "str", "bind", "need", "length", "ind", "raw", "print", "add", "next", "before", "give", "im", "iter", "word", "q", "allow", "shape", "r", " Read", "input", "index", "fill", "check", "open", "hold", "end", "req", "start", "get", "pass", "pe", "send", "feed", "len", "load", "height", "find", "hello", "Read", "row", "query", "record", "w", "size", "reading", "reads", "valid", "readable", "wait", "i", "through", "connect", "set", "push"], "in": ["t", "bin", "din", "or", "inc", "isin", "rin", "ind", "mi", "en", "inner", "l", "ln", "inf", "ain", "inside", "iter", "im", "source", "ie", "is", "input", "check", "irm", "al", "up", "In", "n", "on", "get", "co", "gin", "per", "ma", "init", "all", "info", "o", "IN", "ini", "con", "local", "it", "internal", "cn", "ar", "from", "ins", "inn", "m", "cin", "doc", "i", "mm", "ic", "include", "sin"], "out": ["t", "io", "v", "write", "can", "conn", "or", "oe", "ne", "os", "file", "om", "inner", "b", "l", "ln", "at", "ent", "flush", "ot", "sys", "oss", "gt", "client", "cmd", "cache", "br", "end", "obj", "nt", "up", "op", "conv", "n", "on", "co", "all", "list", "o", "net", "con", "one", "cn", "it", "mit", "ch", "output", "Out", "sum", "outs", "ex", "ns", "again", "to", "cos", "g", "writer", "not", "ou", "aos", "OUT", "outer"]}}
{"id1": "8515891", "id2": "15129155", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"readUrl": ["getUrl", "readUr", "READUr", "loadURL", "getUr", "loadurl", "loadUrl", "geturl", "readURL", "readurl", "READUrl", "getURL", "READurl", "READURL", "loadUr"], "svnUrl": ["svnsServer", " svNServer", "svgUr", "svnURL", "svnsUrl", "svneStr", "svgURL", "svNUrl", "svnsURL", "servicenUr", "svNUr", "servicensURL", "svneServer", "svcUrl", "svNStr", "svnServer", "servicenurl", " svNUrl", "svgurl", "servicensUrl", " svNStr", "svcUr", "svgUrl", "svnsurl", "servicenUrl", "svnsUr", "svnurl", "svcURL", "svcurl", "servicensurl", "svNServer", " svNUr", "servicenURL", "svnUr", " svnServer", "svneUr", " svnUr", "servicensUr", " svnStr", "svnStr", "svneUrl", "svnsStr"], "url": ["lb", "ml", "dl", "cl", "location", "org", "build", "ul", "conn", "acl", "nl", "mount", "str", "base", "html", "host", "raw", "lr", "loc", "l", "gl", "google", "uri", "https", "r", "ssl", "browser", "uf", "impl", "ls", "mail", "ref", "sl", "uu", "bel", "ur", "pl", "github", "http", "ld", "hl", "ll", "link", "abs", "URL", "char", "call", "Url"], "uc": ["c", "cl", "ul", "sc", "ac", "eu", "oc", "conn", "ub", "u", "ui", "ud", "loc", "dc", "bc", "cus", "tc", "mc", "cc", "roc", "nic", "usc", "uf", "uci", "ux", "ci", "orc", "cu", "rc", "uu", "userc", "UC", "ucc", "ec", "uh", "co", "unc", "soc", "unic", "cur", "con", "auc", "fc", "anc", "lu", "cr", "us", "nc", "lc"], "userPassword": ["userGrant", "userpassword", "managerAuth", "userData", "managerPassword", "userPass", "browserPass", "UserPass", " userGrant", " userpassword", " userData", "Userpassword", "managerGrant", "browserData", "browserPassword", " userAuth", "UserAuth", "userAuth", " userPass", "browserpassword", "managerPass", "UserData", "UserPassword", "UserGrant"], "encoding": ["enryption", "enasing", "enoding", "encoder", "coding", "Encryption", "Encoding", "ecryption", "caling", "Encoder", "Encaling", "encasing", "ecaling", "ecoding", "cryption", "ecasing", "Encasing", "encaling", "ecoder", "encryption", "enoder", "coder"], "is": ["ip", "tis", "ists", "iris", "es", "\u00eds", "os", "sis", "imp", "isin", "mi", "isc", "bis", "isi", "isf", "im", "ows", "oss", "as", "iso", "lis", "ys", "ois", "its", "IS", "si", "ris", "fs", "ims", "ais", "isa", "mis", "iss", "it", "ios", "isl", "vis", "abs", "ir", "obs", "ins", "us", "i", "Is", "ic", "ism", "ri", "s", "ms"], "in": ["text", "t", "v", "bin", "read", "din", "k", "str", "inc", "isin", "rin", "file", "en", "print", "inner", "l", "ln", "e", "vin", "out", "r", "pin", "input", "nin", "login", "In", "n", "on", "password", "gin", "f", "edIn", "IN", "con", "it", "sum", "lit", "ins", "report", "inn", "m", "cin", "oin", "i", "kin"]}}
{"id1": "13720140", "id2": "16590954", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"modifyProperty": ["modifiesProperty", "ModifyAttribute", "ModifiesProp", "modifiesAttribute", "ModifyValue", "modateProperty", "modureProperty", "modureValue", "ModifiesProperty", "modifyAttribute", "modifyValue", "ModifiesAttribute", "ModifiesValue", "ModifyProperty", "modateAttribute", "modureProp", "modateValue", "modateProp", "ModifyProp", "modureAttribute", "modifiesValue", "modifiesProp", "modifyProp"], "valueID": ["versionIDs", "versionid", "propertyID", "versionId", " valueIDs", "VALUEID", "valueIDs", "versionUID", "versionMD", "VALUEUID", "valueUID", "propertyid", "propertyIDs", " valueUID", " valueId", "versionID", " valueid", "VALUEMD", " valueMD", "propertyId", "valueMD", "valueid", "VALUEId", "valueId"], "value": ["version", "content", "text", "save", "VALUE", "example", "memory", "v", "buffer", "type", "padding", "instance", "state", "default", "data", "comment", "attribute", "expression", "string", "update", "Value", "input", "application", "address", "name", "format", "variable", "password", "get", "description", "val", "hello", "field", "message", "output", "values", "vector", "entry", "label", "function", "code", "current", "key"], "userID": ["userType", " userId", "ownerName", "userURL", "usernameName", "UserName", "UserId", "ownerType", " userType", " userName", "userName", "UserURL", "usernameURL", "UserType", "UserID", "usernameID", " userURL", "userId", "usernameId", "ownerId", "ownerID"], "property": ["object", "claim", "license", "type", "method", "state", "translation", "data", "prop", "this", "attribute", "relation", "print", "ty", "prefix", "expression", "language", "prototype", "profile", "section", "operator", "item", "setup", "policy", "alias", "address", "title", "name", "metadata", "term", "command", "position", "project", "p", "feature", "pe", "media", "description", "pair", "properties", "option", "module", "Property", "field", "message", "display", "label", "style", "to", "table", "resource", "config", "function", "associated", "second", "key"], "newValue": ["oldValue", "newResult", "NewString", "NEWValue", " newMessage", "oldMessage", " newVersion", "oldString", "oldVersion", "oldValues", "newVersion", "uniqueValue", "oldResult", " newName", "Newvalue", "newString", " newString", "NEWvalue", "NEWResult", "NEWString", "uniqueVersion", "newName", "NewValue", "newMessage", "newvalue", "uniqueName", " newvalue", "NewValues", "uniqueMessage", " newResult", " newValues", "oldName", "newValues", "oldvalue"], "crypt": ["sync", "ctr", "ct", "coin", "enc", "dict", "cy", "ocr", "cont", "sm", "rem", "rot", "core", "col", "cry", "go", "bec", "trust", "cs", "comm", "pt", "hex", "roy", "rypt", "cp", "cc", "cmd", "sys", "dec", "ssl", "hash", "cert", "gc", "mac", "check", "Crypt", "magic", "nt", "conv", "rh", "mem", "arch", "password", "coll", "init", "cook", "cur", "cm", "ch", "reset", "cos", "cr", "prot", "auth", "cmp", "cot", "code", "CR"], "digest": ["hashge", "dested", "mdestamp", "digests", "digestamp", " digEST", "hexert", "mdest", " digestamp", "hashest", "Digests", " Digert", "Digge", "mdests", "hexEST", "dest", "Digert", "digester", " DigEST", "mdgest", "digert", "mdester", "hexest", " digested", "mdge", "hashgest", "dEST", "hexester", "Digestamp", "digge", "digEST", "digested", "dester", "DigEST", "mdEST", " Digest", " Digester", "Diggest", "hashests", "Digest", "Digester", "diggest", "Digested", "mdested"], "hexString": ["shortstring", "hashString", "shortStr", " hexstring", "formBuffer", "exBytes", "exStr", "formBytes", "hexArray", " hexBytes", "shortBuffer", "exString", "hashStr", " hexArray", "shortString", "hexBuffer", "hashArray", "hexstring", "exstring", "exBuffer", "hashstring", "hexStr", " hexStr", "formString", "formStr", " hexBuffer", "exArray", "hexBytes"], "i": ["ip", "li", "y", "io", "v", "span", "bi", "ii", "phi", "multi", "point", "I", "id", "u", "ui", "ind", "mi", "gu", "e", "gi", "uri", "im", "q", "hi", "cli", "x", "is", "ki", "ie", "ti", "major", "index", "ci", "slice", "pi", "ji", "chain", "a", "qi", "si", "init", "ix", "di", "info", "o", "ini", "ei", "number", "it", "sim", "j", "ex", "\u0438", "m", "ai", "us", "ic", "ms"]}}
{"id1": "17202157", "id2": "1473212", "code1": "    static Matrix readMatrix(String filename, int nrow, int ncol) {\n        Matrix cij = new Matrix(nrow, ncol);\n        try {\n            URL url = filename.getClass().getResource(filename);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            for (int i = 0; i < nrow; i++) for (int j = 0; j < ncol; j++) cij.set(i, j, Double.parseDouble(lnr.readLine()));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return cij;\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"readMatrix": [" readVector", " readTable", "readImage", "loadMatrix", " readImage", "readerTable", "readerMatrix", "readVector", "loadTable", "loadImage", "readerImage", "readerVector", "loadVector", "readTable"], "filename": ["println", "location", "pdf", "instance", "fil", "which", "FILE", "csv", "file", "File", "username", "image", "original", "self", "prefix", "nil", "uri", "string", "png", "JSON", "path", "java", "title", "name", "n", "SourceFile", "f", "description", "json", "directory", "URI", "fp", "kl", "via", "Filename", "sql", "output", "subject", "nm", "resource", "ename", "fn", "source", "kj", "txt"], "nrow": ["Ncell", "Now", "ncell", " nrecord", "ncroot", " nrun", "drecord", " nroot", "nroot", "now", "ncrow", "nwrow", "drow", " now", "nrecord", "nwrows", "ncrun", "Ncol", "intcell", "gnrows", "gnrun", " nrows", "nrows", "introw", "nwcol", " ncell", "nwrecord", "dcol", "gnrow", "nrun", "intcol", "drows", "gnroot", "ncrows", "intow", "Nrow"], "ncol": ["neCol", "NCol", "trow", "ncell", "mrow", "nerow", "ncolumn", "tcell", "nCol", "tcolumn", "tcol", "drow", "dCol", " ncolumn", "Ncol", "Ncolumn", "mcolumn", "mcol", "mCol", " ncell", "dcolumn", " nCol", "dcol", "necolumn", "mcell", "necol", "Nrow", "dcell"], "cij": ["coji", "coj", "dij", "CIuj", "ccijp", "dijs", "pij", "ccidj", "cijs", "cijp", "diji", "cije", "cilaj", "cindj", "ciji", "cidj", "ciaj", "ccij", "ciljs", "CIr", "piuj", "ccije", "ciuj", "CIji", "piaj", "coje", "cilji", "piji", "cilj", "cinjp", "cojp", "cor", "diaj", "cir", "CIj", "codj", "pir", "pijs", "couj", "cinj", "cinje"], "url": ["dl", "ul", "rl", "nl", "mount", "str", "base", "user", "log", "file", "loc", "lr", "l", "b", "web", "loader", "uri", "q", "browser", "impl", "ls", "util", "open", "job", "mail", "ref", "sl", "address", "bel", "ur", "get", "f", "pl", "http", "kl", "ll", "link", "rel", "ret", "URL", "fl", "char", "resource", "Url"], "lnr": ["linar", "lnnr", "gnl", "nlr", "lannr", "lnl", "nlp", "gnar", "lanr", "nll", "linr", "gnr", "knmr", "lnp", "nlmr", "linp", "lnar", "lanmr", "nlnr", "nlar", "linl", "lanar", "knar", "gnp", "lnmr", "knnr", "knr"], "i": ["ip", "ori", "li", "io", "bi", "in", "ii", "phi", "multi", "asi", "xi", "id", "I", "ui", "mi", "iu", "gi", "im", "q", "hi", "ami", "x", "is", "ki", "ie", "ti", "index", "aci", "pi", "ij", "iq", "wi", "me", "iri", "ia", "si", "init", "ix", "di", "ims", "ei", "ini", "it", "yi", "sim", "ret", "ir", "ai", "us", "zi", "ic", "ri"], "j": ["jj", "ja", "y", "J", "v", "zone", "aj", "k", "js", "ne", "u", "jc", "pr", "l", "jp", "oj", "b", "pt", "e", "je", "im", "ge", "q", "ph", "out", "ie", "jump", "br", "err", "att", "obj", "ji", "ij", "job", "n", "ix", "json", "o", "jac", "uj", "bj", "it", "jl", "jo", "z", "m", "g", "ion", "h", "us", "dj", "s", "kid", "kj", "other"]}}
{"id1": "11153282", "id2": "4938100", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"existsURL": [" existURL", "existURL", "existUrl", "existUR", "exitsUrl", "exitsURL", "existingUR", "existingURL", "exitsUR", "existsHTTP", " existHTTP", " existUR", "existsUrl", " existsHTTP", " existUrl", " existsUR", "existsUR", "existingUrl", " existsUrl", "exitsHTTP", "existHTTP", "existingHTTP"], "urlStr": ["uriSpec", "UrlSpec", "URLStr", "URLString", "UrlStr", "UrlObj", "urlString", "uriStr", "uriSt", " urlSpec", "urlObj", " urlObj", "UrlSt", "urlSpec", " urlSt", "uriWr", "uriObj", "URLWr", "urlSt", "URLSpec", "uriString", " urlString", " urlWr", "urlWr"], "url": ["lb", "dl", "org", "build", "ul", "conn", "rl", "acl", "nl", "mount", "str", "base", "this", "log", "file", "loc", "l", "b", "uri", "https", "il", "arl", "r", "ssl", "ls", "gc", "job", "sl", "name", "sur", "bel", "ur", "arch", "p", "pl", "http", "ll", "link", "abs", "URL", "char", "null", "Url"], "con": ["compl", "c", "close", "can", "conn", "cont", "re", "Con", "connection", "Conn", "col", "user", "pen", "en", "sub", "inner", "cs", "bc", "cf", "comm", "ln", "ain", "cp", "client", "proc", "cons", "res", "CON", "cond", "open", "conv", "n", "un", "on", "ran", "co", "coll", "soc", "cur", "conf", "num", "cn", "fin", "cm", "ch", "fc", "canon", "rec", "dial", "syn", "com", "ctrl", "cos", "nc", "fn", "connect"], "responseCode": ["conditionMap", " responseType", "ResponseMessage", "responsecode", "responseMap", " responseMap", "replycode", "answerType", "replyMessage", "ResponseCode", "answerZone", "conditionCode", "answerMap", " responseMessage", "responseMessage", "Responsecode", "answerCode", " responsecode", "conditionType", "replyCount", "responseType", "responseZone", "ResponseCount", "responseCount", "conditionZone", "replyCode", " responseZone", " responseCount"]}}
{"id1": "14303294", "id2": "11005804", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["toClientPassword", "toServerSalt", "getUserHash", "getserverSalt", "toClientHash", "getUserMac", "getserverMac", "getUserPassword", "toServerHash", "getClientMac", "getUserSalt", "getServerPassword", "getServerMac", "getClientSalt", "toServerPassword", "toClientSalt", "getServerSalt", "getserverPassword", "getClientPassword", "toClientMac", "getserverHash", "toServerMac", "getClientHash"], "passwordHash": ["emailHTML", "PasswordKey", "serverHash", "emailHas", "passwordHTML", "swordHTML", "swordSalt", "swordHas", " passwordSalt", "serverSalt", "passwordKey", "PasswordHash", "emailSalt", "passwordHas", " passwordPassword", "serverKey", "PasswordPassword", "serverPassword", "emailHash", "swordHash", "PasswordHas", "passwordPassword", "PasswordHTML", " passwordKey", "passwordSalt"], "PasswordSalt": ["PasswordToken", "UserSecret", "UserSalt", "PasswordSecret", "passwordToken", " passwordSalt", " PasswordToken", " passwordToken", "UserHash", "PasswordHash", "passwordSecret", " PasswordHash", " PasswordPassword", " PasswordSecret", "UserToken", " passwordPassword", "PasswordPassword", "passwordPassword", "passwordSalt"], "hash": ["echo", "serial", "build", "score", "copy", "html", "total", "log", "ash", "test", "print", "Hash", "component", "hex", "result", "dig", "sha", "transform", "crypt", "mask", "index", "shift", "mac", "cache", "address", "map", "password", "handle", "height", "search", "match", "value", "row", "json", "tag", "sample", "block", "response", "message", "sum", "char", "report", "sh", "filter", "h", "word", "key"], "digest": ["displaygest", "dested", "digse", "decest", " digEST", "mdest", " digester", "hashest", " digse", "descse", "dest", "digester", "decse", "mdester", " digested", "hashgest", "dEST", "descest", "displayester", "digEST", "descester", "digested", "dester", "DigEST", "mdEST", "Diggest", "decester", "displayest", "Digest", "descested", "decested", "Digester", "diggest", "hashested", "Digested", "hashester", "displayested", "mdested", "Digse"]}}
{"id1": "1421557", "id2": "18114701", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "647224", "id2": "12678045", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"uploadFile": ["putFiles", "saveFiles", "uploadImage", " uploadfile", "putfile", " uploadImage", " uploadFiles", "uploadFiles", "putImage", "savefile", "saveFile", "putFile", "saveImage", "uploadfile"], "inputFile": ["imgOne", "infoFilename", "inputFILE", "inputfile", " inputLe", "inputField", "InputFiles", "Inputfile", "inputResource", "imgLe", "targetField", "fromField", "evalField", "imgFile", "outputLine", " inputfile", "inputLe", "outputPath", "imgLine", "updateOne", "infoFile", "updateFile", "thisLine", "targetFILE", "outputfile", "inputLine", "evalFile", "targetResource", "inputPath", "fromResource", "InputLine", "fromFile", "inputOne", "inFILE", "thisPath", "updateLe", "outputFiles", "fromFILE", "inLine", "infoFILE", " inputFiles", "thisfile", " inputFilename", " inputFILE", " inputLine", "InputFile", "inputFiles", "inFilename", " inputPath", "evalResource", "inFile", "inputFilename", "evalFILE", "infoLine", "updateLine", "thisFile", " inputOne"], "targetFile": ["sourceFiles", "outputDir", "targetPath", "detailString", "targetString", " targetFilename", "TargetFile", " targetString", "tofile", "toDir", " targetFILE", "outputDate", "TargetString", "sourceDir", "targetFilename", "outputFolder", "TargetPath", "sourceFile", "detailDir", "TargetFiles", "outputPath", "targetDir", "targetDate", "toFile", "toFolder", "targetFILE", "sourceDate", "outputfile", " targetPath", "sourcefile", " targetDir", "targetfile", "outputFilename", "targetFiles", "targetFolder", "detailFILE", "detailFile", "sourceFolder", "outputFiles", "sourcePath", "sourceFilename", " targetDate", "TargetDir", "TargetFILE"], "outputFile": ["sourceFiles", " outputGe", "outputDir", "inputLog", "removePlace", "displayFILE", "targetDirectory", "outFile", "outputPlace", " outputDir", "inputfile", "inputDo", "putFile", "noGe", "putPlace", "sourceDir", "displayPlace", " outputDirectory", "displayStore", "nullStyle", "noPlace", "targetFilename", "outDir", "sourceFile", "nofile", "targetDir", "outModel", " outputLog", "inputDirectory", "outFiles", "outputfile", "outputDo", "outputFILE", "displayFile", "sourcefile", "removeFile", "outfile", "putfile", "nullfile", "targetfile", "targetFiles", " outputStore", "removeStore", " outputStyle", "outputFilename", "targetLog", "outputLog", " outputModel", "outputFiles", " outputFILE", "removeFILE", "outDo", " outputFilename", "inputDir", "outStyle", "targetModel", " outputPlace", "inputFiles", "putGe", "nullFile", "outputStore", "inputModel", "nullModel", " outputfile", "outputDirectory", " outputDo", " outputFiles", "noFile", "outputStyle", "outputModel", "outputGe", "inputFilename"], "in": ["io", "read", "bin", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "l", "ze", "inf", "ain", "inside", "iter", "ro", "mc", "im", "is", "input", "al", "In", "on", "per", "init", "info", "ini", "IN", "like", "con", "it", "ar", "ins", "inn", "cin", "act", "ai", "i", "mm", "ic", "ri", "source", "by"], "out": ["t", "println", "io", "v", "dis", "can", "write", "by", "os", "auto", "log", "print", "inner", "b", "ln", "at", "console", "sys", "ot", "client", "put", "cache", "res", "err", "end", "obj", "screen", "name", "nt", "up", "n", "on", "co", "all", "list", "conf", "IN", "net", "o", "con", "cn", "outs", "it", "vol", "Out", "output", "sum", "report", "null", "we", "ex", "to", "cos", "g", "writer", "s", "ou", "aos", "OUT", "outer", "and"], "line": ["detail", "lin", "lane", "inline", "range", "point", "nl", "column", "comment", "log", "LINE", "phrase", "l", "ln", "cell", "eline", "Line", "lo", "stroke", "entity", "rule", "chain", "ine", "command", "ide", "frame", "row", "query", "edge", "record", "sample", "block", "field", "sequence", "lock", "message", "link", "entry", "label", "node", "code", "word", "page"], "bytes": ["gs", "terms", "ies", "oms", "uses", "classes", "es", "bs", "gments", "parts", "ales", "xes", "frames", "gets", "ones", "books", "errors", "bits", "lements", "ges", "ites", "pages", "ows", "rows", "bes", "ls", "comments", "odes", "bps", "Bytes", "otes", "cells", "les", "ices", "amples", "ends", "outs", "lines", "seconds", "blocks", "nets", "reads", "files", "comes", "values", "steps", "bles", "times", "vals", "ips", "tes", "units", "sofar"]}}
{"id1": "3430784", "id2": "6403868", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodesContent", "decodedBody", "decprocessContent", " DecodeForm", " DecodeHeader", " DecodesForm", " DecodesHeader", "decprocessHeader", "decodedForm", "decodesForm", "decprocessForm", " DecodesBody", "decprocessBody", " DecodeContent", "decodeContent", " DecodeBody", "decodedHeader", "decodeHeader", "decodesBody", "decodesHeader", "decodedContent", "decodeForm", " DecodesContent"], "in": ["mat", "v", "bin", "or", "k", "ac", "data", "en", "ain", "iter", "is", "up", "In", "on", "init", "con", "pc", "ins", "cin", "act", "xml", "conn", "asin", "file", "inner", "add", "l", "body", "q", "nin", "pi", "al", "req", "get", "ma", "h", "oin", "din", "inc", "isin", "serv", "inf", "inside", "vin", "check", "load", "info", "it", "sql", "doc", "to", "cont", "source", "content", "c", "reader", "rin", "ind", "b", "r", "input", "n", "gin", "all", "IN", "from", "ex", "inn", "m", "ai", "i", "mm", "form"], "contentTransferEncoding": ["contentTypeEncoded", "contentRequestEncication", "contentRequestEnasting", "contentInfoEncling", "contentTransferChoding", "contentTransferChode", "contentTransferChapping", "contentTransferEnication", "contentTransferEncication", "contentTransferEnation", "contentTransferEncation", "contentTransferEncType", "contentTransferEncasting", "contentTransferencication", "contentInfoencling", "contentInfoencoder", "contentTypeEncoding", "contentTypeEnode", "contentTransferencacing", "contentTransferFormType", "contentRequestencoding", "contentInfoencacing", "contentTransferSeapping", "contentTransferAuthoded", "contentTransferEvoding", "contentTransferCollation", "contentTransferEncling", "contentTypeEnoding", "contentTransferEncapping", "contentRequestEncoding", "contentRequestEncoded", "contentTransferEnoding", "contentTransferEvoder", "contentTransferAuthoder", "contentRequestencoder", "contentTypeEnapping", "contentTransferSeoded", "contentTransferEvoded", "contentTransferChoded", "contentTransferencoder", "contentRequestEnType", "contentRequestEncType", "contentTransferCollasting", "contentTypeEncode", "contentInfoencoding", "contentTransferencoding", "contentTransferColloder", "contentTransferFormoding", "contentTransferEnode", "contentTransferEnoded", "contentTransferEncoded", "contentRequestEnoded", "contentTransferEnling", "contentTransferColloding", "contentRequestEncation", "contentRequestencication", "contentTransferencling", "contentTransferEncode", "contentTransferEnapping", "contentTransferFormling", "contentTransferEncacing", "contentTransferEnoder", "contentRequestEnoder", "contentTransferencType", "contentInfoEncoding", "contentTransferEncoder", "contentTransferSeoding", "contentTransferEnType", "contentRequestencoded", "contentTransferAuthoding", "contentTransferEnasting", "contentTransferencoded", "contentRequestEnation", "contentRequestEncoder", "contentTransferAuthType", "contentTypeEnoded", "contentRequestEncasting", "contentTransferEvication", "contentTransferEnacing", "contentTransferSeode", "contentTypeEncapping", "contentInfoEncacing", "contentRequestEnoding", "contentTransferFormoder", "contentInfoEncoder"], "tempBody": [" tempbody", "tempFile", "tempFoot", "tmpHead", " tempBox", "temHead", "tabFoot", "tempReturn", "temReturn", "tempBox", " tempFile", "tabReturn", "tmpBody", "temBody", "tempHead", "tembody", "TempFile", " tempHead", "temBox", "temFoot", "tabBody", "tmpbody", "tmpBox", "temFile", "TempBody", " temporaryReturn", "TempHead", " temporaryBox", " temporaryBody", " temporaryFoot", "tempbody", "Tempbody", "tabBox"], "out": ["t", "io", "v", "inv", "os", "user", "OU", "auto", "log", "inner", "l", "ent", "sys", "oss", "client", "is", "gc", "res", "obj", "conv", "up", "n", "co", "all", "o", "net", "con", "one", "cn", "outs", "it", "Out", "output", "sum", "ex", "null", "m", "cin", "to", "cos", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "771802", "id2": "11952735", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputFile", "createInputSteam", " createOutFile", " createInputstream", " createOutputstream", " createInputFile", "createInputstream", " createOutputSteam", " createFileSteam", " createOutStream", "createOutputFile", "createInputStream", "createOutputSteam", " createFileFile", " createInputSteam", " createOutSteam", " createInputStream", " createOutstream", " createOutputFile", " createFilestream", " createFileStream", "createOutputstream"], "inFile": [" inPath", " infile", "dinFile", "ninfile", " inDir", "dinPath", "infile", "ninFilename", "inPath", "outPath", "inputPort", "outFilename", " inPort", "dinDir", "inPort", "ninFile", "inputPath", "outfile", "ninPath", "inputFile", "inputDir", "inFilename", "inDir", " inFilename", "dinPort"], "outFile": ["outPlace", "newPlace", "toPort", "OutFilename", "tofile", "outputPlace", "infile", "OutFile", "newFilename", "outFilename", "toFile", "inPort", "toFilename", "outputfile", "newFile", "exfile", "outPort", "outfile", "exFile", "outputFile", "outputFilename", "OutPort", "inFilename", "Outfile", "exPlace", "newfile", "exFilename"], "k_blockSize": ["k_byteName", "k_BlockStyle", "k2blockSize", "k4blockName", "k_BlockName", "k4BlockName", "k_byteLength", "k2byteCount", "k_blockCount", "k_batchLength", "k_batchCount", "k4blockSize", "k4blockCount", "k2byteTime", "k_blockName", "k2byteSize", "k_BlockSize", "k_batchTime", "k2blockTime", "k2byteLength", "k4BlockCount", "k_BlockCount", "k_blockTime", "k4BlockSize", "k4BlockStyle", "k_blockLength", "k_byteTime", "k_batchSize", "k_byteCount", "k_byteSize", "k_BlockLength", "k_blockStyle", "k4blockStyle", "k2blockLength", "k2blockCount", "k_byteStyle", "k_BlockTime"], "byteCount": [" bytePtr", "bitN", "bitCounter", "linecount", "bitSize", "byteCheck", "bbCount", "byteCode", "byteCounter", "bitCode", "bitCount", " bytecount", "byteN", " byteCheck", "linePtr", "blockCount", "bbN", "charPtr", "lineLength", "charcount", "bbSize", "blockCounter", "wordCount", "wordN", "bytecount", "charCount", "wordSize", "bitCheck", "charLength", "lineCount", "wordCode", "bitLength", " byteCounter", "blockLength", "blockCheck", "bbCode", " byteLength", "byteSize", "byteLength", "bytePtr"], "buf": ["bg", "img", "ctr", "cv", "Buffer", "buffer", "arr", "ctx", "str", "buff", "Buff", "raw", "batch", "b", "bc", "vec", "cmd", "alph", "proc", "queue", "uf", "cb", "bl", "rb", "conv", "bag", "mem", "exp", "cast", "seq", "pkg", "cur", "pb", "block", "cap", "cat", "tx", "fg", "bytes", "doc", "db", "msg", "bn", "txt"], "ofp": ["Ofp", "Ofd", " ofd", "OFP", " ofpa", "ofl", "ofpa", "owld", "ofd", "ofP", "owlP", "owlp", "Ofpa", " ofl", "OFp", "Ofl", "owlpa", "OfP", " ofP", "OFd", "OFl"], "zos": ["tis", "gs", "zb", "LOS", "amia", "ps", "esa", "es", "bs", "zin", "js", "rez", "sbm", "os", "hz", "sis", "psy", "nz", "cz", "python", "south", "zen", "jp", "webkit", "ze", "zer", "sch", "zh", "hess", "oss", "zona", "bes", "zag", "ws", "ossus", "zzle", "eros", "zl", "enos", "init", "los", "ez", "jas", "zu", "rose", "std", "zik", "css", "za", "zers", "settings", "zon", "rss", "z", "osi", "socket", "zo", "cos", "zi", "zes", "zip", "zy"], "osw": ["aospace", "sysW", "osd", "aosw", "cosew", "issw", "osrw", "iswx", "osswx", " osws", "osiw", "ossW", "sysrw", "owa", "aosrw", "oswa", "aosew", "osws", "aosws", "aosW", " ossw", "aoswd", "ow", " osW", "oW", "isW", " oswx", "osiwa", "ossw", "osW", "cosws", "osssw", "aoswa", "isw", "osswd", "syswd", "opace", "ospace", "oswd", "sysw", "osiW", "cosw", " osew", "oswx", "osipace", "cosd", "osew", " osd", "aosd", "ossrw"], "bw": [" bws", "obz", "bbem", "besw", "bsw", "pbew", "abew", " bwl", "bend", "wbz", "bew", "obwl", "sbw", "bws", "bbz", "wbwp", "obwk", "bewl", " bx", "bwb", "wbx", "sbwb", " bwk", "obwb", "bwl", "wbend", "pbwe", "obwt", "pbwt", "pbwy", "pbz", "nbew", "bbwp", "bbwt", "bwk", "bbend", "bbex", "rbws", "nbw", "pbwb", "abwe", "rbw", "bbx", " bex", "nbwy", "bz", "bewk", "wbw", " bem", "pbw", "sbz", "nbwe", "bx", "rbz", "bex", "bem", "bwt", "bbw", " bend", "bwy", "wbwt", "wbem", " bsw", "obsw", "bwe", "abw", "rbex", "sbwt", "bbws", "bwp", " bwp", " bwt", "abwy", "obw", " bz"], "zot": ["zeronet", "Zote", "zipiot", "zoonet", " ziat", "zote", "ziat", "zeror", "zerot", "zerhot", " zonet", " ziot", " zhot", "Zit", "Zot", "zipiat", " zo", "zerote", "zoo", " zote", "zerit", "zor", "zhot", "zonet", "zero", "zoot", "Zott", "zipot", "ziot", "ziphot", "zoor", "zott", "zeriat", " zott", "zeriot", " zor", "zerott", "zo"], "ifp": ["Ifjp", "ifP", "iwr", "ifjp", " ifP", " ifjp", "isth", "ihr", "iwtp", "isp", "Ifp", "iftp", " ifr", " iftp", "isjp", "ifth", "ihtp", " ifth", "ifr", "ihp", "isP", "ifd", "Ifth", "IfP", "iwd", "iwp", "ihd", " ifd"], "zis": [" zIS", " zi", "izisa", "zoiss", "izinit", "zisc", " zic", "zinit", " zisc", "ziss", "zipis", "zeris", "zisa", "ziinit", "ezis", "zerIS", "zoisa", "zoinit", "zipic", "ezi", "zois", " ziss", "izi", "zic", "zipIS", "ziiss", "ezisc", "zIS", "eziss", "ziis", "ziisa", "iziss", "zi", "izisc", "izis", "zeric"], "isr": ["itsr", " isrs", " iscr", "itsstr", "ispr", "issrs", "iosr", "isalstr", "sisrs", "sisr", "isalpr", "isalr", "isrc", "isalsr", "isstr", "iosstr", "iscr", " isrc", "itspr", "sisrc", "isrs", "iospr", "itssr", "siscr", "issr", "iossr", "isscr", "issrc"], "br": ["fr", "bd", "ctr", "vr", "gr", "Br", "sr", "bm", "dr", "bh", "ba", "bi", "shr", "mr", "js", "str", "bf", " Br", "lr", "pr", "b", "bt", "wr", "ber", "obl", "yr", "r", "tr", "hr", "bl", "rb", "ptr", "bro", "bj", "bp", "rel", "cr", "Fr", "BR", "bn", "kr"], "zit": ["ziti", "zeip", "izip", "zist", "ozit", "czot", "oziti", "zop", "ozip", "czunit", "zipit", "ziit", "zipIT", "ziist", "czit", " zop", "cziti", "lexIT", "zip", " zIT", "ezIT", "zlit", "zunit", "zipite", "lexIt", "ziIt", "lexit", "zipist", "czop", "zipIt", " zip", "iziti", "zeit", "czip", "izit", "ziplit", "zeop", "zIt", "zeot", "ezlit", " zlit", "zIT", "ezit", "ziIT", "ozunit", "zite", " zite", "ezite", "izunit", "lexist"]}}
{"id1": "11484416", "id2": "17792212", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"moveFile": ["moveImage", "copyfile", "MoveFile", " moveImage", "moveDirectory", "movefile", "copyDirectory", " movefile", " moveDirectory", "MoveDirectory", "copyImage", "MoveImage", "Movefile", "copyFile"], "orig": ["ori", "ip", "img", "tmp", "coord", "create", "org", "copy", "or", "inv", "src", "base", "imp", " original", "prop", "raw", "dest", "original", "temp", "was", "im", "iter", "clip", "origin", "ie", "rc", "created", "ra", "old", "exp", "Origin", "init", "dom", "Original", "cur", "ord", "proxy", "existing", "internal", "ret", " ORIG", "Orig", "ex", "act", "lim", "good", "def"], "target": ["tile", "t", "tmp", "replace", "top", "build", "copy", "src", "arget", "base", "dest", "test", "file", "next", "origin", "gt", "sys", "out", "png", "path", "mac", "format", "goal", "match", "touch", "template", "local", "it", "rel", "output", "ret", "null", "table", "parent", "source", "Target"], "buffer": ["scroll", "history", "Buffer", "binary", "read", "memory", "stack", "stream", "data", "buff", "base", "length", "comment", "attribute", "bank", "batch", "available", "document", "print", "phrase", "iter", "button", "bar", "limit", "queue", "line", "cache", "engine", "chain", "screen", "variable", "command", "face", "header", "buf", "mem", "password", "paste", "sample", "block", "sequence", "message", "output", "bytes", "char", "display", "table", "page", "filter", "bridge", "window", "bb"], "bread": ["corruption", "bush", " breadth", "bi", "robe", "beck", "web", "give", "lf", "rik", "blow", "leen", "bled", "billion", "bb", "boat", "read", "bill", "READ", " barely", "ig", "crafted", "fine", "uckle", "jing", "bishop", "piece", "iber", "rew", "less", "good", "fee", "score", "bird", "brow", "gear", "fred", "nob", "fan", " ribs", "spoken", "eb", "wake", "eric", "bad", "bold", "brew", "rain", "knife", "bridge", "level", "scroll", "four", "neum", "middle", "rown", "log", "print", "bc", "shield", "cake", "ful", "ble", "broken", "don", "bel", "wei", "beat", " Bread", "stay", "inn", "bn", "oug"], "fis": ["liss", "li", "ufos", " fi", "dis", "fiss", "bi", "bis", "frei", "ufris", " fia", " fiss", "bos", "ufis", "Fos", "lis", " fris", "fia", "Fris", "los", "di", "Fiss", "freis", "freia", "biss", "ufiss", "Fis", "fi", "dia", "fris"], "fos": ["Fot", "tis", "voos", "foes", " fus", " fot", "Foos", "pus", "oot", " foos", "Foses", "fot", "vus", "ooes", "pos", " foses", "eoes", "poos", "Foes", "eos", "vos", "oos", "Fos", "foses", "eis", "toos", "poes", "ooses", "fus", "foos", "tos", "eoos", "Fis", "voes", " foes", "toes"]}}
{"id1": "942693", "id2": "19134229", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverted", "unversion", "conprocess", "consverting", "converted", "Confer", "consVERT", "Converting", "unfer", "consvert", "unvert", "compversion", "compprocess", "CONverting", "compverts", "CONfer", "confer", "compvert", "conversion", "unverted", "CONversion", "converts", "Converted", "ConVERT", "conVERT", "Conversion", "unprocess", "converting", "Converts", "CONvert", "unverts", "consversion", "Conprocess", "CONVERT", "Convert"], "src": ["scan", "img", "sr", "ipl", "sc", "sin", "host", "scene", "stream", "str", "rx", "usr", "sit", "upload", "rest", "file", "loc", "func", "sq", "uri", "RC", "sys", "cc", "SOURCE", "input", "path", "ource", "rc", "orig", "start", "Source", "its", "url", "req", "ur", "SourceFile", "iv", "pkg", "http", "buster", "href", "cur", "dist", "rs", "hl", "attr", "rel", "st", "from", "ins", "ebin", "addr", "config", "inst", "s", "cont", "ser", "source", "filename", "txt"], "dest": [" orig", "img", " dst", "est", " Dest", "Dest", "mat", "write", "rest", "disk", "test", "foreign", "temp", "result", "dir", " destination", "dat", "orig", "tif", "gin", "target", "dist", " Destination", " destinations", "table", "port", "source", "txt"], "in": ["io", "reader", "bin", "din", "stream", "isin", "rin", "ind", "file", "el", "en", "inner", "l", "b", "serv", "inf", "as", "r", "is", "input", "res", "up", "In", "d", "IN", "st", "from", "sql", "ar", "ins", "inn", "m", "cin", "ad", "i", "source"], "p": ["pm", "parse", "lp", "t", "c", "tp", "ps", "pa", "part", "py", "dp", "l", "jp", "b", "pg", "pt", "vp", "post", "ap", "at", "parser", "cp", "ph", "r", "P", "pi", "pd", "op", "er", "f", "per", "pe", "pl", "d", "pkg", "wp", "pb", "fp", "php", "ping", "it", "pc", "pre", "j", "pro", "pp", "m", "g", "prot", "i", "sp", "h", "rep", "pers"], "ds": ["dl", "ads", " des", " DS", "sd", "bs", "posts", "vs", "dp", "eps", "dds", "DS", "edes", "sts", " d", "yes", "gs", "dos", "dh", "iffs", "js", "points", "ils", "lists", "dd", "aws", "df", "ls", "pd", "its", "di", "rs", "sets", "docs", "s", "ts", "ps", "tp", "des", "mys", "os", "cks", "workers", "cs", "scripts", "ks", " dd", "ys", "nas", " ads", "ws", "drivers", "loads", "ands", "eds", "ods", "uds", "ras", "db", "tes", " os", "qs", "terms", "ss", "ags", "tags", "ats", "hs", "amps", "els", "ports", "hd", "Ds", "dt", "dates", "d", "outs", "tests", "obs", "gd", "ns", "xs"], "format": ["version", "parse", "t", "ct", "unit", "mat", "type", "top", "status", "ats", "id", "mt", "Format", "file", "l", "MAT", "lat", "at", "source", " Format", "shape", "pattern", "feat", "path", "fm", "policy", "pi", "title", "spec", "name", "layout", "feature", "f", "pretty", "set", "template", "module", "tag", "it", "size", "output", "fc", "settings", "sche", "style", "act", "table", "filter", "mode", "cf", "form"], "hasPixelData": ["hasixelData", "HaspixelDATA", "HaspixelData", "haspixelData", "hasFrameData", "hasixeldata", "hasPixeldata", "HasPixelDATA", "hasFrameDATA", "hasPixelDATA", "haspixeldata", "HasPixelData", "Haspixeldata", " hasPixelDATA", "hasixelDATA", "HasPixeldata", "haspixelDATA", "hasFramedata", " hasPixeldata"], "inflate": ["inFlATE", "infolated", "inFlate", "Inflate", "inFLated", "inFlicate", "infolat", "informocate", "invalidicate", "inflat", " inflocate", "infolate", " invalidicate", "Inflat", "incelocate", " invalidate", "incelate", "inFlocate", "invalidocate", "Inflocate", "Informocate", "Informate", "inflated", "inflocate", "inflATE", "inFLate", "invalidate", "Inflated", "informate", "invalidATE", "Informated", " inflicate", "informat", "infolocate", " inflATE", " invalidATE", "incelicate", "Informat", "informated", "inFLocate", " invalidocate", "incelATE", "inflicate", "inFLat"], "pxlen": ["cplength", "pexls", "pxden", "packlen", "pxfun", "xpln", "pexln", "cplen", "phplength", "pxlength", "mxln", "pixells", "packls", "packfun", "tmpln", "xyln", "pexlen", "mmlength", "pxln", "mmlin", "xpden", "xplength", "pexlength", "xplen", "pxdec", "xylength", "mxdec", "pixellength", "pxls", "phplen", "pxlin", "packln", "mxlength", "mmlen", "phpdec", "pixelfun", "xylen", "tmplen", "mxlen", "mmln", "tmplength", "tmplin", "pexfun", "cpden", "cpln", "phpln", "xylin", "packlength", "pixellen", "packdec", "pexden"], "out": ["io", "gr", "cfg", "inv", "conn", "user", "log", "inter", "print", "prefix", "temp", "ln", "dir", "sys", "client", "cmd", "res", "err", "obj", "screen", "up", "name", "pretty", "init", "list", "net", "crit", "outs", "group", "output", "sum", "gov", "ex", "Out", "store", "msg", "writer", "ou", "aos", "OUT", "outer"]}}
{"id1": "20247400", "id2": "7006052", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"in": ["io", "bin", "din", " din", "inc", "isin", "rin", "ind", "file", "inner", "ze", "inf", "is", "input", "check", "up", "In", "on", "gin", "init", "info", "IN", "net", "con", "it", "from", "ins", "inn", "cin", "ai", "i", "source", "and"], "out": ["t", "println", "io", "exit", "write", "or", "str", "ne", "os", "auto", "OU", "log", "print", "b", "ln", "dir", "at", "sys", "gt", "r", "cmd", "oss", "line", "client", "ot", "check", "err", "obj", "screen", "name", "n", "list", "o", "net", "con", "outs", "w", "it", "output", "Out", "we", "report", "null", "ins", "ex", "to", "msg", "writer", "ou", "OUT", "outer", "other"], "buffer": ["history", "Buffer", "binary", "memory", "se", "view", "stack", "data", "buff", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "b", "component", "temp", "trace", "result", "iter", "source", "flush", "bar", "size", "queue", "limit", "pause", "shape", "library", "index", "cache", "database", "address", "variable", "command", "position", "buf", "clear", "processor", "match", "channel", "template", "event", "sample", "block", "sequence", "output", "message", "display", "append", "table", "function", "filter", "bridge", "window", "db", "key", "header"]}}
{"id1": "771802", "id2": "20100809", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputFile", "createInputSteam", " createOutFile", " createInputstream", " createOutputstream", " createInputFile", "createInputstream", " createOutputSteam", " createFileSteam", " createOutStream", "createOutputFile", "createInputStream", "createOutputSteam", " createFileFile", " createInputSteam", " createOutSteam", " createInputStream", " createOutstream", " createOutputFile", " createFilestream", " createFileStream", "createOutputstream"], "inFile": [" inPath", " infile", "dinFile", "ninfile", " inDir", "dinPath", "infile", "ninFilename", "inPath", "outPath", "inputPort", "outFilename", " inPort", "dinDir", "inPort", "ninFile", "inputPath", "outfile", "ninPath", "inputFile", "inputDir", "inFilename", "inDir", " inFilename", "dinPort"], "outFile": ["outPlace", "newPlace", "toPort", "OutFilename", "tofile", "outputPlace", "infile", "OutFile", "newFilename", "outFilename", "toFile", "inPort", "toFilename", "outputfile", "newFile", "exfile", "outPort", "outfile", "exFile", "outputFile", "outputFilename", "OutPort", "inFilename", "Outfile", "exPlace", "newfile", "exFilename"], "k_blockSize": ["k_byteName", "k_BlockStyle", "k2blockSize", "k4blockName", "k_BlockName", "k4BlockName", "k_byteLength", "k2byteCount", "k_blockCount", "k_batchLength", "k_batchCount", "k4blockSize", "k4blockCount", "k2byteTime", "k_blockName", "k2byteSize", "k_BlockSize", "k_batchTime", "k2blockTime", "k2byteLength", "k4BlockCount", "k_BlockCount", "k_blockTime", "k4BlockSize", "k4BlockStyle", "k_blockLength", "k_byteTime", "k_batchSize", "k_byteCount", "k_byteSize", "k_BlockLength", "k_blockStyle", "k4blockStyle", "k2blockLength", "k2blockCount", "k_byteStyle", "k_BlockTime"], "byteCount": [" bytePtr", "bitN", "bitCounter", "linecount", "bitSize", "byteCheck", "bbCount", "byteCode", "byteCounter", "bitCode", "bitCount", " bytecount", "byteN", " byteCheck", "linePtr", "blockCount", "bbN", "charPtr", "lineLength", "charcount", "bbSize", "blockCounter", "wordCount", "wordN", "bytecount", "charCount", "wordSize", "bitCheck", "charLength", "lineCount", "wordCode", "bitLength", " byteCounter", "blockLength", "blockCheck", "bbCode", " byteLength", "byteSize", "byteLength", "bytePtr"], "buf": ["bg", "img", "ctr", "cv", "Buffer", "buffer", "arr", "ctx", "str", "buff", "Buff", "raw", "batch", "b", "bc", "vec", "cmd", "alph", "proc", "queue", "uf", "cb", "bl", "rb", "conv", "bag", "mem", "exp", "cast", "seq", "pkg", "cur", "pb", "block", "cap", "cat", "tx", "fg", "bytes", "doc", "db", "msg", "bn", "txt"], "ofp": ["Ofp", "Ofd", " ofd", "OFP", " ofpa", "ofl", "ofpa", "owld", "ofd", "ofP", "owlP", "owlp", "Ofpa", " ofl", "OFp", "Ofl", "owlpa", "OfP", " ofP", "OFd", "OFl"], "zos": ["tis", "gs", "zb", "LOS", "amia", "ps", "esa", "es", "bs", "zin", "js", "rez", "sbm", "os", "hz", "sis", "psy", "nz", "cz", "python", "south", "zen", "jp", "webkit", "ze", "zer", "sch", "zh", "hess", "oss", "zona", "bes", "zag", "ws", "ossus", "zzle", "eros", "zl", "enos", "init", "los", "ez", "jas", "zu", "rose", "std", "zik", "css", "za", "zers", "settings", "zon", "rss", "z", "osi", "socket", "zo", "cos", "zi", "zes", "zip", "zy"], "osw": ["aospace", "sysW", "osd", "aosw", "cosew", "issw", "osrw", "iswx", "osswx", " osws", "osiw", "ossW", "sysrw", "owa", "aosrw", "oswa", "aosew", "osws", "aosws", "aosW", " ossw", "aoswd", "ow", " osW", "oW", "isW", " oswx", "osiwa", "ossw", "osW", "cosws", "osssw", "aoswa", "isw", "osswd", "syswd", "opace", "ospace", "oswd", "sysw", "osiW", "cosw", " osew", "oswx", "osipace", "cosd", "osew", " osd", "aosd", "ossrw"], "bw": [" bws", "obz", "bbem", "besw", "bsw", "pbew", "abew", " bwl", "bend", "wbz", "bew", "obwl", "sbw", "bws", "bbz", "wbwp", "obwk", "bewl", " bx", "bwb", "wbx", "sbwb", " bwk", "obwb", "bwl", "wbend", "pbwe", "obwt", "pbwt", "pbwy", "pbz", "nbew", "bbwp", "bbwt", "bwk", "bbend", "bbex", "rbws", "nbw", "pbwb", "abwe", "rbw", "bbx", " bex", "nbwy", "bz", "bewk", "wbw", " bem", "pbw", "sbz", "nbwe", "bx", "rbz", "bex", "bem", "bwt", "bbw", " bend", "bwy", "wbwt", "wbem", " bsw", "obsw", "bwe", "abw", "rbex", "sbwt", "bbws", "bwp", " bwp", " bwt", "abwy", "obw", " bz"], "zot": ["zeronet", "Zote", "zipiot", "zoonet", " ziat", "zote", "ziat", "zeror", "zerot", "zerhot", " zonet", " ziot", " zhot", "Zit", "Zot", "zipiat", " zo", "zerote", "zoo", " zote", "zerit", "zor", "zhot", "zonet", "zero", "zoot", "Zott", "zipot", "ziot", "ziphot", "zoor", "zott", "zeriat", " zott", "zeriot", " zor", "zerott", "zo"], "ifp": ["Ifjp", "ifP", "iwr", "ifjp", " ifP", " ifjp", "isth", "ihr", "iwtp", "isp", "Ifp", "iftp", " ifr", " iftp", "isjp", "ifth", "ihtp", " ifth", "ifr", "ihp", "isP", "ifd", "Ifth", "IfP", "iwd", "iwp", "ihd", " ifd"], "zis": [" zIS", " zi", "izisa", "zoiss", "izinit", "zisc", " zic", "zinit", " zisc", "ziss", "zipis", "zeris", "zisa", "ziinit", "ezis", "zerIS", "zoisa", "zoinit", "zipic", "ezi", "zois", " ziss", "izi", "zic", "zipIS", "ziiss", "ezisc", "zIS", "eziss", "ziis", "ziisa", "iziss", "zi", "izisc", "izis", "zeric"], "isr": ["itsr", " isrs", " iscr", "itsstr", "ispr", "issrs", "iosr", "isalstr", "sisrs", "sisr", "isalpr", "isalr", "isrc", "isalsr", "isstr", "iosstr", "iscr", " isrc", "itspr", "sisrc", "isrs", "iospr", "itssr", "siscr", "issr", "iossr", "isscr", "issrc"], "br": ["fr", "bd", "ctr", "vr", "gr", "Br", "sr", "bm", "dr", "bh", "ba", "bi", "shr", "mr", "js", "str", "bf", " Br", "lr", "pr", "b", "bt", "wr", "ber", "obl", "yr", "r", "tr", "hr", "bl", "rb", "ptr", "bro", "bj", "bp", "rel", "cr", "Fr", "BR", "bn", "kr"], "zit": ["ziti", "zeip", "izip", "zist", "ozit", "czot", "oziti", "zop", "ozip", "czunit", "zipit", "ziit", "zipIT", "ziist", "czit", " zop", "cziti", "lexIT", "zip", " zIT", "ezIT", "zlit", "zunit", "zipite", "lexIt", "ziIt", "lexit", "zipist", "czop", "zipIt", " zip", "iziti", "zeit", "czip", "izit", "ziplit", "zeop", "zIt", "zeot", "ezlit", " zlit", "zIT", "ezit", "ziIT", "ozunit", "zite", " zite", "ezite", "izunit", "lexist"]}}
{"id1": "19944975", "id2": "949327", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteConfiguration", "outputContent", "writeConfig", "WriteContent", "writeContent", "WriteSettings", "outputSettings", " writeContent", "WriteConfig", " writeConfig", "writeSettings", " writeSettings", "outputConfig", "outputConfiguration"], "out": ["c", "t", "io", "v", "conn", "help", "over", "this", "OU", "log", "file", "pool", "print", "b", "free", "result", "ent", "at", "client", " OUT", "cmd", "check", "res", "err", "nt", "up", "n", "cast", "p", "pretty", "all", "list", "o", "set", "con", "outs", "w", "ch", "cm", "output", "Out", "group", "report", "null", "to", "table", "msg", "writer", "g", "h", "ou", "aos", "OUT", "outer"], "url": ["dl", "location", "rl", "nl", "mount", "str", "base", "user", "file", "loc", "l", "gl", "uri", "r", "client", "pattern", "cert", "ssl", "path", "mail", "ref", "sl", "address", "name", "bel", "f", "http", "service", "net", "ll", "link", "domain", "rel", "abs", "URL", "char", "ret", "resource", "Url", "rect", "key"], "in": ["io", "reader", "bin", "read", "din", " din", "str", "user", "isin", "rin", "ind", "el", "file", "en", "inner", "l", "serv", "inside", "body", "source", "mc", "r", "none", "is", "input", "al", "up", "In", "on", "gin", "f", "ma", "IN", "con", "it", "sample", "st", "sum", "from", "ins", "null", "inn", "m", "cin", "i", "sin", "and"]}}
{"id1": "12078471", "id2": "8024375", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryLoadUR", "tryReadUrl", " tryloadUrl", "tryLoadUrl", "tryloadURL", " tryloadUR", "tryloadUR", "tryOpenURL", "tryReadUR", "tryloadUrl", "tryReadURL", " tryLoadUR", "tryOpenUR", " tryLoadString", "tryloadString", "tryOpenUrl", " tryloadString", "tryOpenString", " tryLoadUrl", " tryloadURL", "tryLoadString", "tryReadString"], "url": ["dl", "location", "build", "ul", "k", "host", "nl", "html", "log", "file", "loc", "print", "l", "web", "uri", "https", "string", "q", "r", "out", "pattern", "ssl", "path", "ls", "job", "ref", "sl", "address", "un", "ur", "pl", "http", "ll", "link", "abs", "sql", "URL", "Url", "key"], "format": ["version", "parse", "unit", "mat", "type", "status", "printf", "ats", "html", "mt", "Format", "file", "with", "print", "join", "MAT", "sort", "at", "transform", "pattern", "feat", "edit", "index", "att", "spec", "term", "accept", "layout", "f", "use", "list", "set", "template", "cat", "output", "fc", "settings", "struct", "act", "config", "function", "filter", "mode", "style", "form", "and"], "c": ["ct", "cl", "xc", "v", "enc", "ac", "sc", "cont", "etc", "ca", "u", "ce", "dc", "l", "b", "cs", "mc", "cp", "cc", "r", "cb", "cu", "rc", "conv", "a", "ec", "co", "p", "f", "cur", "con", "cm", "ch", "fc", "anc", "com", "m", "ctrl", "cin", "cr", "g", "C", "i", "nc", "call", "cf", "lc"], "data": ["content", "text", "buffer", "serial", "DATA", "html", "base", "space", "ata", "raw", "batch", "image", "dump", "hex", "body", "string", "input", "no", "cache", "name", "dat", "accept", "d", "feed", "description", "json", "info", "value", "row", "sample", "sequence", "response", "message", "output", "area", "bytes", "window", "source", "key"], "model": ["save", "object", "manager", "bm", "instance", "re", "view", "human", "sm", "tree", "server", "controller", "el", "log", "batch", "mod", "relation", "result", "im", "form", "Model", "transform", "impl", "mb", "gp", "dm", "job", "de", "obj", "map", "command", "me", "models", "frame", "rm", "template", "module", "proxy", "value", "ll", "sample", "response", "message", "sim", "report", "m", "table", "xml", "mm", "db", "set"]}}
{"id1": "1180878", "id2": "13891080", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchURLdata", "fetchStringStream", "fectURLdata", "fetchGETFrame", "fectUrlData", "fetchUrlFrame", "fectURLData", "fetchStringdata", "fetchStringFrame", "fetchGETStream", "fetchGETData", "fetchURLFrame", "fectURLStream", "fetchGETdata", "fectURLFrame", "fectUrlFrame", "fectUrlStream", "fetchUrlData", "fetchURLStream", "fectUrldata", "fetchUrldata", "fetchStringData", "fetchUrlStream"], "url": ["dl", "cl", "location", "ul", "default", "host", "nl", "mount", "html", "base", "full", "log", "file", "el", "loc", "print", "l", "b", "gl", "web", "uri", "https", "string", "pattern", "ssl", "path", "ls", "mail", "ref", "sl", "address", "name", "ur", "pl", "http", "ll", "link", "rel", "domain", "sql", "URL", "null", "lim", "xml", "resource", "Url"], "proxyHost": ["proxyUrl", "serverName", "slaveOver", "serverPort", "roxyLabel", "slaveCheck", "slaveAddress", " proxyName", "roxyAddress", "ProxyName", "Proxyhost", "ProxyHost", "roxyhost", "roxyOver", " proxyhost", "ProxyLabel", "serverHost", "ProxyUrl", " proxyAddress", "proxyOver", " proxyOver", "proxyCheck", "serverhost", "slaveUrl", "slavehost", "proxyLabel", "roxyUrl", " proxyCheck", "slaveHost", "ProxyPort", "proxyAddress", "slaveLabel", "roxyCheck", "proxyhost", "proxyName", "roxyHost"], "proxyPort": ["serverport", " proxyPORT", "aliasHost", " proxyport", "proxyport", "serverPort", "ProxyHost", "aliasport", "serverHost", " proxyAddress", "ProxyPORT", "serverPORT", "aliasPort", "serverAddress", "ProxyPort", "proxyAddress", "proxyPORT", "Proxyport", "aliasAddress"], "con": ["c", "xc", "trans", "close", "can", "ocon", "conn", "cone", "cont", "ver", "cal", "Con", "connection", "po", "Conn", "fac", "col", "pen", "en", "go", "func", "sub", "pan", "const", "cs", "bc", "ln", "comm", "cf", "ain", "mc", "cp", "cc", "client", "proc", "cmd", "cgi", "mo", "cons", "CON", "cond", "open", "don", "conv", "cover", "un", "ran", "co", "non", "conf", "cur", "cn", "gate", "pc", "bo", "cat", "fin", "fc", "lock", "dial", "canon", "rec", "syn", "ex", "act", "ctrl", "cos", "call", "com", "nc", "connect"], "is": ["ip", "ains", "ps", "ists", "dis", "iris", "in", "es", "bs", "os", "sis", "isin", "isc", "bis", "isi", "eps", "has", "gets", "cs", "isp", "was", "isf", "im", "bits", "iter", "ist", "sys", "xs", "as", "oss", "iso", "lis", "ys", "ois", "its", "IS", "si", "ris", "init", "are", "fs", "ims", "ais", "rs", "isa", "mis", "iss", "ios", "abs", "isl", "ins", "us", "i", "Is", "s", "ri", "ts", "ms"], "u": ["c", "fu", "uv", "ul", "nu", "eu", "uid", "user", "ui", "ud", "iu", "ut", "su", "uri", " nu", "hu", "uni", "uf", "ue", "cu", "uu", "up", "un", "ur", "o", "pu", "uj", "tu", "au", "U", "yu", "lu", "us", "mu", "i", "ru", "bu", "ou", "g"], "proxy": ["version", "ip", "embed", "echo", "pse", "translation", "cone", "host", "pipe", "po", "connection", "base", "server", "PRO", "py", "prime", "xy", "go", "pool", "jp", "friend", "phone", "web", "roxy", "https", "cp", "client", "Proxy", "profile", "browser", "x", "pointer", "pin", "gp", "library", "ssl", "cache", " proxies", "cas", "alias", "policy", "pi", "address", "map", " prox", "password", "shadow", "project", "pe", "aco", "token", "http", "timeout", "slave", "XY", "ping", "link", "pre", "bo", "domain", "via", "null", "pro", "socket", "port", "zip"], "baos": ["baOS", "BAoss", " baows", "baOs", "vaOS", "BAose", " baOs", "poo", "poos", " baose", "naos", " baoS", "baose", " baoss", "baoss", "vaos", "bais", "BAows", "aoOS", "vaoS", "naows", "aois", " baOS", "poOs", " bais", "aoos", "baows", "nao", "naoss", "BAo", "aooS", "BAos", "bao", "baoS", " bao", "vais", "poose", "BAOs"]}}
{"id1": "8132219", "id2": "5035872", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", "copyFiles", "copyfile", "CopyStream", " copyfile", " copyStream", " CopyStream", " Copyfile", "CopyFiles", "CopyFile", "copyStream", " CopyFiles", " copyFiles", "Copyfile"], "inFile": [" inPath", "ninTemplate", "inputName", " inRow", "dinFile", "inName", "dinPath", "innRow", "ninFilename", "inTemplate", "inPath", "outTemplate", "innFile", "outFilename", "inEmail", "inputTemplate", "innPath", "ninFile", "innEmail", "dinEmail", "inputFile", "inRow", " inEmail", "inFilename", "dinRow", "outName", "ninName", "inputFilename"], "outFile": ["ouFILE", "destFormat", "outFILE", " outFormat", "ouTable", "outFilename", "destFILE", " outfile", "outFormat", "outputfile", "outputTable", "outputFILE", "destfile", "outfile", "ouFilename", "outputFile", "outputFilename", "outTable", "inFILE", "inTable", " outFILE", "destFile", "outputFormat", "inFilename", "ouFile"], "in": ["bin", "din", " din", "id", "inc", "isin", "rin", "ind", "el", "en", "inner", "ze", "inf", "ain", "source", "is", "input", "irm", "up", "In", "old", "on", "gin", "init", "info", "ini", "IN", "o", "it", " input", "ir", "from", "ins", "inn", "cin", "ai", "i", "s", "ic", "sin"], "out": ["c", "t", "io", "v", "can", "ne", "by", "os", "file", "en", "b", "e", "at", "ot", "gt", "client", "res", "name", "n", "p", "co", "all", "o", "net", "one", "w", "outs", "it", "Out", "output", "ex", "to", "g", "ou", "aos", "OUT"], "inChannel": ["cinColumn", "sinCase", "cinHandler", "newPanel", "ginPanel", "inButton", "inChan", "cinChannel", "newCase", "isinCase", "sinSlot", "innChannel", "inComponent", "outColumn", "isinChannel", " inHandler", "innerChannel", "outchannel", "outBlock", "inBlock", "innSlot", " inchannel", "innerConnection", "ginCategory", "innerchannel", "inSlot", " inChan", "cinButton", "outStream", "isinSlot", "newCategory", "ginChannel", "sinChannel", "sinBlock", "inchannel", "inStream", " inConnection", "isinCategory", "vinPanel", " inButton", "inCase", "vinCategory", "innCategory", "insideButton", "inHandler", "vinChannel", "inConnection", "innerChan", " inComponent", "cinBlock", "insideHandler", "insideComponent", "inPanel", "sinStream", "cinComponent", "outChan", "sinCategory", "inColumn", "vinCase", "insideChannel", "inCategory", "newChannel", "innCase", "ginCase", "cinStream", "sinColumn", "outConnection"], "outChannel": ["outClient", "inChan", "oChan", "outputCh", " outChain", " outPassword", "inPassword", "exChain", "outchannel", "outBlock", "exBlock", "OutChan", "OutChannel", " outClient", "nChannel", "outStream", "oPassword", "inchannel", "inStream", "inClient", " outChan", "outputChan", "nStream", "nChan", "outCh", "exChan", "outputConnection", "outputChannel", "nchannel", "oChannel", " outBlock", "outChan", " outchannel", "OutCh", "OutConnection", "oClient", "outChain", "exChannel", " outStream", " outConnection", " outCh", "outConnection", "outPassword"]}}
{"id1": "17724879", "id2": "4056444", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 1, "substitutes": {"getDigest": ["getDigse", "getDigEST", "getMDest", " getMDested", "getMDEST", " getDigested", "getHashest", "getHashEST", "getdigEST", " getDigse", "getHashse", "getdigested", " getMDse", " getDigEST", "getMDested", "getDigested", "getdigse", "getMDse", " getMDEST", "getdigest", " getMDest", "getHashested"], "attribute": ["object", "request", "type", "member", "each", "operation", "data", "space", "document", "relation", "add", "expression", "at", "ident", "missing", "definition", "operator", "input", "item", "reference", "ribute", "Attribute", "application", "att", "policy", "address", "al", "name", "metadata", "variable", "a", "position", "command", "password", "communication", "description", "property", "pair", "qualified", "element", "character", "value", "directory", "option", "event", "message", "subject", "report", "entry", "argument", "information", "article", "associated", "attr", "management", "word", "and"], "digestAlgorithm": ["digestALgorithm", "digestsalgo", "digestPalgo", "digestAlgorith", "digestalgebra", "digestSchegebra", "digestsAlgorithm", "digestsalgebra", "digesterAlgorithm", "digestALgorith", "digestAlgebra", "digesteralgebra", "digesteralgo", "digestSchegorithm", "digesteralgorithm", "digestALgebra", "digestPalgorith", "digesteralgorith", "digestALgo", "digestalgorithm", "digestsalgorithm", "digestalgorith", "digestAlgo", "digesterAlgebra", "digesterAlgorith", "digestPalgorithm", "digestsAlgo", "digestalgo", "digestSchego", "digestsAlgebra", "digesterAlgo", "digestPalgebra"], "digest": ["digests", "digse", "digitude", " digEST", "mdest", "Digests", "hashest", "designests", " digse", "digtest", "mditude", "designest", "mdse", "Digtest", "equend", " digested", " digests", "hashEST", "diagnitude", "diagnest", "digEST", "digested", "designist", "DigEST", "hashend", "Digist", "digend", "equEST", "diagnse", "diagnested", "equest", "designEST", " digtest", " digist", "Digest", "equested", " digitude", "digist", "mdtest", "hashested", "Digested", "Digend", "mdested", "Digse"], "md": ["pm", "bd", "MD", "ct", "managed", "dh", "pdf", "det", "cd", "rpm", "wd", "dr", "sd", "sm", "js", "ud", "mt", "ind", "mod", "esm", "pt", "dd", "hd", "mc", "cmd", "ds", "df", "mk", "mb", "nd", "dm", "amd", "mac", "cond", "pd", "mind", "nt", "metadata", "grad", "fd", "d", "ma", "der", "di", "ld", "rm", "strong", "mn", "met", "m", "red", "mm", "good", "mg", "ms"]}}
{"id1": "9319440", "id2": "21608109", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"load": ["save", "create", "read", "build", "view", "upload", "file", "download", "Load", "dump", "loader", "update", "loading", "install", "library", "open", "get", "init", "loads", "LOAD", "link", "process", "show", "call", "store"], "id": ["ip", "rid", "t", "mid", "pid", "create", "k", "uid", "data", "md", "image", "l", "hex", "uri", "ident", "sid", "aid", "hash", "path", "edit", "no", "job", "ids", "ref", "title", "name", "ID", "token", "description", "info", "json", "tag", "one", "event", "it", "link", "oid", "code", "h", "i", "kid", "ad", "db", "key", "Id", "and"], "xml": ["parse", "img", "t", "ml", "text", "content", "pdf", "px", "tree", "html", "md", "csv", "file", "log", "batch", "sv", "document", "om", "print", "image", "zip", "xf", "body", "im", "string", "x", "ql", "mail", "name", "format", "n", "export", "chart", "http", "tml", "json", "template", "php", "response", "context", "output", "message", "sql", " XML", "sheet", "tx", "report", "pp", "m", "css", "doc", "model", "s", "msg", "cloud", "txt"], "url": ["lb", "dl", "cl", "build", "ul", "rl", "re", "nl", "mount", "connection", "base", "loc", "l", "b", "comm", "gl", "loader", "q", "r", "client", "cmd", "ssl", "cert", "mb", "res", "open", "dll", "ref", "sl", "att", "bel", "ur", "handle", "f", "http", "service", "con", "hl", "ll", "link", "rel", "ret", "URL", "git", "socket", "addr", "resource", "Url"], "conn": ["ctx", "connection", "Conn", " con", " res", "client", "cb", "res", "open", " net", "obj", "ws", "nt", "n", " cur", " err", "http", "con", "Connection", "w", "ch", " cs", "j", " connection", "socket", "Url", "txt"], "reader": ["io", "read", "buffer", "worker", "dr", "in", "rl", "stream", "rx", "rot", "connection", "file", "inner", "loader", "Reader", "ro", "iter", "parser", "r", "ner", "client", "rer", "input", "rar", "nt", "rc", "er", "wrapper", "http", "cur", "row", "roller", "reading", "reads", "context", "runner", "handler", "writer", "resource", "ser", "ri", "iterator"], "str": ["qs", "text", "t", "fr", "gr", "ev", "Str", "arr", "cont", "part", "data", "print", "inner", "cs", "next", "pt", "bc", "e", "hex", "comm", "iter", "string", "del", "r", "line", "ls", "tr", "err", "obj", "chain", "bl", "name", "n", "exec", "exp", "p", "STR", "it", "w", "block", "st", "j", "char", "entry", "syn", "m", "z", "msg", "cr", "sp", "s", "source", "set", "txt"]}}
{"id1": "22875895", "id2": "8430178", "code1": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readVersion": ["loadversion", "parseVersion", "parseversion", "parseVERSION", "parseVersions", "loadVersions", "readVersions", "loadVERSION", "getVERSION", "readversion", "loadVersion", "getversion", "getVersion", "readVERSION", "getVersions"], "url": ["dl", "location", "v", "org", "bb", "ul", "rl", "ver", "re", "nl", "mount", "str", "base", "user", "server", "el", "file", "lr", "l", "loader", "gl", "result", "uri", "web", "r", "client", "ssl", "browser", "path", "ls", "util", "mail", "ref", "sl", "address", "name", "arch", "get", "f", "github", "http", "service", "channel", "ll", "link", "rel", "URL", "char", "entry", "resource", "xml", "Url", "system"], "reader": ["linger", "peer", "taker", "io", "read", "buffer", "worker", "dr", "range", "rl", "mr", "stream", "book", "length", "auto", "controller", "layer", "liner", "lr", "ipper", "download", "inner", "author", "timer", "loader", "Reader", "dd", "older", "iter", "parser", "creator", "r", "ner", "driver", "player", "upper", "rar", "er", "builder", "handle", "maker", "redo", "load", "row", "control", "event", "reading", "lock", "bo", "roller", "runner", "field", "holder", "handler", "rr", "resource", "writer", "consumer", "source", "iterator"], "line": ["level", "text", "le", "detail", "lin", "inline", "range", "se", "point", "nl", "stream", "str", "part", "col", "column", "comment", "log", "LINE", "liner", "print", "l", "phrase", "next", "ln", "trace", "e", "cell", "word", "Line", "string", "lo", "eline", "iter", "normal", "cmd", "out", "cli", "queue", "item", "job", "err", "rule", "linux", "chain", "ine", "n", "note", "ve", "len", "frame", "channel", "list", "row", "one", "record", "link", "lines", "sequence", "block", "message", "sample", "char", "display", "tab", "entry", "cat", "label", "style", "code", "msg", "port", "error"], "version": ["license", "usage", "v", "type", "status", "ver", "volume", "release", "server", "index", "time", "title", "environment", "name", "format", "Version", "date", "feature", "description", "number", "value", "tag", "VERSION", "resource", "current", "source", "summary"], "revision": ["reision", "intervision", "revruction", "prevision", "interision", "interruction", "revvision", "reruction", "preision", "revious", "previous", "preruction", "intervious", "revvious"], "sSec": ["sDec", "lSecond", "tsec", "tDec", "lsec", "lsSEC", " ssec", "sSEC", "lssec", "lDec", "lsSec", "ssec", "lsDec", "nSEC", "sSecond", "tSEC", "tSec", "nsec", " sSecond", "lSEC", " sSEC", "nSec", "nSecond"], "lSec": ["dlSEC", "dlMs", "Lsec", "LSec", "lsec", "sMs", "LDec", "lsSEC", " lDec", "nDec", " lsec", "dlSec", " lSEC", "sSEC", "lssec", "LSEC", "dlsec", "lDec", "lsSec", "ssec", "nSEC", "nsec", "lSEC", "lMs", "nSec", "lsMs"], "compileDate": ["composeDate", "Compiledate", "compilationate", "compilationdate", "CompileDay", "composeate", "compileDay", "composeDay", "CompileDate", "Compileate", "compilationDay", "compiledDate", "compiledate", "compileddate", "Compileddate", "composedate", "compileate", "CompiledDay", "compilationDate", "CompiledDate", "compiledDay"]}}
{"id1": "13757855", "id2": "149935", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["parse", "save", "create", "replace", "write", "build", "run", "processing", "add", "render", "transform", "proc", "Process", "step", "format", "loop", "handle", "project", "processor", "execute", "load", "apply", "display", "call", "task", "filter"], "tpl": ["tpg", "otbl", "tplates", "ttopl", "ptbl", "tspr", "itplate", "teruple", "otld", "atpl", "tld", "terld", " turtle", "tembl", "stpg", "atuple", "tmplate", "terpl", "itbl", "ptpl", "turtle", "Tplates", "ttph", "tuple", "tpp", "timplug", "tspl", "Tld", "tbl", "itPL", "Tbl", "otplate", "tmplates", "tsbl", "tplug", "ptld", "typl", "atplate", "stplate", " tplates", "tmPL", "tmpp", "Tph", "tpr", "Tplate", "stbl", "stpl", "ttplug", "terplate", "topl", " tplate", "ttpl", "timopl", "timbl", " tuple", "itpl", "otpl", "tph", "tmpl", "stopl", "timplate", "tempr", "stplug", "TPL", "temPL", "timpg", "tsurtle", " tbl", " tPL", "tsPL", "ptplates", "tyPL", "ttbl", "ttPL", "Tpp", "timspl", "tyurtle", "ttpg", "templ", "Tpr", "Tpl", "timpl", "tplate", " tpp", " tld", "tPL", "tmbl", " tph", "stspl", "Tspl", "atld"], "model": ["content", "object", " Model", "ml", "product", "data", "tree", "base", "md", "html", "el", "file", "log", "document", "Document", "Model", " models", "project", "M", "models", "module", "record", "m", "node", "parent"], "packageName": [" packageFamily", "pkgNames", " packageNames", "pkgVersion", "viewClass", "groupFamily", "PackageName", " packageClass", "viewName", "pkgName", "groupName", "packagename", "PackageRoot", " packagename", "packageFamily", " packageVersion", "groupNames", "PackageClass", "pkgFamily", " packageRoot", "groupVersion", "Packagename", "packageRoot", "packageClass", "packageNames", "packageVersion", "viewRoot", "viewname"], "outFileName": [" outfilename", " outTableSize", "outStreamPath", " outFilename", " outfilePath", "outTableName", "outFPath", "outFilenameTime", "outfileChain", "outDirName", "infilePath", "outFName", "outStreamType", "outFilenameChain", "outStreamNames", " outFilenameSize", " outFilenamePath", "inFileTime", "infileType", "inFileType", "outDirPath", " outFileTime", "outFilenameName", "inFileName", "outfilePath", "outTableChain", " outFileSize", "outFNames", "outfileName", " outTablePath", " outFilenamename", "outFileChain", "outfilename", "outTablename", "outImagename", " outfileNames", "outFilenameNames", "outFilenameSize", "outTableType", "outTablePath", "outTableSize", " outFileType", "outTableTime", "outFilenamename", " outTableName", "outStreamName", "infileNames", "outFilenamePath", "outFilenameType", "outFileNames", " outFilenameChain", "outDirTime", "inFileNames", " outFilenameName", " outFilePath", "outfileType", " outTableTime", " outfileName", " outFileNames", "outFname", "inFilePath", " outFilenameType", "infileName", "outFileType", "outStreamTime", "outFilename", "outfileNames", "outFileTime", "outFileSize", "infileTime", "outDirSize", "outImageSize", "outImageName", "outfileTime", " outFileChain", "outImagePath", "outFilePath"], "xsltParam": ["xsltConf", "xsslParam", "xsslParameter", "xsqlConf", "xsltParameter", "xsmlParam", "xltParameter", "xmlParameter", "xsslConf", "xmlConf", "xsmlConf", "xsqlParameter", "xltConf", "xmlParam", "xsqlParam", "xsmlParameter", "xltParam"], "artifact": ["Artifact", " artifacts", "artificial", "anificate", "arifact", "anifacts", "ardifact", "ardificial", "ardificate", "artificate", "partifacts", "ardifacts", "arifacts", "anifact", "artifacts", " artificial", " artificate", "Artifacts", "anificial", "partifact"], "destinationPath": ["termininationJar", "identinationChain", "destensionPath", "destesticAt", "destigationNow", "destociationpath", "desticationPath", "DestinationDir", "termininationTarget", "descinationHost", "generinateJar", "destinatePath", "destinoHost", "destinateLocation", "destinationPart", "DestensionDir", "destensionHost", "estinoPath", "destinantPath", "destigationPath", "destinateHost", "chaininatedDriver", "destinoPath", "destinatedpath", "destinatedForm", "destigationForm", "destinerJar", "desturationJar", "destventionDisk", "destinerPart", "DestinationTemp", "destinateKey", "delinateForm", "destinoKey", "destinationPATH", "destitutionPATH", "destregationPath", "destinatedNow", "destationDir", "chaininationHome", "chaininationPath", "destensionPoint", "estionPoint", "destociationPath", "destinationChain", "destinationForm", "destositoryHost", "identinateKey", "destinateTime", "descositoryParent", "destationLocation", "destinatedHome", "estionPath", "DestensionPoint", "destinatorParent", "destinatedChain", "identinationKey", "destacementPath", "estinationPoint", "destionPATH", "destinationDisk", "chaininatedHome", "destinerPath", "delinationLog", " destociationpath", "destranceForm", "origininatedNow", "identinateChain", "origininationForm", "origininationPath", "desturationpath", "destinationLocation", "destATIONPort", "destATIONParent", "destinatorChain", "destinationDriver", "destinateUrl", "destitutionPath", "origininatedForm", "destociationHome", "DestinationPath", "destATIONHost", "destinoTime", "destinationHost", " destinationpath", "destinationInfo", "destinationSystem", "destinationHome", "termininationPath", " destinationTarget", "destinationName", "destinatorKey", "destinoName", "destitutionpath", "DestinationPod", "destacementName", "estionPATH", "delinationForm", "destinantDir", "destociationLog", "estinationpath", "delinatePath", "destventionDriver", "estinationTime", "chaininatedPath", "destinatorPort", "destinatedDisk", "generinateAt", "destinatedInfo", "generinationSystem", " destociationTarget", "estationPart", "descinationPort", "destinatedPath", "destinatePoints", "destositoryPort", "destinatorPath", "destesticJar", "destacementTime", "descositoryPath", "destificationPath", "delinatePoints", "estinationDir", "destinatorHost", "destinateForm", "destationHost", "estationDir", "identinateInfo", "estinationName", "destinerSystem", "estinationPATH", "termininerpath", "destinateChain", "destinationPort", "desticationDir", "origininatedChain", "destinationLog", "destinateAt", "destinateName", "delinationPath", "destesticSystem", "destinatedTarget", "destinantTemp", "destinoDir", "destigationChain", "desturationTarget", "estinoTime", "destensionPod", "estinationPart", "destinateLog", "DestificationUrl", "destionPath", "destificationLocation", "destinoPoint", "destationPath", "destinatepath", "destificationUrl", "desturationPath", "destinationPod", "destranceLog", "DestensionHost", "DestinationLocation", "destregationpath", "destinerpath", "destrancePath", "destinationJar", "estinationPath", "destrancePoints", "DestinationUrl", "estationPath", "generinationJar", "destinatedDriver", "generinationAt", "destensionTemp", "destventionPath", "descositoryHost", "destinatedKey", "destinationTarget", "destinationUrl", "destinationNow", "destesticPath", "identinationInfo", "destinatorPATH", "origininationNow", "destinateTarget", "DestensionPath", "identinationPath", "destinateDir", "delinationPoints", "destociationPoints", "estinoName", "destionPoint", "destinationTime", "destensionDir", "DestensionPod", "destinatePart", "termininerTarget", "desticationPod", "destionpath", "destregationDisk", "chaininationDisk", "termininationpath", "destinationPoint", "destociationDriver", "destregationTarget", "DestinationHost", "origininatedPath", "destinatorInfo", "estinationKey", "destinationTemp", "destinationPoints", "destociationForm", "destationUrl", "destinatorPoint", "destinatorpath", "destventionHome", "chaininatedDisk", "chaininationDriver", "descositoryPort", "DestensionTemp", "desticationTemp", "termininerPath", "descinationPath", "DestificationPath", "estionpath", "destationPart", "estinationHost", "destinationAt", "destociationDir", "destinerDir", "destinateJar", "termininerJar", "origininationChain", "destinationDir", " destinationDisk", "destinateNow", "destositoryParent", "descinationParent", "destinantPod", "identinatePath", "generinatePath", "destinationpath", "destociationHost", "destificationDir", "destinationParent", " destociationPath", "destinerAt", "delinateLog", "destociationPoint", "destinerHost", "destociationTarget", " destociationDisk", "destinateInfo", "DestinationPoint", "destitutionPoint", "destATIONPath", "DestificationLocation", "generinateSystem", "DestificationDir", "destinerTarget", "destositoryPath", "estinoKey", "destacementKey", "generinationPath", "destinationKey", "destociationDisk", "destinateSystem", "estationHost"], "in": ["c", "t", "io", "reader", "bin", "din", "id", "file", "l", "inner", "r", "input", " IN", "In", "n", "f", "d", "info", "o", "IN", "w", "ins", "m", "doc", "i"], "out": ["c", "t", "println", "io", "ger", "gr", "dis", "v", "write", "can", "cfg", "conn", "inv", "or", "oe", "nr", "os", "u", "log", "raw", "file", "go", "print", "inner", "l", "b", "ln", "e", "sys", "cmd", "client", "cache", "res", "err", "obj", "screen", "nt", "up", "n", "co", "p", "f", "all", "list", "o", "conf", "net", "gen", "con", "cn", "w", "outs", "it", "Out", "output", "ch", "report", "null", "ex", "ins", "to", "msg", "writer", "s", "ou", "aos", "OUT", "outer"], "root": ["parents", " roots", "println", "ok", "create", "_", "se", "data", "tree", "scope", "id", "dump", "roots", "dir", "r", "child", "impl", "Root", "de", "chain", "name", "Template", "New", "start", "p", "json", "graph", "group", "context", "initial", "m", "config", "node", "parent", "table", "def"]}}
{"id1": "2518655", "id2": "11933797", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"fnOut": ["bfOut", "bfNet", "bfIn", " fnNet", "synOut", "synIn", "pdfOs", "pdfNet", "pdfOut", "fnNet", "dnOutput", "synOr", "fnOr", "dnIn", " fnOs", "fnOutput", " fnOutput", "fnOs", " fnOr", "synOutput", "pdfIn", "fnIn", "bfOs", "dnOut", "dnOr", " fnIn"], "writer": ["written", "println", "widget", "reader", "window", "buffer", "write", "rator", "worker", "close", "commit", "comment", "auto", "external", "file", "print", "inner", "and", "loader", "flush", "console", "parser", "creator", "client", "white", "driver", "operator", "zero", "riter", "writing", "format", "variable", "builder", "width", "maker", "journal", "caster", "send", "her", "wrapper", "writ", "Writer", "wright", "service", "w", "runner", "writers", "report", "walker", "master", "handler", "table", "aster", "fn", "outer", "editor"], "i": ["ip", "c", "li", "y", "v", "bi", "ii", "phi", "multi", "key", "xi", "I", "u", "id", "ui", "ind", "mi", "iu", "ski", "batch", "gu", "ogi", "gi", "uri", "im", "q", "hi", "client", "x", "is", "ki", "ti", "ie", "ci", "pi", "chain", "ij", "me", "qi", "si", "init", "ix", "di", "ma", "ini", "ims", "ei", "it", "sim", "j", "my", "\u0438", "m", "ai", "g", "us", "ic", "ri"], "fInput": [" fIn", "linput", "sfInput", "cfNew", "fOutput", "sfOutput", " finput", "fileIn", "cfinput", "fileinput", "sfIn", "cfInput", "fileOutput", "sfinput", "finput", "lNew", "lInput", "lOutput", "fIn", "cfOutput", "fNew", " fOutput", "fileInput", " fNew"], "in": ["t", "bin", "din", " din", "or", "re", "inc", "isin", "rin", "ind", "en", "inner", "ln", "serv", "inf", "inside", "vin", "out", "r", "client", "is", "pin", "input", "check", "al", "conv", "In", "n", "thin", "gin", "ma", "all", "info", "ini", "IN", "conf", "con", "it", "ins", "inn", "cin", "again", "sin", "kin"]}}
{"id1": "23008590", "id2": "1005108", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    public void googleImageSearch(String search, String start) {\n        try {\n            String u = \"http://images.google.com/images?q=\" + search + start;\n            if (u.contains(\" \")) {\n                u = u.replace(\" \", \"+\");\n            }\n            URL url = new URL(u);\n            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n            httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n            BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n            googleImages.clear();\n            String text = \"\";\n            String lin = \"\";\n            while ((lin = readIn.readLine()) != null) {\n                text += lin;\n            }\n            readIn.close();\n            if (text.contains(\"\\n\")) {\n                text = text.replace(\"\\n\", \"\");\n            }\n            String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n            for (String s : array) {\n                if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                    String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                    googleImages.add(s1);\n                }\n            }\n        } catch (Exception ex4) {\n            MusicBoxView.showErrorDialog(ex4);\n        }\n        MusicBoxView.jButton7.setEnabled(true);\n        ImageIcon icon;\n        try {\n            icon = new ImageIcon(new URL(googleImages.elementAt(MusicBoxView.googleImageLocation)));\n            ImageIcon ico = new ImageIcon(icon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH));\n            MusicBoxView.albumArtLabel.setIcon(ico);\n        } catch (MalformedURLException ex1) {\n            MusicBoxView.showErrorDialog(ex1);\n        }\n    }\n", "label": 0, "substitutes": {"run": ["submit", "unit", " Run", "status", "test", "go", "func", "web", "Run", "render", "running", "work", "thread", "loop", "exec", "start", "un", "execute", "launch", "sample", "block", "runner", "process", "dial", "call", "UN", "background"], "url": ["dl", "location", "ul", "host", "mount", "str", "base", "external", "file", "loc", "lr", "print", "l", "b", "web", "gl", "uri", "https", "il", "r", "browser", "ssl", "path", "ls", "mail", "email", "sl", "address", "ref", "name", "bel", "ur", "p", "pl", "github", "http", "hub", "ll", "hl", "link", "rel", "ret", "URL", "resource", "xml", "Url", "remote", "page"], "is": ["ip", "sb", "ists", "iris", "in", "es", "bs", "os", "sis", "isin", "ui", "isc", "bis", "isi", "ib", "serv", "il", "im", "iter", "sys", "as", "oss", "iso", "ic", "ls", "lis", "its", "IS", "ris", "info", "fs", "ais", "rs", "isa", "iss", "ios", "isl", "ir", "ar", "ins", "us", "i", "Is", "s", "ri", "ms"], "writer": ["written", "window", "write", "worker", "wire", "data", "order", "server", "file", "layer", "liner", "document", "print", "loader", "Reader", "word", "console", "string", "oder", "storage", "ner", "white", "driver", "player", "line", "out", "client", "riter", "writing", "counter", "er", "format", "variable", "builder", "maker", "caster", "processor", "Writer", "network", "wright", "service", "row", "message", "writers", "runner", "output", "entry", "null", "handler", "table", "node", "wrote", "fn", "page", "key", "outer", "editor"], "buffer": ["memory", "binary", "Buffer", "padding", "buff", "base", "column", "length", "comment", "total", "batch", "available", "document", "phrase", "print", "word", "string", "bar", "line", "library", "cache", "command", "variable", "note", "buf", "password", "paste", "frame", "character", "number", "value", "template", "row", "sample", "block", "sequence", "message", "append", "char", "display", "reset", "table", "function", "seed", "window", "source"], "reader": ["io", "read", "dr", "ener", "rl", "mr", "stream", "rx", "rot", "file", "inner", "loader", "Reader", "ro", "iper", "iter", "oder", "parser", "ner", "r", "driver", "rar", "er", "builder", "handle", "per", "her", "row", "runner", "handler", "resource", "ser", "iterator"], "n": ["c", "y", "v", "k", "sn", "nu", "nl", "max", "nr", "ne", "en", "l", "ln", "e", "na", "nn", "out", "r", "an", "no", "nt", "nan", "note", "on", "N", "p", "d", "len", "number", "o", "nb", "num", "yn", "w", "cn", "nor", "j", "syn", "m", "gn", "i", "nc", "ns", "fn", "ren"], "updatePage": ["currentPage", " updateSection", "updateLink", "updateClass", "uploadFile", "UPDATEPoint", "updatepage", "uploadPage", "updatedURL", "UpdateLink", "indexPage", "addPage", " updateLine", "indexPoint", "downloadFile", "downloadPath", "updatedpage", "makeLine", "UpdatePage", "updatedTime", " updateClass", "updateLine", "updatedLink", "updatePath", "downloadPage", "createTime", "currentpage", "updateFile", "updateLog", "updateNow", "updateTime", " updateURL", "downloadLine", "updatedPath", "updateSection", "showPage", "showClass", "makeClass", "indexLog", "updatedLine", "uploadLink", "currentURL", " updateNow", "makeSection", " updatepage", "addLog", " updatePages", "makePage", "updatedPage", "showLine", "uploadPath", "uploadPages", " updateLink", "UPDATELog", "showSection", "updatedFile", "UpdatePages", "updateURL", "createPage", "UPDATEPage", "indexTime", "updatePoint", "downloadNow", "addPoint", "updatePages", "uploadLine", "updatedNow", "downloadLink"], "pos1": ["position1", "pose1", "pos0", "pose81", "position4", "position3", "po1", "position0", "position81", "po3", " pos0", "pos81", "position2", "po2", "Pos3", "pose0", " pos81", "posOne", "poseOne", "Pos4", " posOne", "Pos2", "Pos1", "po4", "positionOne"], "pos2": ["prop6", " pos02", "pro3", "prop4", "prop2", "po3", "prop3", " pos6", "pro2", "pro4", "Pos02", "po2", "po6", "Pos3", "pro02", "pos02", "Pos4", "pos6", "Pos2", "po4"], "pos3": ["position1", "posthirds", "position4", "index03", "pointthirds", "PosIII", "po1", "position3", "index3", "Pos03", "po3", "point3", "point03", "indexIII", "posIII", "pos03", "Posthirds", "position2", "po2", "Pos3", "Pos4", "pointIII", "indexthirds", "Pos2", "Pos1", "po4"], "pos4": ["op4", "posr", " pos24", "opr", "position4", "po1", "po3", "position24", "positionFour", "op24", "posFour", "po2", "Pos3", "pos24", " posFour", "positionr", " posr", "Pos4", "Pos2", "Pos1", "po4", "opFour"], "currentVersion": ["currentPage", "CurrentKey", "CurrentVer", "currentlyPage", " currentPage", "currentKey", "currentlyVer", "currentUpdate", " currentFilter", "recentPage", "updateVer", "recentUpdate", "currentVer", "currentVers", "recentVer", "newVersion", "recentVersion", "newVers", "newPage", " currentUpdate", "updateFilter", "updateKey", "CurrentFilter", "currentlyVers", "currentFilter", " currentVer", " currentKey", "newUpdate", "CurrentVersion", "updateVersion", "currentlyVersion", "newVer", "updateVers"], "downloadURL": ["downloadPDF", "DownloadPDF", "updatePDF", " downloadPDF", " downloadUrl", "DownloadURL", "updateURL", " downloadLink", "updateLink", "DownloadUrl", "downloadUrl", "DownloadLink", "updateUrl", "downloadLink"]}}
{"id1": "300397", "id2": "17557289", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "8046691", "id2": "13657103", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievedFile", "retractLocal", "detrieveLocal", "detrievedLocal", "detrieveFile", "retrieveImage", "retireLocal", "retractFile", "retrievedLink", "detrieveImage", "retrievedLocal", "retrieveLink", "detrievedImage", "retrievedImage", "retractLink", "detrieveLink", "retractImage", "detrievedLink", "retrieveLocal", "detrievedFile", "retireFile", "retireLink", "retireImage"], "url": ["dl", "ml", "location", "build", "rl", "host", "nl", "run", "str", "base", "id", "u", "el", "file", "l", "image", "web", "uri", "string", "arl", "cp", "ssl", "path", "ls", "job", "ref", "sl", "address", "name", "bel", "un", "ur", "get", "f", "pl", "http", "row", "ll", "abs", "URL", "char", "m", "call", "resource", "Url", "remote", "rect"], "link": ["le", "li", "dl", "detail", "relation", "cp", "mail", "loop", "init", "list", "message", "tool", "remote", "system", "def", " lock", "ml", "build", "links", "file", "l", "add", "loader", "sign", "path", "ls", "index", "open", "ink", "get", "ld", "local", "entry", "label", "style", "error", "ment", "type", "write", "status", "lib", "let", "stream", "download", "self", "image", "post", "line", " jump", "check", "pack", "map", "thread", "light", " load", "load", " delay", "info", "network", "query", "block", "Link", "share", "msg", " reload", "db", "key", "set", "page", " relay", " check", "base", " LINK", "log", "go", "mark", "linked", "ssl", "install", "library", "handle", " block", "tag", "lock", "rel", "master", "task"], "httpConn": ["httpCmd", "httpsCon", "socketConn", "appConn", "HTTPConn", "httpConnect", "httpCon", "ttpSyn", "socketconn", "internalconn", "HTTPCons", " httpconn", "internalCon", "httpsConnection", "HttpConnection", "ttpConn", "httpsCons", "hoverConn", "HttpConnect", "realconn", "appConnect", "socketConnect", "httpSyn", "ttpCt", "localConnection", "hoverCon", "httpCons", "ttpCmd", " httpCt", "hoverConnect", "hoverCt", "HttpConn", "realConn", "htmlCt", "httpsConnect", "hoverCons", "internalCt", " httpConnect", "hoverSyn", "htmlConnect", "htmlConn", "HttpCon", "ttpconn", "ttpConnection", " httpCon", "realConnect", " httpCmd", "appconn", "internalConnect", "htmlconn", "internalConn", "ttpCons", "hoverConnection", "ttpCon", "HTTPConnect", "realCt", "socketConnection", "httpconn", "httpCt", "httpsCmd", "ttpConnect", "httpsconn", " httpSyn", "localconn", " httpConnection", "internalConnection", "localCon", "localConn", "httpConnection", "HTTPCon", "appConnection", " httpCons", "httpsConn"], "outs": ["qs", "gs", "nos", "aps", "locks", "ats", "bs", " layouts", "fits", "os", "als", "eps", "gets", "lists", " ops", "ports", "yout", "bits", "ks", "orts", "out", "ds", "plays", "ows", "ls", "uds", "ops", "dates", "aches", "tops", "its", "uts", "ches", "checks", "lets", " outputs", " out", "offs", "uns", "cells", "ims", "sets", "uploads", "ends", "nets", "ios", "obs", "ins", "boxes", "cos", "s", "ts", "ns", "vals", "aos", "ips"], "bins": ["binn", "lins", "blins", "blans", " binn", "bin", "blouts", "bids", "lin", "bobs", " bans", " bids", "hins", "blinn", "houts", "rans", "lids", "linn", "routs", "bans", "wins", "hin", "linos", "wobs", "blkins", "win", "hobs", "wouts", "blinos", "lobs", " bkins", "blids", " binos", "rkins", "louts", "rins", "binos", "bkins"], "bouts": ["bbyout", "fbins", " baints", " baos", "wbout", "fbyout", "bbins", "bbbs", "Bouts", " bonds", " bout", "fbouts", "wbonds", "wbaos", "bout", "Baints", "Baos", "wout", "wins", "obins", "bbouts", "wonds", "wbouts", "obouts", "wouts", "bbs", "waos", "waints", "byout", "baints", "baos", "fbbs", "obbs", "obyout", "Bins", "bonds"], "postData": ["POSTDATA", "PostBody", "PostData", "PostDATA", "postdata", "PostBytes", " postDat", "postDATA", " postDATA", " postBody", "PostQuery", "formDat", "POSTBody", "postBody", " postBytes", "postDat", "POSTQuery", "postQuery", "Postdata", "POSTDat", "POSTdata", "formData", " postQuery", "postsBytes", " postdata", "postBytes", "POSTData", "POSTBytes", "formdata", "postsData", "formDATA", "postsdata", "postsDATA"], "mimePattern": ["mimeTemplate", " muxTemplate", "smimeFormat", "mIMEFormat", "smimePattern", "mimepattern", "metyPattern", "mimeFormat", " mimeTemplate", "muxTemplate", " mimepattern", " muxpattern", "muxPattern", "metypattern", "mimespattern", "mimesFormat", "smetyPattern", "smetyFormat", " muxPattern", "mimesTemplate", "muxpattern", "smetypattern", "mIMEpattern", "metyFormat", "mIMEPattern", "smimepattern", "metyTemplate", "mimesPattern"], "matcher": ["pather", "mather", "mature", "disure", "patch", " matmatch", "stather", "Match", "statcher", "matter", "discher", "matching", "statching", "statter", "matches", " mature", "Matches", "Matching", "matmatch", " mather", "Mature", "dismatch", "Mather", "Matcher", "match", " matches", " matching", " match", "Matter", " matter", "patter", "disches", "Matmatch", "patcher"], "byteBuffer": ["byteVar", "byteMatrix", "noteVar", "Bytebuffer", "noteBuilder", "bytebuffer", " byteMatrix", "byteFFER", "noteBuffer", "wordMatrix", "charBuff", "wordFrame", "letterbuffer", "wordBuffer", "charVar", "ByteFFER", "bFFER", "ByteBuff", " bytebuffer", "ByteBuffer", "byteBuff", "byteFrame", "letterFrame", "bBuff", " byteVar", "byteBuilder", " byteFrame", " byteFFER", "letterMatrix", " byteBuff", "bbuffer", "noteBuff", "charBuffer", " byteBuilder", "charBuilder", "letterBuffer", "bBuffer", "wordbuffer"], "count": ["c", "ctr", "read", "buffer", "acc", "max", "core", "more", "length", "cycle", "total", "comment", "ind", "batch", "add", "continue", "result", "val", "iter", "cc", "child", "index", "cache", "check", "err", "counter", "found", "nt", "n", "loop", "start", "amount", "len", "all", "find", "list", "conf", "number", "first", "depth", "num", "force", "size", "ch", "cap", "sum", "char", "Count", "call", "code", "ount", "last", "C", "cont", "current"]}}
{"id1": "21754659", "id2": "14783950", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getButtonSonico", "getButtonDonida", "getButtonSonida", "getButtonDonido", "getbuttonSonida", "getbuttonSonico", "getbuttonSonilo", "getButtonLeonido", "getbuttonSonido", "getButtonDonico", "getButtonLeonico", "getButtonLeonida", "getButtonDonilo", "getButtonLeonilo", "getButtonSonilo"], "buttonSonido": ["positionSonido", "labelSONphp", "fieldsoningo", "buttonSonano", "buttonHonilo", "buttonSunao", "ButtonSonao", "buttonSONilo", "ButtonSunico", "buttonSonicho", "buttonNorthingo", "buttonsonilo", "buttonSunata", "labelSONido", "buttonJonphp", "buttonDenicho", "buttonSynido", "buttonSunido", "ButtonSunao", "buttonBoningo", "keySonardo", "secondSonicho", "buttonJonida", "fieldSonida", "secondSynido", "buttonNorthano", "labelSonido", "buttonSonao", "keysonilo", "buttonJonidable", "buttonSonata", "secondSynidable", "buttonJonito", "buttonSynicho", "buttonSynphp", "keyson\u00ed", "fieldsonano", "buttonJonao", "fieldSoningo", "ButtonSonico", "buttonSonito", "positionSonito", "buttonJonilo", "buttonsonardo", "buttonBonida", "buttonSunilo", "buttonSonardo", "keySonido", "positionJonico", "buttonsonano", "buttonSONico", "buttonsoningo", "buttonHonardo", "fieldSonido", "buttonBonata", "labelSonida", "buttonBon\u00ed", "buttonDenidable", "buttonBonilo", "ButtonSonata", "labelSONida", "buttonSONida", "buttonSynidable", "buttonSONila", "buttonHon\u00ed", "fieldSonano", "buttonNorthida", "buttonJonicho", "buttonNorthido", "keysonido", "buttonSunito", "buttonsonido", "buttonBonao", "buttonJonico", "secondSynito", "buttonJonido", "buttonSONphp", "buttonsonida", "buttonDenito", "labelSonila", "buttonSonidable", "fieldsonido", "buttonSonilo", "buttonJonata", "ButtonSunata", "keySon\u00ed", "positionJonito", "buttonSonida", "buttonBonido", "buttonSoningo", "buttonSynito", "secondSynicho", "buttonSunico", "buttonSonphp", "labelSonphp", "positionJonilo", "ButtonSunido", "buttonBonano", "keysonardo", "secondSonido", "positionSonico", "buttonSONido", "positionJonido", "buttonBonardo", "buttonJonila", "positionSonilo", "buttonSynida", "labelSONila", "secondSonidable", "buttonDenido", "fieldsonida", "buttonSon\u00ed", "buttonBonico", "buttonHonido", "secondSonito", "buttonSONito", "buttonSonico", "buttonSynila", "keySonilo", "buttonSonila", "ButtonSonido", "buttonson\u00ed"], "e": ["t", "ese", "ae", " ie", "ev", "te", "es", " ate", "AE", " ke", " pe", "ie", "ED", " ge", " ve", "a", "er", "ing", "me", "pe", " fe", "event", "E", "ee", "act", " sent", " who", "ed"], "fc": ["c", "tf", "cv", "FC", "rl", "abc", "WC", "etc", "uc", "bf", "fb", "inc", "fa", "isc", "dc", "bc", "fab", "tc", "mc", "cc", "ic", "icc", "lf", "fm", "gc", "mac", "rc", "conv", "ec", "RFC", "irc", "coll", "soc", "f", "fd", "fs", "fp", "con", "vc", "pc", "fl", "anc", "ifa", "fi", "ctrl", "nc", "fn", "cf", "lc"], "returnVal": ["retValue", "retval", "ReturnVal", " returnValue", "ReturnVAL", "resultVAL", "retVal", "ReturnValue", "Returnval", "resultValue", "resultval", "resultVal", "returnValue", " returnval", " returnVAL", "returnVAL", "returnval", "retVAL"], "file": ["io", "create", "buffer", "type", "fe", "data", "tree", "base", "user", "this", "FILE", "full", "File", "disk", "document", "image", "dir", "uri", "ile", "single", "input", "path", "time", "spec", "name", "format", "handle", "url", "get", "f", "http", "info", "channel", "template", "fp", "local", "link", "block", "output", "message", "valid", "files", "null", "stat", "show", "to", "table", "resource", "page", "parent", "word", "source", "form"], "rutaGlobal": ["RutoLocal", "rutanGlobal", "rutaglobal", "redutaGeneral", "RutoGlobal", "rutoStatic", "redutaLocal", "RutaGlobal", "RutoRemote", "redutaDefault", "rutenGlobal", "Rutaglobal", "RutaLocal", "rutiDefault", "rutaStatic", "rutiFile", "rontoLocal", "rutoLocal", "rutoRemote", "rutoglobal", "rutiRemote", "rutiStatic", "rutoGlobal", "rutenRemote", "rutaRemote", "rutenStatic", "redutanDefault", "RutaRemote", "rutiglobal", "rutanLocal", "rutaGeneral", "rutoFile", "RutoFile", "redutaGlobal", "rutenglobal", "redutanGeneral", "rontoGlobal", "rutiGlobal", "rontoDefault", "rutanDefault", "rutenLocal", "RutoStatic", "rutiGeneral", "rutanGeneral", "redutanLocal", "rontoGeneral", "rutaLocal", "redutanGlobal", "RutaFile", "rutenFile", "rutaFile", "rutaDefault", "rutiLocal", "Rutoglobal", "RutaStatic"], "rutaRelativa": ["rutaRELativa", "rutaRELATiva", "rutaRelantiv", "rutaRelATivo", "rutaRELATiv", "rutaRelativ", "rutaRELitiva", "rutaRelantiva", "rutaRELitivo", "rutaRelitiv", "rutaRelatiiva", "rutaRelatiivo", "rutaRelativo", "rutaRELATivas", "rutaRelATiv", "rutaRelantivo", "rutaRelatiiv", "rutaRELATivo", "rutaRELitivas", "rutaRelantivas", "rutaRelitivas", "rutaRelATiva", "rutaRELitiv", "rutaRelitivo", "rutaRELativo", "rutaRelativas", "rutaRelATivas", "rutaRELativ", "rutaRelitiva", "rutaRelatiivas", "rutaRELativas"], "fis": ["flis", "dfois", "vois", "dfis", "dfiss", "fiss", " fais", "ros", "df\u00eds", "dfisa", "viss", "dfais", "lfisa", " fois", " fiss", "fois", "lfiss", "flys", "fais", "flisc", "f\u00eds", " fisa", "ris", "flos", "fisa", "fys", "lf\u00eds", " fisc", "vis", " fys", "rys", " f\u00eds", "vais", "risc", "fisc", "lfis"], "fos": ["ioses", "woes", "foes", "mos", "mops", "wios", "fows", "fops", "woses", "fios", "iios", "hos", "fdoss", "woss", " foss", "fdaos", "foss", "hios", "vos", "faos", "vows", " fops", "vops", "fdos", "foses", "moes", "mows", "fdoes", "hoss", "waos", "ios", " faos", " fows", "ioss", "voes", " foes", "hoses", "wos"], "canalFuente": ["canallfucer", "canalFuestro", "canallFuper", "canalfuelia", "canallFuente", "canalFUent", "canelFaelia", "canelFuante", "canalfumelon", "canalFaent", "canalFaante", "canalFaestro", "canalPotper", "canallFuent", "canalFuencia", "canalfuestro", "canelFaent", "canallFuencia", "canalFient", "canalFaelia", "canelFuent", "canallFuestro", "canallfumelon", "canalFraencia", "canallfuestro", "canalFramelon", "canalFUelia", "canelFaente", "canalFucer", "canalfuente", "canelFuelia", "canalFuante", "canallfuent", "canalFiente", "canalFaente", "canalFuper", "canalPotmelon", "canallfuper", "canelFuente", "canalFuelia", "canalFacer", "canalPotente", "canallFucer", "canallfuente", "canalFUente", "canallFumelon", "canalfuencia", "canelFaante", "canalfucer", "canalfuper", "canalfuante", "canalFiestro", "canalFUante", "canalFicer", "canallfuencia", "canalFraper", "canalFuent", "canalfuent", "canalFraente", "canalFumelon", "canalPotencia"], "canalDestino": ["canaldOrigine", "canalNegina", "canalsDestina", "canaldDestina", "canaldOrigination", "canalsDestinian", "canalDescina", "canalDescination", "canalOrigination", "canalNegination", "canalDestine", "canaldestinian", "canalOrigine", "canalNegino", "canalDescine", "canalsdestina", "canalDestinian", "canalsdestination", "canalsDestination", "canaldestination", "canalsdestino", "canalsDestino", "canalDestination", "canaldDestino", "canalOrigino", "canaldestina", "canalOrigina", "canalDescino", "canaldDestination", "canaldOrigina", "canalsdestinian", "canalDestina", "canaldestino", "canalNeginian", "canaldOrigino", "canaldDestine"]}}
{"id1": "6742637", "id2": "11556231", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findEXTensions", "findEXTras", " findExtras", " findEXTions", "findExtions", "findExtras", "findAppension", "findAppras", " findEXTension", "findextension", "findextras", " findEXTensions", " findExtension", "findextensions", "findAppions", " findEXTras", "findEXTions", "findEXTension", "findExtension", "findextions", " findExtions", "findAppensions"], "url": ["parse", "sb", "dl", "cl", "location", "ul", "rl", "host", "nl", "mount", "str", "key", "server", "el", "file", "loc", "lr", "l", "norm", "gl", "loader", "web", "uri", "https", "string", "browser", "ssl", "cert", "path", "ls", "util", "email", "ref", "sl", "address", "mail", "name", "req", "ur", "pl", "http", "val", "row", "hl", "ll", "link", "ch", "rel", "abs", "domain", "URL", "char", "addr", "config", "resource", "xml", "lim", "Url", "filename"], "extensions": ["dimends", " extences", "dimensions", "expends", "expperties", "Extensions", "exances", "expended", "xtended", "expensions", "extperties", "extances", "exends", "expences", "exensions", "xtances", "exended", "extended", "dimances", "appendended", "Extension", "extension", "expension", "xtensions", "appendensions", "Extends", "extences", "Extences", "appendperties", "dimended", " extension", "xtends", "xtperties", "appendends"], "res": ["pres", "vers", "ps", "gr", "ry", "range", "ver", "es", "re", "mr", "rem", "rez", "reg", "rest", "ers", "ber", "rex", "ro", "Res", "sys", "r", "proc", "mer", "cons", "ref", "er", "req", "resolution", "rt", "rs", "ch", "vol", "rel", "ress", "abs", "ins", "reset", "rys", "us", "RES", "ser", "pers", "ms"], "prop": ["np", "priv", "tmp", "pic", "ps", "pid", "kw", "cfg", "pred", "etc", "po", "col", "ext", "pos", "pr", "jp", "add", "pt", "cp", "cmd", "proc", "feat", "att", "term", "op", "exp", "mp", "buf", "p", "pkg", "Prop", "comp", "property", "properties", "val", "bug", "pb", "conf", "rel", "cap", "desc", "rop", "tab", "pro", "plot", "prot", "attr", "key", "def"], "msg": ["gs", "text", "bg", "sg", "med", "cfg", "str", "sm", "md", "nom", "mt", "log", "urg", "print", "mun", "body", "hog", "string", "kg", "cmd", "Msg", "mess", "err", "reason", "og", "notice", "pkg", "Message", "mn", "utt", "desc", "message", "uint", "char", "gov", "gm", "ug", "m", "g", "cmp", "good", "ms", "txt"]}}
{"id1": "12678045", "id2": "18782385", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addQDInfo", "addQDinformation", "addQuestiondInfo", "addQuestionDinfo", "addQdinformation", "addQSInfo", "addQDMInformation", "addQuestionDinformation", "addQuestionDInfo", "addQuestionDInformation", "addQSinformation", "addQdInformation", "addQdInfo", "addQDinfo", "addQdinfo", "addQuestiondInformation", "addQuestiondinformation", "addQSInformation", "addQuestiondinfo", "addQDMInfo", "addQDMinfo", "addQDMinformation", "addQSinfo"], "qdDate": ["qdxTime", "qadNow", "qadDate", "qduDat", "qdDisplay", "qdtDat", "qdoDate", "qadDat", "qdmDate", " qdoDat", " qdodate", "qdtDate", "qdodate", "qdoDat", "qlDate", "questdDo", "qlDat", "questedDo", "qdtdate", "qdmDo", "qadDo", "qdmFile", "requduDat", "qduDisplay", "qdxDate", " qdTime", " qdDat", "qlDo", "qdmTime", "qdxDo", " qdDo", "qdxDat", "qddate", "qldDate", "qdTime", " qdoDate", "requduTime", "qdxdate", " qdoNow", "questdDat", "questedDate", "qlNow", "qedNow", "questdNow", "requdDate", "qdDat", "qedDo", "qdNow", "qldDisplay", "qldTime", " qddate", "qdtNow", "questedDat", "qdsDat", "qduTime", "requdDisplay", "requduDisplay", "questdDate", "questedNow", " qdNow", "qdsDisplay", "qedDat", "qdsTime", "qdsDate", "qdxNow", "requdTime", "qedDate", "qdxFile", "qdDo", "qldDat", "requdDat", "qdoNow", "requduDate", "qduDate"], "qdFile": ["qdsFile", "qdfile", "querydSourceFile", "qdSourceFile", "iqdfile", "qrdByte", "iqdoSourceFile", "qsdTime", "qdmFile", "qdFilename", "qrdFile", "qdsFilename", "querydByte", "qdoFile", "querydTime", "qdsTime", "qmdSourceFile", "iqdSourceFile", "qdmTime", "qmdFile", "qdoSourceFile", " qdfile", "querydFile", "qsdByte", "qrdSourceFile", "querysdByte", "qdsByte", " qdTable", "qdrfile", "qdmSourceFile", "iqdofile", "qdrTable", "querysdFile", "qdsTable", "iqdByte", "qdrFile", "qdTime", "qdmByte", "qdsSourceFile", "qdofile", "iqdFile", "iqdoByte", "iqdoFile", "qsdSourceFile", " qdFilename", "qrdfile", "qmdByte", "qdsfile", "querysdTime", "qdByte", "querysdSourceFile", "qdoByte", "qdrFilename", "qmdfile", "qsdFile", "qdTable"], "_qdFileDate": ["_qdSetNumber", "_qdFileMap", "_qdsfileDate", "_qpFileDate", "_qdFileWrite", "_qdSetDate", "_qpFileFormat", "_qdUnitDate", "_qdDirNumber", "_qdTotalYear", "_qdDirMap", "_qdUnitWrite", "_qdDirFormat", "_qpTotalDate", "_qdUnitFormat", "_qdSetMap", "_qdsfileNumber", "_qdFileFormat", "_qdsFileDate", "_qdTotalDate", "_qpTotalWrite", "_qdsfileMap", "_qdTotalFormat", "_qdsFileMap", "_qdDirWrite", "_qpTotalFormat", "_qdsfileDo", "_qdSetDo", "_qdUnitYear", "_qdfileDo", "_qdTotalWrite", "_qpTotalYear", "_qdfileDate", "_qdFileYear", "_qdfileNumber", "_qdFileDo", "_qdDirDate", "_qpFileYear", "_qdDirDo", "_qdFileNumber", "_qdfileMap", "_qdsFileNumber", "_qpFileWrite", "_qdsFileDo", "_qdDirYear"], "ii": ["jj", "inch", "ori", "li", "ico", "iy", "xi", "Si", " ni", "II", "ind", "mi", "umi", "ski", "ati", "oi", "aa", "gi", "hi", "ami", "ie", "iso", "ti", "ice", "iii", "ani", " iii", "cgi", "ishi", "ci", "oci", "pi", "cu", "ij", "iq", "iat", "co", "ia", "qi", "ni", "iri", "si", "ix", "di", "ini", "ei", "ims", "chi", "yi", "sim", "ta", "fi", "ai", "iona", "zi", "i", "ou", "qq", "aii", "ku"], "info": ["ip", "history", "object", "io", "details", "tip", "type", "instance", "status", "translation", "data", "unknown", "id", "used", "join", "inner", "Info", "inf", "none", "iso", "is", "ti", "item", "index", "time", "check", "fo", "alias", "success", "pi", "name", "INFO", "note", "notice", "f", "http", "init", "conf", "query", "about", "entry", "information", "i", "what", "error", "key", "def", "summary"], "_qdValue": ["_qdvalue", "_qdResult", "_qldResult", "_qDValue", "_dqDValue", "_qDInfo", "_dqdValue", "_qdoResult", "_dqdInfo", "_qldvalue", "_qldInfo", "_qDvalue", "_qdInfo", "_dqdvalue", "_dqDResult", "_dqdResult", "_qdoValue", "_qldValue", "_qdoInfo", "_qdovalue", "_qDResult", "_dqDvalue", "_dqDInfo"], "reader": ["then", "read", "buffer", "worker", "dr", "READ", "rl", "rx", "data", "rot", "lr", "relation", "inner", "loader", "dd", "Reader", "ro", "body", "iter", "parser", "ner", "r", "driver", "library", "upper", "rar", "er", "builder", "handle", "wrapper", "feed", "redo", "row", "reading", "runner", "random", "holder", "handler", "rr", "resource", "writer", "pull", "iterator"], "urlName": ["rowName", "URLname", "UrlPath", "UrlDefault", "urlKey", "URLString", "URLPath", "URLDefault", "strName", " urlDefault", " urlname", "urlString", "lNames", " urlKey", "urlN", "strKey", "urlDefault", "UrlName", "urlNames", "urlname", "urlPath", "UrlNames", "URLNames", "lname", "URLKey", "lName", "URLName", "rowN", "UrlString", "Urlname", " urlNames", "rowname", "rowNames", "UrlN", " urlPath", "strNames", "lN", " urlString", "strname", "UrlKey"], "url": ["location", "rl", "re", "nl", "mount", "str", "host", "user", "lr", "loc", "l", "b", "gl", "uri", "console", "string", "r", "browser", "ssl", "mb", "open", "mail", "ref", "sl", "address", "name", "bel", "ur", "f", "http", "hl", "ll", "link", "rel", "URL", "char", "resource", "Url"], "stream": ["stage", "pod", "buffer", "instance", "in", "stack", "data", "str", "inner", "ream", "poll", "body", "iter", "console", "clean", "REAM", "platform", "input", "sl", "screen", "present", "feed", "network", "sw", "Stream", "channel", "row", "sample", "message", "socket", "resource", "cont", "window", "form", "system", "iterator"], "file": ["fr", "io", "buffer", "in", "range", "run", "data", "tree", "FILE", "File", "document", "loader", "dir", "body", "ile", "r", "input", "open", "format", "handle", "f", "fd", "fs", "fp", "message", "fast", "files", "report", "handler", "table", "db", "writer", "port", "rule", "page", "filename", "header"], "line": ["le", "detail", "column", "trace", "iter", "cmd", "normal", "job", "position", "online", "frame", "row", "lines", "message", "char", "node", "rule", "part", "liner", "LINE", "l", "next", "e", "dd", "cell", "body", "Line", "out", "piece", "section", "side", "record", "link", "entry", "error", "header", "buffer", "lin", "inline", "range", "se", "point", "user", "comment", "raw", "phrase", "ln", "continue", "string", "lo", "ice", "no", "ine", "channel", "query", "sample", "block", "field", "sql", "page", "level", "ip", "log", "print", "eline", "queue", "chain", "note", "handle", "one", "sequence", "store", "code", "port", "word"], "_qdDate": ["_qdxTotal", "_qdtDat", "_iqdValue", "_qlValue", "_qdoTotal", "_qdxGeneral", "_qudtDat", "_iqtDate", "_qdsPort", "_qdTotal", "_qudPort", "_iqdTime", "_qdtDate", "_qudtPort", "_kdxFile", "_qdsValue", "_qdDat", "_qudtTime", "_qudTime", "_qlDat", "_qtValue", "_qlTime", "_kdxTotal", "_qdsTime", "_qudDate", "_qdTime", "_qdmDate", "_kdTotal", "_qdoPort", "_qdxFile", "_qtDate", "_iqdDat", "_qtTime", "_qdmGeneral", "_qdFile", "_kdGeneral", "_qdGeneral", "_kdFile", "_qdPort", "_qdmFile", "_qdtTime", "_qdtPort", "_iqdDate", "_iqtTime", "_qdsDat", "_qdoFile", "_qudtDate", "_qdoDat", "_qdoTime", "_kdxGeneral", "_kdxDate", "_iqtValue", "_qudDat", "_qdoDate", "_qtDat", "_qdoGeneral", "_qdsDate", "_qdxDate", "_qlDate", "_qdmTotal", "_kdDate", "_iqtDat"], "pos": ["pres", "nos", "pid", "ps", "px", "min", "top", "or", "max", "point", "part", "po", "pad", "os", "length", "ind", "POS", "loc", "pr", "add", "prefix", "pt", "axis", "snap", "neg", "proc", "index", "no", "zero", "cond", "n", "position", "start", "exp", "p", "present", "len", "apo", "slot", "win", "pat", "o", "conf", "num", "pose", "size", "pc", "sp", "pro", "offset", "yes", "cos", "port", "prot", "i", "Pos", "def"], "projectNum": ["componentNumber", "projectNo", "componentNo", "projectNumber", "ProjectNumber", "componentDir", "modelDir", "modelNum", "componentnum", " projectConn", "Projectnum", " projectnum", "componentNum", "ProjectNum", "projectnum", "componentConn", "projectDir", "projectConn", "modelnum", " projectNumber", " projectNo", "ProjectConn", " projectDir", "modelNo"], "value": ["object", "scale", "VALUE", "unit", "v", "type", "point", "data", "total", "result", "profile", "Value", "distance", "index", "ue", "name", "format", "project", "feature", "description", "property", "val", "number", "field", "values", "port", "key"]}}
{"id1": "19086952", "id2": "15737836", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createUrlView", " createUrlView", "createURLresponse", "createUrlResp", " createURLResponse", " createURLresponse", " createURLResp", "createurlresponse", " createUrlResp", "createurlView", "createurlResponse", "createURLResponse", " createUrlresponse", "createUrlresponse", "createURLView", "createURLResp", "createFileResponse", "createFileView", " createURLView", "createFileResp", "createurlResp", "createFileresponse"], "url": ["dl", "location", "org", "build", "host", "nl", "mount", "str", "base", "html", "el", "file", "loc", "document", "l", "image", "b", "web", "gl", "uri", "string", "parser", "client", "ssl", "cert", "browser", "path", "ls", "job", "email", "mail", "address", "name", "bel", "ur", "get", "pl", "http", "ll", "link", "domain", "sql", "URL", "char", "call", "xml", "Url"], "connection": ["c", "generation", "location", "usage", "close", "window", "ctx", "server", "controller", "remote", "log", "pool", "document", "relation", "computer", "using", "self", "session", "creator", "client", "application", "open", "connected", "database", "reason", "thread", "communication", "command", "position", "builder", "processor", "description", "network", "channel", "number", "directory", "con", "Connection", "intention", "link", "response", "context", "message", "condition", "output", "process", "subject", "entry", "socket", "to", "config", "ion", "handler", "writer", "callback", "nc", "current", "connect"], "fullPath": [" fullpath", "FullPort", "fullUrl", " fullName", " fullUrl", "partialUrl", "fullName", "partialPath", "FullName", "Fullpath", "fullpath", "partialpath", "fullPort", "FullPath", "partialName", "partialPort", " fullPort", "FullUrl"], "conn": ["c", "ct", "ann", "enc", "cfg", "ctx", "cont", "Conn", "col", "reg", "loc", "jp", "comm", "cell", "cp", "cmd", "proc", "oss", "cert", "cb", "res", "connected", "open", "obj", "nt", "conv", "iw", "n", "exec", "resp", "co", "init", "cur", "conf", "con", "Connection", "num", "ch", "desc", "j", "canon", "alloc", "pg", "nc", "ns", "connect"], "in": ["reader", "bin", "din", "or", "stream", "user", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "inf", "inside", "body", "mc", "out", "is", "input", "In", "n", "on", "get", "gin", "ma", "IN", "sql", "sum", "from", "ins", "inn", "m", "cin", "ad", "i", "and"], "length": ["history", "text", "count", "buffer", "type", "ENGTH", "Length", "padding", "enc", "phi", "volume", "data", "total", "left", "l", "result", "string", "HH", "shape", "impl", "distance", "path", "duration", "family", "time", "end", "address", "position", "width", "amount", "loop", "description", "len", "height", "load", "frame", "number", "value", "size", "sequence", "message", "offset", "ength", " Length", "filename", "h", "loss"]}}
{"id1": "8490297", "id2": "13063241", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyDir", "copyFiles", " copyfile", "copyfile", " cpfile", " copyDir", " duplicateFiles", " duplicateDir", " copyFiles", " cpFile", " duplicateFile", " cpDir", " duplicatefile", " cpFiles"], "src": ["lb", "sb", "img", "ctr", "tmp", "sr", "ipl", "sc", "rl", "bs", "sn", "ctx", "rx", "usr", "sit", "dest", "func", "loc", "sq", "nil", "uri", "ck", "sys", "usc", "impl", "input", "ls", "obj", "rc", "spec", "conv", "req", "start", "Source", "url", "pkg", "iv", "comp", "init", "http", "target", "sec", "cur", "rs", "via", "rel", "desc", "st", "from", "obs", "ins", "subject", "stat", "syn", "config", "addr", "msg", "sf", "inst", "resource", "cont", "ser", "source", "filename", "txt"], "dst": ["dth", "Dng", "pust", "dudest", "ddest", "sddest", "dng", "dest", "Dnd", "deust", "dnd", " dnd", "dust", "deth", "dedest", " dng", "sdust", " ddest", "dund", "sdst", "sdth", "Dst", "dung", "pth", "pst", "Ddest", "pdest"], "in": ["read", "din", "min", " din", "inc", "isin", "rin", "ind", "en", "inner", "ze", "ln", "inf", "ain", "inside", "iter", "im", "source", "is", "input", "al", "rc", "up", "In", "on", "gin", "init", "info", "IN", "con", "it", "st", "from", "ir", "ins", "ar", "inn", "cin", "ai", "mm", "i", "ic", "sin", "oin"], "out": ["c", "t", "io", "v", "write", "oe", "by", "ne", "os", "auto", "at", "ot", "gt", "sys", "client", "cache", "res", "obj", "end", "nt", "up", "n", "on", "co", "p", "o", "net", "con", "cn", "outs", "it", "ch", "output", "Out", "sum", "to", "g", "writer", "ou", "aos", "OUT", "outer", "and"], "buf": ["img", "cv", "Buffer", "buffer", "bin", "arr", "data", "fac", "buff", "fb", "Buff", "prop", "log", "batch", "b", "bus", "bc", "vec", "bar", "cmd", "queue", "uf", "cb", "br", "good", "fam", "bl", "rb", "conv", "aka", "bag", "pkg", "seq", "cur", "gen", "cam", "block", "cap", "cat", "tx", "char", "bytes", "tab", "nm", "mu", "msg", "box", "db"], "len": ["compl", "le", "dl", "count", "v", "span", "lon", "lib", "nl", "length", "full", "el", "pos", "en", "l", "wid", "ln", "e", "vec", "del", "lan", "ls", "lf", "no", "elt", "end", "nt", "n", "coll", "seq", "all", "val", "ld", "ll", "fin", "yn", "hl", "lic", "fun", "size", "cap", "cmp", "Len", "ren"]}}
{"id1": "19086952", "id2": "20426057", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createUrlView", " createUrlView", "createURLresponse", "createUrlResp", " createURLResponse", " createURLresponse", " createURLResp", "createurlresponse", " createUrlResp", "createurlView", "createurlResponse", "createURLResponse", " createUrlresponse", "createUrlresponse", "createURLView", "createURLResp", "createFileResponse", "createFileView", " createURLView", "createFileResp", "createurlResp", "createFileresponse"], "url": ["dl", "location", "org", "build", "host", "nl", "mount", "str", "base", "html", "el", "file", "loc", "document", "l", "image", "b", "web", "gl", "uri", "string", "parser", "client", "ssl", "cert", "browser", "path", "ls", "job", "email", "mail", "address", "name", "bel", "ur", "get", "pl", "http", "ll", "link", "domain", "sql", "URL", "char", "call", "xml", "Url"], "connection": ["c", "generation", "location", "usage", "close", "window", "ctx", "server", "controller", "remote", "log", "pool", "document", "relation", "computer", "using", "self", "session", "creator", "client", "application", "open", "connected", "database", "reason", "thread", "communication", "command", "position", "builder", "processor", "description", "network", "channel", "number", "directory", "con", "Connection", "intention", "link", "response", "context", "message", "condition", "output", "process", "subject", "entry", "socket", "to", "config", "ion", "handler", "writer", "callback", "nc", "current", "connect"], "fullPath": [" fullpath", "FullPort", "fullUrl", " fullName", " fullUrl", "partialUrl", "fullName", "partialPath", "FullName", "Fullpath", "fullpath", "partialpath", "fullPort", "FullPath", "partialName", "partialPort", " fullPort", "FullUrl"], "conn": ["c", "ct", "ann", "enc", "cfg", "ctx", "cont", "Conn", "col", "reg", "loc", "jp", "comm", "cell", "cp", "cmd", "proc", "oss", "cert", "cb", "res", "connected", "open", "obj", "nt", "conv", "iw", "n", "exec", "resp", "co", "init", "cur", "conf", "con", "Connection", "num", "ch", "desc", "j", "canon", "alloc", "pg", "nc", "ns", "connect"], "in": ["reader", "bin", "din", "or", "stream", "user", "inc", "isin", "rin", "ind", "file", "mi", "en", "inner", "inf", "inside", "body", "mc", "out", "is", "input", "In", "n", "on", "get", "gin", "ma", "IN", "sql", "sum", "from", "ins", "inn", "m", "cin", "ad", "i", "and"], "length": ["history", "text", "count", "buffer", "type", "ENGTH", "Length", "padding", "enc", "phi", "volume", "data", "total", "left", "l", "result", "string", "HH", "shape", "impl", "distance", "path", "duration", "family", "time", "end", "address", "position", "width", "amount", "loop", "description", "len", "height", "load", "frame", "number", "value", "size", "sequence", "message", "offset", "ength", " Length", "filename", "h", "loss"]}}
{"id1": "7872659", "id2": "14191679", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoindexTable", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndVideoindexfile"], "completePath": ["CompleteLocation", "completePod", "totalPath", " completesDirectory", "COMPLEPath", "pletePath", "pleteScript", " completeDirectory", "completeDirectory", "totalRoot", "CompleteLog", "totalPod", "fullPod", "fullRoot", "CompleteDir", "completeScript", " completeDir", "pletionProject", "completeLog", "pleteLog", "CompleteDirectory", "COMPLEScript", "pletionNow", "CompleteNow", "pletionDir", "fullPath", "completeProject", "CompletePath", "pleteRoot", "pleteNow", "totalLocation", " completesDir", "pletionPath", "fullLocation", "pleteLocation", " completesPath", " completesLocation", "completeDir", "CompleteProject", "COMPLEDir", "completeRoot", "completeNow", "CompleteScript", "COMPLELog", "pletePod", "pleteProject", "completeLocation", " completeLocation", "pleteDir"], "masterFile": ["completefile", "managerFile", "MasterPath", "currentFile", " masterfile", "currentPath", "masterName", "masterfile", "managerfile", "MasterFilename", "masterPath", "masterFilename", "completeFile", "completeName", "Masterfile", "MasterName", " masterFilename", "currentName", "MasterFile", "currentfile", " masterPath", "managerFilename", "managerPath"], "CustRatingFileName": ["CustRankFileName", "CustRankFileInfo", "CustRatingfileType", "CustRatingFilenameType", "CustRankFilesType", "CustRatingFilesType", "CustRatedFileType", "CustRatingFieldName", "CustRatingTableType", "CustRatedfileName", "CustRatingFieldType", "CustRatingFileSet", "CustRatingFilesname", "CustRankFilesName", "CustRatingFieldInfo", "CustRatingFieldname", "CustRatedfileType", "CustRatingFileType", "CustRatingTableSet", "CustRatingFilesInfo", "CustRatedFileNames", "CustRatingTableNames", "CustRatingfileNames", "CustRatingFileInfo", "CustRatedFileName", "CustRatingTablename", "CustRatingFilenameName", "CustRatingFilename", "CustRatingTableName", "CustRatedfileNames", "CustRankFilename", "CustRatingFileNames", "CustRatingTableInfo", "CustRatingfileName", "CustRatingFilenameSet", "CustRatingfileSet", "CustRankFilesInfo", "CustRatingFilenameNames", "CustRatedFileSet", "CustRankFilesname", "CustRatedfileSet", "CustRatingFilesName", "CustRankFileType"], "MovieIndexFileName": ["MovieindexfileType", "MovieindexFileName", "MovieIndexFILEName", "MovieindexFileKey", "MovieIndexfileName", "MovieIndexFieldType", "MovieindexFileNumber", "MovieIndexfileNames", "MovieindexFileNames", "MovieIndexTableType", "MovieIndexFileNames", "MovieIndexfileType", "MovieindexFileType", "MovieIndexFILENumber", "MovieIndexFILENames", "MovieIndexFileKey", "MovieIndexFieldNames", "MovieIndexTableKey", "MovieIndexFieldName", "MovieIndexFILEType", "MovieindexfileKey", "MovieIndexfileKey", "MovieIndexTableNames", "MovieindexfileName", "MovieIndexFieldKey", "MovieIndexfileNumber", "MovieindexfileNames", "MovieIndexTableName", "MovieIndexFileNumber", "MovieindexfileNumber", "MovieIndexFileType"], "inFile": ["localfile", " infile", "outF", " inF", "outFile", "INC", "infile", "localC", " inFILE", "INF", "INFILE", "INfile", "localFile", "outfile", "inFILE", "localFILE", "outC", "INFile", "inF"], "inC": [" inL", " outC", "outF", " inF", "inCL", "outFile", "iCI", " inR", " outF", "intCS", "intR", "inputG", "intCI", " inCI", "outG", "inG", "inL", "iC", " outCL", "iCS", " inG", "inR", " inCS", "intC", "inputC", "inCI", "inputF", "outCL", "inputFile", "outC", " outL", "outL", "iR", " inCL", "inCS", "inF"], "outFile1": ["outPage6", " outfile0", "outputFile1", "outPage2", "outPageOne", "outputFile9", "outfile6", "outChannelOnce", "outputFileOne", "outputPageOne", " outfile6", "outputPage1", " outfile1", "outChannelOne", "outChannel1", "outPage9", "outFile9", "outFILE0", "outFileOnce", "outFILE6", "outputPage9", "outPage0", "outfile0", "outFILE1", "outfile1", "outFileOne", "outfile2", "outputPageOnce", " outfile2", "outFILE2", "outputFileOnce", " outFile6", "outChannel9", "outPageOnce", "outFile6", " outFile0", "outPage1", "outFile0"], "outC1": ["outR1", "outP2", "outc2", "outCB3", "outP3", "inC2", "outPOne", "inFile2", "outC3", "outCOne", "outP1", "outFile3", "inFile1", "outR3", "inC3", "outCB1", "outROne", "outCB2", "inFile3", "outFileOne", "inCOne", "outc3", "inC1", "outCB0", "outc1", "outc0", "outR2", "outC0", "inC0", "inFileOne"], "outFile2": ["exChannel0", "outChannel0", "outfile02", "outTable2", " outFileTwo", "outChannel3", "outTableTwo", "exChannel1", "outChannel1", "exChannel2", "outfileTwo", "outFile3", "outF2", " outFile3", "outF0", "outTable3", "outTable02", "outF1", " outFile02", "outfile0", "outFile02", "outfile1", "exFile1", "outFileTwo", "outfile3", "outfile2", "exFile2", "exFile0", "exFile3", "exChannel3", "outChannel2", "outF3", "outFile0"], "outC2": ["OutR1", "outC4", "outR1", "outM22", "outE1", "outS3", "outB2", "outE4", "outM2", "outSTwo", "allC22", "OutC2", "outC3", "OutC1", "OutR3", "outCTwo", "outR3", "allCTwo", "allB2", "allB3", "outR4", "outE2", "outC22", "outS22", "outBTwo", "outS2", "outB3", "allBTwo", "OutR2", "allB22", "outM3", "outMTwo", "allC3", "outB22", "allC2", "outR2", "OutC4", "outE3", "OutC3", "OutR4"], "fileSize": [" fileSIZE", "baseSize", " fileLength", " fileName", "fileSIZE", "issueName", "byteName", "FileSize", "FileLength", " fileCount", "baseSIZE", "FileName", "fileName", "issueSize", "baseName", "issueLength", "FileSIZE", "FileCount", "fileCount", "byteSIZE", "baseCount", "byteSize", "issueSIZE", "byteLength", "fileLength"], "totalNoDataRows": ["totalNoDataBows", "totalNoDataRecues", "totalNodataRues", "totalNoDataRecoles", "totalNoDataSlocks", "totalNodataRocks", "totalNoDataRocks", "totalNodataRecocks", "totalNoDataRues", "totalNodataRecows", "totalNodataRows", "totalNoDataRecows", "totalNoDataSlues", "totalNodataRecoles", "totalNoDataRoles", "totalNoDataBues", "totalNoDataSlows", "totalNoDataBoles", "totalNoDataBocks", "totalNoDataRecocks", "totalNodataRoles", "totalNoDataSloles", "totalNodataRecues"], "mappedBuffer": ["mattedBB", "mmappingBuff", "mmappedBuffer", "mappingCounter", " mappedBuff", "mappedCallback", "MapperBuffer", "mappingQueue", " mapperBuffer", "matchedBuffer", "MapperBB", " mappedCallback", "MappedBuff", "mapedQueue", "mmappingbuffer", "mressedBuffer", "mapedData", " mappedQueue", "MappedBB", "mappingBuff", "mapedBuffer", "mapperbuffer", "mapedCallback", "matchedBuff", "mressedCallback", "maphCallback", "MapperBuff", " mapperBuff", "mmappedbuffer", " mapedCallback", "mapBB", "mappingbuffer", "mapBuffer", " mapperQueue", " mappedFB", " mapedBuff", "maphFB", "mappingData", "mapedbuffer", "mappedCounter", "mappedFB", "maphBuffer", "mappedQueue", "mapperQueue", "MappedBuffer", "mattedBuffer", "MapedBuffer", "MapedBuff", "mattedBuff", "MappedData", "MapedBB", "mmappedQueue", " mapperCounter", "mattedData", "mapedBuff", "mappedBB", " mapedFB", " mappedCounter", "maphBuff", "mressedBuff", "mapedBB", "matchedCounter", "mapedFB", "matchedQueue", " mapedBuffer", "mappedbuffer", "mappedBuff", "mappingBB", "MapedData", "mmappingBuffer", "mapperCounter", "mapperBuffer", "mapperBB", "mmappingQueue", "mmappedBuff", "mressedFB", "mapBuff", "mappedData", "mappingBuffer", "mapperBuff"], "startIndex": ["endPage", "Startindex", "StartPosition", "StartIndex", "firstindex", "startPoint", "currentPoint", " startindex", "startIter", "startInd", " startPoint", "startPage", " startPage", "currentPos", "StartIter", "StartPos", "firstInd", "startPos", "endPosition", " startPos", " startPosition", "endIter", "StartPoint", "initPosition", "startPosition", "firstIndex", "currentIndex", "initIndex", "initindex", "StartPage", "StartInd", " startIter", "firstPosition", " startInd", "endIndex", "currentPosition", "startindex"], "count": ["c", "ctr", "type", "state", "status", "max", "mount", "order", "core", "more", "length", "id", "total", "ind", "category", "user", "batch", "now", "add", "next", "continue", "result", "limit", "index", "check", "counter", "found", "name", "created", "n", "start", "amount", "cast", "coll", "find", "number", "conf", "list", "depth", "info", "con", "num", "force", "size", "first", "sum", "process", "Count", "act", "call", "code", "ount", "last", "i", "current", "page", "cloud"], "currentMovie": ["primaryMovie", "currentlyMovie", "firstDate", "currentHero", "currentMedia", " currentMouse", "currentImage", "activeVideo", "currentMusic", " currentSpider", "currentMouse", "reportedImage", "reportedMouse", "currentlyMonster", "primaryHero", "presentMovie", "primaryVideo", "activeSpider", "reportedHero", "firstMedia", "firstMouse", "reportedMusic", "firstMonster", "currentlyHero", "currentlySpider", "currentSpider", "currentDate", " currentMusic", "reportedMedia", "currentVideo", " currentMedia", " currentVideo", "firstHero", "presentHero", " currentHero", " currentImage", " currentMonster", "activeMovie", "reportedMovie", "activePlayer", "presentMusic", "currentlyDate", "currentMonster", "presentImage", "firstMovie", " currentPlayer", "currentlyVideo", "firstVideo", "currentPlayer", "currentlyPlayer", "primaryDate"], "movieName": ["mpegNAME", "filmType", "oviename", "httpNAME", "mpegName", " movieType", "MovieType", "monsterNAME", " moviename", "ovieNAME", "moviename", "httpname", "Moviename", "MovieTitle", "movieType", "movieNAME", "ovieName", " movieNAME", "monsterName", "MovieName", "ovieGroup", "movieGroup", "movieTitle", "monstername", "filmName", "mpegGroup", "mpegname", "filmNAME", "filmGroup", "httpName", " movieTitle", "filmTitle", "filmname"], "customer": ["Customity", "Customizer", "customizer", "developer", "developator", " customator", "customator", "developizer", "Customer", "customorder", "ustomorder", "developorder", "developER", "ustomator", "stickizer", "ustomER", "stickity", "stickER", " customorder", " customER", "ustomer", "customER", "CustomER", "sticker", "developity", "customity"], "rating": ["scale", "type", "score", "heading", "translation", "average", "scoring", "core", "user", "attribute", "rage", "card", "playing", "review", "boarding", "credit", "term", "format", "rate", "weight", "option", "setting", "rat", "ping", "reporting", "tag", "rank", "testing", "reading", "having", "strength", "ating", "Rating", "saving", "rated", " Rating", "error", "ranking"], "outBuf1": ["outBuf0", "outBufl", "outBuff3", "outBBuff1", "outBuc0", "outBlf1", "outBulp3", "outBuf64", "outRbuf1", "outBdfOnce", "outBuff0", "outBfx0", "outBbufOne", "outBuffyone", "outBlf0", "outBbuf5", "outBool3", "outDuf0", "outBulp64", "outBdf64", "outRuf0", "outBuf5", "outBulpOnce", "outRuf5", "outBbufOnce", "outBooll", "outBuffy1", "outBool1", "outBuf3", "outBuffyl", "outBuff1", "outBfx1", "outBurg3", "outBbufl", "outBbufone", "outBbuf64", "outBuf18", "outDuf11", "outBBuff0", "outRuf3", "outBurg18", "outRuf18", "outBurg1", "outBbuf11", "outRuf1", "outBlf2", "outBdf3", "outDbuf1", "outBoolone", "outBuffy18", "outDuf3", "outBuc5", "outBufOnce", "outBlf3", "outBdf1", "outBfx11", "outRbuf3", "outBurg0", "outBfx3", "outBbuf3", "outBbuf1", "outDuf1", "outBufOne", "outRbuf5", "outBuffy3", "outRufOne", "outRbuf18", "outBbuf18", "outDbuf3", "outBbuf0", "outBucOne", "outBBuff3", "outBuff2", "outRbufOne", "outBuc1", "outBBuff11", "outDbuf11", "outBulp1", "outBuf11", "outDbuf0", "outBuffy0", "outRbuf0", "outBufone"], "outBuf2": ["outMuf1", "outBfg4", "outBuffyTwo", "outBuff3", "outFbuf4", "outBbuff3", "outFufTwo", "outBuffy4", "outFuf02", "outFbuf02", "outFuf4", "outMbuf2", "outBuffj", "outMbuf15", "outBuffy3", "outFbufTwo", "outBbuf15", "outMbuf3", "outMuf2", "outBbuf2", "outFuf2", "outBbuf42", "outBuffy2", "outBfg2", "outBbuf02", "outBbuffj", "outBuff4", "outBuf3", "outBfx2", "outBbufj", "outBuf42", "outBuf02", "outBuff1", "outFbuf2", "outBuff42", "outBbuf4", "outMbuf1", "outBuff2", "outMuf3", "outBuf15", "outBuf4", "outBbuff42", "outBbuff2", "outBuffTwo", "outBuffy02", "outBfx1", "outMuf15", "outBfx15", "outBufTwo", "outBbuff15", "outBfx3", "outBbufTwo", "outBfgTwo", "outBfg02", "outBbuf3", "outBufj", "outBbuff1", "outBbuf1", "outBbuff4"], "endOfIndexFile": ["endOfIndexTable", "endOfErrorfile", "endOfErrorFiles", " endFile", "endOfIndfile", "endOfindexfile", "endOFindexFile", "endOFindexfile", "endofIndexFile", "endofindexfile", "endOfindexTable", "EndFile", "endofindexFile", "endofindexTable", "endOfindexFiles", "endOFIndexLine", "endOfIndLine", "endOfIndexLine", "endofIndexfile", "endOfIndexF", "endOfindexFile", "endOfPositionFiles", "endOfPositionTable", "endofindexF", "endOfPositionFile", "endofIndexF", "endOfIndFile", "endOFindexLine", "endedFile", "endOfIndexfile", "endOfindexF", "endofIndexTable", "endOFIndexfile", "endOfPositionfile", "endFile", "endOfErrorFile", "endOfIndexFiles", "endofindexFiles", "endofIndexFiles", "endOfindexLine", "endOFIndexFile", "endOfErrorF"]}}
{"id1": "8024375", "id2": "15904772", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomGID", "getRandomUUID", "getRandomSid", "getRandUuid", "getRandUid", "getRandGuid", "getRandomSUID", "getRandomGuid", "getRandomUuid", "getRandomCuid", "getRandUID", "getRandomCid", "getRandomCID", "getRandomUid", "getRandGID", "getRandGUID", "getRandGid", "getRandUUID", "getRandomSID", "getRandomUID", "getRandomGid", "getRandomCUID", "getRandomSuid"], "secure": ["confirmed", "sync", "encrypted", "sr", "stable", "secret", "status", "nice", "active", "server", "prime", "trust", "google", "https", "sys", "client", "ssl", "security", "ie", " Secure", "Secure", " insecure", "clear", "safe", "pretty", "sensitive", "http", "strong", "service", "sec", "force", "protect", "dirty", "weak", "quiet", " securely"], "md5": [" md3", "metadata2", "metadata45", "md6", " md512", "sha2", "digle", "mdle", "MD512", "MD3", "dig4", "md512", "MDle", "md3", " md6", "metadata3", "sha3", "sha512", "MD45", "md45", "metadata5", " md2", " md4", "sha5", "MD4", "MD2", " mdle", " md45", "dig3", "MD5", "sha6", "dig5", "MD6", "md2", "md4"], "sbValueBeforeMD5": ["sbValueBeforeMDson", "sbValueAfterNDson", "sbValueBeforeDS2", "sbValueBeforeMOD5", "sbValueBeforemdson", "sbValueBeforeOLD5", "sbValueAfterMD65", "sbValueBeforeMP2", "sbValueBeforeMTson", "sbValueBeforeAMD5", "sbValueBeforeMS5", "sbValueBeforeMD1", "sbValueBeforemd5", "sbValueBeforeMT4", "sbValueBeforeMD65", "sbValueBeforeSMson", "sbValueBeforeMD3", "sbValueBeforeLM5", "sbValueBeforeMT5", "sbValueAfterMD5", "sbValueWithoutDD512", "sbValueBeforeMP5", "sbValueBeforeSM4", "sbValueBeforeND2", "sbValueBeforeAMDson", "sbValueAfterMD2", "sbValueAfterMD1", "sbValueWithoutMD2", "sbValueBeforeOLD512", "sbValueBeforeAMD2", "sbValueAfterMDLeft", "sbValueBeforemdFound", "sbValueBeforeMD2", "sbValueAfterMD3", "sbValueAfterND2", "sbValueBeforeMACFive", "sbValueBeforeMD512", "sbValueBeforeMAC5", "sbValueBeforeDDFive", "sbValueAfterMDson", "sbValueBeforeDS512", "sbValueBeforeND4", "sbValueBeforeMDFive", "sbValueAfterND5", "sbValueBeforeMPLeft", "sbValueBeforeLM2", "sbValueWithoutDD5", "sbValueAfterMD4", "sbValueBeforeIM1", "sbValueAfterND4", "sbValueBeforeMT2", "sbValueBeforeIMLeft", "sbValueBeforeMDLeft", "sbValueWithoutMD5", "sbValueBeforeMOD2", "sbValueBeforeMS3", "sbValueBeforeOLD2", "sbValueBeforeDD5", "sbValueBeforeDD65", "sbValueBeforemd2", "sbValueBeforeDS5", "sbValueBeforeMOD1", "sbValueBeforeMOD3", "sbValueBeforeAMDFound", "sbValueBeforeIM2", "sbValueBeforeMAC2", "sbValueWithoutDD2", "sbValueBeforeMP1", "sbValueWithoutMD512", "sbValueBeforeMDFound", "sbValueAfterMDFive", "sbValueBeforeNDson", "sbValueBeforeMS1", "sbValueBeforeDD2", "sbValueBeforeSM2", "sbValueBeforeDD512", "sbValueBeforeIM5", "sbValueBeforeMS2", "sbValueAfterMDFound", "sbValueBeforeSM5", "sbValueBeforeND5", "sbValueBeforeLM512", "sbValueBeforeMD4", "sbValueBeforeMAC65"], "time": ["estamp", "history", "est", "t", "Time", "top", "ime", "clock", "age", "TIME", "id", "length", "user", "total", "now", "ty", "year", "timer", "client", "runtime", "duration", "work", "counter", "hour", "name", "today", "start", "rate", "date", "etime", "frame", "timeout", "value", "size", "tim", "times", "ts", "current", "when", "set", "system", "race"], "rand": ["rid", "mid", "pid", "gz", "rd", "serial", "dr", "ng", "range", "quant", "uid", "inv", "pick", "rot", "id", "reg", "sam", "did", "gt", "r", "Rand", "sid", "hash", "nd", "rev", "res", "rad", "rc", "nt", "rh", "grad", "rate", "init", "frac", "rt", "dist", "gen", "sample", "rank", "std", "roll", "rss", "random", "z", "round", "red", "cr", "seed", "and"], "valueBeforeMD5": ["valueBeforeMOD2", "valueBeforeND2", "valueBeforeMC25", "valueBeforeND7", "valueBeforeMOD3", "valueBeforeMD2", "valueBeforeMOD5", "valueBeforeMT5", "valueAfterND7", "valueBeforeMC2", "valueBeforeMOD7", "valueBeforeND5", "valueAfterMD2", "valueBeforeMC3", "valueAfterMD7", "valueBeforeMC5", "valueBeforeMT3", "valueAfterND2", "valueAfterMD3", "valueBeforeMD7", "valueAfterND5", "valueBeforeMC7", "valueBeforeMT2", "valueBeforeMD25", "valueBeforeND3", "valueAfterND3", "valueBeforeMT25", "valueBeforeMD3"], "array": ["angular", "object", "app", "binary", "RAY", "buffer", "instance", "arr", "range", "data", "archive", "rays", "external", "length", "ash", "raw", "attribute", "batch", "collection", "image", "expression", "storage", "audio", "hash", "our", "address", "map", "a", "var", "av", "feature", "arrow", "atomic", "pair", "ray", "number", "list", "row", " Array", "Array", "record", "sample", "response", "area", "vector", "angle", "random", "share", "sh", "ary"], "sb": ["lb", "zb", "lp", "sg", "bg", "sr", "wb", "bh", "bs", "hs", "ub", "bf", "rob", "bis", "sv", "sq", "bt", "ib", "sa", "ssl", "eb", "sth", "cb", "ob", "gc", "SB", "rb", "bps", "soc", "si", "sw", "gb", "erb", "pb", "nb", "kb", "xb", "bp", "obs", "ctrl", "sh", "sf", "bsp", "db", "abb", "bb"], "j": ["jj", "ja", "t", "ct", "J", "v", "__", "_", "aj", "off", "k", "js", "str", "ind", "bot", "jc", "oj", "jp", "je", "q", "yy", "jump", "index", "jack", "br", "att", "job", "obj", "ij", "ji", "jit", "ix", "json", "uj", "ju", "bj", "it", "jl", "jo", "z", "m", "g", "i", "msg", "us", "dj", "key", "kj"], "b": ["bg", "bd", "B", "y", "v", "bound", "bi", "ba", "k", "bs", "bf", "u", "fb", "bis", "bc", "bt", "ib", "ab", "bar", "mb", "eb", "cb", "br", "rb", "a", "d", "be", "gb", "nb", "beta", "bp", "xb", "bu", "db", "bb"], "valueAfterMD5": ["valueAftermd5", "valueAfterID5", "valueBeforeMD2", "valueAftermd7", "valueAftermd2", "valueAftermd3", "valueAfterMD2", "valueAfterMD7", "valueAfterMD3", "valueBeforeMD7", "valueAfterID3", "valueAfterID7", "valueAfterID2", "valueBeforeMD3"]}}
{"id1": "6009527", "id2": "11933797", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadDetention", "doFinishShowAttention", "doFinishLoadAttachachment", "doFinishLoadAttachached", "doFinishLoadAttached", "doFinishLoadAssachment", "doFinishShowDetachment", "doFinishLoadAttention", "doFinishShowDetention", "doFinishShowAttached", "doFinishShowAttachment", "doFinishLoadAttachention", "doFinishShowDetached", "doFinishLoadAssached", "doFinishLoadAssention", "doFinishLoadDetachment", "doFinishLoadDetached"], "attachmentId": ["attociationID", "attagramId", "attociationName", "attachmentid", "atutationName", "ATTociationId", "detachedid", "attociationById", "attentionById", "attachmentKey", "ATTociationid", "attgmentId", "detachmentid", "ATTachmentId", "attentionID", "attgmentKey", "ATTachmentid", "ATTachmentKey", "attachmentName", "attagramKey", "attachmentById", "attachedKey", "attociationid", "attociationKey", "attachmentID", "atachmentId", "attociationId", "ATTociationKey", "atutationById", "attagramid", "attagramById", "attgmentid", "detachedKey", "atachmentName", "attutationId", "attachedById", "detachedId", "attentionId", "ATTociationById", "atachmentById", "attentionName", "attachedid", "detachmentKey", "attutationName", "detachmentId", "atutationID", "attutationById", "ATTachmentById", "attutationID", "attachedId", "atutationId", "atachmentID"], "attachment": ["attachociation", "detachment", "addociation", "assachment", "detacher", "assention", "assached", "attment", "detment", "contached", "attachachment", " attacher", "ATTached", "ATTention", " attment", "association", "ATTachment", "attachacher", "contacher", "assacher", "attached", "addachment", "ATTacher", "attachention", "addached", "attaching", "attachaching", "contachment", "contment", " attached", "attociation", "detached", "attachached", "attention", "addaching", "attacher", "assaching"], "attachmentUri": ["attachmentTpi", "attachmentUtrid", "attachmentUtri", "attentionUtpi", "attentionUtri", "attachmentOURI", "attachmentUuri", "attachmentOri", "attachmentOuri", "attachmenturid", "attachableOpi", "attachableOri", "attachableUri", "attachmentUnpi", "attachmentUnURI", "attentionUri", "attachmentTuri", "attachmentUrid", "attachmentUnri", "attachableOuri", "attachmentTURI", "attachableUpi", "attachmentUnuri", "attachmentUtRI", "attachableOURI", "attachmentTri", "attentionUrid", "attachmentURI", "attachmentUURI", "attachmenturi", "attentionUpi", "attentionUtrid", "attachmentOpi", "attachmentupi", "attentionUtRI", "attachmentUpi", "attachableUuri", "attachmentuRI", "attachableUURI", "attachmentUtpi", "attentionURI"], "contentUri": ["resourceURI", "contentuuri", "ContentUsri", "contentUnrid", "messageUiri", "contentUruri", "contentUnuri", "messageUtri", "contentURri", "contentUric", "contenturi", "ContentUsris", "contentUtiri", "ContentUrid", "contentUtres", "contentUres", "contentSri", "resourceURres", "contentUtRI", "contentUsris", "contentSuri", "resourceURuri", "contentUnris", "resourceUuri", "messageUturi", "resourceUri", "contentUnri", "ContentUri", "ContentUsrid", "contentURRI", "contentUuri", "messageUri", "contentUrri", "contentUiri", "contentures", "ContentUuri", "contentUsuri", "contentUtris", "messageUuri", "contentUsri", "contentUrid", "contentSric", "contentUtric", "contentSiri", "resourceURRI", "messageUtiri", "contentURI", "contentUturi", "contentUrric", "ContentUris", "contentUtrid", "contentuRI", "ContentUsuri", "resourceUres", "contentUris", "contentURuri", "resourceURri", "messageUtric", "contentUsrid", "messageUric", "contentUriri", "contentUtri", "contentURres"], "file": ["save", "content", "le", "create", "buffer", "type", "tree", "base", "user", "FILE", "upload", "File", "disk", "pool", "document", "image", "zip", "result", "dir", "picture", "il", "ile", "line", "page", "path", "work", "entity", "name", "format", "play", "f", "folder", "media", "init", "channel", "template", "fp", "local", "link", "output", "message", "from", "files", "angle", "to", "db", "resource", "sf", "port", "ca", "table", "h", "rule", "source", "filename", "header"], "in": ["io", "bin", "read", "din", " din", "inc", "isin", "rin", "ind", "mi", "en", "inner", "l", "inf", "ain", "inside", "body", "is", "input", "al", " IN", "up", "In", "on", "play", "gin", "ini", "IN", "con", "it", "sql", "from", "ar", "ins", "inn", "cin", "i", "ic", "source", "and"], "out": ["io", "v", "can", "stable", "write", "os", "auto", "OU", "print", "b", "serv", "flush", "sys", "client", "oss", "put", "check", "res", "obj", "nt", "conv", "screen", "n", "ao", "co", "all", "o", "net", "con", "outs", "w", "it", "Out", "output", "ex", "null", "to", "g", "writer", "i", "ou", "aos", "OUT", "outer"], "intent": ["text", "venture", "widget", "animate", "method", "ence", "inv", "displayText", "activate", "verbal", "ant", "complete", "Activity", "express", "phrase", "statement", "continue", "action", "ent", " Intent", "q", "ident", "agent", "asso", "ment", "concept", "device", "alert", "entity", "activity", "term", "ink", "communication", "spirit", "wordpress", "init", "json", "service", "prom", "man", "query", "skill", "intention", "event", "activation", "automatic", "context", "voice", "condition", "entry", "initial", "act", "xml", "inst", "ic", "window"]}}
{"id1": "1798720", "id2": "18211588", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"save": ["version", "data", "release", "archive", "upload", "download", "register", "dump", "update", "install", "aw", "pack", "accept", "export", "send", "folder", "pkg", "init", "delete", "Save", " seal", " Save", "store", "saving", "zip", "filename"], "packageName": ["packageId", "pkgNames", " packageNames", "PackageId", " packageKey", "PackageType", "packageType", "pkgCode", "PackageName", " packageCode", "moduleKey", "pkgName", "moduleCode", "pkgId", "packagename", " packagename", "moduleName", " packageId", "pkgname", "PackageNames", " packageType", "packageCode", "modulename", "packageNames", "moduleNames", "packageKey", "pkgType", "pkgKey", "moduleId"], "fileContents": ["pageContents", " fileValues", "fileValues", "FileIngredients", "pageNames", "byteNames", "pageItems", "pageBytes", "fileItems", "FileContent", "fileContent", "fileBytes", " fileContent", "packageContents", "FileContents", "FileBytes", "FileItems", "FileValues", "FileNames", "fileIngredients", " fileItems", "packageIngredients", "packageContent", "byteContents", "packageNames", " fileIngredients", "byteContent", " fileBytes", "byteValues"], "fileNames": [" fileLeaks", "dirNames", " fileValues", "fieldNames", "resourceContents", "issueVaults", "moduleContents", "fieldTypes", "fileLeaks", "FileLeaks", " fileName", "fileValues", "resourceValues", "fieldContents", "issueName", "FileTypes", " fileNumbers", "issueNames", "messageValues", "dirLeaks", "resourceNames", "resourceTypes", "FileKeys", "FileName", "fileVaults", "messageKeys", "moduleName", "fieldNumbers", "fileName", "dirKeys", "moduleVaults", "FileContents", " fileTypes", "messageName", "FileNames", "FileValues", " fileKeys", "fileKeys", " fileVaults", "fileNumbers", "moduleNames", "dirTypes", "messageNames", "fileTypes", "resourceNumbers", "issueContents"], "dirBase": ["directoryBasic", "pkgSet", "dirbase", " directoryBase", "pathBas", "DIRBase", "directorybase", "irBas", "pkgBase", "pkgBas", "dirBas", "DirBottom", " directoryBas", "dirBottom", "pkgbase", "directoryBas", "dirBuilder", "DirBuilder", "directoryBase", "dirSet", "pathbase", "folderBasic", "DIRBas", "DIRBottom", "folderBase", "dirBasic", "folderbase", "folderBas", "pathBasic", " directoryBottom", "DIRBuilder", "irBase", "directorySet", "irSet", "irbase", "DirBase", " directoryBuilder", "DirBas", "pathBase"], "packageDir": ["podDir", " packageDist", "packageDef", "installDef", " packageD", "pkgFolder", "installDir", "moduleRel", "packageFolder", "pkgPath", " packageDef", " packagePath", "pkgDir", "moduleFolder", " packageRel", "podD", "installD", "modulePath", " packageFolder", "packageDist", "installDist", "podDef", "pkgDef", "packageRel", "moduleDef", "pkgRel", "packagePath", "moduleDir", "packageD", "podDist"], "created": ["confirmed", "generated", "checked", "started", "create", "creation", "registered", "called", "defined", "mounted", "arted", "raised", "produced", "existent", "creat", "recorded", "developed", "creator", "reported", "printed", "founded", "allowed", "successful", "Created", "present", "TED", "loaded", "ced", "made", "forced", "added", "joined", " started", "provided", " generated", "activated", "given", "associated", "released", "installed", "filled", "locked", "ready"], "currentPath": ["currentlyPath", " currentName", " currentParent", "currentPoint", "currentFile", "currentlyName", " currentFile", "CurrentPath", "currentCh", " currentCh", "CurrentFile", "currentParent", "currentName", " currentPoint", "CurrentCh", "recentParent", "currentlyFile", "CurrentPoint", "recentPoint", "CurrentParent", "recentPath", "currentlyCh", "recentName", "CurrentName"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "batch", "hi", "cli", "ami", "exp", "init", "ini", "ei", "sim", "j", "my", "mu", "g", "zi", "ic", "in", "multi", "u", "this", "q", "ki", "index", "pi", "ij", "qi", "f", "di", "o", "jj", "status", "ity", "id", "os", "mi", "them", "gi", "uri", "ie", "iii", "slice", "ji", "iq", "me", "p", "si", "ix", "info", "it", "yi", "key", "ip", "iy", "phi", "ui", "ind", "iu", "go", "ski", "oi", "im", "cgi", "ti", "major", "ci", "chain", "ex", "m", "ai", "ri"], "file": ["et", "le", "io", "buffer", "type", "base", "comment", "FILE", "log", "File", "disk", "pool", "l", "dir", "body", "ile", "child", "path", "fo", "name", "format", "play", "handle", "p", "f", "info", "row", "template", "local", "link", "handler", "page", "port", "sf", "resource", "table", "parent", "db", "rule", "source", "h", "set", "header"], "fos": ["woes", "foes", " foes", "Faos", "Foss", "ffos", "FOS", "woses", " fow", "ffoes", " foses", " fOS", "oo", "oow", "woss", "sfaos", " foss", "flo", "foss", "floes", "fbow", "flaos", "Foes", "sfoss", "oos", "faos", "Fos", "sfos", "fo", "fbaos", "sfOS", "fOS", "flos", "floses", "floss", "oaos", "ffo", "ffaos", "fow", "fbo", " faos", " fo", "Fo", "foses", "fbos", "wos"], "fileSrc": [" fileInsRC", "fileDsrc", " fileInsource", "fileInRC", "fileInssrc", "fileEci", " fileInsrc", " fileSsrc", "jobNrc", " fileSource", "fileErc", "fileNci", "fileDci", "fileInsrc", "fileSri", "jobNci", " fileInssrc", "fileSRC", "jobSri", "fileInource", "fileSource", "fileSci", "fileNrc", "jobNri", "fileErl", "fileEri", "fileInsource", "jobSrl", "fileInrc", "fileNrl", "jobSrc", "fileDRC", "jobNrl", " fileSRC", "fileDri", "fileDrc", "fileSsrc", "fileDource", "jobSci", "fileSrl", "fileNri", "fileDrl", "fileInsRC"], "fileDst": ["filedld", "FileSld", "fileNld", "fileDot", "FileDst", "fileNst", "filednd", "fileSpl", "FileDld", "fileDnd", "fileDld", "FileSst", "fileDpl", "FileDpl", "fileWst", "fileDcr", "fileSst", "FileSpl", "fileScr", "FileSnd", "FileDlt", "filedcr", "fileSlt", "FileSlt", "fileWlt", "FileDot", "FileSot", "fileNnd", "fileNlt", "fileWot", "FileDnd", "FileDcr", "fileSld", "fileWpl", "fileNot", "FileScr", "fileNcr", "fileSnd", "fileNpl", "fileSot", "filedst", "fileDlt"], "reader": ["ler", "read", "buffer", "dr", "ader", "actor", "rl", "stream", "rx", "rot", "book", "controller", "author", "review", "inner", "loader", "Reader", "ro", "iter", "oder", "parser", "ner", "r", "driver", "rer", "Larry", "upper", "ocker", "rar", "rc", "er", "row", "query", "roller", "reading", "context", "runner", "readable", "entry", "rr", "handler", "resource", "ri", "iterator"], "writer": ["println", "buffer", "write", "worker", "read", "manager", "wire", "stream", "order", "user", "server", "test", "liner", "document", "print", "draw", "loader", "Reader", "adder", "flush", "console", "word", "parser", "creator", "storage", "client", "iter", "driver", "player", "operator", "browser", "riter", "writing", "later", "format", "iterator", "variable", "builder", "maker", "caster", "wrapper", "Writer", "wright", "service", "query", "w", "runner", "writers", "report", "walker", "entry", "store", "handler", "table", "function", "ter", "window", "outer", "editor"], "line": ["text", "le", "detail", "lin", "inline", "range", "point", "nl", "user", "column", "comment", "liner", "LINE", "print", "l", "continue", "ln", "cell", "word", "Line", "eline", "source", "string", "stroke", "ole", "entity", "chain", "ine", "date", "pe", "lined", "frame", "number", "row", "edge", "record", "link", "sample", "block", "sequence", "message", "valid", "entry", "label", "style", "code", "port", "node", "rule", "page", "kin", "header"]}}
{"id1": "17791385", "id2": "7149578", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyfile", "cloneFiles", " cpfile", "cloneFile", " copyResource", "cloneResource", " cpResource", " copyFiles", " cpFile", " cpFiles", "clonefile", "copyResource"], "src": ["sb", "ctr", "sr", "ipl", "sc", "rl", "bs", "sin", "rx", "usr", "sit", "sq", "ck", "sys", "usc", "input", "ux", "ys", "rc", "sur", "req", "start", "Source", "iv", "init", "sec", "cur", "rs", "via", "rel", "st", "from", "obs", "ins", "sel", "sf", "inst", "cont", "ser", "source", "txt"], "dst": ["dth", "wth", "ddest", " dth", "Dth", "Dnd", "dnt", "ddst", "dnd", "snt", " dnd", "ddnd", "snd", "sst", "Dnt", " ddest", "ddnt", "Dst", "sdest", "dddest", "wdest", "Ddest", "wst", "wnd"], "in": ["bin", "din", "min", "inc", "isin", "rin", "ind", "en", "inner", "ze", "ln", "inf", "ain", "inside", "iter", "im", "source", "is", "input", "al", "up", "In", "on", "gin", "init", "info", "IN", "con", "it", "st", "from", "ar", "ins", "rec", "inn", "cin", "ai", "act", "mm", "i", "ic", "sin", "oin"], "out": ["t", "io", "dis", "can", "write", "OUT", "bin", "oe", "po", "ne", "os", "auto", "inner", "at", "ot", "gt", "sys", "client", "oss", "res", "obj", "nt", "up", "conv", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "sum", "ex", "st", "to", "g", "writer", "ou", "aos", "by", "outer", "and"], "buf": ["cv", "Buffer", "stab", "buffer", "bh", "arr", "bed", "buff", "Buff", "fb", "prop", "log", "batch", "norm", "b", "bus", "cf", "vec", "ck", "bar", "cp", "cmd", "uf", "cb", "br", "good", "conv", "var", "bag", "aka", "seq", "pkg", "pl", "cur", "gen", "cam", "block", "cap", "cat", "tx", "bytes", "tab", "mu", "msg", "box", "db"], "len": ["compl", "t", "dl", "count", "le", "v", "lon", "lib", "str", "L", "length", "el", "pos", "en", "loc", "l", "wid", "ln", "e", "il", "lan", "lf", "no", "ls", "elt", "end", "nt", "n", "exp", "coll", "seq", "all", "val", "ld", "ll", "fin", "size", "num", "vol", "fun", "lic", "fl", "cap", "rel", "z", "lim", "h", "cmp", "Len", "ren"]}}
{"id1": "300397", "id2": "4118412", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewend", "readAndrewrite", "readAndRepend", "readAndrewWrite", "readAndResWrite", "readAndResrites", "readAndResend", "readAndRepWrite", "readAndResrite", "readAndRewWrite", "readAndrewrites", "readAndRewrites", "readAndRewend", "readAndReprite", "readAndReprites"], "inFile": ["INPlace", "INFilename", " infile", "INFace", "inputPlace", "inputFace", "iFILE", "infile", "iFile", "inTime", "InFile", "outFilename", "INFILE", "InFilename", "initFace", "Infile", "docFILE", "docFilename", "initPlace", "inPlace", "initFilename", "INTime", "outfile", "docTime", "docFile", "iFilename", "inFILE", "inputFile", "initFile", "inFace", "inFilename", "INFile", "iTime", " inFilename", "inputFilename"], "outFile": ["reportFile", "nameFile", "outFILE", "tofile", " outFilename", "infile", "namefile", "reportfile", "checkFILE", "outFilename", "nameFILE", "toFile", " outfile", "toFilename", "checkFile", "reportFILE", "outfile", "inFILE", "reportFilename", "checkfile", "nameFilename", " outFILE", "toFILE", "checkFilename", "inFilename"], "iis": ["diiss", "aiIs", "iiris", "dii", "liIs", "iris", "ii", "iisc", "aiis", "iiss", "iiIs", "liris", "liis", "eIs", " ii", " iris", "Iis", "liisc", "iIS", " iIs", " iisc", "eis", " iIS", "iiisc", "eIS", "diIs", "iIs", "iiis", " iiss", "IIs", "aiIS", "Ii", "Iiss", "diis"], "dcmParser": ["dpmParser", "dmoduleParser", "DcmReader", "deromParser", "dfmParser", " dcmLoader", "dgrStatement", "dmmmParser", "dcmReader", "dmparser", "dcommListener", "dromarser", "dcrparser", "dgrPar", "DcmBuilder", "DpmBuilder", " dpmParser", "dromAssistant", " dcmarser", "dromReader", "dromparser", "dpcParser", " dcmparser", "dpmarser", "dmoduleReader", "dcrParser", "decmarser", "dcomReader", "decmParser", "dcmparser", "dmmAdapter", "dmmmparser", "dcmPar", "dcrReader", "decmparser", "dpcReader", "dromParser", "DpmAdapter", "dcmBuilder", " dpmBuilder", "dmmmReader", "drumPar", "dmmparser", " dpmarser", "dfmBuilder", "drumParser", "dmReader", "dcommReader", "dcmarser", "dmmReader", " dpmReader", "dcmListener", "Dcmparser", "dcfStatement", " dpmAssistant", " dpmPar", "deromReader", "dcrBuilder", "Dpmparser", "dpmLoader", " dpmStatement", "dpmStatement", " dcmAssistant", "dpmPar", " dpmparser", " dcmListener", "dcommParser", "dpmListener", "dpmPrivate", "dcmLoader", " dcmStatement", "dcmAssistant", "dcmStatement", " dcmPar", "dcmPrivate", "drumBuilder", "DcmParser", "dpmAdapter", "dmParser", "DpmReader", "dcfPar", "dpcAssistant", "dromListener", "dpmAssistant", "dcomParser", "drumReader", "dpmReader", " dcmPrivate", " dpmPrivate", "deromarser", "dpmparser", "dpmBuilder", " dpmLoader", "dmmParser", "dpcPrivate", "dcfParser", "DcmAdapter", "dcmAdapter", "dmmmAdapter", "dcfReader", "DpmPar", " dcmReader", "dmarser", "dgrParser", "dcomBuilder", "dgrReader", "dfmLoader", "deromparser", "DcmPar", "dfmReader", "dmodulePrivate", "decmReader", " dpmListener", "dmmarser", " dcmBuilder", "dmoduleAssistant", "DpmParser", "dcomLoader", "dcommAssistant"], "ds": ["qs", "gs", "dos", "bd", "dl", "ss", "dh", "ps", "ads", "details", " des", "in", " DS", "sd", "bs", "es", "hs", "des", "js", "data", "os", "ils", "vs", "services", "sv", "eps", "dds", "da", "cs", "dd", "hd", "Ds", "dt", "aos", "ks", "sys", "as", "DS", "df", "ls", "ys", "pd", "ws", "dat", "drivers", "its", "dx", "d", "der", "fs", "ims", "rs", "eds", "sets", "outs", "dq", "obs", "ins", "gd", "ods", "s", "uds", "ns", "db", "pers", "tes", "xs"], "pdReader": ["vdHelper", "hdWriter", "dpCar", "xdHelper", "xdReader", "ddHelper", "ddWriter", "dpRunner", "pdParser", "pdRunner", "pdLoader", "vdLoader", "ddCar", "hdRead", "pdRead", "tdWriter", "xdWriter", "ddRunner", "vdReader", "pedLoader", "tdParser", "xdLoader", "ddReader", "hdReader", "pedRunner", "hdParser", "pedReader", "pdHelper", "pedCar", "dpReader", "ddRead", "vdWriter", "ddParser", "tdReader", "pdCar", "dpLoader", "tdRead", "ddLoader"], "out": ["t", "tmp", "v", "gr", "data", "full", "en", "cmd", "err", "up", "conv", "on", " err", "list", "con", "output", "Out", "ins", "null", "writer", "outer", "io", "in", "conn", "js", "nr", "auto", "inner", "sys", "oss", "client", "cache", "o", "gen", "net", "s", "ou", "aos", "txt", "status", "over", "os", "id", "raw", "pos", "inter", "serv", "ent", "at", "gt", "opt", "nt", "screen", "p", "cn", "it", "to", "msg", "OUT", "c", "cfg", "inv", "str", "log", "go", "pool", "flush", "cb", "res", "obj", "end", "name", "n", "co", "all", "sw", "one", "outs", "w", "desc", "ch", "we", "sum", "ex"], "dcmEncParam": ["dmmEncPar", "dcmDecCmd", "dcmencPar", "dcmencCmd", "dcmEnParam", "dcmDecParam", "dcmencParam", "dmmEnNum", "dcmEnPar", "dcmEscPar", "dcmEncMsg", "dmmencParam", "dmmencCmd", "dmmencNum", "dcmEncNum", "dcmDecNum", "dmmEnPar", "dcmEscVal", "dcmEncCmd", "dmmencMsg", "dcmencNum", "dcmEnNum", "dmmEncNum", "dmmEncMsg", "dcmencMsg", "dmmEncParam", "dcmEscNum", "dmmEnParam", "dmmEncCmd", "dcmEncVal", "dcmEncPar", "dcmEscParam", "dmmEncVal", "dcmDecMsg", "dcmEnVal"], "pdWriter": ["PDReader", "pcWriting", "dpWrite", "pidWrite", "PDEditor", "tdwriter", "pcwriter", "dpEditor", "dpWriter", "pdWrite", "tdWrite", "pdWriting", "pidwriter", "tdWriter", "PDWrite", "PDWriter", "pidWriter", "pdEditor", "pcWrite", "dpReader", "tdEditor", "pdwriter", "tdReader", "pcWriter", "pidWriting", "tdWriting"]}}
{"id1": "21979462", "id2": "3631989", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURL2JSON", " downloadURL2String", " downloadurltoString", " downloadurloJSON", " downloadURLToText", " downloadURLtoJSON", " downloadurloBytes", " downloadurloText", " downloadurltoBytes", " downloadURLToBytes", " downloadurloString", " downloadURLoBytes", " downloadurltoText", " downloadURLoJSON", " downloadURLToJSON", " downloadurltoJSON", " downloadURLtoText", " downloadURLToString", " downloadURLtoBytes", " downloadURL2Bytes", " downloadURLoText", " downloadURL2Text", " downloadURLoString"], "url": ["dl", "location", "ul", "run", "mount", "base", "id", "log", "file", "l", "gl", "web", "uri", "ssl", "browser", "ls", "job", "mail", "ref", "sl", "address", "uu", "name", "bel", "un", "ur", "http", "all", "ll", "link", "domain", "ret", "URL", "char", "resource", "Url", "rect"], "in": ["io", "reader", "bin", "read", "din", "copy", "or", "re", "inc", "isin", "ind", "ill", "inner", "inf", "mc", "out", "is", "input", "check", "al", "up", "er", "In", "on", "thin", "gin", "ma", "all", "info", "conf", "IN", "mn", "con", "it", "sum", "from", "ins", "inn", "cin", "ai", "again", "i", "ic", "oin", "by", "and"], "sb": ["lb", "zb", "lp", "bg", "bd", "sg", "pa", "wb", "bh", "bs", "sd", "bf", "sk", "sam", "rob", "bis", "sq", "b", "bt", "ib", "sa", "ab", "ssl", "mb", "eb", "gc", "cb", "SB", "rb", "gb", "erb", "pb", "nb", "bj", "kb", "xb", "bp", "db", "gob", "sf", "sp", "bsp", "bn", "ub", "bb"], "str": ["text", "fr", "t", "gr", "dr", "Str", "arr", "re", "part", "comment", "div", "print", "l", "b", "comm", "bc", "pt", "next", "iter", "string", "del", "r", "ls", "tr", "br", "err", "obj", "sl", "bl", "chain", "dat", "n", "req", "exec", "p", "comp", "expr", "cur", "list", "STR", "sts", "ch", "vol", "sp", "st", "char", "j", "block", "cat", "syn", "m", "msg", "i", "s", "cont", "source", "set", "def", "txt"]}}
{"id1": "8942491", "id2": "7372311", "code1": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"openProxiedConnection": ["openProxedUrl", "openProxyingConnection", "openProzedUrl", "openProziedChannel", "openProziedConnection", "openProzedChannel", "openProxiedUrl", "openProxedConnection", "openProxedConnect", "openProziedConnect", "openProxiedChannel", "openProxyingChannel", "openProxifiedConnect", "openProzedConnect", "openProxifiedChannel", "openProxyingUrl", "openProzedConnection", "openProxedChannel", "openProxiedConnect", "openProziedUrl", "openProxyingConnect", "openProxifiedConnection", "openProxifiedUrl"], "url": ["dl", "location", "build", "ul", "rl", "nl", "mount", "str", "base", "user", "log", "iu", "l", "b", "web", "gl", "uri", "https", "r", "ssl", "cert", "uf", "path", "ls", "job", "email", "ref", "sl", "address", "uu", "un", "bel", "ur", "http", "ll", "link", "ret", "URL", "char", "call", "Url"], "cnx": ["ncfx", "lnv", "cnco", "cnv", "nnco", "cnxs", "nnx", "CNX", "lnxi", "lnxf", "nicxs", "nnxf", "bnx", "cnxf", "cinxf", "ncex", "lnX", "bnxi", "nx", "cnfx", "lnx", "cinco", "nicX", "nicxi", "cnex", "cinx", "nfx", "lnco", "nicx", "nnv", "nX", "CNex", "bnX", "bnxs", "ncx", "CNx", "cnX", "cinv", "ncX", "cnxi", "lnxs", "CNfx", "nex"]}}
{"id1": "13563706", "id2": "21656668", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleget", " doGET", "Doget", "DoPut", "DoGet", "doPut", "handleGET", "handleGet", "handlePut", "doget", "doGET", "DoGET", " doget", " doPut"], "request": ["version", "create", "re", "each", "view", "connection", "order", "user", "attribute", "QUEST", "document", "complete", "route", "transform", "input", "reference", "path", "application", "setup", "address", "command", "position", "project", "get", "url", "Request", "use", "http", "frame", "search", "hello", "first", "directory", "query", "event", "context", "message", "subject", "report", "reset", "initial", "socket", "call", "resource", "xml", "parent", "current", "forward"], "response": ["version", "reply", "respond", "fire", "example", "exit", "write", "status", "default", "view", "foundation", "connection", "tree", "server", "answer", "ce", "collection", "document", "print", "image", "relation", "next", "continue", "result", "console", "render", "security", "hash", "zero", "application", "res", "success", "format", "position", "resp", "ve", "description", "http", "frame", "network", "search", "json", "service", "sequence", "block", "output", "message", "condition", "display", "report", "see", "Response", "header", "summary"], "selectedPage": ["electedpage", "selectItem", "specifiedPage", "electionDocument", "selectedPath", "singlePort", "namedpage", "matchedPort", "electionFrame", "selectedKey", "selectedpage", "electedFrame", "selectLine", "selectedDocument", "namedFrame", "selectionItem", " selectedFile", "singlepage", "namedKey", "selectionLine", "electionPort", "lectedpage", "verifiedRow", " selectedPath", "electedPort", "selectedItem", "lectedItem", "selectPath", "matchedPage", "lectedRow", "selectedFrame", "lectedPort", "specifiedDocument", "selectedToken", "verifiedpage", "lectedKey", "lectedLine", "selectedRow", "selectionPort", "selectFile", " selectedLine", "namedLine", "singleFrame", "electionPage", "namedPort", "selectPort", "selectionPage", " selectedpage", "lectedPath", "matchedpage", "namedPage", "verifiedPage", "specifiedFrame", " selectedKey", "singlePage", "selectionFile", " selectedFrame", "verifiedFile", "specifiedPort", "electedPage", "selectedLine", "namedToken", "lectedPage", "lectedDocument", "lectedFrame", "matchedFrame", "lectedFile", " selectedRow", "selectedFile", "selectedPort", "selectPage", "selectionToken", "lectedToken", " selectedPort"], "page": ["object", "profile", "address", "position", "frame", "row", "message", "output", "node", "parent", "filter", "rule", "version", "server", "collection", "next", "phone", "client", "menu", "pointer", "cache", "application", "policy", "successful", " Page", "project", "site", "record", "group", "window", "age", "point", "user", "document", "phrase", "image", "self", "language", "pages", "line", "created", "me", "url", "p", "layout", "be", "network", "channel", "office", "force", "Page", "block", "pp", "to", "table", "resource", "peer", "instance", "view", "log", "pool", "complete", "result", "chain", "number", "proxy", "display", "port", "associated", "current", "form"], "portalRequest": ["portalingAccess", "portalerequest", "portalidRequest", " portaleApply", "terminalidQuery", "portsortalrequest", "portortalRequest", " portalCall", "PortaleQuery", "terminalRequest", "terminalSession", "portsortalResponse", "portaleEvent", "PortalRequest", "portalApply", "portaleContext", "portaleFrame", "portalaAccess", "PortaleThread", "portalQuery", "portaleAccess", "portpalRequest", "PortaleRequest", "portalingCall", "portortalContext", "portortalResponse", "portalityRequest", "portaleQuery", "portortalrequest", "portalaRequest", "portalAccess", "PortaleFrame", "portalrequest", "portortalQuery", "portalContext", "portaleResponse", "portaleCall", "portalThread", "portsalResponse", "portortalThread", "portualRequest", "terminalQuery", "portalityContext", "PortalQuery", "portsortalRequest", "PortaleContext", "portalidResponse", "portpalContext", "portalityFrame", " portaleRequest", "PortalResponse", "portalFrame", " portaleCall", "portalidFrame", "portalEvent", "portalityResponse", "PortalFrame", "portalingApply", "PortalThread", "portalidQuery", "portsalRequest", "portsortalEvent", "portalSession", "portaleRequest", "portualResponse", "portualrequest", " portalAccess", "portpalThread", "portaleSession", "portralResponse", "portralRequest", "portalCall", "portpalResponse", "portralSession", "portalaCall", "terminalidSession", "portaleThread", "portortalEvent", "portalResponse", "portralQuery", "portalidSession", "terminalidResponse", "terminalidRequest", "portralContext", "portsalrequest", "portsalEvent", " portalApply", "portalaApply", " portaleAccess", "portualEvent", "terminalResponse", "portaleApply", "portalidContext", "portalingRequest", "PortalContext", "PortaleResponse"], "pageProp": ["imagePred", "ageProp", "profilePred", "profileZip", "keyPr", "propertyDef", " pageProperty", "pagePred", "pagePr", "phraseComp", "officePriv", " pageDef", "pagePriv", "poolProp", "sectionZip", "imagePr", "imagePro", " pagePred", "sectionPred", "propertyProp", "officeProp", "phraseProperty", "pagePro", "keyComp", "sectionPro", "propertyPack", "poolPro", " pagePr", "officeDef", "officePack", "sectionProp", "phrasePr", "imageProp", "poolPred", "pageZip", "pageComp", "agePred", "pageDef", " pageComp", "keyProp", "propertyPriv", " pagePack", "poolZip", "profilePro", " pagePriv", " pagePro", "profileProp", "phraseProp", "pageProperty", "agePr", "agePro", "pagePack", "keyProperty"], "possiblePage": ["pableTag", "pbablePage", "PossibleCollection", "pentialpage", "pbableCollection", " packedPage", "pibleUser", "pentialPage", "packedCollection", "possibleLine", "PossibleTag", "possiblyLine", "packedLine", " possibleCollection", "PossiblePage", "pentialTag", "possibleUser", "pableLine", "PossiblyPage", "PossibleUser", "PossiblePages", "pspecifiedpage", "PossiblyChild", "pibleChild", " packedTag", "piblePage", " packedCollection", " packedLine", "possiblyPage", "possiblepage", "pspecifiedPage", "possiblyTag", "possibleCollection", "pspecifiedPages", "possiblyUser", "pspecifiedTag", "PossiblyUser", "pbableUser", "possiblyCollection", "packedTag", "possibleTag", "pableCollection", "packedPage", "pbableChild", "pentialPages", "possiblePages", "PossiblyCollection", "Possiblepage", "pibleCollection", "pablePage", " possibleLine", "PossibleChild", "possiblyChild", " possibleTag", "possibleChild"], "property": ["object", "location", "type", "rue", "behavior", "prop", "attribute", "relation", "phrase", "integer", "expression", "trace", "string", "definition", "operator", "policy", "title", "address", "name", "metadata", "command", "variable", "position", "p", "feature", "description", "frame", "properties", "service", "value", "Property", "domain", "field", "message", "config", "function", "resource", "second", "owner", "rule", "key", "header", "class"], "referer": ["printrer", "Refrer", "refrier", "refender", "rederee", "reerential", "frer", "reener", "redrer", "reeree", "diffrer", "refirect", "defrer", "fering", "deferer", "retrer", "fener", "reterer", "defirect", "reere", "reender", "defered", "Refere", "rearer", "rorered", "relender", " refirect", "aferer", "Referee", "reerer", "reportered", "ferer", "refered", "refarer", "refere", "rangeerer", "printerer", "refering", "requerer", "verrer", "differing", "reportarer", "diffonder", "relener", "reportrer", "printerential", "reered", "verrier", "rangerer", "referential", "relering", "relerer", "rangeener", "refener", "reonder", "rederer", "Referer", "relrer", "redere", "requonder", "reporterer", "vererer", "printrier", "rorerer", "relerential", "rerer", " refrer", " refered", "aferential", "requrer", "rerier", "rorirect", "refrer", "rangeender", "refonder", "differer", "referee", "vererential", "retered", "reering", "retarer", "afener", "requering", "afrer", "rorrer"], "e": ["t", "ae", "echo", "te", "eur", "se", "eu", "eeee", "es", "oe", "ception", "ge", "eg", "r", "x", "ie", "err", "de", "a", "er", "n", "me", "p", "f", "o", "event", "ee", "E", "m", "g", "h", "error"]}}
{"id1": "14191679", "id2": "530882", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnccodeReturn", "EncodeText", "EnforceReturn", "EnforceText", "EnccodeData", "EnforceData", "EnodeText", "EnodeReturn", "EnodeData", "EncodeData", "EnccodeText"], "IOException": ["IOFailure", "ioEvent", "ioFailure", "AudioEvent", "AudioFailure", "AudioException", " IOFailure", " IOEvent", "ioException", "IOEvent"], "c": ["t", "xc", "v", "coin", "enc", "ac", "u", "arc", "dc", "l", "b", "cs", "e", "tc", "mc", "cp", "cc", "r", "crypt", "icc", "ci", "cu", "ec", "n", "co", "p", "f", "o", "w", "cm", "ch", "fc", "m", "cin", "cos", "cr", "cmp", "C", "ca", "ic", "h", "lc"], "tmpf": [" tmpw", "mpv", " tmpfile", "mintf", "mkw", "mpw", "tmpd", "tmpfe", "mpd", "tmpw", "mintw", "tmpv", "mkf", "tmpfile", "mintfile", "mkfile", " tmpd", "tempd", " tmpv", "tempv", " tmpfe", "mpf", "tempf", "mintfe", "mkd", "mpfile", "mpfe", "tempfile"], "cw": ["ccsw", "fws", "cpwindow", "cws", "cuw", "dcsw", "ccwe", "cwd", "Cw", "cweb", "cwe", "cpweb", "cewriter", "ccw", "cwindow", " cweb", "fwindow", "cewd", "fw", "Cwd", "dcw", " cwindow", "dcwe", "fweb", "cew", "dcwd", "cuwriter", "Csw", "Cwe", "cpw", "cwriter", "cpws", " csw", " cwd", "csw", "ccwd", "cesw", "cusw", " cws", " cwriter", "cuwd"], "encdata": ["exttext", "extdat", "ENCdat", "ENCdata", "extdata", " encresult", "excData", "encdat", "ENCtext", "excresult", "Enctext", " encData", "Encdat", "excdat", "decData", " encdat", "excdata", "ENCData", "Encdata", "enctext", "decdat", "EncData", "extData", "decdata", "encresult", "Encresult", "encData"], "pigdata": ["pibata", "pagData", "Pigata", "prigdes", "pickfile", "PIGfile", "PIGdat", " pigata", "pixdata", "pircdat", "PIGata", "pIGdat", " pIGata", "pagdes", " pigData", "pibdata", "PIGData", "pibdat", " pIGData", "pigData", "pixData", "prigdata", "Pigfile", "prigata", " pIGdat", "pIGdes", "PigData", "pIGfile", "PIGdata", " pIGdata", "pigfile", "pickdat", "Pigdes", "pigdat", "pircata", "pagdata", "pickdata", "pigdes", "pircdata", "Pigdat", "pickData", "pibData", "pixdat", "prigData", "pIGdata", "pIGData", "pixfile", " pigdat", "PIGdes", "pagata", "pircData", "pIGata", "Pigdata", "pigata"], "pigroute": ["piscoute", "piscange", "pigranne", " pigranne", "pyrouse", "pyroute", " pibrroute", "prigoute", " pigata", "pibrroute", "pibrata", "pigrouter", "piderouse", "pideroute", "pyrouter", "piscouter", " pigoute", "prigata", " pyrange", " pyrouter", "pyrroute", " pigrouse", "pircouter", "pibrouter", "piderouter", "pyranne", " pigrange", " pigote", "pibroute", "pigoute", " pigrroute", " pigrouter", "pircoute", "pigrroute", "pircanne", "prigroute", "piscanne", " pibrouse", "pigrata", " pyranne", " pigrata", " pigrote", "pibrouse", "prigote", "pigote", "pigrote", "pyrange", " pibrouter", "pigrange", " pyroute", " pibroute", "pigrouse", "pibrote", "pircange", "piderroute", "pigata"], "fos": [" fbos", "Fios", "Foses", "fops", "fios", "wbos", " foses", " fOS", "woss", " foss", "foss", "Fos", " fops", " fios", "wOS", "foops", "fOS", "fbbos", "foos", "fbOS", "foios", "fboss", "foses", "Fops", "fooses", "fbos", "wos"], "foc": ["focal", "fiic", "Foc", "bfic", "Fic", "bfoc", "bfoco", "hos", "hog", "fioc", "rfoc", "Fos", "fbosc", "hic", "rfos", "fiocal", "fioco", " focal", " fosc", "fboca", "fboc", " fog", "rfoca", " foca", "foco", " foco", "fosc", "foca", "hoc", "Fog", "fog", "rfosc", "bfocal", "fbos"], "fis": ["sfisc", "feedis", "vic", "sfis", "vos", "sfics", "sfos", " fisa", "vics", "sfisa", "feedic", " fics", "fisa", " fisc", "sfic", "vis", "fics", "feedisc", "fisc", "feedisa"], "fic": ["sfoc", "flicon", "Foc", "Ficon", "Fic", "sfico", "sfis", "ficon", "ific", "fico", "Fric", " fico", "flics", "ifics", "hic", " ficon", "hics", "his", "hico", " fics", "flic", "flric", "ifico", "sfic", "fics", "hoc", "ifis", "fric", "Fis", " fric", "Fics", "Fico"]}}
{"id1": "19912848", "id2": "13499897", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "10690321", "id2": "20924119", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 0, "substitutes": {"readData": ["processInfo", "readInfo", "processData", "readArray", "ReadInfo", "loadInfo", "loadArray", "loadResults", "loadData", "ReadResults", "ReadArray", "readResults", "processResults", "ReadData", "processArray"], "sTok": [" sIter", "sesPut", "sPut", "sqlIter", "gsOct", "sSocket", "fsEp", "gsCorp", "stsTyp", "tSax", "tsTok", " sToy", "tesIv", "sqlEp", "gsTok", "sAsk", " sPut", " sNob", "tesAsk", "dsInst", "tsOtt", " sInst", "fsTok", "sOp", "sqlOtt", "sLex", "rsEp", "atsLex", "sEp", "sysNik", "newEp", "gsPick", "sesTok", "dsIter", "tsSax", "atsIter", "gsEp", "tsEar", "itsTok", "nsIter", "atsAsk", "sysTok", "newEar", "seRap", "fsCorp", "sOtt", "tesSocket", "usPet", "qsTok", " sIv", "sNik", "nsAsk", "sEar", "sToy", "sqlEar", "sVo", "sCorp", "stsIter", " sOtt", "jsArch", "jsEp", "fsEar", "nsInst", "fsNob", "tTok", "SEp", "tsNik", "persOtt", "STok", "gsEar", " sArch", "atsOtt", "fsObj", "gsToy", "newNik", "gsSax", "persIter", "jsSax", "jsTok", "stsOtt", "persOct", " sApp", "gsOtt", "gsRex", "usTok", "sPet", " sOp", " sTyp", "sesObj", "rsTok", " sSocket", "atsEp", "tsCorp", " sOK", "sqlTyp", "sInst", "sqlNob", "atsTok", "sysVo", " sVo", "atsPet", "sysIv", " sObj", "nsVo", " sSax", "qsToy", "tesPut", "tsEp", " sPet", "qsIter", "seIter", "sObj", "sArch", "sOK", " sOct", "gsIter", "sPick", "stsTok", "tIter", "rsIter", "sysSax", " sEar", "itsArch", "qsApp", "newTok", "seOK", "jsOtt", "fsOp", "simpleTok", " sVal", "jsIter", " sLex", "stsSax", "atsTyp", "usOtt", "gsAsk", "tsRex", "gsTyp", "stsEp", "dsVo", "sRap", "simpleRap", "persTok", "gsApp", "nsEar", "rsOtt", "nsTok", "sApp", "gsNik", "itsEp", "seTok", "sqlTok", "tsIter", "sysVal", "sysOK", "sOct", "sVal", " sPick", "sIv", "fsOtt", "sysAsk", " sEp", "atsOct", "nsSax", "sysIter", "tesObj", "sNob", "sRex", "fsRex", "simpleIter", "dsTok", " sRap", "itsSax", "sIter", "SInst", "sTyp", "stsPick", "sSax", "tesVal", "tOtt", "simpleOK", "nsOtt", "SOp", "sesSocket", " sNik", " sAsk", "tesTok", "usIter", "stsOct", "nsEp"], "topSet": ["hopMap", "rightSize", " topSize", "bottomSize", "topScan", "hopSet", " topMap", "rightMap", "hopScan", "topsScan", "topMap", "bottomMap", "topsSet", "topSize", "topLog", "rightLog", "bottomLog", " topLog", " topScan", "bottomSet", "topsMap"], "leftSet": ["LeftNet", "LeftMap", "LeftGroup", "rightGroup", "oldNet", "oldset", "leftSum", " leftMap", "LeftSum", "oldMap", "Leftset", "oldSet", " leftset", " leftGroup", "leftMap", "rightSum", "leftNet", " leftNet", "leftset", "LeftSet", "leftGroup", " leftSum"], "rightSet": [" rightPos", " rightEx", " rightGen", "leftGen", "rightSET", "blockPos", "rightGen", "blockSET", "rowPos", "rowGen", "blockSet", "blockHat", "rowSet", "rowHat", "leftEx", " rightSET", "rightEx", "rowSET", " rightHat", "rightPos", "rowEx", "rightHat"], "farRightSet": [" farLeftSet", "farRUse", "farrightUse", "farrightset", "farLeftset", " farRightset", "farrightSet", " farRightForce", "farRForce", "farRoleSet", " farrightset", "farRset", " farRightUse", "farRoleForce", " farLeftUse", "farRSet", "farRoleset", " farLeftset", "farLeftUse", "farRightset", "farLeftSet", " farrightForce", " farrightSet", "farrightForce", "farRightUse", "farRightForce"], "vowelSet": ["vowsellMap", "vowsellSet", "vowellSet", "vowellBase", "vowelsUse", "vowelUse", "vowilMap", "vowelsBase", "vowselSet", "voxellBase", "vowselMap", "voxellUse", "vowellMap", "vowselList", "voxelBase", "vowleUse", "voxelSet", "vowelsMap", "vowilSet", "vowelBase", "vowleBase", "voxelUse", "voxellSet", "vowsellList", "vowelsSet", "vowellUse", "vowelsList", "vowleSet", "vowelMap", "vowelList", "vowellList", "vowilList"], "ntk": ["detkid", "ptykn", "ntik", "ontk", "enttek", "ntks", "rentp", "gtik", "detkar", "mdik", "mdok", "ftok", "ntq", "osskw", "ntK", "nextkn", " syntmk", "rentok", "retk", "rettk", "rentk", "renttek", "gtq", "gtkn", "ontkj", "etk", "retok", "ntcp", "ntok", "rentK", "ontak", "montkn", "ptykar", "retkar", "entik", "renty", "ntr", "ontz", "gtcp", "ptyok", " etok", " etik", "otq", "ntmk", "oddkar", "nextkar", "ftkw", "ptyak", "gtk", " syntok", "cmdik", "gtke", "gtK", " etk", "montk", "entz", " etkw", "otik", "ntkar", "ossk", "entK", "retik", "entk", "detK", "retch", "ontik", "montq", "cmdK", "cmdk", "ontkn", "nttek", "ontkr", "ptp", "ntch", "ntp", "entch", "otk", "ptyk", "oddkid", "nnkar", "ftmk", "cmdok", "otkn", "detok", "ptykr", "ntkid", "oddk", "ontch", "otK", "nnks", "ptyK", "nextkr", "nnk", "ontkar", "ossok", "detr", "rtok", "detk", "etmk", " syntkw", "montke", "rttk", "dettek", "rtk", "ontp", "otke", "ntkw", "mdk", "cmdak", "etkw", "rentkar", "rentik", "pty", "ntz", "ossik", "oddr", "otcp", "cmdcp", "onttk", "rentks", " syntk", "rtks", "ntak", "onty", "entok", "mdkw", "nnik", "ontkid", "ontK", "ftk", "ntkj", "rtkar", "ntkn", "ontok", "rtik", "ntkr", "ontr", "ntke", "ptk", "nttk", "nty", "etok", "rentkj", "ptkj", "nextk", "retz"], "maxEwtsVowelLength": ["maxEwtsVowylWidth", "maxEwtsVovelDuration", "maxEwtsVovellLength", "maxEwtsVoxalLen", "maxEwtsVowelDuration", "maxEwtsVowelslength", "maxEwtsVowellLength", "maxEwtsVowylLength", "maxEwtsVowellDuration", "maxEwtsVowalLen", "maxEwtsVowellWidth", "maxEwtsVovellWidth", "maxEwtsVowalLength", "maxEwtsVovelWidth", "maxEwtsVoxelLength", "maxEwtsVowelsLength", "maxEwtsVowelWidth", "maxEwtsVoxalWidth", "maxEwtsVoxalLength", "maxEwtsVowallength", "maxEwtsVovellLen", "maxEwtsVowelllength", "maxEwtsVowalDuration", "maxEwtsVowelLen", "maxEwtsVowelsLen", "maxEwtsVowellLen", "maxEwtsVowelsWidth", "maxEwtsVowylLen", "maxEwtsVoxallength", "maxEwtsVowalWidth", "maxEwtsVovelLength", "maxEwtsVowellength", "maxEwtsVovelLen", "maxEwtsVoxelWidth", "maxEwtsVoxellength", "maxEwtsVoxelLen", "maxEwtsVovellDuration", "maxEwtsVowylDuration"], "puncSet": ["paucGroup", "punctSet", "punctSetting", "paucBase", "ptcSetting", "pacSet", "pacGroup", "cpunctSetting", "cpuncSetting", "cpuncset", "pfuncSet", " pfuncBase", "pocoset", " pfuncGroup", "pfuncBase", " puncBase", "cpuncSet", "punctset", "puncset", "ptcSet", "ptcset", " puncGroup", "puncBase", "paucSet", "pocoSet", "puncGroup", " pfuncSet", "cpunctSet", "pocoSetting", "pacBase", "puncSetting", "pfuncGroup", "cpunctset"], "charSet": ["charList", "byteSet", "charset", " charLog", "characterSet", "byteset", "charBase", "characterLog", "CharacterSet", "CharSet", "Charset", "CharList", " charBase", "CharacterBase", "CharacterLog", " charset", " charList", "characterBase", "charLog", "byteList"], "tibSet": ["nibSet", " tibiSet", "tibChain", "tibiSum", " tibSum", "tibSum", "nibiSet", "tibiChain", "tiberSet", "nibEn", "tobEn", "tibiSet", "torgEn", "tilibChain", "tilibSum", "nibiEn", "tobSet", " tibChain", "tiberSum", "tibiEn", "tiberChain", " tibiChain", "torgSet", "tilibSet", " tibiSum", "tibEn"], "sanskritStackSet": ["sanskraStateHash", "sanskraStackSet", "sanskritStepBase", "sanskriticBase", "sanskritStackBase", "sanskritStateSet", "sanskritStepHash", "sanskraStackHash", "sanskritStateBase", "sanskraStateSet", "sanskriticHash", "sanskraStackBase", "sanskraStateBase", "sanskritStackHash", "sanskriticSet", "sanskritStateHash", "sanskritStepSet"]}}
{"id1": "14168494", "id2": "16388708", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" CopyFile", " copyfile", "CopyByte", "CopyStream", " copyStream", " cpfile", " cpStream", " CopyStream", " Copyfile", "CopyFile", " cpByte", "Copyfile", " CopyByte", " copyByte", " cpFile"], "dest": ["img", "np", "tmp", "Dest", "v", "trans", "etc", "des", "usr", "nom", "rest", "loc", "them", "temp", "result", "dir", "del", "origin", "gt", "out", "way", "www", "nt", "nw", "orig", "d", "target", "dist", "w", "st", "master", "to", "doc", "pub", "cont", "good", "source"], "src": ["sb", "img", "sr", "sc", "rx", "usr", "upload", "file", "loc", "sub", "sq", "sys", "input", "ls", "sl", "rc", "req", "start", "Source", "iv", "init", "sec", "cur", "rs", "rel", "desc", "st", "from", "ins", "sel", "inst", "cont", "ser", "source"], "srcChannel": ["rcMessage", "srcCommand", "rcChannel", "rcChan", " srcChan", "instChan", "srcChain", "rcchannel", "instCh", "sysChannel", "bgChain", "srcchannel", "sourceCh", "rcChain", "sysCommand", "syschannel", "destChannel", "instPanel", "bgChannel", " srcChain", "destChain", " srcchannel", "sqChain", "sourceChan", " srcCommand", "sysChan", "srcCh", "srcMessage", "sqCan", "instChannel", "instChain", "destChan", "sqPanel", "srcChan", "bgPanel", "srcCan", "instCan", "srcPanel", "destMessage", "sourceChannel", " srcCh", "rcCommand", "bgCan", "sqChannel", " srcMessage"], "dstChannel": ["dndClient", "dndChannel", " dotCh", "ddestChannel", " dotChannel", "dbrCh", "dotCh", "dotChannel", "dndCh", " dstButton", "pdestChannel", "pstClient", "pdestButton", " dotHandler", "dndButton", "dndChan", " dstChan", " dstCh", "pdestClient", "destChannel", "dotChan", "destCommand", "dotHandler", " dotButton", "ddestClient", "pdestCommand", "dndCommand", "ddestHandler", "dbrHandler", "dstButton", "dstClient", "dbrChan", "dstCh", "ddestChan", "dbrChannel", "pstButton", "dotButton", "ddestCh", "dstChan", "ddestCommand", "destClient", "pstChannel", " dstHandler", " dotChan", "dstHandler", "dstCommand", "destButton", "ddestButton", "pstCommand"]}}
{"id1": "620855", "id2": "9210168", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionUpdate", "DoDateFix", "DoDatecheck", "doDateFix", "doVersionsCheck", "doDatecheck", "doDateUpdate", "DoDateCheck", "DoVersionCheck", "DoDateUpdate", "DoVersionUpdate", "doVersioncheck", "doDateCheck", "doLicenseFix", "doVersionscheck", "doLicenseUpdate", "DoVersionFix", "doVersionsFix", "doLicensecheck", "doLicenseCheck", "doVersionsUpdate", "DoVersioncheck", "doVersionFix"], "view": ["VIEW", "widget", "cv", "v", "buffer", "manager", "View", "host", "views", "tree", "help", "html", "server", "controller", "this", "eye", "file", "blade", "document", "image", "print", "review", "self", "component", "web", "cell", "console", "q", "update", "out", "client", "browser", "iew", "input", "index", "check", "open", "util", "engine", "layout", "get", "wrapper", "http", "row", "query", "hl", "tv", "block", "context", "display", "report", "subject", "show", "doc", "see", "call", "table", "model", "window", "page", "form"], "url": ["lb", "dl", "location", "v", "org", "ul", "rl", "host", "nl", "mount", "str", "html", "id", "log", "file", "loc", "lr", "l", "b", "language", "gl", "web", "uri", "string", "oul", "r", "client", "ssl", "browser", "path", "ls", "sl", "address", "bel", "ur", "date", "f", "pl", "github", "http", "json", "hl", "ll", "link", "rel", "URL", "char", "null", "socket", "Url"], "in": ["reader", "mat", "din", " din", "stream", "asin", "inc", "isin", "rin", "file", "l", "b", "inner", "ln", "inf", "ain", "body", "vin", "source", "out", "is", "input", " IN", "In", "n", "gin", "f", "init", "info", "IN", "mn", "ins", "inn", "cin", "i", "sin", "kin"], "bin": ["bg", "binary", "reader", "buffer", "din", "bi", " din", "conn", "bed", "lib", "pipe", "by", "buff", "sam", "rin", "file", "inner", "b", "ln", "stock", "spin", "loader", "out", "abin", "cache", "bl", "rb", "bur", "ran", "mem", "thin", "gin", "len", " bins", "win", "nb", "con", "local", "bn", "ebin", "inn", "cin", "cos", " Bin", "sin", "obin", "mon"], "line": ["level", "text", "le", "lin", "lane", "inline", "state", "range", "se", "point", "part", "base", "col", "column", "comment", " Line", "el", "file", "log", "liner", "LINE", "print", "l", "ln", "trace", "cell", "body", "iter", "Line", "string", "eline", "lo", "cmd", "section", "path", "ice", "ls", "no", "job", "err", "chain", "ine", "ide", "load", "frame", "channel", "row", "one", "record", "link", "sample", "block", "lines", "cat", "field", "char", "entry", "style", "store", "code", "port", "word", "page"], "version": ["vers", "scale", "river", "license", "v", "usage", "type", "serial", "status", "translation", "ver", "VER", "volume", "release", "vision", "software", "test", "python", "image", "language", "string", "update", "client", "versions", "virtual", "browser", "iso", "hash", "video", "index", "major", "title", "spec", "name", "format", "command", "Version", "position", "project", "feature", "date", "description", "match", "number", "value", "info", "tag", "sequence", "latest", "VERSION", "resource", "ion", "key", "form"], "build": ["th", "bor", "ship", "uild", "where", "binary", "unit", "boost", "built", "ver", "lib", "dev", "release", "full", "log", "test", "print", "add", "b", "update", "install", "hash", "work", "hold", "util", "develop", "ble", "old", "Build", "builder", "arch", "project", "date", "use", "load", "building", "match", "bug", "dist", "be", "tag", "link", "ward", "latest", "struct", "round", "style", "last", "fail", "make", "db", "other"]}}
{"id1": "21491791", "id2": "3495460", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"run": ["exit", "unit", "test", "su", "Run", "cmd", "running", "work", "par", "don", "eval", "name", "command", "un", "exec", "use", "execute", "runs", "pre", "apply", "fun", "runner", "process", "call", "system"], "input": ["history", "parse", "text", " inputs", "io", "request", "read", "state", "in", "view", "active", "stream", "data", "back", "select", "upload", "file", "print", "image", "inner", "before", "action", "iter", "client", "out", "audio", "index", "partial", "address", "start", "Input", "feed", "http", "json", "hello", "info", "hub", "local", "it", "internal", "context", "from", "readable", "initial", "config", "table", "xml", "cont", "background", "source", "form", "system"], "output": ["generated", "text", "four", "exit", "io", "memory", "binary", "write", "oe", "stream", "connection", "data", "column", "external", "log", "file", "print", "image", "web", "result", "console", "update", "out", "hidden", "Output", "put", "admin", "success", "format", "command", "export", "header", "network", "target", "o", "directory", "net", "response", "block", "you", "display", "latest", "ilo", "config", "table", "port", "ou", "source", "filename", "outer"], "reader": ["read", "manager", "dr", "worker", "in", "stream", "data", "usr", "rx", "controller", "file", "inner", "draw", "loader", "Reader", "ro", "iter", "parser", "client", "r", "proc", "driver", "rar", "er", "builder", "wrapper", "row", "penter", "reading", "rw", "context", "readable", "entry", "handler", "table", "owner", "ter", "resource", "window", "system", "iterator"], "writer": ["written", "println", "widget", "window", "write", "worker", "manager", "close", "wire", "pipe", "connection", "server", "file", "draw", "loader", "adder", "creator", "storage", "out", "client", "driver", "player", "riter", "writing", "variable", "builder", "yard", "handle", "wrapper", "processor", "writ", "caster", "Writer", "network", "service", "target", "penter", "rw", "w", "writers", "store", "handler", "holder", "ter", "wrote", "ser", "word", "outer", "iterator"], "pump": ["pamp", "deter", "cUMP", " pipe", " pumps", " pong", "prong", "prump", " pamp", "PUMP", "cump", "damp", "Pmp", "pipe", "peumper", "psumper", " pUMP", "pong", "Pump", "cumper", "dump", "dumper", " peter", "psipe", "prodge", "psump", "pumps", "pemp", " pumper", "camp", "pmp", "pumper", "pripe", "Pipe", "peumps", "Pong", "Podge", "peump", "pUMP", " podge", "Peter", "peter", "psamp", "Pumper", " pmp", "Pumps", "podge", "Pamp"], "counter": ["ctr", "responsible", "memory", "scope", "column", "batch", "currency", "term", "conv", "loop", "buster", "processor", "row", "message", "condition", "parent", "outer", "system", "history", "frequency", "clock", "seen", "book", "ounter", "card", "collection", "inner", "Counter", "timer", "loader", "cell", "client", "pointer", "index", "time", "amount", "cookie", "record", "context", "entry", "walker", "count", "controller", "comment", "total", "phrase", "continue", "hash", "created", "thread", "vector", "page", "key", "peer", "encrypted", "average", "const", "common", "recorded", "console", "radius", "zero", "description", "number", "container", "sequence", "random", "second", "code", "unique", "ter", "current"], "buffer": ["text", "Buffer", "uffer", "binary", "data", "buff", "base", "length", "batch", "document", "phrase", "b", "result", "queue", "uf", "address", "command", "buf", "value", "row", "size", "block", "context", "message", "sequence", "bytes", "vector", "table", "source", "key", "header"], "off": ["ip", "Off", "aff", "oct", "ff", "pos", "now", "Offset", "before", "OFF", "oa", " Off", "origin", "cmd", "offer", "ow", "shift", "no", "att", " offset", "end", "art", "op", "hand", "un", "of", "after", "offs", " OFF", "fun", "offset", "ap", "eff", "set", "def"], "len": ["eff", "compl", "lp", "written", "le", "cl", "pent", "mat", "lon", "enc", "lib", "nl", "bf", "length", "pos", "wl", "en", "mult", "l", "ln", "body", "vec", "del", "line", "lan", "ls", "lf", "cond", "lvl", "elt", "end", "mem", "buf", "coll", "all", "val", "ld", "kl", "ll", "fin", "size", "vol", "fun", "rel", "fl", "bytes", "offset", "Len", "alt"], "rd": ["ird", "rid", "RD", "bd", "ard", "R", "sr", "cd", "dr", "rl", "sd", "mr", "rez", "md", "ind", "lr", "udd", "dd", "xd", "dra", "dig", "r", "nd", "adr", "hr", "rb", "rc", "rh", "ptr", "d", "rt", "ld", "rs", "mn", "rw", "rand", "rr", "cr", "red", "rn", "ri", "rod"]}}
{"id1": "160739", "id2": "14191679", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputFile", "createInputSteam", " createOutFile", " createInputstream", " createOutputstream", " createInputFile", "createInputstream", " createOutputSteam", " createFileSteam", " createOutStream", "createOutputFile", "createInputStream", "createOutputSteam", " createFileFile", " createInputSteam", " createOutSteam", " createInputStream", " createOutstream", " createOutputFile", " createFilestream", " createFileStream", "createOutputstream"], "inFile": [" inPath", " infile", "dinFile", "ninfile", " inDir", "dinPath", "infile", "ninFilename", "inPath", "outPath", "inputPort", "outFilename", " inPort", "dinDir", "inPort", "ninFile", "inputPath", "outfile", "ninPath", "inputFile", "inputDir", "inFilename", "inDir", " inFilename", "dinPort"], "outFile": ["outPlace", "newPlace", "toPort", "OutFilename", "tofile", "outputPlace", "infile", "OutFile", "newFilename", "outFilename", "toFile", "inPort", "toFilename", "outputfile", "newFile", "exfile", "outPort", "outfile", "exFile", "outputFile", "outputFilename", "OutPort", "inFilename", "Outfile", "exPlace", "newfile", "exFilename"], "k_blockSize": ["k_byteName", "k_BlockStyle", "k2blockSize", "k4blockName", "k_BlockName", "k4BlockName", "k_byteLength", "k2byteCount", "k_blockCount", "k_batchLength", "k_batchCount", "k4blockSize", "k4blockCount", "k2byteTime", "k_blockName", "k2byteSize", "k_BlockSize", "k_batchTime", "k2blockTime", "k2byteLength", "k4BlockCount", "k_BlockCount", "k_blockTime", "k4BlockSize", "k4BlockStyle", "k_blockLength", "k_byteTime", "k_batchSize", "k_byteCount", "k_byteSize", "k_BlockLength", "k_blockStyle", "k4blockStyle", "k2blockLength", "k2blockCount", "k_byteStyle", "k_BlockTime"], "byteCount": [" bytePtr", "bitN", "bitCounter", "linecount", "bitSize", "byteCheck", "bbCount", "byteCode", "byteCounter", "bitCode", "bitCount", " bytecount", "byteN", " byteCheck", "linePtr", "blockCount", "bbN", "charPtr", "lineLength", "charcount", "bbSize", "blockCounter", "wordCount", "wordN", "bytecount", "charCount", "wordSize", "bitCheck", "charLength", "lineCount", "wordCode", "bitLength", " byteCounter", "blockLength", "blockCheck", "bbCode", " byteLength", "byteSize", "byteLength", "bytePtr"], "buf": ["bg", "img", "ctr", "cv", "Buffer", "buffer", "arr", "ctx", "str", "buff", "Buff", "raw", "batch", "b", "bc", "vec", "cmd", "alph", "proc", "queue", "uf", "cb", "bl", "rb", "conv", "bag", "mem", "exp", "cast", "seq", "pkg", "cur", "pb", "block", "cap", "cat", "tx", "fg", "bytes", "doc", "db", "msg", "bn", "txt"], "ofp": ["Ofp", "Ofd", " ofd", "OFP", " ofpa", "ofl", "ofpa", "owld", "ofd", "ofP", "owlP", "owlp", "Ofpa", " ofl", "OFp", "Ofl", "owlpa", "OfP", " ofP", "OFd", "OFl"], "zos": ["tis", "gs", "zb", "LOS", "amia", "ps", "esa", "es", "bs", "zin", "js", "rez", "sbm", "os", "hz", "sis", "psy", "nz", "cz", "python", "south", "zen", "jp", "webkit", "ze", "zer", "sch", "zh", "hess", "oss", "zona", "bes", "zag", "ws", "ossus", "zzle", "eros", "zl", "enos", "init", "los", "ez", "jas", "zu", "rose", "std", "zik", "css", "za", "zers", "settings", "zon", "rss", "z", "osi", "socket", "zo", "cos", "zi", "zes", "zip", "zy"], "osw": ["aospace", "sysW", "osd", "aosw", "cosew", "issw", "osrw", "iswx", "osswx", " osws", "osiw", "ossW", "sysrw", "owa", "aosrw", "oswa", "aosew", "osws", "aosws", "aosW", " ossw", "aoswd", "ow", " osW", "oW", "isW", " oswx", "osiwa", "ossw", "osW", "cosws", "osssw", "aoswa", "isw", "osswd", "syswd", "opace", "ospace", "oswd", "sysw", "osiW", "cosw", " osew", "oswx", "osipace", "cosd", "osew", " osd", "aosd", "ossrw"], "bw": [" bws", "obz", "bbem", "besw", "bsw", "pbew", "abew", " bwl", "bend", "wbz", "bew", "obwl", "sbw", "bws", "bbz", "wbwp", "obwk", "bewl", " bx", "bwb", "wbx", "sbwb", " bwk", "obwb", "bwl", "wbend", "pbwe", "obwt", "pbwt", "pbwy", "pbz", "nbew", "bbwp", "bbwt", "bwk", "bbend", "bbex", "rbws", "nbw", "pbwb", "abwe", "rbw", "bbx", " bex", "nbwy", "bz", "bewk", "wbw", " bem", "pbw", "sbz", "nbwe", "bx", "rbz", "bex", "bem", "bwt", "bbw", " bend", "bwy", "wbwt", "wbem", " bsw", "obsw", "bwe", "abw", "rbex", "sbwt", "bbws", "bwp", " bwp", " bwt", "abwy", "obw", " bz"], "zot": ["zeronet", "Zote", "zipiot", "zoonet", " ziat", "zote", "ziat", "zeror", "zerot", "zerhot", " zonet", " ziot", " zhot", "Zit", "Zot", "zipiat", " zo", "zerote", "zoo", " zote", "zerit", "zor", "zhot", "zonet", "zero", "zoot", "Zott", "zipot", "ziot", "ziphot", "zoor", "zott", "zeriat", " zott", "zeriot", " zor", "zerott", "zo"], "ifp": ["Ifjp", "ifP", "iwr", "ifjp", " ifP", " ifjp", "isth", "ihr", "iwtp", "isp", "Ifp", "iftp", " ifr", " iftp", "isjp", "ifth", "ihtp", " ifth", "ifr", "ihp", "isP", "ifd", "Ifth", "IfP", "iwd", "iwp", "ihd", " ifd"], "zis": [" zIS", " zi", "izisa", "zoiss", "izinit", "zisc", " zic", "zinit", " zisc", "ziss", "zipis", "zeris", "zisa", "ziinit", "ezis", "zerIS", "zoisa", "zoinit", "zipic", "ezi", "zois", " ziss", "izi", "zic", "zipIS", "ziiss", "ezisc", "zIS", "eziss", "ziis", "ziisa", "iziss", "zi", "izisc", "izis", "zeric"], "isr": ["itsr", " isrs", " iscr", "itsstr", "ispr", "issrs", "iosr", "isalstr", "sisrs", "sisr", "isalpr", "isalr", "isrc", "isalsr", "isstr", "iosstr", "iscr", " isrc", "itspr", "sisrc", "isrs", "iospr", "itssr", "siscr", "issr", "iossr", "isscr", "issrc"], "br": ["fr", "bd", "ctr", "vr", "gr", "Br", "sr", "bm", "dr", "bh", "ba", "bi", "shr", "mr", "js", "str", "bf", " Br", "lr", "pr", "b", "bt", "wr", "ber", "obl", "yr", "r", "tr", "hr", "bl", "rb", "ptr", "bro", "bj", "bp", "rel", "cr", "Fr", "BR", "bn", "kr"], "zit": ["ziti", "zeip", "izip", "zist", "ozit", "czot", "oziti", "zop", "ozip", "czunit", "zipit", "ziit", "zipIT", "ziist", "czit", " zop", "cziti", "lexIT", "zip", " zIT", "ezIT", "zlit", "zunit", "zipite", "lexIt", "ziIt", "lexit", "zipist", "czop", "zipIt", " zip", "iziti", "zeit", "czip", "izit", "ziplit", "zeop", "zIt", "zeot", "ezlit", " zlit", "zIT", "ezit", "ziIT", "ozunit", "zite", " zite", "ezite", "izunit", "lexist"]}}
{"id1": "14783950", "id2": "13757855", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["composeWithzip", "compressWithzip", "compresswithExt", "composeWithZip", "compressByExt", "composeWithExt", "compressWithExt", "compressWithFiles", "composeWithoutExt", "compresswithFiles", "compressByZip", "composeWithFiles", "composeWithoutZip", "compressByzip", "compresswithZip", "compressByFiles", "compressWithoutzip", "compresswithzip", "compressWithoutExt", "composeWithoutFiles", "composeWithoutzip", "compressWithoutZip", "compressWithoutFiles"], "fileList": [" FileLIST", "fileL", "fileIterator", "tileLIST", "pageList", "itemNames", "fileSet", "pageCode", "fileLIST", "fileCode", "pageLIST", "tileIterator", " fileLIST", "pagelist", " fileCode", "resourceNames", " fileIterator", "ileLIST", "itemList", "fileLock", "wordLIST", "pageL", " FileList", "filelist", "resourceLock", " fileSet", "wordList", "wordIterator", "fileNames", "itemLock", "wordSet", " fileL", "ileL", " FileSet", " filelist", " fileLock", "ileList", "pageSet", " fileNames", " FileCode", "ilelist", "tileSet", "tileList", "resourceList"], "zipFileName": ["zFilenameName", "zipFilenamePath", "zFileFilename", "zipFilenameName", "zipDirName", " zipFileNames", "zipfileName", "zFilenamename", "zipFileNames", "zFileName", " zipFileFilename", "zipfileFilename", "zFilename", "zipDirPath", "zipFilenamename", "zFilePath", "zipFilePath", "zipFileFilename", " zipFilePath", "zFilenameFilename", " zipfilePath", "zipileName", "zipfilePath", "zipfileNames", "zipilename", " zipfileName", "zipDirNames", "zipileFilename", " zipfileNames", " zipfileFilename", "zipilePath", "zipFilenameNames", "zipFilename", "zFilenamePath", "zipDirFilename", "zipFilenameFilename", "zipfilename"], "fos": ["loos", "flis", "lfos", "lOS", "Foos", "flOS", "Foss", "FOS", " foos", " fOS", "woss", "lfOS", "foss", "Fos", "wOS", "floos", "fOS", "flos", "los", "lfoos", "foos", "woos", "lfis", "loss", "wos"], "zos": ["zb", "ss", "zar", "ps", "zan", "Sax", "iners", "es", "zin", "js", "rez", "sbm", "sis", "hz", "os", "ippers", "nz", "cz", "zen", "webkit", "ze", "zip", "zer", "zh", "hess", "oss", "ess", "han", "bes", "zero", "zag", "ws", "ossus", "zzle", "eros", "iaz", "enos", "ses", "los", "ez", "jas", "zu", "css", "za", "enz", "zers", "zon", "z", "rys", "zo", "zes", "zi", "zik", "less"], "iter": ["ip", "ator", "li", "former", "cer", "ger", "where", "fer", "reader", "ver", "re", "Iterator", "gener", "orient", "order", "user", "el", "inter", "loc", "ipper", "oper", "inner", "ait", "izer", "Iter", "loader", "kit", "ner", "is", "tr", "er", "ptr", "loop", "its", "exp", "maker", "coll", "iv", "train", "list", "it", "vis", "valid", "ir", "iner", "ee", "walker", "i", "ter", "iver", "ser", "liter", "here", "outer", "iterator"], "fileName": ["fieldname", "FileString", "fNumber", "ileCurrent", "localNAME", " fileNumber", "fileSet", "fileStore", "shortStore", "ileString", "fBody", "getname", "fName", "getSource", "localname", "ileNAME", "ileBody", "localName", " fileSource", "shortSource", "fNames", " fileStore", "ilename", "tableName", "fileBody", "fieldList", "FilePath", "FileName", "ilePath", "FileCurrent", "fileCurrent", "fileNumber", "fileNAME", "fSource", "filePath", " fileSet", "fileSource", "fileNames", "tableSet", "ileSet", "ileName", "fieldNAME", " filePath", " fileString", " fileCurrent", " fileBody", "fileString", "FileNames", " fileNames", "ileSource", "ileList", "Filename", "getStore", "getName", "tablePath", "fString", "fname", "localList", "fieldName", "shortname", " filename", "filename", "ileNumber"], "ind": ["count", "cd", "kind", "med", "td", "pred", "inder", "bind", "md", "Ind", "inc", "pos", "butt", "stick", "div", "loc", "mod", "hend", "draw", "ent", "cod", "cand", "sign", "nd", "index", "cond", "IND", "att", "mind", "n", "ptr", "req", "typ", "d", "pl", "find", "ld", "wind", "num", "j", "dial", "roll", "inn", "red", "i", "seed", "dj", "ded"], "shortName": ["shortType", " shortKey", "shortFilename", "ShortType", "ShortCode", "fullType", "shortKey", "quickString", "smallCode", "fullName", "smallName", "recentname", "smallFilename", "recentFilename", "ShortKey", " shortType", "ShortString", "recentCode", "quickname", " shortString", "fullString", "shortString", "smallname", "shortCode", "fullname", "Shortname", "quickKey", " shortname", "quickName", "ShortFilename", "shortname", "recentName", "ShortName"], "fis": ["ufois", "sfIs", "pris", "sfis", "wois", "ufi", "cfris", "ufris", "ufIs", "sfi", "fois", "hi", "ufis", " fris", "FIs", "pi", "hris", " fIs", "wi", "Fris", "cfois", "wis", "his", "wIs", "pois", "cfis", "fIs", "Fis", "fi", "hois", "cfi", "pis", "sfois", "fris"], "buf": ["img", "cv", "Buffer", "buffer", "bin", "wb", "arr", "bed", "buff", "fb", "Buff", "batch", "b", "bus", "bc", "temp", "vec", "bar", "cmd", "uf", "tr", "cb", "br", "ref", "bl", "fam", "rb", "conv", "var", "bag", "mem", "orig", "aka", "seq", "pkg", "cur", "block", "cap", "cat", "fg", "bytes", "tab", "mu", "msg", "box", "db"], "bytesRead": ["blocksLoad", "blocksRead", "BytesWritten", "bytesNeed", "postsLoad", "bytesLoad", "BytesLength", " bytesNeed", " bytesLength", "usersReady", "postsFind", "secondsWritten", "BytesRead", "postsRead", "flowsLoad", " bytesLoad", "blocksWritten", "bytesFind", "postsReady", "flowsFind", "BytesNeed", "usersFind", " bytesWrite", "bytesWritten", "linesWritten", " bytesWritten", "secondsRead", "linesLength", "bytesWrite", "secondsWrite", "usersRead", "secondsLoad", "flowsRead", "linesRead", "bytesLength", "blocksWrite", "bytesReady", "usersLoad", "flowsReady", "linesNeed"]}}
{"id1": "16572931", "id2": "16719805", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"unJar": ["unExt", "UnExt", "UnPath", "UnJar", " unExt", "unZip", " unPath", "removeZip", "unPath", "UnZip", "removePath", " unZip", "removeExt", "removeJar"], "jarPath": ["bareFull", "jarHost", " jarFile", "jobPath", "javaFull", " jarInfo", "javaLocation", "jarName", " jarBase", "jarBase", "jarFile", "javaName", "reportUrl", "browserName", "browserInfo", "pkgPath", "carpath", "barePath", "browserPath", "jarpath", "bareHost", " jarUrl", "pkgName", "carBase", "javaHost", "jobLocation", "pkgInfo", " jarName", "javaInfo", "jHost", "relInfo", "javaUrl", "javaBase", "carName", " jarLocation", "reportPath", " jarHome", " jarpath", "reportName", "jobFile", "relpath", "jName", "jarHome", "jarFull", "jFull", "javaFile", "jarUrl", "javapath", "javaPath", "jPath", "bareName", "carPath", "jarLocation", "browserUrl", "relHome", "jarInfo", "browserpath", "reportpath", "pkgpath", "browserHome", "jobpath"], "jarEntry": ["browserEnter", "JarEnt", "jEntry", "reportentry", "certName", " jarInfo", "jitInfo", "jarName", "springEntry", "jarPost", "reportEnt", "jarEnter", "javaEnt", "browserName", "browserInfo", "javaItem", "sessionName", "javaEntry", "springentry", "browserEntry", "springItem", " jarentry", "certentry", "javaPost", "sessionEnt", "jitEnter", "browserentry", "JarPost", "jentry", "jarEnt", "jitEnt", " jarName", "jobEntry", "jarItem", "sessionEntry", "jEnt", "jobEnt", "reportEntry", "sessionentry", "Jarentry", "jitEntry", " jarEnter", "springEnt", "jItem", "browserEnt", "certEnt", "reportPost", "JarEntry", "jarInfo", "jobPost", "browserPost", "jarentry", "javaentry", " jarEnt", "certEntry"], "path": ["text", "location", "min", "near", "PATH", "mount", "data", "select", "full", "with", "left", "hex", "trace", "dir", "cmd", "address", "position", "room", "message", "output", "parent", "history", "host", "order", "core", "this", "file", "join", "prefix", "temp", "transform", "client", "pattern", "x", "distance", "index", "pi", "root", "context", "zip", "home", "where", "point", "tree", "id", "ath", "self", "route", "walk", "at", "string", "check", "ref", "url", "p", "pkg", "relative", "value", "template", "api", "it", "to", "key", "set", "Path", "method", "phi", "base", "log", "test", "loc", "print", "input", "right", "partial", "title", "name", "format", "folder", "module", "empty", "port", "here"], "relPath": ["RELText", "elEntry", "elName", "Relpath", "RELPath", " relText", "RelName", "RELName", "RelEntry", "elpath", "relPort", " relpath", "relText", "RelPort", "relpath", " relName", "relName", "RELPort", "relEntry", "elPath", "RelPath", " relPort", "RelText", " relEntry"], "jar": ["jj", "car", "ja", "le", "ctr", "jet", "se", "lib", "archive", "batch", "jc", "jp", "bare", "war", "bar", "cp", "deb", "ie", "cert", "pack", "job", "java", "rar", "og", "tar", "bag", "jit", "pkg", "comp", "be", "vol", "sp", "sea", "j", "ar", "tab", "jo", "star", "zo", "Jar", "zip", "good"], "ze": ["le", "ae", "te", "se", "oe", "ne", "sle", "sk", "ce", "cz", "so", "e", "je", "zer", "ene", "ge", "ie", "ZE", "zing", "sl", "aze", "ve", "pe", "be", "ez", "ea", "ke", "za", "zie", "enz", "ee", "Ze", "jo", "z", "zed", "zo", "zi", "zes", "zip", "she", "zy"], "bin": ["bg", "pic", "binary", "din", "bi", "bm", "in", "lib", "bed", "buff", "sam", "pan", "b", "skin", "ln", "spin", "jin", "png", "bat", "pin", "abin", "dll", "bl", "thin", "gin", "bian", "di", "win", "bu", "con", "fin", "ebin", "cin", "db", " Bin", "ic", "box", "sin", "kin", "obin"]}}
{"id1": "13783898", "id2": "7425022", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "2521141", "id2": "21182766", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "label": 0, "substitutes": {"copy": ["sync", "save", "io", "create", "replace", "write", "close", "archive", "transfer", "select", "file", "upload", "download", "insert", "ate", "drop", "clip", "clone", "cp", "cop", "edit", "crop", "slice", "export", "get", "opy", "cut", "move", "paste", "load", "delete", "link", "Copy", "share", "zip", "source", "set", "remove"], "from_name": [" from_case", "from_Name", "from_no", " from_Name", "from_names", "fromamekey", " from_resource", "fromamefilename", "from_case", " from_info", " from_names", "from_filename", "fromkname", " from_part", " from_filename", " from_no", "fromameName", "fromkName", "fromkcase", " from_key", "from_resource", "from_part", "from_key", "fromkpart", "from_info", "fromamename"], "to_name": ["tolyfile", "to7get", "tolynumber", "eto_name", "to_new", "to_get", "tolynm", "toNamefile", "toNameget", "to7new", "to_Name", "eto_word", "toNamename", " to_number", "to_word", "to7file", "from_new", "from_get", "toNamenew", "to_number", " to_nm", "to_nm", "eto_Name", "tolyname", "to7name"], "from_file": ["fromsdir", "from_port", "or_name", " from_resource", "fromlyresource", "from_dir", "fromlyfile", " from_type", "from_node", "from_type", " from_time", " from_do", "fromlynode", "to_dir", " from_port", "or_run", " from_node", "from_do", "from_resource", "fromlyFile", "from_time", "fromsfile", "from_File", "or_File", "from_run", "or_file", " from_File", "fromsname"], "to_file": ["to_create", "that_File", "TO_element", "TO_port", "to_link", " to_create", "toJFile", "TO_file", "TO_name", "toJdrop", "to_files", "from_dir", "to_tree", "toJfile", "from_type", "to_element", " to_File", "to_drop", "to_base", "that_tree", "to_port", "to_dir", "that_link", "to_run", "TO_FILE", "to_type", " to_dir", " to_base", " to_run", " to_local", "to_FILE", "toJblock", "to_local", "to_block", "that_file", " to_drop", "to_File", " to_block", "TO_files"], "parent": ["parents", "ip", "peer", "pid", "unit", "where", "pa", "top", "instance", "default", "point", "mother", "part", "tree", "base", "id", "remote", "comment", "server", "user", "prop", "file", "test", "pool", "percent", "prefix", "temp", "form", "shape", "client", "child", "path", "paren", "family", "par", "chain", "spec", "name", "up", "global", "tar", "position", "params", "root", "p", "per", "folder", "ma", "timeout", "relative", "directory", "man", "event", "desc", "block", "def", "my", "null", "master", "holder", "page", "owner", "port", "sp", "cmp", "pixel", "rule", "source", "home", "Parent"], "dir": ["dep", "det", "cd", "wd", "dr", "dict", "part", "str", "md", "ind", "file", "div", "loc", "self", "mod", "dd", "iter", "del", "cmd", "path", "tr", "Dir", "cond", "DIR", "dim", "coll", "fd", "d", "folder", "init", "di", "directory", "dist", "module", "cur", "local", "rel", "vol", "ir", "rec", "addr", "red", "sp", "cont", "good", "db", "def"], "from": ["fr", "io", "bound", "or", "in", "se", "re", "stream", "back", "base", "user", "pos", "file", "with", "en", "func", "inner", "left", "error", "before", "so", "ent", "form", "out", "normal", "client", "ie", "no", "check", "term", "ra", "old", "From", "on", "start", "orig", "false", "init", "set", "query", "con", "local", "link", "vol", "fun", "st", "entry", "reset", "com", "style", "empty", "store", "window", "source", "by", "and"], "to": ["t", "TO", "stable", "top", "te", "can", "or", "tty", "po", "ne", "too", "base", "auto", "total", "tt", "please", "go", "b", "ato", "so", "e", "eto", "sys", "out", "client", "no", "two", "will", "pi", "nt", "To", "op", "on", "co", "pretty", "token", "ma", "target", "o", "tto", "toc", "output", "must", "that", "null", "ta", "table", "ts", "into", "by"], "buffer": ["binary", "memory", "Buffer", "stack", "buff", "base", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "word", "button", "bar", "queue", "stroke", "cache", "database", "command", "variable", "buf", "password", "paste", "frame", "character", "template", "row", "event", "sample", "block", "sequence", "message", "append", "char", "entry", "table", "function", "window", "page"], "bytes_read": ["bytes_range", "bytesyncread", " bytes_Read", "bytes2range", "words_write", "Bytes_read", "Bytes_write", "wordsyncread", " bytes2read", "wordsynclen", " bytes2write", "bytesynclen", "bytes2Read", "bytes__range", "words_len", "wordsyncwrite", "bytes2write", "bytes__Read", " bytes_write", "words_report", "bytes_run", "bytes2read", " bytes2Read", "bytes__read", "bytesyncreport", "bytes_Read", "bytes__write", "words_read", "Bytes_run", " bytes_range", "wordsyncreport", "bytes_write", "bytes_len", "bytesyncwrite", "bytes_report", " bytes2range"]}}
{"id1": "12236729", "id2": "12106167", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["read", " replicate", " combine", " duplicate", "transfer", " transfer", " dup", " cp", " restore", " cat", "cp", " copying", " Copy", " delete", " parallel", " download", " clone", " join", "paste", " seek", " upload", " operate", "Copy", " append", " paste", " recover", " merge", " move"], "inputFile": ["outputDir", "inile", "inputfile", "configPath", " inputPost", "argumentPath", " inputile", "configfile", "inputPost", "inPath", "argumentfile", "outputPath", " inputfile", "configPost", "inputPath", "configFile", "argumentFile", "argumentPost", " inputDir", "outputile", "inputDir", "inFile", "inDir", " inputPath", "inputile"], "outputFile": ["outPlace", "outputDir", "targetPath", "outFile", "outputPlace", " outputDir", "inputfile", "writePlace", "outPath", "outDir", "outFilename", "outputPath", "targetDir", "writeFile", "outputfile", "inputPath", "outfile", "targetfile", "outputFilename", " outputFilename", "inputDir", " outputPlace", "targetFile", "writeFilename", "writeDir"], "in": ["reader", "read", "bin", "din", "min", " din", "inc", "isin", "rin", "ind", "en", "inner", "ze", "inf", "inside", "iter", "is", "input", "al", "up", "In", "on", "old", "gin", "per", "init", "all", "info", "ini", "IN", "con", "it", "ir", "from", "ins", "inn", "cin", "ai", "i", "ic", "ri", "sin"], "out": ["io", "v", "dis", "can", "write", "OUT", "ne", "user", "os", "auto", "log", "en", "print", "at", "flush", "sys", "ot", "client", "cache", "check", "res", "end", "obj", "nt", "n", "on", "co", "o", "net", "con", "one", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "cos", "g", "writer", "ou", "aos", "by", "outer"], "c": ["t", "ct", "count", "cl", "v", "cd", "ac", "k", "uc", "u", "ce", "arc", "l", "cs", "bc", "mc", "cp", "cod", "r", "cc", "x", "cb", "gc", "cache", "cu", "rc", "chain", "ec", "n", "unc", "f", "d", "character", "conf", "con", "ch", "cm", "pc", "cap", "char", "z", "code", "nc", "cos", "C", "i", "cont", "cr", "current", "cf", "lc"]}}
{"id1": "16048516", "id2": "4461350", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"load": ["parse", "content", "create", " Load", "read", "build", " reconstruct", "upload", "download", "Load", "dump", " restore", "construct", "loader", " loader", "open", " download", "get", "init", "loads", " loads", "LOAD", " overload", " fill", "config", " loaded", " reload"], "urlConfiguracion": ["urlConfiguATION", "urlConfigulATION", "urlConfigURaton", "urlconfigoricion", "urlConfiguratable", "urlConfiguaton", "urlConfigureatable", "urlconfigurATION", "urlConfiguicion", "urlExecurateator", "urlconfiguATION", "urlConfigurateator", "urlconfiguricion", "urlExecurateaton", "urlconfiguaci", "urlConfiguriaton", "urlConfigruaton", "urlConfigurATION", "urlConfiguraci", "urlconfiguraci", "urlConfigulacion", "urlconfigoraton", "urlConfiguricion", "urlconfigoracion", "urlConfigruacion", "urlConfigURaci", "urlConfigureator", "urlConfigurateatable", "urlExecuracion", "urlconfiguaton", "urlConfiguraton", "urlConfigoraci", "urlconfiguacion", "urlConfigoraton", "urlExecurateatable", "urlConfiguriicion", "urlConfigurateacion", "urlConfigurateaton", "urlConfigureaton", "urlConfigulaton", "urlConfigruator", "urlConfigURATION", "urlConfiguriaci", "urlconfigoraci", "urlConfiguriacion", "urlConfigruatable", "urlconfiguracion", "urlExecuraton", "urlConfiguaci", "urlConfigurator", "urlExecuratable", "urlExecurator", "urlConfigureacion", "urlExecurateacion", "urlConfigoricion", "urlConfiguacion", "urlConfigulaci", "urlconfiguraton", "urlConfigoracion", "urlConfigURacion"], "configuracion": ["configureicion", "figuraton", "configurance", "configaurcation", "figureance", "configuratecation", "execurATION", "configureracion", "figuricion", "configuraci", " configureicion", "configurateacion", "configurableacion", "configureacion", " configureacion", "figuracion", "execurableATION", " configureaci", "configaurance", "configurerATION", " configuraton", "execurableaton", "execuration", " configuricion", "configurableaton", "configurcation", "configuacion", " configureATION", "configuraton", "configurateaci", "configauraci", "configureATION", "execurableation", " configuraci", "figureicion", "configurationaton", "figurance", " configurATION", "execuracion", "configuricion", "figureacion", "configurableation", " configurcation", "configurATION", "configurericion", "configurationicion", "configureraton", " configureaton", "configurecation", "configurationacion", "configuaton", "configureaci", "figureaton", "configuration", "configureance", "configurateaton", "configauricion", "configurationATION", "execurableacion", "configuicion", "configureation", "configuance", "configureaton", "configurableATION", "configauraton", "configurationation", "execuraton", " configurecation", "configauracion"], "xenc": ["axdec", "uxenc", " xen", "axorc", "axvec", "xtdec", "rxenc", "xtenc", "Xenc", "Xen", "XEnc", "Xec", " xdec", "uxorc", "Xdec", "xorc", " xorc", "xdec", "xtEnc", "xvec", "xEnc", "xen", "xec", "axenc", "uxvec", " xvec", "rxen", "rxEnc", " xEnc", "rxec", " xec", "uxdec", "xten"]}}
{"id1": "19687456", "id2": "10158738", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"testReadPerMemberSixSmall": [" testReadPermemberEightsmall", " testReadPerMemberSixLarge", " testReadPerMembersixsmall", " testReadPermemberSixSmall", " testReadPerMemberSixsmall", " testReadPerMembersixSmall", " testReadPerMembersixLarge", " testReadPerMemberEightSmall", " testReadPermemberEightLarge", " testReadPerMemberEightMember", " testReadPermemberEightSmall", " testReadPerMemberSixMember", " testReadPerMembersixMember", " testReadPermemberEightMember", " testReadPerMemberEightsmall", " testReadPermemberSixsmall", " testReadPermemberSixMember", " testReadPerMemberEightLarge", " testReadPermemberSixLarge"], "gzin": ["zipisin", "cliin", "zaginner", "urgin", "zagpin", "zagins", "gtIN", "gzisin", "gtcin", "zipcin", "gzIn", "gifIN", "cliIN", "zagnin", "urgins", "gtnin", "gdins", "gzcin", "gzIN", "qusin", "gcin", "zagadd", "cfgin", "gcIn", "gifinner", "gifins", "gifIn", "gifin", "gznin", "ctxins", "gtIn", "gifadd", "gilin", "gilvin", "gzadd", "gtgen", "cliins", "gtin", "respvin", "gilisin", "gzins", "gdinner", "gcIN", "zagin", "gcins", "respin", "zaggen", "ctxIN", "zcin", "gilcin", "gzpin", "gzinner", "urgIN", "cfgcin", "znin", "gdin", "zin", "gifcin", "gdcin", "qusisin", "quscin", "zipin", "zagcin", "cfgins", "gzgen", "gtins", "cfgadd", "ctxin", "gilpin", "gzvin", "zagvin", "resppin", "zgen"], "i": ["ip", "li", "y", "v", "ii", "phi", "multi", "mill", "I", "id", "u", "ui", "ind", "go", "batch", "print", "gu", "gi", "im", "q", "client", "x", "is", "index", "ci", "pi", "chain", "n", "me", "p", "qi", "init", "ix", "di", "ini", "it", "sim", "j", "ex", "wait", "m", "ai", " j", "us", "ic", "ms"], "count2": ["found2", "countTwo", "count1", "count4", "const5", "ount2", "const2", "Count4", "constTwo", " countTwo", "Count1", "ount5", "found4", "Count2", "ountTwo", "found1", " count5", " count1", " count4", "count5"], "count3": ["countThree", " countThree", "ount313", "currencyThree", "ountthree", "ount43", "trust43", "currencythree", "command3", "ountThree", "countthree", "count313", "trust3", "currency3", "count43", "ount3", "command43", "trustthree", "currency313", " countthree", "commandthree", " count313"], "countEnd": [" countend", "countend", "CountEnd", "CountEND", "ountend", "detailEND", "foundend", "detailend", "foundEnd", "detailBegin", "ountBegin", "Countend", "ountEND", "countEND", "foundBegin", "ountEnd", " countBegin", "foundEND", "countBegin", " countEND", "detailEnd", "CountBegin"]}}
{"id1": "4602568", "id2": "18782385", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"storeImage": ["StoreFile", "saveImages", "StoreImages", " storeImages", "storeFile", "StorePicture", "storeImages", " storeFile", " storePicture", "saveFile", "StoreImage", "savePicture", "saveImage", "storePicture"], "inStream": ["cinView", " inSteam", "outFile", " inFile", " inForm", "cinSteam", "cinFile", "inSteam", " inView", "outSteam", "fileStream", "fileFile", "inputStream", "inForm", "fileSteam", "inputFile", "inputView", "fileForm", "inFile", "inputSteam", "cinStream", "outForm", "inView"], "fileName": ["fileType", "imageInfo", " fileInfo", "FileType", "imagename", "FILEPath", "FilePath", "imageName", "FileName", "imageTime", "resourcePath", "FILEName", "imagePath", "filePath", " filePath", "FileInfo", "imageType", "FileTime", "fileTime", "resourceTime", "fileInfo", "FILEInfo", "resourceType", "Filename", " fileType", "resourceName", "FILEname", " filename", "filename"], "resize": ["renized", " resized", " resizes", "renize", "renizes", "resizes", "Resized", "Ressize", "rensize", " ressize", "resized", "ressize", "Resizes", "Resize"], "rightNow": ["westNow", "rServer", "rightCurrent", "rightFuture", "correctToday", "RightCurrent", "rNOW", " rightNOW", "RightToday", "correctFuture", "RightNow", "rNow", "westThen", "westFuture", "rightServer", "westCurrent", "correctNOW", " rightThen", " RightThen", " RightNOW", " RightCurrent", " rightToday", " rightFuture", "rightNOW", " rightServer", "westToday", " RightNow", "rightToday", "westServer", "rToday", "correctNow", " rightCurrent", "westNOW", "rightThen", "RightFuture"], "dayNamedFolderName": ["dayNamedFolderNames", "dayNamingDirectoryNames", "dayNamingFileNames", "dayNamedDirectoryName", "dayNamedFileSize", "dayNamingDirectory1", "dayNamedFoldername", "dayNamedFilePath", "dayNamedDirectoryname", "dayNamingFileName", "dayNamedFileNames", "dayNamedFileName", "dayNamedFolder1", "dayNamedThemeNames", "dayNamingDirectoryname", "dayNamedDirectory1", "dayNamedThemeSize", "dayNamingFilePath", "dayNamingFolderSize", "dayNamedfoldername", "dayNamedAreaname", "dayNamedAreaNames", "dayNamedAreaName", "dayNamingFoldername", "dayNamedfolder1", "dayNamedThemename", "dayNamingFileSize", "dayNamedfolderName", "dayNamingDirectoryName", "dayNamedDirectoryNames", "dayNamingFolder1", "dayNamingFolderName", "dayNamedFolderSize", "dayNamingFilename", "dayNamedThemePath", "dayNamedfolderNames", "dayNamedFilename", "dayNamedfolderPath", "dayNamedThemeName", "dayNamedArea1", "dayNamingFolderPath", "dayNamedFolderPath", "dayNamingFolderNames"], "uploadDirRoot": ["uploadDirectoryRoot", "UploadDbBase", " uploadRelPath", "saveDirRoot", "uploadUrlParent", "uploadDirParent", "UploadDirCover", "saveDbroot", "saveDirroot", "uploadNetBase", "uploadFolderRoot", "uploadDirBase", "uploadDbroot", "UploadDbRoot", "uploadDirPath", "uploadFolderroot", "uploadUrlBase", "uploadNetCover", "uploadRelBase", "uploadDbBase", "uploadUrlRoot", "UploadDirroot", "UploadDbCover", "uploadDirectoryroot", "uploadFolderPath", "uploadNetRoot", "uploadDbRoot", "uploaddirCover", "saveDirParent", "uploadDbParent", " uploadDirPath", "uploadFolderBase", "uploadNetroot", " uploadRelroot", "uploaddirRoot", "saveDbRoot", "uploadRelroot", "uploadDbCover", "uploadUrlPath", "UploadDirRoot", "uploadDirCover", "uploadRelPath", " uploadRelRoot", "uploaddirroot", "uploadRelRoot", " uploadRelBase", "uploadDirroot", "saveDbParent", "uploaddirBase", "uploadDirectoryParent", "UploadDirBase", "UploadDbroot", " uploadDirBase", " uploadDirroot", "uploadUrlroot"], "file": ["t", "type", "top", "run", "tree", "base", "FILE", "full", "el", "File", "pool", "image", "dir", "il", "source", "ile", "no", "time", "work", "open", "entity", "name", "up", "op", "handle", "project", "get", "f", "folder", "channel", "force", "local", "link", "null", "to", "table", "resource", "parent", "port", "node", "task", "page", "key", "h", "class"], "extension": ["expention", "exention", "EXTend", "dimensions", "expended", "expensions", "xtended", "dimension", "EXTension", "EXTended", "exendant", "dimention", "EXTention", "extensions", "expend", "xtend", "expendant", "extend", "exensions", "extendant", "extended", "xtention", "extention", "xtension", "expension", "exension", "dimendant"], "outFileName": ["outFileInfo", "outLinename", " outFilename", "OUTFieldName", "outDirName", "OutFileKey", "outLineNames", "OUTLogPath", " outLogname", "outLogName", "outLogVersion", "outFieldname", "outFileKey", "OutFileName", "OUTFilePath", "infileType", "outLogPath", "inFileType", "outDirPath", "OUTLogname", "outImageKey", " outLogNames", "OUTFieldname", "outFieldName", "outLogKey", "outFilenameName", "outFileVersion", "outfilePath", "inFileName", "outFilesName", "OutFilePath", "outFilenameKey", "outDirname", " outLineInfo", "outfileName", "Outfilename", "outfilename", "outfileVersion", "outLogname", "outFilenameInfo", "outImagename", "outFilenameNames", "outfileKey", "outFilenameSize", "outImageNames", "infilename", " outLogName", "outLineKey", "inFilename", "outFilenamename", "outFilenameVersion", "outFilesname", "inFileSize", " outLinePath", " outLineName", "outFilenamePath", "infileSize", "OUTLogName", "outFilenameType", "OutfileName", "outFileNames", " outFileVersion", " outFileInfo", "OUTFieldPath", "OUTLogKey", "outFilesPath", " outFilePath", "outFieldPath", "outfileType", "OutfilePath", " outFileNames", "OUTFileName", "outLineInfo", "infileName", "OutFilename", "OutfileKey", "outFileType", " outLineNames", "outFilename", "outImageInfo", "outfileNames", " outLogVersion", "outFieldSize", "outFileSize", "outLogNames", "outImageName", "outLinePath", "outLineName", "OUTFilename", "OUTFileKey", "outImagePath", "outfileSize", "outFilePath", "outFieldType"], "outPathAndName": ["outPortAndName", "outPathOrKey", "outPathOrNames", "outTimeButName", "outPathANDName", "outPortAndPath", "outTimeAndLike", "outPathOrLike", "outPortButName", "outLocationAndKey", "outLocationandNames", "outLocationAndName", "outTimeAndPath", "outPathButName", "outPathAndTime", "outPathandSize", "outTimeButLike", "outPathButTime", "outPathANDLike", "outPathandNames", "outPathAndKey", "outTimeAndTime", "outPathAndPath", "outTimeButTime", "outPathButLike", "outPortButKey", "outPathOrName", "outPathandName", "outLocationandSize", "outPathAndNames", "outPathandPath", "outPathButKey", "outTimeButPath", "outPathOrSize", "outLocationandName", "outPathButPath", "outPathAndSize", "outPathAndLike", "outPathANDPath", "outPathOrTime", "outPortButPath", "outPathandKey", "outTimeAndName", "outPathOrPath", "outPathANDTime", "outLocationandKey", "outLocationAndSize", "outPortAndKey", "outLocationAndNames"], "uploadedFile": ["presentedfile", "uploadiedFile", "presentedFILE", "uploadededFormat", " uploadededLine", " uploadedifiedF", "uploadpedLine", "uploadiedF", " uploadededF", "uploadedGlobal", "presenttedField", "presenttedfile", "uploadmedFile", " uploadededFile", " uploadedifiedUnit", "uploadashedfile", "uploadedF", "uploadashedFile", "presentedFile", "uploaderfile", "uploadedLine", "uploadredGlobal", "uploadredFile", "uploadededPlace", "uploadtedfile", "presenttedFILE", "uploadedField", "presenttedFile", "uploadtedFILE", "uploadifiedLine", "uploadiedLine", " UploadmedPlace", "uploadashedField", "uploadredPlace", "uploaderField", " UploadmedFormat", "uploadpedUnit", " UploadedGlobal", "uploadashedFILE", "uploadedUnit", " UploadmedGlobal", " UploadedPlace", "uploadmedFormat", "uploadedfile", "uploaderFILE", "uploadifiedUnit", " uploadededUnit", "uploadmedPlace", "uploadtedFile", "uploadedFILE", " uploadedifiedLine", "uploadmedGlobal", "uploadredFormat", " UploadmedFile", "uploadededFile", "presentedField", "uploadifiedFile", "uploadpedF", "uploadedPlace", "uploadiedUnit", " UploadedFormat", "uploadifiedF", "uploadtedField", "uploadededGlobal", " uploadedifiedFile", "uploadpedFile", "uploaderFile", " UploadedFile", "uploadedFormat"], "outStream": ["outView", "oSteam", "_", "outFile", "oFile", "inSteam", "outSteam", "oStream", " outFile", " outSteam", "inFile", " outView", "oView", "inView"]}}
{"id1": "2521141", "id2": "13886238", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["sync", "save", "io", "create", "replace", "write", "close", "archive", "transfer", "select", "file", "upload", "download", "insert", "ate", "drop", "clip", "clone", "cp", "cop", "edit", "crop", "slice", "export", "get", "opy", "cut", "move", "paste", "load", "delete", "link", "Copy", "share", "zip", "source", "set", "remove"], "from_name": [" from_case", "from_Name", "from_no", " from_Name", "from_names", "fromamekey", " from_resource", "fromamefilename", "from_case", " from_info", " from_names", "from_filename", "fromkname", " from_part", " from_filename", " from_no", "fromameName", "fromkName", "fromkcase", " from_key", "from_resource", "from_part", "from_key", "fromkpart", "from_info", "fromamename"], "to_name": ["tolyfile", "to7get", "tolynumber", "eto_name", "to_new", "to_get", "tolynm", "toNamefile", "toNameget", "to7new", "to_Name", "eto_word", "toNamename", " to_number", "to_word", "to7file", "from_new", "from_get", "toNamenew", "to_number", " to_nm", "to_nm", "eto_Name", "tolyname", "to7name"], "from_file": ["fromsdir", "from_port", "or_name", " from_resource", "fromlyresource", "from_dir", "fromlyfile", " from_type", "from_node", "from_type", " from_time", " from_do", "fromlynode", "to_dir", " from_port", "or_run", " from_node", "from_do", "from_resource", "fromlyFile", "from_time", "fromsfile", "from_File", "or_File", "from_run", "or_file", " from_File", "fromsname"], "to_file": ["to_create", "that_File", "TO_element", "TO_port", "to_link", " to_create", "toJFile", "TO_file", "TO_name", "toJdrop", "to_files", "from_dir", "to_tree", "toJfile", "from_type", "to_element", " to_File", "to_drop", "to_base", "that_tree", "to_port", "to_dir", "that_link", "to_run", "TO_FILE", "to_type", " to_dir", " to_base", " to_run", " to_local", "to_FILE", "toJblock", "to_local", "to_block", "that_file", " to_drop", "to_File", " to_block", "TO_files"], "parent": ["parents", "ip", "peer", "pid", "unit", "where", "pa", "top", "instance", "default", "point", "mother", "part", "tree", "base", "id", "remote", "comment", "server", "user", "prop", "file", "test", "pool", "percent", "prefix", "temp", "form", "shape", "client", "child", "path", "paren", "family", "par", "chain", "spec", "name", "up", "global", "tar", "position", "params", "root", "p", "per", "folder", "ma", "timeout", "relative", "directory", "man", "event", "desc", "block", "def", "my", "null", "master", "holder", "page", "owner", "port", "sp", "cmp", "pixel", "rule", "source", "home", "Parent"], "dir": ["dep", "det", "cd", "wd", "dr", "dict", "part", "str", "md", "ind", "file", "div", "loc", "self", "mod", "dd", "iter", "del", "cmd", "path", "tr", "Dir", "cond", "DIR", "dim", "coll", "fd", "d", "folder", "init", "di", "directory", "dist", "module", "cur", "local", "rel", "vol", "ir", "rec", "addr", "red", "sp", "cont", "good", "db", "def"], "from": ["fr", "io", "bound", "or", "in", "se", "re", "stream", "back", "base", "user", "pos", "file", "with", "en", "func", "inner", "left", "error", "before", "so", "ent", "form", "out", "normal", "client", "ie", "no", "check", "term", "ra", "old", "From", "on", "start", "orig", "false", "init", "set", "query", "con", "local", "link", "vol", "fun", "st", "entry", "reset", "com", "style", "empty", "store", "window", "source", "by", "and"], "to": ["t", "TO", "stable", "top", "te", "can", "or", "tty", "po", "ne", "too", "base", "auto", "total", "tt", "please", "go", "b", "ato", "so", "e", "eto", "sys", "out", "client", "no", "two", "will", "pi", "nt", "To", "op", "on", "co", "pretty", "token", "ma", "target", "o", "tto", "toc", "output", "must", "that", "null", "ta", "table", "ts", "into", "by"], "buffer": ["binary", "memory", "Buffer", "stack", "buff", "base", "attribute", "batch", "available", "document", "phrase", "temp", "iter", "word", "button", "bar", "queue", "stroke", "cache", "database", "command", "variable", "buf", "password", "paste", "frame", "character", "template", "row", "event", "sample", "block", "sequence", "message", "append", "char", "entry", "table", "function", "window", "page"], "bytes_read": ["bytes_range", "bytesyncread", " bytes_Read", "bytes2range", "words_write", "Bytes_read", "Bytes_write", "wordsyncread", " bytes2read", "wordsynclen", " bytes2write", "bytesynclen", "bytes2Read", "bytes__range", "words_len", "wordsyncwrite", "bytes2write", "bytes__Read", " bytes_write", "words_report", "bytes_run", "bytes2read", " bytes2Read", "bytes__read", "bytesyncreport", "bytes_Read", "bytes__write", "words_read", "Bytes_run", " bytes_range", "wordsyncreport", "bytes_write", "bytes_len", "bytesyncwrite", "bytes_report", " bytes2range"]}}
{"id1": "10214218", "id2": "4461350", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"encrypt": ["decrypt", "decrypted", "encrypted", "decode", "encode", "Encrypt", " encrypted", "encryption", " encryption", "Encryption", "decryption", "Encrypted", " encode", "Encode"], "plaintext": [" plainpassword", "plaincontext", "longprotein", "plainprotein", " plainprotein", "richprotein", " plainText", "plainText", " plaincontext", "pretext", "prepassword", "preText", "richText", "longcontext", " Plaintext", " plainterm", "plainterm", " Plainterm", "richcontext", "preterm", " PlainText", "longText", " Plainpassword", "plainpassword", "longtext", "richtext"], "md": ["bd", "MD", "managed", " mo", "dh", "det", "cd", "med", "dr", "ng", "sm", "mand", "mt", "ind", "mod", "esm", "e", "dd", "hd", "mc", "dig", "del", "cmd", "deb", "mk", " mc", "mb", "dm", "mo", "nd", "mac", "pd", "nt", "metadata", "mem", "grad", "me", "mp", "d", "der", "ld", "rm", "mn", "od", "m", "doc", "msg", "red", "mm", "mg", "ms"], "raw": ["rendered", "box", "stream", "data", "extra", "base", "unknown", "full", "available", " RAW", "original", "draw", "hex", "bare", "hook", "result", "out", "input", "RAW", " Raw", "aw", "pack", "cooked", "rew", "known", "n", "orig", "buf", "clear", "custom", "array", "all", "value", "row", "unsigned", "message", "valid", "bytes", "random", "sh", "clean", "good", "Raw"], "hash": ["proof", "bh", "html", "id", "total", "ash", "ssh", "Hash", "has", "print", "hex", "result", "sha", "zh", "hidden", "cert", "mask", "tr", "cache", "check", "mac", "alert", "ASH", "rh", "password", "handle", "shadow", "array", "hed", "height", "href", "json", "search", "tag", "message", "sum", "ashes", "sh", "code", "h", "key"]}}
{"id1": "1357662", "id2": "8069594", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFileFile", "CopDirectoryTo", "copyfileFrom", "copyFileTO", "copyDirectoryTo", "CopFileTO", "copyToFile", "copyToTo", "copyDirectoryFile", "CopDirectoryFile", "copyToFrom", "CopFileTo", "CopDirectoryTO", "copyFileFrom", "copyDirectoryFrom", "copyfileFile", "copyDirectoryTO", "CopFileFile", "copyfileTO", "CopFileFrom", "copyToTO", "copyfileTo", "CopDirectoryFrom"], "destination": ["restinated", "destinated", "distinated", "disturation", "destification", "distination", "destinity", "delinity", "catinated", "delification", " desturation", "Destification", "dominated", "restination", "destinator", "estination", " destinity", "restinate", "distinate", "Destinated", "descinate", "desturation", "descinated", "destinate", "domination", "distification", "restification", "catination", " destinator", "dominations", "destinations", "descination", "catification", "Destinate", " destification", "descification", "Destination", "deluration", " destinated", "estinator", "dominator", " destinations", "estinations", "estinated", "delination", " destinate", "distinity", "catinate"], "srcChannel": ["sinCase", "sinChan", " srcStream", "rcChannel", "srcCase", " srcChan", "rcChan", "srChannel", "insChan", "srcChain", "rcchannel", "rcStream", "sysChannel", "sourceCh", "sourcechannel", "srcchannel", "rcChain", "srcStream", "insChannel", "insChain", "sinChain", " srcChain", "sysConnection", "sinChannel", "srChan", "sysStream", " srcConnection", " srcchannel", "sourceChan", "sysChan", "srcCh", "srCase", "insCh", "srcChan", " srcCase", "rcCh", "srChain", "sourceConnection", "rcConnection", "sourceChannel", " srcCh", "srcConnection"], "destChannel": ["destC", "srcC", "certConnection", "certCh", " destC", "homechannel", "DestChannel", " destChan", " destchannel", "destConnection", "homeChannel", " destCategory", " destCh", "certChannel", "destCh", "srcchannel", "etcChan", "destchannel", "certCan", " destCan", "destCategory", "Destchannel", "etcConnection", "etcC", "destChan", "DestCan", "DestChan", " destConnection", "srcChan", "homeChan", "DestCategory", "destCan", "DestConnection", "homeCategory", "etcChannel", "DestCh", "srcConnection"]}}
{"id1": "11154758", "id2": "16719805", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"client": ["c", "plugin", "cl", "product", "type", "close", "list", "conn", "lib", "acl", "connection", "tree", "base", "core", "server", "controller", "ce", "batch", "so", "secure", "google", "cell", "console", "cp", "cmd", "cli", "cache", "util", "ci", "obj", "ace", "nt", "command", "url", "co", "http", "contact", "network", "service", "channel", "template", "net", "control", "con", "api", "force", "cm", "response", "query", "sim", "Client", "store", "config", "call", "resource", "i", "remote", "window", "key", "and"], "fos": ["dfora", "foes", "Faos", "dfos", "vOS", "flOS", "fooss", "FOS", "fows", " foos", " fose", "Fose", "fooes", " fOS", "woss", "foaos", " foss", "dfosi", "flosi", "flora", " fora", "foss", "floes", "flose", "vos", "faos", "Fos", "wo", "fis", "fo", "vaos", "foo", " fosi", "fooos", "floos", "Fows", "fOS", "flos", "fora", "floss", "flows", " fis", "waos", "foos", "vis", " faos", " fo", "fosi", "dfoss", " fows", "Fis", "fose", " foes", "wos"], "filename": ["fle", "println", "river", "mson", "mpeg", "key", "sbm", "fil", "FILE", "file", "ame", "PDATE", "username", "won", "prefix", "nil", "string", "png", "path", "ename", "title", "lua", "name", "stem", "n", "foo", "ideo", "f", "til", "ames", "directory", "fp", "kl", "existing", "Filename", "output", "exe", "sql", "subject", "knife", "nm", "what", "fn", "source", "kj", "txt"]}}
{"id1": "2642914", "id2": "12389873", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 0, "substitutes": {"addFileToTarGz": ["addFileToTarGsz", "addFileToTarGp", "addFileToTarGst", "addFileToTarJzip", "addFileToTarRzip", "addFileToTarGez", "addFileToTarBt", "addFileToTarRw", "addFileToTarRx", "addFileToTarBw", "addFileToTarJz", "addFileToTarGep", "addFileToTarGx", "addFileToTarGet", "addFileToTarBzip", "addFileToTarGzip", "addFileToTarRz", "addFileToTarGsp", "addFileToTarJw", "addFileToTarGszip", "addFileToTarBp", "addFileToTarGw", "addFileToTarBx", "addFileToTarJx", "addFileToTarBz", "addFileToTarGt", "addFileToTarGezip"], "taro": [" tary", "ttara", "trro", "Tamo", "tary", "Targo", "taco", "staco", "temparo", "Tolan", "retaro", "tarro", "Tro", "toa", "tempargo", "Taco", "qtaro", "trary", "ktara", " targo", " toa", "ttaro", "margo", "thrar", "ttosa", "tara", "qtolan", "ktrar", "tory", " tosa", "stary", "thara", "stamo", "Taro", "qtro", "retara", "troa", " tarro", "tosa", "trar", "thosa", "ktaro", "stoa", "staro", "wro", "tempamo", "tolan", " trar", "stargo", "qtory", "tharo", "tamo", "wargo", "tro", "waro", "tempro", "retaco", "ktarro", "warro", "ttamo", "Tory", "starro", " taco", " tamo", "Tara", "Tarro", " tara", "tharro", "retamo", "maro", " tolan", "thamo", "mro", "targo", " tro", "stro", "marro", "traro", " tory"], "path": ["history", "text", "c", "th", "binding", "kind", "PATH", "key", "mount", "parts", "core", "full", "file", "ath", "print", "dir", "string", "transform", "pattern", "ref", "pi", "chain", "name", "root", "url", "project", "p", "local", "w", "ex", "entry", "m", "doc", "h", "clean", "Path"], "base": ["binding", "create", "buffer", "padding", "ase", "build", "based", "default", "part", "pad", "extra", "bf", "server", "full", "file", "bas", "b", "prefix", "bare", "common", "normal", "check", "family", "alias", "name", "start", "bad", "root", "absolute", "shadow", "relative", "Base", "template", "basic", "reset", "parent", "db"], "f": ["life", "c", "t", "fr", "tf", "y", "v", "rf", "fe", "fx", "fed", "fac", "bf", "fb", "fa", "file", "l", "b", "e", "inf", "fab", "xf", "far", "r", "af", "df", "uf", "lf", "fm", "fo", "ft", "p", "fd", "d", "perm", "fs", "o", "fp", "w", "fc", "fl", "fg", "elf", "fi", "F", "g", "sf", "i", "h", "cf", "alf", "form"], "entryName": ["ryName", "rowName", "rowType", "entryLetter", " entryname", "ryType", " entryType", "rowLetter", "EntryPath", "ryLetter", "elementKey", " entryLetter", "elementname", "EntryType", "entryKey", "cueType", "EntryName", "elementPath", " entryPath", "rowname", " entryKey", "entryPath", "cueName", "EntryKey", "entryType", "Entryname", "elementName", "ryname", "cueKey", "cuename", "entryname"], "goIn": ["goIns", "GoIns", " goIns", "poin", "GoIN", "GoIn", "moIN", "GoOut", "moIns", "goInput", " goOut", "goOut", "Goin", " goIN", "poOut", "moin", " goin", "moInput", "goIN", "goin", "poIN", "poIn", "geInput", "geIn", " goInput", "geIns", "gein", "moIn"], "tarEntry": ["rarEnt", "rarCategory", "tarCategory", " tarentry", "carEntry", "warEntry", "carEnt", " tarCategory", "rarItem", " tarComponent", "rarEntry", "tarItem", "rarComponent", "warEnt", "rarentry", "carentry", "tarentry", " tarItem", "tarEnt", "warComponent", "tarComponent", "warItem", " tarEnt", "carCategory"], "children": ["parents", "modules", "ml", "follow", "ps", "ul", "cloud", "each", "batch", "gall", "cs", "ports", "roots", "these", "balls", "ren", "items", "pages", "objects", "ls", "reports", "cache", "Children", "wn", "names", "all", "members", "los", "json", "fs", "kids", "jobs", "ll", "packages", "resources", "blocks", "users", "files", "stories", "groups", "hawks", "parent", "keys", "aos", "they", "many"], "child": ["c", "fr", "count", "follow", "close", "col", "id", "comment", "file", "batch", "l", "friend", "cell", "uncle", "q", "ph", "client", "Child", "lf", "cache", "job", "name", "cow", "handle", "fd", "row", "ll", "ch", "block", "char", "entry", "label", "last", "shell", "parent", "pixel", "zip", "brother", "background", "page", "key"]}}
{"id1": "18114701", "id2": "9687813", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"resolveEntity": ["resolvingEnt", "consolvingInternal", "consolveInternal", "resolveInternal", "resloveInternal", "consolvingObject", "resolveObject", "resolvingEntity", "resolvedEnt", "consolveObject", "resolveEnt", "resolvingObject", "resolvedInternal", "resloveEntity", "resolvedEntity", "consolvingEnt", "consolveEnt", "resloveEnt", "consolvingEntity", "resloveObject", "resolvingInternal", "consolveEntity", "resolvedObject"], "publicId": ["publicAnd", "privateID", " publicID", "ublicPart", "openPart", "ublicID", "fullLink", " publicTime", "publicInt", "publicID", "primaryId", " publicAnd", "publicTime", "openId", " publicInt", "privatePart", "privateId", "ublicId", "primaryPart", " publicLink", "publicLink", "fullID", "primaryID", "privateInt", " publicPart", "openID", "publicPart", "openAnd", "fullId", "fullInt", "privateAnd", "ublicTime", "primaryTime", "privateLink"], "systemId": ["externalUrl", " systemID", "systemID", " systemUrl", " systemName", "externalName", "externalID", "userUrl", "sysId", "systemName", "userName", "sysID", "systemUrl", "sysUrl", "externalId", "userId", "sysName", "userID"], "resolved": [" reserved", "presolver", "rolving", "presolve", "solves", "presolution", "remolved", "Resolver", "revolution", "involved", "involving", "presolved", "resolves", "resultsolving", "consolution", "Resolve", "involve", "remolution", "served", "resolve", "Resolving", "resolver", "solution", "rolved", "remolving", "solving", " resolution", "solve", "resultsolved", "resolution", "remolves", "consolved", "revolving", "resolving", "revolved", "resultsolution", "reserved", "Resolution", "resultsolver", "preserved", " resolve", " resolver", "Resolved", "rolution", "solved", "consolving", "involution", "presolving", "rolve", " resolving", "consolves", "revolver"], "iSource": [" iSOURCE", "iniResource", "qiSourceFile", " iSources", "liSources", "aiSource", "qiSOURCE", "iService", "iniSite", "ISource", "IResource", "iniMember", "iuSOURCE", "iiSite", "iiSource", "uiSite", " iSite", "aiService", "aiStream", "liSourceFile", "liStream", "qiSource", "uiSources", "uiSourceFile", "liSource", "iiMember", "iuSource", "iSOURCE", "iMember", "aiSourceFile", "uiSource", "iuSourceFile", "iniSource", " iService", "iResource", "liSite", "iSourceFile", "ISite", "IMember", "iSources", "iSite", "iiResource", "qiSources", " iSourceFile", "liService", "iuSources"], "url": ["dl", "location", "build", "ul", "rl", "re", "nl", "mount", "str", "html", "user", "u", "log", "mol", "l", "gl", "web", "uri", "arl", "r", "ssl", "browser", "mb", "ls", "path", "mail", "ref", "sl", "address", "name", "bel", "ur", "f", "http", "hl", "ll", "link", "rel", "URL", "char", "null", "resource", "Url"], "iStream": ["iStack", "sourcestream", " iRead", "riStack", " iSteam", "uStreamer", "uStream", "riRead", "riStream", "ipStream", "ipstream", "ipStreamer", "sourceStream", "ustream", "sourceSteam", " iStack", "riSteam", "inputStream", "iStreamer", "sourceStreamer", "ipSteam", "uSteam", "istream", "iRead", "iSteam", "inputSteam", "inputRead", "inputStack"]}}
{"id1": "4602568", "id2": "15445861", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"storeImage": ["StoreFile", "saveImages", "StoreImages", " storeImages", "storeFile", "StorePicture", "storeImages", " storeFile", " storePicture", "saveFile", "StoreImage", "savePicture", "saveImage", "storePicture"], "inStream": ["cinView", " inSteam", "outFile", " inFile", " inForm", "cinSteam", "cinFile", "inSteam", " inView", "outSteam", "fileStream", "fileFile", "inputStream", "inForm", "fileSteam", "inputFile", "inputView", "fileForm", "inFile", "inputSteam", "cinStream", "outForm", "inView"], "fileName": ["fileType", "imageInfo", " fileInfo", "FileType", "imagename", "FILEPath", "FilePath", "imageName", "FileName", "imageTime", "resourcePath", "FILEName", "imagePath", "filePath", " filePath", "FileInfo", "imageType", "FileTime", "fileTime", "resourceTime", "fileInfo", "FILEInfo", "resourceType", "Filename", " fileType", "resourceName", "FILEname", " filename", "filename"], "resize": ["renized", " resized", " resizes", "renize", "renizes", "resizes", "Resized", "Ressize", "rensize", " ressize", "resized", "ressize", "Resizes", "Resize"], "rightNow": ["westNow", "rServer", "rightCurrent", "rightFuture", "correctToday", "RightCurrent", "rNOW", " rightNOW", "RightToday", "correctFuture", "RightNow", "rNow", "westThen", "westFuture", "rightServer", "westCurrent", "correctNOW", " rightThen", " RightThen", " RightNOW", " RightCurrent", " rightToday", " rightFuture", "rightNOW", " rightServer", "westToday", " RightNow", "rightToday", "westServer", "rToday", "correctNow", " rightCurrent", "westNOW", "rightThen", "RightFuture"], "dayNamedFolderName": ["dayNamedFolderNames", "dayNamingDirectoryNames", "dayNamingFileNames", "dayNamedDirectoryName", "dayNamedFileSize", "dayNamingDirectory1", "dayNamedFoldername", "dayNamedFilePath", "dayNamedDirectoryname", "dayNamingFileName", "dayNamedFileNames", "dayNamedFileName", "dayNamedFolder1", "dayNamedThemeNames", "dayNamingDirectoryname", "dayNamedDirectory1", "dayNamedThemeSize", "dayNamingFilePath", "dayNamingFolderSize", "dayNamedfoldername", "dayNamedAreaname", "dayNamedAreaNames", "dayNamedAreaName", "dayNamingFoldername", "dayNamedfolder1", "dayNamedThemename", "dayNamingFileSize", "dayNamedfolderName", "dayNamingDirectoryName", "dayNamedDirectoryNames", "dayNamingFolder1", "dayNamingFolderName", "dayNamedFolderSize", "dayNamingFilename", "dayNamedThemePath", "dayNamedfolderNames", "dayNamedFilename", "dayNamedfolderPath", "dayNamedThemeName", "dayNamedArea1", "dayNamingFolderPath", "dayNamedFolderPath", "dayNamingFolderNames"], "uploadDirRoot": ["uploadDirectoryRoot", "UploadDbBase", " uploadRelPath", "saveDirRoot", "uploadUrlParent", "uploadDirParent", "UploadDirCover", "saveDbroot", "saveDirroot", "uploadNetBase", "uploadFolderRoot", "uploadDirBase", "uploadDbroot", "UploadDbRoot", "uploadDirPath", "uploadFolderroot", "uploadUrlBase", "uploadNetCover", "uploadRelBase", "uploadDbBase", "uploadUrlRoot", "UploadDirroot", "UploadDbCover", "uploadDirectoryroot", "uploadFolderPath", "uploadNetRoot", "uploadDbRoot", "uploaddirCover", "saveDirParent", "uploadDbParent", " uploadDirPath", "uploadFolderBase", "uploadNetroot", " uploadRelroot", "uploaddirRoot", "saveDbRoot", "uploadRelroot", "uploadDbCover", "uploadUrlPath", "UploadDirRoot", "uploadDirCover", "uploadRelPath", " uploadRelRoot", "uploaddirroot", "uploadRelRoot", " uploadRelBase", "uploadDirroot", "saveDbParent", "uploaddirBase", "uploadDirectoryParent", "UploadDirBase", "UploadDbroot", " uploadDirBase", " uploadDirroot", "uploadUrlroot"], "file": ["t", "type", "top", "run", "tree", "base", "FILE", "full", "el", "File", "pool", "image", "dir", "il", "source", "ile", "no", "time", "work", "open", "entity", "name", "up", "op", "handle", "project", "get", "f", "folder", "channel", "force", "local", "link", "null", "to", "table", "resource", "parent", "port", "node", "task", "page", "key", "h", "class"], "extension": ["expention", "exention", "EXTend", "dimensions", "expended", "expensions", "xtended", "dimension", "EXTension", "EXTended", "exendant", "dimention", "EXTention", "extensions", "expend", "xtend", "expendant", "extend", "exensions", "extendant", "extended", "xtention", "extention", "xtension", "expension", "exension", "dimendant"], "outFileName": ["outFileInfo", "outLinename", " outFilename", "OUTFieldName", "outDirName", "OutFileKey", "outLineNames", "OUTLogPath", " outLogname", "outLogName", "outLogVersion", "outFieldname", "outFileKey", "OutFileName", "OUTFilePath", "infileType", "outLogPath", "inFileType", "outDirPath", "OUTLogname", "outImageKey", " outLogNames", "OUTFieldname", "outFieldName", "outLogKey", "outFilenameName", "outFileVersion", "outfilePath", "inFileName", "outFilesName", "OutFilePath", "outFilenameKey", "outDirname", " outLineInfo", "outfileName", "Outfilename", "outfilename", "outfileVersion", "outLogname", "outFilenameInfo", "outImagename", "outFilenameNames", "outfileKey", "outFilenameSize", "outImageNames", "infilename", " outLogName", "outLineKey", "inFilename", "outFilenamename", "outFilenameVersion", "outFilesname", "inFileSize", " outLinePath", " outLineName", "outFilenamePath", "infileSize", "OUTLogName", "outFilenameType", "OutfileName", "outFileNames", " outFileVersion", " outFileInfo", "OUTFieldPath", "OUTLogKey", "outFilesPath", " outFilePath", "outFieldPath", "outfileType", "OutfilePath", " outFileNames", "OUTFileName", "outLineInfo", "infileName", "OutFilename", "OutfileKey", "outFileType", " outLineNames", "outFilename", "outImageInfo", "outfileNames", " outLogVersion", "outFieldSize", "outFileSize", "outLogNames", "outImageName", "outLinePath", "outLineName", "OUTFilename", "OUTFileKey", "outImagePath", "outfileSize", "outFilePath", "outFieldType"], "outPathAndName": ["outPortAndName", "outPathOrKey", "outPathOrNames", "outTimeButName", "outPathANDName", "outPortAndPath", "outTimeAndLike", "outPathOrLike", "outPortButName", "outLocationAndKey", "outLocationandNames", "outLocationAndName", "outTimeAndPath", "outPathButName", "outPathAndTime", "outPathandSize", "outTimeButLike", "outPathButTime", "outPathANDLike", "outPathandNames", "outPathAndKey", "outTimeAndTime", "outPathAndPath", "outTimeButTime", "outPathButLike", "outPortButKey", "outPathOrName", "outPathandName", "outLocationandSize", "outPathAndNames", "outPathandPath", "outPathButKey", "outTimeButPath", "outPathOrSize", "outLocationandName", "outPathButPath", "outPathAndSize", "outPathAndLike", "outPathANDPath", "outPathOrTime", "outPortButPath", "outPathandKey", "outTimeAndName", "outPathOrPath", "outPathANDTime", "outLocationandKey", "outLocationAndSize", "outPortAndKey", "outLocationAndNames"], "uploadedFile": ["presentedfile", "uploadiedFile", "presentedFILE", "uploadededFormat", " uploadededLine", " uploadedifiedF", "uploadpedLine", "uploadiedF", " uploadededF", "uploadedGlobal", "presenttedField", "presenttedfile", "uploadmedFile", " uploadededFile", " uploadedifiedUnit", "uploadashedfile", "uploadedF", "uploadashedFile", "presentedFile", "uploaderfile", "uploadedLine", "uploadredGlobal", "uploadredFile", "uploadededPlace", "uploadtedfile", "presenttedFILE", "uploadedField", "presenttedFile", "uploadtedFILE", "uploadifiedLine", "uploadiedLine", " UploadmedPlace", "uploadashedField", "uploadredPlace", "uploaderField", " UploadmedFormat", "uploadpedUnit", " UploadedGlobal", "uploadashedFILE", "uploadedUnit", " UploadmedGlobal", " UploadedPlace", "uploadmedFormat", "uploadedfile", "uploaderFILE", "uploadifiedUnit", " uploadededUnit", "uploadmedPlace", "uploadtedFile", "uploadedFILE", " uploadedifiedLine", "uploadmedGlobal", "uploadredFormat", " UploadmedFile", "uploadededFile", "presentedField", "uploadifiedFile", "uploadpedF", "uploadedPlace", "uploadiedUnit", " UploadedFormat", "uploadifiedF", "uploadtedField", "uploadededGlobal", " uploadedifiedFile", "uploadpedFile", "uploaderFile", " UploadedFile", "uploadedFormat"], "outStream": ["outView", "oSteam", "_", "outFile", "oFile", "inSteam", "outSteam", "oStream", " outFile", " outSteam", "inFile", " outView", "oView", "inView"]}}
{"id1": "5676111", "id2": "1122585", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "label": 0, "substitutes": {"get": ["sync", " finish", " fetch", "GET", "run", "upload", "download", "print", "dump", " delete", " copy", "gc", " construct", " download", "Download", "exec", "export", "init", "execute", "delete", "info", " reload", " put", "call", "Get", "zip", " recover"], "cnt": ["uncNT", "cNT", "acnt", "Cnc", "nct", "ncht", "nnc", "uncnc", " cnc", "acNT", "Ccount", "Cnt", "CNT", "Cct", "clen", "uncnt", "nccount", "aclen", "ccount", "acnc", "ncnt", "nnt", " clen", "cct", "cnc", "Cht", " cct", "cht", " cNT", "unclen", " cht", " ccount", "ncct", "nNT"], "url": ["dl", "build", "ul", "host", "nl", "mount", "str", "base", "el", "loc", "l", "gl", "web", "google", "uri", "https", "cp", "r", "client", "ssl", "cert", "browser", "path", "ls", "www", "open", "mail", "ref", "sl", "bel", "ur", "handle", "f", "pl", "http", "fs", "con", "ll", "hl", "link", "rel", "ret", "URL", "fl", "char", "null", "socket", "addr", "xml", "Url"], "conn": ["c", "ct", "org", "enc", "ctx", "cont", "nl", "connection", "Conn", "col", "os", "en", "loc", "l", "jp", "comm", "serv", "pas", "cp", "cmd", "client", "cert", "nec", "cb", "cons", "open", "obj", "nt", "conv", "exec", "co", "coll", "resp", "init", "cur", "net", "con", "cn", "ens", "ch", "yn", "rel", "cm", "dial", "syn", "com", "gn", "act", "addr", "ca", "nc", "ns", "connect", "access"], "is": ["ip", "ps", "ists", "dis", "iris", "in", "es", "bs", "os", "imp", "sit", "isin", "bis", "isc", "isi", "has", "ib", "isf", "im", "iter", "ist", "sys", "iso", "lis", "nis", "ys", "its", "IS", "si", "ris", "init", "fs", "ais", "rs", "isa", "mis", "iss", "ends", "it", "ios", "isl", "abs", "sim", "vis", "ins", "icks", "us", "i", "Is", "ic", "ri", "ms"], "filename": ["println", "river", "mson", "nu", "str", "LCS", "sbm", "fil", "FILE", "file", "ame", "FIL", "username", "prefix", "string", "source", "path", "family", "title", "lua", "name", "stem", "journal", "f", "til", "continental", "fp", "kl", "Filename", "sql", "subject", "latest", "knife", "nm", "ename", "fn", "ren", "txt"], "fos": ["foes", "Faos", "Foss", "fows", "Foses", "fres", " foses", "boes", " foss", "voses", "foss", "bos", "flaos", "floes", "Foes", "loes", "vos", "vres", "faos", "Fos", "bows", "vaos", "Fres", "foses", "boss", "Fows", "flos", "los", "floss", " faos", " fres", " fows", "laos", " foes", "loss"], "buffer": ["history", "text", "scroll", "Buffer", "memory", "binary", "view", "stack", "data", "buff", "base", "length", "comment", "attribute", "total", "batch", "available", "document", "phrase", "print", "temp", "result", "iter", "source", "button", "bar", "queue", "library", "cache", "database", "command", "note", "variable", "mem", "buf", "bone", "paste", "frame", "template", "event", "sample", "sequence", "block", "message", "output", "display", "bytes", "append", "char", "table", "window", "page"]}}
{"id1": "1698200", "id2": "2461169", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginByteshare", " loginbitshare", "loginbitshare", "loginByteStock", "loginBitStock", "loginbitShare", " loginBitshare", "loginbitStock", " loginbitStock", " loginBitStock", " loginbitShare", "loginByteShare", "loginBitshare"], "params": ["gs", "terms", "pres", "ps", "details", "tags", "requires", "Parameters", "posts", "acl", "parts", "points", "headers", "services", "pins", "ports", "photos", "options", "pas", "parser", "cp", "changes", "ams", "hash", "comments", "Par", "pi", "metadata", "param", "pps", "chains", "p", "pretty", "names", "http", "properties", "json", "members", "rs", "stats", "types", "settings", "cms", "config", "keys", "mm", "auth", "caps"], "httpclient": [" httpcli", "Httprequest", " httprequest", "httpsClient", "httClient", "hypercli", "httpscontroller", " httpClient", "HttpClient", "ttpco", "httpconnection", "httpcontroller", "httprequest", "hyper2", "httpcli", "hyperconnection", " http2", "ttpcontroller", "https2", "httpClient", "httco", "httpscli", " httpconnection", "http2", "ttpclient", "httpco", "httpsconnection", "httpsrequest", "httpsclient", "Httpclient", "hyperclient", "ttpClient", "httpsco", "httclient", "Httpconnection", "httcontroller"], "httppost": ["httpplop", "httphoint", "httpperost", "httploster", "httpploint", "httpperpost", "httpart", "httpop", "httpoint", " httpppost", "httplop", "httphoster", "httpppoint", "httplom", "httpploster", " httpom", "httpperom", "httpplart", "httplpost", "httpplost", "httppom", "httplost", "httpost", "httposter", "httmpart", "httplart", "httppoint", " httpost", " httppom", " httppop", "httpppop", "httppposter", "httpppost", "httppop", "httppppost", "httpppart", "httpom", "httmppost", "httpperop", "httploint", " httpop", "httmpost", "httmpop", "httphpost", "httpplpost", "httppart", "httphost", "httpposter"], "formparams": ["inputparam", " formauthors", "formParameters", "functionmembers", "functiondetails", "foreproperties", "feedparam", "formdetails", "functionchanges", " formdetails", "formsettings", "formnames", " formnames", "feedParameters", "formchanges", "functionproperties", "batchnames", "inputerrors", "functionparams", "formerrors", "forenames", " formsettings", "formmembers", "formedtags", "condnames", "formtags", "condproperties", "functionargs", "foreauthors", " formchanges", "formparam", "feedparams", "inputtags", "formednames", "functionauthors", "forechanges", " formproperties", "foreargs", "formauthors", "formargs", "foresettings", "batcherrors", "foremembers", "condsettings", " formmembers", "foreparams", "foredetails", " formparam", "inputdetails", " formParameters", "formproperties", "batchparams", "batchtags", " formargs", "feeddetails", "inputparams", "inputnames", "formederrors", "condparams", "formedparams", "inputParameters"], "entity": ["content", "object", "create", "ITY", "buffer", "fee", "enc", "ity", "ENT", "inv", "data", "html", "user", "comment", "eme", "el", "ce", "orm", "document", "component", "body", "ent", "out", "profile", "security", "line", "activity", "metadata", "note", "json", "ell", "em", "template", "ew", "event", "person", "ee", "entry", "Entity", "empty", "xml", "quote", "form"], "httpresponse": ["ttpResponse", " httpreply", " httpResponse", "HTTPresult", " httpresp", "procresult", "HTTPresponse", "httpconnection", "httpresult", "procresponse", "procResponse", "httpResponse", "HTTPresp", "httpresp", " httpconnection", "HTTPreply", "ttpresponse", "HTTPResponse", "httpreply", "procreply", "ttpresp", "HTTPconnection", " httpresult", "ttpconnection"], "it": ["et", "ip", "est", "t", "li", "v", "iz", "ul", "ite", "ect", "IT", "sit", "itter", "ate", "ind", "It", "el", "ut", "MIT", "rit", "l", "at", "iter", "im", "il", "ot", "ent", "ert", "ist", "is", "itted", "al", "its", "init", "he", "mit", "st", "you", "lit", "ex", "act", "i", "ic", "ed"], "escookie": ["espcookie", "eyace", "httpsog", "ecotton", "eyancel", "ecue", "escue", "isecookie", "httpsotton", "espancel", "esccookie", "escog", "occookie", "iseccake", "httpsookie", "ecookie", "Esccookie", "eyookie", "eccake", "espace", "occog", "Escookie", "escoder", "ectrl", "escace", "Escue", "desccookie", "occoder", "ecog", "desctrl", "isecoder", "ecace", "iseccookie", "ecancel", "eccookie", "espookie", "descue", "occcookie", "ecoder", "descookie", "esccake", "Esctrl", "esctrl", "occotton", "escotton", "escancel", "occcake", "httpscookie", "eycookie"]}}
{"id1": "14878593", "id2": "6188784", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": ["hyperloadUpdated", "hyperlinkupdate", "hyperlineClick", "hyperlineUpdated", " hyperlinkUpdated", "hyperLinkupdate", " hyperLinkUpdate", " hyperlinkupdate", "hyperLinkClick", "hyperLinkUpdated", "hyperlinkUpdated", "hyperLinkUpdate", "hyperloadClick", "hyperloadupdate", "hyperlinkClick", " hyperLinkClick", " hyperLinkUpdated", "hyperlineupdate", "hyperlineUpdate", " hyperLinkupdate", "hyperloadUpdate", " hyperlinkClick"], "e": ["et", "c", "t", "ae", "v", "fe", "ev", "te", "eur", "se", "es", "ef", "re", "oe", "eeee", "eu", "esc", "u", "el", "ce", "ame", "en", "Event", "l", "b", "ent", "ge", "eg", "r", "ie", "ue", "de", "err", "a", "er", "n", "ec", "p", "f", "d", "ve", "o", "event", "one", "ea", "w", "it", "E", "ee", "ex", "m", "h", "s", "ed"], "url": ["location", "buffer", "rl", "host", "nl", "mount", "str", "re", "html", "id", "base", "this", "el", "log", "loc", "lr", "l", "gl", "web", "uri", "string", "r", "ssl", "browser", "path", "ls", "ob", "job", "mail", "sl", "address", "term", "bel", "ur", "f", "pl", "http", "json", "hl", "ll", "link", "rel", "sql", "URL", "char", "addr", "resource", "Url", "filename", "form"], "stream": ["sync", "reader", "buffer", "read", "enc", "in", "view", "stack", "data", "str", "pipe", "mount", "down", "user", "upload", "file", "download", "pool", "image", "ream", "secure", "body", "iter", "console", "transform", "out", "REAM", "path", "our", "input", "res", "open", "sl", "present", "feed", "http", "sw", "Stream", "channel", "row", "sample", "context", "message", "steam", "resource", "zip", "clean", "window", "source", "form", "iterator"], "writer": ["written", "widget", "io", "reader", "buffer", "write", "worker", "manager", "wire", "file", "liner", "document", "draw", "loader", "word", "console", "string", "creator", "storage", "client", "white", "player", "browser", "ner", "riter", "writing", "er", "builder", "maker", "caster", "writ", "Writer", "wright", "unsigned", "local", "w", "output", "writers", "null", "master", "WR", "to", "wrote", "window"], "editor": ["license", "cer", "widget", "reader", "buffer", "instance", "paper", "actor", "translation", "or", "core", "view", "order", "over", "answer", "server", "auto", "external", "Editor", "upload", "insert", "liner", "author", "ui", "document", "edited", "language", "loader", "options", "action", "older", "oder", "button", "creator", "storage", "definition", "browser", "player", "edit", "video", "offer", "application", "enter", "er", "accept", "term", "EDIT", "builder", "maker", "media", "folder", "description", "init", "option", "finder", "settings", "vector", "area", "entry", "article", "code", "owner", "key"], "name": ["version", "text", "named", "type", "Name", "nl", "key", "tree", "base", "id", "str", "length", "comment", "part", "order", "file", "ame", "lower", "prefix", "string", "normal", "path", "no", "family", "title", "term", "format", "n", "position", "me", "root", "NAME", "names", "description", "all", "init", "info", "one", "local", "size", "null", "label", "nm", "code", "resource", "alpha", "word", "source", "filename", "system"], "dialog": ["compog", "dlag", "Dialch", "dog", "dializ", "dlop", "Dialogs", "dlogs", "Dialoder", "dlogue", "tdg", "conresh", "dialag", "dialch", "conog", "dlose", "initialog", "tdect", "redg", "initialag", "dialect", "doog", "conoder", "compoder", "redog", "choop", "dialop", "Dialag", "tdog", "dialose", "conch", "Dialose", "dlOG", "doect", "dlog", "compch", "Dialresh", "choogs", "dialogue", "Dialogue", "dialOG", "dialresh", "choogue", "initialose", "Dialog", "dialg", "dialogs", "redect", "doiz", "Dialop", "initialOG", "compresh", "DialOG", "dialoder", "choog", "rediz", "tdiz"]}}
{"id1": "8011262", "id2": "732800", "code1": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"uploadFile": ["uploadImage", "updatePath", "updateFilename", "UploadPage", "UploadImage", "createPath", "uploadPage", "updateImage", " uploadMessage", "updateFile", "uploadMessage", "createFilename", "updatePage", "uploadFilename", "updatefile", "createfile", "updateMessage", " uploadImage", " uploadPage", "createFile", "UploadMessage", "savefile", "saveFile", "saveFilename", "savePath", "uploadfile", "UploadFile", "uploadPath"], "end": ["ender", "est", "close", "default", "endif", "quit", "pad", "except", "stop", "order", "begin", "external", "comment", "rest", "bottom", "en", "hend", "join", "ended", "add", "post", "e", " End", "ent", "End", "ending", "pend", "ue", "right", "enter", "chain", "start", "END", "send", "use", "ord", "edge", "event", "ends", "die", "enable", "append", "entry", "reset", "pard", "empty", "ad", "ment", "drop", "and"], "twoHyphens": ["twohyphens", " twoHyphen", "twoPerskens", "secondhypkens", "secondhyphen", "twoHykens", "twohypphas", "threehyphes", "twoHyphers", "twoHyphen", "twoHyoms", "twoHaskens", "twoDiskens", "secondHyphen", "threeHypkens", "fourHypoms", "secondHyphens", "twoDisphas", "twoHyens", " twoHypkens", "twoHyhers", "twoHyhens", "twoHypkens", "twoHotens", "twoHyphes", "fourHypens", "twoHascludes", "fourHyens", "fourHyphes", "twoHypphas", "threehypkens", "twoHyhes", "secondhyphers", "threeHyphens", "twoPerscludes", "secondHyphers", "threehyphens", "twoHothes", "twoPershens", "threehypcludes", "twoHypoms", "threeHypcludes", "fourHyoms", "twohyphes", "twohyphen", "twohypkens", "threeHyphes", "twoHothens", "secondHypkens", "twoHypcludes", "twoHashes", "twohyphers", " twoHypphas", "twoPershes", "secondhyphens", "twoDishens", "twoDishen", "fourHyphens", "twohypcludes", "fourHyhens", "twoHashens", "twoHyhen", "fourHyhes", "twoHypens", "twoHotoms"], "boundary": ["bounditary", "mbARY", "commonaration", "banory", "terminaration", "boundory", "verbaries", "directionory", "boundaries", "boundaration", "mbory", "minary", "Boundangle", "boundARY", "commonitary", "commonaries", "bindory", "Boundory", "Boundary", "banaries", "terminory", "banary", "terminary", "verbARY", "verbaration", "boundangle", "commonary", "directionaries", "mbitary", "terminARY", "bindry", "commonory", "banry", "boundry", "verbary", "directionangle", "minARY", "minory", "mbary", "directionary", "bindary", "Boundaries", "terminaries", "bindangle", "commonARY", "minitary", "bindaries", "terminry"], "url": ["c", "dl", "ocl", "ml", "ul", "conn", "rl", "re", "nl", "cal", "uc", "str", "atl", "log", "loc", "l", "gl", "uri", "https", "il", "r", "client", "ssl", "ls", "gc", "open", "sl", "sur", "ur", "f", "pl", "http", "ll", "link", "URL", "fl", "ctrl", "Url"], "con": ["c", "ct", "cl", "can", "conn", "ver", "cont", "cal", "Con", "connection", "fac", "Conn", "col", "pen", "pos", "go", "func", "en", "loc", "const", "cs", "bc", "ln", "comm", "ain", "cp", "cc", "cmd", "client", "cert", "ls", "cons", "CON", "open", "don", "conv", "connect", "sur", "ran", "un", "co", "coll", "soc", "conf", "cur", "num", "cn", "cm", "pc", "fc", "fl", "canon", "dial", "com", "act", "ctrl", "cos", "call", "nc", "fn", "cf"], "ds": ["qs", "sync", "gs", "dos", "bd", "dl", "ads", "dh", "ps", "dis", "conn", "ats", "bs", "sd", "posts", "hs", "des", "js", "ils", "vs", "cks", "els", "dp", "eps", "dds", "dc", "cs", "ones", "dd", "aos", "Ds", "ts", "scripts", "aws", "ks", "sys", "dt", "ows", "DS", "ls", "ys", "ops", "nas", "pd", "ws", "fd", "d", "ses", "loads", "der", "di", "edes", "ands", "fs", "rs", "eds", "sets", "sts", "docs", "stats", "sql", "css", "def", "obs", "ods", "s", "uds", "ns", "db", "pers", "xs"], "fStream": ["fSteam", "mstream", "aForm", "fstream", "mThread", "ftStream", "fileRound", " fStreamer", "sfSteam", "ftRound", " fRound", "mStreamer", "fpstream", "fileSystem", " fstream", "ftSystem", "fStreamer", "mStream", "aStream", " fThread", "fSystem", "sfStream", "aSteam", "fileStream", "sfReader", "fThread", "aReader", " fSteam", " fSystem", " fReader", "fRound", "sfForm", "fpStream", "fForm", "fpThread", "fileForm", "fReader", "ftForm", " fForm", "fpStreamer"], "bufferSize": [" bufferSIZE", " bufferCount", "buffScale", "buffSize", "BufferScale", "BufferSize", " bufferLength", "BufferLength", "surfaceSize", "surfaceScale", "surfaceLength", "BufferCount", "buffSIZE", "bufferSIZE", "surfaceSIZE", "BufferSIZE", "tableSIZE", "tableCount", "bufferScale", "bufferLength", "bufferCount", "buffLength", "tableSize", "tableLength"], "buffer": ["memory", "binary", "Buffer", "view", "stack", "buff", "total", "raw", "batch", "available", "document", "phrase", "temp", "result", "word", "iter", "bar", "queue", "stroke", "pause", "library", "reference", "cache", "database", "variable", "command", "face", "buf", "bone", "paste", "frame", "number", "template", "sample", "sequence", "block", "message", "append", "char", "initial", "table", "bridge", "window", "source"], "length": ["history", "count", "deep", "ENGTH", "kind", "Length", "bow", "point", "volume", "tail", "pad", "core", "ah", "total", "rest", "full", "idth", "collection", "component", "l", "result", "shape", "piece", "no", "duration", "database", "partial", "command", "loop", "capacity", "amount", "position", "present", "enth", "len", "load", "be", "number", "height", "hello", "all", "expected", "size", "sequence", "angle", "ength", " Length", "code"], "is": ["ip", "tis", "ps", "ists", "iris", "ii", "bs", "does", "sis", "os", "isin", "vs", "isc", "bis", "isi", "has", "isf", "sys", "ls", "lis", "nis", "ys", "its", "IS", "si", "ris", "fs", "ims", "ais", "isa", "iss", "ios", "isl", "ates", "icks", "Is", "i", "ism", "ri", "ms"], "ch": ["inch", "c", "ct", "count", "y", "ctr", "cl", "cy", "chan", "che", "CH", "unk", "str", "col", "comment", "ce", "Ch", "ty", "cle", "cs", "ouch", "qu", "chid", "cell", "cho", "sch", "ph", "cp", "cmd", "zh", "x", "ech", "check", "br", "ach", "och", "ches", "ich", "cha", "channel", "cur", "conf", "cm", "pc", "cor", "j", "char", "tch", "ex", "cht", "code", "sh", "i", "unch"], "b": ["sb", "c", "bd", "B", "binary", "v", "bound", "wb", "ba", "emb", "bs", "buff", "base", "fb", "bf", "auto", "ib", "ab", "bar", "r", "mb", "eb", "cb", "ob", "orb", "br", "job", "rb", "a", "buf", "f", "d", "be", "gb", "nb", "pb", "bp", "xb", "shell", "s", "db", "bb"]}}
{"id1": "10361370", "id2": "5399593", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hash": ["version", "html", "attribute", "ash", "test", "Hash", "print", "update", "render", "profile", "sign", "crypt", "index", "check", "handle", "password", "array", "match", "tag", "message", "sum", "ashes", "code", "filter", "h", "key", "header"], "saltBefore": ["sALTStart", "sadeAfter", " sALTStart", "sALTAfter", "saveAfter", "SaltPrevious", "SaltBefore", "sadePrevious", "sALTPrevious", "sadeBefore", " sALTBefore", "SALTPrevious", " sALTAfter", "sashStart", "SaltAfter", "sashBefore", "sashAfter", "sadeStart", "sALTBefore", "savePrevious", "saveBefore", "SALTBefore", "SALTAfter", "saltPrevious", "saltStart", " saltStart"], "content": ["text", "object", "c", "example", "license", "any", "translation", "data", "str", "html", "comment", "raw", "file", "document", "image", "expression", "body", "word", "string", "input", "Content", "path", "time", "entity", "title", "reason", "format", "password", "url", "media", "present", "description", "json", "value", "record", "sequence", "message", "output", "subject", "null", "initial", "config", "code", "xml", "cont", "current", "source", "txt"], "saltAfter": ["sadeAfter", "saltPost", "soltResult", "saltafter", "sALTAfter", "saveAfter", "soltAfter", "sALTResult", "SaltBefore", "sintBody", "sadeBefore", "valtafter", "soltBefore", "SALTResult", "saveafter", "sALTafter", "saveBody", "sALTBody", "valtBody", "vintBefore", "SALTPost", "sintBefore", "SaltAfter", "vintafter", "valtBefore", "saltResult", "sadePost", "sALTPost", "sALTBefore", "saltBody", "SaltPost", "sintafter", "SALTBefore", "SaltResult", "SALTAfter", "sadeResult", "saveBefore", "vintBody", "vintAfter", "valtAfter", "sintAfter", "soltPost"], "repeatedHashingCount": ["repeatedHashCode", "repeatedHashingCode", "repeatedHashescount", "repeatedHashCC", "repeatedRashLength", "repeatedHachingCC", "repeatedRashCC", "repeatedHashCount", "repeatedHashingCC", "repeatedRashingCounter", "repeatedHashesCount", "repeatedHashesCode", "repeatedHashingcount", "repeatedRashCount", "repeatedHashesCounter", "repeatedRashescount", "repeatedHASHCount", "repeatedHashLength", "repeatedRashingCount", "repeatedHASHLength", "repeatedRashingCode", "repeatedHashingCounter", "repeatedRashesLength", "repeatedRashesCounter", "repeatedRashingcount", "repeatedHashCounter", "repeatedRashingCC", "repeatedHashcount", "repeatedHASHCounter", "repeatedHachingLength", "repeatedHASHcount", "repeatedRashingLength", "repeatedRashesCount", "repeatedHashingLength", "repeatedHashesCC", "repeatedHachingCount", "repeatedRashCode", "repeatedHashesLength", "repeatedHachingCode"], "digest": ["descity", " digse", "algest", "designest", "mdse", "printest", " digested", "extester", "fingerest", "digesting", "debugest", "digEST", "fifest", "Digist", "Digest", "digum", "digitude", "digests", "fifitude", "Digests", "digute", "argest", "descse", "debugency", " Digested", "digester", "digity", "diagnests", "fingerhest", "algested", " digests", "descest", "debugitude", "fingeresting", " Digest", "printhest", "dighest", "fifency", "fingerEST", " digist", " digency", "designester", "mdested", "Digse", "commse", "digency", "dested", " digEST", " digester", "designested", "dfest", " digert", "compest", "digert", "dighash", " digity", "commity", "hashhash", "compute", "diagnest", "digested", "dfesting", "printEST", "fifEST", " dighest", "dse", " Digester", "diagnist", "designesting", "debugEST", "commested", "extested", " digitude", "algester", " digum", "comphash", "Digum", "Dighash", "dfested", "digse", "mdest", "hashest", " Digert", "argEST", "commest", "dest", "mdester", "Digute", "hashEST", "dert", "argested", "dfester", "argester", "dester", "DigEST", "diagnum", " digesting", "hashute", "algEST", "extse", "printesting", "compEST", "extest", "descested", "digist", "Digester", "Digested"], "digestLength": ["descestlength", "digesterlength", "digestedLength", "digselength", "digestType", " digestLen", "digestedlength", "descestLen", "descesterLen", "digesterLength", "digistData", "descesterOffset", "digistLength", "digesterData", "digestData", " digesterLength", "descesterlength", "digistType", "digistLen", "digseLen", "digestLen", "digesterOffset", " digesterData", "digestedType", " digestData", " digesterType", "digestedOffset", "digestOffset", "digseLength", "digesterLen", " digestType", "descestOffset", "digesterType", " digesterLen", "digestedLen", "descesterLength", "digseOffset", "digestedData", "digestlength", "descestLength"], "i": ["ip", "li", "y", "v", "bi", "in", "ii", "phi", "multi", "mill", "I", "xi", "u", "ui", "ind", "mi", "iu", "ski", "batch", "print", "gu", "gi", "uri", "im", "iter", "q", "client", "cli", "x", "is", "ti", "index", "ci", "err", "pi", "uu", "iq", "n", "me", "qi", "init", "si", "ix", "di", "ini", "ei", "it", "sim", "j", "sql", "my", "ex", "m", "z", "ai", "ic", "ms"]}}
{"id1": "11546108", "id2": "21395184", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 0, "substitutes": {"run": ["scan", " runs", "submit", " Run", "evaluate", "invoke", "go", "func", "Run", "render", "running", "impl", "loop", "exec", "start", "execute", "search", "hello", "find", "launch", "runs", "sample", "apply", "block", "runner", "process", "wait", "call"], "in": ["reader", "bin", "read", "din", "copy", " din", "asin", "inc", "isin", "rin", "file", "inner", "l", "add", "ln", "inf", "mc", "r", "out", "is", "line", "input", "er", "In", "on", "get", "p", "gin", "f", "ma", "all", "info", "conf", "IN", "mn", "fin", "from", "sum", "ins", "inn", "cin", "again", "source", "oin", "by", "and"], "ligneEnCours": ["ligneEnCuours", "ligneENConturs", "ligneEnNourses", "ligneEnClurs", "ligneEnCurs", "ligneEncears", "ligneENCours", "ligneENCour", "ligneEnCuChamp", "ligneEncons", "ligneEnCoodes", "ligneENNres", "ligneENContChamp", "ligneEnContours", "ligneEncour", "ligneEnCuRS", "ligneEnCourses", "ligneEnClChamp", "ligneConCour", "ligneEnContChamp", "ligneConcodes", "ligneENCsons", "ligneEnNurs", "ligneEncodes", "ligneENcurs", "ligneConCodes", "ligneEnNres", "ligneENCsurs", "ligneENCRS", "ligneEnCoours", "ligneEnCoourses", "ligneENCsour", "ligneEnContRS", "ligneENCears", "ligneEnChodes", "ligneENCons", "ligneEnCores", "ligneEnCRS", "ligneEnCoour", "ligneENcour", "ligneENCsours", "ligneEnCChamp", "ligneEnCsour", "ligneENNurs", "ligneENContours", "ligneENCChamp", "ligneENNours", "ligneEnCuurs", "ligneConcours", "ligneENContRS", "ligneENCurs", "ligneEnCears", "ligneEnCres", "ligneENNourses", "ligneConcurs", "ligneEnChour", "ligneENCourses", "ligneEnConturs", "ligneEnCsours", "ligneEnCsons", "ligneEncours", "ligneEnClRS", "ligneENcears", "ligneEnACurs", "ligneEnACears", "ligneConCours", "ligneConcour", "ligneEnACours", "ligneEnChurs", "ligneEnChours", "ligneEnClours", "ligneEnCodes", "ligneConCurs", "ligneEnACour", "ligneEnCour", "ligneEnCoons", "ligneEncurs", "ligneENcours", "ligneEnNours", "ligneEnCsurs", "ligneEnCons", "ligneENCres"], "i": ["ori", "t", "li", "io", "y", " I", "v", "bi", "off", "ii", "phi", "multi", "asi", "I", "xi", "ui", "ind", "mi", "iu", "oi", "l", "b", "continue", "e", "iter", "cli", "x", "is", "ti", "index", "ci", "pi", "n", "p", "si", "init", "ix", "di", "ini", "ei", "it", "j", "m", "ai", " j", "g"], "informations": ["Informsions", "ingenerations", "Informsations", "informATIONS", "informsATIONS", "instrations", "Informations", "Informsation", "Information", "inflators", "informsions", "Informsators", "ingenerates", "informators", "InformATIONS", "Informators", "inflation", "informates", "informsation", "inflates", "instrators", "informsators", "Informions", "Informsates", "ingenerions", "instration", "InformsATIONS", "ingenerATIONS", "informions", "Informates", "informsations", "informsates", "information", "inflations", "inflions", "instrATIONS", "inflATIONS"], "version": ["v", "type", "serial", "status", "ver", "part", "id", "server", "action", "versions", "client", "index", "major", "edition", "program", "title", "format", "position", "description", "channel", "value", "number", "sequence", "VERSION", "label", "port", "source", "class"], "url": ["location", "host", "str", "base", "id", "file", "download", "loc", "print", "l", "uri", "pattern", "browser", "path", "address", "title", "format", "http", "href", "link", "domain", "URL", "label", "resource", "Url", "source", "filename"], "texteErreur": ["texteIrreur", "texteStrreurred", "texteStrneur", "texteStrreur", "texteErriUR", "texteErreult", "texteErrerurred", "texteIrbreura", "texteErrorbreure", "texteErneurred", "texteErruleurred", "texteErseura", "texteErrorreUR", "texteErseUR", "texteErreuer", "texteErrure", "texteErrorreure", "texteErreurred", "texteErriur", "texteCorseult", "texteErruer", "texteErbreura", "texteErREult", "texteErREut", "texteErneurs", "texteErrorbreur", "texteErleure", "texteErreure", "texteErbreure", "texteErseul", "texteIrbreUR", "texteErbreUR", "texteIrbreur", "texteErseut", "texteErrult", "texteCorreut", "texteCorreur", "texteErreut", "texteErseure", "texteStrneurred", "texteErbreur", "texteErleuer", "texteErriul", "texteErrorreur", "texteErseult", "texteErREure", "texteCorseure", "texteErrorbreUR", "texteErleur", "texteErbreul", "texteIrbreul", "texteErriura", "texteErREur", "texteStrneurs", "texteErbreuer", "texteErneur", "texteErrorbreuer", "texteErreura", "texteCorreult", "texteIrreUR", "texteCorseut", "texteStrreurs", "texteCorseur", "texteErreUR", "texteErrerur", "texteErruleur", "texteErseur", "texteIrreura", "texteErreurs", "texteErrorreuer", "texteErrerurs", "texteErreul", "texteErrut", "texteErrUR", "texteErrur", "texteCorreure", "texteErruleurs", "texteErleUR", "texteIrreul"], "numErreur": ["numErneUR", "numErbreurs", "numErreUR", "numerreiber", "numErr\u00e9urs", "numErReur", "numerreurs", "numerreur", "numErreau", "numErneur", "numErReUR", "numErReau", "numErbreiber", "numerReUR", "numerReurs", "numErbreUR", "numErneau", "numerreUR", "numErReiber", "numErbreau", "numErReurs", "numErreiber", "numerReur", "numErr\u00e9UR", "numErbreur", "numErneurs", "numErr\u00e9iber", "numErreurs", "numErr\u00e9ur", "numerReiber"], "al": ["dal", " bl", " wal", " fal", "ali", "sal", " cal", "ale", "alist", "cal", "pal", "als", "el", "alog", "l", "hal", " sal", " aval", "af", "ial", "att", "bl", "a", "fal", " hal", " bal", "stal", " mal", "all", "tal", " tal", "wal", "Al", "atal", "ald", "aval", "alon", "ral", "ar", "bal", "AL", "sel", "mal", "ad", "ap", "alf", " recal"]}}
{"id1": "9647576", "id2": "16308040", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean update(String dbName, Query[] queries) throws ServiceException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        int rows = 0;\n        try {\n            con = getDbConnection().getConnection(dbName);\n            con.setAutoCommit(false);\n            for (int i = 0; i < queries.length; i++) {\n                Query query = queries[i];\n                System.out.println(query.getSql());\n                pstmt = con.prepareStatement(query.getSql());\n                addParametersToQuery(query, pstmt);\n                rows += pstmt.executeUpdate();\n            }\n            con.commit();\n            return rows > 0;\n        } catch (DbException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } catch (SQLException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } finally {\n            closeConnection(con, pstmt, null);\n        }\n    }\n", "label": 1, "substitutes": {"Reserve": ["Conserved", "Resolve", "Consolve", "Served", "Conservation", "reserved", "Servation", "Conserve", "Solve", "resolve", "reservation", "Reservation", "Reserved", "Serve", "reserve"], "stbookings": ["stbinders", "Stbooksers", "stbooksies", "Stbookers", "Stbooksings", "stBookies", "Stbooking", "stbindies", "stbindings", "stbooking", "stbooksing", "stBookings", "Stbookings", "Stbooksies", "stbooksings", "stBooking", "stbookies", "Stbookies", "stbooksers", "stbookers", "stBookers", "Stbooksing", "stbinding"], "stchartwl": ["STChartbook", "stChartbook", "stchartbook", "stChartwal", "stChartml", "stplotwal", "STchartwal", "STchartwl", "stpagewl", "STChartwal", "stChartwl", "stchartwal", "STchartml", "STChartwl", "stpageml", "stpagewal", "STChartml", "STchartbook", "stplotwl", "stplotbook", "stpagebook", "stplotml", "stchartml"], "sp": ["sb", "lp", "ss", "tp", "ps", " esp", "sc", "spr", "se", "spe", "asp", "sm", "scope", "esp", "space", "sk", "sv", "jp", "pt", "isp", "so", "ap", "cp", "yp", "Sp", "policy", "sy", "sil", " SP", "pol", "p", "osp", "pe", "si", "sw", "service", "pb", "SP", "vol", "st", "pp", "sh", "sf", "bsp"], "userbooksql": ["clientreadsql", "usertypesqs", "agentpagesQL", "clientbookselly", "agentpagesqs", "userbookql", "clientreadsqs", " userbindsql", "userbooksels", "userooksqs", "userooksql", "userBooksSQL", "userbooksSQL", "userpagesQL", "userreadsql", " userbindquer", "userbookQL", "userreadsels", "agentpagessql", "usertypessql", "userscriptsql", "userbooksqs", "userbookselly", "userpagessql", " userbooksquer", "userookselly", "userbindquer", "clientreadsels", "userbindsql", "userbysquer", "userBooksql", "userbooksquer", "userbyssql", "userreadsqs", "userbysql", "userBookssql", "userbookqs", "userscriptselly", " userbindSQL", "userpagesqs", " userbooksSQL", "userbookssql", "clientbooksqs", "userscriptsels", "userooksels", "userreadselly", "usertypesQL", "userbindSQL", "userscriptsqs", "userbindql", " userbindql", " userbookssql", "usertypesql", "agentbooksqs", "userpagesql", "agentpagesql", "userbooksQL", "clientbooksql", "clientbooksels", "agentbookssql", "clientreadselly", "userbysSQL", "agentbooksQL", "userBooksquer"], "agentbooksql": ["agentBooksili", "ownerbooksql", "agentbeansili", "agentiquessql", "agentpagesQL", "agentiquesql", " agentbookssql", "agentbooksquer", "agentbookQL", " agentBooksql", "agentiquesqu", " agentbooksQL", "agentbookquer", "ownerbooksquer", "agentpagessql", "agentiquesquer", "agentbooksili", "agentletsquer", "ownerbeansili", " agentbookql", "agentbeansquer", "ownerbeansquer", " agentbookili", "ownerbeansQL", " agentbookQL", "agentBooksQL", "agentpagesili", "agentiquesili", "agentBooksqu", "agentbookql", "agentbeansQL", " agentbooksili", " agentBookssql", "ownerbooksili", "agentbooksqu", " agentBooksquer", " agentBooksqu", "agentBooksql", "agentletsqu", "agentletssql", "ownerbooksQL", " agentbooksqu", " agentbooksquer", "agentpagesql", "ownerbeansql", "agentbookssql", "agentBooksquer", "agentbooksQL", "agentiquesQL", "agentBookssql", "agentbookili", "agentletsql", "agentbeansql"], "bookingid": ["Bookingsids", "bookillingid", "Bookingid", "bookingID", "bookillingID", "Bookingsid", "Bookingids", "bookingsids", "bookingsID", "bookingids", "BookingID", "BookingsID", "bookillingids", "bookingingids", "bookingingID", "bookingsid", "bookingingid"], "currentcoach": ["currentlyCoch", "currentcat", "currentcoarch", "currentcalch", " currentfoarch", "currentfoch", "currentconat", "currentCoACH", "currentCOat", "currentcasp", "currentlycoat", "currentlycach", "currentfoach", "currentlycac", "currentlycoac", "currentfoech", "currentlycasp", "currentCoarch", "currentcoac", " currentfoch", "currentCoach", " currentcoarch", "currentfoarch", "currentcalachable", "currentcoech", "currentlyCoech", "currentlycoch", " currentcoch", "currentcoeACH", "currentCOach", "currentcoachable", " currentfoach", " currentcoACH", "currentcoat", "currentlycoasp", "currentlycat", "currentcoch", "currentCoachable", "currentlycoachable", "currentconach", "currentfoACH", "currentCoech", " currentfoACH", "currentcalech", "currentCOac", "currentCoch", "currentcalach", "currentfoachable", "currentconac", "currentlyCoachable", "currentcoearch", "currentconasp", "currentcoasp", "currentlycoach", "currentcoACH", "currentcach", "currentcoeach", "currentlyCoach", "currentlycoech", "currentCOasp", "currentcac"], "currentseat": ["currentslot", "currentroute", "Currentsel", "reportedsel", "curroute", "currentlysen", " currentroute", "currentlysel", "Currentseat", "curport", " currentport", "Currentslot", "currentlyslot", "reportedport", " currentsel", "currentsel", "currentlyseat", "curseat", "cursel", "reportedroute", " currentsen", "reportedseat", "currentport", "currentsen", "Currentsen", " currentslot"], "tickpos": ["quoteno", "stickposition", "rickpo", "tickno", "snapPos", " tickprop", "testpo", "snappos", "tickpo", " tickpo", "ickposition", "ickPos", "ickpos", " tickposition", "popPos", "poppos", "tickposition", "quotepos", "quoteposition", "stickprop", " tickno", "checkposition", "rickprop", "quotePos", "rickPos", "stickPos", "testPos", "stickpos", "tickprop", "tickPos", "checkPos", "rickpos", "checkpos", "checkpo", "snapposition", "ickpo", "popposition", "testpos", "snappo", "testposition", "stickno", "poppo", "stickpo", " tickPos"], "chartavailupdsql": ["chartavailupsdssql", "chartavailupdssql", "chartavailupsdsq", "chartavailupsdatesql", "chartavailupdsQL", "chartavailupdatessql", "chartavailupysQL", "chartavailupyssql", "chartavailupsdatessql", "chartavailupysq", "chartavailupdsq", "chartavailupdatesql", "chartavailupysql", "chartavailupdatesq", "chartavailupdatesQL", "chartavailupdql", "chartavailupsdsQL", "chartavailupsdsql", "chartavailupsdatesq", "chartavailupdq", "chartavailupdQL", "chartavailupsdatesQL"]}}
{"id1": "17296916", "id2": "1097146", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"logging": ["Loging", "logger", " loging", "debugStorage", "debugging", "loging", " logStorage", "debugger", "logStorage", "debuging", "LogStorage", "Logger", " logger", "Logging"], "wrap": ["wra", "parse", "create", "rap", "read", "build", "W", "wire", "pad", "inter", "python", "add", "web", "xf", " wrapper", "word", "form", "transform", "shape", " wrapped", "x", "ow", "work", "aw", "pack", "ws", "chain", "format", "nw", "start", "handle", "me", "get", "safe", "root", "wrapper", "use", "sw", "find", "wind", "ew", "wa", "gate", "wx", "w", "sp", "message", "we", "link", "force", "reset", "store", "ad", "zip", "box", "window", "grow"], "buffer": ["reply", "Buffer", "binary", "bb", "memory", "surface", "view", "buff", "base", "attribute", "layer", "batch", "document", "flash", "print", "phrase", "complete", "trace", "flag", "body", "iter", "console", "word", "bar", "button", "queue", "profile", "line", "library", "reference", "cache", "ob", "database", "screen", "command", "note", "position", "face", "buf", "builder", "wrapper", "frame", "directory", "template", "row", "pb", "size", "block", "append", "message", "output", "display", "report", "sequence", "bo", "reset", "store", "table", "writer", "bridge", "window", "quote", "header"], "encoding": ["enryption", "enoded", "enumging", "enoding", "encoder", "enumlanguage", "enlanguage", "coding", "cododer", "cododing", "Encryption", "encoded", "enclanguage", "enumoding", "Encoding", "ecryption", "caling", "enaling", "Encoder", "Encaling", "encging", "ecoding", "cryption", "encaling", "ecoded", "ecoder", "codryption", "cging", "clanguage", "encryption", "enoder", "cododed", "enumoder", "enging", "coder"], "getEncoding": ["getencryption", "getencging", "getExpryption", " getEnination", "getencression", "getEnling", " getEnoding", "getExpression", "getEnging", "getOrigryption", " getEnling", " getEncging", " getEnression", "getencination", "getEncling", "getEncging", "getOrigination", "getEncression", "getencoding", " getEncling", "getencling", " getEnging", "getEnination", "getOrigling", " getEncryption", " getEnryption", "getExpoding", "getEncryption", "getEnryption", "getEnoding", " getEncression", "getEnression", "getOrigoding", " getEncination", "getExpging", "getEncination"], "headers": ["pres", "codes", "terms", "head", "modules", "tags", "images", "ers", "frames", "holders", "pins", "relations", "ports", "limits", "ilers", "ctors", "objects", "heads", "comments", "reports", "styles", "ids", "drivers", "checks", "params", "ppers", "chains", "builders", "names", "properties", "members", "rs", "users", "blocks", "writers", "values", "authors", "fields", "groups", "ters", "boxes", "keys", "weights", "caps", "header"], "is": ["isd", "tis", "ip", "ists", "dis", "iris", "or", "in", "bs", "\u00eds", "does", "os", "sis", "isin", "ui", "isc", "bis", "isi", "has", "was", "isf", "ist", "sys", "as", "iso", "lis", "nis", "ys", "ois", "its", "IS", "si", "ris", "fs", "ais", "ims", "isa", "mis", "iss", "ios", "isl", "obs", "ins", "osi", "us", "i", "Is", "ic", "ri", "ms"], "bos": ["oids", "tis", "dos", "nos", "pod", "ps", "bones", "bin", "ots", "bi", "bh", "bs", "fits", "js", "des", "os", "ui", "bot", "bis", "bas", "isi", "cs", "ones", "bits", "ts", "sys", "ows", "oss", "bes", "oos", "ms", "ys", "windows", "tops", "uts", "banks", "eros", "soc", "boards", "ubis", "lets", "oops", "ses", "ols", "los", "fs", "jas", "stats", "bo", "ios", "obs", "bytes", "cos", "ods", "uds", "aos", "tes"], "e": ["c", "t", "le", "ae", "v", "ev", "se", "es", "eeee", "re", "oe", "ne", "ate", "en", "ge", "r", "x", "ie", "err", "de", "er", "a", "n", "me", "p", "f", "d", "exc", "o", "E", "ex", "ee", "m", "g", "h", "i", "error", "ed"]}}
{"id1": "3046085", "id2": "6008635", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"s": ["gs", "c", "t", "text", "ss", "strings", "ps", "v", " ts", "es", "js", "str", "data", "os", "b", "e", "string", "q", "r", "is", "ls", "name", "a", "n", "its", "p", "f", "rs", "S", "w", "m", "h", "i", "g", "ns"], "tokenizer": ["operatoriter", "valueizable", "nodeization", " tokeniner", "okenzer", "tokenized", " tokener", "dateizable", "nodeisher", "Tokenize", "Tokenization", "okenizer", "terminisher", "serialzer", "terminizer", "valueisher", "valueoser", "tokenazer", "tokenitor", "Tokenizers", "serialize", "okenifier", "okenisher", "operatoriser", "toolize", "serializable", " tokenzie", "nodeized", "tokener", "okenitor", "okenener", " tokenifier", "Tokenized", "terminizable", "okeniser", "dateize", "kinizers", "okeniter", "templateizer", "tokenisher", "tokenization", "Tokenner", "terminize", "terminiser", "tokenize", "terminization", "kinizer", "tokeniner", "templateer", "toolizer", " tokenener", "datezer", "operatorzie", "okenner", " tokenner", "kinzer", " tokenoser", "operatorized", "Tokenzer", "tokenener", "templateisher", "templatezer", "tokenizers", "operatorization", "terminitor", "webitor", " tokenzer", "operatoriner", "tokenner", "operatorazer", " tokenisher", "dateizer", "okeniner", "valueizer", "okenoser", "nodeizer", "webizer", "operatorisher", "webizable", "Tokenisher", "terminazer", "templateizable", " tokenization", "Tokenifier", "templateization", "Tokener", "kinize", "okenizable", "webisher", "okenazer", "tokeniser", "terminiter", " tokenizable", "tokenzie", "toolizers", "okenize", "tokenifier", "tokeniter", "tokenzer", "Tokenener", "webize", "toolzer", "okenzie", "webization", "operatorizer", "tokenoser", "Tokenizer", "tokenizable", "serializer"], "title": ["version", "meta", "text", "t", "tip", "Title", "type", "itled", "part", "displayText", "id", "total", "story", "author", "phrase", "prefix", "holiday", "lead", "profile", "horse", "primary", "art", "name", "term", "metadata", "note", "position", "description", "template", "important", "tag", "label", "article", "table", "source", "filename", "itle", "summary"], "artist": ["object", "track", "photo", "volume", "part", "chapter", "user", "archive", "attribute", "author", "assisted", "username", "component", "image", "song", "picture", "adult", "creator", "audio", "player", "item", "art", "metadata", "position", "Artist", "project", "folder", "album", "music", "directory", "tag", "rank", "gallery", "voice", "person", "associated", "source"], "location": ["zone", "country", "translation", "near", "comment", "loc", "language", "phone", "place", "origin", "shape", "reference", "time", "address", "activity", "Location", "position", "direction", "layout", "feature", "media", "folder", "description", "directory", "local", "gallery", "area", "source"], "rating": ["meta", "scale", "frequency", "score", "average", "training", "erate", "scoring", "playing", "boarding", "profile", "library", "credit", "metadata", "rate", "weight", "confidence", "media", "music", "rates", "rank", "fps", "Rating", "rated", "movie", "genre", "ranking", "race"], "overplay": ["Overgrade", "overgrade", "appride", " overgrade", "Overcast", " override", "Override", "override", "appcast", "Overplay", "appplay", "overcast", " overcast", "appgrade"], "temp": ["tem", "generated", "tmp", "encrypted", "unit", "memory", "buffer", "type", "Temp", "base", "test", "loc", "flash", "now", "prefix", "porary", " tmp", " temporary", "time", "cache", "Temperature", "partial", "created", "stem", "tm", "name", "term", "mem", "orig", "template", "local", "texture", "emp", "output", "null", "empty", "fake", "current", "source", "key", "set", " Temp"], "tags": ["terms", "ags", "strings", "details", "links", "flags", "parts", "images", "lists", "assets", "relations", "options", "marks", "balls", "thumbnails", "pages", "tracks", "reports", "comments", "dates", "styles", "words", "names", "atts", "stats", "Tags", "types", "lines", "nets", "packages", "lights", "files", "fields", "groups", "keys", "weights", "stars"], "bytes": ["videos", "gs", "terms", "classes", "es", "bs", "parts", "services", "images", "frames", "gets", "bits", "rows", "pages", "mb", "comments", "ids", "bps", "Bytes", "words", "len", "loads", "gb", "uploads", "lines", "seconds", "blocks", "values", "files", "fields", "groups", "keys", "vals", "ips", "tes"], "hasher": ["hadher", "hydHer", "hadter", "hadger", " hascher", "haveest", " hasDR", "haveher", "hahers", "haser", "haest", "hater", "hadHer", " haser", "haster", " haster", "hadpher", "HasDR", " hader", "hashers", " hasest", "haveter", " hadher", "haher", "hascher", "havehers", "hasHer", "Hashed", "hydher", "hasest", " hadDR", " hashed", "hadcher", "hasDR", " haspher", " hadter", " hasHer", "Haster", "hasger", " hashers", "hydcher", "haspher", "Hasher", " hasger", "hashed", "Haser", "Haspher", "hydger", "hadhed"]}}
{"id1": "14758866", "id2": "20920051", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourceInSteam", "getStreamasSteam", "getResourceAsForm", "getResourceInStream", "getResourceasSteam", "getResourceasInput", "getResourceInForm", "getStreamAsInput", "getStreamAsForm", "getResourceAsInput", "getResourceasForm", "getStreamasInput", "getStreamAsSteam", "getResourceAsSteam", "getStreamAsStream", "getResourceASForm", "getResourceasStream", "getResourceASSteam", "getResourceASStream", "getStreamasStream", "getStreamasForm", "getResourceInInput", "getResourceASInput"], "name": ["version", "location", "type", "Name", "run", "part", "base", "id", "file", "ame", "image", "prefix", "error", "uri", "string", "missing", "client", "path", "cache", "title", "address", "a", "format", "n", "password", "NAME", "pkg", "names", "description", "search", "local", "size", "domain", "initial", "resource", "filename", "remote", "word", "source", "key"], "inputStream": ["quickSteam", "currentFile", "InputSteam", "inputChannel", "quickStream", "uploadView", "uploadStream", "rawSteam", "quickChannel", "inputPort", "currentPort", "rawView", "currentSteam", "rawstream", " inputView", "uploadstream", "InputChannel", "inputFile", "inputstream", "quickForm", " inputSteam", "inputView", "InputStream", "InputPort", " inputForm", "InputFile", " inputChannel", "inputForm", "InputForm", " inputFile", "inputSteam", "rawStream", " inputstream", " inputPort", "currentStream", "uploadSteam"], "in": ["io", "bin", "buffer", "din", "stream", "data", "file", "inner", "inf", "mc", "r", "input", "In", "n", "p", "info", "edIn", "o", "IN", "con", "context", "ins", "m", "ai", "xml"], "out": ["c", "t", "tmp", "io", "buffer", "dis", "cfg", "inv", "conn", "os", "user", "log", "inter", "print", "l", "b", "inner", "ln", "dir", "sys", "client", "cache", "res", "err", "obj", "nt", "screen", "conv", "up", "n", "p", "pretty", "all", "info", "list", "o", "net", "cn", "outs", "w", "group", "Out", "output", "gov", "report", "ins", "ex", "m", "to", "last", "msg", "writer", "ou", "OUT", "outer"], "url": ["dl", "cl", "location", "build", "rl", "nl", "mount", "str", "re", "base", "html", "server", "this", "log", "file", "raw", "el", "loc", "l", "b", "gl", "web", "uri", "il", "https", "r", "ssl", "browser", "impl", "path", "ls", "mail", "ref", "address", "bel", "ur", "handle", "get", "f", "github", "http", "ll", "hl", "link", "rel", "domain", "abs", "URL", "char", "sql", "git", "addr", "call", "resource", "xml", "Url", "remote"], "remoteName": ["quickPath", "localname", "externalName", " remotename", "localPath", "remoteKey", "quickname", "remotename", "externalPath", " remoteKey", " remotePath", "commonKey", "remotePath", "externalname", "commonname", "commonName", "quickKey", "quickName", "externalKey", "localKey", "commonPath"], "localName": ["LocalKey", "fixedFilename", "remoteNode", "localNAME", "localname", "shortFilename", "shortName", " localNames", "locNode", "remoteFile", " localFilename", "Localname", "localValue", "remoteNames", "LocalNames", "localType", "localNames", "fullName", " localValue", "locFile", " localNode", "fixedNAME", "localImage", "remoteKey", "localFilename", "fullNames", "LocalValue", "fixedName", "fullKey", " localFile", "localFile", " localname", "fullValue", "remoteImage", " localImage", "locFilename", "singleName", " localType", "remoteFilename", "LocalName", "locImage", "remoteType", "fullname", "singleFilename", "remoteValue", "locValue", "singlename", "shortNAME", "localKey", "shortname", " localKey", "singleNAME", "localNode", "locType", "fixedname", "locName"], "host": ["ip", "top", "base", "bind", "server", "loc", "Host", "hook", "dir", "hd", "uri", "localhost", "client", "cert", "path", "www", "address", "chain", "handle", "root", "http", "height", "target", "hop", "ost", "local", "domain", "subject", "addr", "h", "ca", "remote", "campus", "source", "home", "system"], "prot": ["version", "tp", "type", "top", "rot", "col", "server", "prop", "pool", "prefix", "iot", "prototype", "https", "at", "uri", "client", "pattern", "crypt", "ssl", "platform", "path", "Prot", "ref", "format", "typ", "header", "password", "pkg", "http", "pat", "net", "tel", "ping", "eth", "ios", "ret", "pro", "sche", "ocol", "ht", "system"], "port": ["version", "pid", "padding", "point", "Port", "server", "length", "column", "file", "test", "pool", "print", "trust", "language", "eport", "ports", "pt", "trace", "post", "localhost", "limit", "client", "duration", "pi", "PORT", "note", "position", "width", "password", "project", "p", "pe", "timeout", "number", "proxy", "ping", "size", "message", "report", "ort", "pro", "socket", "priority", "pport", "page", "key"], "cacheFile": ["tempFilename", "localfile", " cachefile", "cacheFiles", "CacheDir", "tempFile", "proxyFile", "proxyfile", "tempfile", "CacheStore", "acheField", "proxyInfo", " cacheEntry", "mapfile", "localStore", " cacheFolder", "apacheInfo", "localDir", " cacheInfo", "acheFile", "CacheFiles", " cacheDir", "CacheFolder", "acheFolder", "cacheFolder", "proxyFolder", "apacheFolder", "localField", "cacheFILE", "mapFile", "localEntry", "CacheFILE", "apachefile", "mapStore", "cacheFilename", " cacheFilename", "tempFILE", "localFile", "CacheFile", "achefile", "mapDir", "Cachefile", "cacheField", "cacheStore", " cacheField", " cacheFILE", "apacheFile", "cacheInfo", "localFiles", "acheDir", " cacheStore", "cacheEntry", "CacheEntry", "cacheUser", " cacheFiles", " cacheUser", "localUser", "cachefile", "acheUser", "cacheDir", "CacheFilename"], "urlConnection": ["UrlConnect", "UrlConnection", "dlConnector", "httpConnect", "dlconnection", "llConnection", "sslConnection", "urlConnect", "UrlResponse", "browserConnector", "URLFile", "sslConnect", " urlconnection", "browserFile", "methodLink", "urlComment", "Urlconnection", "urlLink", "urlconnection", "dlConnection", "httpConn", "httpconnection", "methodConnection", "channelConnector", "browserConnection", " urlTransaction", "sslTransaction", "urlConn", "urlFile", "channelComment", "llConnector", "browserconnection", "URLConn", "URLConnect", "dlConnect", "URLConnection", "httpLink", "browserConnect", " urlConnect", "browserConn", "llConn", "sslconnection", "dlConn", "urlResponse", "channelConnection", "methodConnect", "httpFile", " urlResponse", "llconnection", "UrlLink", "URLConnector", "browserResponse", "URLComment", "dlComment", "methodconnection", "httpConnection", "urlConnector", "urlTransaction", "httpTransaction", "channelConnect"], "httpURLConnection": ["httpsHTTPConnect", "httpPORTConnection", "httpURLNetwork", "httpsHTTPConnector", "HttpURLConnect", "historyILconnection", "httpSRconnection", "httpALLConnect", "httpSRConnection", "githubUrlconnection", "httpUrlconnection", "httpDOMEntry", "httpsHTTPConnection", "httpSSLConnection", "httpILConnect", "httpsURLConnection", "httpMLConnect", "httpHTTPTransaction", "httpALLConn", "webUrlConnect", "historyILNetwork", "httpHTTPEntry", "httpsURLConnect", "historyURLConnection", "httpILconnection", "httpULConnection", "webUrlconnection", "httpsURLConnector", "HttpHTTPConnect", "httpUrlEntry", "httpDOMConnection", "httpDOMConnect", "httpDBconnection", "historyURLConnect", "httpUrlNetwork", "webUrlConnection", "httpHTTPconnection", "githubURLConnection", "HttpURLEntry", "httpULEntry", "httpMLConnection", " httpMLConnection", "githubURLConnect", "webURLConnection", "httpPORTConnector", "HttpHTTPConnector", "httpURLConnector", "httpTLConnect", "httpHTTPInstance", "HttpURLConnection", "httpURLTransaction", "httpUrlConnect", "httpDOMconnection", "historyURLNetwork", "httpPORTConnect", "httpURLconnection", "HttpURLConnector", "httpULConnect", " httpURLconnection", "historyILConnection", "githubUrlConnect", "httpHTTPNetwork", "httpTLConn", " httpMLconnection", "httpILConnection", " httpURLConnect", "webURLConnect", "httpHTTPConn", "httpsHTTPConn", "webURLconnection", "HttpURLconnection", "HttpHTTPConnection", "HttpHTTPConn", "httpSSLInstance", "httpHTTPConnection", "httpURLEntry", "HttpHTTPInstance", "webURLEntry", " httpMLConn", "httpUrlConnector", " httpURLConn", "httpURLConn", "githubURLTransaction", "httpREConnection", "httpSRConnect", "httpSSLEntry", "httpMLconnection", "httpSRConn", "githubUrlConnection", " httpMLConnect", "HttpHTTPconnection", "httpHTTPConnector", "httpULInstance", "httpHTTPConnect", "httpUrlTransaction", "httpALLconnection", "webUrlEntry", "historyILConnect", "httpDBConnection", "githubUrlTransaction", "httpURLConnect", "githubURLconnection", "httpALLConnection", "HttpURLConn", "httpTLConnection", "historyURLconnection", "httpSSLConnect", "httpREConnector", "httpILNetwork", "httpsURLConn", "httpTLConnector", "httpMLConn", "httpREConnect", "HttpHTTPEntry", "HttpURLInstance", "httpUrlConnection", "httpREConn", "httpDBTransaction", "httpURLInstance", "httpDBConnect"], "responseCode": ["requestCode", "replyActionCode", "resultCount", "ResponseSize", "requestCount", "responseClass", "ResponseCode", "responseSize", " responseClass", " responseActionCode", "complianceCategory", "complianceClass", "replyClass", "resultSize", " responseCategory", "replyCategory", "complianceCode", "complianceActionCode", "responseCategory", "resultCode", "requestClass", "responseActionCode", "ResponseCount", "resultClass", "requestSize", "responseCount", "ResponseClass", "replyCode"], "lastModified": ["lastMODify", "lastTrmodified", "LastModified", "lastTrification", "lastTred", "lastmoded", "LastContentified", "lastModed", "_", "lastTrify", "lastContentify", " lastModification", "lastmodify", " lastTrmodified", "LastContentification", "lastmodified", "lastTrifier", "lastModifier", "lastMODification", " lastModmodified", "lastModmodified", "LastContentify", " lastTrification", " lastTred", " lastTrify", "lastContentification", "LastContentifier", "lastContentifier", " lastModed", "lastMODified", "New", "LastModifier", "lastMODifier", "lastModify", " lastModify", "lastContentmodified", "LastModification", "lastmodification", "lastModification", "lastContentified", " lastTrified", "lastContented", "LastModify", "lastTrified", "lastmodmodified"]}}
{"id1": "416857", "id2": "23273706", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 0, "substitutes": {"process": ["scan", "parse", "create", "read", "run", "processing", "walk", "update", "proc", "Process", "input", "check", "work", "program", "step", "accept", "loop", "exec", "handle", "processor", "load", "execute", "output", "display", " ingest", "task", "filter"], "dir": ["dl", "tmp", "det", "cd", "wd", "org", "dr", "orig", "src", "lib", "host", "str", "data", "html", "md", "id", "rot", "this", "log", "file", "disk", "ind", "loc", "div", "mod", "prefix", "dd", "del", "out", "mk", "Dir", "www", "DIR", "name", "dat", "tar", "old", "start", "handle", "root", "url", "direction", "grad", "pkg", "d", "folder", "http", "fd", "directory", "cur", "dist", "local", "desc", "rect", "rel", "vol", "ir", "direct", "deg", "doc", "lim", "addr", "window", "db", "filename", "home", "def", "txt"], "list": ["dl", "li", "tmp", "v", "detail", "state", "data", "select", "batch", "left", "spec", "names", "pre", "null", "config", "filter", "def", "other", "history", "details", "dict", "L", "this", "LIST", "file", "collection", "l", "lists", "now", "add", "lat", "sort", "ist", "out", "single", "listed", "ls", "index", "cache", "get", "delete", "match", "record", "local", "link", "see", "write", "status", "copy", "range", "tree", "length", "ln", "string", "line", "map", "old", "block", "table", "cont", "source", "set", "re", "str", "log", "test", "print", "dump", "result", "queue", "split", "chain", "name", "note", "array", "all", "number", "rm", "sequence", "st", "display", "stat", "show", "code", "word", "form"], "n": ["c", "np", "t", "count", "v", "ng", "sn", "nu", "nl", "nr", "ne", "total", "norm", "l", "ln", "na", "nn", "no", "pi", "nt", "name", "nan", "nw", " N", "un", "N", "p", "d", "ni", "len", "names", "network", "number", "nb", "net", "num", "w", "nor", "j", "m", "nm", "z", "g", "nc", "ns"], "bubblesort": ["bubblingORT", "gobblingorter", "bubbledorter", "bubbsORT", "bubbsorter", "robbledist", "bubblort", "robbledorts", "bubblingorts", "gobbsORT", "robbledorter", "robblesorter", "bubblesorter", "gobblesord", "bubblerv", "gobblingerv", "robbledort", "bubblingort", "gobbleorter", "bubblingorter", "gobblessort", "bubbsord", "bubblersort", "bubbledord", "bubbledorts", "bubbsort", "bubblingord", "bubblorter", "bubbleserv", "bubbleorter", "robblesorts", "bubblessort", "gobblingort", "bubblesist", "bubbledORT", "bubbsist", "gobbleort", "gobbleserv", "bubbledsort", "gobblingsort", "gobblesorter", "bubbleorts", "gobbsort", "bubbledort", "robbledord", "robblesist", "gobblesist", "gobbsorter", "bubbsorts", "robblessort", "bubblerord", "bubblerort", "gobbsord", "bubblerorter", "bubblingerv", "robbledsort", "gobblesort", "robblesord", "gobbleist", "bubbleord", "bubbleist", "bubbledist", "bubblsort", "bubblesORT", "bubblesord", "bubblingsort", "bubblederv", "bubbleort", "robblesort", "gobblesORT", "bubblesorts", "bubbssort"], "i": ["li", "y", "v", "bi", "ii", "xi", "I", "batch", "iter", "hi", "cli", "ami", "is", "err", "exp", "init", "ini", "ei", "ims", "sim", "j", "my", "g", "zi", "us", "parent", "ic", "io", "in", "multi", "u", "this", "l", "e", "q", "x", "ki", "index", "pi", "ij", "iri", "qi", "di", "record", "s", "fire", "ity", "eu", "point", "id", "mi", "gi", "uri", "ji", "iq", "me", "p", "si", "ix", "it", "to", "key", "set", "c", "phi", "ui", "ind", "iu", "go", "oi", "im", "ti", "ci", "chain", "ex", "m", "z", "ai", "ri"], "f": ["t", "fr", "tf", "c", "aff", "v", "fe", "fac", "bf", "fb", "file", "l", "b", "fab", "af", "df", "lf", "fm", "fw", "p", "d", "fd", "fs", "fp", "w", "fc", "elf", "fi", "m", "F", "sf", "h", "cf"], "img": ["imgur", "tmp", "pic", " im", "jpg", "org", "aj", "shr", "src", "amp", "medium", "html", "md", "fb", "raw", "aug", "images", "orm", "image", "now", "jp", "Image", "inf", "picture", "im", "png", "imag", "uf", "mb", "impl", "dm", "fm", "util", "anim", "ref", "obj", "conv", "og", "small", "fig", "buf", "url", "gif", "mp", "tif", "gb", "it", "j", "gm", "m", "h", "good", "window"], "whichcase": ["whocase", " whichstring", "whostring", "whosetest", "whotest", " whichmatch", "howchar", "whosepath", "whetherrule", "wheretest", "whatspace", "whichrule", "whichcatch", "howtest", "whichspace", "whatmatch", "whatrule", "whoCase", "howrule", "whoseCase", "whethercatch", "whichpath", "whatCase", "whopath", " whichpath", "whichCase", " whichspace", " whichrule", "whichtest", "whattest", "howcase", "whichmatch", "howspace", " whichtest", "whethercase", "whatcase", "whorule", "wherecase", "whereCase", "whatstring", " whichchar", "whatchar", "whethertest", "whichchar", "whererule", "howCase", "whatcatch", "howmatch", "wherematch", "wherecatch", " whichCase", "whosematch", "whichstring", "howstring", "whosecase"], "lastDigit": [" lastDigita", "lastDbit", "lastPosit", "lastHourita", "lastDigbit", "lastdigit", "maxDigbit", "maxdigit", "firstdiguster", "firstdigbit", "firstdigiter", "lastDiguster", "firstdigi", "firstdigit", "firstDigot", "maxdigbit", "firstDiguster", "lastDiget", "firstDigiter", "lastDigot", "lastdiguster", "lastPosbit", "lastdigiter", " lastDigbit", "lastDigi", "lastDiter", "firstdigot", "lastdigot", "firstDigit", " lastDigot", "lastDet", "lastDoublebit", "lastValit", "lastDit", "firstDigbit", "lastPositer", "lastHourit", " lastdigit", "maxdigiter", "lastDoubleit", "lastHourot", "lastdigita", "lastDoublei", "lastValbit", "lastPosot", "maxdigot", " lastdigiter", "lastdigbit", "lastHourbit", "firstDigi", "lastdiget", "lastDigita", " lastDigiter", " lastDiget", "lastDoubleuster", "maxDigiter", "lastdigi", "lastPosuster", " lastdiget", "lastValet", " lastdigbit", "lastPosi", "maxDigot", "lastDigiter", "maxDigit", "lastValiter"], "sorted": ["unsorted", "Sorted", "insort", "sorting", "unsorter", "Sort", "isorting", "sorter", "sort", "Sorter", "Sorting", " sort", "unsorting", "unsort", "insorting", "insorted", " sorter", " sorting", "isorter", "isort", "insorter", "isorted"], "temp": [" temperature", "tem", "level", "t", "tmp", "v", "buffer", "Temp", " total", " v", " w", "base", "test", "porary", " t", " temporary", "stem", "orig", "mp", "local", "w", "pre", "emp", "tim", "m", "fake", " tmp", "txt"], "tempp": ["compl", "comple", "compp", "temple", "typle", "timpps", "typl", "typp", "tempps", "timpp", "compps", "typps", "templ", "timple", "timpl"]}}
{"id1": "15445861", "id2": "13783549", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyDir", "cpfile", " copyfile", "copyfile", "copyFiles", " cpfile", "cpFile", "cpFiles", " copyDir", " copyFiles", " cpFile", " cpDir", " cpFiles", "cpDir"], "srcFile": [" srcModel", "destPage", "sysLine", " srcfile", " srcLine", "srcModel", "srcPath", "sourceDir", "synWeb", "rcPath", "sqFile", "rcDir", "rcfile", "sourceFile", "sysfile", "synFile", "srcWeb", "sysFile", "srcLine", " srcTime", "sysWeb", "sourceModel", "sourcePage", " srcDir", "destfile", "sqPage", " srcPath", "sourcefile", "srcfile", "sqTime", "srcPage", "synLine", "sourceLine", " srcPage", "rcFile", "synfile", "srcTime", " srcWeb", "sourcePath", "rcPage", "rcTime", "rcLine", "destModel", "srcDir", "sqLine"], "destFile": ["destPage", "DestDir", "gtEmail", "destTable", "DestFine", " destTable", " destFolder", "tomFILE", "destLine", "tomPort", "destEmail", "DestFolder", " destfile", "gtFILE", "sourceDir", "imgfile", "optFile", "tomFile", "destDir", "optTable", "potfile", "sourceFile", "imgFile", "destFolder", "estFile", "estEmail", "destFILE", "Destfile", "tomEmail", "expPlace", "destPort", "portPlace", "potFile", "sourceFine", "destfile", "sourcefile", "DestFile", "destFine", "potPort", "gtPlace", "potDir", "gtLine", "expPage", "destPlace", "gtPort", "imgFine", "gtFile", "DestTable", "expFile", "gtPage", "estFILE", "estPort", "optFolder", "optDir", "portLine", "DestPort", "portFile", " destDir", "portPage", "expLine", " destPort", "imgDir"], "in": ["io", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "ze", "inf", "ain", "inside", "im", "iter", "is", "input", "irm", "al", "up", "In", "on", "old", "gin", "init", "info", "ini", "IN", "con", "it", "from", "ar", "ins", "inn", "cin", "act", "i", "mm", "ic", "source", "by"], "out": ["c", "t", "io", "v", "dis", "can", "write", "OUT", "ne", "user", "auto", "log", "inner", "at", "sys", "client", "gc", "cache", "res", "err", "end", "obj", "nt", "up", "n", "on", "co", "o", "net", "con", "one", "cn", "outs", "it", "ch", "output", "sum", "Out", "ex", "null", "to", "writer", "ou", "aos", "by", "outer", "and"], "buffer": ["history", "binary", "memory", "Buffer", "stack", "pad", "base", "buff", "length", "comment", "total", "raw", "attribute", "bank", "batch", "document", "phrase", "print", "temp", "body", "iter", "word", "bar", "queue", "library", "cache", "reason", "command", "variable", "mem", "buf", "bone", "paste", "frame", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "bridge", "window"], "no": ["NO", "nos", "io", "read", "sn", "po", "ne", "nr", "os", "total", "pos", "go", "na", "lo", "sha", "nn", "never", "none", "mo", "zero", "index", "eno", " No", "orno", "a", "n", "un", " NO", "vo", "start", "ni", "No", "number", "o", "num", "bo", "how", "ano", "yes", "to", "node", "not", "i", "who", "ko"]}}
{"id1": "23199071", "id2": "7087108", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getReadStream", "newInputSource", "getReadBody", "getReadSource", "getInputSource", "newOutputSource", "newOutputBody", "getReadFile", "getInputFile", "newOutputStream", "newOutputFile", "getContentSource", "getOutputSource", "newInputBody", "getOutputStream", "getOutputFile", "getOutputBody", "getContentBody", "getInputBody", "newInputFile", "getContentStream", "getContentFile", "newInputStream"], "url": ["dl", "location", "build", "ul", "host", "nl", "mount", "str", "base", "html", "server", "u", "this", "full", "raw", "log", "id", "lr", "loc", "print", "l", "web", "uri", "https", "string", "q", "r", "ssl", "impl", "browser", "path", "ls", "res", "mail", "email", "ref", "address", "sl", "err", "ur", "f", "pl", "http", "val", "row", "api", "ll", "internal", "link", "hl", "rel", "ret", "URL", "null", "pp", "resource", "Url", "remote", "page"], "file": ["tile", "object", "t", "checked", "le", "buffer", "fe", "lib", "base", "user", "FILE", "full", "File", "relation", "image", "print", "language", "dir", "uri", "source", "ile", "path", "library", "util", "check", "job", "mail", "ref", "obj", "entity", "name", "f", "folder", "info", "template", "fp", "event", "local", "link", "field", "message", "fi", "table", "resource", "page", "rule", "db", "filename"]}}
{"id1": "17716716", "id2": "14473711", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "label": 1, "substitutes": {"plainToMD": [" stringAsmd", " stringToDM", " stringAsMD", " convertToMC", " stringFromDM", " stringFrommd", " stringTomd", " convertToDM", " convertAsDM", " stringToMD", " convertTomd", " convertAsMD", " stringToMC", " convertAsMC", " stringAsDM", " stringAsMC", " convertToMD", " stringFromMC", " convertAsmd", " stringFromMD"], "loggerCol": ["logiderCol", "logggerCol", "logiderColumn", "loggerColl", "badinatorCol", " loggerCOL", "logGERCOL", "badgerCl", "logggerCl", "badinatorCl", "logggerColl", "loginatorColl", "badinatorCOL", " logggerCOL", "loggerColumn", "loginatorCol", "loggeCOL", "logggerCOL", " logggerCol", "badinatorColl", "loggeCol", " loggerColumn", "loggeColl", "badgerColl", "loggerCOL", "logiderCOL", "badgerCol", "logGERCol", " logggerColumn", "loginatorCl", "loginatorCOL", "logggerColumn", "logGERColumn", "loggerCl", "loggeCl", "badgerCOL"], "input": ["text", " inputs", "example", "request", "buffer", "in", "active", "str", "data", "base", "this", "raw", "file", "document", "image", "prefix", "result", "string", "q", "out", "pattern", "hash", " Input", "up", "command", "Input", "url", "hello", "value", "it", "context", "output", "from", "subject", "char", "initial", "config", "background", "source", "form"], "byteHash": ["ByteLength", "binaryHash", "byteshash", " byteMap", "binaryhash", "ByteHas", "Bytehash", "bytesHas", "binaryHas", "ueHash", "ueTr", "ByteMap", "ByteHash", " byteHas", "byteHas", " byteTr", "bytehash", "uehash", "ByteTr", "byteTr", " bytehash", "ueLength", "byteMap", "bytesHash", " byteLength", "bytesMap", "byteLength"], "md": ["pm", " Md", "bd", "MD", "ct", "det", "cd", "med", "gr", "dr", "ng", "sd", "sm", "sam", "mt", "ind", "mod", "add", "dd", "hd", "mc", "dig", "cmd", "ds", "df", "mk", " mc", "mb", "dm", "mo", "nd", "mac", "ms", "cond", "de", "pd", "material", " MD", "grad", "mg", "mp", "d", "comp", "der", "di", "ld", "rm", "mn", "od", "hash", "met", "gm", "m", "doc", "msg", "red", "mm", "ded", "def"], "md5result": ["MD5response", "md45comment", "md65Result", "MD2comment", "md5Result", "md7string", "md5response", "md3result", " md5Result", "md8Result", "md8proc", "MD5result", "md64comment", "md5results", "md5comment", "md7result", "md5message", "MD2string", "md2result", "md3string", "md8result", "md2response", "md3message", "md7results", "md45response", "md65result", "md3proc", " md5message", " md5proc", "md8message", "md64response", " md8proc", "md3results", "MD5results", " md8Result", "md2comment", "md2Result", "MD2result", "md5proc", "MD5Result", "md45result", "md2results", "md65message", " md8result", "md3Result", "md45results", "MD2results", "md2string", "md7Result", " md8message", "md64results", "MD5comment", "md5string", "MD5string", "MD2Result", "md64result", "MD2response", "md65proc"], "i": ["ip", "c", "li", "y", "io", "v", "span", "bi", "in", "ii", "phi", "multi", "key", "I", "id", "u", "xi", "ui", "ind", "mi", "l", "b", "gu", "gi", "uri", "im", "iter", "q", "cli", "x", "is", "ti", "ie", "index", "ci", "pi", "ji", "a", "n", "me", "qi", "si", "init", "ix", "di", "ims", "ei", "o", "it", "sim", "j", "my", "\u0438", "m", "z", "ai", "fi", "us", "ic"]}}
{"id1": "16232202", "id2": "11005804", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"doPost": ["Dopost", "handlepost", "handleAdd", "doPOST", "DoPOST", "handlePOST", "doAdd", " doAdd", "handlePost", "DoAdd", "DoPost", " doPOST", "dopost", " dopost"], "request": ["claim", "begin", "select", "web", "session", "browser", "reference", "work", "address", "position", "pe", "media", "frame", "first", "list", "directory", "message", "condition", "subject", "initial", "xml", "remote", "version", "worker", "order", "server", "attribute", "collection", "require", "client", "the", "application", "open", "req", "get", "local", "record", "context", "law", "requ", "remove", "create", "ire", "user", "controller", "raw", "QUEST", "document", "post", "setup", "environment", "quest", "url", "template", "query", "have", "process", "reset", "call", "forward", "re", "view", "connection", "print", "complete", "register", "result", "input", "runtime", "command", "handle", "Request", "http", "report", "current"], "response": ["version", "reply", "respond", "object", "onse", "exit", "location", "detail", "status", "social", "view", "re", "connection", "answer", "server", "document", "image", "print", "next", "continue", "e", "session", "console", "render", "out", "profile", "esi", "security", "video", "application", "res", "environment", "position", "resp", "send", "ve", "description", "http", "network", "service", "event", "site", "sequence", "output", "message", "settings", "report", "entry", "shell", "Response", "page", "header", "summary"], "cu": ["cul", "c", "CU", "du", "um", "ua", "cy", "nu", "eu", "ocr", "chu", "ctx", "aus", "uc", "ub", "u", "ui", "umi", "cro", "uo", "ut", "gu", "cus", "su", "UD", "cum", "tc", "ck", "cp", "hu", "cgi", "uci", "ue", "util", "ci", "uu", "gru", "ucc", "ur", "co", "cci", "cpu", "aco", "unc", "pu", "ju", "zu", "cn", "tu", "cm", "bo", "hua", "au", "angu", "yu", "U", "lu", "us", "mu", "ru", "Cu", "ou", "lc"], "ud": ["eus", "bd", "dl", "du", "um", "urd", "td", "eu", "und", "uid", "dk", "aus", "uc", "u", "ui", "ut", "udo", "gu", "udd", "cus", "dd", "UD", "su", "uda", "vd", "hd", "ck", "edu", "htt", "ow", " du", "ci", "aud", "util", "pd", "uu", "ur", "uh", "unc", "d", "di", "udi", "gb", "ld", "ord", "od", "zu", "ku", "ost", "tu", "unt", "gd", "us", "ad", "uds", "oud", "mud", "ub", "rod"], "returnTo": ["ReturnTo", "urnTarget", "render2", "addto", "endTo", "Return2", "endTO", "return2", "endTarget", "ReturnTO", "addTO", "Returnto", "addTo", "returnTarget", "endto", "urnTO", "returnto", "renderTO", "returnTO", "addTarget", "urnto", "urn2", "renderto", "urnTo", "renderTo"], "password": ["pty", "padding", "secret", "wd", "PASS", "default", "user", "attribute", "ssh", "pool", "username", "phrase", "prefix", "trust", "sword", "profile", "definition", "pattern", "crypt", "security", "email", "database", "remember", "login", "command", "shadow", "paste", "description", "token", "hello", "message", "reset", "auth", "word", "Password", "push"], "md": [" Md", "bd", "MD", "dh", "pdf", "det", "cd", "Cmd", "td", "sd", "sm", "mt", "mod", "dd", "hd", "mc", "cmd", "df", "mk", "mb", "dm", "nd", "amd", "mac", "magic", "pd", " MD", "grad", "d", "der", "ld", "mn", "od", "m", "msg", "mm", "mg", "ms", "and"], "hash": ["where", "oh", "str", "data", "html", "raw", "ash", "test", "Hash", "flash", "has", "hex", "ho", "result", "hd", "dig", "sha", "tr", "shift", "check", "mac", "rh", "handle", "shadow", "her", "hed", "height", "init", "len", "rand", "sum", "ashes", "bytes", "char", "sh", "h", "key"], "pass": ["ack", "priv", "ps", "read", "wd", "secret", "PASS", "default", "conn", "push", "prop", "pos", "test", "pool", "Pass", "add", "zip", "ass", "pas", "session", "ph", "mask", "alias", "step", "pack", "handle", "pkg", "conf", "tag", " def", "cat", "ask", "pp", "act", "task", "fail", "auth", "pg", "def"], "vis": ["pres", "priv", "v", "tri", "type", "circ", "iz", "status", "state", "cfg", "inv", "ver", "view", "san", "str", "visible", "rav", "VIS", "mod", "vid", "gu", "serv", "comm", "miss", "hidden", "feat", "is", "study", "vert", "cond", "ha", "att", "var", "info", "val", "wa", "mit", "nav", "vol", "virt", "cap", "display", "stat", "label", "see", "act", "Vis", "key", "access", "def"]}}
{"id1": "2461169", "id2": "15905041", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileAsFiles", "decodeString2Files", "decodeStringTofile", "decodeString2String", "decodeStringToFiles", "decodeFileFileFiles", "decodeFileTofile", "decodeStringToString", "decodeFileToFiles", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2Files", "decodeFileFileFile", "decodeFileToString", "decodeString2file", "decodeFile2file", "decodeFileAsString", "decodeString2File", "decodeStringToFile", "decodeFileFileString", "decodeFile2String", "decodeFile2File", "decodeFileAsfile"], "infile": ["isinfile", "outname", "isinFile", "isinfolder", "outfolder", "outFile", "inputfile", "infolder", "Infilename", "fromfile", "inputname", "frombase", "InFile", "outfilename", "Infile", "inputfolder", "inbase", "inputFile", "infilename", "outbase", "isinname", "inname", "inFile", "Inbase", "fromfilename", "fromFile"], "outfile": ["otFile", "outname", "outFILE", "outFile", "tofile", "otname", "Outfilename", "tofilename", "otfile", "OutFile", "outfilename", "toFile", " outFile", " outname", "inFILE", "outdir", "infilename", "Outdir", " outFILE", "inname", "inFile", "Outfile", "otFILE", "indir", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "inf", "ain", "inside", "iter", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "write", "can", "ne", "os", "auto", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "shape", "library", "cache", "command", "variable", "note", "mem", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "shift", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": [" succeed", "growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "scope", "positive", " successes", "please", " succeeds", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "exist", "setup", "cess", "accept", "city", "safe", "danger", "first", "value", "unity", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "12236729", "id2": "2518655", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "label": 1, "substitutes": {"copy": ["read", " replicate", " combine", " duplicate", "transfer", " transfer", " dup", " cp", " restore", " cat", "cp", " copying", " Copy", " delete", " parallel", " download", " clone", " join", "paste", " seek", " upload", " operate", "Copy", " append", " paste", " recover", " merge", " move"], "inputFile": ["outputDir", "inile", "inputfile", "configPath", " inputPost", "argumentPath", " inputile", "configfile", "inputPost", "inPath", "argumentfile", "outputPath", " inputfile", "configPost", "inputPath", "configFile", "argumentFile", "argumentPost", " inputDir", "outputile", "inputDir", "inFile", "inDir", " inputPath", "inputile"], "outputFile": ["outPlace", "outputDir", "targetPath", "outFile", "outputPlace", " outputDir", "inputfile", "writePlace", "outPath", "outDir", "outFilename", "outputPath", "targetDir", "writeFile", "outputfile", "inputPath", "outfile", "targetfile", "outputFilename", " outputFilename", "inputDir", " outputPlace", "targetFile", "writeFilename", "writeDir"], "in": ["reader", "read", "bin", "din", "min", " din", "inc", "isin", "rin", "ind", "en", "inner", "ze", "inf", "inside", "iter", "is", "input", "al", "up", "In", "on", "old", "gin", "per", "init", "all", "info", "ini", "IN", "con", "it", "ir", "from", "ins", "inn", "cin", "ai", "i", "ic", "ri", "sin"], "out": ["io", "v", "dis", "can", "write", "OUT", "ne", "user", "os", "auto", "log", "en", "print", "at", "flush", "sys", "ot", "client", "cache", "check", "res", "end", "obj", "nt", "n", "on", "co", "o", "net", "con", "one", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "cos", "g", "writer", "ou", "aos", "by", "outer"], "c": ["t", "ct", "count", "cl", "v", "cd", "ac", "k", "uc", "u", "ce", "arc", "l", "cs", "bc", "mc", "cp", "cod", "r", "cc", "x", "cb", "gc", "cache", "cu", "rc", "chain", "ec", "n", "unc", "f", "d", "character", "conf", "con", "ch", "cm", "pc", "cap", "char", "z", "code", "nc", "cos", "C", "i", "cont", "cr", "current", "cf", "lc"]}}
{"id1": "5543349", "id2": "5989666", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"loadMFileViaWeb": ["loadMFileviaWe", "loadMFileByweb", "loadMFilesviaWeb", "loadMFilesviaWe", "loadMFileUsingweb", "loadMFileviaweb", "loadMFileByWeb", "loadMFileviaWeb", "loadMFileViaweb", "loadMFilesViaWe", "loadMFileUsingWeb", "loadMFileViaWe", "loadMFileUsingWe", "loadMFilesViaWeb", "loadMFilesviaweb", "loadMFilesViaweb", "loadMFileByWe"], "codeBase": ["filebase", "codeMark", "codeBased", "CodeRoot", "CodeBase", "fileRoot", "codeRoot", "uriMark", " codeRoot", " codebase", "Codebase", "CodeMark", "uriBase", "fileBased", "codebase", "CodeBased", "fileBase", "uribase", " codeMark", " codeBased", "uriBased"], "directoryAndFile": ["directoryandFile", "directoryandModel", " directoryOrType", " directoryOrfile", "directoryAndModel", " directoryAndDirectory", "DirectoryAndfile", "directoryButfile", "directoryOrPath", "DirectoryAndModel", "directoryOrModel", "directoryButDirectory", "directoryandType", "DirectoryandFile", "directoryAndPath", "directoryAndfile", " directoryAndType", "DirectoryAndFile", "directoryButFile", "directoryandDirectory", "directoryOrFile", "Directoryandfile", "directoryAndDirectory", "directoryandfile", "DirectoryandModel", "DirectoryAndPath", "directoryAndType", "directoryOrType", "directoryButType", "directoryOrDirectory", "DirectoryandPath", "directoryOrfile", " directoryOrDirectory", "directoryandPath", " directoryOrFile", " directoryAndfile"], "mFileName": ["mFileFile", "mFileBody", "mfileFile", "mFilenameNames", "mSourceFileSource", "MFilenameSource", " mfileName", "mfileType", "mSourceFileType", "mFileNames", "mTableName", "mFolderPath", " mfileType", "MFilenamePart", "mFilePart", "mFilenameType", "mFoldername", "mfileBody", "mSourceFileSize", "MFilenamePath", "mSourceFileFile", "MFileBody", "mfileSource", "MFilenamename", "mFilenameSource", "MFilePart", "mSourceFilePath", "mfileNames", "MFileNames", "MFilenameNames", "mFilenameSize", "MFilenameBody", "mFileSource", "MFileSource", " mFilePath", "mFilenamename", "mFilePath", "MFilePath", "mFileSize", "mFilenameBody", "MFileName", "mFilenameFile", "mfileSize", "MFilenameSize", "mFolderName", "MFilenameName", " mFileType", "mTablePart", "mFilenamePart", "mFilenamePath", "mFileType", "mSourceFileNames", "mFilename", "mTablePath", "mFolderPart", " mfilePath", "mfilePath", "mFilenameName", "mSourceFileName", "MFilename", "mTablename", "MFileSize", "mfileName", " mFileFile", "mSourceFileBody", " mfileFile"], "code": ["text", "t", "data", "func", "component", "hex", "program", "reason", "Code", "frame", "message", "output", "done", "node", " to", "coe", " coding", " content", "core", "l", "e", "cell", "body", "x", "cache", "time", "event", "zip", "create", "buffer", "copy", "scene", "html", "coded", "comment", "length", "expression", "string", "cod", "stroke", "script", "json", "value", "template", "query", "to", " Code", "source", "content", "c", "codes", " data", "ce", "ode", "test", "action", "result", "input", "command", "n", "hello", "module", "sequence", "form"], "function": [" command", "object", "closure", "lambda", "method", "instance", " func", "foundation", "connection", "user", " computation", "full", "file", "func", "python", "document", "component", "relation", "foreign", "expression", "result", "action", " functionality", "normal", "library", "functional", "family", "program", "job", "partial", "production", "command", "false", "feature", "f", " program", "service", "value", " Function", "module", "event", "FUN", "fun", " functions", "from", "role", "process", "handler", "Function", "resource", "callback", "fn", "class", "form", "and"], "url": ["dl", "li", "io", "location", "build", "rl", "re", "nl", "mount", "str", "base", "log", "file", "el", "loc", "l", "b", "gl", "web", "il", "r", "out", "ssl", "browser", "open", "job", "mail", "sl", "address", "bel", "ur", "p", "get", "http", "hl", "ll", "link", "rel", "URL", "char", "resource", "Url"], "in": ["reader", "bin", "din", " din", "sin", "stream", "inc", "isin", "rin", "ind", "file", "inner", "l", "inf", "body", "r", "out", "is", "input", "In", "n", "p", "gin", "f", "info", "IN", "it", "from", "ins", "null", "inn", "cin", "i", "ic", "source"], "inReader": ["innerRunner", "InRead", "innerReader", " inLine", "inRead", "InLine", "inWriter", " inWriter", "cinWriter", " inR", "InStream", "inLoader", "fromLoader", "fromReader", "fromWriter", " inLoader", "cinRunner", " inRunner", " inRead", "fromBuilder", "innerBuilder", "inStream", "innerR", "innReader", "inR", " inBuilder", "inRunner", "fromR", "cinLoader", "cinReader", " inStream", "innLine", "inLine", "fromRunner", "inBuilder", "innRead", "innStream", "InReader"], "line": ["text", "le", "zone", "lin", "lane", "inline", "point", "column", "comment", "file", "ode", "LINE", "liner", "print", "l", "ln", "e", "cell", "Line", "eline", "string", "stroke", "section", "email", "rule", "entity", "ine", "online", "lined", "frame", "element", "number", "row", "record", "link", "sample", "block", "sequence", "message", "char", "entry", "change", "stay", "port", "error", "page", "key", "header"], "end": ["close", "run", "data", "id", "stop", "begin", "length", "log", "ended", "next", "e", "End", "open", "export", "start", "END", "load", "info", "list", "block", "reset", "ed", "class"]}}
{"id1": "647224", "id2": "23531898", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"uploadFile": ["putFiles", "saveFiles", "uploadImage", " uploadfile", "putfile", " uploadImage", " uploadFiles", "uploadFiles", "putImage", "savefile", "saveFile", "putFile", "saveImage", "uploadfile"], "inputFile": ["imgOne", "infoFilename", "inputFILE", "inputfile", " inputLe", "inputField", "InputFiles", "Inputfile", "inputResource", "imgLe", "targetField", "fromField", "evalField", "imgFile", "outputLine", " inputfile", "inputLe", "outputPath", "imgLine", "updateOne", "infoFile", "updateFile", "thisLine", "targetFILE", "outputfile", "inputLine", "evalFile", "targetResource", "inputPath", "fromResource", "InputLine", "fromFile", "inputOne", "inFILE", "thisPath", "updateLe", "outputFiles", "fromFILE", "inLine", "infoFILE", " inputFiles", "thisfile", " inputFilename", " inputFILE", " inputLine", "InputFile", "inputFiles", "inFilename", " inputPath", "evalResource", "inFile", "inputFilename", "evalFILE", "infoLine", "updateLine", "thisFile", " inputOne"], "targetFile": ["sourceFiles", "outputDir", "targetPath", "detailString", "targetString", " targetFilename", "TargetFile", " targetString", "tofile", "toDir", " targetFILE", "outputDate", "TargetString", "sourceDir", "targetFilename", "outputFolder", "TargetPath", "sourceFile", "detailDir", "TargetFiles", "outputPath", "targetDir", "targetDate", "toFile", "toFolder", "targetFILE", "sourceDate", "outputfile", " targetPath", "sourcefile", " targetDir", "targetfile", "outputFilename", "targetFiles", "targetFolder", "detailFILE", "detailFile", "sourceFolder", "outputFiles", "sourcePath", "sourceFilename", " targetDate", "TargetDir", "TargetFILE"], "outputFile": ["sourceFiles", " outputGe", "outputDir", "inputLog", "removePlace", "displayFILE", "targetDirectory", "outFile", "outputPlace", " outputDir", "inputfile", "inputDo", "putFile", "noGe", "putPlace", "sourceDir", "displayPlace", " outputDirectory", "displayStore", "nullStyle", "noPlace", "targetFilename", "outDir", "sourceFile", "nofile", "targetDir", "outModel", " outputLog", "inputDirectory", "outFiles", "outputfile", "outputDo", "outputFILE", "displayFile", "sourcefile", "removeFile", "outfile", "putfile", "nullfile", "targetfile", "targetFiles", " outputStore", "removeStore", " outputStyle", "outputFilename", "targetLog", "outputLog", " outputModel", "outputFiles", " outputFILE", "removeFILE", "outDo", " outputFilename", "inputDir", "outStyle", "targetModel", " outputPlace", "inputFiles", "putGe", "nullFile", "outputStore", "inputModel", "nullModel", " outputfile", "outputDirectory", " outputDo", " outputFiles", "noFile", "outputStyle", "outputModel", "outputGe", "inputFilename"], "in": ["io", "read", "bin", "din", "inc", "isin", "rin", "ind", "el", "en", "inner", "l", "ze", "inf", "ain", "inside", "iter", "ro", "mc", "im", "is", "input", "al", "In", "on", "per", "init", "info", "ini", "IN", "like", "con", "it", "ar", "ins", "inn", "cin", "act", "ai", "i", "mm", "ic", "ri", "source", "by"], "out": ["t", "println", "io", "v", "dis", "can", "write", "by", "os", "auto", "log", "print", "inner", "b", "ln", "at", "console", "sys", "ot", "client", "put", "cache", "res", "err", "end", "obj", "screen", "name", "nt", "up", "n", "on", "co", "all", "list", "conf", "IN", "net", "o", "con", "cn", "outs", "it", "vol", "Out", "output", "sum", "report", "null", "we", "ex", "to", "cos", "g", "writer", "s", "ou", "aos", "OUT", "outer", "and"], "line": ["detail", "lin", "lane", "inline", "range", "point", "nl", "column", "comment", "log", "LINE", "phrase", "l", "ln", "cell", "eline", "Line", "lo", "stroke", "entity", "rule", "chain", "ine", "command", "ide", "frame", "row", "query", "edge", "record", "sample", "block", "field", "sequence", "lock", "message", "link", "entry", "label", "node", "code", "word", "page"], "bytes": ["gs", "terms", "ies", "oms", "uses", "classes", "es", "bs", "gments", "parts", "ales", "xes", "frames", "gets", "ones", "books", "errors", "bits", "lements", "ges", "ites", "pages", "ows", "rows", "bes", "ls", "comments", "odes", "bps", "Bytes", "otes", "cells", "les", "ices", "amples", "ends", "outs", "lines", "seconds", "blocks", "nets", "reads", "files", "comes", "values", "steps", "bles", "times", "vals", "ips", "tes", "units", "sofar"]}}
{"id1": "9081749", "id2": "15202804", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"encrypt": ["encrypted", "Encrypt", "Encryption", "encryption", "encress", "cress", "compress", "crypted", "Encrypted", "Encress", "comprypt", "crypt", "cryption", "comprypted", "compryption"], "password": ["confirmed", "text", "request", "padding", "secret", "wd", "PASS", "account", "default", "user", "comment", "total", "attribute", "username", "phrase", "prefix", "expression", "secure", "picture", "sword", "string", "pattern", "path", "input", "email", "database", "address", "chain", "name", "command", "wordpress", "shadow", "pass", "Password", "p", "description", "token", "hello", "value", "past", "message", "reset", "word", "source", "key", "push"], "encryptType": ["escryptionype", "escryptionTy", "encreatype", "encjectClass", "encveytype", "encveyType", "encryptionStyle", "encryptionTy", "escryptStyle", "encribeType", "encribeype", "encryptionClass", "ethryptType", "encryptStyle", "encryptionype", "escryptype", "ethryptTYPE", "ethjectType", "encryptiontype", "encveyTYPE", "escryptionType", "ethrypttype", "ethryptClass", "ethjectClass", "encryptype", "escryptionStyle", "escryptTy", "encjectTYPE", "encreatTy", "encryptionTYPE", "encribeTy", "encryptionType", "encryptTYPE", "encjecttype", "encrypttype", "ethjectTYPE", "encjectType", "escryptType", "encreatType", "encveyClass", "ethjecttype", "encreatStyle", "encryptClass", "encryptTy", "encribeStyle"], "md": [" Md", "bd", "MD", "ct", "dh", "pdf", "det", "cd", "rd", "dr", "sd", "down", "sm", "mand", "mt", "ind", "mod", "add", "dd", "hd", "dir", "mc", "del", "cmd", "ds", "df", "mk", "mb", "dm", "nd", "de", "obj", "pd", "nt", "metadata", " MD", "grad", "me", "d", "der", "di", "ld", "man", "mn", "od", "m", "red", "ad", "mm", "ms"], "hash": ["where", "oh", "esh", "replace", "score", "host", "stack", "html", "hz", "length", "total", "ash", "test", "Hash", "has", "print", "hex", "sort", "stock", "dig", "sha", "mask", "cache", "check", "mac", "shift", "address", "map", "rh", "handle", "array", "her", "height", "all", "search", "match", "number", "here", "query", "hello", "sample", "block", "how", "sum", "ashes", "char", "style", "show", "sh", "color", "h", "filter", "box", "window", "square"], "hexString": [" Hexstring", "exService", "xfArray", "hashString", " HexResult", " hexstring", "pexArray", "hexResult", "exResult", "pexService", "pexList", "jsonStr", "exList", "exStr", "hexService", " hexResult", "octString", "hexArray", "octArray", "xfStatement", " hexList", "xfstring", "exString", "hexStatement", "hexList", " HexStr", " hexArray", "jsonString", "hashStr", "exStatement", "hexBuffer", "hashArray", "hexstring", "octstring", "hashBuffer", "exstring", "xfString", "exBuffer", "hexStr", "pexString", " hexService", "jsonArray", " hexStr", " HexString", "exArray", "octStatement", "jsonBuffer"], "i": ["ip", "c", "li", "y", "io", "gravity", "v", "bi", "in", "ii", "phi", "multi", "point", "I", "id", "u", "xi", "ui", "this", "mi", "iu", "ski", "oi", "gu", "e", "gi", "uri", "im", "cli", "ami", "x", "is", "ki", "ti", "ie", "index", "major", "ci", "pi", "ji", "a", "iq", "n", "me", "exp", "qi", "si", "init", "ix", "di", "info", "list", "ei", "json", "it", "sim", "j", "ex", "my", "\u0438", "m", "ai", "ic", "set"]}}
{"id1": "810342", "id2": "8011262", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionUpdate", "DoDateFix", "DoDatecheck", "doDateFix", "doVersionsCheck", "doDatecheck", "doDateUpdate", "DoDateCheck", "DoVersionCheck", "DoDateUpdate", "DoVersionUpdate", "doVersioncheck", "doDateCheck", "doLicenseFix", "doVersionscheck", "doLicenseUpdate", "DoVersionFix", "doVersionsFix", "doLicensecheck", "doLicenseCheck", "doVersionsUpdate", "DoVersioncheck", "doVersionFix"], "view": ["VIEW", "widget", "cv", "v", "buffer", "manager", "View", "host", "views", "tree", "help", "html", "server", "controller", "this", "eye", "file", "blade", "document", "image", "print", "review", "self", "component", "web", "cell", "console", "q", "update", "out", "client", "browser", "iew", "input", "index", "check", "open", "util", "engine", "layout", "get", "wrapper", "http", "row", "query", "hl", "tv", "block", "context", "display", "report", "subject", "show", "doc", "see", "call", "table", "model", "window", "page", "form"], "url": ["lb", "dl", "location", "v", "org", "ul", "rl", "host", "nl", "mount", "str", "html", "id", "log", "file", "loc", "lr", "l", "b", "language", "gl", "web", "uri", "string", "oul", "r", "client", "ssl", "browser", "path", "ls", "sl", "address", "bel", "ur", "date", "f", "pl", "github", "http", "json", "hl", "ll", "link", "rel", "URL", "char", "null", "socket", "Url"], "in": ["reader", "mat", "din", " din", "stream", "asin", "inc", "isin", "rin", "file", "l", "b", "inner", "ln", "inf", "ain", "body", "vin", "source", "out", "is", "input", " IN", "In", "n", "gin", "f", "init", "info", "IN", "mn", "ins", "inn", "cin", "i", "sin", "kin"], "bin": ["bg", "binary", "reader", "buffer", "din", "bi", " din", "conn", "bed", "lib", "pipe", "by", "buff", "sam", "rin", "file", "inner", "b", "ln", "stock", "spin", "loader", "out", "abin", "cache", "bl", "rb", "bur", "ran", "mem", "thin", "gin", "len", " bins", "win", "nb", "con", "local", "bn", "ebin", "inn", "cin", "cos", " Bin", "sin", "obin", "mon"], "line": ["level", "text", "le", "lin", "lane", "inline", "state", "range", "se", "point", "part", "base", "col", "column", "comment", " Line", "el", "file", "log", "liner", "LINE", "print", "l", "ln", "trace", "cell", "body", "iter", "Line", "string", "eline", "lo", "cmd", "section", "path", "ice", "ls", "no", "job", "err", "chain", "ine", "ide", "load", "frame", "channel", "row", "one", "record", "link", "sample", "block", "lines", "cat", "field", "char", "entry", "style", "store", "code", "port", "word", "page"], "version": ["vers", "scale", "river", "license", "v", "usage", "type", "serial", "status", "translation", "ver", "VER", "volume", "release", "vision", "software", "test", "python", "image", "language", "string", "update", "client", "versions", "virtual", "browser", "iso", "hash", "video", "index", "major", "title", "spec", "name", "format", "command", "Version", "position", "project", "feature", "date", "description", "match", "number", "value", "info", "tag", "sequence", "latest", "VERSION", "resource", "ion", "key", "form"], "build": ["th", "bor", "ship", "uild", "where", "binary", "unit", "boost", "built", "ver", "lib", "dev", "release", "full", "log", "test", "print", "add", "b", "update", "install", "hash", "work", "hold", "util", "develop", "ble", "old", "Build", "builder", "arch", "project", "date", "use", "load", "building", "match", "bug", "dist", "be", "tag", "link", "ward", "latest", "struct", "round", "style", "last", "fail", "make", "db", "other"]}}
{"id1": "17947247", "id2": "2199604", "code1": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"postURL": ["getUR", "POSTPage", "getPage", " postPage", "getURI", "POSTURL", " postURI", "postPage", "postUR", " postUR", "POSTURI", "getURL", "postURI", "POSTUR"], "urlLocation": ["URLHistory", "implDescription", "UrlLocated", "strLocated", "UrlLoc", "llLocation", "strLoc", "lLoc", "implLoc", " urlDescription", " urlLocal", "llLocal", "pathName", "llLoc", "urlLoc", "pathLocated", "urlName", "Urllocation", "urlHistory", "lLocation", "UrlLocation", "llDescription", "logLocation", "UrlName", "logLoc", "strLocation", "strlocation", "urlLocal", "urlDescription", "loglocation", "implLocation", "URLDescription", "implHistory", "URLName", "urlLocated", "lLocal", "URLLocation", "URLLocated", "URLlocation", " urlLoc", "lDescription", " urlLocated", " urlHistory", "logLocated", "URLLoc", "urllocation", " urllocation", "pathLocation"], "headers": ["qs", "history", "codes", "modules", "head", "terms", "strings", "pres", "tags", "articles", "ors", "workers", "images", "ers", "frames", "holders", "ackers", "relations", "errors", "bits", "items", "ilers", "objects", "ctors", "heads", "comments", "dates", "archives", "ids", "months", "drivers", " collectors", "checks", "masters", "ppers", "actions", "names", "http", "properties", "members", " trailers", "users", "resources", "blocks", "writers", "types", "authors", "files", "ancers", "orders", "ters", "boxes", "events", "keys", "weights", "times", "caps"], "content": ["version", " Content", "text", "request", "any", "padding", "default", "data", "str", "html", "core", "connection", "comment", "raw", "ce", "document", "now", "body", "string", "hash", "Content", "gc", "time", "title", "address", "name", "accept", "command", "script", "get", "layout", "present", "description", "property", "json", "template", "response", "sequence", "context", "output", "message", "settings", "ontent", "empty", "code", "xml", "page", "cont", "current", "source"], "postVariables": ["postsVariams", "putVams", " postVariableates", "putVariants", "putVants", "postVarables", "putVables", "postVariableables", "postParams", "postVariableams", "postsVables", "PostVariables", "postsVabilities", "PostVariabilities", " postVariates", "PostVams", " postVariams", "postVams", "postvariabilities", "postParates", "postVants", "postvariants", "postVariams", "postsVants", "postVariableates", "PostVariams", "postVariates", "putVariams", "postVarams", "postsVariabilities", "postVables", "postvariables", "postVarates", "postVariableabilities", "postVariants", "postsVams", "postVariabilities", "PostVables", " postVariableams", "postParables", "postVariableants", "PostVants", "PostVariants", "postvariams", "PostVabilities", "putVariables", " postVariableables", "postsVariants", "postVabilities", "postsVariables"], "c": ["t", "ct", "v", " cr", "ctx", " cc", "dc", "l", "b", " e", "bc", "e", "tc", " C", "mc", "cc", "r", "cb", "gc", "cache", "chain", "ec", "n", "p", "f", "o", "w", "context", "fc", "m", "config", "code", "g", "h", "C", "nc", " ec"], "postContent": ["putText", "postMessage", "preCopy", "PostData", "POSTContents", "preData", "printValue", "PostMessage", "postcontent", "POSTCopy", "uploadContents", "postContents", "prettyData", "putContents", "Postcontent", "postCopy", "postData", "PostContent", "postValue", "preContents", "preValue", " postValue", "POSTContent", " postText", "preContent", "putValue", "prettyMessage", "putData", "printcontent", "uploadContent", "postText", "uploadcontent", "putContent", "ostContent", " postData", " postCopy", "uploadData", "POSTValue", "putCopy", " postMessage", "ostData", "printContent", "PostCopy", "PostText", "ostContents", "printContents", " postContents", "prettyContents", "PostContents", "putcontent", " postcontent", "prettyContent"], "elements": ["engonents", " eumbers", "erils", "eslements", "selements", "eonents", "edtons", "leumbers", "engils", "eppers", "seles", "leles", "etons", "entityonents", "eils", "peumbers", "eronents", "entityumbers", "evers", "sefaces", "pelem", "estons", "erlements", "Elements", "entitylements", "Efaces", "elem", "Elem", "erumbers", "edppers", "Evers", "esppers", "entityils", "severs", " eppers", "lelements", "elelem", "eles", "selem", "lelem", "efaces", "pelements", "engumbers", " etons", "esumbers", "seumbers", "englements", "peles", "eumbers", "elevers", "elefaces", "edlements", "elelements", "edumbers"], "key": ["y", "k", "column", "Key", "primary", "step", "var", "feature", "token", "pair", "search", "option", "char", "ek", "my", "parent", "KEY", "kid", "def", "tip", "member", "ver", "part", "col", "core", "attribute", "prefix", "index", "param", "cookie", "important", "event", "link", "entry", "label", "keys", "by", "et", "where", "count", "type", "id", "phrase", "string", "ie", "hash", "ice", "item", "no", "check", "mac", "ox", "p", "pkg", "property", "info", "query", "field", "owner", "set", "base", "prop", "ind", "test", "cond", "title", "chain", "name", "variable", "typ", "description", "tag", "ke", "tab", "code"], "val": ["text", "unit", "v", "ver", "dev", "cal", "str", "data", "col", "el", "az", "test", "VAL", "ind", "rol", "pt", "serv", "Value", "item", "res", "ival", "elt", "eval", "var", "pol", "buf", "pet", "pl", "seq", "element", "von", "vet", "aval", "crit", "Val", "vol", "valid", "tx", "values", "ret", "sel", "label", "vals", "alt", "def"], "firstElement": ["FirstToken", "Firstelement", "nextKey", "secondEle", "currentKey", "firstelement", "lastElement", "lastEle", "firstEntry", "currentelement", "FirstEle", "nextToken", "firstEle", "currentElement", "secondEntry", "firstKey", " firstKey", "currentEle", "lastKey", " firstEntry", "firstToken", "lastEntry", " firstEle", " firstToken", "secondKey", " firstelement", "nextelement", "nextElement", "FirstElement", "FirstKey", "secondElement"], "url": ["t", "dl", "ocl", "ml", "location", "org", "blog", "ul", "lt", "rl", "acl", "nl", "host", "connection", "str", "u", "atl", "el", "log", "loc", "l", "b", "web", "gl", "https", "il", "cp", "r", "ssl", "cert", "browser", "ls", "mail", "sl", "address", "name", "bel", "ur", "get", "pkg", "github", "http", "con", "ll", "hl", "link", "rel", "URL", "m", "g", "resource", "Url"], "lines": [" results", "buffer", " text", " raw", " br", " request", " buff", " cc", " ss", " values", " cp", " state", " req", " res", " temp", " params", " strings", " buffers", " rows", " msg", " sp", " resp", " context", " input", " code", " str", " sql", " rc"], "conn": ["ct", "org", "ann", "close", "enc", "ctx", "connection", "po", "Conn", "ca", "js", "jp", "comm", "bc", "pas", "aux", "cp", "cc", "client", "cmd", "cert", "nec", "cb", "res", "open", "connected", "err", "obj", "nt", "conv", "iw", "n", "resp", "http", "conf", "cur", "con", "Connection", "cn", "ch", "canon", "socket", "addr", "config", "auth", "pg", "nc", "ns", "connect", "txt"], "i": ["ori", "li", "y", "v", "bi", "ii", "multi", "xi", "id", "u", "I", "ui", "ind", "mi", "iu", "oi", "ski", "inner", "gi", "im", "hi", "cli", "ami", "x", "is", "ti", "ki", "ie", "index", "ci", "pi", "ij", "ji", "iq", "me", "qi", "si", "ix", "di", "info", "ini", "ei", "ims", "it", "yi", "sim", "j", "ex", "\u0438", "m", "ai", "mu", "us", "ic", "ri"], "header": ["version", "history", "text", "head", "request", "buffer", "detail", "padding", "dr", "heading", "Header", "status", "host", "part", "html", "protection", "column", "comment", "server", "attribute", "layer", "component", "prefix", "body", "string", "client", "hidden", "section", "hash", "item", "magic", "policy", "title", "address", "format", "er", "variable", "metadata", "handle", "wrapper", "token", "http", "init", "frame", "info", "first", "property", "cookie", "query", "tag", "event", "element", "response", "block", "field", "context", "border", "subject", "entry", "argument", "initial", "holder", "handler", "code", "filter", "h", "port", "table"], "value": ["text", "VALUE", "widget", "unit", "v", "buffer", "default", "ver", "des", "comment", "total", "attribute", "csv", "test", "python", "add", "vp", "expression", "result", "language", "cell", "browser", "Value", "ow", "ue", "cas", "title", "term", "name", "address", "description", "pair", "json", "number", "element", "hello", "option", "event", "local", "sample", "block", "field", "message", "valid", "values", "null", "true", "label", "function"], "contentLengthFound": [" contentLengthValid", "timeLengthValid", " contentLengthRequired", "contentLengthRequired", "contentContentPresent", "timelengthRequired", " contentLengthPresent", "contentTypePresent", "contentLenFound", "contentContentRequired", " contentLenfound", "contentSizeValid", "contentTypeChanged", "contentLenChanged", "timelengthValid", "timelengthFound", "contentlengthfound", " contentLenValid", "timeLengthPresent", "contentLengthValid", " contentLengthfound", "contentTypeFound", "contentContentFound", "timelengthPresent", "timeLengthFound", "contentContentValid", " contentLengthChanged", "contentLenPresent", "contentLenfound", "contentlengthValid", " contentLenFound", " contentLenPresent", "contentTypefound", "contentSizeRequired", " contentTypeRequired", "contentSizeChanged", "contentLengthChanged", "contentLengthfound", "contentlengthRequired", "contentlengthFound", " contentTypeValid", "contentlengthPresent", "contentLenValid", "contentLenRequired", "contentTypeRequired", "contentLengthPresent", "timeLengthRequired", "contentTypeValid", "contentSizeFound", " contentTypeFound", " contentTypeChanged"]}}
{"id1": "3994258", "id2": "15500892", "code1": "    public boolean connectServer(String server, String user, String password) {\n        boolean result = true;\n        try {\n            if (user.equals(\"\")) {\n                user = \"anonymous\";\n                password = \"anonymous\";\n            }\n            this.server = server;\n            this.user = user;\n            this.password = password;\n            ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(encode);\n            ftpClient.connect(server);\n            ftpClient.setSoTimeout(1000 * 30);\n            ftpClient.setDefaultTimeout(1000 * 30);\n            ftpClient.setConnectTimeout(1000 * 30);\n            ftpClient.enterLocalPassiveMode();\n            ftpClient.login(user, password);\n            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                ftpClient.disconnect();\n                return false;\n            }\n            queFilePath = \"data\\\\\" + this.server + \".que\";\n            bufFilePath = \"data\\\\\" + this.server + \".buf\";\n            startGetList();\n        } catch (java.net.SocketTimeoutException e1) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e1, \"\u8fde\u63a5\u8d85\u65f6\");\n        } catch (Exception e) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e, \"\u672a\u77e5\u5f02\u5e38\");\n        } finally {\n            if (ftpClient.isConnected()) {\n                try {\n                    ftpClient.disconnect();\n                } catch (IOException ioe) {\n                    cn.imgdpu.util.CatException.getMethod().catException(ioe, \"IO\u5f02\u5e38\");\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"connectServer": ["connectDatabase", "openDatabase", "selectServer", "connectionSite", "openSer", "selectSer", "connectSer", "connectionSer", "selectSite", "connectionDatabase", "connectSite", "connectionServer", "selectDatabase", "openServer", "openSite"], "server": ["version", "ip", "peer", "scale", "manager", "instance", "ver", "host", "connection", "base", "remote", "column", "total", "erver", "controller", "test", "computer", "free", "serv", "Server", "uri", "center", "localhost", "console", "source", "client", "browser", "mobile", "device", "engine", "database", "email", "address", "enter", "name", "er", "url", "project", "ve", "folder", "description", "http", "cookie", "search", "service", "directory", "hello", "slave", "row", "query", "template", "site", "value", "domain", "sample", "entry", "socket", "store", "master", "table", "port", "node", "code", "model", "seed", "ser", "ter", "page", "parent", "system"], "user": ["usage", "any", "manager", "account", "type", "or", "ver", "uid", "host", "human", "data", "usr", "order", "u", "used", "attribute", "file", "author", "usa", "username", "post", "form", "word", "string", "creator", "client", "profile", "path", "admin", "ername", "util", "device", "rule", "database", "login", "name", "term", "note", "command", "er", "me", "root", "student", "issue", "per", "use", "token", "User", "info", "query", "basic", "field", "person", "you", "char", "from", "USER", "nick", "consumer", "owner", "port", "auth", "store", "error", "key", "by"], "password": ["pty", "padding", "secret", "wd", "PASS", "worker", "account", "data", "comment", "power", "attribute", "pool", "username", "phrase", "prefix", "language", "picture", "sword", "session", "parser", "client", "profile", "pattern", "crypt", "security", "hash", "sudo", "mask", "application", "device", "database", "policy", "chain", "remember", "login", "command", "wordpress", "shadow", "pass", "p", "words", "paste", "token", "description", "hello", "directory", "number", "wp", "code", "port", "auth", "word", "Password"], "ftpClient": ["ftcCan", "aftpConnection", "ftpCan", "fftControl", "aftpClient", "aftPBuilder", "ftpclient", "aftcHandler", "aftPConnection", "factpDo", "ftcControl", "aftPDo", "fttpClient", " ftPClient", "ftppControl", "ftcpMethod", "ftcclient", " ftpConnection", "ftpStore", "aftcpControl", "ftcpClient", "ftlpClient", "ftcNode", "factpClient", "ctcpclient", "aftpBuilder", "ftpHandler", "ftwpclient", "ftpAdmin", "fttStore", "ftcBuilder", "fttHandler", "ftcpHandler", " ftpBody", "ftpaMethod", "fftCan", "ftphpContent", "fttpclient", "fftpConnection", "fttpBuilder", "factpatclient", "ftphpclient", "ftwpClient", "fftpclient", "ctcpContent", "ftPclient", "fttclient", "ftppclient", "ftpiContent", "ftppCan", "ftpMethod", " ftPclient", "ftpatClient", "ffpControl", " ftpStore", "ftcStore", "aftPClient", "ftcpclient", "aftcpMethod", "ftpatDo", "factpNode", "aftpMethod", " ftPConnection", "ftphpClient", "fttCan", "fttControl", "ftlpContent", "ftcpBody", "ftpBody", "ftpContent", "factpclient", "ftPClient", "fttMethod", "aftpclient", "aftpDo", "ftfControl", "ftpatclient", "ftfClient", "factpatDo", "ftPBuilder", "ctpContent", "ftcContent", "ctpclient", "ftlpBody", "ftpConnection", "ctpClient", "aftpControl", "ftpiClient", "fttAdmin", "fftpClient", "fttClient", "ftppClient", "ftpatNode", "ftpiBody", " ftpContent", "ftwpNode", "ffpClient", "ftfConnection", "ftpatAdmin", "ffpCan", "fftclient", "ftcpStore", " ftcpBody", "ftpBuilder", "ftcDo", "ftPStore", "ffpConnection", "aftcpConnection", "factpatClient", "aftcclient", "fftAdmin", " fttclient", "aftcpclient", "ftcConnection", "ftpControl", "ftpNode", "ffpclient", " ftcpContent", "ftPConnection", "fttpControl", "ffpAdmin", "ftpaClient", " ftPStore", "fttConnection", "fftClient", " ftcpClient", "ftcClient", "ftcpConnection", " fttClient", " fttStore", "ftcpContent", "ctcpClient", "fttpConnection", "aftpHandler", "ftfclient", " fttConnection", "ftcAdmin", " ftpclient", "ftlpDo", "aftcControl", "ftpatControl", "aftcClient", "ftcpControl", "ftcHandler", "ftwpDo", "ftpDo", "ftpaclient", "factpatNode", "ftPDo", "fttpStore", "aftcpClient", "fttpDo"], "queFilePath": [" queTableName", "queFileDir", " queTableId", "queDirPath", "queLinepath", "queFPath", "queTablePath", " queTableDir", "queTimePath", "bufFilepath", "queFilePart", "queFileId", " queFileId", "queFPos", "queItemPath", "queStoreStep", "queLinePath", "queFileFormat", "quFilePath", "queTableName", "queLinePos", "queItemInfo", "queStorePart", "queFileName", "quItemInfo", "queStoreInfo", "queDirDir", "queDirName", "quefilePath", "queFileInfo", "queTableDir", "queTimeStep", "quItemPart", "queItemStep", "quefileName", "queLineFormat", "quFileStep", "queFpath", "queTimePart", "queStorePath", "queDirId", "quItemPath", "queFilePos", "quFilePart", "bufFilePos", "queFilepath", "quFileInfo", "queTimeInfo", "queItemPart", "queFileStep", "queTableId", "queFFormat", "bufFileFormat", " queFileName", "quefileDir", " queFileDir", "quefileId", "quItemStep", " queTablePath"], "bufFilePath": ["bufTableData", "buffileLocation", "vecFilePath", "vecQueueName", "bufFilenameDef", "bufLinepath", " bufFileLocation", "bufByteName", "bufQueueStr", "bufferfileName", "buffileData", "vecFileDef", "bufTablePath", "buffileName", "bufFilepath", "bufferFilePath", "bufFileStr", " bufFileData", "bufQueueDef", "bufLineName", "bufRelName", "bufferFileName", "bufFileName", "bufTableLocation", "bufRelpath", " bufByteLocation", "buffileTime", "bufferfilepath", "vecFileName", " bufFileName", "buffileDef", "bufBytePath", "buffilepath", "bufQueuePath", "vecQueuePath", "bufferFileTime", "bufQueueName", "bufRelTime", "bufferFilepath", "bufFileTime", "bufFileDef", " bufByteName", "bufTableName", "vecQueueStr", "bufRelPath", "vecQueueDef", "bufByteData", "bufFilenameStr", "bufFileLocation", " bufByteData", "bufferfilePath", "vecFileStr", "bufByteLocation", "bufFileData", "bufLineTime", " bufBytePath", "bufFilenamePath", "bufFilenameName", "buffileStr", "bufLinePath", "buffilePath", "bufferfileTime"], "errMsg": ["erMess", "erLog", "erMsg", "errStr", "erMessage", "sprStr", "cfgLog", "errMess", "errLog", "sprSm", "errSm", " errLog", "failStr", " errStr", " errSm", "sprMess", "failSm", "cfgMessage", " errMess", "failMess", "cfgMsg", "sprMsg", "errMessage", " errMessage", "failMsg", "cfgMess"], "errCode": ["errCon", "urgNo", " errCount", "eorDef", "urgCode", "eorSc", "errNo", "errSc", "sprSc", "sprDef", "sprCode", " errCon", "urgCheck", "errCount", "sprCount", "rrNo", "eorCount", " errCheck", "errCheck", "rrCon", " errDef", "rrCheck", " errSc", " errNo", "rrCode", "errDef", "eorCode", "urgCon"], "result": ["results", "details", "status", "run", "data", "fac", "answer", "relation", "draw", "continue", "su", "flag", " res", "out", "r", "cert", "profile", "mask", "were", "duration", "res", "cache", "success", "chain", "global", "goal", "false", "journal", "feature", "date", "description", "perm", "match", "value", "event", "sequence", "ret", "valid", "process", "report", " Result", "show", "Result", "msg", "know", "table", "make"]}}
{"id1": "9526031", "id2": "6756635", "code1": "    public boolean register(Object o) {\n        String passwordAsText;\n        if (o == null) throw new IllegalArgumentException(\"object cannot be null\");\n        if (!(o instanceof User)) {\n            throw new IllegalArgumentException(\"passed argument is not an instance of the User class\");\n        }\n        User newUser = (User) o;\n        passwordAsText = newUser.getPassword();\n        newUser.setPassword(passwordEncoder.encodePassword(passwordAsText, null));\n        newUser.setRegDate(new Date());\n        logger.debug(\"Setting default Authority {} to new user!\", Authority.DEFAULT_NAME);\n        newUser.getAuthorities().add(super.find(Authority.class, 1));\n        logger.debug(\"Creating hash from email address! using Base64\");\n        newUser.setHash(new String(Base64.encodeBase64(newUser.getEmail().getBytes())));\n        logger.debug(\"Creating phpBB forum User, by calling URL: {}\", forumUrl);\n        try {\n            StringBuilder urlString = new StringBuilder(forumUrl);\n            urlString.append(\"phpBB.php?action=register\").append(\"&login=\").append(newUser.getLogin()).append(\"&password=\").append(passwordAsText).append(\"&email=\").append(newUser.getEmail());\n            sqlInjectionPreventer(urlString.toString());\n            logger.debug(\"Connecting to URL: {}\", urlString.toString());\n            URL url = new URL(urlString.toString());\n            URLConnection urlCon = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlCon.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) newUser.setForumID(Integer.valueOf(inputLine));\n            in.close();\n        } catch (IOException io) {\n            logger.error(\"Connecting failed! Msg: {}\", io.getMessage());\n            throw new RuntimeException(\"Couldn't conntect to phpBB\");\n        } catch (NumberFormatException e) {\n            logger.error(\"phpBB user generation failed! Msg: {}\", e.getMessage());\n            throw new RuntimeException(\"phpBB user generation failed!\");\n        }\n        entityManager.persist(newUser);\n        try {\n            sendConfirmationEmail(newUser);\n            return true;\n        } catch (MailException ex) {\n            return false;\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"register": ["reply", "save", "submit", "create", "registered", "write", "reg", "activate", "log", "insert", "print", "add", "post", "update", "Registration", "install", "login", "Register", "send", " registration", "init", "load", "Login", "record", "protect", "link", "auth"], "o": ["object", "t", "io", "y", "ok", "v", "O", "obo", "or", "oc", "po", "os", "u", "user", "auto", "go", "uo", "om", "oo", "so", "e", "oa", "onet", "ro", "lo", "ot", "out", "an", "mo", "ow", "ob", "fo", "obj", "a", "op", "n", "er", "vo", "ao", "co", "ooo", "bo", "oid", "ilo", "m", "h", "i", "ou", "goo", "oin"], "passwordAsText": [" passwordAstext", "passwordastext", "passwordasTEXT", " passwordInTEXT", "passwordInText", "passASTEXT", "passwordAsTEXT", "secretAsLeft", "passAsPath", "passwordFromtext", "passwordToText", "passwordToTEXT", "passwordAndText", "passwordTotext", "passwordAndTEXT", "passASText", "passwordInTEXT", "passwordASPrint", "passwordAsString", " passwordInString", "passwordAstext", "passwordasText", "passwordInPrint", "passwordASText", "passwordInLeft", " passwordIntext", "passwordAndString", "passwordInString", "secretASTEXT", "passASPath", "passAsTEXT", "passwordFromString", " passwordAsTEXT", "passwordAsPrint", "passwordasString", "passAsText", "secretAsPrint", "secretAsText", "passwordIntext", "passwordASLeft", "passwordASTEXT", "secretASLeft", "passwordASPath", "passwordASString", "passwordAsLeft", "passAstext", " passwordAsString", "passAsString", "passwordAndtext", "passwordAsPath", "secretASPrint", "passwordAStext", "passwordFromTEXT", "secretASText", "passASString", "passwordFromPath", "passwordToPath", "passwordFromText", " passwordInText", "passAStext", "secretAsTEXT"], "newUser": ["createAccount", "uniqueuser", " newPer", "seeLong", "nextPost", "newsDevice", "oldPerson", "newsUser", "newsuser", "normalSystem", "normalPer", "nextMember", "normalTime", " newAccount", "nextPerson", "NewUsers", "fromCustomer", "nextCustomer", "newLong", "newTime", "createPerson", "newMember", " newSystem", " newTrans", "uniqueTrans", " newOwner", "normaluser", "newSystem", "normalAccount", "nextSystem", "normalTrans", "addSystem", "createuser", "oldUser", "adduser", "Newuser", "addUser", "nextUser", " newTime", "newPer", "newPerson", "newsSystem", " newUsers", "newuser", "ewOwner", "ewUser", "ewLong", "createUser", "newPost", "newUsers", " newCustomer", "nextForm", " newDevice", "NewPerson", "addDevice", "newTrans", "newOwner", "uniqueUser", "seeUser", "fromUser", "uniqueTime", "seePer", "nextPer", " newForm", " newLong", " newPerson", "newDevice", "newCustomer", " newPost", "seeOwner", "olduser", "normalUser", "ewPer", "oldPost", " newMember", "oldMember", "newAccount", "newForm", " newuser", "NewUser", "fromForm", "newsUsers", "fromPerson"], "urlString": [" urlSource", " urlS", "urlBuilder", "strString", "uriServer", " urlBuffer", "linkstring", " urlBuilder", "uriSource", "URLString", "urlS", " urlServer", "uriParser", "linkBuilder", "Urlstring", " urlstring", "UrlStr", "urlSan", " urlChain", "uriStr", "UrlParser", "URLBuilder", "URLstring", "urlService", "urlParser", "feedBuffer", "linkString", "UrlServer", "URLService", "UrlChain", "uristring", "urlChain", "strStr", "feedSource", "uriBuffer", "urlStr", "UrlString", "feedSan", "strstring", "urlSource", "urlstring", "urlServer", "UrlS", "feedString", " urlSan", "uriString", " urlService", "uriS", "urlBuffer", "linkService", "uriSan", "uriChain", "strParser", " urlStr"], "url": ["dl", "ml", "cl", "build", "ul", "conn", "rl", "re", "nl", "connection", "str", "base", "l", "web", "gl", "uri", "il", "console", "r", "client", "ssl", "browser", "ls", "open", "address", "bel", "ur", "get", "http", "con", "ll", "hl", "link", "ret", "URL", "socket", "resource", "xml", "Url"], "urlCon": ["UrlConnect", " urlConn", "UrlCon", "httpConnect", "httpCon", "urlConnect", "UrlConn", "Urlcon", "httpConn", "urlConn", " urlcon", "URLConn", "URLcon", "URLConnect", " urlCtrl", "UrlCtrl", "httpcon", "URLCon", "urlcon", "urlCtrl", "URLCtrl"], "in": ["c", "t", "io", "reader", "bin", "din", " din", "inc", "rin", "log", "file", "raw", "inner", "l", "serv", "inf", "ain", "body", "mc", "r", "out", "is", "line", "input", "al", "login", "er", "In", "n", "on", "gin", "f", "ma", "all", "conf", "IN", "mn", "con", "it", "cm", "from", "sum", "ins", "inn", "cin", "again", "ic", "form"], "inputLine": ["fromBlock", "InputBlock", "readStream", "textLine", " inputEntry", "InputRow", "fromLine", "textEntry", "helloEntry", "inputEntry", "InputText", "readText", " inputStream", "inputStream", " inputText", "currentBlock", "helloText", "helloLine", "currentLine", "InputLine", "readLine", "inputBlock", "fromRow", "helloRow", "inputText", " inputBlock", "readBlock", "currentText", "textText", "fromText", " inputRow", "currentStream", "inputRow", "textRow"]}}
{"id1": "8973505", "id2": "11968328", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["readfileName", "writeFileInfo", "writeContentName", "writePageType", "readfiletype", "readFiletype", "writefileInfo", "writeFileName", "writeContentInfo", "readFileType", "writefiletype", "readfileType", "readFileName", "writefileType", "writeContentType", "writefileName", "writePageInfo", "readFileInfo", "readfileInfo", "writeContenttype", "writeFiletype", "writePagetype", "writePageName"], "uriFile": ["iriFile", "rangeData", "uriData", "filenameFile", "urifile", "uriFiles", "filefile", "uriFilename", "rangefile", "fileFiles", "fileFile", "filenameFiles", "filenameFilename", "fileFilename", "URIfile", "uriFILE", "rangeFile", "irifile", "iriData", "filenamefile", "URIFILE", "iriFILE", "URIFiles", "URIData", "URIFile", "rangeFILE", "URIFilename"], "outputfile": ["inputbase", "Outputfile", "OutputFILE", "imageFile", "outFile", "Outputport", "inputFILE", "inputfile", "outputbase", "imageport", " outputbase", "outputport", "outputFILE", "outf", "outfile", "inputport", "OutputFile", "outputFile", "outputf", "inputFile", "outbase", "imagefile", " outputFile", "inputf", " outputf", "imageFILE"], "num": ["np", "count", "um", "max", "current", "multi", "nom", "total", "mult", "add", "alph", "x", "no", "index", "zero", "check", "end", "n", "Number", "NUM", "all", "Num", "number", "required", "nb", "con", "done", "random", "m", "nm", "cmp", "nam", "mon"], "writer": ["memory", "director", "wire", "data", "layer", "author", "ner", "driver", "riter", "term", "maker", "processor", "writ", "service", "writers", "editor", "RW", "written", "read", "worker", "ener", "server", "external", "file", "liner", "inner", "loader", "timer", "creator", "client", "writing", "builder", "caster", "Writer", "wright", "event", "record", "link", "entry", "function", "window", "ender", "buffer", "write", "commit", "stream", "comment", "document", "Reader", "storage", "player", "operator", "er", "journal", "wrapper", "network", "thus", "handler", "to", "resource", "owner", "table", "utils", "linger", "widget", "manager", "connection", "usher", "test", "flush", "console", "will", "format", "variable", "width", "w", "runner", "iterator"], "uri": ["du", "location", "obo", "doi", "qu", "uno", "origin", "uni", "hi", "browser", "reference", "ource", "address", "ni", "href", "directory", "URI", "ei", "basic", "via", "ir", "subject", "bid", "remote", "rid", "details", "multi", "file", "username", "inner", "prefix", "pi", "uu", "iterator", "iri", "qi", "link", "filename", "hyper", "unit", "copy", "range", "uid", "id", "user", "mi", "umi", "phrase", "image", "wiki", "https", "ref", " URI", "channel", "query", "resource", "source", "ip", "general", "phi", "connection", "ui", "result", "queue", "chain", "ur", "folder", "description", "http", "ugi", "verb", "domain", "i", "ri", "form", "sofar"], "counter": ["ctr", "count", "memory", "buffer", "manager", "frequency", "instance", "clock", "mill", "mr", "nr", "TER", "order", "book", "scope", "controller", "total", "ounter", "card", "currency", "const", "inner", "phrase", "Counter", "continue", "timer", "common", "loader", "machine", "creator", "browser", "mer", "pointer", "ier", "index", "time", "term", "outer", "conv", "cover", "loop", "amount", "coll", "processor", "another", "cookie", "norm", "number", "finder", "container", "meter", "sequence", "context", "message", "walker", "entry", "random", "editor", "cms", "ter", "money", "key", "system", "iterator"], "reader": ["yer", "read", "buffer", "method", "rl", "rx", "server", "file", "layer", "liner", "document", "inner", "loader", "dd", "Reader", "ro", "iter", "timer", "parser", "older", "ner", "r", "driver", "player", "input", "upper", "rar", "address", "iterator", "er", "builder", "journal", "processor", "redo", "row", "roller", "context", "runner", "entry", "handler", "resource", "editor"], "url": ["dl", "li", "location", "build", "re", "nl", "mount", "str", "base", "loc", "l", "gl", "web", "google", "il", "https", "r", "client", "browser", "ssl", "www", "open", "mail", "ref", "sl", "address", "name", "bel", "ur", "get", "github", "http", "hl", "ll", "link", "rel", "URL", "char", "resource", "Url"], "myConnection": ["thisConnection", "myConn", "myconnection", "myLink", "newLink", "Myconnection", "MyLink", "MyConnection", " myConnector", "MyConnector", "newConnection", "yourConnector", "yourConnection", "myConnect", "thisConn", " myconnection", "newConn", " myConn", "thisLink", "thisConnect", " myConnect", "newConnect", "yourconnection", "myConnector", "yourLink", " myLink"], "myReader": ["myFr", "myWriter", " myParser", "MyWriter", "mxSer", "yourReader", " mySer", " myFr", "myParser", "mySer", "yFr", "MyRead", "mxReader", "yourParser", "myRead", "yWriter", "yourWriter", "MyParser", "yReader", "mxFr", " myRead", "ySer", " myWriter", "yourRead", "MyReader", "mxWriter"], "line": ["ip", "text", "le", "detail", "lin", "lane", "inline", "range", "point", "part", "user", "comment", " Line", "log", "raw", "ode", "liner", "LINE", "l", " LINE", "ln", "trace", "cell", "body", "ge", "Line", "eline", "iter", "lo", "normal", "stroke", "definition", "cli", "ole", "no", "email", "rule", "ine", "side", "online", "frame", "channel", "row", "edge", "one", "link", "sample", "block", "sequence", "message", "char", "entry", "label", "style", "code", "word", "page"], "linecount": ["linnumber", " lineCount", "strokenumber", "elinecounter", "linconsider", " linenumber", "Linecount", "lineconsider", " lineconst", "Linefound", "linefound", "inlineconst", "linelength", "lineamount", "linercount", "LineCount", "lincount", "Lineconfig", "elinecount", "elineconst", " lineconfig", "inlinecount", "linecounter", "linerconfig", "strokeconsider", "lineconfig", " linecounter", "linenumber", "inlinelength", "linerCount", "linerfound", "inlinecounter", " lineconsider", " linefound", "lineconst", "lineCount", " linelength", " lineamount", "strokecount", "elinelength", "linamount", "strokeamount"], "hasOWL": ["hasOWLP", "hasOWNLP", " hasEWLP", "hasOWB", " hasOWSLP", " hasEWLS", " hasOWNL", "hasSOLS", " hasOWLP", "hasEWR", "hasOWSR", " hasOWSR", "hasEWL", "hasOWSB", "hasOWSS", "HasOWS", "hasEWLP", "hasOWSL", "HasOWSB", "hasROL", "hasEWS", "HasOWSLP", "hasOHS", "hasOHL", "hasSOR", " hasEWR", "hasEWB", " hasOWSNL", "hasOWNL", " hasOWR", " hasEWL", "hasRONL", "hasOWS", "HasOWL", "HasOWB", "hasOWSNL", "hasOWNNL", "hasOWSLP", "hasEWLS", "hasOHLP", " hasOWLS", "hasOWR", "hasROLP", "hasOWSLS", "hasOWNR", "HasOWSS", "hasOWLS", "HasOWSL", "hasOHB", "hasSOLP", " hasOWSL", "HasOWLP", "hasROR", "hasSOL"], "hasRDFS": ["hasRDFM", "hasXDSDS", "hasRDSCS", "hasRdfs", "hasRRIs", "hasORDFM", "hasXDFM", "hasXDSM", "hasORDSS", "hasRDFB", "hasORDFS", "hasRMLS", "hasRdfS", "hasRdfB", "hasSRDFB", "hasSRDSS", "hasRDFs", "hasRNFs", "hasXDFS", "hasSRDFS", "hasXDSS", "hasRNFDS", "hasXDSs", "hasSRDSB", "hasSRDFCS", "hasRDSB", "hasRDSM", "hasRNFS", "hasRDSS", "hasRRICS", "hasORDFs", "hasRMLs", "hasRNFM", "hasRdfM", "hasORDSs", "hasRdfCS", "hasRDFDS", "hasORDSM", "hasRMLDS", "hasXDFDS", "hasSRDFs", "hasRdfDS", "hasRDSs", "hasRRIS", "hasSRDSs", "hasRMLM", "hasSRDSCS", "hasXDFs", "hasRRIB", "hasORDSDS", "hasRDSDS", "hasORDFDS", "hasRDFCS"], "hasRDF": ["hasRCCD", " hasRDR", " hasDdf", "hsRDT", "hasRDS", "hasRDI", "hasREDI", "hasREDT", "hsRDF", " hasRRDF", "hasRRDS", "hasRTNF", " hasRRDR", " hasRCD", "hasRRCD", " hasRRDS", "hsRRDF", "hasRADS", "hasRRdf", " hasDDF", "hsRDS", "hasRRDR", "hasORDF", "hasRdf", "hasRRDT", "hasRNF", "hasRTDS", "hasRCDF", "hasRCD", "hasRDR", " hasDNF", "hasRRDI", "hasREDF", " hasRRNF", " hasRDS", "hasDCD", "hasRTDR", "hasRADT", "hasDdf", "hsRRDS", "hasRADF", "hasORNF", "hsRDI", "hsRRDT", " hasRdf", " hasDCD", "hasRADI", "hasRRDF", "hasDDF", "hasRCNF", "hasORDS", "hasRDT", "hasDNF", "hasORDR", "hasRRNF", "hasRTDF", "hasRCdf", "hsRRDI", "hasREDS", " hasRNF"]}}
{"id1": "5808579", "id2": "23035537", "code1": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "code2": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptedString", "decryptedLogin", "encryptedPass", "decryptPassword", "encryptedLogin", "encryptLogin", "encryptString", "encrollString", "encryptedPassword", "encrollLogin", "enccryptLogin", "enccryptString", "decryptLogin", "decryptedPassword", "encrollPass", "decryptedPass", "enccryptPass", "decryptString", "decryptedString", "decryptPass", "enccryptPassword", "encrollPassword", "encryptPass"], "loginName": [" loginname", " loginCode", "blogN", "LoginTime", "blogName", "usernameCode", "usernameName", " loginType", "cellName", "usernameTime", "LoginName", "cellTime", " loginN", "loginTime", "cellType", "cellname", "loginType", "LoginType", "Loginname", "usernameN", "blogTime", "blogCode", "loginname", " loginTime", "loginN", "loginCode"], "password": ["confirmed", "content", "text", "encrypted", "padding", "secret", "PASS", "default", "user", "comment", "attribute", "username", "phrase", "prefix", "expression", "result", "picture", "sword", "session", "string", "pattern", "path", "database", "email", "address", "name", "command", "pass", "p", "paste", "another", "description", "token", "hello", "value", "past", "response", "message", "argument", "reset", "last", "word", "Password"], "md5": [" md3", "red8", " Md5", "md6", " md1", "sha2", "md1", "sha7", " md53", "MD7", " Md53", "red5", " Md2", "MD8", " MD6", " MD3", "MD53", "md53", "MD3", "md3", " md6", "red2", "md7", " MD2", " md8", " md2", " MD5", "sha5", "MD1", " md7", "MD2", "sha1", " Md3", "MD5", "red3", "md8", "MD6", "md2"], "ba": ["CA", "ja", "bd", "pa", "ena", "bi", "bee", "abc", "ka", "va", "Ba", "fa", "bas", "bre", "ya", "b", "aa", "bc", "da", "BA", "tta", "sa", "oa", "sta", "ga", "aba", "ha", "a", "aka", "ao", "ada", "pha", "cca", "beta", "bo", "xa", "aaa", "ta", "ca", "bu", "bb"]}}
{"id1": "1421557", "id2": "9449064", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFile", "encodeStringToFile", "encodeStringAsFiles", "encodeStringAsStream", "encodeStringToFiles", "encodeStringAsDisk", "encodeFiletoDisk", "encodeFileAsStream", "encodeFileToStream", "encodeFiletoFiles", "encodeFileAsDisk", "encodeFileAsFiles", "encodeStringToStream", "encodeFileFromDisk", "encodeFileFromFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeFileToFiles", "encodeFileFromFile", "encodeFileFromStream", "encodeStringToDisk", "encodeFiletoStream", "encodeStringAsFile"], "infile": ["outFile", " inFile", "inputpath", "inputfile", "inputfilename", "InFile", "outfilename", "outpath", " inpath", "Infile", "inpath", " inbase", " infilename", "inbase", "inputFile", "infilename", "outbase", "inFile", "Inbase", "Inpath"], "outfile": ["outname", " outfilename", "tofile", "outFile", "tofp", "fromdir", "outfp", "newfilename", "fromfile", "outfilename", "toFile", "infp", "newFile", " outFile", " outname", "outdir", "infilename", "newname", "inname", "inFile", "fromfp", "indir", "fromFile", "newfile", "todir"], "in": ["t", "bin", "din", "conn", " din", "or", "re", "id", "inc", "isin", "rin", "ind", "en", "inner", "image", "inf", "ain", "ro", "iter", "inside", "im", "form", "is", "input", "pin", "nin", "al", "up", "In", "on", "get", "gin", "per", "init", "info", "ini", "IN", "con", "it", "amin", "from", "ins", "ar", "inn", "cin", "i", "source", "oin", "by"], "out": ["t", "io", "can", "write", "ne", "os", "OU", "file", "en", "print", "inner", "b", "at", "flush", "ot", "gt", "sys", "oss", "opt", "res", "end", "nt", "up", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "ex", "null", "to", "g", "ion", "writer", "ou", "fn", "aos", "OUT", "outer"], "buffer": ["history", "memory", "binary", "Buffer", "padding", "view", "stack", "black", "pad", "buff", "base", "column", "comment", "length", "total", "attribute", "batch", "available", "document", "phrase", "print", "temp", "button", "bar", "queue", "library", "cache", "command", "note", "mem", "variable", "buf", "password", "bone", "paste", "frame", "info", "number", "character", "template", "row", "sample", "sequence", "block", "message", "append", "display", "initial", "table", "window", "header"], "read": ["text", "count", "ok", "reader", "write", "close", "READ", "range", "each", "run", "need", "stream", "length", "select", "ind", "raw", "print", "add", "before", "give", "iter", "allow", " Read", "input", "index", "check", "open", "hold", "end", "n", "req", "start", "get", "send", "len", "load", "find", "first", "set", "Read", "query", "size", "reading", "reads", "seek", "readable", "wait", "i", "through", "connect", "skip", "push", "ready"], "success": ["growth", "surv", "submit", "ok", "same", "photo", " succ", "status", "commit", "successfully", "release", "democracy", "positive", " successes", "please", "complete", "ccess", "continue", "result", " successful", "snap", " okay", " failure", "Success", "sufficient", "ceed", "ratulations", "primary", "successful", "setup", "cess", " Success", "accept", "city", "warning", "safe", "danger", "first", "value", "unity", "ith", "crit", "response", "town", "valid", "condition", "done", "second", "support", "fail", "good", "error", "summary"]}}
{"id1": "17791385", "id2": "494226", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyfile", "cloneFiles", " cpfile", "cloneFile", " copyResource", "cloneResource", " cpResource", " copyFiles", " cpFile", " cpFiles", "clonefile", "copyResource"], "src": ["sb", "ctr", "sr", "ipl", "sc", "rl", "bs", "sin", "rx", "usr", "sit", "sq", "ck", "sys", "usc", "input", "ux", "ys", "rc", "sur", "req", "start", "Source", "iv", "init", "sec", "cur", "rs", "via", "rel", "st", "from", "obs", "ins", "sel", "sf", "inst", "cont", "ser", "source", "txt"], "dst": ["dth", "wth", "ddest", " dth", "Dth", "Dnd", "dnt", "ddst", "dnd", "snt", " dnd", "ddnd", "snd", "sst", "Dnt", " ddest", "ddnt", "Dst", "sdest", "dddest", "wdest", "Ddest", "wst", "wnd"], "in": ["bin", "din", "min", "inc", "isin", "rin", "ind", "en", "inner", "ze", "ln", "inf", "ain", "inside", "iter", "im", "source", "is", "input", "al", "up", "In", "on", "gin", "init", "info", "IN", "con", "it", "st", "from", "ar", "ins", "rec", "inn", "cin", "ai", "act", "mm", "i", "ic", "sin", "oin"], "out": ["t", "io", "dis", "can", "write", "OUT", "bin", "oe", "po", "ne", "os", "auto", "inner", "at", "ot", "gt", "sys", "client", "oss", "res", "obj", "nt", "up", "conv", "n", "on", "co", "o", "net", "con", "cn", "outs", "it", "output", "Out", "sum", "ex", "st", "to", "g", "writer", "ou", "aos", "by", "outer", "and"], "buf": ["cv", "Buffer", "stab", "buffer", "bh", "arr", "bed", "buff", "Buff", "fb", "prop", "log", "batch", "norm", "b", "bus", "cf", "vec", "ck", "bar", "cp", "cmd", "uf", "cb", "br", "good", "conv", "var", "bag", "aka", "seq", "pkg", "pl", "cur", "gen", "cam", "block", "cap", "cat", "tx", "bytes", "tab", "mu", "msg", "box", "db"], "len": ["compl", "t", "dl", "count", "le", "v", "lon", "lib", "str", "L", "length", "el", "pos", "en", "loc", "l", "wid", "ln", "e", "il", "lan", "lf", "no", "ls", "elt", "end", "nt", "n", "exp", "coll", "seq", "all", "val", "ld", "ll", "fin", "size", "num", "vol", "fun", "lic", "fl", "cap", "rel", "z", "lim", "h", "cmp", "Len", "ren"]}}
